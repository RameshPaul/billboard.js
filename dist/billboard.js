(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-axis", "d3-brush", "d3-scale", "d3-dsv", "d3-drag", "d3-shape", "d3-interpolate", "d3-color", "d3-zoom", "d3-ease"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__, __WEBPACK_EXTERNAL_MODULE__50__, __WEBPACK_EXTERNAL_MODULE__51__, __WEBPACK_EXTERNAL_MODULE__52__, __WEBPACK_EXTERNAL_MODULE__53__, __WEBPACK_EXTERNAL_MODULE__54__, __WEBPACK_EXTERNAL_MODULE__55__, __WEBPACK_EXTERNAL_MODULE__56__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(62);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(2);

var socket = __webpack_require__(4);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost"))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(3)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/

var Client = __webpack_dev_server_client__;
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(5)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(6);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);
    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(5);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.3.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var Entities = __webpack_require__(11).AllHtmlEntities;

var entities = new Entities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We're already creating it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
}

function showMessageOverlay(message) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(message)));
  });
}

function destroyErrorOverlay() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Successful compilation.


exports.clear = function handleSuccess() {
  destroyErrorOverlay();
}; // Compilation with errors (e.g. syntax error or missing modules).


exports.showMessage = function handleMessage(messages) {
  showMessageOverlay(messages[0]);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(12),
  Html4Entities: __webpack_require__(13),
  Html5Entities: __webpack_require__(14),
  AllHtmlEntities: __webpack_require__(14)
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...'); // eslint-disable-next-line global-require

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var querystring = __webpack_require__(26);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    urlParts = url.parse(resourceQuery.substr(1));
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape

    scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
    urlParts = url.parse(scriptHost || '/', false, true);
  }

  if (!urlParts.port || urlParts.port === '0') {
    urlParts.port = self.location.port;
  }

  var _urlParts = urlParts,
      auth = _urlParts.auth,
      path = _urlParts.path;
  var _urlParts2 = urlParts,
      hostname = _urlParts2.hostname,
      protocol = _urlParts2.protocol; // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  if ((hostname === '0.0.0.0' || hostname === '::') && self.location.hostname && // eslint-disable-next-line no-bitwise
  !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = self.location.protocol;
  } // default values of the sock url if they are not provided


  var sockHost = hostname;
  var sockPath = '/sockjs-node';
  var sockPort = urlParts.port; // eslint-disable-next-line no-undefined

  if (path !== null && path !== undefined && path !== '/') {
    var parsedQuery = querystring.parse(path); // all of these sock url params are optionally passed in through
    // resourceQuery, so we need to fall back to the default if
    // they are not provided

    sockHost = parsedQuery.sockHost || sockHost;
    sockPath = parsedQuery.sockPath || sockPath;
    sockPort = parsedQuery.sockPort || sockPort;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module), __webpack_require__(7)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(34);

var iterableToArrayLimit = __webpack_require__(35);

var nonIterableRest = __webpack_require__(36);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(43);

var iterableToArray = __webpack_require__(44);

var nonIterableSpread = __webpack_require__(45);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return doc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */
var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    doc = win && win.document,
    isMobile = win.navigator && win.navigator.userAgent && win.navigator.userAgent.indexOf("Mobi") > -1 || !1;
/* eslint-enable no-new-func, no-undef */



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__50__;

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__51__;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__52__;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__53__;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__54__;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__55__;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__56__;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(58);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(60)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(59)(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px GothamPro;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  fill: #5D5C71; }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px GothamPro; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: none; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n\nh2#title {\n  font-size: 16px;\n  text-transform: \"uppercase\"; }\n", ""]);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(61);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 61 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(32);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(33);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(37);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(38);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(39);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(40);

// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/config/classes.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_"
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(42);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(46);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/internals/util.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof_default()(v) === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return arr && arr.constructor === Array;
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
},
    getOption = function (options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
},
    util_hasValue = function (dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
},
    callFn = function (fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
},
    sanitise = function (str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
},
    setTextValue = function (node, text) {
  var dy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-1, 1];
  if (node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"); // reset possible text

      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", "".concat(i === 0 ? dy[0] : dy[1], "em")).text(v);
      });
    }
  }
},
    getRectSegList = function (path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height // seg3

  }];
},
    getPathBox = function (path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
},
    getBrushSelection = function (ctx) {
  var selection = null,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = ctx.context || ctx.main;
  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select(".".concat(config_classes.brush)).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
},
    getRandom = function () {
  var asStr = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
  return Math.random() + (asStr ? "" : 0);
},
    brushEmpty = function (ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
},
    extend = function () {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      source = arguments.length > 1 ? arguments[1] : undefined;

  for (var p in source) target[p] = source[p];

  return target;
},
    capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
},
    getCssRules = function (styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from ".concat(sheet.href, ": ").concat(e.toString()));
    }
  }), rules;
},
    getUnique = function (data) {
  return data.filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
},
    mergeArray = function (arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
},
    mergeObj = function (_mergeObj) {
  function mergeObj() {
    return _mergeObj.apply(this, arguments);
  }

  return mergeObj.toString = function () {
    return _mergeObj.toString();
  }, mergeObj;
}(function (target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}),
    sortValue = function (data) {
  var fn,
      isAsc = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && data.every(Number) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
},
    getMinMax = function (type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, toConsumableArray_default()(res)) : res[0] instanceof Date && (res = sortValue(res, type === "min")[0]) : res = undefined, res;
},
    getRange = function (start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
},
    sendStats = function () {
  if (navigator && localStorage) {
    var url = "https://www.google-analytics.com/collect?v=1&tid=UA-141911582-1&cid=555&t=pageview&dp=%2F".concat(location ? location.hostname : ""),
        t = +new Date(),
        last = +localStorage.getItem("$bb.stats"),
        expire = 1209600000;
    if (!last || last + expire < t) if (localStorage.setItem("$bb.stats", t + expire), navigator.sendBeacon) navigator.sendBeacon(url);else {
      var i = new Image();
      i.src = url, i.style.display = "none", document.body.appendChild(i), document.body.removeChild(i);
    }
  }
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams();
        el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams(),
            mouseEvent = document.createEvent("MouseEvent");
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(Object.assign({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
},
    tplProcess = function (tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=".concat(x, "}"), "g"), data[x]);

  return res;
};


// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/axis/AxisRendererHelper.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(config, params) {
    classCallCheck_default()(this, AxisRendererHelper);

    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])();
    this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = scale.rangeExtent ? scale.rangeExtent() : this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  return createClass_default()(AxisRendererHelper, [{
    key: "axisX",
    value: function axisX(selection, x) {
      var _this = this;

      selection.attr("transform", function (d) {
        return "translate(".concat(Math.ceil(x(d) + _this.config.tickOffset), ",0)");
      });
    }
  }, {
    key: "axisY",
    value: function axisY(selection, y) {
      selection.attr("transform", function (d) {
        return "translate(0,".concat(Math.ceil(y(d)), ")");
      });
    }
  }, {
    key: "scaleExtent",
    value: function scaleExtent(domain) {
      var start = domain[0],
          stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
    }
  }, {
    key: "generateTicks",
    value: function generateTicks(scale) {
      var ticks = [];
      if (scale.ticks) return scale.ticks.apply(scale, toConsumableArray_default()(this.config.tickArguments || [])).map(function (v) {
        return (// round the tick value if is number
          isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
        );
      });

      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      return ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0])), ticks;
    }
  }, {
    key: "copyScale",
    value: function copyScale() {
      var newScale = this.scale.copy();
      return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
    }
  }, {
    key: "textFormatted",
    value: function textFormatted(v) {
      var tickFormat = this.config.tickFormat,
          value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
          formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
      // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
      // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

      return isDefined(formatted) ? formatted : "";
    }
  }, {
    key: "transitionise",
    value: function transitionise(selection) {
      var config = this.config;
      return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
    }
  }], [{
    key: "getSizeFor1Char",
    value: function getSizeFor1Char(node) {
      // default size for one character
      var size = {
        w: 5.5,
        h: 11.5
      };
      return node.empty() || node.select("text").text("0").call(function (el) {
        try {
          var _el$node$getBBox = el.node().getBBox(),
              width = _el$node$getBBox.width,
              height = _el$node$getBBox.height;

          width && height && (size.w = width, size.h = height), el.text("");
        } catch (e) {}
      }), this.getSizeFor1Char = function () {
        return size;
      }, size;
    }
  }]), AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/axis/AxisRenderer.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AxisRenderer);

    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.helper = new AxisRendererHelper_AxisRendererHelper(config, params), this.config = config, this.params = params;
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  return createClass_default()(AxisRenderer, [{
    key: "create",
    value: function create(g) {
      var ctx = this,
          config = this.config,
          params = this.params,
          helperInst = this.helper,
          scale = helperInst.scale,
          orient = config.orient,
          splitTickText = this.splitTickText.bind(this),
          isLeftRight = /^(left|right)$/.test(orient),
          isTopBottom = /^(top|bottom)$/.test(orient),
          tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
          axisPx = tickTransform === helperInst.axisX ? "y" : "x",
          sign = /^(top|left)$/.test(orient) ? -1 : 1,
          rotate = params.tickTextRotate;
      this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
      var _config = config,
          innerTickSize = _config.innerTickSize,
          tickLength = _config.tickLength,
          range = _config.range,
          name = params.name,
          tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_".concat(name, "_tick_text_position")] : {
        x: 0,
        y: 0
      },
          prefix = name === "subX" ? "subchart_axis_x" : "axis_".concat(name),
          axisShow = params.config["".concat(prefix, "_show")],
          tickShow = {
        tick: !!axisShow && params.config["".concat(prefix, "_tick_show")],
        text: !!axisShow && params.config["".concat(prefix, "_tick_text_show")]
      },
          $g = null; // // get the axis' tick position configuration

      g.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            scale0 = this.__chart__ || scale,
            scale1 = helperInst.copyScale();
        $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
        // update selection - data join
        var path = g.selectAll(".domain").data([0]); // enter + update selection

        if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
          var outerTickSized = config.outerTickSize * sign;
          return isTopBottom ? "M".concat(range[0], ",").concat(outerTickSized, "V0H").concat(range[1], "V").concat(outerTickSized) : "M".concat(outerTickSized, ",").concat(range[0], "H0V").concat(range[1], "H").concat(outerTickSized);
        }), tickShow.tick || tickShow.text) {
          // count of tick data in array
          var ticks = config.tickValues || helperInst.generateTicks(scale1),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
              tickExit = tick.exit().remove(); // update selection

          tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
          var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
              counts = [],
              tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
            var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
            return counts[index] = split.length, split.map(function (splitted) {
              return {
                index: index,
                splitted: splitted
              };
            });
          });
          tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
            return d.splitted;
          }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
            var dx = 0;
            return orient === "bottom" && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180))), dx + (tickTextPos.x || 0);
          }()).attr("dy", function (d, i) {
            var dy = 0;
            return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
          });
          var lineUpdate = tick.select("line"),
              textUpdate = tick.select("text");

          if (tickEnter.select("line").attr("".concat(axisPx, "2"), innerTickSize * sign), tickEnter.select("text").attr("".concat(axisPx), tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
            Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
          }), scale1.bandwidth) {
            var x = scale1,
                dx = x.bandwidth() / 2;
            scale0 = function (d) {
              return x(d) + dx;
            }, scale1 = scale0;
          } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

          tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
        }
      }), this.g = $g;
    }
    /**
     * Get tick x/y coordinate
     * @return {{x: number, y: number}}
     * @private
     */

  }, {
    key: "getTickXY",
    value: function getTickXY() {
      var config = this.config,
          pos = {
        x: 0,
        y: 0
      };
      return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
    }
    /**
     * Get tick size
     * @param d
     * @return {number}
     * @private
     */

  }, {
    key: "getTickSize",
    value: function getTickSize(d) {
      var scale = this.helper.scale,
          config = this.config,
          innerTickSize = config.innerTickSize,
          range = config.range,
          tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
      return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
    }
    /**
     * Set tick's line & text position
     * @param lineUpdate
     * @param textUpdate
     * @param scale
     * @private
     */

  }, {
    key: "setTickLineTextPosition",
    value: function setTickLineTextPosition(lineUpdate, textUpdate) {
      var tickPos = this.getTickXY(),
          _this$config = this.config,
          innerTickSize = _this$config.innerTickSize,
          orient = _this$config.orient,
          tickLength = _this$config.tickLength,
          tickOffset = _this$config.tickOffset,
          rotate = this.params.tickTextRotate;
      orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", function yForText(r) {
        return r ? 11.5 - 2.5 * (r / 15) * (r > 0 ? 1 : -1) : tickLength;
      }(rotate)).style("text-anchor", function textAnchorForText(r) {
        return r ? r > 0 ? "start" : "end" : "middle";
      }(rotate)).attr("transform", function textTransform(r) {
        return r ? "rotate(".concat(r, ")") : null;
      }(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -tickLength * 2).style("text-anchor", "middle")) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
    } // this should be called only when category axis

  }, {
    key: "splitTickText",
    value: function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
      function split(splitted, text) {
        for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
        if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

        return splitted.concat(text);
      }

      var params = this.params,
          tickText = this.helper.textFormatted(d),
          splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
      if (splitted.length) return splitted;
      if (isArray(tickText)) return tickText;
      var tickWidth = params.tickWidth;
      return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
    }
  }, {
    key: "scale",
    value: function scale(x) {
      return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
    }
  }, {
    key: "orient",
    value: function orient(x) {
      return arguments.length ? (this.config.orient = x in {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      } ? x + "" : "bottom", this) : this.config.orient;
    }
  }, {
    key: "tickFormat",
    value: function tickFormat(format) {
      return arguments.length ? (this.config.tickFormat = format, this) : this.config.tickFormat;
    }
  }, {
    key: "tickCentered",
    value: function tickCentered(isCentered) {
      var config = this.config;
      return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
    }
    /**
     * Return tick's offset value.
     * The value will be set for 'category' axis type.
     * @return {number}
     * @private
     */

  }, {
    key: "tickOffset",
    value: function tickOffset() {
      return this.config.tickOffset;
    }
    /**
     * Get tick interval count
     * @private
     * @param {Number} size Total data size
     * @return {number}
     */

  }, {
    key: "tickInterval",
    value: function tickInterval(size) {
      var interval;
      if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
        var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
        interval = length / (size || this.g.selectAll("line").size());
      }
      return interval === Infinity ? 0 : interval;
    }
  }, {
    key: "ticks",
    value: function ticks() {
      for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
    }
  }, {
    key: "tickCulling",
    value: function tickCulling(culling) {
      var config = this.config;
      return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
    }
  }, {
    key: "tickValues",
    value: function tickValues(x) {
      var _this = this,
          config = this.config;

      if (isFunction(x)) config.tickValues = function () {
        return x(_this.helper.scale.domain());
      };else {
        if (!arguments.length) return config.tickValues;
        config.tickValues = x;
      }
      return this;
    }
  }, {
    key: "setTransition",
    value: function setTransition(t) {
      return this.config.transition = t, this;
    }
  }]), AxisRenderer;
}();


// CONCATENATED MODULE: ./src/axis/Axis.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var isHorizontal = function ($$, forHorizontal) {
  var isRotated = $$.config.axis_rotated;
  return forHorizontal ? isRotated : !isRotated;
},
    getAxisClassName = function (id) {
  return "".concat(config_classes.axis, " ").concat(config_classes["axis".concat(capitalize(id))]);
};

var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    classCallCheck_default()(this, Axis), this.owner = owner, this.setOrient();
  }

  return createClass_default()(Axis, [{
    key: "init",
    value: function init() {
      var _this = this,
          $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          main = $$.main,
          target = ["x", "y"];

      config.axis_y2_show && target.push("y2"), $$.axesList = {}, target.forEach(function (v) {
        var classAxis = getAxisClassName(v),
            classLabel = config_classes["axis".concat(capitalize(v), "Label")];
        $$.axes[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
          var res = null;
          return v === "x" ? res = $$.clipPathForXAxis : v === "y" && config.axis_y_inner && (res = $$.clipPathForYAxis), res;
        }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_".concat(v, "_show")] ? "visible" : "hidden"), $$.axes[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this.textAnchorForXAxisLabel.bind(_this)), _this.generateAxes(v);
      });
    }
    /**
     * Set axis orient according option value
     * @private
     */

  }, {
    key: "setOrient",
    value: function setOrient() {
      var $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          yInner = config.axis_y_inner,
          y2Inner = config.axis_y2_inner;
      $$.xOrient = isRotated ? "left" : "bottom", $$.yOrient = isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left", $$.y2Orient = isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right", $$.subXOrient = isRotated ? "left" : "bottom";
    }
    /**
     * Generate axes
     * It's used when axis' axes option is set
     * @param {String} id Axis id
     * @private
     */

  }, {
    key: "generateAxes",
    value: function generateAxes(id) {
      var d3Axis,
          $$ = this.owner,
          config = $$.config,
          axes = [],
          axesConfig = config["axis_".concat(id, "_axes")],
          isRotated = config.axis_rotated;
      id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
        var tick = v.tick;
        axes.push(d3Axis($$[id]).ticks(tick.count).tickFormat(tick.format || function (x) {
          return x;
        }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
      }), $$.axesList[id] = axes;
    }
    /**
     * Update axes nodes
     * @private
     */

  }, {
    key: "updateAxes",
    value: function updateAxes() {
      var $$ = this.owner,
          config = $$.config;
      Object.keys($$.axesList).forEach(function (id) {
        var range = $$[id].range();
        $$.axesList[id].forEach(function (v, i) {
          var axisRange = v.scale().range(); // adjust range value with the current
          // https://github.com/naver/billboard.js/issues/859

          range.every(function (v, i) {
            return v === axisRange[i];
          }) || v.scale().range(range);
          var className = "".concat(getAxisClassName(id), "-").concat(i + 1),
              g = $$.main.select(".".concat(className.replace(/\s/, ".")));
          g.empty() ? g = $$.main.append("g").attr("class", className).style("visibility", config["axis_".concat(id, "_show")] ? "visible" : "hidden").call(v) : $$.xAxis.helper.transitionise(g).call(v.scale($$[id])), g.attr("transform", $$.getTranslate(id, i + 1));
        });
      });
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getXAxis",
    value: function getXAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          isCategory = $$.isCategorized(),
          orient = $$["".concat(name, "Orient")],
          tickFormat = $$.xAxisTickFormat,
          tickValues = $$.xAxisTickValues,
          axisParams = {
        isCategory: isCategory,
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickMultiline: config.axis_x_tick_multiline,
        tickWidth: config.axis_x_tick_width,
        tickTextRotate: noTickTextRotate ? 0 : config.axis_x_tick_rotate,
        tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
        orgXScale: $$.x
      },
          axis = new AxisRenderer_AxisRenderer(axisParams).scale($$.zoomScale || scale).orient(orient),
          newTickValues = tickValues;
      return $$.isTimeSeries() && tickValues && !isFunction(tickValues) && (newTickValues = tickValues.map(function (v) {
        return $$.parseDate(v);
      })), axis.tickFormat(tickFormat).tickValues(newTickValues), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config.axis_x_tick_count && axis.ticks(config.axis_x_tick_count), axis;
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getYAxis",
    value: function getYAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          orient = $$["".concat(name, "Orient")],
          tickFormat = config["axis_".concat(name, "_tick_format")],
          tickValues = $$["".concat(name, "AxisTickValues")],
          axisParams = {
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickTextRotate: noTickTextRotate ? 0 : config.axis_y_tick_rotate
      },
          axis = new AxisRenderer_AxisRenderer(axisParams).scale(scale).orient(orient).tickFormat(tickFormat || $$.isStackNormalized() && function (x) {
        return "".concat(x, "%");
      });
      return $$.isTimeSeriesY() ? // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
      axis.ticks(config.axis_y_tick_time_value) : axis.tickValues(tickValues), axis;
    }
  }, {
    key: "updateXAxisTickValues",
    value: function updateXAxisTickValues(targets, axis) {
      var values,
          $$ = this.owner,
          config = $$.config,
          fit = config.axis_x_tick_fit,
          count = config.axis_x_tick_count;
      return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.xAxis && ($$.xAxis.tickValues(values), $$.subXAxis.tickValues(values)), values;
    }
  }, {
    key: "getId",
    value: function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : "y";
    }
  }, {
    key: "getXAxisTickFormat",
    value: function getXAxisTickFormat() {
      var format,
          $$ = this.owner,
          config = $$.config,
          tickFormat = config.axis_x_tick_format,
          isTimeSeries = $$.isTimeSeries(),
          isCategorized = $$.isCategorized();
      return tickFormat ? isFunction(tickFormat) ? format = tickFormat : isTimeSeries && (format = function (date) {
        return date ? $$.axisTimeFormat(tickFormat)(date) : "";
      }) : format = isTimeSeries ? $$.defaultAxisTimeFormat : isCategorized ? $$.categoryName : function (v) {
        return v < 0 ? v.toFixed(0) : v;
      }, isFunction(format) ? function (v) {
        return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
      } : format;
    }
  }, {
    key: "getTickValues",
    value: function getTickValues(id) {
      var $$ = this.owner,
          tickValues = $$.config["axis_".concat(id, "_tick_values")],
          axis = $$["".concat(id, "Axis")];
      return tickValues || (axis ? axis.tickValues() : undefined);
    }
  }, {
    key: "getXAxisTickValues",
    value: function getXAxisTickValues() {
      return this.getTickValues("x");
    }
  }, {
    key: "getYAxisTickValues",
    value: function getYAxisTickValues() {
      return this.getTickValues("y");
    }
  }, {
    key: "getY2AxisTickValues",
    value: function getY2AxisTickValues() {
      return this.getTickValues("y2");
    }
  }, {
    key: "getLabelOptionByAxisId",
    value: function getLabelOptionByAxisId(id) {
      return this.owner.config["axis_".concat(id, "_label")];
    }
  }, {
    key: "getLabelText",
    value: function getLabelText(id) {
      var option = this.getLabelOptionByAxisId(id);
      return isString(option) ? option : option ? option.text : null;
    }
  }, {
    key: "setLabelText",
    value: function setLabelText(id, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(id);
      isString(option) ? config["axis_".concat(id, "_label")] = text : option && (option.text = text);
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(id, defaultPosition) {
      var isRotated = this.owner.config.axis_rotated,
          option = this.getLabelOptionByAxisId(id),
          position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
          has = function (v) {
        return !!~position.indexOf(v);
      };

      return {
        isInner: has("inner"),
        isOuter: has("outer"),
        isLeft: has("left"),
        isCenter: has("center"),
        isRight: has("right"),
        isTop: has("top"),
        isMiddle: has("middle"),
        isBottom: has("bottom")
      };
    }
  }, {
    key: "getXAxisLabelPosition",
    value: function getXAxisLabelPosition() {
      return this.getLabelPosition("x", ["inner-top", "inner-right"]);
    }
  }, {
    key: "getYAxisLabelPosition",
    value: function getYAxisLabelPosition() {
      return this.getLabelPosition("y", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getY2AxisLabelPosition",
    value: function getY2AxisLabelPosition() {
      return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getLabelPositionById",
    value: function getLabelPositionById(id) {
      return this["get".concat(id.toUpperCase(), "AxisLabelPosition")]();
    }
  }, {
    key: "textForXAxisLabel",
    value: function textForXAxisLabel() {
      return this.getLabelText("x");
    }
  }, {
    key: "textForYAxisLabel",
    value: function textForYAxisLabel() {
      return this.getLabelText("y");
    }
  }, {
    key: "textForY2AxisLabel",
    value: function textForY2AxisLabel() {
      return this.getLabelText("y2");
    }
  }, {
    key: "xForAxisLabel",
    value: function xForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          x = position.isMiddle ? -$$.height / 2 : 0;
      return isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom && (x = -$$.height), x;
    }
  }, {
    key: "dxForAxisLabel",
    value: function dxForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          dx = position.isBottom ? "0.5em" : "0";
      return isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
    }
  }, {
    key: "textAnchorForAxisLabel",
    value: function textAnchorForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          anchor = position.isMiddle ? "middle" : "end";
      return isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
    }
  }, {
    key: "xForXAxisLabel",
    value: function xForXAxisLabel() {
      return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "xForYAxisLabel",
    value: function xForYAxisLabel() {
      return this.xForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "xForY2AxisLabel",
    value: function xForY2AxisLabel() {
      return this.xForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dxForXAxisLabel",
    value: function dxForXAxisLabel() {
      return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "dxForYAxisLabel",
    value: function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "dxForY2AxisLabel",
    value: function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dyForXAxisLabel",
    value: function dyForXAxisLabel() {
      var $$ = this.owner,
          config = $$.config,
          isInner = this.getXAxisLabelPosition().isInner,
          xHeight = config.axis_x_height;
      return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
    }
  }, {
    key: "dyForYAxisLabel",
    value: function dyForYAxisLabel() {
      var $$ = this.owner,
          isInner = this.getYAxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
    }
  }, {
    key: "dyForY2AxisLabel",
    value: function dyForY2AxisLabel() {
      var $$ = this.owner,
          isInner = this.getY2AxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
    }
  }, {
    key: "textAnchorForXAxisLabel",
    value: function textAnchorForXAxisLabel() {
      return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "textAnchorForYAxisLabel",
    value: function textAnchorForYAxisLabel() {
      return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "textAnchorForY2AxisLabel",
    value: function textAnchorForY2AxisLabel() {
      return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "getMaxTickWidth",
    value: function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          currentTickMax = $$.currentMaxTickWidths[id],
          maxWidth = 0;
      if (withoutRecompute || !config["axis_".concat(id, "_show")]) return currentTickMax.size;

      if ($$.svg) {
        var isYAxis = /^y2?$/.test(id),
            targetsToShow = $$.filterTargetsToShow($$.data.targets),
            getFrom = isYAxis ? "getY" : "getX",
            scale = $$[id].copy().domain($$["".concat(getFrom, "Domain")](targetsToShow, id)),
            domain = scale.domain();
        // do not compute if domain is same
        if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
          return v === domain[i];
        })) return currentTickMax.size;
        currentTickMax.domain = domain;
        var axis = this["".concat(getFrom, "Axis")](id, scale, !1, !1, !0),
            tickCount = config["axis_".concat(id, "_tick_count")];
        tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
        var dummy = $$.selectChart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
        axis.create(dummy), dummy.selectAll("text").each(function () {
          maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
        }), dummy.remove();
      }

      return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
    }
  }, {
    key: "updateLabels",
    value: function updateLabels(withTransition) {
      var _this2 = this,
          $$ = this.owner,
          labels = {
        X: $$.main.select(".".concat(config_classes.axisX, " .").concat(config_classes.axisXLabel)),
        Y: $$.main.select(".".concat(config_classes.axisY, " .").concat(config_classes.axisYLabel)),
        Y2: $$.main.select(".".concat(config_classes.axisY2, " .").concat(config_classes.axisY2Label))
      };

      Object.keys(labels).filter(function (id) {
        return !labels[id].empty();
      }).forEach(function (v) {
        var node = labels[v],
            axisLabel = "".concat(v, "AxisLabel");
        (withTransition ? node.transition() : node).attr("x", _this2["xFor".concat(axisLabel)].bind(_this2)).attr("dx", _this2["dxFor".concat(axisLabel)].bind(_this2)).attr("dy", _this2["dyFor".concat(axisLabel)].bind(_this2)).text(_this2["textFor".concat(axisLabel)].bind(_this2));
      });
    }
  }, {
    key: "getPadding",
    value: function getPadding(padding, key, defaultValue, domainLength) {
      var p = isNumber(padding) ? padding : padding[key];
      return isValue(p) ? padding.unit === "ratio" ? padding[key] * domainLength : this.convertPixelsToAxisPadding(p, domainLength) : defaultValue; // assume padding is pixels if unit is not specified
    }
  }, {
    key: "convertPixelsToAxisPadding",
    value: function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    }
  }, {
    key: "generateTickValues",
    value: function generateTickValues(values, tickCount, forTimeSeries) {
      var start,
          end,
          count,
          interval,
          i,
          tickValue,
          tickValues = values;

      if (tickCount) {
        var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

        if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
          for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);

          tickValues.push(end);
        }
      }

      return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
        return a - b;
      })), tickValues;
    }
  }, {
    key: "generateTransitions",
    value: function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes,
          _map = ["x", "y", "y2", "subx"].map(function (v) {
        var axis = axes[v];
        return axis && duration && (axis = axis.transition().duration(duration)), axis;
      }),
          _map2 = slicedToArray_default()(_map, 4),
          axisX = _map2[0],
          axisY = _map2[1],
          axisY2 = _map2[2],
          axisSubX = _map2[3];

      return {
        axisX: axisX,
        axisY: axisY,
        axisY2: axisY2,
        axisSubX: axisSubX
      };
    }
  }, {
    key: "redraw",
    value: function redraw(transitions, isHidden, isInit) {
      var $$ = this.owner,
          opacity = isHidden ? "0" : "1";
      ["x", "y", "y2", "subX"].forEach(function (id) {
        var axis = $$["".concat(id, "Axis")];
        axis && (!isInit && (axis.config.withoutTransition = !$$.config.transition_duration), $$.axes[id.toLowerCase()].style("opacity", opacity), axis.create(transitions["axis".concat(capitalize(id))]));
      }), this.updateAxes();
    }
  }]), Axis;
}();


// EXTERNAL MODULE: ./src/internals/browser.js
var browser = __webpack_require__(49);

// CONCATENATED MODULE: ./src/internals/ChartInternal.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */







/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  function ChartInternal(api) {
    classCallCheck_default()(this, ChartInternal);

    var $$ = this;
    $$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {};
  }

  return createClass_default()(ChartInternal, [{
    key: "beforeInit",
    value: function beforeInit() {
      var $$ = this;
      $$.config.stats && sendStats(), $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$);
    }
  }, {
    key: "afterInit",
    value: function afterInit() {
      var $$ = this;
      $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$);
    }
  }, {
    key: "init",
    value: function init() {
      var $$ = this;
      $$.initParams();
      var convertedData = $$.convertData($$.config, $$.initWithData);
      convertedData && $$.initWithData(convertedData);
    }
  }, {
    key: "initParams",
    value: function initParams() {
      var _this = this,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated;

      $$.datetimeId = "bb-".concat(+new Date()), $$.initClip(), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], $$.axisTimeFormat = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
      $$.defaultAxisTimeFormat = function (d) {
        var isZoomed = isDragZoom ? _this.zoomScale : _this.zoomScale && $$.x.orgDomain().toString() !== _this.zoomScale.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return $$.axisTimeFormat(specifier)(d);
      }, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
        x: {
          size: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      }, $$.rotated_padding_left = 30, $$.rotated_padding_right = isRotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.inputType = $$.convertInputType(), $$.axes.subx = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
    }
  }, {
    key: "initWithData",
    value: function initWithData(data) {
      var $$ = this,
          config = $$.config;
      $$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom();
      var bindto = {
        element: config.bindto,
        classname: "bb"
      };

      if (isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $$.selectChart.empty() && ($$.selectChart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(document.body.appendChild(document.createElement("div")))), $$.selectChart.html("").classed(bindto.classname, !0), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.hasType("gauge") && (config.legend_show = !1), $$.updateSizes(), $$.updateScales(!0), $$.x && ($$.x.domain(sortValue($$.getXDomain($$.data.targets))), $$.subX.domain($$.x.domain()), $$.orgXDomain = $$.x.domain()), $$.y && ($$.y.domain($$.getYDomain($$.data.targets, "y")), $$.subY.domain($$.y.domain())), $$.y2 && ($$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subY2 && $$.subY2.domain($$.y2.domain())), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
        var isTouch = $$.inputType === "touch";
        $$.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
          return callFn(config.onover, $$);
        }).on(isTouch ? "touchend" : "mouseleave", function () {
          return callFn(config.onout, $$);
        });
      }

      config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
        return $$.defs.append(function () {
          return p.node;
        });
      }), $$.updateSvgSize();
      // Define regions
      var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

      // data.onmin/max callback
      if ($$.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", "".concat(config_classes.text, " ").concat(config_classes.empty)).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
      .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", $$.clipPath), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g.".concat(config_classes.regions)).attr("class", config_classes.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), config.oninit.call($$), $$.redraw({
        withTransition: !1,
        withTransform: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withTransitionForAxis: !1,
        initializing: !0
      }), config.data_onmin || config.data_onmax) {
        var minMax = $$.getMinMaxData();
        callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
      } // Bind resize event


      $$.bindResize(), $$.api.element = $$.selectChart.node();
    }
  }, {
    key: "initChartElements",
    value: function initChartElements() {
      var $$ = this;
      ["Bar", "Line", "Bubble", "Arc", "Gauge", "Pie", "Radar"].forEach(function (v) {
        $$["init".concat(v)]();
      }), notEmpty($$.config.data_labels) && $$.initText();
    }
  }, {
    key: "getChartElements",
    value: function getChartElements() {
      var $$ = this;
      return {
        chart: $$.selectChart,
        svg: $$.svg,
        defs: $$.defs,
        main: $$.main,
        tooltip: $$.tooltip,
        legend: $$.legend,
        title: $$.title,
        grid: $$.grid,
        arc: $$.arcs,
        bar: {
          bars: $$.mainBar
        },
        line: {
          lines: $$.mainLine,
          areas: $$.mainArea,
          circles: $$.mainCircle
        },
        text: {
          texts: $$.mainText
        }
      };
    }
  }, {
    key: "smoothLines",
    value: function smoothLines(el, type) {
      type === "grid" && el.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            _map = ["x1", "x2", "y1", "y2"].map(function (v) {
          return Math.ceil(g.attr(v));
        }),
            _map2 = slicedToArray_default()(_map, 4),
            x1 = _map2[0],
            x2 = _map2[1],
            y1 = _map2[2],
            y2 = _map2[3];

        g.attr({
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        });
      });
    }
    /**
     * Update size values
     * @param {Boolean} isInit If is called at initialization
     * @private
     */

  }, {
    key: "updateSizes",
    value: function updateSizes(isInit) {
      var $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          hasArc = $$.hasArcType(),
          legend = {
        width: $$.legend ? $$.getLegendWidth() : 0,
        height: $$.legend ? $$.getLegendHeight() : 0
      },
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legend.height,
          xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
          subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
          subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
      isInit || $$.setContainerSize(), $$.margin = isRotated ? {
        top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        // for top tick text
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      }, $$.margin2 = isRotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: subchartXAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      }, $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      }, $$.updateSizeForLegend && $$.updateSizeForLegend(legend), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = isRotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = isRotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legend.width + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1);
    }
    /**
     * Update targeted element with given data
     * @param {Object} targets Data object formatted as 'target'
     * @private
     */

  }, {
    key: "updateTargets",
    value: function updateTargets(targets) {
      var $$ = this; // Text

      $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
    }
    /**
     * Display targeted elements
     * @private
     */

  }, {
    key: "showTargets",
    value: function showTargets() {
      var $$ = this;
      $$.svg.selectAll(".".concat(config_classes.target)).filter(function (d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", "1");
    }
  }, {
    key: "getWithOption",
    value: function getWithOption(options) {
      var withOptions = {
        Y: !0,
        Subchart: !0,
        Transition: !0,
        EventRect: !0,
        Dimension: !0,
        TrimXDomain: !0,
        Transform: !1,
        UpdateXDomain: !1,
        UpdateOrgXDomain: !1,
        Legend: !1,
        UpdateXAxis: "UpdateXDomain",
        TransitionForExit: "Transition",
        TransitionForAxis: "Transition"
      };
      return Object.keys(withOptions).forEach(function (key) {
        var defVal = withOptions[key];
        isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with".concat(key), defVal);
      }), withOptions;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          transitionsValue = arguments.length > 1 ? arguments[1] : undefined,
          $$ = this,
          main = $$.main,
          config = $$.config,
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          initializing = options.initializing,
          flow = options.flow,
          wth = $$.getWithOption(options),
          duration = wth.Transition ? config.transition_duration : 0,
          durationForExit = wth.TransitionForExit ? duration : 0,
          durationForAxis = wth.TransitionForAxis ? duration : 0,
          transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
      initializing && config.tooltip_init_show || $$.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), $$.updateXgridFocus(), config.data_empty_label_text && main.select("text.".concat(config_classes.text, ".").concat(config_classes.empty)).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(duration, durationForExit), $$.mainText && main.selectAll(".".concat(config_classes.selectedCircles)).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && ($$.redrawEventRect(), $$.bindZoomEvent()), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
    }
    /**
     * Redraw axis
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} wth
     * @param {Ojbect} transitions
     * @param {Object} flow
     * @private
     */

  }, {
    key: "redrawAxis",
    value: function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
      var tickValues,
          intervalForCulling,
          xDomainForZoom,
          $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          hasZoom = !!$$.zoomScale;
      // show/hide if manual culling needed
      if (!hasZoom && $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), $$.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && (tickValues = $$.axis.updateXAxisTickValues(targetsToShow))) : $$.xAxis && ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = $$.x.orgDomain()), ["y", "y2"].forEach(function (key) {
        var axis = $$[key];

        if (axis) {
          var tickValues = config["axis_".concat(key, "_tick_values")],
              tickCount = config["axis_".concat(key, "_tick_count")];

          if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
            var domain = axis.domain();
            $$["".concat(key, "Axis")].tickValues($$.axis.generateTickValues(domain, domain.every(function (v) {
              return v === 0;
            }) ? 1 : tickCount, $$.isTimeSeriesY()));
          }
        }
      }), $$.axis.redraw(transitions, hasArcType, isInit), $$.axis.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis) && targetsToShow.length) if (config.axis_x_tick_culling && tickValues) {
        for (var i = 1; i < tickValues.length; i++) if (tickValues.length / i < config.axis_x_tick_culling_max) {
          intervalForCulling = i;
          break;
        }

        $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).each(function (d) {
          var index = tickValues.indexOf(d);
          index >= 0 && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("display", index % intervalForCulling ? "none" : "block");
        });
      } else $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).style("display", "block"); // Update sub domain

      wth.Y && ($$.subY && $$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2 && $$.subY2.domain($$.getYDomain(targetsToShow, "y2")));
    }
    /**
     * Generate redraw list
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} flow
     * @param {Object} duration
     * @param {Boolean} withSubchart whether or not to show subchart
     * @private
     */

  }, {
    key: "generateRedrawList",
    value: function generateRedrawList(targetsToShow, flow, duration, withSubchart) {
      var $$ = this,
          config = $$.config,
          shape = $$.getDrawShape();
      config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
      // generate flow
      var flowFn = flow && $$.generateFlow({
        targets: targetsToShow,
        flow: flow,
        duration: flow.duration,
        shape: shape,
        xv: $$.xv.bind($$)
      }),
          isTransition = (duration || flowFn) && $$.isTabVisible(),
          redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
          afterRedraw = flow || config.onrendered ? function () {
        flowFn && flowFn(), callFn(config.onrendered, $$);
      } : null;
      if (afterRedraw) // Only use transition when current tab is visible.
        if (isTransition) {
          // Wait for end of transitions for callback
          var waitForDraw = $$.generateWait(); // transition should be derived from one transition

          Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
            redrawList.reduce(function (acc, t1) {
              return acc.concat(t1);
            }, []).forEach(function (t) {
              return waitForDraw.add(t);
            });
          }).call(waitForDraw, afterRedraw);
        } else afterRedraw(); // update fadein condition

      $$.mapToIds($$.data.targets).forEach(function (id) {
        $$.withoutFadeIn[id] = !0;
      });
    }
    /**
     * Get the shape draw function
     * @return {Object}
     * @private
     */

  }, {
    key: "getDrawShape",
    value: function getDrawShape() {
      var $$ = this,
          isRotated = $$.config.axis_rotated,
          hasRadar = $$.hasType("radar"),
          shape = {
        type: {},
        indices: {}
      };

      // setup drawer - MEMO: these must be called after axis updated
      if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
        var indices = $$.getShapeIndices($$.isLineType);

        if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
          var _indices = $$.getShapeIndices($$.isAreaType);

          shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
        }
      }

      if ($$.hasType("bar")) {
        var _indices2 = $$.getShapeIndices($$.isBarType);

        shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
      }

      return shape.pos = {
        xForText: $$.generateXYForText(shape.indices, !0),
        yForText: $$.generateXYForText(shape.indices, !1),
        // generate circle x/y functions depending on updated params
        cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
        cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
      }, shape;
    }
  }, {
    key: "getRedrawList",
    value: function getRedrawList(shape, flow, flowFn, isTransition) {
      var $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          _shape$pos = shape.pos,
          cx = _shape$pos.cx,
          cy = _shape$pos.cy,
          xForText = _shape$pos.xForText,
          yForText = _shape$pos.yForText,
          list = [];

      if (!hasArcType) {
        var _shape$type = shape.type,
            area = _shape$type.area,
            bar = _shape$type.bar,
            line = _shape$type.line;
        (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition));
      }

      return (!hasArcType || $$.hasType("radar")) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
    }
  }, {
    key: "updateAndRedraw",
    value: function updateAndRedraw() {
      var transitions,
          options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          $$ = this,
          config = $$.config;
      options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
    }
  }, {
    key: "redrawWithoutRescale",
    value: function redrawWithoutRescale() {
      this.redraw({
        withY: !1,
        withSubchart: !1,
        withEventRect: !1,
        withTransitionForAxis: !1
      });
    }
  }, {
    key: "isTimeSeries",
    value: function isTimeSeries() {
      return this.config.axis_x_type === "timeseries";
    }
  }, {
    key: "isCategorized",
    value: function isCategorized() {
      return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
    }
  }, {
    key: "isCustomX",
    value: function isCustomX() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    }
  }, {
    key: "isTimeSeriesY",
    value: function isTimeSeriesY() {
      return this.config.axis_y_type === "timeseries";
    }
  }, {
    key: "getTranslate",
    value: function getTranslate(target) {
      var x,
          y,
          index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          padding = 0;
      if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel($$.margin.left), y = asHalfPixel($$.margin.top);else if (target === "context") x = asHalfPixel($$.margin2.left), y = asHalfPixel($$.margin2.top);else if (target === "legend") x = $$.margin3.left, y = $$.margin3.top;else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : $$.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? $$.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : $$.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subx") x = 0, y = isRotated ? 0 : $$.height2;else if (target === "arc") x = $$.arcWidth / 2, y = $$.arcHeight / 2;else if (target === "radar") {
        var diff = ($$.arcWidth - $$.arcHeight) / 2;
        x = Math.max(diff, 0) + 4, y = diff < 0 ? Math.abs(diff) : asHalfPixel($$.margin.top);
      }
      return "translate(".concat(x, ", ").concat(y, ")");
    }
  }, {
    key: "initialOpacity",
    value: function initialOpacity(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? "1" : "0";
    }
  }, {
    key: "initialOpacityForCircle",
    value: function initialOpacityForCircle(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
    }
  }, {
    key: "opacityForCircle",
    value: function opacityForCircle(d) {
      var opacity = this.config.point_show ? "1" : "0";
      return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
    }
  }, {
    key: "opacityForText",
    value: function opacityForText() {
      return this.hasDataLabel() ? "1" : "0";
    }
  }, {
    key: "xx",
    value: function xx(d) {
      var fn = this.config.zoom_enabled && this.zoomScale ? this.zoomScale : this.x;
      return d ? fn(d.x) : null;
    }
  }, {
    key: "xv",
    value: function xv(d) {
      var $$ = this,
          value = $$.getBaseValue(d);
      return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = $$.config.axis_x_categories.indexOf(value)), Math.ceil($$.x(value));
    }
  }, {
    key: "yv",
    value: function yv(d) {
      var $$ = this,
          yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;
      return Math.ceil(yScale($$.getBaseValue(d)));
    }
  }, {
    key: "subxx",
    value: function subxx(d) {
      return d ? this.subX(d.x) : null;
    }
  }, {
    key: "transformMain",
    value: function transformMain(withTransition, transitions) {
      var xAxis,
          yAxis,
          y2Axis,
          $$ = this;
      transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select(".".concat(config_classes.axisX)), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select(".".concat(config_classes.axisY)), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select(".".concat(config_classes.axisY2)), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select(".".concat(config_classes.chartArcs)).attr("transform", $$.getTranslate("arc"));
    }
  }, {
    key: "transformAll",
    value: function transformAll(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
    }
  }, {
    key: "updateSvgSize",
    value: function updateSvgSize() {
      var $$ = this,
          brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), $$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#".concat($$.clipId), "#".concat($$.clipIdForGrid)]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#".concat($$.clipIdForXAxis)).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForYAxis)).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForSubchart)).select("rect").attr("width", $$.width).attr("height", brushSize.height), $$.svg.select(".".concat(config_classes.zoomRect)).attr("width", $$.width).attr("height", $$.height);
    }
  }, {
    key: "updateDimension",
    value: function updateDimension(withoutAxis) {
      var $$ = this;
      withoutAxis || ($$.xAxis && $$.config.axis_rotated ? ($$.xAxis.create($$.axes.x), $$.subXAxis.create($$.axes.subx)) : ($$.yAxis && $$.yAxis.create($$.axes.y), $$.y2Axis && $$.y2Axis.create($$.axes.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
    }
  }, {
    key: "bindResize",
    value: function bindResize() {
      var $$ = this,
          config = $$.config;
      $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(config.onresize.bind($$)), config.resize_auto && $$.resizeFunction.add(function () {
        $$.resizeTimeout && (window.clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = window.setTimeout(function () {
          $$.api.flush(!1, !0);
        }, 200);
      }), $$.resizeFunction.add(config.onresized.bind($$)), window.addEventListener("resize", $$.resizeFunction);
    }
  }, {
    key: "generateResize",
    value: function generateResize() {
      function callResizeFunctions() {
        resizeFunctions.forEach(function (f) {
          return f();
        });
      }

      var resizeFunctions = [];
      return callResizeFunctions.add = function (f) {
        return resizeFunctions.push(f);
      }, callResizeFunctions.remove = function (f) {
        return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
      }, callResizeFunctions;
    }
  }, {
    key: "endall",
    value: function endall(transition, callback) {
      var n = 0;
      transition.each(function () {
        return ++n;
      }).on("end", function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

        --n || callback.apply.apply(callback, [this].concat(args));
      });
    }
  }, {
    key: "generateWait",
    value: function generateWait() {
      var transitionsToWait = [],
          f = function (transition, callback) {
        function loop() {
          var done = 0;
          transitionsToWait.forEach(function (t) {
            if (t.empty()) return void done++;

            try {
              t.transition();
            } catch (e) {
              done++;
            }
          }), timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
        }

        var timer;
        loop();
      };

      return f.add = function (transition) {
        isArray(transition) ? transitionsToWait = transitionsToWait.concat(transition) : transitionsToWait.push(transition);
      }, f;
    }
  }, {
    key: "parseDate",
    value: function parseDate(date) {
      var parsedDate,
          $$ = this;
      return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '".concat(date, "' to Date object")), parsedDate;
    }
  }, {
    key: "isTabVisible",
    value: function isTabVisible() {
      return !document.hidden;
    }
  }, {
    key: "convertInputType",
    value: function convertInputType() {
      var $$ = this,
          config = $$.config,
          hasMouse = config.interaction_inputType_mouse && !browser["isMobile"] && "onmouseover" in window,
          hasTouch = !1;
      return config.interaction_inputType_touch && (hasTouch = "ontouchmove" in window || window.DocumentTouch && document instanceof window.DocumentTouch), hasMouse && "mouse" || hasTouch && "touch" || null;
    }
    /**
     * Call plugin hook
     * @param {String} phase The lifecycle phase
     * @private
     */

  }, {
    key: "callPluginHook",
    value: function callPluginHook(phase) {
      for (var _this2 = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

      this.config.plugins.forEach(function (v) {
        phase === "$beforeInit" && (v.$$ = _this2, _this2.api.plugins.push(v)), v[phase].apply(v, args);
      });
    }
  }]), ChartInternal;
}();


// CONCATENATED MODULE: ./src/internals/Chart.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access primary node elements
 * @name Chart#$
 * @type {Object}
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @instance
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart = function Chart(config) {
  classCallCheck_default()(this, Chart);

  var $$ = new ChartInternal_ChartInternal(this);
  /**
   * Plugin instance array
   * @name Chart#plugins
   * @type {Array}
   * @instance
   * @memberof Chart
   * @example
   *  var chart = bb.generate({
   *     ...
   *     plugins: [
   *        new bb.plugin.stanford({ ... }),
   *        new PluginA()
   *     ]
   *  });
   *
   *  chart.plugins; // [Stanford, PluginA] - instance array
   */

  // bind "this" to nested API
  this.plugins = [], this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), this.$ = $$.getChartElements(), $$.afterInit(config), function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this);
};


// CONCATENATED MODULE: ./src/config/Options.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */
var Options_Options = function Options() {
  return classCallCheck_default()(this, Options), {
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * Allow usage stats collection.
     * - **NOTE:**
     *   - The usage stats collection is used for reference purpose only.
     *   - The stats data will be sent in a period of once in every 2 weeks.
     *   - Help us to make a better chart library! :)
     * @name stats
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * // turn off stats sending
     * stats: false
     */
    stats: !0,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set zoom options
     * @name zoom
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [zoom.enabled=false] Enable zooming.
     * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
     *  - **Available types:**
     *    - wheel
     *    - drag
     * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
     *  If true set, y domain will be updated according to the zoomed region.
     * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
     * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
     * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
     * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
     *  Specified function receives the zoom event.
     * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
     *  Specified function receives the zoomed domain.
     * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
     *  Specified function receives the zoomed domain.
     * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
     * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
     * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
     * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
     * @example
     *  zoom: {
     *      enabled: {
              *          type: "drag"
              *      },
     *      rescale: true,
     *      extent: [1, 100]  // enable more zooming
     *      x: {
     *          min: -1,  // set min range
     *          max: 10  // set max range
     *      },
     *      onzoomstart: function(event) { ... },
     *      onzoom: function(domain) { ... },
     *      onzoomend: function(domain) { ... },
     *
     *      // show reset button when is zoomed-in
     *      resetButton: true,
     *
     *      // customized text value for reset zoom button
     *      resetButton: {
     *          text: "Unzoom"
     *      }
     *  }
     */
    zoom_enabled: undefined,
    zoom_extent: undefined,
    zoom_privileged: !1,
    zoom_rescale: !1,
    zoom_onzoom: undefined,
    zoom_onzoomstart: undefined,
    zoom_onzoomend: undefined,
    zoom_resetButton: !0,
    zoom_x_min: undefined,
    zoom_x_max: undefined,

    /**
     * Interaction options
     * @name interaction
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
     *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
     * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
     * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
     * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
     * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
     * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
     * @example
     * interaction: {
              *    enabled: false,
              *    brighten: false,
              *    inputType: {
              *        mouse: true,
              *        touch: false
              *
              *        // or declare preventDefault explicitly.
              *        // In this case touch inputType is enabled by default
              *        touch: {
              *            preventDefault: true
              *
              *            // or threshold pixel value (pixel moved from touchstart to touchmove)
              *            preventDefault: 5
              *        }
              *    }
     * }
     */
    interaction_enabled: !0,
    interaction_brighten: !0,
    interaction_inputType_mouse: !0,
    interaction_inputType_touch: {},

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onover: function() {
     *   ...
     * }
     */
    onover: function onover() {},

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onout: function() {
     *   ...
     * }
     */
    onout: function onout() {},

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onresize: function() {
     *   ...
     * }
     */
    onresize: function onresize() {},

    /**
     * SSet a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onresized: function() {
     *   ...
     * }
     */
    onresized: function onresized() {},

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onbeforeinit: function() {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * oninit: function() {
     *   ...
     * }
     */
    oninit: function oninit() {},

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onafterinit: function() {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * onrendered: function() {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Specify the key of x values in the data.<br><br>
     * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
     * @name datax
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
              *   x: "date"
     * }
     */
    data_x: undefined,

    /**
     * Specify the keys of the x values for each data.<br><br>
     * This option can be used if we want to show the data that has different x values.
     * @name dataxs
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   xs: {
              *      data1: "x1",
              *      data2: "x2"
              *   }
     * }
     */
    data_xs: {},

    /**
     * Set a format specifier to parse string specifed as x.
     * @name dataxFormat
     * @memberof Options
     * @type {String}
     * @default %Y-%m-%d
     * @example
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "01012019", "02012019", "03012019"],
     *        ["data1", 30, 200, 100]
     *    ],
     *    // Format specifier to parse as datetime for given 'x' string value
     *    xFormat: "%m%d%Y"
     * },
     * axis: {
     *    x: {
     *        type: "timeseries"
     *    }
     * }
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     */
    data_xFormat: "%Y-%m-%d",

    /**
     * Set localtime format to parse x axis.
     * @name dataxLocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xLocaltime: false
     * }
     */
    data_xLocaltime: !0,

    /**
     * Sort on x axis.
     * @name dataxSort
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xSort: false
     * }
     */
    data_xSort: !0,

    /**
     * Converts data id value
     * @name dataidConverter
     * @memberof Options
     * @type {Function}
     * @default function(id) { return id; }
     * @example
     * data: {
              *    idConverter: function(id) {
              *       // when id is 'data1', converts to be 'data2'
              *       // 'data2' should be given as the initial data value
              *       if (id === "data1") {
              *          return "data2";
              *       } else {
              *          return id;
              *       }
              *    }
     * }
     */
    data_idConverter: function data_idConverter(id) {
      return id;
    },

    /**
     * Set custom data name.
     * @name datanames
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
     * @example
     * data: {
              *   names: {
              *     data1: "Data Name 1",
              *     data2: "Data Name 2"
              *   }
     * }
     */
    data_names: {},

    /**
     * Set custom data class.<br><br>
     * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
     * @name dataclasses
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   classes: {
              *     data1: "additional-data1-class",
              *     data2: "additional-data2-class"
              *   }
     * }
     */
    data_classes: {},

    /**
     * Set groups for the data for stacking.
     * @name datagroups
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * data: {
              *   groups: [
              *     ["data1", "data2"],
              *     ["data3"]
              *   ]
     * }
     */
    data_groups: [],

    /**
     * Set y axis the data related to. y and y2 can be used.
     * @name dataaxes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   axes: {
     *     data1: "y",
     *     data2: "y2"
     *   }
     * }
     */
    data_axes: {},

    /**
     * Set chart type at once.<br><br>
     * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
     * **Available Values:**
     * - area
     * - area-line-range
     * - area-spline
     * - area-spline-range
     * - area-step
     * - bar
     * - bubble
     * - donut
     * - gauge
     * - line
     * - pie
     * - radar
     * - scatter
     * - spline
     * - step
     * @name datatype
     * @memberof Options
     * @type {String}
     * @default line
     * @example
     * data: {
     *    type: "bar"
     * }
     */
    data_type: undefined,

    /**
     * Set chart type for each data.<br>
     * This setting overwrites data.type setting.
     * - **NOTE:** `radar` type can't be combined with other types.
     * @name datatypes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   types: {
     *     data1: "bar",
     *     data2: "spline"
     *   }
     * }
     */
    data_types: {},

    /**
     * Set labels options
     * @name datalabels
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [data.labels=false] Show or hide labels on each data points
     * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
     * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
     * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
     *  - `v` is the value of the data point where the label is shown.
     *  - `id` is the id of the data where the label is shown.
     *  - `i` is the index of the data point where the label is shown.
     *  - `j` is the sub index of the data point where the label is shown.<br><br>
     * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
    	 * @property {String|Object} [data.labels.colors] Set label text colors.
     * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
     * @property {NUmber} [data.labels.position.y=0] y coordinate position, relative the original.
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
     * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
     * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
     * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
     * @example
     * data: {
     *   labels: true,
     *
     *   // or set specific options
     *   labels: {
     *     format: function(v, id, i, j) { ... },
     *
     *     // it's possible to set for each data
     *     format: {
     *         data1: function(v, id, i, j) { ... },
     *         ...
     *     },
     *
     *     // align text to center of the 'bar' shape (works only for 'bar' type)
     *     centered: true,
     *
     *     // apply for all label texts
     *     colors: "red",
     *
     *     // or set different colors per dataset
     *     // for not specified dataset, will have the default color value
     *     colors: {
     *        data1: "yellow",
     *        data3: "green"
     *     },
     *
     *     // set x, y coordinate position
     *     position: {
     *        x: -10,
     *        y: 10
     *     }
     *   }
     * }
     */
    data_labels: {},
    data_labels_colors: undefined,
    data_labels_position: {},

    /**
     *  This option changes the order of stacking data and pieces of pie/donut.
     *  - If `null` specified, it will be the order the data loaded.
     *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
     *
     *  **Available Values:**
     *  - `desc`: In descending order
     *  - `asc`: In ascending order
     *  - `null`: It keeps the data load order
     *  - `function(data1, data2) { ... }`: Array.sort compareFunction
     * @name dataorder
     * @memberof Options
     * @type {String|Function|null}
     * @default desc
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
     * @example
     * data: {
     *   // in descending order (default)
     *   order: "desc"
     *
     *   // in ascending order
     *   order: "asc"
     *
     *   // keeps data input order
     *   order: null
     *
     *   // specifying sort function
     *   order: function(a, b) {
     *       // param data passed format
     *       {
     *          id: "data1", id_org: "data1", values: [
     *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
     *              ...
     *          ]
     *       }
     *   }
     * }
     */
    data_order: "desc",

    /**
     * Define regions for each data.<br>
     * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
     * - The object type should be as:
     *   - start {Number}: Start data point number. If not set, the start will be the first data point.
     *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
     *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
     * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
     * @name dataregions
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   regions: {
     *     data1: [{
     *         start: 1,
     *         end: 2,
     *         style: {
     *             dasharray: "5 2"
     *         }
     *     }, {
     *         start: 3
     *     }],
     *     ...
     *   }
     * }
     */
    data_regions: {},

    /**
     * Set color converter function.<br><br>
     * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
     * @name datacolor
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
     * @example
     * data: {
     *   color: function(color, d) { ... }
     * }
     */
    data_color: undefined,

    /**
     * Set color for each data.
     * @name datacolors
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   colors: {
     *     data1: "#ff0000",
     *     data2: function(d) {
     *        return "#000";
     *     }
     *     ...
     *   }
     * }
     */
    data_colors: {},

    /**
     * Hide each data when the chart appears.<br><br>
     * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
     * @name datahide
     * @memberof Options
     * @type {Boolean|Array}
     * @default false
     * @example
     * data: {
     *   // all of data will be hidden
     *   hide: true
     *
     *   // specified data will be hidden
     *   hide: ["data1", ...]
     * }
     */
    data_hide: !1,

    /**
     * Filter values to be shown
     * The data value is the same as the returned by `.data()`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     * @name datafilter
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * data: {
     *   // filter for id value
     *   filter: function(v) {
     *      // v: [{id: "data1", id_org: "data1", values: [
     *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
     *      //    }, ...]
     *      return v.id !== "data1";
     *   }
     */
    data_filter: undefined,

    /**
     * Set the stacking to be normalized
     * - **NOTE:**
     *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
     *   - y Axis will be set in percentage value (0 ~ 100%)
     *   - Must have postive values
     * @name datastacknormalize
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
     * @example
     * data: {
        *   stack: {
        *      normalize: true
        *   }
        * }
     */
    data_stack_normalize: !1,

    /**
     * Set data selection enabled<br><br>
     * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
     * @name dataselectionenabled
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
     * @example
     * data: {
     *    selection: {
     *       enabled: true
     *    }
     * }
     */
    data_selection_enabled: !1,

    /**
     * Set grouped selection enabled.<br><br>
     * If this option set true, multiple data points that have same x value will be selected by one selection.
     * @name dataselectiongrouped
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       grouped: true
     *    }
     * }
     */
    data_selection_grouped: !1,

    /**
     * Set a callback for each data point to determine if it's selectable or not.<br><br>
     * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
     * @name dataselectionisselectable
     * @memberof Options
     * @type {Function}
     * @default function() { return true; }
     * @example
     * data: {
     *    selection: {
     *       isselectable: function(d) { ... }
     *    }
     * }
     */
    data_selection_isselectable: function data_selection_isselectable() {
      return !0;
    },

    /**
     * Set multiple data points selection enabled.<br><br>
     * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
     * @name dataselectionmultiple
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
     *    selection: {
     *       multiple: false
     *    }
     * }
     */
    data_selection_multiple: !0,

    /**
     * Enable to select data points by dragging.
     * If this option set true, data points can be selected by dragging.
     * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
     * @name dataselectiondraggable
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       draggable: true
     *   }
     * }
     */
    data_selection_draggable: !1,

    /**
     * Set a callback for click event on each data point.<br><br>
     * This callback will be called when each data point clicked and will receive d and element as the arguments. d is the data clicked and element is the element clicked. In this callback, this will be the Chart object.
     * @name dataonclick
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onclick: function(d, element) { ... }
     * }
     */
    data_onclick: function data_onclick() {},

    /**
     * Set a callback for mouse/touch over event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves onto each data point and will receive d as the argument. d is the data where mouse cursor moves onto. In this callback, this will be the Chart object.
     * @name dataonover
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onover: function(d) { ... }
     * }
     */
    data_onover: function data_onover() {},

    /**
     * Set a callback for mouse/touch out event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves out each data point and will receive d as the argument. d is the data where mouse cursor moves out. In this callback, this will be the Chart object.
     * @name dataonout
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onout: function(d) { ... }
     * }
     */
    data_onout: function data_onout() {},

    /**
     * Set a callback for on data selection.
     * @name dataonselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onselected: function data_onselected() {},

    /**
     * Set a callback for on data un-selection.
     * @name dataonunselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onunselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onunselected: function data_onunselected() {},

    /**
     * Set a callback for minimum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmin
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmin: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmin: undefined,

    /**
     * Set a callback for maximum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmax
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmax: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmax: undefined,

    /**
     * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
     * @name dataurl
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
     * @example
     * data: {
     *     url: "/data/test.csv"
     * }
     */
    data_url: undefined,

    /**
     * XHR header value
     * - **NOTE:** Should be used with `data.url` option
     * @name dataheaders
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
     * @example
     * data: {
     *     url: "/data/test.csv",
     *     headers: {
     *        "Content-Type": "text/xml",
     *        ...
     *     }
     * }
     */
    data_headers: undefined,

    /**
     * Parse a JSON object for data. See also data.keys.
     * @name datajson
     * @memberof Options
     * @type {Object}
     * @default undefined
     * @see [datakeys](#.data%25E2%2580%25A4keys)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_json: undefined,

    /**
     * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
     * @name datarows
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
     * @example
     * data: {
     *   rows: [
     *     ["A", "B", "C"],
     *     [90, 120, 300],
     *     [40, 160, 240],
     *     [50, 200, 290],
     *     [120, 160, 230],
     *     [80, 130, 300],
     *     [90, 220, 320]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {high:150, mid: 140, low: 110}, 120
     *        [150, 140, 110], 120
     *      ],
     *      [[155, 130, 115], 55],
     *      [[160, 135, 120], 60]
     *   ],
     *   types: {
     *       data1: "area-line-range",
     *       data2: "line"
     *   }
     * }
     */
    data_rows: undefined,

    /**
     * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
     * @name datacolumns
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
     * @example
     * data: {
     *   columns: [
     *      ["data1", 30, 20, 50, 40, 60, 50],
     *      ["data2", 200, 130, 90, 240, 130, 220],
     *      ["data3", 300, 200, 160, 400, 250, 250]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   columns: [
     *      ["data1",
     *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
     *          [150, 140, 110],
     *          [150, 140, 110]
     *      ]
     *   ],
     *   type: "area-line-range"
     * }
     */
    data_columns: undefined,

    /**
     * Used if loading JSON via data.url.
     * @name datamimeType
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     mimeType: "json"
     * }
     */
    data_mimeType: undefined,

    /**
     * Choose which JSON object keys correspond to desired data.
     * - **NOTE:** Only for JSON object given as array.
     * @name datakeys
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_keys: undefined,

    /**
     * Set text label to be displayed when there's no data to show.
     * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
     * @name dataemptylabeltext
     * @memberof Options
     * @type {String}
     * @default ""
     * @example
     * data: {
     *   empty: {
     *     label: {
     *       text: "No Data"
     *     }
     *   }
     * }
     */
    data_empty_label_text: "",

    /**
     * Set subchart options
     * @name subchart
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
     * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
     * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
     * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
     * @property {Number} [subchart.size.height] Change the height of the subchart.
     * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
     *  Specified function receives the current zoomed x domain.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
     * @example
     *  subchart: {
     * 		axis: {
     * 			x: {
     * 				show: true,
     * 				tick: {
     * 					show: true,
     * 					text: {
     * 						show: false
     * 					}
     * 				}
     * 			}
     * 		},
     *      show: true,
     *      size: {
     *          height: 20
     *      },
     *      onbrush: function(domain) { ... }
     *  }
     */
    subchart_show: !1,
    subchart_size_height: 60,
    subchart_axis_x_show: !0,
    subchart_axis_x_tick_show: !0,
    subchart_axis_x_tick_text_show: !0,
    subchart_onbrush: function subchart_onbrush() {},

    /**
     * Set color of the data values
     * @name color
     * @memberof Options
     * @type {Object}
     * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
     * @property {Array} [color.pattern] custom color pattern
     * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
     *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
     *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
     *    - `bb-colorize-pattern-red`
     *    - `bb-colorize-pattern-fff`
     * @property {Object} [color.threshold] color threshold for gauge and tooltip color
     * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
     * @property {Array} [color.threshold.values] Threshold values for each steps
     * @property {Array} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
     * @example
     *  color: {
     *      pattern: ["#1f77b4", "#aec7e8", ...],
     *
     *      // Set colors' patterns
     *      // it should return an array of SVGPatternElement
     *      tiles: function() {
     *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
     *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
     *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
     *
     *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
     *         pattern.setAttribute("width", "32");
     *         pattern.setAttribute("height", "32");
     *
     *         g.style.fill = "#000";
     *         g.style.opacity = "0.2";
              *
     *         circle1.setAttribute("cx", "3");
     *         circle1.setAttribute("cy", "3");
     *         circle1.setAttribute("r", "3");
              *
     *         g.appendChild(circle1);
     *         pattern.appendChild(g);
     *
     *         return [pattern];
     *      },
     *
     *      // for threshold usage, pattern values should be set for each steps
     *      pattern: ["grey", "green", "yellow", "orange", "red"],
     *      threshold: {
     *          unit: "value",
     *          values: [10, 20, 30, 40, 50],  // when the value is 20, 'green' will be set and the value is 40, 'orange' will be set.
     *          max: 30  // the equation for max is: value*100/30
     *      },
     *
     *      // set all data to 'red'
     *      onover: "red",
     *
     *      // set different color for data
     *      onover: {
     *          data1: "red",
     *          data2: "yellow"
     *      },
     *
     *      // will pass data object to the callback
     *      onover: function(d) {
     *          return d.id === "data1" ? "red" : "green";
     *      }
     *  }
     */
    color_pattern: [],
    color_tiles: undefined,
    color_threshold: {},
    color_onover: undefined,

    /**
     * Legend options
     * @name legend
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [legend.show=true] Show or hide legend.
     * @property {Boolean} [legend.hide=false] Hide legend
     *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
     * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
     * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
     *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
     *    - {=COLOR}: data color value
     *    - {=TITLE}: data title value
     *  - If set `function` value, will pass following arguments to the given function:
     *   - title {String}: data's id value
     *   - color {String}: color string
     *   - data {Array}: data array
     * @property {String} [legend.position=bottom] Change the position of legend.<br>
     *  Available values are: `bottom`, `right` and `inset` are supported.
     * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
     *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
     *  - **anchor** decides the position of the legend:
     *   - top-left
     *   - top-right
     *   - bottom-left
     *   - bottom-right
     *  - **x** and **y**:
     *   - set the position of the legend based on the anchor.
     *  - **step**:
     *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
     * @property {Boolean} [legend.equally=false] Set to all items have same width size.
     * @property {Boolean} [legend.padding=0] Set padding value
     * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
     * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
     * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
     * @property {Number} [legend.item.tile.width=10] Set width of item tile element
     * @property {Number} [legend.item.tile.height=10] Set height of item tile element
     * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
     * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
     * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
     * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
     * @example
     *  legend: {
     *      show: true,
     *      hide: true,
     *      //or hide: "data1"
              *      //or hide: ["data1", "data2"]
     *      contents: {
     *          bindto: "#legend",   // <ul id='legend'></ul>
     *
     *          // will be as: <li style='background-color:#1f77b4'>data1</li>
     *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
     *
     *          // or using function
     *          template: function(id, color, data) {
     *               // if you want omit some legend, return falsy value
     *               if (title !== "data1") {
     *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
     *               }
     *          }
     *      },
              *      position: "bottom",  // bottom, right, inset
     *      inset: {
     *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
     *          x: 20,
     *          y: 10,
     *          step: 2
     *      },
              *      equally: false,
              *      padding: 10,
              *      item: {
     *          onclick: function(id) { ... },
     *          onover: function(id) { ... },
     *          onout: function(id) { ... },
     *
     *          // set tile's size
     *          tile: {
     *              width: 20,
     *              height: 15
     *          }
     *      },
     *      usePoint: true
     *  }
     */
    legend_show: !0,
    legend_hide: !1,
    legend_contents_bindto: undefined,
    legend_contents_template: undefined,
    legend_position: "bottom",
    legend_inset_anchor: "top-left",
    legend_inset_x: 10,
    legend_inset_y: 10,
    legend_inset_step: undefined,
    legend_item_onclick: undefined,
    legend_item_onover: undefined,
    legend_item_onout: undefined,
    legend_equally: !1,
    legend_padding: 0,
    legend_item_tile_width: 10,
    legend_item_tile_height: 10,
    legend_usePoint: !1,

    /**
     * Switch x and y axis position.
     * @name axisrotated
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   rotated: true
     * }
     */
    axis_rotated: !1,

    /**
     * Set clip-path attribute for x axis element
     * @name axisxclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo]()
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_x_clipPath: !0,

    /**
     * Show or hide x axis.
     * @name axisxshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     show: false
     *   }
     * }
     */
    axis_x_show: !0,

    /**
     * Set type of x axis.<br><br>
     * **Available Values:**
     * - timeseries
     * - category
     * - indexed
     * @name axisxtype
     * @memberof Options
     * @type {String}
     * @default indexed
     * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
     * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
     * @example
     * axis: {
     *   x: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_x_type: "indexed",

    /**
     * Set how to treat the timezone of x values.<br>
     * If true, treat x value as localtime. If false, convert to UTC internally.
     * @name axisxlocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     localtime: false
     *   }
     * }
     */
    axis_x_localtime: !0,

    /**
     * Set category names on category axis.
     * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
     * @name axisxcategories
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * axis: {
     *   x: {
     *     categories: ["Category 1", "Category 2", ...]
     *   }
     * }
     */
    axis_x_categories: [],

    /**
     * centerize ticks on category axis.
     * @name axisxtickcentered
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       centered: true
     *     }
     *   }
     * }
     */
    axis_x_tick_centered: !1,

    /**
     * A function to format tick value. Format string is also available for timeseries data.
     * @name axisxtickformat
     * @memberof Options
     * @type {Function|String}
     * @default undefined
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *        // for timeseries, a 'datetime' object is given as parameter
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *
     *       // for category, index(Number) and categoryName(String) are given as parameter
     *       format: function(index, categoryName) {
     *           return categoryName.substr(0, 10);
     *       },
     *
     *        // for timeseries format specifier
     *        format: "%Y-%m-%d %H:%M:%S"
     *     }
     *   }
     * }
     */
    axis_x_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.x.tick.culling.max.
     * @name axisxtickculling
     * @memberof Options
     * @type {Boolean}
     * @default
     * - true for indexed axis and timeseries axis
     * - false for category axis
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_x_tick_culling: {},

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisxtickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 10
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_culling_max: 10,

    /**
     * The number of x axis ticks to show.<br><br>
     * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
     * @name axisxtickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_x_tick_count: undefined,

    /**
     * Show or hide x axis tick line.
     * @name axisxtickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_x_tick_show: !0,

    /**
     * Show or hide x axis tick text.
     * @name axisxticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_show: !0,

    /**
     * Set the x Axis tick text's position relatively its original position
     * @name axisxticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Fit x axis ticks.
     * - **true**: ticks will be positioned nicely to have same intervals.
     * - **false**: ticks will be positioned according to x value of the data points.
     * @name axisxtickfit
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
     * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       fit: false
     *     }
     *   }
     * }
     */
    axis_x_tick_fit: !0,

    /**
     * Set the x values of ticks manually.<br><br>
     * If this option is provided, the position of the ticks will be determined based on those values. This option works with timeseries data and the x values will be parsed accoding to the type of the value and data.xFormat option.
     * @name axisxtickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       values: [1, 2, 4, 8, 16, 32, ...]
     *     }
     *   }
     * }
     */
    axis_x_tick_values: null,

    /**
     * Rotate x axis tick text.<br>
     * If you set negative value, it will rotate to opposite direction.
     * @name axisxtickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_x_tick_rotate: 0,

    /**
     * Show x axis outer tick.
     * @name axisxtickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_x_tick_outer: !0,

    /**
     * Set tick text to be multiline
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
     * @name axisxtickmultiline
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       multiline: false
     *     }
     *   }
     * }
     * @example
     * // example of line break with '\n'
     * // In this case, 'axis.x.tick.width' is ignored
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "long\ntext", "Another\nLong\nText"],
     *        ...
     *    ],
     * }
     */
    axis_x_tick_multiline: !0,

    /**
     * Set tick width
     * - **NOTE:**
     *  > When x tick text contains `\n`, this option is ignored.
     * @name axisxtickwidth
     * @memberof Options
     * @type {Number}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       width: 50
     *     }
     *   }
     * }
     */
    axis_x_tick_width: null,

    /**
     * Set to display system tooltip(via 'title' attribute) for tick text
     * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
     * @name axisxticktooltip
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       tooltip: true
     *     }
     *   }
     * }
     */
    axis_x_tick_tooltip: !1,

    /**
     * Set max value of x axis range.
     * @name axisxmax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     max: 100
     *   }
     * }
     */
    axis_x_max: undefined,

    /**
     * Set min value of x axis range.
     * @name axisxmin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     min: -100
     *   }
     * }
     */
    axis_x_min: undefined,

    /**
     * Set padding for x axis.<br><br>
     * If this option is set, the range of x axis will increase/decrease according to the values.
     * If no padding is needed in the rage of x axis, 0 should be set.
     * - **NOTE:**
     *   The padding values aren't based on pixels. It differs according axis types<br>
     *   - **category:** The unit of tick value
     *     ex. the given value `1`, is same as the width of 1 tick width
     *   - **timeseries:** Numeric time value
     *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
     * @name axisxpadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   x: {
     *     padding: {
     *       // when axis type is 'category'
     *       left: 1,  // set left padding width of equivalent value of a tick's width
     *       right: 0.5  // set right padding width as half of equivalent value of tick's width
     *
     *       // when axis type is 'timeseries'
     *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
     *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
     *     }
     *   }
     * }
     */
    axis_x_padding: {},

    /**
     * Set height of x axis.<br><br>
     * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
     * @name axisxheight
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     height: 20
     *   }
     * }
     */
    axis_x_height: undefined,

    /**
     * Set default extent for subchart and zoom. This can be an array or function that returns an array.
     * @name axisxextent
     * @memberof Options
     * @type {Array|Function}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     // extent range as a pixel value
     *     extent: [0, 200],
     *
     *     // when axis is 'timeseries', parsable datetime string
     *     extent: ["2019-03-01", "2019-03-05"],
     *
     *     // return extent value
     *     extent: function(domain, scale) {
     *    	 var extent = domain.map(function(v) {
     *     	    return scale(v);
     *     	 });
     *
     *   	 // it should return a format of array
     *   	 // ex) [0, 584]
     *     	 return extent;
     *     }
     *   }
     * }
     */
    axis_x_extent: undefined,

    /**
     * Set label on x axis.<br><br>
     *  You can set x axis label and change its position by this option. string and object can be passed and we can change the poisiton by passing object that has position key. Available position differs according to the axis direction (vertical or horizontal). If string set, the position will be the default.
     *  - **If it's horizontal axis:**
     *    - inner-right [default]
     *    - inner-center
     *    - inner-left
     *    - outer-right
     *    - outer-center
     *    - outer-left
     *  - **If it's vertical axis:**
     *    - inner-top [default]
     *    - inner-middle
     *    - inner-bottom
     *    - outer-top
     *    - outer-middle
     *    - outer-bottom
     * @name axisxlabel
     * @memberof Options
     * @type {String|Object}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     label: "Your X Axis"
     *   }
     * }
     *
     * axis: {
     *   x: {
     *     label: {
     *        text: "Your X Axis",
     *        position: "outer-center"
     *     }
     *   }
     * }
     */
    axis_x_label: {},

    /**
     * Set additional axes for x Axis.
     * - **NOTE:** Axis' scale is based on x Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisxaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * x: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_x_axes: [],

    /**
     * Set clip-path attribute for y axis element
     * @name axisyclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_y_clipPath: !0,

    /**
     * Show or hide y axis.
     * @name axisyshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     show: false
     *   }
     * }
     */
    axis_y_show: !0,

    /**
     * Set type of y axis.<br><br>
     * **Available Values:**
     *   - timeseries
     *   - category
     *   - indexed
     * @name axisytype
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_y_type: undefined,

    /**
     * Set max value of y axis.
     * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     max: 1000
     *   }
     * }
     */
    axis_y_max: undefined,

    /**
     * Set min value of y axis.
     * - **NOTE:**
     *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     min: 1000
     *   }
     * }
     */
    axis_y_min: undefined,

    /**
     * Change the direction of y axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisyinverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inverted: true
     *   }
     * }
     */
    axis_y_inverted: !1,

    /**
     * Set center value of y axis.
     * @name axisycenter
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     center: 0
     *   }
     * }
     */
    axis_y_center: undefined,

    /**
     * Show y axis inside of the chart.
     * @name axisyinner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inner: true
     *   }
     * }
     */
    axis_y_inner: !1,

    /**
     * Set label on y axis.<br><br>
     * You can set y axis label and change its position by this option. This option works in the same way as axis.x.label.
     * @name axisylabel
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     label: "Your Y Axis"
     *   }
     * }
     *
     * axis: {
     *   y: {
     *     label: {
     *        text: "Your Y Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y_label: {},

    /**
     * Set formatter for y axis tick text.<br><br>
     * This option accepts d3.format object as well as a function you define.
     * @name axisytickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_format: undefined,

    /**
     * Show y axis outer tick.
     * @name axisytickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y_tick_outer: !0,

    /**
     * Set y axis tick values manually.
     * @name axisytickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y_tick_values: null,
    axis_y_tick_rotate: 0,

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisytickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y_tick_count: undefined,

    /**
     * Show or hide y axis tick line.
     * @name axisytickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y_tick_show: !0,

    /**
    * Show or hide y axis tick text.
    * @name axisyticktextshow
    * @memberof Options
    * @type {Boolean}
    * @default true
    * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
    * @example
    * axis: {
    *   y: {
    *     tick: {
    *       text: {
    *           show: false
    *       }
    *     }
    *   }
    * }
    */
    axis_y_tick_text_show: !0,

    /**
     * Set the y Axis tick text's position relatively its original position
     * @name axisyticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisyticktime
     * @memberof Options
     * @private
     * @type {Object}
     * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       time: {
     *          // ticks at 15-minute intervals
     *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
     *          value: d3.timeMinute.every(15)
     *       }
     *     }
     *   }
     * }
     */
    // @TODO: not fully implemented yet
    axis_y_tick_time_value: undefined,

    /**
     * Set padding for y axis.<br><br>
     * You can set padding for y axis to create more space on the edge of the axis.
     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
     *
     * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
     * @name axisypadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     padding: {
     *       top: 0,
     *       bottom: 0
     *     }
     *   }
     * }
     */
    axis_y_padding: {},

    /**
     * Set default range of y axis.<br><br>
     * This option set the default value for y axis when there is no data on init.
     * @name axisydefault
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y_default: undefined,

    /**
     * Set additional axes for y Axis.
     * - **NOTE:** Axis' scale is based on y Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisyaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y_axes: [],

    /**
     * Show or hide y2 axis.
     * @name axisy2show
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     show: true
     *   }
     * }
     */
    axis_y2_show: !1,

    /**
     * Set max value of y2 axis.
     * @name axisy2max
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     max: 1000
     *   }
     * }
     */
    axis_y2_max: undefined,

    /**
     * Set min value of y2 axis.
     * @name axisy2min
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     min: -1000
     *   }
     * }
     */
    axis_y2_min: undefined,

    /**
     * Change the direction of y2 axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisy2inverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inverted: true
     *   }
     * }
     */
    axis_y2_inverted: !1,

    /**
     * Set center value of y2 axis.
     * @name axisy2center
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     center: 0
     *   }
     * }
     */
    axis_y2_center: undefined,

    /**
     * Show y2 axis inside of the chart.
     * @name axisy2inner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inner: true
     *   }
     * }
     */
    axis_y2_inner: !1,

    /**
     * Set label on y2 axis.<br><br>
     * You can set y2 axis label and change its position by this option. This option works in the same way as axis.x.label.
     * @name axisy2label
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     label: "Your Y2 Axis"
     *   }
     * }
     *
     * axis: {
     *   y2: {
     *     label: {
     *        text: "Your Y2 Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y2_label: {},

    /**
     * Set formatter for y2 axis tick text.<br><br>
     * This option works in the same way as axis.y.format.
     * @name axisy2tickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       format: d3.format("$,")
     *       //or format: function(d) { return "$" + d; }
     *     }
     *   }
     * }
     */
    axis_y2_tick_format: undefined,

    /**
     * Show or hide y2 axis outer tick.
     * @name axisy2tickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_outer: !0,

    /**
     * Set y2 axis tick values manually.
     * @name axisy2tickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y2_tick_values: null,

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2tickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y2_tick_count: undefined,

    /**
     * Show or hide y2 axis tick line.
     * @name axisy2tickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_show: !0,

    /**
     * Show or hide y2 axis tick text.
     * @name axisy2ticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_show: !0,

    /**
     * Set the y2 Axis tick text's position relatively its original position
     * @name axisy2ticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2padding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     padding: {
     *       top: 100,
     *       bottom: 100
     *     }
     *   }
     * }
     */
    axis_y2_padding: {},

    /**
     * Set default range of y2 axis.<br><br>
     * This option set the default value for y2 axis when there is no data on init.
     * @name axisy2default
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y2_default: undefined,

    /**
     * Set additional axes for y2 Axis.
     * - **NOTE:** Axis' scale is based on y2 Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisy2axes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y2: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y2_axes: [],

    /**
     * Set related options
     * @name grid
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
     * @property {Boolean} [x.show=false] Show grids along x axis.
     * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
     *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
     *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
     * @property {Boolean} [y.show=false] Show grids along x axis.
     * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
     *  This option accepts array including object that has value, text, position and class.
     * @property {Number} [y.ticks=10] Number of y grids to be shown.
     * @property {Boolean} [focus.show=true] Show grids when focus.
     * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
     * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
     * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
     * @example
     * grid: {
     *   x: {
     *     show: true,
     *     lines: [
     *       {value: 2, text: "Label on 2"},
     *       {value: 5, text: "Label on 5", class: "label-5"},
     *       {value: 6, text: "Label on 6", position: "start"}
     *     ]
     *   },
     *   y: {
     *     show: true,
     *     lines: [
     *       {value: 100, text: "Label on 100"},
     *       {value: 200, text: "Label on 200", class: "label-200"},
     *       {value: 300, text: "Label on 300", position: 'middle'}
     *     ],
     *     ticks: 5
     *   },
     *   front: true,
     *   focus: {
     *      show: false
     *   },
     *   lines: {
     *      front: false
     *   }
     * }
     */
    grid_x_show: !1,
    grid_x_type: "tick",
    grid_x_lines: [],
    grid_y_show: !1,
    grid_y_lines: [],
    grid_y_ticks: 10,
    grid_focus_show: !0,
    grid_front: !1,
    grid_lines_front: !0,

    /**
     * Set point options
     * @name point
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [point.show=true] Whether to show each point in line.
     * @property {Number|Function} [point.r=2.5] The radius size of each point.
     *  - **NOTE:** Disabled for 'bubble' type
     * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
     * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
     *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
     * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
     * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
     * @property {String} [point.type="circle"] The type of point to be drawn
     * - **NOTE:**
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
     * - **NOTE:**
     *  - This is an `experimental` feature and can have some unexpected behaviors.
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     *  - svg shape tag interpreted as string<br>
     *    (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
     * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
     * @example
     *  point: {
     *      show: false,
     *      r: 5,
     *
     *      // or customize the radius
     *      r: function(d) {
     *          ...
     *          return r;
     *      },
     *
     *      focus: {
     *          expand: {
     *              enabled: true,
     *              r: 1
     *          }
     *      },
     *      select: {
     *          r: 3
     *      },
     *
     *      // having lower value, means how closer to be for interaction
     *      sensitivity: 3,
     *
     *      // valid values are "circle" or "rectangle"
     *      type: "rectangle",
     *
     *      // or indicate as pattern
    	 *      pattern: [
    	 *        "circle",
    	 *        "rectangle",
    	 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
    	 *     ],
     *  }
     */
    point_show: !0,
    point_r: 2.5,
    point_sensitivity: 10,
    point_focus_expand_enabled: !0,
    point_focus_expand_r: undefined,
    point_pattern: [],
    point_select_r: undefined,
    point_type: "circle",

    /**
     * Set line options
     * @name line
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
     *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
     * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
     * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
     * **Available values:**
     * - step
     * - step-before
     * - step-after
     * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
     * @example
     *  line: {
     *      connectNull: true,
     *      classes: [
     *          "line-class1",
     *          "line-class2"
     *      ],
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ]
     *  }
     */
    line_connectNull: !1,
    line_step_type: "step",
    line_classes: undefined,
    line_point: !0,

    /**
     * Set bar options
     * @name bar
     * @memberof Options
     * @type {Object}
     * @property {Number} [bar.padding=0] The padding pixel value between each bar.
     * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
     * - **NOTE:** Works only for non-stacked bar
     * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
    	 * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
     * @property {Number} [bar.width] Change the width of bar chart.
     * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.max] The maximum width value for ratio.
     * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
     * - **NOTE:**
     *   - Works only for non-stacked bar
     *   - Bars are centered accoding its total width value
     * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
     * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
     * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
     * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
     * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
     * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
     * @example
     *  bar: {
     *      padding: 1,
     *
     *      // the 'radius' option can be used only for non-stacking bars
     *      radius: 10,
     *      // or
     *      radius: {
     *          ratio: 0.5
     *      }
     *
     *      // will not have offset between each bar elements for interaction
     *      sensitivity: 0,
     *
     *      width: 10,
     *
     *      // or
     *      width: {
     *          ratio: 0.2,
     *          max: 20
     *      },
     *
     *      // or specify width per dataset
     *      width: {
     *          data1: 20,
     *          data2: {
     *              ratio: 0.2,
     *              max: 20
     *          }
     *      },
     *
     *      zerobased: false
     *  }
     */
    bar_padding: 0,
    bar_radius: undefined,
    bar_radius_ratio: undefined,
    bar_sensitivity: 2,
    bar_width: undefined,
    bar_width_ratio: .6,
    bar_width_max: undefined,
    bar_zerobased: !0,

    /**
     * Set bubble options
     * @name bubble
     * @memberof Options
     * @type {Object}
     * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
     * @example
     *  bubble: {
     *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
     *      // And the lesser will have radius relatively from tha max value.
     *      maxR: 50,
     *
     *      // or set radius callback
     *      maxR: function(d) {
     *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
     *          ...
     *          return Math.sqrt(d.value * 2);
     *      }
     *  }
     */
    bubble_maxR: 35,

    /**
     * Set area options
     * @name area
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
     * @property {Boolean} [area.above=false] Set background area above the data chart line.
     * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
     * Or customize by giving below object value:
     *  - x {Array}: `x1`, `x2` value
     *  - y {Array}: `y1`, `y2` value
     *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
     * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
     * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
     * @example
     *  area: {
     *      zerobased: false,
     *      above: true,
     *
     *      // will generate follwing linearGradient:
     *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
     *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
     *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
     *      // </linearGradient>
     *      linearGradient: true,
     *
     *      // Or customized gradient
     *      linearGradient: {
     *      	x: [0, 0],  // x1, x2 attributes
     *      	y: [0, 0],  // y1, y2 attributes
     *      	stops: [
     *      		// offset, stop-color, stop-opacity
     *      		[0, "#7cb5ec", 1],
     *
     *      		// setting 'null' for stop-color, will set its original data color
     *      		[0.5, null, 0],
     *
     *      		// setting 'function' for stop-color, will pass data id as argument.
     *      		// It should return color string or null value
     *      		[1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
     *      	]
     *      }
     *  }
     */
    area_zerobased: !0,
    area_above: !1,
    area_linearGradient: !1,

    /**
     * Set pie options
     * @name pie
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
     * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
     * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
     * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
     * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
     * @property {Number} [pie.padAngle=0] Set padding between data.
     * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
     * @example
     *  pie: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *              ...
     *              return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      // set duration of expand transition to 500ms.
     *      expand: {
     *          duration: 500
     *      },
     *
     *      innerRadius: 0,
     *
     *      // set different innerRadius for each data
     *      innerRadius: {
     *      	data1: 10,
     *      	data2: 0
     *      }
     *
     *      padAngle: 0.1,
     *      padding: 0
     *  }
     */
    pie_label_show: !0,
    pie_label_format: undefined,
    pie_label_threshold: .05,
    pie_label_ratio: undefined,
    pie_expand: {},
    pie_expand_duration: 50,
    pie_innerRadius: 0,
    pie_padAngle: 0,
    pie_padding: 0,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Set gauge options
     * @name gauge
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
     * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
     * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
     * @property {Function} [gauge.label.extents] Set customized min/max label text.
     * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
     * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
     * @property {Number} [gauge.min=0] Set min value of the gauge.
     * @property {Number} [gauge.max=100] Set max value of the gauge.
     * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2]
     * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
     * @property {String} [gauge.units] Set units of the gauge.
     * @property {Number} [gauge.width] Set width of gauge chart.
     * @example
     *  gauge: {
     *      fullCircle: false,
     *      label: {
     *          show: false,
     *          format: function(value, ratio) {
     *              return value;
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          extents: function(value, isMax) {
    	 *              return (isMax ? "Max:" : "Min:") + value;
     *          }
     *      },
     *      expand: false,
     *
     *      // or set duration
     *      expand: {
     *          duration: 20
     *      },
     *      min: -100,
     *      max: 200,
     *      title: "Title Text",
     *      units: "%",
     *      width: 10
     *  }
     */
    gauge_fullCircle: !1,
    gauge_label_show: !0,
    gauge_label_format: undefined,
    gauge_min: 0,
    gauge_max: 100,
    gauge_startingAngle: -1 * Math.PI / 2,
    gauge_label_extents: undefined,
    gauge_title: "",
    gauge_units: undefined,
    gauge_width: undefined,
    gauge_expand: {},
    gauge_expand_duration: 50,

    /**
     * Set donut options
     * @name donut
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
     * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
     * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
     * @property {Number} [donut.width] Set width of donut chart.
     * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
     * @property {Number} [donut.padAngle=0] Set padding between data.
     * @example
     *  donut: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *          	...
     *          	return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *      expand: false,
     *      width: 10,
     *      padAngle: 0.2,
     *      title: "Donut Title"
     *
     *      // title with line break
     *      title: "Title1\nTitle2"
     *  }
     */
    donut_label_show: !0,
    donut_label_format: undefined,
    donut_label_threshold: .05,
    donut_label_ratio: undefined,
    donut_width: undefined,
    donut_title: "",
    donut_expand: {},
    donut_expand_duration: 50,
    donut_padAngle: 0,

    /**
     * Set spline options
     * - **Available interpolation type values:**
     *  - basis (d3.curveBasis)
     *  - basis-closed (d3.curveBasisClosed)
     *  - basis-open (d3.curveBasisOpen)
     *  - bundle (d3.curveBundle)
     *  - cardinal (d3.curveCardinal)
     *  - cardinal-closed (d3.curveCardinalClosed)
     *  - cardinal-open (d3.curveCardinalOpen)
     *  - catmull-rom (d3.curveCatmullRom)
     *  - catmull-rom-closed (d3.curveCatmullRomClosed)
     *  - catmull-rom-open (d3.curveCatmullRomOpen)
     *  - monotone-x (d3.curveMonotoneX)
     *  - monotone-y (d3.curveMonotoneY)
     *  - natural (d3.curveNatural)
     *  - linear-closed (d3.curveLinearClosed)
     *  - linear (d3.curveLinear)
     *  - step (d3.curveStep)
     *  - step-after (d3.curveStepAfter)
     *  - step-before (d3.curveStepBefore)
     * @name spline
     * @memberof Options
     * @type {Object}
     * @property {String} [spline.interpolation.type="cardinal"]
     * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
     * @example
     *  spline: {
     *      interpolation: {
     *          type: "cardinal"
     *      }
     *  }
     */
    spline_interpolation_type: "cardinal",

    /**
     * Set radar options
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break.
     * @name radar
     * @memberof Options
     * @type {Object}
     * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
     * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
     * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
     * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
     * @property {Number} [radar.level.depth=3] Set the level depth.
     * @property {Boolean} [radar.level.show=true] Show or hide level.
     * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
     * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
     * @property {Number} [radar.size.ratio=0.87] Set size ratio.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
     * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
     * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
     * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
     * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
     * @example
     *  radar: {
     *      axis: {
     *          max: 50,
     *          line: {
     *              show: false
     *          },
     *          text: {
     *              show: false
     *          }
     *      },
     *      direction: {
     *          clockwise: true
     *      },
     *      level: {
     *          show: false,
     *          text: {
     *              format: function(x) {
     *                  return x + "%";
     *              },
     *              show: true
     *          }
     *      },
     *      size: {
     *          ratio: 0.7
     *      }
     *  }
     */
    radar_axis_max: undefined,
    radar_axis_line_show: !0,
    radar_axis_text_show: !0,
    radar_level_depth: 3,
    radar_level_show: !0,
    radar_level_text_format: function radar_level_text_format(x) {
      return x % 1 === 0 ? x : x.toFixed(2);
    },
    radar_level_text_show: !0,
    radar_size_ratio: .87,
    radar_direction_clockwise: !1,

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class. The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end. If not specified, the edge values will be used. If timeseries x axis, date string, Date object and unixtime integer can be used. If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: [],

    /**
     * Tooltip options
     * @name tooltip
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
     * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
     * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
     *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
     * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
     * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
     * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
     *  Specified function receives x of the data point to show.
     * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     *  If undefined returned, the row of that value will be skipped.
     * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
     *  This option can be used to modify the tooltip position by returning object that has top and left.
     * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
     *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
     * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
     * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.
     *  - **NOTE:** When is specified, will not be updating tooltip's position.
     *  - Within template, below syntax will be replaced using template-like syntax string:
     *    - {{ ... }}: the doubly curly brackets indicate loop block for data rows
     *    - {=CLASS_TOOLTIP}: default tooltip class name `bb-tooltip`.
     *    - {=CLASS_TOOLTIP_NAME}: default tooltip data class name (ex. `bb-tooltip-name-data1`)
     *    - {=TITLE}: title value
     *    - {=COLOR}: data color
     *    - {=VALUE}: data value
     * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
     *  - **NOTE:** It should contain `{ key: Array, ... }` value
     *    - 'key' name is used as substitution within template as '{=KEY}'
     *    - The value array length should match with the data length
     * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
     * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
     * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
     * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
     * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
     * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
     * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
     * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
     *  **Available Values:**
     *  - `desc`: In descending data value order
     *  - `asc`: In ascending data value order
     *  - `null`: It keeps the data display order<br>
     *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
     *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
     *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
     * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
     * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
     * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
     * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
     * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
     * @example
     *  tooltip: {
     *      show: true,
     *      doNotHide: true,
     *      grouped: false,
     *      format: {
     *          title: function(x) { return "Data " + x; },
     *          name: function(name, ratio, id, index) { return name; },
     *          value: function(value, ratio, id, index) { return ratio; }
     *      },
     *      position: function(data, width, height, element) {
     *          return {top: 0, left: 0}
    		 *      },
     *
    		 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
    		 *          return ... // formatted html as you want
     		 *      },
     *
     *       // specify tooltip contents using template
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
     *      		'}}</ul>'
     *      }
     *
     *       // with additional text value
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	text: {
     *      		// a) 'key' name is used as substitution within template as '{=KEY}'
     *      		// b) the length should match with the data length
     *      		VAR1: ["text1", "text2"],
     *      		VAR2: ["comment1", "comment2"],
     *      	},
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
     *      		'}}</ul>'
     *      }
     		 *
     		 *      // sort tooltip data value display in ascending order
     		 *      order: "asc",
     		 *
     *      // specifying sort function
     *      order: function(a, b) {
     *         // param data passed format
     *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
     *           ...
     *      },
     *
     *      // show at the initialization
     *      init: {
     *          show: true,
     *          x: 2,
     *          position: {
     *              top: "150px",
     *              left: "250px"
     *          }
     *      },
     *
     *      // fires prior tooltip is shown
     *      onshow: function() { ...},
     *      // fires prior tooltip is hidden
     *      onhide: function() { ... },
     *      // fires after tooltip is shown
     *      onshown: function() { ... },
     *      // fires after tooltip is hidden
     *      onhidden: function() { ... },
     *
     *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
     *      // Useful for timeseries correlation
     *      linked: true,
     *
     *      // Specify name to interact those with the same name only.
     *      linked: {
     *          name: "some-group"
     *      }
     *  }
     */
    tooltip_show: !0,
    tooltip_doNotHide: !1,
    tooltip_grouped: !0,
    tooltip_format_title: undefined,
    tooltip_format_name: undefined,
    tooltip_format_value: undefined,
    tooltip_position: undefined,
    tooltip_contents: {},
    tooltip_init_show: !1,
    tooltip_init_x: 0,
    tooltip_init_position: {
      top: "0px",
      left: "50px"
    },
    tooltip_linked: !1,
    tooltip_linked_name: "",
    tooltip_onshow: function tooltip_onshow() {},
    tooltip_onhide: function tooltip_onhide() {},
    tooltip_onshown: function tooltip_onshown() {},
    tooltip_onhidden: function tooltip_onhidden() {},
    tooltip_order: null,

    /**
     * Set title options
     * @name title
     * @memberof Options
     * @type {Object}
     * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
     * @property {Number} [title.padding.top=0] Top padding value.
     * @property {Number} [title.padding.right=0] Right padding value.
     * @property {Number} [title.padding.bottom=0] Bottom padding value.
     * @property {Number} [title.padding.left=0] Left padding value.
     * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
     * @example
     *  title: {
     *      text: "Title Text",
     *
     *      // or Multiline title text
     *      text: "Main title text\nSub title text",
     *
     *      padding: {
     *          top: 10,
     *          right: 10,
     *          bottom: 10,
     *          left: 10
     *      },
     *      position: "center"
     *  }
     */
    title_text: undefined,
    title_padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    title_position: "center"
  };
};


// CONCATENATED MODULE: ./src/config/config.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getOptions: function getOptions() {
    return new Options_Options();
  },

  /**
   * Load configuration option
   * @param {Object} config User's generation config value
   * @private
   */
  loadConfig: function loadConfig(config) {
    var target,
        keys,
        read,
        thisConfig = this.config,
        find = function () {
      var key = keys.shift();
      return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
    };

    Object.keys(thisConfig).forEach(function (key) {
      target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/scale.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.zoomScale || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.xAxis.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    return this.axis.getId(id) === "y2" ? this.y2 : this.y;
  },
  getSubYScale: function getSubYScale(id) {
    return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit) {
    var updateXDomain = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.xMin = isRotated ? 1 : 0, $$.xMax = isRotated ? $$.height : $$.width, $$.yMin = isRotated ? 0 : $$.height, $$.yMax = isRotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = isRotated ? 0 : $$.height2, $$.subYMax = isRotated ? $$.width2 : 1;
    // update scales
    // x Axis
    var xDomain = updateXDomain && $$.x && $$.x.orgDomain(),
        xSubDomain = updateXDomain && $$.orgXDomain;
    // y Axis
    // update for arc
    $$.x = $$.getX($$.xMin, $$.xMax, xDomain, function () {
      return $$.xAxis.tickOffset();
    }), $$.subX = $$.getX($$.xMin, $$.xMax, xSubDomain, function (d) {
      return d % 1 ? 0 : $$.subXAxis.tickOffset();
    }), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getXAxisTickValues(), $$.xAxis = $$.axis.getXAxis("x", $$.x, config.axis_x_tick_outer, isInit), $$.subXAxis = $$.axis.getXAxis("subX", $$.subX, config.axis_x_tick_outer, isInit), $$.y = $$.getY($$.yMin, $$.yMax, $$.y ? $$.y.domain() : config.axis_y_default), $$.subY = $$.getY($$.subYMin, $$.subYMax, $$.subY ? $$.subY.domain() : config.axis_y_default), $$.yAxisTickValues = $$.axis.getYAxisTickValues(), $$.yAxis = $$.axis.getYAxis("y", $$.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && ($$.y2 = $$.getY($$.yMin, $$.yMax, $$.y2 ? $$.y2.domain() : config.axis_y2_default), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, $$.subY2 ? $$.subY2.domain() : config.axis_y2_default), $$.y2AxisTickValues = $$.axis.getY2AxisTickValues(), $$.y2Axis = $$.axis.getYAxis("y2", $$.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/internals/domain.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has".concat(isMin ? "Negative" : "Positive", "ValueInTargets")](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
        yMin = config["axis_".concat(axisId, "_min")],
        yMax = config["axis_".concat(axisId, "_max")],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_".concat(axisId, "_center")],
        isZeroBased = $$.hasType("bar", yTargets) && config.bar_zerobased || $$.hasType("area", yTargets) && config.area_zerobased,
        isInverted = config["axis_".concat(axisId, "_inverted")],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    if (yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, yTargets.length === 0) // use current domain if target of axisId is none
      return $$[axisId].domain();
    isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain($$.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_".concat(axisId, "_padding")];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_".concat(type)];
    return isDefined(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        firstX = xDomain[0],
        lastX = xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && ($$.x.domain(domain || sortValue($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? $$.orgXDomain : getBrushSelection($$).map($$.subX.invert);
      $$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        _zoomDomain = slicedToArray_default()(zoomDomain, 2),
        min = _zoomDomain[0],
        max = _zoomDomain[1];

    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/data/data.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return config.data_stack_normalize && config.data_groups.length;
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this;
    Object.keys(xs).forEach(function (id) {
      $$.config.data_xs[id] = xs[id];
    });
  },
  hasMultipleX: function hasMultipleX(xs) {
    return Object.keys(xs).map(function (id) {
      return xs[id];
    }).length > 1;
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this;
    return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  cloneTarget: function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  },
  updateXs: function updateXs() {
    var $$ = this,
        targets = $$.data.targets;
    targets.length && ($$.xs = [], targets[0].values.forEach(function (v) {
      $$.xs[v.index] = v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && $$.isAreaRangeType(data) && (value = $$.getAreaRangeData(data, "mid")), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(toConsumableArray_default()(value))), max = Math.max.apply(Math, [i ? max : -Infinity].concat(toConsumableArray_default()(value)));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.getCache(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.addCache(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.getCache("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.getCache(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.addCache(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, toConsumableArray_default()(this.data.targets.map(function (t) {
      return t.values.length;
    })));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget(targets) {
    var maxTarget,
        length = targets.length,
        max = 0;
    return length > 1 ? targets.forEach(function (t) {
      t.values.length > max && (maxTarget = t, max = t.values.length);
    }) : maxTarget = length ? targets[0] : null, maxTarget;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, toConsumableArray_default()(value)) : isObject(value) && "high" in value ? data.push.apply(data, toConsumableArray_default()(Object.values(value))) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = toConsumableArray_default()(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();

    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        minDist = $$.config.point_sensitivity;
    return values.filter(function (v) {
      return v && $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = $$.main.select(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(v.id), " .").concat(config_classes.bar, "-").concat(v.index)).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), values.filter(function (v) {
      return v && !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = ($$.zoomScale || $$.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_".concat(name)];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown.call(api).length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            $$.hiddenTargetIds.length && (total -= dataValues($$.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if ($$.hiddenTargetIds.length) {
          var hiddenSum = dataValues($$.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0)) / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(50);

// CONCATENATED MODULE: ./src/data/data.convert.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data,
        $$ = this;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_".concat(v);
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) $$.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = $$.convertJsonToData(data.json, data.keys);else if (data.rows) data = $$.convertRowsToData(data.rows);else if (data.columns) data = $$.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return data;
  },
  convertUrlToData: function convertUrlToData(url) {
    var _this = this,
        mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
        headers = arguments.length > 2 ? arguments[2] : undefined,
        keys = arguments.length > 3 ? arguments[3] : undefined,
        done = arguments.length > 4 ? arguments[4] : undefined,
        req = new XMLHttpRequest();

    headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.open("GET", url), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert".concat(capitalize(mimeType), "ToData")](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error("".concat(url, ": Something went wrong loading!"));
    }, req.send();
  },
  _convertCsvTsvToData: function _convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];

    for (var i = 1, len1 = rows.length; i < len1; i++) {
      var newRow = {};

      for (var j = 0, len2 = rows[i].length; j < len2; j++) {
        if (isUndefined(rows[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRow[keys[j]] = rows[i][j];
      }

      newRows.push(newRow);
    }

    return newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];

    for (var i = 0, len1 = columns.length; i < len1; i++) {
      var key = columns[i][0];

      for (var j = 1, len2 = columns[i].length; j < len2; j++) {
        if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(columns[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRows[j - 1][key] = columns[i][j];
      }
    }

    return newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || _this3.isTimeSeries() ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!xsData) throw new Error("x is not defined for id = \"".concat(id, "\"."));
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) ? isArray(value) || isObject(value) && value.high ? value : null : +d[id], isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(d[id]) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.addCache(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/data/data.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.resetCache();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      $$.load(data ? $$.convertDataToTargets(data) : null, args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.resetCache(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      $$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll(".".concat(config_classes.legendItem).concat($$.getTargetSelectorSuffix(id))).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// CONCATENATED MODULE: ./src/internals/category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var config = this.config;
    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(51);

// CONCATENATED MODULE: ./src/interactions/interaction.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.main.select(".".concat(config_classes.eventRects)).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll(".".concat(config_classes.eventRect)).remove(), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), isMultipleX) eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $$.eventRect
      var maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
      eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), eventRectUpdate = $$.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $$.updateEventRect(eventRectUpdate), $$.inputType !== "touch" || $$.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(document.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(".concat(config_classes.eventRect, "-?|s)"), "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client".concat(config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect();

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        if ($$.dragging || $$.flowing || $$.hasArcType()) return;
        preventEvent(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"]), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) && $$.cancelClick && ($$.cancelClick = !1);
    });
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        xScale = $$.zoomScale || $$.x,
        eventRectData = eventRectUpdate || $$.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = $$.width, h = $$.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        $$.updateXs();

        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? $$.height : $$.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = $$.data.xs[d.id][d.index];
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? $$.width : rectW, h = isRotated ? rectW : $$.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showXGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideXGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showXGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showXGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select(".".concat(config_classes.eventRect)).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.svg.select(".".concat(config_classes.eventRect)).style("cursor", null), $$.hideXGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      config.color_onover && $$.setOverColor(isOver, d, isArc), isArc ? callback(d) : (isOver && $$.expandCirclesBars(d, null, !0), !$$.isMultipleX() && $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(callback));
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover", function (d) {
      $$.dragging || $$.flowing || $$.hasArcType() || $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!($$.dragging || $$.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.svg.select(".".concat(config_classes.eventRect, "-").concat(index));
        $$.isStepType(d) && $$.config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index);
      }
    }).on("mouseout", function (d) {
      !$$.config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config;
    if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));
    var index = d.index;
    $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll(".".concat(config_classes.shapes).concat($$.getTargetSelectorSuffix(closest.id))).selectAll(".".concat(config_classes.shape, "-").concat(closest.index)).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = ".".concat(isMultipleX ? config_classes.eventRect : "".concat(config_classes.eventRect, "-").concat(index)),
        eventRect = $$.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/internals/size.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this;
    $$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? 10 + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset".concat(capitalize(key)), parent = this.selectChart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = document.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.selectChart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $$.main.select(".".concat(leftAxisClass)).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $$.selectChart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this,
        position = $$.axis.getLabelPositionById(id);
    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        h = 30;
    return id !== "x" || config.axis_x_show ? id === "x" && config.axis_x_height ? config.axis_x_height : id !== "y" || config.axis_y_show ? id !== "y2" || config.axis_y2_show ? ((id === "x" && !isRotated && config.axis_x_tick_rotate || id === "y" && isRotated && config.axis_y_tick_rotate) && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - config["axis_".concat(id, "_tick_rotate")]) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10)) : $$.rotated_padding_top : !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10 : 8; // Calculate x/y axis height when tick rotated
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.xAxis.tickInterval());
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(52);

// CONCATENATED MODULE: ./src/shape/shape.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        indices = {},
        i = 0;
    return $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in indices) {
        indices[d.id] = indices[_row4];
        break;
      }

      isUndefined(indices[d.id]) && (indices[d.id] = i++);
    }), indices.__max__ = i - 1, indices;
  },
  getShapeX: function getShapeX(offset, targetsNum, indices, isSub) {
    var $$ = this,
        scale = isSub ? $$.subX : $$.zoomScale || $$.x,
        barPadding = $$.config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var index = d.id in indices ? indices[d.id] : 0,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = scale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(isStackNormalized ? $$.getRatio("index", d, !0) : d.value);
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        targetIds = targets.map(function (t) {
      return t.id;
    });
    return function (d, idx) {
      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          offset = y0,
          i = idx;
      return targets.forEach(function (t) {
        var rowValues = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values,
            values = rowValues.map(function (v) {
          return $$.isStackNormalized() ? $$.getRatio("index", v, !0) : v.value;
        });
        t.id === d.id || indices[t.id] !== indices[d.id] || targetIds.indexOf(t.id) < targetIds.indexOf(d.id) && ((isUndefined(rowValues[i]) || +rowValues[i].x !== +d.x) && (i = -1, rowValues.forEach(function (v, j) {
          var x1 = v.x.constructor === Date ? +v.x : v.x,
              x2 = d.x.constructor === Date ? +d.x : d.x;
          x1 === x2 && (i = j);
        })), i in rowValues && rowValues[i].value * d.value >= 0 && (offset += scale(values[i]) - y0));
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        type = $$.config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(53);

// CONCATENATED MODULE: ./src/shape/arc.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






extend(ChartInternal_ChartInternal.prototype, {
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        padding = config.pie_padding,
        padAngle = $$.hasType("pie") && padding ? padding * .01 : config["".concat(config.data_type, "_padAngle")] ? config["".concat(config.data_type, "_padAngle")] : 0;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().padAngle(padAngle).sortValues($$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width;
    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2, $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6;
    var innerRadius = radius || (padding ? padding * ($$.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    $$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        radius = $$.innerRadius;
    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded(), $$.svgArcExpandedSub = $$.getSvgArcExpanded(.98);
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
          gStart = config.gauge_startingAngle,
          gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = $$.pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    return pie($$.filterTargetsToShow()).forEach(function (t) {
      found || t.data.id !== d.data.id || (found = !0, d = t);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        ir = $$.getInnerRadius(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radius).innerRadius(isNumber(ir) ? ir : 0),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radiusExpanded * (rate || 1));
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? arc.innerRadius($$.getInnerRadius(d))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        updated = $$.updateAngle(d),
        translate = "";

    if (updated && (!$$.hasType("gauge") || $$.hasMultiTargets())) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, $$.radius, h) : ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(".concat(x * ratio, ",").concat(y * ratio, ")");
    }

    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : null,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          isUnderThreshold = $$.hasType("gauge") || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this; // MEMO: avoid to cancel transition

    if ($$.transiting) {
      var interval = setInterval(function () {
        $$.transiting || (clearInterval(interval), $$.legend.selectAll(".".concat(config_classes.legendItemFocused)).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).each(function (d) {
      if ($$.shouldExpand(d.data.id) && d.value !== 0) {
        var expandDuration = $$.expandDuration(d.data.id);
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", $$.svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this;

    if (!$$.transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).selectAll("path").transition().duration(function (d) {
        return $$.expandDuration(d.data.id);
      }).attr("d", $$.svgArc), $$.svg.selectAll("".concat(config_classes.arc)).style("opacity", "1");
    }
  },
  expandDuration: function expandDuration(id) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config["".concat(type, "_expand_duration")] : 50;
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config["".concat(v, "_label_show")];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config["".concat(type, "_title")] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select(".".concat(config_classes.chartArcs)).selectAll(".".concat(config_classes.chartArc)).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this;
    $$.arcs = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-1.3, 1.3]);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arc)).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && (config.data_selection_isselectable(d) ? "pointer" : null);
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      $$.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      $$.transiting = !1;
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        isTouch = $$.inputType === "touch",
        isMouse = $$.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(document.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!$$.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        text = main.selectAll(".".concat(config_classes.chartArc)).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && !$$.hasMultiTargets() ? "".concat(Math.round($$.radius / 5), "px") : "";
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    });

    if (main.select(".".concat(config_classes.chartArcsTitle)).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          endAngle = (isFullCircle ? -4 : -1) * config.gauge_startingAngle;
      isFullCircle && text.attr("dy", "".concat(Math.round($$.radius / 14))), $$.arcs.select(".".concat(config_classes.chartArcsBackground)).attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: config.gauge_startingAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      }), $$.arcs.select(".".concat(config_classes.chartArcsGaugeUnit)).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select(".".concat(config_classes.chartArcsGaugeMin)).attr("dx", "".concat(-1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)), "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && $$.arcs.select(".".concat(config_classes.chartArcsGaugeMax)).attr("dx", "".concat($$.innerRadius + ($$.radius - $$.innerRadius) / 2, "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append("path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/shape/bar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  initBar: function initBar() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.main.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $$.mainBar = $$.main.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($$.mainBar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    return [(withTransition ? this.mainBar.transition(getRandom()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        tickInterval = axis.tickInterval($$.getMaxDataCount()),
        isGrouped = config.data_groups.length,
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.bar).concat(suffix));
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a".concat(radius, ",").concat(radius, " ").concat(isNegative ? "1 0 0" : "0 0 1", " ");
        pathRadius[+!isRotated] = "".concat(arc).concat(radius, ",").concat(radius), pathRadius[+isRotated] = "".concat(arc).concat([-radius, radius][isRotated ? "sort" : "reverse"]()), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H".concat(points[1][indexX] - radius, " ").concat(pathRadius[0], "V").concat(points[2][indexY] - radius, " ").concat(pathRadius[1], "H").concat(points[3][indexX]) : "V".concat(points[1][indexY] + (isNegative ? -radius : radius), " ").concat(pathRadius[0], "H").concat(points[2][indexX] - radius, " ").concat(pathRadius[1], "V").concat(points[3][indexY]);
      return "M".concat(points[0][indexX], ",").concat(points[0][indexY]).concat(path, "z");
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        axis = isSub ? $$.subXAxis : $$.xAxis,
        barTargetsNum = barIndices.__max__ + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list2 = slicedToArray_default()(list, 2),
        seg0 = _list2[0],
        seg1 = _list2[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/shape/bubble.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        cacheKey = "$baseLength",
        baseLength = $$.getCache(cacheKey);
    return baseLength || $$.addCache(cacheKey, baseLength = getMinMax("min", [$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = d.value * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  }
});
// CONCATENATED MODULE: ./src/shape/line.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  initLine: function initLine() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = $$.main.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      $$.main.selectAll(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(t.id))).selectAll("".concat(config_classes.selectedCircle)).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this;
    $$.mainLine = $$.main.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function (d) {
      return "".concat($$.classLine.bind($$)(d), " ").concat($$.extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    return [(withTransition ? this.mainLine.transition(getRandom()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? $$.subX : $$.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        lineTargetsNum = lineIndices.__max__ + 1,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineTargetsNum, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M".concat(points[0][0], ",").concat(points[0][1], "L").concat(points[1][0], ",").concat(points[1][1]);
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "M";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          style = isWithinRegions(data.x, regions);
      // Draw as normal
      if (isUndefined(regions) || !style) path += "".concat(_i ? "L" : "").concat(xValue(data), ",").concat(yValue(data));else {
        try {
          style = style.dasharray.split(" ");
        } catch (e) {
          style = dasharray.split(" ");
        } // Draw with region // TODO: Fix for horizotal charts


        xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
        var dx = x(data.x) - x(prevData.x),
            dy = y(data.value) - y(prevData.value),
            dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        diff = style[0] / dd, diffx2 = diff * style[1];

        for (var j = diff; j <= 1; j += diffx2) path += sWithRegion(prevData, data, j, diff), j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
      }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this;
    $$.data.targets.forEach(function (d) {
      var id = "".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id));

      if ($$.isAreaType(d) && $$.defs.select("#".concat(id)).empty()) {
        var color = $$.color(d),
            _$$$config$area_linea = $$.config.area_linearGradient,
            _$$$config$area_linea2 = _$$$config$area_linea.x,
            x = _$$$config$area_linea2 === void 0 ? [0, 0] : _$$$config$area_linea2,
            _$$$config$area_linea3 = _$$$config$area_linea.y,
            y = _$$$config$area_linea3 === void 0 ? [0, 1] : _$$$config$area_linea3,
            _$$$config$area_linea4 = _$$$config$area_linea.stops,
            stops = _$$$config$area_linea4 === void 0 ? [[0, color, 1], [1, color, 0]] : _$$$config$area_linea4,
            linearGradient = $$.defs.append("linearGradient").attr("id", "".concat(id)).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id), ")") : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this;
    $$.config.area_linearGradient && $$.updateAreaGradient(), $$.mainArea = $$.main.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this;
    return [(withTransition ? $$.mainArea.transition(getRandom()) : $$.mainArea).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return $$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity;
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        areaTargetsNum = areaIndices.__max__ + 1,
        x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  updateCircle: function updateCircle() {
    var $$ = this;
    $$.config.point_show && ($$.mainCircle = $$.main.selectAll(".".concat(config_classes.circles)).selectAll(".".concat(config_classes.circle)).data(function (d) {
      return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
    }), $$.mainCircle.exit().remove(), $$.mainCircle = $$.mainCircle.enter().append($$.point("create", this, $$.classCircle.bind($$), $$.pointR.bind($$), $$.color)).merge($$.mainCircle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$)));
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.main.selectAll(".".concat(config_classes.selectedCircle));
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.mainCircle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr("".concat(posAttr, "x"), cx).attr("".concat(posAttr, "y"), cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this;

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? $$.generateGetLinePoints($$.getShapeIndices($$.isLineType))(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.circles).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.circle).concat(suffix));
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(".concat(x, " ").concat(y, ") scale(").concat(scale, ")"));
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(".concat(r(circles) / $$.config.point_r, ")"));
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr("".concat(prefix, "x")),
        cy = +element.attr("".concat(prefix, "y"));

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    var is = Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
    return is;
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/shape/point.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = document.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.defs.select("#".concat(id));
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var point,
            id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        if (ids.indexOf(id) < 0 && ids.push(id), point = pattern[ids.indexOf(id) % pattern.length], $$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = "".concat($$.datetimeId, "-point-").concat(id),
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, cssClassFn, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#".concat(id)).attr("class", cssClassFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          yPosFn2 = function (d) {
        return yPosFn(d) - height / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = element.attr("x", xPosFn2)), mainCircles = element.transition(transitionName).attr("x", xPosFn2).attr("y", yPosFn2).transition(transitionName), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = element.attr("x", xPosFn2).attr("y", yPosFn2);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", cssClassFn).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && (mainCircles = mainCircles.attr("r", $$.pointR.bind($$))), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = mainCircles.attr("cx", xPosFn)), mainCircles = element.attr("cx") ? mainCircles.transition(transitionName).attr("cx", xPosFn).attr("cy", yPosFn).transition(transitionName) : mainCircles.attr("cx", xPosFn).attr("cy", yPosFn), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = mainCircles.attr("cx", xPosFn).attr("cy", yPosFn);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", cssClassFn).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          rectYPosFn = function (d) {
        return yPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = mainCircles.attr("x", rectXPosFn)), mainCircles = mainCircles.transition(transitionName).attr("x", rectXPosFn).attr("y", rectYPosFn).transition(transitionName), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = mainCircles.attr("x", rectXPosFn).attr("y", rectYPosFn);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/shape/radar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
extend(ChartInternal_ChartInternal.prototype, {
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min($$.arcWidth, $$.arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        _$$$getRadarSize2 = slicedToArray_default()(_$$$getRadarSize, 2),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize3 = $$.getRadarSize(),
        _$$$getRadarSize4 = slicedToArray_default()(_$$$getRadarSize3, 2),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        points = $$.getCache(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.addCache(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(duration, durationForExit) {
    var $$ = this,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), $$.main.selectAll(".".concat(config_classes.circles)).attr("transform", translate), $$.main.select(".".concat(config_classes.chartTexts)).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(duration, durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var $$ = this,
        points = $$.getCache(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize5 = $$.getRadarSize(),
        _$$$getRadarSize6 = slicedToArray_default()(_$$$getRadarSize5, 2),
        width = _$$$getRadarSize6[0],
        height = _$$$getRadarSize6[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll(".".concat(config_classes.level)).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.level, " ").concat(config_classes.level, "-").concat(i);
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(".concat(width - levelRatio[d], ", ").concat(height - levelRatio[d], ")");
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize7 = $$.getRadarSize(),
        _$$$getRadarSize8 = slicedToArray_default()(_$$$getRadarSize7, 2),
        width = _$$$getRadarSize8[0],
        height = _$$$getRadarSize8[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.axis, "-").concat(i);
    });
    config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show && axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
      selection.each(function (d) {
        setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d, [-1.2, 1.2]);
      });
    }).datum(function (d, i) {
      return {
        index: i
      };
    }).attr("transform", function (d, i) {
      return "translate(".concat($$.getRadarPosition("x", i, undefined, 1), " ").concat($$.getRadarPosition("y", i, undefined, 1), ")");
    }), $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config;

    if (config.interaction_enabled) {
      var isMouse = $$.inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select(".".concat(config_classes.axis)).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!$$.transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle($$.svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || $$.svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(duration, durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.getCache(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).transition().duration(duration).style("fill", function (d) {
      return $$.color(d);
    }).style("stroke", function (d) {
      return $$.color(d);
    }).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/internals/text.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartTexts), $$.mainText = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.main.select(".".concat(config_classes.chartTexts)).selectAll(".".concat(config_classes.chartText)).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $$.mainText = $$.main.selectAll(".".concat(config_classes.texts)).selectAll(".".concat(config_classes.text)).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").merge($$.mainText).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [this.mainText.each(function () {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x).attr("y", y).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$".concat(text.replace(/\W/g, "_")),
        rect = $$.getCache(cacheKey);
    return rect || ($$.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = v.node().getBoundingClientRect();
    }).remove(), $$.addCache(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet".concat(capitalize(v), "Points")](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = textElement.getBoundingClientRect(),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null && (xPos > $$.width ? xPos = $$.width - textElement.getBoundingClientRect().width : xPos < 0 && (xPos = 4)), isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + (config.data_labels_position.x || 0);
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = textElement.getBoundingClientRect(),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !$$.hasPositiveValue) yPos += rect.height, $$.isBarType(d) ? yPos -= baseY : !$$.isBarType(d) && (yPos += baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + (config.data_labels_position.y || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/type.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // defined chart types as category

var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
extend(ChartInternal_ChartInternal.prototype, {
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      $$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        types = $$.config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = $$.config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets) {
    var _this = this,
        exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    return !TYPES[type].filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/internals/grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

extend(ChartInternal_ChartInternal.prototype, {
  initGrid: function initGrid() {
    var $$ = this;
    $$.xgrid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]), $$.initGridLines(), $$.initXYFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.main.insert("g", ".".concat(config_classes.chart).concat(config.grid_lines_front ? " + *" : "")).attr("clip-path", $$.clipPathForGrid).attr("class", "".concat(config_classes.grid, " ").concat(config_classes.gridLines)), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), $$.xgridLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, $$.x),
        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0,
        pos = function (d) {
      return (($$.zoomScale || $$.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    $$.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": $$.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": $$.height
    }, $$.xgrid = $$.main.select(".".concat(config_classes.xgrids)).selectAll(".".concat(config_classes.xgrid)).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", config_classes.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys($$.xgridAttr).forEach(function (id) {
        grid.attr(id, $$.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? $$.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.y(d));
    };

    $$.ygrid = $$.main.select(".".concat(config_classes.ygrids)).selectAll(".".concat(config_classes.ygrid)).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", config_classes.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : $$.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? $$.height : pos), $$.smoothLines($$.ygrid, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this;
    // hide if arc type
    $$.gridLines || $$.initGridLines(), $$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden"), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select(".".concat(config_classes.xgridLines)).selectAll(".".concat(config_classes.xgridLine)).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = $$.xgridLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), $$.xgridLines.attr("class", function (d) {
      return "".concat(config_classes.xgridLine, " ").concat(d["class"] || "").trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select(".".concat(config_classes.ygridLines)).selectAll(".".concat(config_classes.ygridLine)).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = $$.ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);
    // update
    var yv = $$.yv.bind($$);
    $$.ygridLines.attr("class", function (d) {
      return "".concat(config_classes.ygridLine, " ").concat(d["class"] || "").trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : $$.width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, $$.width, $$.height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xv = $$.xv.bind($$),
        lines = $$.xgridLines.select("line"),
        texts = $$.xgridLines.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, $$.width, $$.height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initXYFocusGrid: function initXYFocusGrid() {
    var $$ = this,
        config = $$.config,
        isFront = config.grid_front,
        className = ".".concat(config_classes[isFront && $$.gridLines ? "gridLines" : "chart"]).concat(isFront ? " + *" : "");
    $$.grid = $$.main.insert("g", className).attr("clip-path", $$.clipPathForGrid).attr("class", config_classes.grid), config.grid_x_show && $$.grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && $$.grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus);
  },
  showXGridFocus: function showXGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        focusEl = $$.main.selectAll("line.".concat(config_classes.xgridFocus)),
        xx = $$.xx.bind($$);
    !config.tooltip_show || $$.hasType("bubble") || $$.hasType("scatter") || $$.hasArcType() || (focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(isRotated ? "y1" : "x1", xx).attr(isRotated ? "y2" : "x2", xx), $$.smoothLines(focusEl, "grid")); // Hide when bubble/scatter/stanford plot exists
  },
  hideXGridFocus: function hideXGridFocus() {
    this.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden");
  },
  updateXgridFocus: function updateXgridFocus() {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    $$.main.select("line.".concat(config_classes.xgridFocus)).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? $$.width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : $$.height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.main.select(".".concat(config_classes.axisX)).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date("".concat(i, "-01-01 00:00:00")));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line["class"] === param["class"]) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.main.select(".".concat(classLines)).selectAll(".".concat(classLine)).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_".concat(forX ? "x" : "y", "_lines");
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/tooltip.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($$.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $$.tooltip.empty() && ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $$.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$ = $$).getTooltipContent.apply(_$$, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return "".concat((ratio * 100).toFixed(2), "%");
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template;

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr);

    for (i = 0; row = d[i]; i++) if (getRowValue(row) || getRowValue(row) === 0) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">".concat(title, "</th></tr>") : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(toConsumableArray_default()(param)))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(toConsumableArray_default()(param))));
        }),
            _map2 = slicedToArray_default()(_map, 2),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> ".concat(value, " <b>High:</b> ").concat(high, " <b>Low:</b> ").concat(low);
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(toConsumableArray_default()(param)))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:".concat(color, "\" width=\"10\" height=\"10\"></rect></svg>"),
            NAME: name,
            VALUE: value
          };
          tplStr && isObject(contents.text) && Object.keys(contents.text).forEach(function (key) {
            contentValue[key] = contents.text[key][i];
          }), text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return "".concat(text, "</table>");
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">".concat(this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>", "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>")).replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        _d3Mouse2 = slicedToArray_default()(_d3Mouse, 2),
        left = _d3Mouse2[0],
        top = _d3Mouse2[1],
        svgLeft = $$.getSvgLeft(!0),
        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = $$.inputType === "touch" || $$.hasType("radar");
      raw || (top += $$.height / 2, left += ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = $$.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + ($$.zoomScale ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > $$.currentHeight && (top -= tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        positionFunction = config.tooltip_position || $$.tooltipPosition;

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = $$.tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          width = datum && datum.width || 0,
          height = datum && datum.height || 0;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$), $$.tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = $$.tooltip.property("offsetWidth"),
          height: height = $$.tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        // Get tooltip dimensions
        var position = positionFunction.call(this, dataToShow, width, height, element); // Set tooltip position

        $$.tooltip.style("top", "".concat(position.top, "px")).style("left", "".concat(position.left, "px"));
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config;
    (!config.tooltip_doNotHide || force) && (callFn(config.tooltip_onhide, $$), this.tooltip.style("display", "none").style("visibility", "hidden") // for IE9
    .datum(null), callFn(config.tooltip_onhidden, $$));
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this;

    if ($$.config.tooltip_linked) {
      var linkedName = $$.config.tooltip_linked_name;
      ($$.api.internal.charts || []).forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = document.body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/internals/legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config;
    $$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !$$.zoomScale), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $$.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.margin3 = {
      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - height,
      right: NaN,
      bottom: 0,
      left: $$.isLegendRight ? $$.currentWidth - width : $$.isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this;
    (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.legendItemHeight = h;
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight ? $$.currentHeight : Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.legend.selectAll(".".concat(config_classes.legendItem)).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Clear the LegendItemTextBox cache.
   * @private
   */
  clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
    this.legendItemTextBox = {};
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        isTouch = $$.inputType === "touch";
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        getTextBox = function (textElement, id) {
      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
    },
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = getTextBox(textElement, id),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    $$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : $$.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = $$.legend.selectAll(".".concat(config_classes.legendItem)).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = $$.config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), document.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#".concat($$.datetimeId, "-point-").concat(data) : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = $$.legend.select(".".concat(config_classes.legendBackground, " rect")), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", ".".concat(config_classes.legendItem)).attr("class", config_classes.legendBackground).append("rect"));
    var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = $$.legend.selectAll("rect.".concat(config_classes.legendItemEvent)).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = $$.legend.selectAll(".".concat(config_classes.legendItemPoint)).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = $$.config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = $$.legend.selectAll("line.".concat(config_classes.legendItemTile)).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/internals/title.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

var getTextPos = function () {
  var position,
      pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "left",
      width = arguments.length > 1 ? arguments[1] : undefined,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
};

extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this;

    if ($$.config.title_text) {
      $$.title = $$.svg.append("g");
      var text = $$.title.append("text").style("text-anchor", getTextPos($$.config.title_position)).attr("class", config_classes.title);
      setTextValue(text, $$.config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this;

    if ($$.title) {
      var y = $$.yForTitle.call($$);
      /g/i.test($$.title.node().tagName) ? $$.title.attr("transform", "translate(".concat(getTextPos($$.config.title_position, $$.currentWidth), ", ").concat(y, ")")) : $$.title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        position = config.title_position || "left";
    return /(right|center)/.test(position) ? (x = $$.currentWidth - $$.getTextRect($$.title, config_classes.title).width, position.indexOf("right") >= 0 ? x -= config.title_padding.right || 0 : position.indexOf("center") >= 0 && (x /= 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/clip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  initClip: function initClip() {
    var $$ = this; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist

    // Define 'clip-path' attribute values
    $$.clipId = "".concat($$.datetimeId, "-clip"), $$.clipIdForXAxis = "".concat($$.clipId, "-xaxis"), $$.clipIdForYAxis = "".concat($$.clipId, "-yaxis"), $$.clipIdForGrid = "".concat($$.clipId, "-grid"), $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(".concat(isIE9 ? "" : document.URL.split("#")[0], "#").concat(id, ")");
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    // axis line width + padding for left
    var left = Math.max(30, this.margin.left);
    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    return forHorizontal ? -20 : -this.margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        left = Math.max(30, $$.margin.left),
        right = Math.max(30, $$.margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    // less than 20 is not enough to show the axis label 'outer' without legend
    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/internals/region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection




extend(ChartInternal_ChartInternal.prototype, {
  initRegion: function initRegion() {
    var $$ = this;
    $$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config;
    // hide if arc type
    // select <g> element
    $$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select(".".concat(config_classes.regions)).selectAll(".".concat(config_classes.region)).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.mainRegion.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], pos = scale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, pos = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = $$[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], end = scale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, end = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// CONCATENATED MODULE: ./src/interactions/drag.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        main = $$.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _$$$dragStart = slicedToArray_default()($$.dragStart, 2),
            sx = _$$$dragStart[0],
            sy = _$$$dragStart[1],
            _mouse = slicedToArray_default()(mouse, 2),
            mx = _mouse[0],
            my = _mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

        main.select(".".concat(config_classes.dragarea)).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = shape.attr("cx") * 1,
                y = shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return;

          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select(".".concat(config_classes.chart)).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.main.select(".".concat(config_classes.dragarea)).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll(".".concat(config_classes.shape)).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(54);

// CONCATENATED MODULE: ./src/internals/selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this;
    // remove selected-circle from low layer g
    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = "".concat(selected ? "" : "un", "selectPoint");
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this["".concat(selected ? "" : "un", "selectPath")](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = ".".concat(config_classes.shapes);
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll(selector).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/interactions/subchart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = $$.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map($$.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && $$.context && $$.context.select(".".concat(config_classes.brush)).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return $$.context ? $$.context.select(".".concat(config_classes.brush)) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([]);
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = "".concat($$.clipId, "-subchart"),
        clipPath = $$.getClipPath(clipId);
    $$.clipIdForSubchart = clipId, $$.appendClip($$.defs, clipId), $$.initBrush(), $$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));
    var context = $$.context;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars), context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        context = $$.context,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var contextBarUpdate = context.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", classChartBar),
          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
      contextBarEnter.append("g").attr("class", classBars);
      // -- Line --//
      var contextLineUpdate = context.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", classChartLine),
          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll(".".concat(config_classes.brush, " rect")).attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this;
    $$.contextBar = $$.context.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this;
    $$.contextLine = $$.context.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this;
    $$.contextArea = $$.context.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.contextArea).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config;
    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw".concat(name)](shape.indices[v], !0);
      $$["update".concat(name, "ForSubchart")](duration), $$["redraw".concat(name, "ForSubchart")](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this;
    $$.redraw({
      withTransition: !1,
      withY: $$.config.zoom_rescale,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), $$.config.subchart_onbrush.call($$.api, $$.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select(".".concat(config_classes.axisX)), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        extent = $$.config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), $$.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return $$.subX($$.parseDate(v));
    }))), extent;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(55);

// CONCATENATED MODULE: ./src/interactions/zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.zoomScale = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent() {
    var bind = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0],
        $$ = this,
        zoomEnabled = $$.config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = $$.main.select(".".concat(config_classes.eventRects));
    zoomEnabled && bind ? $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      $$.orgXScale && $$.orgXScale.range($$.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"]($$.orgXScale || $$.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, $$.orgXDomain), $$.zoomScale = $$.getCustomizedScale(newScale), $$.xAxis.scale($$.zoomScale), rescale && (!$$.orgXScale && ($$.orgXScale = $$.x.copy()), $$.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0) {
      var isMousemove = event.sourceEvent.type === "mousemove",
          isZoomOut = event.sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && $$.x.domain().every(function (v, i) {
        return v !== $$.orgXDomain[i];
      }) && $$.x.domain($$.orgXDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && $$.x.orgDomain()[0] === $$.orgXDomain[0] && $$.x.domain([$$.orgXDomain[0] - 1e-10, $$.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, $$.zoomScale.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        startEvent = $$.zoom.startEvent;
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn($$.config.zoom_onzoomend, $$.api, $$[$$.zoomScale ? "zoomScale" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        _$$$orgXDomain = slicedToArray_default()($$.orgXDomain, 2),
        min = _$$$orgXDomain[0],
        max = _$$$orgXDomain[1];

    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this;

    if ($$.zoomScale) {
      var zoomDomain = $$.zoomScale.domain(),
          xDomain = $$.subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.xAxis.scale($$.subX), $$.x.domain($$.subX.orgDomain()), $$.zoomScale = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        zoomRect = null,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.main.append("rect").attr("clip-path", $$.clipPath).attr("class", config_classes.zoomBrush).attr("width", isRotated ? $$.width : 0).attr("height", isRotated ? 0 : $$.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.zoomScale || $$.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
            _ref3 = slicedToArray_default()(_ref2, 2),
            x = _ref3[0],
            y = _ref3[1],
            target = document.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.selectChart.append("div").classed(config_classes.button, !0).append("span").on("click", $$.api.unzoom.bind($$)).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/internals/color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = document.body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = document.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = window.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = "".concat($$.datetimeId, "-pattern-").concat(color, "-").concat(index);
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#".concat(p.id, ")");
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var color = colors[colors.length - 1];

      for (var v, val, i = 0; val = values[i]; i++) if (v = asValue ? value : value * 100 / max, v < val) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restore in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (d) {
      var id = d.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? $$.main.selectAll(".".concat(config_classes.arc, "-").concat(d.id)).style("fill", color(d)) : $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(function (d) {
      var val = color(d);
      this.style.stroke = val, this.style.fill = val;
    });
  }
});
// CONCATENATED MODULE: ./src/internals/format.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



var getFormat = function ($$, typeValue, v) {
  var config = $$.config,
      type = "axis_".concat(typeValue, "_tick_format"),
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
};

extend(ChartInternal_ChartInternal.prototype, {
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        formatForY = $$.yFormat,
        formatForY2 = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return "".concat((ratio * 100).toFixed(1), "%");
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/internals/cache.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  addCache: function addCache(key, value) {
    var isDataType = !!(arguments.length > 2 && arguments[2] !== undefined) && arguments[2];
    this.cache[key] = isDataType ? this.cloneTarget(value) : value;
  },

  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  removeCache: function removeCache(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  },

  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  getCache: function getCache(key) {
    var isDataType = !!(arguments.length > 1 && arguments[1] !== undefined) && arguments[1];

    if (isDataType) {
      var targets = [];

      for (var id, i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  },

  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  resetCache: function resetCache(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
});
// CONCATENATED MODULE: ./src/internals/class.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  generateClass: function generateClass(prefix, targetId) {
    return " ".concat(prefix, " ").concat(prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return "".concat(this.generateClass(config_classes.region, i), " ").concat("class" in d ? d["class"] : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " ".concat(config_classes.target, "-").concat(additionalClassSuffix)), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " ".concat(this.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " ".concat(this.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? "-".concat(targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return "".concat(prefix || "", ".").concat(config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return ".".concat(config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/api/api.focus.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && $$.expandArc(targetIds), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && $$.unexpandArc(targetIds), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), $$.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/api/api.show.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Show/Hide data series
   * @private
   */
  _showHide: function _showHide(show, targetIdsValue, options) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue);
    $$["".concat(show ? "remove" : "add", "HiddenTargetIds")](targetIds);
    var targets = $$.svg.selectAll($$.selectorTargets(targetIds)),
        opacity = show ? "1" : "0";
    targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
      targets.style("opacity", null).style("opacity", opacity);
    }), options.withLegend && $$["".concat(show ? "show" : "hide", "Legend")](targetIds), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    });
  },

  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds) {
    var _this = this,
        options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };

    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/api/api.zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

var withinRange = function (domain, range) {
  var _range = slicedToArray_default()(range, 2),
      min = _range[0],
      max = _range[1];

  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
},
    api_zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      domain = domainValue;

  if ($$.config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), $$.config.subchart_show) {
      var xScale = $$.zoomScale || $$.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else $$.x.domain(domain), $$.zoomScale = $$.x, $$.xAxis.scale($$.zoomScale), resultDomain = $$.zoomScale.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: $$.config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn($$.config.zoom_onzoom, resultDomain);
  } else resultDomain = $$.zoomScale ? $$.zoomScale.domain() : $$.x.orgDomain();

  return resultDomain;
};
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


extend(api_zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoomenable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "wheel",
        $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoommax
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [$$.orgXDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoommin
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [$$.orgXDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoomrange
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range2) {
    var zoom = this.zoom;

    if (isObject(_range2)) {
      var min = _range2.min,
          max = _range2.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
}), extend(Chart_Chart.prototype, {
  zoom: api_zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.zoomScale) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.main.select(".".concat(config_classes.eventRects));
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/api/api.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set 'json' if loading JSON via data.url.<br>@see [dataheaders](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [datakeys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [datamimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json"
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.removeCache(ids), args.done && args.done();
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(56);

// CONCATENATED MODULE: ./src/api/api.flow.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(Chart_Chart.prototype, {
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [datajson](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [datarows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [datacolumns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
}), extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $$.xgrid || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          xgridLines = $$.xgridLines || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainRegion = $$.mainRegion || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainText = $$.mainText || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainBar = $$.mainBar || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainLine = $$.mainLine || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainArea = $$.mainArea || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainCircle = $$.mainCircle || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);

      $$.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(".concat(translateX, ",0) scale(").concat(scaleX, ",1)");
      $$.hideXGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.axes.x.transition(gt).call(function (g) {
        return $$.xAxis.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var shapes = [],
            texts = [],
            eventRects = [];

        // remove flowed elements
        if (flowLength) {
          for (var index, i = 0; i < flowLength; i++) index = flowIndex + i, shapes.push(".".concat(config_classes.shape, "-").concat(index)), texts.push(".".concat(config_classes.text, "-").concat(index)), eventRects.push(".".concat(config_classes.eventRect, "-").concat(index));

          $$.svg.selectAll(".".concat(config_classes.shapes)).selectAll(shapes).remove(), $$.svg.selectAll(".".concat(config_classes.texts)).selectAll(texts).remove(), $$.svg.selectAll(".".concat(config_classes.eventRects)).selectAll(eventRects).remove(), $$.svg.select(".".concat(config_classes.xgrid)).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv), xgridLines.select("text").attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
      });
    };
  }
});
// CONCATENATED MODULE: ./src/api/api.selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.main.selectAll(".".concat(config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll(".".concat(config_classes.shape)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/api/api.transform.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Change the type of the chart.
 * @private
 * @param {String|Array} targetIds
 * @param {String} type
 * @param {Object} optionsForRedraw
 */

function transformTo(targetIds, type, optionsForRedraw) {
  var $$ = this,
      options = optionsForRedraw || {
    withTransitionForAxis: !$$.hasArcType()
  };
  // this is needed when transforming to arc
  options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
}

extend(Chart_Chart.prototype, {
  /**
   * Change the type of the chart.
   * @method transform
   * @instance
   * @memberof Chart
   * @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
   * @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
   * @example
   *  // all targets will be bar chart.
   *  chart.transform("bar");
   *
   *  // only data1 will be bar chart.
   *  chart.transform("bar", "data1");
   *
   *  // only data1 and data2 will be bar chart.
   *  chart.transform("bar", ["data1", "data2"]);
   */
  transform: function transform(type, targetIds) {
    var $$ = this.internal,
        options = ["pie", "donut"].indexOf(type) >= 0 ? {
      withTransform: !0
    } : null;
    transformTo.bind($$)(targetIds, type, options);
  }
});
// CONCATENATED MODULE: ./src/api/api.group.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/api/api.grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

var xgrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
};

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */
var ygrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
};

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
}), extend(Chart_Chart.prototype, {
  xgrids: xgrids,
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/api/api.region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

var api_region_regions = function (_regions) {
  var $$ = this.internal,
      config = $$.config;
  return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), _regions) : config.regions;
};

extend(api_region_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regionsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regionsremove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.main.select(".".concat(config_classes.regions)).selectAll(classes.map(function (c) {
      return ".".concat(c);
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region["class"] || (region["class"].split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
}), extend(Chart_Chart.prototype, {
  regions: api_region_regions
});
// CONCATENATED MODULE: ./src/api/api.data.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

var api_data_data = function (targetIds) {
  var targets = this.internal.data.targets;
  return isUndefined(targetIds) ? targets : targets.filter(function (t) {
    return targetIds.indexOf(t.id) >= 0;
  });
};

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method datashown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method datavalues
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId) {
    var flat = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        values = null;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method datanames
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method datacolors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * @method dataaxes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method datamin
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method datamax
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
}), extend(Chart_Chart.prototype, {
  data: api_data_data
});
// CONCATENATED MODULE: ./src/api/api.category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/api/api.color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/api/api.x.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? $$.api.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? $$.api.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// CONCATENATED MODULE: ./src/api/api.axis.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

var setMinMax = function ($$, type, value) {
  var config = $$.config,
      axisX = "axis_x_".concat(type),
      axisY = "axis_y_".concat(type),
      axisY2 = "axis_y2_".concat(type);
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config[axisX] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
},
    api_axis_getMinMax = function ($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_".concat(type)],
    y: config["axis_y_".concat(type)],
    y2: config["axis_y2_".concat(type)]
  };
},
    api_axis_axis = extend(function () {}, {
  /**
   * Get and set axis labels.
   * @method axislabels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axismin
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "min", _min) : api_axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axismax
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : api_axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axisrange
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
});
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


extend(Chart_Chart.prototype, {
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/api/api.legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define legend
 * @ignore
 */

var legend = extend(function () {}, {
  /**
   * Show legend for each target.
   * @method legendshow
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legendhide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
});
extend(Chart_Chart.prototype, {
  legend: legend
});
// CONCATENATED MODULE: ./src/api/api.chart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(Chart_Chart.prototype, {
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @param {Boolean} [isFromResize] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, isFromResize) {
    var $$ = this.internal; // reset possible zoom scale

    isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.zoomScale = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    });
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $$.svg.select("*").interrupt(), isDefined($$.resizeTimeout) && browser["window"].clearTimeout($$.resizeTimeout), browser["window"].removeEventListener("resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function config(name, value, redraw) {
    var res,
        $$ = this.internal,
        key = name && name.replace(/\./g, "_");
    return key in $$.config && (isDefined(value) ? ($$.config[key] = value, res = value, redraw && this.flush()) : res = $$.config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/api/api.tooltip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define tooltip
 * @ignore
 */

var tooltip = extend(function () {}, {
  /**
   * Show tooltip
   * @method tooltipshow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted x Axis element.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: Axis id. 'y' or 'y2'(default 'y')<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate relative the x Axis element.
   *  chart.tooltip.show({
   *    data: {x: 2},
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show() {
    var index,
        mouse,
        args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        $$ = this.internal;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.x(args.data.x), y] : (!$$.config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    ($$.inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltiphide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideXGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
});
extend(Chart_Chart.prototype, {
  tooltip: tooltip
});
// CONCATENATED MODULE: ./src/api/api.export.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode("0x".concat(p));
  }));
},
    nodeToSvgDataUrl = function (node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(document.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = document.createElement("style"); // escape css for XML

  style.appendChild(document.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = "<svg xmlns=\"".concat(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, "\" width=\"").concat(size.width, "\" height=\"").concat(size.height, "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t").concat(styleXml, "\n\t\t\t\t").concat(nodeXml.replace(/(url\()[^#]+/g, "$1"), "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64,".concat(b64EncodeUnicode(dataStr));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @return {String}
 * @private
 */


extend(Chart_Chart.prototype, {
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  "export": function _export(mimeType, callback) {
    var $$ = this.internal,
        size = {
      width: $$.currentWidth,
      height: $$.currentHeight
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (isFunction(callback)) {
      var img = new Image();
      img.crosssOrigin = "Anonymous", img.onload = function () {
        var canvas = document.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// EXTERNAL MODULE: ./src/scss/billboard.scss
var billboard = __webpack_require__(57);

// CONCATENATED MODULE: ./src/core.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */






















































 // base CSS


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "1.9.2",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {},

  /**
   * Internal chart object
   * @private
   */
  chart: {
    fn: Chart_Chart.prototype,
    internal: {
      fn: ChartInternal_ChartInternal.prototype,
      axis: {
        fn: Axis_Axis.prototype
      }
    }
  }
};
/**
 * @namespace bb
 * @version 1.9.2
 */


/* harmony default export */ var core = __webpack_exports__["default"] = (bb);

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1NvY2tKU0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9CYXNlQ2xpZW50LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJjb21tb25qczJcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJhbWRcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNlbGVjdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy1zZWxlY3Rpb25cIixcImFtZFwiOlwiZDMtc2VsZWN0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRyYW5zaXRpb25cIixcImNvbW1vbmpzMlwiOlwiZDMtdHJhbnNpdGlvblwiLFwiYW1kXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWF4aXNcIixcImNvbW1vbmpzMlwiOlwiZDMtYXhpc1wiLFwiYW1kXCI6XCJkMy1heGlzXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYnJ1c2hcIixcImNvbW1vbmpzMlwiOlwiZDMtYnJ1c2hcIixcImFtZFwiOlwiZDMtYnJ1c2hcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2NhbGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2NhbGVcIixcImFtZFwiOlwiZDMtc2NhbGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRzdlwiLFwiY29tbW9uanMyXCI6XCJkMy1kc3ZcIixcImFtZFwiOlwiZDMtZHN2XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRyYWdcIixcImNvbW1vbmpzMlwiOlwiZDMtZHJhZ1wiLFwiYW1kXCI6XCJkMy1kcmFnXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNoYXBlXCIsXCJjb21tb25qczJcIjpcImQzLXNoYXBlXCIsXCJhbWRcIjpcImQzLXNoYXBlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWludGVycG9sYXRlXCIsXCJjb21tb25qczJcIjpcImQzLWludGVycG9sYXRlXCIsXCJhbWRcIjpcImQzLWludGVycG9sYXRlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWNvbG9yXCIsXCJjb21tb25qczJcIjpcImQzLWNvbG9yXCIsXCJhbWRcIjpcImQzLWNvbG9yXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXpvb21cIixcImNvbW1vbmpzMlwiOlwiZDMtem9vbVwiLFwiYW1kXCI6XCJkMy16b29tXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWVhc2VcIixcImNvbW1vbmpzMlwiOlwiZDMtZWFzZVwiLFwiYW1kXCI6XCJkMy1lYXNlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz8yZmZlIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2JpbGxib2FyZC5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jbGFzc2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXhpcy9BeGlzUmVuZGVyZXJIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F4aXMvQXhpc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9heGlzL0F4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9DaGFydEludGVybmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9kb21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmNvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZGF0YS5sb2FkLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2F0ZWdvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL3NoYXBlLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL2Jhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvYnViYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9saW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvcmFkYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy90ZXh0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy90b29sdGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvbGVnZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9jbGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvcmVnaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmFjdGlvbnMvZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJhY3Rpb25zL3N1YmNoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmFjdGlvbnMvem9vbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2NvbG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvZm9ybWF0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5zaG93LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkubG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5mbG93LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5yZWdpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5jYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS54LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmF4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkubGVnZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmNoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnRvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZXhwb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlLmpzIl0sIm5hbWVzIjpbIndpbiIsImRlZiIsIm8iLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIiwiZG9jIiwiZG9jdW1lbnQiLCJpc01vYmlsZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJhcmMiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRMaW5lIiwieWdyaWRMaW5lcyIsInlncmlkcyIsInpvb21CcnVzaCIsInpvb21SZWN0IiwiRVhQQU5ERUQiLCJTRUxFQ1RFRCIsIklOQ0xVREVEIiwiaXNWYWx1ZSIsInYiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNCb29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiT2JqZWN0Iiwia2V5cyIsImlzTmFOIiwibm90RW1wdHkiLCJpc0FycmF5IiwiYXJyIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImlzT2JqZWN0Iiwib2JqIiwibm9kZVR5cGUiLCJnZXRPcHRpb24iLCJvcHRpb25zIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaGFzVmFsdWUiLCJkaWN0IiwidmFsdWUiLCJmb3VuZCIsImZvckVhY2giLCJjYWxsRm4iLCJmbiIsImlzRm4iLCJhcmdzIiwiY2FsbCIsInNhbml0aXNlIiwic3RyIiwicmVwbGFjZSIsInNldFRleHRWYWx1ZSIsIm5vZGUiLCJkeSIsImRpZmYiLCJtYXAiLCJtdWx0aWxpbmUiLCJzcGxpdCIsImh0bWwiLCJpIiwiYXBwZW5kIiwiYXR0ciIsImdldFJlY3RTZWdMaXN0IiwicGF0aCIsImdldEJCb3giLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0UGF0aEJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIml0ZW1zIiwibWluIiwiZ2V0QnJ1c2hTZWxlY3Rpb24iLCJjdHgiLCJzZWxlY3Rpb24iLCJldmVudCIsImQzRXZlbnQiLCJtYWluIiwiY29udGV4dCIsIm5hbWUiLCJzZWxlY3QiLCJDTEFTUyIsImQzQnJ1c2hTZWxlY3Rpb24iLCJnZXRSYW5kb20iLCJhc1N0ciIsInJhbmRvbSIsImJydXNoRW1wdHkiLCJleHRlbmQiLCJzb3VyY2UiLCJwIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0FycmF5IiwiZ2V0Q3NzUnVsZXMiLCJzdHlsZVNoZWV0cyIsInJ1bGVzIiwic2hlZXQiLCJjc3NSdWxlcyIsImNvbmNhdCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJocmVmIiwidG9TdHJpbmciLCJnZXRVbmlxdWUiLCJkYXRhIiwiZmlsdGVyIiwibWVyZ2VBcnJheSIsInJlZHVjZSIsImMiLCJtZXJnZU9iaiIsIm9iamVjdE4iLCJzaGlmdCIsInNvcnRWYWx1ZSIsImlzQXNjIiwiYSIsImIiLCJldmVyeSIsIk51bWJlciIsInNvcnQiLCJnZXRNaW5NYXgiLCJ0eXBlIiwicmVzIiwidW5kZWZpbmVkIiwiZ2V0UmFuZ2UiLCJzdGFydCIsImVuZCIsInB1c2giLCJzZW5kU3RhdHMiLCJsb2NhbFN0b3JhZ2UiLCJ1cmwiLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwidCIsImxhc3QiLCJnZXRJdGVtIiwiZXhwaXJlIiwic2V0SXRlbSIsInNlbmRCZWFjb24iLCJJbWFnZSIsInNyYyIsInN0eWxlIiwiZGlzcGxheSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiZW11bGF0ZUV2ZW50IiwibW91c2UiLCJnZXRQYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZUV2ZW50IiwiZWwiLCJldmVudFR5cGUiLCJwYXJhbXMiLCJkaXNwYXRjaEV2ZW50IiwibW91c2VFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ0b3VjaCIsInRvdWNoT2JqIiwiVG91Y2giLCJhc3NpZ24iLCJpZGVudGlmaWVyIiwibm93IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbkFuZ2xlIiwiZm9yY2UiLCJUb3VjaEV2ZW50Iiwic2hpZnRLZXkiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidHBsUHJvY2VzcyIsInRwbCIsIlJlZ0V4cCIsIkF4aXNSZW5kZXJlckhlbHBlciIsImNvbmZpZyIsInNjYWxlIiwiZDNTY2FsZUxpbmVhciIsIm5vVHJhbnNpdGlvbiIsInRyYW5zaXRpb25fZHVyYXRpb24iLCJ3aXRob3V0VHJhbnNpdGlvbiIsInJhbmdlIiwicmFuZ2VFeHRlbnQiLCJzY2FsZUV4dGVudCIsIm9yZ1hTY2FsZSIsInRpY2tPZmZzZXQiLCJkb21haW4iLCJzdG9wIiwidGlja3MiLCJ0aWNrQXJndW1lbnRzIiwicm91bmQiLCJ1bnNoaWZ0IiwibmV3U2NhbGUiLCJjb3B5IiwidGlja0Zvcm1hdCIsInRlc3QiLCJmb3JtYXR0ZWQiLCJpbnRlcnJ1cHQiLCJ0cmFuc2l0aW9uIiwic2l6ZSIsInciLCJoIiwiZ2V0U2l6ZUZvcjFDaGFyIiwiQXhpc1JlbmRlcmVyIiwiaW5uZXJUaWNrU2l6ZSIsIm91dGVyVGlja1NpemUiLCJvdXRlclRpY2siLCJvcmllbnQiLCJ0aWNrQ2VudGVyZWQiLCJ0aWNrQ3VsbGluZyIsInRpY2tMZW5ndGgiLCJ0aWNrUGFkZGluZyIsInRpY2tWYWx1ZXMiLCJtYXgiLCJoZWxwZXIiLCJIZWxwZXIiLCJnIiwiaGVscGVySW5zdCIsInNwbGl0VGlja1RleHQiLCJiaW5kIiwiaXNMZWZ0UmlnaHQiLCJpc1RvcEJvdHRvbSIsInRpY2tUcmFuc2Zvcm0iLCJheGlzUHgiLCJzaWduIiwicm90YXRlIiwidGlja1RleHRSb3RhdGUiLCJ0aWNrVGV4dFBvcyIsInByZWZpeCIsImF4aXNTaG93IiwidGlja1Nob3ciLCJ0aWNrIiwiJGciLCJlYWNoIiwiZDNTZWxlY3QiLCJzY2FsZTAiLCJfX2NoYXJ0X18iLCJzY2FsZTEiLCJjb3B5U2NhbGUiLCJpc0NhdGVnb3J5Iiwic2VsZWN0QWxsIiwiZW50ZXIiLCJtZXJnZSIsInRyYW5zaXRpb25pc2UiLCJvdXRlclRpY2tTaXplZCIsImdlbmVyYXRlVGlja3MiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJ0aWNrRXhpdCIsImV4aXQiLCJyZW1vdmUiLCJzaXplRm9yMUNoYXIiLCJjb3VudHMiLCJ0c3BhbiIsImluZGV4IiwidGlja011bHRpbGluZSIsInRleHRGb3JtYXR0ZWQiLCJzcGxpdHRlZCIsImR4Iiwic2luIiwiUEkiLCJsaW5lVXBkYXRlIiwidGV4dFVwZGF0ZSIsInNldFRpY2tMaW5lVGV4dFBvc2l0aW9uIiwidGlja1RpdGxlIiwiYmFuZHdpZHRoIiwicG9zIiwidGlja1Bvc2l0aW9uIiwidGlja1BvcyIsImdldFRpY2tYWSIsImdldFRpY2tTaXplIiwiciIsImNoYXJXaWR0aCIsInN1YnRleHQiLCJzcGFjZUluZGV4IiwidGV4dFdpZHRoIiwic3Vic3RyIiwidGlja1dpZHRoIiwidGlja1RleHQiLCJhcmd1bWVudHMiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJmb3JtYXQiLCJpc0NlbnRlcmVkIiwiaW50ZXJ2YWwiLCJnZXRUb3RhbExlbmd0aCIsIkluZmluaXR5IiwiY3VsbGluZyIsImlzSG9yaXpvbnRhbCIsIiQkIiwiZm9ySG9yaXpvbnRhbCIsImlzUm90YXRlZCIsImF4aXNfcm90YXRlZCIsImdldEF4aXNDbGFzc05hbWUiLCJpZCIsIkF4aXMiLCJvd25lciIsInNldE9yaWVudCIsImF4aXNfeTJfc2hvdyIsImF4ZXNMaXN0IiwiY2xhc3NBeGlzIiwiY2xhc3NMYWJlbCIsImF4ZXMiLCJjbGlwUGF0aEZvclhBeGlzIiwiYXhpc195X2lubmVyIiwiY2xpcFBhdGhGb3JZQXhpcyIsImdldFRyYW5zbGF0ZSIsInRleHRBbmNob3JGb3JYQXhpc0xhYmVsIiwiZ2VuZXJhdGVBeGVzIiwieUlubmVyIiwieTJJbm5lciIsImF4aXNfeTJfaW5uZXIiLCJ4T3JpZW50IiwieU9yaWVudCIsInkyT3JpZW50Iiwic3ViWE9yaWVudCIsImQzQXhpcyIsImF4ZXNDb25maWciLCJkM0F4aXNMZWZ0IiwiZDNBeGlzQm90dG9tIiwiZDNBeGlzVG9wIiwiZDNBeGlzUmlnaHQiLCJjb3VudCIsInZhbHVlcyIsInRpY2tTaXplT3V0ZXIiLCJvdXRlciIsImF4aXNSYW5nZSIsImNsYXNzTmFtZSIsInhBeGlzIiwibm9UaWNrVGV4dFJvdGF0ZSIsImlzQ2F0ZWdvcml6ZWQiLCJ4QXhpc1RpY2tGb3JtYXQiLCJ4QXhpc1RpY2tWYWx1ZXMiLCJheGlzUGFyYW1zIiwiYXhpc194X3RpY2tfbXVsdGlsaW5lIiwiYXhpc194X3RpY2tfd2lkdGgiLCJheGlzX3hfdGlja19yb3RhdGUiLCJheGlzX3hfdGlja190b29sdGlwIiwiYXBpIiwiY2F0ZWdvcmllcyIsInpvb21TY2FsZSIsIm5ld1RpY2tWYWx1ZXMiLCJpc1RpbWVTZXJpZXMiLCJwYXJzZURhdGUiLCJheGlzX3hfdGlja19jZW50ZXJlZCIsImF4aXNfeF90aWNrX2N1bGxpbmciLCJheGlzX3hfdGlja19jb3VudCIsImF4aXNfeV90aWNrX3JvdGF0ZSIsImlzU3RhY2tOb3JtYWxpemVkIiwiaXNUaW1lU2VyaWVzWSIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJ0YXJnZXRzIiwiZml0IiwiYXhpc194X3RpY2tfZml0IiwiZ2VuZXJhdGVUaWNrVmFsdWVzIiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJzdWJYQXhpcyIsImRhdGFfYXhlcyIsImF4aXNfeF90aWNrX2Zvcm1hdCIsImRhdGUiLCJheGlzVGltZUZvcm1hdCIsImRlZmF1bHRBeGlzVGltZUZvcm1hdCIsImNhdGVnb3J5TmFtZSIsInRvRml4ZWQiLCJhcHBseSIsImdldFRpY2tWYWx1ZXMiLCJvcHRpb24iLCJnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldExhYmVsUG9zaXRpb24iLCJnZXRMYWJlbFRleHQiLCJhbmNob3IiLCJ4Rm9yQXhpc0xhYmVsIiwiZ2V0WEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WUF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbiIsImR4Rm9yQXhpc0xhYmVsIiwieEhlaWdodCIsImF4aXNfeF9oZWlnaHQiLCJnZXRNYXhUaWNrV2lkdGgiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwid2l0aG91dFJlY29tcHV0ZSIsImN1cnJlbnRUaWNrTWF4IiwiY3VycmVudE1heFRpY2tXaWR0aHMiLCJtYXhXaWR0aCIsInN2ZyIsImlzWUF4aXMiLCJ0YXJnZXRzVG9TaG93IiwiZmlsdGVyVGFyZ2V0c1RvU2hvdyIsImdldEZyb20iLCJ0aWNrQ291bnQiLCJ1cGRhdGVYQXhpc1RpY2tWYWx1ZXMiLCJkdW1teSIsInNlbGVjdENoYXJ0IiwiY3JlYXRlIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJYIiwiWSIsIlkyIiwiYXhpc0xhYmVsIiwicGFkZGluZyIsImRvbWFpbkxlbmd0aCIsInVuaXQiLCJjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyIsInBpeGVscyIsImZvclRpbWVTZXJpZXMiLCJ0aWNrVmFsdWUiLCJ0YXJnZXRDb3VudCIsImR1cmF0aW9uIiwiYXhpc1N1YlgiLCJ0cmFuc2l0aW9ucyIsImlzSGlkZGVuIiwiaXNJbml0Iiwib3BhY2l0eSIsInRvTG93ZXJDYXNlIiwidXBkYXRlQXhlcyIsIkNoYXJ0SW50ZXJuYWwiLCJnZXRPcHRpb25zIiwiY2FjaGUiLCJzdGF0cyIsImNhbGxQbHVnaW5Ib29rIiwib25iZWZvcmVpbml0Iiwib25hZnRlcmluaXQiLCJpbml0UGFyYW1zIiwiY29udmVydGVkRGF0YSIsImNvbnZlcnREYXRhIiwiaW5pdFdpdGhEYXRhIiwiZGF0ZXRpbWVJZCIsImluaXRDbGlwIiwiZHJhZ1N0YXJ0IiwiZHJhZ2dpbmciLCJmbG93aW5nIiwiY2FuY2VsQ2xpY2siLCJtb3VzZW92ZXIiLCJ0cmFuc2l0aW5nIiwiY29sb3IiLCJnZW5lcmF0ZUNvbG9yIiwibGV2ZWxDb2xvciIsImdlbmVyYXRlTGV2ZWxDb2xvciIsInBvaW50IiwiZ2VuZXJhdGVQb2ludCIsImV4dHJhTGluZUNsYXNzZXMiLCJnZW5lcmF0ZUV4dHJhTGluZUNsYXNzIiwiZGF0YVRpbWVGb3JtYXQiLCJkYXRhX3hMb2NhbHRpbWUiLCJkM1RpbWVQYXJzZSIsImQzVXRjUGFyc2UiLCJheGlzX3hfbG9jYWx0aW1lIiwiZDNUaW1lRm9ybWF0IiwiZDNVdGNGb3JtYXQiLCJpc0RyYWdab29tIiwiem9vbV9lbmFibGVkIiwiaXNab29tZWQiLCJvcmdEb21haW4iLCJzcGVjaWZpZXIiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsImlzTGVnZW5kUmlnaHQiLCJsZWdlbmRfcG9zaXRpb24iLCJpc0xlZ2VuZEluc2V0IiwiaXNMZWdlbmRUb3AiLCJsZWdlbmRfaW5zZXRfYW5jaG9yIiwiaXNMZWdlbmRMZWZ0IiwibGVnZW5kU3RlcCIsImxlZ2VuZEl0ZW1XaWR0aCIsImxlZ2VuZEl0ZW1IZWlnaHQiLCJ5MiIsInJvdGF0ZWRfcGFkZGluZ19sZWZ0Iiwicm90YXRlZF9wYWRkaW5nX3JpZ2h0IiwiYXhpc194X3Nob3ciLCJyb3RhdGVkX3BhZGRpbmdfdG9wIiwid2l0aG91dEZhZGVJbiIsImlucHV0VHlwZSIsImNvbnZlcnRJbnB1dFR5cGUiLCJzdWJ4IiwiZDNTZWxlY3RBbGwiLCJpbml0Wm9vbSIsImJpbmR0byIsImVsZW1lbnQiLCJjbGFzc25hbWUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NlZCIsInhzIiwiY29udmVydERhdGFUb1RhcmdldHMiLCJkYXRhX2ZpbHRlciIsImRhdGFfaGlkZSIsImFkZEhpZGRlblRhcmdldElkcyIsIm1hcFRvSWRzIiwibGVnZW5kX2hpZGUiLCJhZGRIaWRkZW5MZWdlbmRJZHMiLCJoYXNUeXBlIiwibGVnZW5kX3Nob3ciLCJ1cGRhdGVTaXplcyIsInVwZGF0ZVNjYWxlcyIsImdldFhEb21haW4iLCJzdWJYIiwib3JnWERvbWFpbiIsImdldFlEb21haW4iLCJzdWJZIiwic3ViWTIiLCJpbnRlcmFjdGlvbl9lbmFibGVkIiwiaXNUb3VjaCIsIm9uIiwib25vdmVyIiwib25vdXQiLCJzdmdfY2xhc3NuYW1lIiwiZGVmcyIsImNsaXBDaGFydCIsImFwcGVuZENsaXAiLCJjbGlwSWQiLCJjbGlwWEF4aXMiLCJjbGlwSWRGb3JYQXhpcyIsImNsaXBZQXhpcyIsImNsaXBJZEZvcllBeGlzIiwiY2xpcEdyaWQiLCJjbGlwSWRGb3JHcmlkIiwiY29sb3JfdGlsZXMiLCJwYXR0ZXJucyIsInVwZGF0ZVN2Z1NpemUiLCJzdWJjaGFydF9zaG93IiwiaW5pdFN1YmNoYXJ0IiwiaW5pdFRvb2x0aXAiLCJpbml0TGVnZW5kIiwiaW5pdFRpdGxlIiwiZGF0YV9lbXB0eV9sYWJlbF90ZXh0IiwiaW5pdFJlZ2lvbiIsImNsaXBQYXRoIiwiaW5pdCIsImluaXRFdmVudFJlY3QiLCJpbml0Q2hhcnRFbGVtZW50cyIsImluaXRHcmlkIiwiem9vbV9wcml2aWxlZ2VkIiwidXBkYXRlVGFyZ2V0cyIsInVwZGF0ZURpbWVuc2lvbiIsIm9uaW5pdCIsInJlZHJhdyIsIndpdGhUcmFuc2Zvcm0iLCJ3aXRoVXBkYXRlWERvbWFpbiIsIndpdGhVcGRhdGVPcmdYRG9tYWluIiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwiaW5pdGlhbGl6aW5nIiwiZGF0YV9vbm1pbiIsImRhdGFfb25tYXgiLCJtaW5NYXgiLCJnZXRNaW5NYXhEYXRhIiwiYmluZFJlc2l6ZSIsImRhdGFfbGFiZWxzIiwiaW5pdFRleHQiLCJsZWdlbmQiLCJtYWluQmFyIiwibWFpbkxpbmUiLCJtYWluQXJlYSIsIm1haW5DaXJjbGUiLCJtYWluVGV4dCIsIngxIiwieDIiLCJ5MSIsImhhc0FyYyIsImhhc0FyY1R5cGUiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsImxlZ2VuZEhlaWdodEZvckJvdHRvbSIsInhBeGlzSGVpZ2h0IiwiZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQiLCJzdWJjaGFydFhBeGlzSGVpZ2h0Iiwic3ViY2hhcnRfYXhpc194X3Nob3ciLCJzdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3ciLCJzdWJjaGFydEhlaWdodCIsInN1YmNoYXJ0X3NpemVfaGVpZ2h0Iiwic2V0Q29udGFpbmVyU2l6ZSIsIm1hcmdpbiIsImdldEN1cnJlbnRQYWRkaW5nVG9wIiwiZ2V0Q3VycmVudFBhZGRpbmdSaWdodCIsImdldEN1cnJlbnRQYWRkaW5nQm90dG9tIiwiZ2V0Q3VycmVudFBhZGRpbmdMZWZ0IiwibWFyZ2luMiIsIk5hTiIsImN1cnJlbnRIZWlnaHQiLCJtYXJnaW4zIiwidXBkYXRlU2l6ZUZvckxlZ2VuZCIsImN1cnJlbnRXaWR0aCIsIndpZHRoMiIsImhlaWdodDIiLCJhcmNXaWR0aCIsImFyY0hlaWdodCIsImdhdWdlX2Z1bGxDaXJjbGUiLCJnZXRHYXVnZUxhYmVsSGVpZ2h0IiwidXBkYXRlUmFkaXVzIiwicmFkaXVzRXhwYW5kZWQiLCJ1cGRhdGVUYXJnZXRzRm9yVGV4dCIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsInVwZGF0ZVRhcmdldHNGb3JSYWRhciIsInVwZGF0ZVRhcmdldHNGb3JBcmMiLCJ1cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQiLCJzaG93VGFyZ2V0cyIsImlzVGFyZ2V0VG9TaG93Iiwid2l0aE9wdGlvbnMiLCJTdWJjaGFydCIsIlRyYW5zaXRpb24iLCJFdmVudFJlY3QiLCJEaW1lbnNpb24iLCJUcmltWERvbWFpbiIsIlRyYW5zZm9ybSIsIlVwZGF0ZVhEb21haW4iLCJVcGRhdGVPcmdYRG9tYWluIiwiTGVnZW5kIiwiVXBkYXRlWEF4aXMiLCJUcmFuc2l0aW9uRm9yRXhpdCIsIlRyYW5zaXRpb25Gb3JBeGlzIiwiZGVmVmFsIiwidHJhbnNpdGlvbnNWYWx1ZSIsImZsb3ciLCJ3dGgiLCJnZXRXaXRoT3B0aW9uIiwiZHVyYXRpb25Gb3JFeGl0IiwiZHVyYXRpb25Gb3JBeGlzIiwiZ2VuZXJhdGVUcmFuc2l0aW9ucyIsInRvb2x0aXBfaW5pdF9zaG93IiwiaGlkZVRvb2x0aXAiLCJ1cGRhdGVMZWdlbmQiLCJyZWRyYXdBeGlzIiwidXBkYXRlQ2lyY2xlWSIsInVwZGF0ZVhncmlkRm9jdXMiLCJ1cGRhdGVHcmlkIiwidXBkYXRlUmVnaW9uIiwidXBkYXRlQmFyIiwidXBkYXRlTGluZSIsInVwZGF0ZUFyZWEiLCJ1cGRhdGVDaXJjbGUiLCJoYXNEYXRhTGFiZWwiLCJ1cGRhdGVUZXh0IiwicmVkcmF3VGl0bGUiLCJyZWRyYXdBcmMiLCJyYWRhcnMiLCJyZWRyYXdSYWRhciIsImlzQmFyVHlwZSIsInJlZHJhd0V2ZW50UmVjdCIsImJpbmRab29tRXZlbnQiLCJnZW5lcmF0ZVJlZHJhd0xpc3QiLCJpbnRlcnZhbEZvckN1bGxpbmciLCJ4RG9tYWluRm9yWm9vbSIsImhhc1pvb20iLCJ1cGRhdGVYRG9tYWluIiwiYXhpc194X3RpY2tfdmFsdWVzIiwiem9vbV9yZXNjYWxlIiwidXBkYXRlTGFiZWxzIiwiYXhpc194X3RpY2tfY3VsbGluZ19tYXgiLCJ3aXRoU3ViY2hhcnQiLCJnZXREcmF3U2hhcGUiLCJyZWRyYXdTdWJjaGFydCIsImZsb3dGbiIsImdlbmVyYXRlRmxvdyIsInh2IiwiaXNUcmFuc2l0aW9uIiwiaXNUYWJWaXNpYmxlIiwicmVkcmF3TGlzdCIsImdldFJlZHJhd0xpc3QiLCJhZnRlclJlZHJhdyIsIm9ucmVuZGVyZWQiLCJ3YWl0Rm9yRHJhdyIsImdlbmVyYXRlV2FpdCIsImQzVHJhbnNpdGlvbiIsImFjYyIsInQxIiwiYWRkIiwiaGFzUmFkYXIiLCJpbmRpY2VzIiwiaGFzVHlwZU9mIiwiZ2V0U2hhcGVJbmRpY2VzIiwiaXNMaW5lVHlwZSIsImdlbmVyYXRlRHJhd0xpbmUiLCJpc0FyZWFUeXBlIiwiZ2VuZXJhdGVEcmF3QXJlYSIsImdlbmVyYXRlRHJhd0JhciIsInhGb3JUZXh0IiwiZ2VuZXJhdGVYWUZvclRleHQiLCJ5Rm9yVGV4dCIsImN4IiwicmFkYXJDaXJjbGVYIiwiY2lyY2xlWSIsImNpcmNsZVgiLCJjeSIsInJhZGFyQ2lyY2xlWSIsImxpc3QiLCJncmlkX3hfbGluZXMiLCJncmlkX3lfbGluZXMiLCJyZWRyYXdHcmlkIiwicmVkcmF3UmVnaW9uIiwicmVkcmF3TGluZSIsInJlZHJhd0FyZWEiLCJyZWRyYXdCYXIiLCJyZWRyYXdUZXh0IiwicmVkcmF3Q2lyY2xlIiwid2l0aExlZ2VuZCIsIndpdGhUcmFuc2l0aW9uRm9yRXhpdCIsIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtIiwidHJhbnNmb3JtQWxsIiwid2l0aFkiLCJ3aXRoRXZlbnRSZWN0IiwiYXhpc194X3R5cGUiLCJkYXRhX3giLCJkYXRhX3hzIiwiYXhpc195X3R5cGUiLCJnZXRBeGlzU2l6ZSIsImFicyIsImdldEJhc2VWYWx1ZSIsIm9wYWNpdHlGb3JDaXJjbGUiLCJwb2ludF9zaG93IiwiaXNCdWJibGVUeXBlIiwiaXNTY2F0dGVyVHlwZSIsImF4aXNfeF9jYXRlZ29yaWVzIiwieVNjYWxlIiwieUF4aXMiLCJ5MkF4aXMiLCJ0cmFuc2Zvcm1NYWluIiwidHJhbnNmb3JtQ29udGV4dCIsInRyYW5zZm9ybUxlZ2VuZCIsImJydXNoU2l6ZSIsImdldFhBeGlzQ2xpcFgiLCJnZXRYQXhpc0NsaXBZIiwiZ2V0WEF4aXNDbGlwV2lkdGgiLCJnZXRYQXhpc0NsaXBIZWlnaHQiLCJnZXRZQXhpc0NsaXBYIiwiZ2V0WUF4aXNDbGlwWSIsImdldFlBeGlzQ2xpcFdpZHRoIiwiZ2V0WUF4aXNDbGlwSGVpZ2h0IiwiY2xpcElkRm9yU3ViY2hhcnQiLCJ3aXRob3V0QXhpcyIsInJlc2l6ZUZ1bmN0aW9uIiwiZ2VuZXJhdGVSZXNpemUiLCJvbnJlc2l6ZSIsInJlc2l6ZV9hdXRvIiwicmVzaXplVGltZW91dCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJmbHVzaCIsIm9ucmVzaXplZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsUmVzaXplRnVuY3Rpb25zIiwicmVzaXplRnVuY3Rpb25zIiwiZiIsInNwbGljZSIsImNhbGxiYWNrIiwidHJhbnNpdGlvbnNUb1dhaXQiLCJsb29wIiwiZG9uZSIsInRpbWVyIiwicGFyc2VkRGF0ZSIsImRhdGFfeEZvcm1hdCIsImhpZGRlbiIsImhhc01vdXNlIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlIiwiaGFzVG91Y2giLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2giLCJEb2N1bWVudFRvdWNoIiwicGhhc2UiLCJwbHVnaW5zIiwiQ2hhcnQiLCJpbnRlcm5hbCIsImxvYWRDb25maWciLCJiZWZvcmVJbml0IiwiJCIsImdldENoYXJ0RWxlbWVudHMiLCJhZnRlckluaXQiLCJiaW5kVGhpcyIsImFyZ1RoaXMiLCJwcm90b3R5cGUiLCJPcHRpb25zIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJ6b29tX2V4dGVudCIsInpvb21fb256b29tIiwiem9vbV9vbnpvb21zdGFydCIsInpvb21fb256b29tZW5kIiwiem9vbV9yZXNldEJ1dHRvbiIsInpvb21feF9taW4iLCJ6b29tX3hfbWF4IiwiaW50ZXJhY3Rpb25fYnJpZ2h0ZW4iLCJkYXRhX3hTb3J0IiwiZGF0YV9pZENvbnZlcnRlciIsImRhdGFfbmFtZXMiLCJkYXRhX2NsYXNzZXMiLCJkYXRhX2dyb3VwcyIsImRhdGFfdHlwZSIsImRhdGFfdHlwZXMiLCJkYXRhX2xhYmVsc19jb2xvcnMiLCJkYXRhX2xhYmVsc19wb3NpdGlvbiIsImRhdGFfb3JkZXIiLCJkYXRhX3JlZ2lvbnMiLCJkYXRhX2NvbG9yIiwiZGF0YV9jb2xvcnMiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJkYXRhX29uY2xpY2siLCJkYXRhX29ub3ZlciIsImRhdGFfb25vdXQiLCJkYXRhX29uc2VsZWN0ZWQiLCJkYXRhX29udW5zZWxlY3RlZCIsImRhdGFfdXJsIiwiZGF0YV9oZWFkZXJzIiwiZGF0YV9qc29uIiwiZGF0YV9yb3dzIiwiZGF0YV9jb2x1bW5zIiwiZGF0YV9taW1lVHlwZSIsImRhdGFfa2V5cyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3ciLCJzdWJjaGFydF9vbmJydXNoIiwiY29sb3JfcGF0dGVybiIsImNvbG9yX3RocmVzaG9sZCIsImNvbG9yX29ub3ZlciIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfaW5zZXRfeCIsImxlZ2VuZF9pbnNldF95IiwibGVnZW5kX2luc2V0X3N0ZXAiLCJsZWdlbmRfaXRlbV9vbmNsaWNrIiwibGVnZW5kX2l0ZW1fb25vdmVyIiwibGVnZW5kX2l0ZW1fb25vdXQiLCJsZWdlbmRfZXF1YWxseSIsImxlZ2VuZF9wYWRkaW5nIiwibGVnZW5kX2l0ZW1fdGlsZV93aWR0aCIsImxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0IiwibGVnZW5kX3VzZVBvaW50IiwiYXhpc194X2NsaXBQYXRoIiwiYXhpc194X3RpY2tfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3hfdGlja19vdXRlciIsImF4aXNfeF9tYXgiLCJheGlzX3hfbWluIiwiYXhpc194X3BhZGRpbmciLCJheGlzX3hfZXh0ZW50IiwiYXhpc194X2xhYmVsIiwiYXhpc194X2F4ZXMiLCJheGlzX3lfY2xpcFBhdGgiLCJheGlzX3lfc2hvdyIsImF4aXNfeV9tYXgiLCJheGlzX3lfbWluIiwiYXhpc195X2ludmVydGVkIiwiYXhpc195X2NlbnRlciIsImF4aXNfeV9sYWJlbCIsImF4aXNfeV90aWNrX2Zvcm1hdCIsImF4aXNfeV90aWNrX291dGVyIiwiYXhpc195X3RpY2tfdmFsdWVzIiwiYXhpc195X3RpY2tfY291bnQiLCJheGlzX3lfdGlja19zaG93IiwiYXhpc195X3RpY2tfdGV4dF9zaG93IiwiYXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeV9wYWRkaW5nIiwiYXhpc195X2RlZmF1bHQiLCJheGlzX3lfYXhlcyIsImF4aXNfeTJfbWF4IiwiYXhpc195Ml9taW4iLCJheGlzX3kyX2ludmVydGVkIiwiYXhpc195Ml9jZW50ZXIiLCJheGlzX3kyX2xhYmVsIiwiYXhpc195Ml90aWNrX2Zvcm1hdCIsImF4aXNfeTJfdGlja19vdXRlciIsImF4aXNfeTJfdGlja192YWx1ZXMiLCJheGlzX3kyX3RpY2tfY291bnQiLCJheGlzX3kyX3RpY2tfc2hvdyIsImF4aXNfeTJfdGlja190ZXh0X3Nob3ciLCJheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeTJfcGFkZGluZyIsImF4aXNfeTJfZGVmYXVsdCIsImF4aXNfeTJfYXhlcyIsImdyaWRfeF9zaG93IiwiZ3JpZF94X3R5cGUiLCJncmlkX3lfc2hvdyIsImdyaWRfeV90aWNrcyIsImdyaWRfZm9jdXNfc2hvdyIsImdyaWRfZnJvbnQiLCJncmlkX2xpbmVzX2Zyb250IiwicG9pbnRfciIsInBvaW50X3NlbnNpdGl2aXR5IiwicG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQiLCJwb2ludF9mb2N1c19leHBhbmRfciIsInBvaW50X3BhdHRlcm4iLCJwb2ludF9zZWxlY3RfciIsInBvaW50X3R5cGUiLCJsaW5lX2Nvbm5lY3ROdWxsIiwibGluZV9zdGVwX3R5cGUiLCJsaW5lX2NsYXNzZXMiLCJsaW5lX3BvaW50IiwiYmFyX3BhZGRpbmciLCJiYXJfcmFkaXVzIiwiYmFyX3JhZGl1c19yYXRpbyIsImJhcl9zZW5zaXRpdml0eSIsImJhcl93aWR0aCIsImJhcl93aWR0aF9yYXRpbyIsImJhcl93aWR0aF9tYXgiLCJiYXJfemVyb2Jhc2VkIiwiYnViYmxlX21heFIiLCJhcmVhX3plcm9iYXNlZCIsImFyZWFfYWJvdmUiLCJhcmVhX2xpbmVhckdyYWRpZW50IiwicGllX2xhYmVsX3Nob3ciLCJwaWVfbGFiZWxfZm9ybWF0IiwicGllX2xhYmVsX3RocmVzaG9sZCIsInBpZV9sYWJlbF9yYXRpbyIsInBpZV9leHBhbmQiLCJwaWVfZXhwYW5kX2R1cmF0aW9uIiwicGllX2lubmVyUmFkaXVzIiwicGllX3BhZEFuZ2xlIiwicGllX3BhZGRpbmciLCJnYXVnZV9sYWJlbF9zaG93IiwiZ2F1Z2VfbGFiZWxfZm9ybWF0IiwiZ2F1Z2VfbWluIiwiZ2F1Z2VfbWF4IiwiZ2F1Z2Vfc3RhcnRpbmdBbmdsZSIsImdhdWdlX2xhYmVsX2V4dGVudHMiLCJnYXVnZV90aXRsZSIsImdhdWdlX3VuaXRzIiwiZ2F1Z2Vfd2lkdGgiLCJnYXVnZV9leHBhbmQiLCJnYXVnZV9leHBhbmRfZHVyYXRpb24iLCJkb251dF9sYWJlbF9zaG93IiwiZG9udXRfbGFiZWxfZm9ybWF0IiwiZG9udXRfbGFiZWxfdGhyZXNob2xkIiwiZG9udXRfbGFiZWxfcmF0aW8iLCJkb251dF93aWR0aCIsImRvbnV0X3RpdGxlIiwiZG9udXRfZXhwYW5kIiwiZG9udXRfZXhwYW5kX2R1cmF0aW9uIiwiZG9udXRfcGFkQW5nbGUiLCJzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlIiwicmFkYXJfYXhpc19tYXgiLCJyYWRhcl9heGlzX2xpbmVfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9zaG93IiwicmFkYXJfbGV2ZWxfZGVwdGgiLCJyYWRhcl9sZXZlbF9zaG93IiwicmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQiLCJyYWRhcl9sZXZlbF90ZXh0X3Nob3ciLCJyYWRhcl9zaXplX3JhdGlvIiwicmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZSIsInRvb2x0aXBfc2hvdyIsInRvb2x0aXBfZG9Ob3RIaWRlIiwidG9vbHRpcF9ncm91cGVkIiwidG9vbHRpcF9mb3JtYXRfdGl0bGUiLCJ0b29sdGlwX2Zvcm1hdF9uYW1lIiwidG9vbHRpcF9mb3JtYXRfdmFsdWUiLCJ0b29sdGlwX3Bvc2l0aW9uIiwidG9vbHRpcF9jb250ZW50cyIsInRvb2x0aXBfaW5pdF94IiwidG9vbHRpcF9pbml0X3Bvc2l0aW9uIiwidG9vbHRpcF9saW5rZWQiLCJ0b29sdGlwX2xpbmtlZF9uYW1lIiwidG9vbHRpcF9vbnNob3ciLCJ0b29sdGlwX29uaGlkZSIsInRvb2x0aXBfb25zaG93biIsInRvb2x0aXBfb25oaWRkZW4iLCJ0b29sdGlwX29yZGVyIiwidGl0bGVfdGV4dCIsInRpdGxlX3BhZGRpbmciLCJ0aXRsZV9wb3NpdGlvbiIsInJlYWQiLCJ0aGlzQ29uZmlnIiwiZmluZCIsImdldFNjYWxlIiwiZm9yVGltZXNlcmllcyIsImQzU2NhbGVUaW1lIiwiZ2V0WCIsIm9mZnNldCIsImdldEN1c3RvbWl6ZWRTY2FsZSIsImdldFkiLCJzY2FsZVZhbHVlIiwib2Zmc2V0VmFsdWUiLCJyYXciLCJvcmdTY2FsZSIsImRvbWFpblZhbHVlIiwiZ2V0WVNjYWxlIiwiZ2V0SWQiLCJnZXRTdWJZU2NhbGUiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4Iiwic3ViWE1pbiIsInN1YlhNYXgiLCJzdWJZTWluIiwic3ViWU1heCIsInhEb21haW4iLCJ4U3ViRG9tYWluIiwiZ2V0WEF4aXNUaWNrRm9ybWF0IiwiZ2V0WEF4aXNUaWNrVmFsdWVzIiwiZ2V0WEF4aXMiLCJ5QXhpc1RpY2tWYWx1ZXMiLCJnZXRZQXhpc1RpY2tWYWx1ZXMiLCJnZXRZQXhpcyIsInkyQXhpc1RpY2tWYWx1ZXMiLCJnZXRZMkF4aXNUaWNrVmFsdWVzIiwidXBkYXRlQXJjIiwiZ2V0WURvbWFpbk1pbk1heCIsImlzTWluIiwiZGF0YUdyb3VwcyIsImlkcyIsInlzIiwiZ2V0VmFsdWVzQXNJZEtleWVkIiwiaWRzSW5Hcm91cCIsImoiLCJiYXNlSWQiLCJiYXNlQXhpc0lkIiwiayIsImF4aXNJZCIsInZhbCIsIm1lZXRDb25kaXRpb24iLCJnZXRZRG9tYWluTWluIiwiZ2V0WURvbWFpbk1heCIsInRhcmdldHNCeUF4aXNJZCIsInlUYXJnZXRzIiwiZmlsdGVyQnlYRG9tYWluIiwieURvbWFpbk1pbiIsInlEb21haW5NYXgiLCJjZW50ZXIiLCJpc1plcm9CYXNlZCIsImlzSW52ZXJ0ZWQiLCJzaG93SG9yaXpvbnRhbERhdGFMYWJlbCIsInNob3dWZXJ0aWNhbERhdGFMYWJlbCIsImlzQWxsUG9zaXRpdmUiLCJpc0FsbE5lZ2F0aXZlIiwieURvbWFpbkFicyIsInJhdGlvIiwiZ2V0RGF0YUxhYmVsTGVuZ3RoIiwibGVuZ3RocyIsImdldFBhZGRpbmciLCJyZXZlcnNlIiwiZ2V0WERvbWFpbk1pbk1heCIsImdldFhEb21haW5NaW4iLCJnZXRYRG9tYWluTWF4IiwiZ2V0WERvbWFpblBhZGRpbmciLCJtYXhEYXRhQ291bnQiLCJ4UGFkZGluZyIsImdldE1heERhdGFDb3VudCIsImZpcnN0WCIsImxhc3RYIiwiZ2V0VGltZSIsIndpdGhUcmltIiwiem9vbUVuYWJsZWQiLCJ6b29tIiwidXBkYXRlU2NhbGVFeHRlbnQiLCJpbnZlcnQiLCJ0cmltWERvbWFpbiIsInpvb21Eb21haW4iLCJnZXRab29tRG9tYWluIiwiaXNYIiwiZGF0YUtleSIsImV4aXN0VmFsdWUiLCJpc05vdFgiLCJpc0dyb3VwZWQiLCJnZXRYS2V5IiwiZ2V0WFZhbHVlc09mWEtleSIsInhWYWx1ZXMiLCJnZXRJbmRleEJ5WCIsImJhc2VkWCIsImZpbHRlckJ5WCIsImdldFhWYWx1ZSIsImdldE90aGVyVGFyZ2V0WHMiLCJpZHNGb3JYIiwiZ2V0T3RoZXJUYXJnZXRYIiwiYWRkWHMiLCJoYXNNdWx0aXBsZVgiLCJpc011bHRpcGxlWCIsImFkZE5hbWUiLCJnZXRBbGxWYWx1ZXNPbkluZGV4IiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsImdlbmVyYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwicmF3WCIsImlzQ3VzdG9tWCIsImNsb25lVGFyZ2V0IiwiaWRfb3JnIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiaXNBcmVhUmFuZ2VUeXBlIiwiZ2V0QXJlYVJhbmdlRGF0YSIsImdldE1pbk1heFZhbHVlIiwiY2FjaGVLZXkiLCJtaW5NYXhEYXRhIiwiZ2V0Q2FjaGUiLCJtaW5EYXRhIiwiZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSIsIm1heERhdGEiLCJhZGRDYWNoZSIsImdldFRvdGFsUGVySW5kZXgiLCJzdW0iLCJyb3ciLCJnZXRUb3RhbERhdGFTdW0iLCJ0b3RhbERhdGFTdW0iLCJ0b3RhbCIsImdldE1heERhdGFDb3VudFRhcmdldCIsIm1heFRhcmdldCIsIm1hcFRvVGFyZ2V0SWRzIiwiaGFzVGFyZ2V0IiwidGFyZ2V0SWQiLCJpc0xlZ2VuZFRvU2hvdyIsInRhcmdldElkcyIsInJlbW92ZUhpZGRlblRhcmdldElkcyIsInJlbW92ZUhpZGRlbkxlZ2VuZElkcyIsImNoZWNrVmFsdWVJblRhcmdldHMiLCJjaGVja2VyIiwiaGFzTXVsdGlUYXJnZXRzIiwiaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyIsImhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHMiLCJfY2hlY2tPcmRlciIsIm9yZGVyIiwiaXNPcmRlckRlc2MiLCJpc09yZGVyQXNjIiwib3JkZXJUYXJnZXRzIiwidGFyZ2V0c1ZhbHVlIiwib3JkZXJBc2MiLCJvcmRlckRlc2MiLCJ0MiIsInJlZHVjZXIiLCJ0MVN1bSIsInQyU3VtIiwiZmlsdGVyUmVtb3ZlTnVsbCIsImRhdGFMYWJlbHMiLCJkYXRhTGFiZWxGb3JtYXQiLCJpc05vbmVBcmMiLCJpc0FyYyIsImZpbmRTYW1lWE9mVmFsdWVzIiwidGFyZ2V0WCIsInNhbWVzIiwiZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyIsImNhbmRpZGF0ZXMiLCJmaW5kQ2xvc2VzdCIsImNsb3Nlc3QiLCJtaW5EaXN0IiwiZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgiLCJpc1dpdGhpbkJhciIsImRpc3QiLCJ4SW5kZXgiLCJ5SW5kZXgiLCJzcXJ0IiwicG93IiwiY29udmVydFZhbHVlc1RvU3RlcCIsInN0ZXBUeXBlIiwiY29udmVydGVkIiwiY29udmVydFZhbHVlc1RvUmFuZ2UiLCJyYW5nZXMiLCJ1cGRhdGVEYXRhQXR0cmlidXRlcyIsImF0dHJzIiwiY3VycmVudCIsImdldFJhdGlvIiwiYXNQZXJjZW50Iiwic2hvd24iLCJkYXRhVmFsdWVzIiwicGllIiwicGFkQW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0QW5nbGUiLCJoaWRkZW5TdW0iLCJjdXJyIiwicGFyc2VGbG9hdCIsIm1heFZhbHVlIiwiY29udmVydFVybFRvRGF0YSIsIm1pbWVUeXBlIiwiaGVhZGVycyIsImpzb24iLCJjb252ZXJ0SnNvblRvRGF0YSIsInJvd3MiLCJjb252ZXJ0Um93c1RvRGF0YSIsImNvbHVtbnMiLCJjb252ZXJ0Q29sdW1uc1RvRGF0YSIsIkVycm9yIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3BlbiIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsIkpTT04iLCJwYXJzZSIsInNlbmQiLCJfY29udmVydENzdlRzdlRvRGF0YSIsInBhcnNlciIsInhzdiIsImNvbnZlcnRDc3ZUb0RhdGEiLCJkM0NzdlBhcnNlUm93cyIsImQzQ3N2UGFyc2UiLCJjb252ZXJ0VHN2VG9EYXRhIiwidHN2IiwiZDNUc3ZQYXJzZVJvd3MiLCJkM1RzdlBhcnNlIiwia2V5c1BhcmFtIiwidGFyZ2V0S2V5cyIsIm5ld1Jvd3MiLCJuZXdSb3ciLCJmaW5kVmFsdWVJbkpzb24iLCJ0bXAiLCJvYmplY3QiLCJjb252ZXJ0ZWRQYXRoIiwicGF0aEFycmF5Iiwic29tZSIsImxlbjEiLCJsZW4yIiwiYXBwZW5kWHMiLCJ4c0RhdGEiLCJkYXRhS2V5cyIsInhLZXkiLCJjb252ZXJ0ZWRJZCIsImhhc0NhdGVnb3J5IiwiaGlnaCIsInYxIiwidjIiLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsInNldFRhcmdldFR5cGUiLCJsb2FkIiwicmF3VGFyZ2V0cyIsInR5cGVzIiwibG9hZEZyb21BcmdzIiwicmVzZXRDYWNoZSIsInVubG9hZCIsInJhd1RhcmdldElkcyIsImN1c3RvbURvbmVDYiIsInNlbGVjdG9yVGFyZ2V0IiwiZW5kYWxsIiwiZXZlbnRSZWN0VXBkYXRlIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyIsIm1heERhdGFDb3VudFRhcmdldCIsImRhdHVtIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWCIsInVwZGF0ZUV2ZW50UmVjdCIsImJpbmRUb3VjaE9uRXZlbnRSZWN0Iiwic3RhcnRQeCIsImdldEV2ZW50UmVjdCIsImVsZW1lbnRGcm9tUG9pbnQiLCJnZXRJbmRleCIsInNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyIsImNhbGxPdmVyT3V0Rm9yVG91Y2giLCJ1bnNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yU2luZ2xlIiwicHJldmVudERlZmF1bHQiLCJpc1ByZXZlbnRlZCIsInByZXZlbnRUaHJlc2hvbGQiLCJwcmV2ZW50RXZlbnQiLCJjdXJyZW50WFkiLCJ0b2dnbGVTaGFwZSIsInhTY2FsZSIsImV2ZW50UmVjdERhdGEiLCJyZWN0VyIsInJlY3RYIiwiZ2V0RXZlbnRSZWN0V2lkdGgiLCJnZXRQcmV2TmV4dFgiLCJwcmV2IiwibmV4dCIsInRoaXNYIiwiY2xhc3NFdmVudCIsImlzU2VsZWN0aW9uRW5hYmxlZCIsImlzU2VsZWN0aW9uR3JvdXBlZCIsImlzVG9vbHRpcEdyb3VwZWQiLCJzZWxlY3RlZERhdGEiLCJzaG93VG9vbHRpcCIsInNob3dYR3JpZEZvY3VzIiwiaGlkZVhHcmlkRm9jdXMiLCJleHBhbmRDaXJjbGVzQmFycyIsImlzV2l0aGluU2hhcGUiLCJzZWxlY3RlZCIsInVuZXhwYW5kQ2lyY2xlcyIsInJlc2V0IiwiZXhwYW5kQ2lyY2xlcyIsImV4cGFuZEJhcnMiLCJkM01vdXNlIiwic2FtZVhEYXRhIiwiX2hhbmRsZUxpbmtlZENoYXJ0cyIsInVuZXhwYW5kQmFycyIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJnZXREcmFnZ2FibGVTZWxlY3Rpb24iLCJkcmFnIiwiZDNEcmFnIiwiZHJhZ3N0YXJ0IiwiZHJhZ2VuZCIsImV2ZW50UmVjdEVudGVyIiwicmVjdCIsImNsaWNrSGFuZGxlckZvclNpbmdsZVgiLCJpc1N0ZXBUeXBlIiwiZDIiLCJjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTIiwic2VsZWN0b3IiLCJnZXRDdXJyZW50V2lkdGgiLCJnZXRDdXJyZW50SGVpZ2h0IiwiZ2V0UGFyZW50V2lkdGgiLCJnZXRQYXJlbnRIZWlnaHQiLCJnZXRBeGlzV2lkdGhCeUF4aXNJZCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJsZWdlbmRXaWR0aE9uUmlnaHQiLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsInBhcmVudE5vZGUiLCJib2R5V2lkdGgiLCJvZmZzZXRXaWR0aCIsInBhcnNlSW50IiwiZ2V0U3ZnTGVmdCIsImhhc0xlZnRBeGlzUmVjdCIsImxlZnRBeGlzQ2xhc3MiLCJsZWZ0QXhpcyIsInN2Z1JlY3QiLCJjaGFydFJlY3QiLCJzdmdMZWZ0IiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJjb3MiLCJ0aWNrSW50ZXJ2YWwiLCJ0eXBlRmlsdGVyIiwiZ3JvdXBzIiwiX19tYXhfXyIsImdldFNoYXBlWCIsInRhcmdldHNOdW0iLCJpc1N1YiIsImJhclBhZGRpbmciLCJoYWxmV2lkdGgiLCJ4UG9zIiwiZ2V0U2hhcGVZIiwiZ2V0U2hhcGVPZmZzZXQiLCJpZHgiLCJ5MCIsInJvd1ZhbHVlcyIsInRoYXQiLCJpc1dpdGhpbiIsImhhc1ZhbGlkUG9pbnRUeXBlIiwibm9kZU5hbWUiLCJpc1dpdGhpblN0ZXAiLCJpc1dpdGhpbkNpcmNsZSIsInBvaW50U2VsZWN0UiIsImdldEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGlvbiIsImdldEludGVycG9sYXRlVHlwZSIsImQzQ3VydmVCYXNpcyIsImQzQ3VydmVCYXNpc0Nsb3NlZCIsImQzQ3VydmVCYXNpc09wZW4iLCJkM0N1cnZlQnVuZGxlIiwiZDNDdXJ2ZUNhcmRpbmFsIiwiZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkIiwiZDNDdXJ2ZUNhcmRpbmFsT3BlbiIsImQzQ3VydmVDYXRtdWxsUm9tIiwiZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQiLCJkM0N1cnZlQ2F0bXVsbFJvbU9wZW4iLCJkM0N1cnZlTW9ub3RvbmVYIiwiZDNDdXJ2ZU1vbm90b25lWSIsImQzQ3VydmVOYXR1cmFsIiwiZDNDdXJ2ZUxpbmVhckNsb3NlZCIsImQzQ3VydmVMaW5lYXIiLCJkM0N1cnZlU3RlcCIsImQzQ3VydmVTdGVwQWZ0ZXIiLCJkM0N1cnZlU3RlcEJlZm9yZSIsImlzSW50ZXJwb2xhdGlvblR5cGUiLCJpc1NwbGluZVR5cGUiLCJpbml0UGllIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwicmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImlubmVyUmFkaXVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwic3ZnQXJjRXhwYW5kZWRTdWIiLCJ1cGRhdGVBbmdsZSIsImRWYWx1ZSIsImlzR2F1Z2VUeXBlIiwidG90YWxTdW0iLCJnU3RhcnQiLCJnRW5kIiwiaXIiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwid2l0aG91dFVwZGF0ZSIsInVwZGF0ZWQiLCJjZW50cm9pZCIsInJhdGUiLCJnZXRBcmMiLCJpc0FyY1R5cGUiLCJ0cmFuc2Zvcm1Gb3JBcmNMYWJlbCIsInRyYW5zbGF0ZSIsImNvbnZlcnRUb0FyY0RhdGEiLCJ0ZXh0Rm9yQXJjTGFiZWwiLCJzaG91bGRTaG93QXJjTGFiZWwiLCJpc1VuZGVyVGhyZXNob2xkIiwibWVldHNBcmNMYWJlbFRocmVzaG9sZCIsImdldEFyY0xhYmVsRm9ybWF0IiwiZGVmYXVsdEFyY1ZhbHVlRm9ybWF0IiwidGV4dEZvckdhdWdlTWluTWF4IiwiaXNNYXgiLCJnZXRHYXVnZUxhYmVsRXh0ZW50cyIsImV4cGFuZEFyYyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm5ld1RhcmdldElkcyIsInNlbGVjdG9yVGFyZ2V0cyIsInNob3VsZEV4cGFuZCIsImV4cGFuZER1cmF0aW9uIiwidW5leHBhbmRBcmMiLCJpc0RvbnV0VHlwZSIsImlzUGllVHlwZSIsInRocmVzaG9sZCIsImdldEFyY1RpdGxlIiwiaGFzR2F1Z2UiLCJjbGFzc0NoYXJ0QXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NGb2N1cyIsIm1haW5QaWVVcGRhdGUiLCJtYWluUGllRW50ZXIiLCJpbml0QXJjIiwic2V0QXJjVGl0bGUiLCJoYXNJbnRlcmFjdGlvbiIsIm1haW5BcmMiLCJhcmNEYXRhIiwiY2xhc3NBcmMiLCJfY3VycmVudCIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJzZWxlY3RBcmMiLCJfdGhpcyIsImZvY3VzIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJ1bnNlbGVjdEFyYyIsInJldmVydCIsInJldmVydExlZ2VuZCIsImlzTW91c2UiLCJnZXRFdmVudEFyYyIsImV2ZW50QXJjIiwiaGFuZGxlciIsImlzRnVsbENpcmNsZSIsImluaXRHYXVnZSIsImFwcGVuZFRleHQiLCJpbml0QmFyIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQmFycyIsIm1haW5CYXJVcGRhdGUiLCJtYWluQmFyRW50ZXIiLCJiYXJEYXRhIiwiY2xhc3NCYXIiLCJpbml0aWFsT3BhY2l0eSIsImRyYXdCYXIiLCJnZXRCYXJXIiwiYmFyVGFyZ2V0c051bSIsInJlc3VsdCIsImdldFdpZHRoIiwiZ2V0QmFycyIsInN1ZmZpeCIsImJhckluZGljZXMiLCJnZXRQb2ludHMiLCJnZW5lcmF0ZUdldEJhclBvaW50cyIsImJhclJhZGl1cyIsImJhclJhZGl1c1JhdGlvIiwiZ2V0UmFkaXVzIiwicG9pbnRzIiwiaW5kZXhYIiwiaW5kZXhZIiwiaXNOZWdhdGl2ZSIsInBhdGhSYWRpdXMiLCJiYXJXIiwiYmFyWCIsImJhclkiLCJiYXJPZmZzZXQiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJjbGFzc0NoYXJ0TGluZSIsImNsYXNzTGluZXMiLCJjbGFzc0FyZWFzIiwiY2xhc3NDaXJjbGVzIiwibWFpbkxpbmVVcGRhdGUiLCJtYWluTGluZUVudGVyIiwiZ2VuZXJhdGVDbGFzcyIsImxpbmVEYXRhIiwiY2xhc3NMaW5lIiwiZHJhd0xpbmUiLCJnZXRDdXJ2ZSIsImlzUm90YXRlZFN0ZXBUeXBlIiwic3RlcCIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJsaW5lSW5kaWNlcyIsImxpbmVDb25uZWN0TnVsbCIsImdlbmVyYXRlR2V0TGluZVBvaW50cyIsInlTY2FsZUdldHRlciIsInhWYWx1ZSIsInN1Ynh4IiwieHgiLCJ5VmFsdWUiLCJkM0xpbmUiLCJkZWZpbmVkIiwieDAiLCJsaW5lV2l0aFJlZ2lvbnMiLCJjdXJ2ZSIsImlzU3ViVmFsdWUiLCJsaW5lVGFyZ2V0c051bSIsImxpbmVPZmZzZXQiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJ4T2Zmc2V0IiwiZGFzaGFycmF5IiwiaXNXaXRoaW5SZWdpb25zIiwid2l0aGluWCIsIndpdGhpblJlZ2lvbnMiLCJyZWciLCJnZXRWYWx1ZSIsImR0IiwiZ2VuZXJhdGVNIiwic1dpdGhSZWdpb24iLCJkMCIsImQxIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiZGQiLCJ1cGRhdGVBcmVhR3JhZGllbnQiLCJzdG9wcyIsImxpbmVhckdyYWRpZW50Iiwic3RvcENvbG9yIiwidXBkYXRlQXJlYUNvbG9yIiwiY2xhc3NBcmVhIiwib3JnQXJlYU9wYWNpdHkiLCJkcmF3QXJlYSIsImFyZWFJbmRpY2VzIiwiZ2VuZXJhdGVHZXRBcmVhUG9pbnRzIiwidmFsdWUwIiwidmFsdWUxIiwiZDNBcmVhIiwiYXJlYVRhcmdldHNOdW0iLCJhcmVhT2Zmc2V0Iiwic2hvdWxkRHJhd1BvaW50c0ZvckxpbmUiLCJsYWJlbGlzaERhdGEiLCJjbGFzc0NpcmNsZSIsInBvaW50UiIsImluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlIiwibWFpbkNpcmNsZXMiLCJwb3NBdHRyIiwiaXNDaXJjbGVQb2ludCIsImdldENpcmNsZXMiLCJwb2ludEV4cGFuZGVkUiIsInNlbGVjdFIiLCJpcyIsImxpbmVQb2ludCIsImhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyIsInBvaW50VHlwZSIsInVwZGF0ZSIsImluc2VydFBvaW50SW5mb0RlZnMiLCJjb3B5QXR0ciIsImZyb20iLCJhdHRyaWJzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNsb25lIiwiY3JlYXRlRWxlbWVudE5TIiwiZDNOYW1lc3BhY2VzIiwiZmlsbCIsInN0cm9rZSIsImNoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJwb2ludEZyb21EZWZzIiwicGF0dGVybiIsIm1ldGhvZCIsInBvaW50SWQiLCJjdXN0b20iLCJnZXRUcmFuc2l0aW9uTmFtZSIsImNzc0NsYXNzRm4iLCJzaXplRm4iLCJmaWxsU3R5bGVGbiIsInhQb3NGbiIsInlQb3NGbiIsIm9wYWNpdHlTdHlsZUZuIiwieFBvc0ZuMiIsInlQb3NGbjIiLCJ0cmFuc2l0aW9uTmFtZSIsInJlY3RhbmdsZSIsInJlY3RTaXplRm4iLCJyZWN0WFBvc0ZuIiwicmVjdFlQb3NGbiIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsImdldFJhZGFyU2l6ZSIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibCIsImxldmVsVGV4dEZvcm1hdCIsImpvaW4iLCJsZXZlbEVudGVyIiwiYXhpc0VudGVyIiwiYmluZEV2ZW50IiwiaGlkZSIsIm5vSW5kZXgiLCJhcmVhc0VudGVyIiwiY2xhc3NDaGFydFJhZGFyIiwiY2xhc3NDaGFydFRleHQiLCJjbGFzc1RleHRzIiwibWFpblRleHRVcGRhdGUiLCJtYWluVGV4dEVudGVyIiwiZGF0YUZuIiwiY2xhc3NUZXh0IiwiaXNSYWRhclR5cGUiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsImZvckZsb3ciLCJvcGFjaXR5Rm9yVGV4dCIsImdldFRleHRSZWN0IiwiYmFzZSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImZvclgiLCJnZXR0ZXIiLCJnZXRYRm9yVGV4dCIsImdldFlGb3JUZXh0IiwiZ2V0Q2VudGVyZWRUZXh0UG9zIiwidGV4dEVsZW1lbnQiLCJjZW50ZXJlZCIsImlzUG9zaXRpdmUiLCJ5UG9zIiwiYmFzZVkiLCJib3hIZWlnaHQiLCJUWVBFUyIsIkFyZWEiLCJBcmVhUmFuZ2UiLCJBcmMiLCJMaW5lIiwiU3RlcCIsIlNwbGluZSIsImV4Y2x1ZGUiLCJpc1R5cGVPZiIsImRhdGFUeXBlIiwiYmFyTGluZUJ1YmJsZURhdGEiLCJnZXRHcmlkVGV4dEFuY2hvciIsImdldEdyaWRUZXh0RHgiLCJnZXRHcmlkVGV4dFgiLCJpbml0R3JpZExpbmVzIiwiaW5pdFhZRm9jdXNHcmlkIiwiY2xpcFBhdGhGb3JHcmlkIiwidXBkYXRlWEdyaWQiLCJ4Z3JpZERhdGEiLCJnZW5lcmF0ZUdyaWREYXRhIiwieGdyaWRBdHRyIiwidXBkYXRlWUdyaWQiLCJncmlkVmFsdWVzIiwic21vb3RoTGluZXMiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInRyaW0iLCJ5diIsImlzRnJvbnQiLCJkYXRhVG9TaG93IiwiZm9jdXNFbCIsInRpY2tOdW0iLCJncmlkRGF0YSIsImZpcnN0WWVhciIsImdldEZ1bGxZZWFyIiwibGFzdFllYXIiLCJnZXRHcmlkRmlsdGVyVG9SZW1vdmUiLCJwYXJhbSIsInJlbW92ZUdyaWRMaW5lcyIsInRvUmVtb3ZlIiwiZ2V0VG9vbHRpcEhUTUwiLCJnZXRZRm9ybWF0IiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJkZWZhdWx0VGl0bGVGb3JtYXQiLCJkZWZhdWx0VmFsdWVGb3JtYXQiLCJ0aXRsZUZvcm1hdCIsIm5hbWVGb3JtYXQiLCJ2YWx1ZUZvcm1hdCIsImdldFJvd1ZhbHVlIiwiZ2V0QmdDb2xvciIsImNvbnRlbnRzIiwidHBsU3RyIiwidGVtcGxhdGUiLCJpMiIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiVElUTEUiLCJsb3ciLCJjb250ZW50VmFsdWUiLCJDTEFTU19UT09MVElQX05BTUUiLCJDT0xPUiIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsInRXaWR0aCIsInRIZWlnaHQiLCJjaGFydFJpZ2h0IiwiZGF0YVNjYWxlIiwiZm9yQXJjIiwicG9zaXRpb25GdW5jdGlvbiIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsInNob3ciLCJsaW5rZWROYW1lIiwiY2hhcnRzIiwiaXNMaW5rZWQiLCJpc0luRG9tIiwiY29udGFpbnMiLCJpc05vdFNhbWVJbmRleCIsImxlZ2VuZEl0ZW1UZXh0Qm94IiwibGVnZW5kSGFzUmVuZGVyZWQiLCJvcHRpb256IiwidXBkYXRlTGVnZW5kVGVtcGxhdGUiLCJ1cGRhdGVMZWdlbmRFbGVtZW50Iiwid3JhcHBlciIsImNvbnRlbnQiLCJzZXRMZWdlbmRJdGVtIiwiaW5zZXRMZWdlbmRQb3NpdGlvbiIsInVwZGF0ZUxlZ2VuZFN0ZXAiLCJ1cGRhdGVMZWdlbmRJdGVtV2lkdGgiLCJ1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0Iiwib3BhY2l0eUZvckxlZ2VuZCIsIm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQiLCJ0YXJnZXRJZHoiLCJzaG93TGVnZW5kIiwic2VsZWN0b3JMZWdlbmRzIiwiaGlkZUxlZ2VuZCIsImNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSIsIml0ZW0iLCJpdGVtQ2xhc3MiLCJhbHRLZXkiLCJ0b2dnbGUiLCJ4Rm9yTGVnZW5kIiwieUZvckxlZ2VuZCIsImJhY2tncm91bmQiLCJwb3NNaW4iLCJ0aWxlV2lkdGgiLCJtYXhIZWlnaHQiLCJ0b3RhbExlbmd0aCIsIm9mZnNldHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwibWFyZ2lucyIsInN0ZXBzIiwiaXNMZWdlbmRSaWdodE9ySW5zZXQiLCJnZXRUZXh0Qm94IiwidXBkYXRlUG9zaXRpb25zIiwiaXNMYXN0IiwiYm94IiwiaXRlbVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1MZW5ndGgiLCJhcmVhTGVuZ3RoIiwidXBkYXRlVmFsdWVzIiwiaWQyIiwid2l0aG91dFN0ZXAiLCJtYXhMZW5ndGgiLCJ4Rm9yTGVnZW5kVGV4dCIsInhGb3JMZWdlbmRSZWN0IiwieDFGb3JMZWdlbmRUaWxlIiwieDJGb3JMZWdlbmRUaWxlIiwieUZvckxlZ2VuZFRleHQiLCJ5Rm9yTGVnZW5kUmVjdCIsInlGb3JMZWdlbmRUaWxlIiwidXNlUG9pbnQiLCJyZWN0cyIsInRpbGVzIiwieU9mZnNldCIsImdldFRleHRQb3MiLCJpc051bSIsInlGb3JUaXRsZSIsInhGb3JUaXRsZSIsImdldENsaXBQYXRoIiwiaXNJRTkiLCJhcHBWZXJzaW9uIiwiVVJMIiwiZ2V0QXhpc0NsaXBYIiwiZ2V0QXhpc0NsaXBZIiwiZ2V0QXhpc0NsaXBXaWR0aCIsImdldEF4aXNDbGlwSGVpZ2h0IiwibWFpblJlZ2lvbiIsImNsYXNzUmVnaW9uIiwicmVnaW9uWCIsInJlZ2lvblkiLCJyZWdpb25XaWR0aCIsInJlZ2lvbkhlaWdodCIsImdldFJlZ2lvblhZIiwiZ2V0UmVnaW9uU2l6ZSIsImlzV2lkdGgiLCJpc1JlZ2lvbk9uWCIsImFsdERvbWFpbiIsInN4Iiwic3kiLCJteCIsIm15IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsImlzU2VsZWN0ZWQiLCJpc0luY2x1ZGVkIiwidG9nZ2xlUG9pbnQiLCJ0b2dnbGVQYXRoIiwic2V0RHJhZ1N0YXR1cyIsImlzRHJhZ2dpbmciLCJzZWxlY3RQb2ludCIsInVuc2VsZWN0UG9pbnQiLCJzZWxlY3RQYXRoIiwiZDNSZ2IiLCJicmlnaHRlciIsInVuc2VsZWN0UGF0aCIsImdldFRvZ2dsZSIsInRvZ2dsZWRTaGFwZSIsImluaXRCcnVzaCIsImQzQnJ1c2hZIiwiZDNCcnVzaFgiLCJsYXN0RG9tYWluIiwidGltZW91dCIsImJydXNoSGFuZGxlciIsInJlZHJhd0ZvckJydXNoIiwiZ2V0QnJ1c2hTaXplIiwidXBkYXRlUmVzaXplIiwiZ2V0U2VsZWN0aW9uIiwibW92ZSIsImV4dGVudCIsImdldEV4dGVudCIsInZpc2liaWxpdHkiLCJjb250ZXh0QmFyVXBkYXRlIiwiY29udGV4dEJhckVudGVyIiwiY29udGV4dExpbmVVcGRhdGUiLCJjb250ZXh0TGluZUVudGVyIiwidXBkYXRlQmFyRm9yU3ViY2hhcnQiLCJjb250ZXh0QmFyIiwicmVkcmF3QmFyRm9yU3ViY2hhcnQiLCJkcmF3QmFyT25TdWIiLCJ1cGRhdGVMaW5lRm9yU3ViY2hhcnQiLCJjb250ZXh0TGluZSIsInJlZHJhd0xpbmVGb3JTdWJjaGFydCIsImRyYXdMaW5lT25TdWIiLCJ1cGRhdGVBcmVhRm9yU3ViY2hhcnQiLCJjb250ZXh0QXJlYSIsInJlZHJhd0FyZWFGb3JTdWJjaGFydCIsImRyYXdBcmVhT25TdWIiLCJkcmF3Iiwid2l0aERpbWVuc2lvbiIsImdlbmVyYXRlWm9vbSIsImluaXRab29tQmVoYXZpb3VyIiwiYmluZFpvb21PbkV2ZW50UmVjdCIsInVuem9vbSIsImQzWm9vbSIsIm9uWm9vbVN0YXJ0Iiwib25ab29tIiwib25ab29tRW5kIiwib3JnU2NhbGVFeHRlbnQiLCJ1cGRhdGVUcmFuc2Zvcm1TY2FsZSIsInRyYW5zZm9ybSIsInJlc2NhbGUiLCJzb3VyY2VFdmVudCIsInN0YXJ0RXZlbnQiLCJpc01vdXNlbW92ZSIsImlzWm9vbU91dCIsIndoZWVsRGVsdGEiLCJ1cGRhdGVab29tIiwiZGVsdGEiLCJpc2Z1bGx5U2hvd24iLCJiZWhhdmlvdXIiLCJ6b29tQmVoYXZpb3VyIiwicHJvcCIsImNsaWNrRGlzdGFuY2UiLCJzZXRab29tUmVzZXRCdXR0b24iLCJyZXNldEJ1dHRvbiIsInJlc2V0QnRuIiwiY29sb3JpemVQYXR0ZXJuIiwiY2xvbmVOb2RlIiwic2NoZW1lQ2F0ZWdvcnkxMCIsImdldENvbG9yRnJvbUNzcyIsInNwYW4iLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwiQm9vbGVhbiIsImNvbG9ycyIsImQzU2NhbGVPcmRpbmFsIiwib3JpZ2luYWxDb2xvclBhdHRlcm4iLCJjb2xvcml6ZWRQYXR0ZXJucyIsImlzTGluZSIsImFzVmFsdWUiLCJnZXRGb3JtYXQiLCJ0eXBlVmFsdWUiLCJmb3JtYXRGb3JZIiwieUZvcm1hdCIsImZvcm1hdEZvclkyIiwieTJGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaXNEYXRhVHlwZSIsInJlbW92ZUNhY2hlIiwiYWxsIiwiY2xhc3NTaGFwZSIsImNsYXNzU2hhcGVzIiwiY2xhc3NlcyIsImNsYXNzVGFyZ2V0IiwiYWRkaXRpb25hbENsYXNzU3VmZml4IiwiYWRkaXRpb25hbENsYXNzIiwiY2xhc3NGb2N1c2VkIiwiY2xhc3NEZWZvY3VzZWQiLCJpZHNWYWx1ZSIsInNlbGVjdG9yTGVnZW5kIiwidGFyZ2V0SWRzVmFsdWUiLCJkZWZvY3VzIiwiX3Nob3dIaWRlIiwid2l0aGluUmFuZ2UiLCJyZXN1bHREb21haW4iLCJlbmFibGUiLCJlbmFibGVkIiwiZW5hYmxlVHlwZSIsInVwZGF0ZUFuZFJlZHJhdyIsImQzWm9vbUlkZW50aXR5IiwiZDNab29tVHJhbnNmb3JtIiwibmFtZXMiLCJhcmdzVmFsdWUiLCJ0byIsInRhaWwiLCJub3Rmb3VuZElkcyIsIm9yZ0RhdGFDb3VudCIsIm1pc3NpbmciLCJiYXNlVGFyZ2V0IiwiYmFzZVZhbHVlIiwid2l0aFRyaW1YRG9tYWluIiwid2l0aFVwZGF0ZVhBeGlzIiwidHJhbnNsYXRlWCIsInNjYWxlWCIsImZsb3dJbmRleCIsImZsb3dMZW5ndGgiLCJmbG93U3RhcnQiLCJmbG93RW5kIiwiZHVyYXRpb25Gb3JGbG93Iiwid2FpdCIsImd0IiwiZWFzZSIsImQzRWFzZUxpbmVhciIsInNldFRyYW5zaXRpb24iLCJ4RnVuYyIsInlGdW5jIiwiZGF0YVBvaW50IiwicmVzZXRPdGhlciIsImlzVGFyZ2V0SWQiLCJpc1RhcmdldEluZGV4IiwidW5zZWxlY3QiLCJ0cmFuc2Zvcm1UbyIsIm9wdGlvbnNGb3JSZWRyYXciLCJncmlkcyIsInJlZHJhd1dpdGhvdXRSZXNjYWxlIiwib3B0aW9uc1ZhbHVlIiwiZmxhdCIsImRhdGFWYWx1ZSIsImNhdGVnb3J5Iiwic2V0TWluTWF4Iiwic2V0TGFiZWxUZXh0IiwicmVzaXplIiwic29mdCIsImlzRnJvbVJlc2l6ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiYjY0RW5jb2RlVW5pY29kZSIsImJ0b2EiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5vZGVUb1N2Z0RhdGFVcmwiLCJzZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsImNzc1RleHQiLCJ4aHRtbCIsIm5vZGVYbWwiLCJzZXJpYWxpemVUb1N0cmluZyIsImNyZWF0ZVRleHROb2RlIiwic3R5bGVYbWwiLCJzdmdEYXRhVXJsIiwiaW1nIiwiY3Jvc3NzT3JpZ2luIiwib25sb2FkIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsImRlZmF1bHRzIiwiYmIiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGUiLCJpbnN0IiwiaW5zdGFuY2UiLCJwbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsd05BQXdOO0FBQzNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsOFhBQThYO0FBQ2pZO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHNDQUFzQyxFQUFFOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1COzs7QUFHNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0NBQWdDO0FBQzlFLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsMFFBQTBRO0FBQzdRO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxnRkFBZ0Y7QUFDbkY7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSx3R0FBd0c7QUFDM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHFGQUFxRjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsK0lBQStJO0FBQ2xKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLG1GQUFtRjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGOztBQUV6Rjs7QUFFQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9DQUFvQztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0ZBQW9GO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQkFBMEIscURBQXFELG1CQUFtQixXQUFXO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxrSUFBa0k7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9DQUFvQztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx3REFBd0Q7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFdBQVc7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsY0FBYztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMs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QUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6UFk7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx5Qjs7Ozs7OztBQ2JhO0FBQ2I7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLEVBQU87QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEMscUJBQXFCLG1CQUFPLENBQUMsRUFBcUI7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDdERBLG1CQUFtQixtQkFBTyxDQUFDLEVBQVE7QUFDbkM7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL2JhO0FBQ2I7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLEVBQUs7O0FBRXZCLGtCQUFrQixtQkFBTyxDQUFDLEVBQWE7O0FBRXZDLDZCQUE2QixtQkFBTyxDQUFDLEVBQTBCOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUM7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsRUFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsRUFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RkE7Ozs7O0FBSUE7Ozs7QUFJZTtBQUNkQyxLQUFHLEVBQUUsUUFEUztBQUVkQyxNQUFJLEVBQUUsU0FGUTtBQUdkQyxNQUFJLEVBQUUsU0FIUTtBQUlkQyxPQUFLLEVBQUUsVUFKTztBQUtkQyxNQUFJLEVBQUUsU0FMUTtBQU1kQyxPQUFLLEVBQUUsV0FOTztBQU9kQyxZQUFVLEVBQUUsaUJBUEU7QUFRZEMsT0FBSyxFQUFFLFdBUk87QUFTZEMsUUFBTSxFQUFFLFlBVE07QUFVZEMsYUFBVyxFQUFFLGtCQVZDO0FBV2RDLFlBQVUsRUFBRSxpQkFYRTtBQVlkQyxLQUFHLEVBQUUsUUFaUztBQWFkQyxNQUFJLEVBQUUsU0FiUTtBQWNkQyxPQUFLLEVBQUUsVUFkTztBQWVkQyxRQUFNLEVBQUUsV0FmTTtBQWdCZEMsaUJBQWUsRUFBRSxlQWhCSDtBQWlCZEMsT0FBSyxFQUFFLFVBakJPO0FBa0JkQyxVQUFRLEVBQUUsY0FsQkk7QUFtQmRDLFdBQVMsRUFBRSxlQW5CRztBQW9CZEMscUJBQW1CLEVBQUUsMEJBcEJQO0FBcUJkQyxtQkFBaUIsRUFBRSx5QkFyQkw7QUFzQmRDLG1CQUFpQixFQUFFLHlCQXRCTDtBQXVCZEMsb0JBQWtCLEVBQUUsMEJBdkJOO0FBd0JkQyxnQkFBYyxFQUFFLHFCQXhCRjtBQXlCZEMscUJBQW1CLEVBQUUsMkJBekJQO0FBMEJkQyxVQUFRLEVBQUUsY0ExQkk7QUEyQmRDLFdBQVMsRUFBRSxlQTNCRztBQTRCZEMsV0FBUyxFQUFFLGVBNUJHO0FBNkJkQyxZQUFVLEVBQUUsZ0JBN0JFO0FBOEJkQyxZQUFVLEVBQUUsZ0JBOUJFO0FBK0JkQyxhQUFXLEVBQUUsaUJBL0JDO0FBZ0NkQyxXQUFTLEVBQUUsZUFoQ0c7QUFpQ2RDLFlBQVUsRUFBRSxnQkFqQ0U7QUFrQ2RDLFFBQU0sRUFBRSxXQWxDTTtBQW1DZEMsU0FBTyxFQUFFLFlBbkNLO0FBb0NkQyxjQUFZLEVBQUUsa0JBcENBO0FBcUNkQyxZQUFVLEVBQUUsZUFyQ0U7QUFzQ2RDLFdBQVMsRUFBRSxjQXRDRztBQXVDZEMsVUFBUSxFQUFFLGFBdkNJO0FBd0NkQyxPQUFLLEVBQUUsVUF4Q087QUF5Q2RDLFdBQVMsRUFBRSxlQXpDRztBQTBDZEMsWUFBVSxFQUFFLGdCQTFDRTtBQTJDZEMsb0JBQWtCLEVBQUUseUJBM0NOO0FBNENkQyxrQkFBZ0IsRUFBRSx1QkE1Q0o7QUE2Q2RDLFNBQU8sRUFBRSxZQTdDSztBQThDZEMsWUFBVSxFQUFFLGdCQTlDRTtBQStDZEMsTUFBSSxFQUFFLFNBL0NRO0FBZ0RkQyxXQUFTLEVBQUUsZUFoREc7QUFpRGRDLGtCQUFnQixFQUFFLHNCQWpESjtBQWtEZEMsWUFBVSxFQUFFLGdCQWxERTtBQW1EZEMsaUJBQWUsRUFBRSxzQkFuREg7QUFvRGRDLG1CQUFpQixFQUFFLHdCQXBETDtBQXFEZEMsa0JBQWdCLEVBQUUsdUJBckRKO0FBc0RkQyxpQkFBZSxFQUFFLHNCQXRESDtBQXVEZEMsZ0JBQWMsRUFBRSxxQkF2REY7QUF3RGRDLE9BQUssRUFBRSxVQXhETztBQXlEZEMsUUFBTSxFQUFFLFdBekRNO0FBMERkQyxNQUFJLEVBQUUsU0ExRFE7QUEyRGRDLE9BQUssRUFBRSxVQTNETztBQTREZEMsUUFBTSxFQUFFLFdBNURNO0FBNkRkQyxTQUFPLEVBQUUsWUE3REs7QUE4RGRDLGdCQUFjLEVBQUUsb0JBOURGO0FBK0RkQyxpQkFBZSxFQUFFLHFCQS9ESDtBQWdFZEMsT0FBSyxFQUFFLFVBaEVPO0FBaUVkQyxRQUFNLEVBQUUsV0FqRU07QUFrRWRDLGtCQUFnQixFQUFFLHNCQWxFSjtBQW1FZEMsY0FBWSxFQUFFLGtCQW5FQTtBQW9FZEMsZUFBYSxFQUFFLG1CQXBFRDtBQXFFZEMsZ0JBQWMsRUFBRSxvQkFyRUY7QUFzRWRDLGlCQUFlLEVBQUUscUJBdEVIO0FBdUVkQyxRQUFNLEVBQUUsV0F2RU07QUF3RWRDLE1BQUksRUFBRSxTQXhFUTtBQXlFZEMsT0FBSyxFQUFFLFVBekVPO0FBMEVkQyxPQUFLLEVBQUUsVUExRU87QUEyRWRDLFNBQU8sRUFBRSxZQTNFSztBQTRFZEMsa0JBQWdCLEVBQUUsc0JBNUVKO0FBNkVkQyxhQUFXLEVBQUUsaUJBN0VDO0FBOEVkQyxPQUFLLEVBQUUsVUE5RU87QUErRWRDLFlBQVUsRUFBRSxnQkEvRUU7QUFnRmRDLFdBQVMsRUFBRSxlQWhGRztBQWlGZEMsWUFBVSxFQUFFLGdCQWpGRTtBQWtGZEMsUUFBTSxFQUFFLFdBbEZNO0FBbUZkQyxPQUFLLEVBQUUsVUFuRk87QUFvRmRDLFdBQVMsRUFBRSxlQXBGRztBQXFGZEMsWUFBVSxFQUFFLGdCQXJGRTtBQXNGZEMsUUFBTSxFQUFFLFdBdEZNO0FBdUZkQyxXQUFTLEVBQUUsZUF2Rkc7QUF3RmRDLFVBQVEsRUFBRSxjQXhGSTtBQXlGZEMsVUFBUSxFQUFFLFlBekZJO0FBMEZkQyxVQUFRLEVBQUUsWUExRkk7QUEyRmRDLFVBQVEsRUFBRTtBQTNGSSxDQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0lBRU1DLE9BQU8sR0FBRyxVQUFBQyxDQUFDO0FBQUEsU0FBSUEsQ0FBQyxJQUFJQSxDQUFDLEtBQUssQ0FBZjtBQUFBLEM7SUFDWEMsVUFBVSxHQUFHLFVBQUFELENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxVQUFqQjtBQUFBLEM7SUFDZEUsUUFBUSxHQUFHLFVBQUFGLENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxRQUFqQjtBQUFBLEM7SUFDWkcsUUFBUSxHQUFHLFVBQUFILENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxRQUFqQjtBQUFBLEM7SUFDWkksV0FBVyxHQUFHLFVBQUFKLENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxXQUFqQjtBQUFBLEM7SUFDZkssU0FBUyxHQUFHLFVBQUFMLENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxXQUFqQjtBQUFBLEM7SUFDYk0sU0FBUyxHQUFHLFVBQUFOLENBQUM7QUFBQSxTQUFJLE9BQU9BLENBQVAsS0FBYSxTQUFqQjtBQUFBLEM7SUFDYk8sTUFBTSxHQUFHLFVBQUFQLENBQUM7QUFBQSxTQUFJUSxJQUFJLENBQUNDLElBQUwsQ0FBVVQsQ0FBQyxHQUFHLEVBQWQsSUFBb0IsRUFBeEI7QUFBQSxDO0lBQ1ZVLFdBQVcsR0FBRyxVQUFBQyxDQUFDO0FBQUEsU0FBSUgsSUFBSSxDQUFDQyxJQUFMLENBQVVFLENBQVYsSUFBZSxFQUFuQjtBQUFBLEM7SUFDZkMsVUFBVSxHQUFHLFVBQUFDLENBQUM7QUFBQSxTQUFJQSxDQUFDLENBQUMsQ0FBRCxDQUFELEdBQU9BLENBQUMsQ0FBQyxDQUFELENBQVo7QUFBQSxDO0lBQ2RDLFlBQVksR0FBRyxVQUFBZCxDQUFDO0FBQUEsU0FBSSxpQkFBT0EsQ0FBUCxNQUFhLFFBQWpCO0FBQUEsQztJQUNoQmUsT0FBTyxHQUFHLFVBQUF2SCxDQUFDO0FBQUEsU0FDaEI0RyxXQUFXLENBQUM1RyxDQUFELENBQVgsSUFBa0JBLENBQUMsS0FBSyxJQUF4QixJQUNDMEcsUUFBUSxDQUFDMUcsQ0FBRCxDQUFSLElBQWVBLENBQUMsQ0FBQ3dILE1BQUYsS0FBYSxDQUQ3QixJQUVDRixZQUFZLENBQUN0SCxDQUFELENBQVosSUFBbUIsRUFBRUEsQ0FBQyxZQUFZeUgsSUFBZixDQUFuQixJQUEyQ0MsTUFBTSxDQUFDQyxJQUFQLENBQVkzSCxDQUFaLEVBQWV3SCxNQUFmLEtBQTBCLENBRnRFLElBR0NiLFFBQVEsQ0FBQzNHLENBQUQsQ0FBUixJQUFlNEgsS0FBSyxDQUFDNUgsQ0FBRCxDQUpMO0FBQUEsQztJQU1YNkgsUUFBUSxHQUFHLFVBQUE3SCxDQUFDO0FBQUEsU0FBSSxDQUFDdUgsT0FBTyxDQUFDdkgsQ0FBRCxDQUFaO0FBQUEsQztJQVFaOEgsT0FBTyxHQUFHLFVBQUFDLEdBQUc7QUFBQSxTQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsV0FBSixLQUFvQkMsS0FBL0I7QUFBQSxDO0lBUWJDLFFBQVEsR0FBRyxVQUFBQyxHQUFHO0FBQUEsU0FBSUEsR0FBRyxJQUFJLENBQUNBLEdBQUcsQ0FBQ0MsUUFBWixJQUF3QmQsWUFBWSxDQUFDYSxHQUFELENBQXBDLElBQTZDLENBQUNMLE9BQU8sQ0FBQ0ssR0FBRCxDQUF6RDtBQUFBLEM7SUFFZEUsU0FBUyxHQUFHLFVBQUNDLE9BQUQsRUFBVUMsR0FBVixFQUFlQyxZQUFmO0FBQUEsU0FDakIzQixTQUFTLENBQUN5QixPQUFPLENBQUNDLEdBQUQsQ0FBUixDQUFULEdBQTBCRCxPQUFPLENBQUNDLEdBQUQsQ0FBakMsR0FBeUNDLFlBRHhCO0FBQUEsQztJQUlaQyxhQUFRLEdBQUcsVUFBQ0MsSUFBRCxFQUFPQyxLQUFQLEVBQWlCO0FBQ2pDLE1BQUlDLEtBQUssS0FBVDtBQUlBLFNBRkFsQixNQUFNLENBQUNDLElBQVAsQ0FBWWUsSUFBWixFQUFrQkcsT0FBbEIsQ0FBMEIsVUFBQU4sR0FBRztBQUFBLFdBQUtHLElBQUksQ0FBQ0gsR0FBRCxDQUFKLEtBQWNJLEtBQWYsS0FBMEJDLEtBQUssS0FBL0IsQ0FBSjtBQUFBLEdBQTdCLENBRUEsRUFBT0EsS0FBUDtBQUNBLEM7SUFTS0UsTUFBTSxHQUFHLFVBQUNDLEVBQUQsRUFBaUI7QUFBQSxXQUN6QkMsSUFBSSxHQUFHdkMsVUFBVSxDQUFDc0MsRUFBRCxDQURRLDJCQUFURSxJQUFTLGtFQUFUQSxJQUFTOztBQUkvQixTQURBRCxJQUFJLElBQUlELEVBQUUsQ0FBQ0csSUFBSCxPQUFBSCxFQUFFLEVBQVNFLElBQVQsQ0FDVixFQUFPRCxJQUFQO0FBQ0EsQztJQVFLRyxRQUFRLEdBQUcsVUFBQUMsR0FBRztBQUFBLFNBQUsxQyxRQUFRLENBQUMwQyxHQUFELENBQVIsR0FBZ0JBLEdBQUcsQ0FBQ0MsT0FBSixDQUFZLElBQVosRUFBa0IsTUFBbEIsRUFBMEJBLE9BQTFCLENBQWtDLElBQWxDLEVBQXdDLE1BQXhDLENBQWhCLEdBQWtFRCxHQUF2RTtBQUFBLEM7SUFTZEUsWUFBWSxHQUFHLFVBQUNDLElBQUQsRUFBT3BFLElBQVAsRUFBOEI7QUFBQSxNQUFqQnFFLEVBQWlCLHVFQUFaLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxDQUFZO0FBQ2xELE1BQUtELElBQUQsSUFBVTdDLFFBQVEsQ0FBQ3ZCLElBQUQsQ0FBdEIsRUFJQSxJQUFJQSxJQUFJLENBQUN4RSxPQUFMLENBQWEsSUFBYixNQUF1QixDQUFDLENBQTVCLEVBQ0M0SSxJQUFJLENBQUNwRSxJQUFMLENBQVVBLElBQVYsQ0FERCxNQUVPO0FBQ04sUUFBTXNFLElBQUksR0FBRyxDQUFDRixJQUFJLENBQUNwRSxJQUFMLEVBQUQsRUFBY0EsSUFBZCxFQUFvQnVFLEdBQXBCLENBQXdCLFVBQUFsRCxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDNkMsT0FBRixDQUFVLFNBQVYsRUFBcUIsRUFBckIsQ0FBSjtBQUFBLEtBQXpCLENBQWI7O0FBRUEsUUFBSUksSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZQSxJQUFJLENBQUMsQ0FBRCxDQUFwQixFQUF5QjtBQUN4QixVQUFNRSxTQUFTLEdBQUd4RSxJQUFJLENBQUN5RSxLQUFMLENBQVcsSUFBWCxDQUFsQixDQUR3QixDQUd4Qjs7QUFDQUwsVUFBSSxDQUFDTSxJQUFMLENBQVUsRUFBVixDQUp3QixFQU14QkYsU0FBUyxDQUFDZCxPQUFWLENBQWtCLFVBQUNyQyxDQUFELEVBQUlzRCxDQUFKLEVBQVU7QUFDM0JQLFlBQUksQ0FBQ1EsTUFBTCxDQUFZLE9BQVosRUFDRUMsSUFERixDQUNPLEdBRFAsRUFDWSxDQURaLEVBRUVBLElBRkYsQ0FFTyxJQUZQLFlBRWdCRixDQUFDLEtBQUssQ0FBTixHQUFVTixFQUFFLENBQUMsQ0FBRCxDQUFaLEdBQWtCQSxFQUFFLENBQUMsQ0FBRCxDQUZwQyxTQUdFckUsSUFIRixDQUdPcUIsQ0FIUCxDQUQyQjtBQUszQixPQUxELENBTndCO0FBWXhCO0FBQ0Q7QUFDRCxDO0lBR0t5RCxjQUFjLEdBQUcsVUFBQUMsSUFBSSxFQUFJO0FBQzlCOzs7Ozs7O0FBRDhCLHNCQVFBQSxJQUFJLENBQUNDLE9BQUwsRUFSQTtBQUFBLE1BUXZCQyxDQVJ1QixpQkFRdkJBLENBUnVCO0FBQUEsTUFRcEJDLENBUm9CLGlCQVFwQkEsQ0FSb0I7QUFBQSxNQVFqQkMsS0FSaUIsaUJBUWpCQSxLQVJpQjtBQUFBLE1BUVZDLE1BUlUsaUJBUVZBLE1BUlU7O0FBVTlCLFNBQU8sQ0FDTjtBQUFDSCxLQUFDLEVBQURBLENBQUQ7QUFBSUMsS0FBQyxFQUFFQSxDQUFDLEdBQUdFO0FBQVgsR0FETSxFQUNjO0FBQ3BCO0FBQUNILEtBQUMsRUFBREEsQ0FBRDtBQUFJQyxLQUFDLEVBQURBO0FBQUosR0FGTSxFQUVFO0FBQ1I7QUFBQ0QsS0FBQyxFQUFFQSxDQUFDLEdBQUdFLEtBQVI7QUFBZUQsS0FBQyxFQUFEQTtBQUFmLEdBSE0sRUFHYTtBQUNuQjtBQUFDRCxLQUFDLEVBQUVBLENBQUMsR0FBR0UsS0FBUjtBQUFlRCxLQUFDLEVBQUVBLENBQUMsR0FBR0UsTUFBdEIsQ0FBOEI7O0FBQTlCLEdBSk0sQ0FBUDtBQU1BLEM7SUFFS0MsVUFBVSxHQUFHLFVBQUFOLElBQUksRUFBSTtBQUFBLDhCQUNGQSxJQUFJLENBQUNPLHFCQUFMLEVBREU7QUFBQSxNQUNuQkgsS0FEbUIseUJBQ25CQSxLQURtQjtBQUFBLE1BQ1pDLE1BRFkseUJBQ1pBLE1BRFk7QUFBQSxNQUVwQkcsS0FGb0IsR0FFWlQsY0FBYyxDQUFDQyxJQUFELENBRkY7QUFBQSxNQUdwQkUsQ0FIb0IsR0FHaEJNLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU04sQ0FITztBQUFBLE1BSXBCQyxDQUpvQixHQUloQnJELElBQUksQ0FBQzJELEdBQUwsQ0FBU0QsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTTCxDQUFsQixFQUFxQkssS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTTCxDQUE5QixDQUpnQjs7QUFNMUIsU0FBTztBQUNORCxLQUFDLEVBQURBLENBRE07QUFDSEMsS0FBQyxFQUFEQSxDQURHO0FBQ0FDLFNBQUssRUFBTEEsS0FEQTtBQUNPQyxVQUFNLEVBQU5BO0FBRFAsR0FBUDtBQUdBLEM7SUFHS0ssaUJBQWlCLEdBQUcsVUFBQUMsR0FBRyxFQUFJO0FBQUEsTUFDNUJDLFNBQVMsR0FBRyxJQURnQjtBQUFBLE1BRTFCQyxLQUFLLEdBQUdDLHdGQUZrQjtBQUFBLE1BRzFCQyxJQUFJLEdBQUdKLEdBQUcsQ0FBQ0ssT0FBSixJQUFlTCxHQUFHLENBQUNJLElBSEE7QUFhaEMsU0FQSUYsS0FBSyxJQUFJQSxLQUFLLENBQUMvQyxXQUFOLENBQWtCbUQsSUFBbEIsS0FBMkIsWUFPeEMsR0FOQ0wsU0FBUyxHQUFHQyxLQUFLLENBQUNELFNBTW5CLEdBSldHLElBQUksS0FBS0gsU0FBUyxHQUFHRyxJQUFJLENBQUNHLE1BQUwsWUFBZ0JDLGNBQUssQ0FBQzVKLEtBQXRCLEdBQStCOEgsSUFBL0IsRUFBakIsQ0FJZixLQUhDdUIsU0FBUyxHQUFHUSw2RkFBZ0IsQ0FBQ1IsU0FBRCxDQUc3QixHQUFPQSxTQUFQO0FBQ0EsQztJQUdLUyxTQUFTLEdBQUc7QUFBQSxNQUFDQyxLQUFEO0FBQUEsU0FBa0J4RSxJQUFJLENBQUN5RSxNQUFMLE1BQWlCRCxLQUFLLEdBQUcsRUFBSCxHQUFRLENBQTlCLENBQWxCO0FBQUEsQztJQUVaRSxVQUFVLEdBQUcsVUFBQWIsR0FBRyxFQUFJO0FBQ3pCLE1BQU1DLFNBQVMsR0FBR0YsaUJBQWlCLENBQUNDLEdBQUQsQ0FBbkM7QUFEeUIsVUFHckJDLFNBSHFCLElBT2pCQSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCQSxTQUFTLENBQUMsQ0FBRCxDQVBUO0FBV3pCLEM7SUFFS2EsTUFBTSxHQUFHLFlBQXlCO0FBQUEsTUFBeEJ6RyxNQUF3Qix1RUFBZixFQUFlO0FBQUEsTUFBWDBHLE1BQVc7O0FBQ3ZDLE9BQUssSUFBTUMsQ0FBWCxJQUFnQkQsTUFBaEIsRUFDQzFHLE1BQU0sQ0FBQzJHLENBQUQsQ0FBTixHQUFZRCxNQUFNLENBQUNDLENBQUQsQ0FEbkI7O0FBSUEsU0FBTzNHLE1BQVA7QUFDQSxDO0lBUUs0RyxVQUFVLEdBQUcsVUFBQTFDLEdBQUc7QUFBQSxTQUFJQSxHQUFHLENBQUMyQyxNQUFKLENBQVcsQ0FBWCxFQUFjQyxXQUFkLEtBQThCNUMsR0FBRyxDQUFDNkMsS0FBSixDQUFVLENBQVYsQ0FBbEM7QUFBQSxDO0lBUWhCQyxPQUFPLEdBQUcsVUFBQTFGLENBQUM7QUFBQSxTQUFJLEdBQUd5RixLQUFILENBQVMvQyxJQUFULENBQWMxQyxDQUFkLENBQUo7QUFBQSxDO0lBUVgyRixXQUFXLEdBQUcsVUFBQUMsV0FBVyxFQUFJO0FBQ2xDLE1BQUlDLEtBQUssR0FBRyxFQUFaO0FBWUEsU0FWQUQsV0FBVyxDQUFDdkQsT0FBWixDQUFvQixVQUFBeUQsS0FBSyxFQUFJO0FBQzVCLFFBQUk7QUFDQ0EsV0FBSyxDQUFDQyxRQUFOLElBQWtCRCxLQUFLLENBQUNDLFFBQU4sQ0FBZS9FLE1BRGxDLEtBRUY2RSxLQUFLLEdBQUdBLEtBQUssQ0FBQ0csTUFBTixDQUFhTixPQUFPLENBQUNJLEtBQUssQ0FBQ0MsUUFBUCxDQUFwQixDQUZOO0FBSUgsS0FKRCxDQUlFLE9BQU9FLENBQVAsRUFBVTtBQUNYQyxhQUFPLENBQUNDLEtBQVIsMENBQWdETCxLQUFLLENBQUNNLElBQXRELGVBQStESCxDQUFDLENBQUNJLFFBQUYsRUFBL0QsRUFEVztBQUVYO0FBQ0QsR0FSRCxDQVVBLEVBQU9SLEtBQVA7QUFDQSxDO0lBUUtTLFNBQVMsR0FBRyxVQUFBQyxJQUFJO0FBQUEsU0FBSUEsSUFBSSxDQUFDQyxNQUFMLENBQVksVUFBQ3hHLENBQUQsRUFBSXNELENBQUosRUFBTzdKLElBQVA7QUFBQSxXQUFnQkEsSUFBSSxDQUFDVSxPQUFMLENBQWE2RixDQUFiLE1BQW9Cc0QsQ0FBcEM7QUFBQSxHQUFaLENBQUo7QUFBQSxDO0lBUWhCbUQsVUFBVSxHQUFHLFVBQUFsRixHQUFHO0FBQUEsU0FBS0EsR0FBRyxJQUFJQSxHQUFHLENBQUNQLE1BQVgsR0FBb0JPLEdBQUcsQ0FBQ21GLE1BQUosQ0FBVyxVQUFDckIsQ0FBRCxFQUFJc0IsQ0FBSjtBQUFBLFdBQVV0QixDQUFDLENBQUNXLE1BQUYsQ0FBU1csQ0FBVCxDQUFWO0FBQUEsR0FBWCxDQUFwQixHQUF3RCxFQUE3RDtBQUFBLEM7SUFTaEJDLFFBQVE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFBRyxVQUFDbEksTUFBRCxFQUF3QjtBQUFBLHFDQUFabUksT0FBWSx3RUFBWkEsT0FBWTs7QUFDeEMsTUFBSSxDQUFDQSxPQUFPLENBQUM3RixNQUFULElBQW9CNkYsT0FBTyxDQUFDN0YsTUFBUixLQUFtQixDQUFuQixJQUF3QixDQUFDNkYsT0FBTyxDQUFDLENBQUQsQ0FBeEQsRUFDQyxPQUFPbkksTUFBUDtBQUdELE1BQU0wRyxNQUFNLEdBQUd5QixPQUFPLENBQUNDLEtBQVIsRUFBZjtBQWdCQSxTQWRJcEYsUUFBUSxDQUFDaEQsTUFBRCxDQUFSLElBQW9CZ0QsUUFBUSxDQUFDMEQsTUFBRCxDQWNoQyxJQWJDbEUsTUFBTSxDQUFDQyxJQUFQLENBQVlpRSxNQUFaLEVBQW9CL0MsT0FBcEIsQ0FBNEIsVUFBQU4sR0FBRyxFQUFJO0FBQ2xDLFFBQU1JLEtBQUssR0FBR2lELE1BQU0sQ0FBQ3JELEdBQUQsQ0FBcEI7QUFFSUwsWUFBUSxDQUFDUyxLQUFELENBSHNCLElBSWpDLENBQUN6RCxNQUFNLENBQUNxRCxHQUFELENBQVAsS0FBaUJyRCxNQUFNLENBQUNxRCxHQUFELENBQU4sR0FBYyxFQUEvQixDQUppQyxFQUtqQ3JELE1BQU0sQ0FBQ3FELEdBQUQsQ0FBTixHQUFjNkUsUUFBUSxDQUFDbEksTUFBTSxDQUFDcUQsR0FBRCxDQUFQLEVBQWNJLEtBQWQsQ0FMVyxJQU9qQ3pELE1BQU0sQ0FBQ3FELEdBQUQsQ0FBTixHQUFjVCxPQUFPLENBQUNhLEtBQUQsQ0FBUCxHQUNiQSxLQUFLLENBQUM2RCxNQUFOLEVBRGEsR0FDSTdELEtBUmU7QUFVbEMsR0FWRCxDQWFELEVBQU95RSxRQUFRLE1BQVIsVUFBU2xJLE1BQVQsU0FBb0JtSSxPQUFwQixFQUFQO0FBQ0EsQ0F0QmEsQztJQStCUkUsU0FBUyxHQUFHLFVBQUNSLElBQUQsRUFBd0I7QUFBQSxNQUNyQ2hFLEVBRHFDO0FBQUEsTUFBakJ5RSxLQUFpQjtBQWF6QyxTQVZJVCxJQUFJLENBQUMsQ0FBRCxDQUFKLFlBQW1CdEYsSUFVdkIsR0FUQ3NCLEVBQUUsR0FBR3lFLEtBQUssR0FBRyxVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxXQUFVRCxDQUFDLEdBQUdDLENBQWQ7QUFBQSxHQUFILEdBQXFCLFVBQUNELENBQUQsRUFBSUMsQ0FBSjtBQUFBLFdBQVVBLENBQUMsR0FBR0QsQ0FBZDtBQUFBLEdBU2hDLEdBUEtELEtBQUssSUFBSVQsSUFBSSxDQUFDWSxLQUFMLENBQVdDLE1BQVgsQ0FPZCxHQU5FN0UsRUFBRSxHQUFHLFVBQUMwRSxDQUFELEVBQUlDLENBQUo7QUFBQSxXQUFVRCxDQUFDLEdBQUdDLENBQWQ7QUFBQSxHQU1QLEdBTFksQ0FBQ0YsS0FLYixLQUpFekUsRUFBRSxHQUFHLFVBQUMwRSxDQUFELEVBQUlDLENBQUo7QUFBQSxXQUFXRCxDQUFDLEdBQUdDLENBQUosSUFBUyxDQUFDLENBQVgsSUFBa0JELENBQUMsR0FBR0MsQ0FBSixJQUFTLENBQTNCLElBQWtDRCxDQUFDLEtBQUtDLENBQU4sSUFBVyxDQUF2RDtBQUFBLEdBSVAsR0FBT1gsSUFBSSxDQUFDUCxNQUFMLEdBQWNxQixJQUFkLENBQW1COUUsRUFBbkIsQ0FBUDtBQUNBLEM7SUFTSytFLFNBQVMsR0FBRyxVQUFDQyxJQUFELEVBQU9oQixJQUFQLEVBQWdCO0FBQ2pDLE1BQUlpQixHQUFHLEdBQUdqQixJQUFJLENBQUNDLE1BQUwsQ0FBWSxVQUFBeEcsQ0FBQztBQUFBLFdBQUlxQixRQUFRLENBQUNyQixDQUFELENBQVo7QUFBQSxHQUFiLENBQVY7QUFZQSxTQVZJd0gsR0FBRyxDQUFDeEcsTUFVUixHQVRLYixRQUFRLENBQUNxSCxHQUFHLENBQUMsQ0FBRCxDQUFKLENBU2IsR0FSRUEsR0FBRyxHQUFHaEgsSUFBSSxDQUFDK0csSUFBRCxDQUFKLE9BQUEvRyxJQUFJLDhCQUFVZ0gsR0FBVixFQVFaLEdBUFlBLEdBQUcsQ0FBQyxDQUFELENBQUgsWUFBa0J2RyxJQU85QixLQU5FdUcsR0FBRyxHQUFHVCxTQUFTLENBQUNTLEdBQUQsRUFBTUQsSUFBSSxLQUFLLEtBQWYsQ0FBVCxDQUErQixDQUEvQixDQU1SLElBSENDLEdBQUcsR0FBR0MsU0FHUCxFQUFPRCxHQUFQO0FBQ0EsQztJQVNLRSxRQUFRLEdBQUcsVUFBQ0MsS0FBRCxFQUFRQyxHQUFSLEVBQWdCO0FBQ2hDLE1BQU1KLEdBQUcsR0FBRyxFQUFaOztBQUVBLE9BQUssSUFBSWxFLENBQUMsR0FBR3FFLEtBQWIsRUFBb0JyRSxDQUFDLEdBQUdzRSxHQUF4QixFQUE2QnRFLENBQUMsRUFBOUIsRUFDQ2tFLEdBQUcsQ0FBQ0ssSUFBSixDQUFTdkUsQ0FBVCxDQUREOztBQUlBLFNBQU9rRSxHQUFQO0FBQ0EsQztJQU1LTSxTQUFTLEdBQUcsWUFBTTtBQUN2QixNQUFJN04sU0FBUyxJQUFJOE4sWUFBakIsRUFBK0I7QUFBQSxRQUV4QkMsR0FBRyxzR0FBK0ZDLFFBQVEsR0FBR0EsUUFBUSxDQUFDQyxRQUFaLEdBQXVCLEVBQTlILENBRnFCO0FBQUEsUUFHeEJDLENBQUMsR0FBRyxDQUFDLElBQUlsSCxJQUFKLEVBSG1CO0FBQUEsUUFJeEJtSCxJQUFJLEdBQUcsQ0FBQ0wsWUFBWSxDQUFDTSxPQUFiLGFBSmdCO0FBQUEsUUFLeEJDLE1BQU0sYUFMa0I7QUFPOUIsUUFBSSxDQUFDRixJQUFELElBQVVBLElBQUksR0FBR0UsTUFBUixHQUFrQkgsQ0FBL0IsRUFHQyxJQUZBSixZQUFZLENBQUNRLE9BQWIsY0FBMEJKLENBQUMsR0FBR0csTUFBOUIsQ0FFQSxFQUFJck8sU0FBUyxDQUFDdU8sVUFBZCxFQUNDdk8sU0FBUyxDQUFDdU8sVUFBVixDQUFxQlIsR0FBckIsQ0FERCxNQUVPO0FBQ04sVUFBTTFFLENBQUMsR0FBRyxJQUFJbUYsS0FBSixFQUFWO0FBRUFuRixPQUFDLENBQUNvRixHQUFGLEdBQVFWLEdBSEYsRUFJTjFFLENBQUMsQ0FBQ3FGLEtBQUYsQ0FBUUMsT0FBUixHQUFrQixNQUpaLEVBTU43TyxRQUFRLENBQUM4TyxJQUFULENBQWNDLFdBQWQsQ0FBMEJ4RixDQUExQixDQU5NLEVBT052SixRQUFRLENBQUM4TyxJQUFULENBQWNFLFdBQWQsQ0FBMEJ6RixDQUExQixDQVBNO0FBUU47QUFFRjtBQUNELEM7SUFHSzBGLFlBQVksR0FBRztBQUNwQkMsT0FBSyxFQUFHLFlBQU07QUFDYixRQUFNQyxTQUFTLEdBQUc7QUFBQSxhQUFPO0FBQ3hCQyxlQUFPLElBRGlCO0FBQ1JDLGtCQUFVLElBREY7QUFDV0MsZUFBTyxFQUFFLENBRHBCO0FBQ3VCQyxlQUFPLEVBQUUsQ0FEaEM7QUFDbUNDLGVBQU8sRUFBRSxDQUQ1QztBQUMrQ0MsZUFBTyxFQUFFO0FBRHhELE9BQVA7QUFBQSxLQUFsQjs7QUFJQSxRQUFJO0FBSUgsYUFGQSxJQUFJQyxVQUFKLENBQWUsR0FBZixDQUVBLEVBQU8sVUFBQ0MsRUFBRCxFQUFLQyxTQUFMLEVBQXlDO0FBQUEsWUFBekJDLE1BQXlCLHVFQUFoQlYsU0FBUyxFQUFPO0FBQy9DUSxVQUFFLENBQUNHLGFBQUgsQ0FBaUIsSUFBSUosVUFBSixDQUFlRSxTQUFmLEVBQTBCQyxNQUExQixDQUFqQixDQUQrQztBQUUvQyxPQUZEO0FBR0EsS0FQRCxDQU9FLE9BQU8zRCxDQUFQLEVBQVU7QUFDWDtBQUNBLGFBQU8sVUFBQ3lELEVBQUQsRUFBS0MsU0FBTCxFQUF5QztBQUFBLFlBQXpCQyxNQUF5Qix1RUFBaEJWLFNBQVMsRUFBTztBQUFBLFlBQ3pDWSxVQUFVLEdBQUcvUCxRQUFRLENBQUNnUSxXQUFULENBQXFCLFlBQXJCLENBRDRCO0FBSS9DRCxrQkFBVSxDQUFDRSxjQUFYLENBQ0NMLFNBREQsRUFFQ0MsTUFBTSxDQUFDVCxPQUZSLEVBR0NTLE1BQU0sQ0FBQ1IsVUFIUixFQUlDMVAsTUFKRCxFQUtDLENBTEQsRUFLSTtBQUNIa1EsY0FBTSxDQUFDUCxPQU5SLEVBTWlCTyxNQUFNLENBQUNOLE9BTnhCLEVBT0NNLE1BQU0sQ0FBQ0wsT0FQUixFQU9pQkssTUFBTSxDQUFDSixPQVB4QixrQkFRNkIsQ0FSN0IsRUFRZ0MsSUFSaEMsQ0FKK0MsRUFlL0NFLEVBQUUsQ0FBQ0csYUFBSCxDQUFpQkMsVUFBakIsQ0FmK0M7QUFnQi9DLE9BaEJEO0FBaUJBO0FBQ0QsR0FoQ00sRUFEYTtBQWtDcEJHLE9BQUssRUFBRSxlQUFDUCxFQUFELEVBQUtDLFNBQUwsRUFBZ0JDLE1BQWhCLEVBQTJCO0FBQ2pDLFFBQU1NLFFBQVEsR0FBRyxJQUFJQyxLQUFKLENBQVVqSixNQUFNLENBQUNrSixNQUFQLENBQWM7QUFDeENDLGdCQUFVLEVBQUVwSixJQUFJLENBQUNxSixHQUFMLEVBRDRCO0FBRXhDNUwsWUFBTSxFQUFFZ0wsRUFGZ0M7QUFHeENhLGFBQU8sRUFBRSxHQUgrQjtBQUl4Q0MsYUFBTyxFQUFFLEdBSitCO0FBS3hDQyxtQkFBYSxFQUFFLEVBTHlCO0FBTXhDQyxXQUFLLEVBQUU7QUFOaUMsS0FBZCxFQU94QmQsTUFQd0IsQ0FBVixDQUFqQjtBQVNBRixNQUFFLENBQUNHLGFBQUgsQ0FBaUIsSUFBSWMsVUFBSixDQUFlaEIsU0FBZixFQUEwQjtBQUMxQ1AsZ0JBQVUsSUFEZ0M7QUFFMUNELGFBQU8sSUFGbUM7QUFHMUN5QixjQUFRLElBSGtDO0FBSTFDQyxhQUFPLEVBQUUsQ0FBQ1gsUUFBRCxDQUppQztBQUsxQ1ksbUJBQWEsRUFBRSxFQUwyQjtBQU0xQ0Msb0JBQWMsRUFBRSxDQUFDYixRQUFEO0FBTjBCLEtBQTFCLENBQWpCLENBVmlDO0FBa0JqQztBQXBEbUIsQztJQThEZmMsVUFBVSxHQUFHLFVBQUNDLEdBQUQsRUFBTTFFLElBQU4sRUFBZTtBQUNqQyxNQUFJaUIsR0FBRyxHQUFHeUQsR0FBVjs7QUFFQSxPQUFLLElBQU1ySCxDQUFYLElBQWdCMkMsSUFBaEIsRUFDQ2lCLEdBQUcsR0FBR0EsR0FBRyxDQUFDM0UsT0FBSixDQUFZLElBQUlxSSxNQUFKLGFBQWdCdEgsQ0FBaEIsUUFBc0IsR0FBdEIsQ0FBWixFQUF3QzJDLElBQUksQ0FBQzNDLENBQUQsQ0FBNUMsQ0FEUDs7QUFJQSxTQUFPNEQsR0FBUDtBQUNBLEM7Ozs7Ozs7Ozs7O0FDL2FEOzs7OztBQUtBO0FBQ0E7O0lBRXFCMkQscUM7OztBQUNwQiw4QkFBWUMsTUFBWixFQUFvQnhCLE1BQXBCLEVBQTRCO0FBQUE7O0FBQzNCLFFBQU15QixLQUFLLEdBQUdDLDBGQUFhLEVBQTNCO0FBRUEsU0FBS0YsTUFBTCxHQUFjQSxNQUhhLEVBSTNCLEtBQUtDLEtBQUwsR0FBYUEsS0FKYyxHQU12QkQsTUFBTSxDQUFDRyxZQUFQLElBQXVCLENBQUMzQixNQUFNLENBQUN3QixNQUFQLENBQWNJLG1CQU5mLE1BTzFCSixNQUFNLENBQUNLLGlCQUFQLEtBUDBCLEdBVzNCTCxNQUFNLENBQUNNLEtBQVAsR0FBZUwsS0FBSyxDQUFDTSxXQUFOLEdBQ2ROLEtBQUssQ0FBQ00sV0FBTixFQURjLEdBRWQsS0FBS0MsV0FBTCxDQUFpQixDQUFDaEMsTUFBTSxDQUFDaUMsU0FBUCxJQUFvQlIsS0FBckIsRUFBNEJLLEtBQTVCLEVBQWpCLENBYjBCO0FBYzNCO0FBRUQ7Ozs7Ozs7Ozs7MEJBaUNNcEgsUyxFQUFXVixDLEVBQUc7QUFBQTs7QUFDbkJVLGVBQVMsQ0FBQ2QsSUFBVixDQUFlLFdBQWYsRUFBNEIsVUFBQTNDLENBQUM7QUFBQSxtQ0FBaUJMLElBQUksQ0FBQ0MsSUFBTCxDQUFVbUQsQ0FBQyxDQUFDL0MsQ0FBRCxDQUFELEdBQU8sS0FBSSxDQUFDdUssTUFBTCxDQUFZVSxVQUE3QixDQUFqQjtBQUFBLE9BQTdCLENBRG1CO0FBRW5COzs7MEJBRUt4SCxTLEVBQVdULEMsRUFBRztBQUNuQlMsZUFBUyxDQUFDZCxJQUFWLENBQWUsV0FBZixFQUE0QixVQUFBM0MsQ0FBQztBQUFBLHFDQUFtQkwsSUFBSSxDQUFDQyxJQUFMLENBQVVvRCxDQUFDLENBQUNoRCxDQUFELENBQVgsQ0FBbkI7QUFBQSxPQUE3QixDQURtQjtBQUVuQjs7O2dDQUVXa0wsTSxFQUFRO0FBQUEsVUFDYnBFLEtBQUssR0FBR29FLE1BQU0sQ0FBQyxDQUFELENBREQ7QUFBQSxVQUViQyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0EsTUFBTSxDQUFDL0ssTUFBUCxHQUFnQixDQUFqQixDQUZBO0FBSW5CLGFBQU8yRyxLQUFLLEdBQUdxRSxJQUFSLEdBQWUsQ0FBQ3JFLEtBQUQsRUFBUXFFLElBQVIsQ0FBZixHQUErQixDQUFDQSxJQUFELEVBQU9yRSxLQUFQLENBQXRDO0FBQ0E7OztrQ0FFYTBELEssRUFBTztBQUNwQixVQUFNWSxLQUFLLEdBQUcsRUFBZDtBQUVBLFVBQUlaLEtBQUssQ0FBQ1ksS0FBVixFQUNDLE9BQU9aLEtBQUssQ0FBQ1ksS0FBTixPQUFBWixLQUFLLDhCQUNQLEtBQUtELE1BQUwsQ0FBWWMsYUFBWixJQUE2QixFQUR0QixFQUFMLENBRUxoSixHQUZLLENBRUQsVUFBQWxELENBQUM7QUFBQSxlQUNOO0FBQ0NFLGtCQUFRLENBQUNGLENBQUQsQ0FBUixJQUFlRyxRQUFRLENBQUNILENBQUQsQ0FBdkIsSUFBOEIsQ0FBQ29CLEtBQUssQ0FBQ3BCLENBQUQsQ0FBcEMsSUFDQVEsSUFBSSxDQUFDMkwsS0FBTCxDQUFXbk0sQ0FBQyxHQUFHLEVBQWYsSUFBcUIsRUFEdEIsSUFFS0E7QUFKQztBQUFBLE9BRkEsQ0FBUDs7QUFZRCxlQUZNK0wsTUFBTSxHQUFHVixLQUFLLENBQUNVLE1BQU4sRUFFZixFQUFTekksQ0FBQyxHQUFHOUMsSUFBSSxDQUFDQyxJQUFMLENBQVVzTCxNQUFNLENBQUMsQ0FBRCxDQUFoQixDQUFiLEVBQW1DekksQ0FBQyxHQUFHeUksTUFBTSxDQUFDLENBQUQsQ0FBN0MsRUFBa0R6SSxDQUFDLEVBQW5ELEVBQ0MySSxLQUFLLENBQUNwRSxJQUFOLENBQVd2RSxDQUFYLENBREQ7O0FBUUEsYUFKSTJJLEtBQUssQ0FBQ2pMLE1BQU4sR0FBZSxDQUFmLElBQW9CaUwsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLENBSW5DLElBSENBLEtBQUssQ0FBQ0csT0FBTixDQUFjSCxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVlBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV0EsS0FBSyxDQUFDLENBQUQsQ0FBNUIsQ0FBZCxDQUdELEVBQU9BLEtBQVA7QUFDQTs7O2dDQUVXO0FBQ1gsVUFBTUksUUFBUSxHQUFHLEtBQUtoQixLQUFMLENBQVdpQixJQUFYLEVBQWpCO0FBTUEsYUFKS0QsUUFBUSxDQUFDTixNQUFULEdBQWtCL0ssTUFJdkIsSUFIQ3FMLFFBQVEsQ0FBQ04sTUFBVCxDQUFnQixLQUFLVixLQUFMLENBQVdVLE1BQVgsRUFBaEIsQ0FHRCxFQUFPTSxRQUFQO0FBQ0E7OztrQ0FFYXJNLEMsRUFBRztBQUFBLFVBQ1Z1TSxVQUFVLEdBQUcsS0FBS25CLE1BQUwsQ0FBWW1CLFVBRGY7QUFBQSxVQU1WcEssS0FBSyxHQUFHLG1CQUFtQnFLLElBQW5CLENBQXdCeE0sQ0FBeEIsSUFBNkIsQ0FBQyxDQUFPQSxDQUFQLE9BQVU2QyxPQUFWLENBQWtCLE9BQWxCLEVBQTJCLEVBQTNCLENBQTlCLEdBQStEN0MsQ0FON0Q7QUFBQSxVQU9WeU0sU0FBUyxHQUFHRixVQUFVLEdBQUdBLFVBQVUsQ0FBQ3BLLEtBQUQsQ0FBYixHQUF1QkEsS0FQbkMsRUFHaEI7QUFDQTtBQUNBOztBQUlBLGFBQU85QixTQUFTLENBQUNvTSxTQUFELENBQVQsR0FBdUJBLFNBQXZCLEdBQW1DLEVBQTFDO0FBQ0E7OztrQ0FFYW5JLFMsRUFBVztBQUN4QixVQUFNOEcsTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBRUEsYUFBT0EsTUFBTSxDQUFDSyxpQkFBUCxHQUNObkgsU0FBUyxDQUFDb0ksU0FBVixFQURNLEdBQ2tCcEksU0FBUyxDQUFDcUksVUFBVixDQUFxQnZCLE1BQU0sQ0FBQ3VCLFVBQTVCLENBRHpCO0FBRUE7OztvQ0FoR3NCNUosSSxFQUFNO0FBQzVCO0FBQ0EsVUFBTTZKLElBQUksR0FBRztBQUNaQyxTQUFDLEVBQUUsR0FEUztBQUVaQyxTQUFDLEVBQUU7QUFGUyxPQUFiO0FBc0JBLGFBakJDL0osSUFBSSxDQUFDcEcsS0FBTCxFQUFELElBQWlCb0csSUFBSSxDQUFDNkIsTUFBTCxDQUFZLE1BQVosRUFDZmpHLElBRGUsQ0FDVixHQURVLEVBRWYrRCxJQUZlLENBRVYsVUFBQWdILEVBQUUsRUFBSTtBQUNYLFlBQUk7QUFBQSxpQ0FDcUJBLEVBQUUsQ0FBQzNHLElBQUgsR0FBVVksT0FBVixFQURyQjtBQUFBLGNBQ0lHLEtBREosb0JBQ0lBLEtBREo7QUFBQSxjQUNXQyxNQURYLG9CQUNXQSxNQURYOztBQUdDRCxlQUFLLElBQUlDLE1BSFYsS0FJRjZJLElBQUksQ0FBQ0MsQ0FBTCxHQUFTL0ksS0FKUCxFQUtGOEksSUFBSSxDQUFDRSxDQUFMLEdBQVMvSSxNQUxQLEdBUUgyRixFQUFFLENBQUMvSyxJQUFILENBQVEsRUFBUixDQVJHO0FBU0gsU0FURCxDQVNFLE9BQU9zSCxDQUFQLEVBQVUsQ0FBRTtBQUNkLE9BYmUsQ0FpQmpCLEVBRkEsS0FBSzhHLGVBQUwsR0FBdUI7QUFBQSxlQUFNSCxJQUFOO0FBQUEsT0FFdkIsRUFBT0EsSUFBUDtBQUNBOzs7Ozs7Ozs7QUN4REY7Ozs7O0FBS0E7QUFDQTtBQUNBOztJQUVxQkkseUI7OztBQUNwQiwwQkFBeUI7QUFBQSxRQUFicEQsTUFBYSx1RUFBSixFQUFJOztBQUFBOztBQUN4QixRQUFNd0IsTUFBTSxHQUFHO0FBQ2Q2QixtQkFBYSxFQUFFLENBREQ7QUFFZEMsbUJBQWEsRUFBRXRELE1BQU0sQ0FBQ3VELFNBQVAsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FGeEI7QUFHZEMsWUFBTSxFQUFFLFFBSE07QUFJZDFCLFdBQUssRUFBRSxFQUpPO0FBS2RRLG1CQUFhLEVBQUUsSUFMRDtBQU1kbUIsa0JBQVksRUFBRSxJQU5BO0FBT2RDLGlCQUFXLElBUEc7QUFRZGYsZ0JBQVUsRUFBRSxJQVJFO0FBU2RnQixnQkFBVSxFQUFFLENBVEU7QUFVZHpCLGdCQUFVLEVBQUUsQ0FWRTtBQVdkMEIsaUJBQVcsRUFBRSxDQVhDO0FBWWRDLGdCQUFVLEVBQUUsSUFaRTtBQWFkZCxnQkFBVSxFQUFFLElBYkU7QUFjZHBCLGtCQUFZLEVBQUUzQixNQUFNLENBQUMyQjtBQWRQLEtBQWY7QUFpQkFILFVBQU0sQ0FBQ21DLFVBQVAsR0FBb0IvTSxJQUFJLENBQUNrTixHQUFMLENBQVN0QyxNQUFNLENBQUM2QixhQUFoQixFQUErQixDQUEvQixJQUFvQzdCLE1BQU0sQ0FBQ29DLFdBbEJ2QyxFQW9CeEIsS0FBS0csTUFBTCxHQUFjLElBQUlDLHFDQUFKLENBQVd4QyxNQUFYLEVBQW1CeEIsTUFBbkIsQ0FwQlUsRUFxQnhCLEtBQUt3QixNQUFMLEdBQWNBLE1BckJVLEVBc0J4QixLQUFLeEIsTUFBTCxHQUFjQSxNQXRCVTtBQXVCeEI7QUFFRDs7Ozs7Ozs7OzJCQUtPaUUsQyxFQUFHO0FBQUEsVUFDSHhKLEdBQUcsR0FBRyxJQURIO0FBQUEsVUFFSCtHLE1BQU0sR0FBRyxLQUFLQSxNQUZYO0FBQUEsVUFHSHhCLE1BQU0sR0FBRyxLQUFLQSxNQUhYO0FBQUEsVUFJSGtFLFVBQVUsR0FBRyxLQUFLSCxNQUpmO0FBQUEsVUFLSHRDLEtBQUssR0FBR3lDLFVBQVUsQ0FBQ3pDLEtBTGhCO0FBQUEsVUFNSCtCLE1BQU0sR0FBR2hDLE1BQU0sQ0FBQ2dDLE1BTmI7QUFBQSxVQU9IVyxhQUFhLEdBQUcsS0FBS0EsYUFBTCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FQYjtBQUFBLFVBU0hDLFdBQVcsR0FBRyxpQkFBaUJ6QixJQUFqQixDQUFzQlksTUFBdEIsQ0FUWDtBQUFBLFVBVUhjLFdBQVcsR0FBRyxpQkFBaUIxQixJQUFqQixDQUFzQlksTUFBdEIsQ0FWWDtBQUFBLFVBYUhlLGFBQWEsR0FBR0wsVUFBVSxDQUFDSSxXQUFXLEdBQUcsT0FBSCxHQUFhLE9BQXpCLENBYnZCO0FBQUEsVUFjSEUsTUFBTSxHQUFHRCxhQUFhLEtBQUtMLFVBQVUsQ0FBQ3JULEtBQTdCLEdBQXFDLEdBQXJDLEdBQTJDLEdBZGpEO0FBQUEsVUFlSDRULElBQUksR0FBRyxlQUFlN0IsSUFBZixDQUFvQlksTUFBcEIsSUFBOEIsQ0FBQyxDQUEvQixHQUFtQyxDQWZ2QztBQUFBLFVBa0JIa0IsTUFBTSxHQUFHMUUsTUFBTSxDQUFDMkUsY0FsQmI7QUFvQlQsV0FBS25ELE1BQUwsQ0FBWU0sS0FBWixHQUFvQkwsS0FBSyxDQUFDTSxXQUFOLEdBQ25CTixLQUFLLENBQUNNLFdBQU4sRUFEbUIsR0FFbkJtQyxVQUFVLENBQUNsQyxXQUFYLENBQXVCLENBQUNoQyxNQUFNLENBQUNpQyxTQUFQLElBQW9CUixLQUFyQixFQUE0QkssS0FBNUIsRUFBdkIsQ0F0QlE7QUFBQSxvQkF3QmtDTixNQXhCbEM7QUFBQSxVQXdCRjZCLGFBeEJFLFdBd0JGQSxhQXhCRTtBQUFBLFVBd0JhTSxVQXhCYixXQXdCYUEsVUF4QmI7QUFBQSxVQXdCeUI3QixLQXhCekIsV0F3QnlCQSxLQXhCekI7QUFBQSxVQTJCSC9HLElBM0JHLEdBMkJJaUYsTUFBTSxDQUFDakYsSUEzQlg7QUFBQSxVQTRCSDZKLFdBNUJHLEdBNEJXN0osSUFBSSxJQUFJLGFBQWE2SCxJQUFiLENBQWtCN0gsSUFBbEIsQ0FBUixHQUNuQmlGLE1BQU0sQ0FBQ3dCLE1BQVAsZ0JBQXNCekcsSUFBdEIseUJBRG1CLEdBQ2dDO0FBQUNmLFNBQUMsRUFBRSxDQUFKO0FBQU9DLFNBQUMsRUFBRTtBQUFWLE9BN0IzQztBQUFBLFVBZ0NINEssTUFoQ0csR0FnQ005SixJQUFJLEtBQUssTUFBVCxzQ0FBOENBLElBQTlDLENBaENOO0FBQUEsVUFpQ0grSixRQWpDRyxHQWlDUTlFLE1BQU0sQ0FBQ3dCLE1BQVAsV0FBaUJxRCxNQUFqQixXQWpDUjtBQUFBLFVBa0NIRSxRQWxDRyxHQWtDUTtBQUNoQkMsWUFBSSxJQUFFRixRQUFGLElBQWE5RSxNQUFNLENBQUN3QixNQUFQLFdBQWlCcUQsTUFBakIsZ0JBREQ7QUFFaEI5UCxZQUFJLElBQUUrUCxRQUFGLElBQWE5RSxNQUFNLENBQUN3QixNQUFQLFdBQWlCcUQsTUFBakI7QUFGRCxPQWxDUjtBQUFBLFVBdUNMSSxFQXZDSyxHQXVDQSxJQXZDQSxFQTBCVDs7QUFlQWhCLE9BQUMsQ0FBQ2lCLElBQUYsQ0FBTyxZQUFXO0FBQUEsWUFDWGpCLENBQUMsR0FBR2tCLGlHQUFRLENBQUMsSUFBRCxDQUREO0FBQUEsWUFFYkMsTUFBTSxHQUFHLEtBQUtDLFNBQUwsSUFBa0I1RCxLQUZkO0FBQUEsWUFHYjZELE1BQU0sR0FBR3BCLFVBQVUsQ0FBQ3FCLFNBQVgsRUFISTtBQUtqQk4sVUFBRSxHQUFHaEIsQ0FMWSxFQU1qQixLQUFLb0IsU0FBTCxHQUFpQkMsTUFOQSxFQVFqQjlELE1BQU0sQ0FBQ1UsVUFBUCxHQUFvQmxDLE1BQU0sQ0FBQ3dGLFVBQVAsR0FDbkI1TyxJQUFJLENBQUNDLElBQUwsQ0FBVSxDQUFDeU8sTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFuQixJQUEwQixDQUFwQyxDQURtQixHQUNzQixDQVR6QjtBQVdqQjtBQUNBLFlBQU14TCxJQUFJLEdBQUdtSyxDQUFDLENBQUN3QixTQUFGLENBQVksU0FBWixFQUF1QjlJLElBQXZCLENBQTRCLENBQUMsQ0FBRCxDQUE1QixDQUFiLENBWmlCLENBY2pCOztBQVlBLFlBWEE3QyxJQUFJLENBQUM0TCxLQUFMLEdBQWEvTCxNQUFiLENBQW9CLE1BQXBCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCLFFBRGhCLEVBRUUrTCxLQUZGLENBRVF6QixVQUFVLENBQUMwQixhQUFYLENBQXlCOUwsSUFBekIsQ0FGUixFQUdFRixJQUhGLENBR08sR0FIUCxFQUdZLFlBQU07QUFDaEIsY0FBTWlNLGNBQWMsR0FBR3JFLE1BQU0sQ0FBQzhCLGFBQVAsR0FBdUJtQixJQUE5QztBQUVBLGlCQUFPSCxXQUFXLGNBQ2J4QyxLQUFLLENBQUMsQ0FBRCxDQURRLGNBQ0QrRCxjQURDLGdCQUNtQi9ELEtBQUssQ0FBQyxDQUFELENBRHhCLGNBQytCK0QsY0FEL0IsZUFFYkEsY0FGYSxjQUVLL0QsS0FBSyxDQUFDLENBQUQsQ0FGVixnQkFFbUJBLEtBQUssQ0FBQyxDQUFELENBRnhCLGNBRStCK0QsY0FGL0IsQ0FBbEI7QUFHQSxTQVRGLENBV0EsRUFBSWQsUUFBUSxDQUFDQyxJQUFULElBQWlCRCxRQUFRLENBQUNoUSxJQUE5QixFQUFvQztBQUNuQztBQURtQyxjQUU3QnNOLEtBQUssR0FBR2IsTUFBTSxDQUFDcUMsVUFBUCxJQUFxQkssVUFBVSxDQUFDNEIsYUFBWCxDQUF5QlIsTUFBekIsQ0FGQTtBQUFBLGNBSy9CTixJQUFJLEdBQUdmLENBQUMsQ0FBQ3dCLFNBQUYsQ0FBWSxPQUFaLEVBQ1Q5SSxJQURTLENBQ0owRixLQURJLEVBQ0dpRCxNQURILENBTHdCO0FBQUEsY0FTN0JTLFNBQVMsR0FBR2YsSUFBSSxDQUNwQlUsS0FEZ0IsR0FFaEJNLE1BRmdCLENBRVQsR0FGUyxFQUVKLFNBRkksRUFHaEJwTSxJQUhnQixDQUdYLE9BSFcsRUFHRixNQUhFLEVBSWhCbUYsS0FKZ0IsQ0FJVixTQUpVLEVBSUMsR0FKRCxDQVRpQjtBQUFBLGNBZ0I3QmtILFFBQVEsR0FBR2pCLElBQUksQ0FBQ2tCLElBQUwsR0FBWUMsTUFBWixFQWhCa0IsRUFJbkM7O0FBZUFuQixjQUFJLEdBQUdlLFNBQVMsQ0FBQ0osS0FBVixDQUFnQlgsSUFBaEIsQ0FuQjRCLEVBcUJuQ0QsUUFBUSxDQUFDQyxJQUFULElBQWlCZSxTQUFTLENBQUNwTSxNQUFWLENBQWlCLE1BQWpCLENBckJrQixFQXNCbkNvTCxRQUFRLENBQUNoUSxJQUFULElBQWlCZ1IsU0FBUyxDQUFDcE0sTUFBVixDQUFpQixNQUFqQixDQXRCa0I7QUFBQSxjQXdCN0J5TSxZQUFZLEdBQUdwQyxxQ0FBTSxDQUFDYixlQUFQLENBQXVCNkIsSUFBdkIsQ0F4QmM7QUFBQSxjQXlCN0JxQixNQUFNLEdBQUcsRUF6Qm9CO0FBQUEsY0EyQi9CQyxLQUFLLEdBQUd0QixJQUFJLENBQUNoSyxNQUFMLENBQVksTUFBWixFQUNWeUssU0FEVSxDQUNBLE9BREEsRUFFVjlJLElBRlUsQ0FFTCxVQUFDMUYsQ0FBRCxFQUFJc1AsS0FBSixFQUFjO0FBQ25CLGdCQUFNL00sS0FBSyxHQUFHd0csTUFBTSxDQUFDd0csYUFBUCxHQUNickMsYUFBYSxDQUFDbE4sQ0FBRCxFQUFJcU8sTUFBSixFQUFZakQsS0FBWixFQUFtQmdDLFdBQW5CLEVBQWdDK0IsWUFBWSxDQUFDbkQsQ0FBN0MsQ0FEQSxHQUVadkwsT0FBTyxDQUFDd00sVUFBVSxDQUFDdUMsYUFBWCxDQUF5QnhQLENBQXpCLENBQUQsQ0FBUCxHQUNDaU4sVUFBVSxDQUFDdUMsYUFBWCxDQUF5QnhQLENBQXpCLEVBQTRCbUYsTUFBNUIsRUFERCxHQUN3QyxDQUFDOEgsVUFBVSxDQUFDdUMsYUFBWCxDQUF5QnhQLENBQXpCLENBQUQsQ0FIMUM7QUFRQSxtQkFGQW9QLE1BQU0sQ0FBQ0UsS0FBRCxDQUFOLEdBQWdCL00sS0FBSyxDQUFDcEMsTUFFdEIsRUFBT29DLEtBQUssQ0FBQ0YsR0FBTixDQUFVLFVBQUFvTixRQUFRO0FBQUEscUJBQUs7QUFBQ0gscUJBQUssRUFBTEEsS0FBRDtBQUFRRyx3QkFBUSxFQUFSQTtBQUFSLGVBQUw7QUFBQSxhQUFsQixDQUFQO0FBQ0EsV0FaVSxDQTNCdUI7QUF5Q25DSixlQUFLLENBQUNKLElBQU4sR0FBYUMsTUFBYixFQXpDbUMsRUEyQ25DRyxLQUFLLEdBQUdBLEtBQUssQ0FDWFosS0FETSxHQUVOL0wsTUFGTSxDQUVDLE9BRkQsRUFHTmdNLEtBSE0sQ0FHQVcsS0FIQSxFQUlOdlIsSUFKTSxDQUlELFVBQUFrQyxDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ3lQLFFBQU47QUFBQSxXQUpBLENBM0MyQixFQWtEbkNKLEtBQUssQ0FDSDFNLElBREYsQ0FDTyxHQURQLEVBQ1kwSyxXQUFXLEdBQUcsQ0FBSCxHQUFPWCxVQUFVLEdBQUdjLElBRDNDLEVBRUU3SyxJQUZGLENBRU8sSUFGUCxFQUVjLFlBQU07QUFDbEIsZ0JBQUkrTSxFQUFFLEdBQUcsQ0FBVDtBQU1BLG1CQUpJbkQsTUFBTSxLQUFLLFFBQVgsSUFBdUJrQixNQUkzQixLQUhDaUMsRUFBRSxHQUFHLElBQUkvUCxJQUFJLENBQUNnUSxHQUFMLENBQVNoUSxJQUFJLENBQUNpUSxFQUFMLElBQVduQyxNQUFNLEdBQUcsR0FBcEIsQ0FBVCxDQUdWLEdBQU9pQyxFQUFFLElBQUkvQixXQUFXLENBQUM1SyxDQUFaLElBQWlCLENBQXJCLENBQVQ7QUFDQSxXQVJXLEVBRmIsRUFXRUosSUFYRixDQVdPLElBWFAsRUFXYSxVQUFDM0MsQ0FBRCxFQUFJeUMsQ0FBSixFQUFVO0FBQUEsZ0JBRWpCTixFQUFFLEdBQUcsQ0FGWTtBQWFyQixtQkFUSW9LLE1BQU0sS0FBSyxLQVNmLEtBUkNwSyxFQUFFLEdBQUdnTixZQUFZLENBQUNsRCxDQVFuQixFQU5LeEosQ0FBQyxLQUFLLENBTVgsS0FMRU4sRUFBRSxHQUFHaUwsV0FBVyxHQUFHLEVBQUUsQ0FBQ2dDLE1BQU0sQ0FBQ3BQLENBQUMsQ0FBQ3NQLEtBQUgsQ0FBTixHQUFrQixDQUFuQixLQUF5QkgsWUFBWSxDQUFDbEQsQ0FBYixHQUFpQixDQUExQyxJQUErQyxDQUFqRCxDQUFILEdBQ2QwQixXQUFXLENBQUMzSyxDQUFaLEtBQWtCLENBQWxCLGFBQWlDLENBSXJDLElBQU8xRCxRQUFRLENBQUM2QyxFQUFELENBQVIsSUFBZ0J3TCxXQUFXLENBQUMzSyxDQUE1QixHQUNOYixFQUFFLEdBQUd3TCxXQUFXLENBQUMzSyxDQURYLEdBQ2ViLEVBQUUsV0FEeEI7QUFFQSxXQTFCRixDQWxEbUM7QUFBQSxjQThFN0IwTixVQUFVLEdBQUc5QixJQUFJLENBQUNoSyxNQUFMLENBQVksTUFBWixDQTlFZ0I7QUFBQSxjQStFN0IrTCxVQUFVLEdBQUcvQixJQUFJLENBQUNoSyxNQUFMLENBQVksTUFBWixDQS9FZ0I7O0FBNEZuQyxjQVhBK0ssU0FBUyxDQUFDL0ssTUFBVixDQUFpQixNQUFqQixFQUF5QnBCLElBQXpCLFdBQWlDNEssTUFBakMsUUFBNENuQixhQUFhLEdBQUdvQixJQUE1RCxDQVdBLEVBVkFzQixTQUFTLENBQUMvSyxNQUFWLENBQWlCLE1BQWpCLEVBQXlCcEIsSUFBekIsV0FBaUM0SyxNQUFqQyxHQUEyQ2IsVUFBVSxHQUFHYyxJQUF4RCxDQVVBLEVBUkFoSyxHQUFHLENBQUN1TSx1QkFBSixDQUE0QkYsVUFBNUIsRUFBd0NDLFVBQXhDLENBUUEsRUFMQS9HLE1BQU0sQ0FBQ2lILFNBQVAsSUFBb0JGLFVBQVUsQ0FBQ3BOLE1BQS9CLElBQXlDb04sVUFBVSxDQUFDcE4sTUFBWCxDQUFrQixPQUFsQixFQUN2Q3VMLElBRHVDLENBQ2xDLFVBQVNxQixLQUFULEVBQWdCO0FBQ3JCcEIsNkdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZXBRLElBQWYsQ0FBb0JpTCxNQUFNLENBQUNpSCxTQUFQLENBQWlCVixLQUFqQixDQUFwQixDQURxQjtBQUVyQixXQUh1QyxDQUt6QyxFQUFJakIsTUFBTSxDQUFDNEIsU0FBWCxFQUFzQjtBQUFBLGdCQUNmbE4sQ0FBQyxHQUFHc0wsTUFEVztBQUFBLGdCQUVmcUIsRUFBRSxHQUFHM00sQ0FBQyxDQUFDa04sU0FBRixLQUFnQixDQUZOO0FBSXJCOUIsa0JBQU0sR0FBRyxVQUFBbk8sQ0FBQztBQUFBLHFCQUFJK0MsQ0FBQyxDQUFDL0MsQ0FBRCxDQUFELEdBQU8wUCxFQUFYO0FBQUEsYUFKVyxFQUtyQnJCLE1BQU0sR0FBR0YsTUFMWTtBQU1yQixXQU5ELE1BTVdBLE1BQU0sQ0FBQzhCLFNBTmxCLEdBT0M5QixNQUFNLEdBQUdFLE1BUFYsR0FTQ2YsYUFBYSxDQUFDekwsSUFBZCxDQUFtQm9MLFVBQW5CLEVBQStCK0IsUUFBL0IsRUFBeUNYLE1BQXpDLENBVEQ7O0FBWUFmLHVCQUFhLENBQUN6TCxJQUFkLENBQW1Cb0wsVUFBbkIsRUFBK0I2QixTQUEvQixFQUEwQ1gsTUFBMUMsQ0F4R21DLEVBeUduQ2IsYUFBYSxDQUFDekwsSUFBZCxDQUFtQm9MLFVBQW5CLEVBQStCQSxVQUFVLENBQUMwQixhQUFYLENBQXlCWixJQUF6QixFQUErQmpHLEtBQS9CLENBQXFDLFNBQXJDLEVBQWdELEdBQWhELENBQS9CLEVBQXFGdUcsTUFBckYsQ0F6R21DO0FBMEduQztBQUNELE9BcklELENBekNTLEVBZ0xULEtBQUtyQixDQUFMLEdBQVNnQixFQWhMQTtBQWlMVDtBQUVEOzs7Ozs7OztnQ0FLWTtBQUFBLFVBQ0x6RCxNQUFNLEdBQUcsS0FBS0EsTUFEVDtBQUFBLFVBRUwyRixHQUFHLEdBQUc7QUFBQ25OLFNBQUMsRUFBRSxDQUFKO0FBQU9DLFNBQUMsRUFBRTtBQUFWLE9BRkQ7QUFTWCxhQUxJLEtBQUsrRixNQUFMLENBQVl3RixVQUtoQixLQUpDMkIsR0FBRyxDQUFDbk4sQ0FBSixHQUFRd0gsTUFBTSxDQUFDaUMsWUFBUCxHQUFzQixDQUF0QixHQUEwQmpDLE1BQU0sQ0FBQ1UsVUFJMUMsRUFIQ2lGLEdBQUcsQ0FBQ2xOLENBQUosR0FBUXVILE1BQU0sQ0FBQ2lDLFlBQVAsR0FBc0JqQyxNQUFNLENBQUNVLFVBQTdCLEdBQTBDLENBR25ELEdBQU9pRixHQUFQO0FBQ0E7QUFFRDs7Ozs7Ozs7O2dDQU1ZbFEsQyxFQUFHO0FBQUEsVUFDUndLLEtBQUssR0FBRyxLQUFLc0MsTUFBTCxDQUFZdEMsS0FEWjtBQUFBLFVBRVJELE1BQU0sR0FBRyxLQUFLQSxNQUZOO0FBQUEsVUFHUjZCLGFBQWEsR0FBRzdCLE1BQU0sQ0FBQzZCLGFBSGY7QUFBQSxVQUlSdkIsS0FBSyxHQUFHTixNQUFNLENBQUNNLEtBSlA7QUFBQSxVQU1Sc0YsWUFBWSxHQUFHM0YsS0FBSyxDQUFDeEssQ0FBRCxDQUFMLElBQ25CdUssTUFBTSxDQUFDaUMsWUFBUCxHQUFzQixDQUF0QixHQUEwQmpDLE1BQU0sQ0FBQ1UsVUFEZCxDQU5QO0FBU2QsYUFBT0osS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXc0YsWUFBWCxJQUEyQkEsWUFBWSxHQUFHdEYsS0FBSyxDQUFDLENBQUQsQ0FBL0MsR0FBcUR1QixhQUFyRCxHQUFxRSxDQUE1RTtBQUNBO0FBRUQ7Ozs7Ozs7Ozs7NENBT3dCeUQsVSxFQUFZQyxVLEVBQVk7QUFDekMsVUFBQU0sT0FBTyxHQUFHLEtBQUtDLFNBQUwsRUFBVjtBQUFBLHlCQUNrRCxLQUFLOUYsTUFEdkQ7QUFBQSxVQUNDNkIsYUFERCxnQkFDQ0EsYUFERDtBQUFBLFVBQ2dCRyxNQURoQixnQkFDZ0JBLE1BRGhCO0FBQUEsVUFDd0JHLFVBRHhCLGdCQUN3QkEsVUFEeEI7QUFBQSxVQUNvQ3pCLFVBRHBDLGdCQUNvQ0EsVUFEcEM7QUFBQSxVQUVBd0MsTUFGQSxHQUVTLEtBQUsxRSxNQUFMLENBQVkyRSxjQUZyQjtBQVFFbkIsWUFUdUMsS0FVekMsUUFWeUMsSUFXN0NzRCxVQUFVLENBQ1JsTixJQURGLENBQ08sSUFEUCxFQUNheU4sT0FBTyxDQUFDck4sQ0FEckIsRUFFRUosSUFGRixDQUVPLElBRlAsRUFFYXlOLE9BQU8sQ0FBQ3JOLENBRnJCLEVBR0VKLElBSEYsQ0FHTyxJQUhQLEVBR2EsS0FBSzJOLFdBQUwsQ0FBaUJuRCxJQUFqQixDQUFzQixJQUF0QixDQUhiLENBWDZDLEVBZ0I3QzJDLFVBQVUsQ0FDUm5OLElBREYsQ0FDTyxHQURQLEVBQ1ksQ0FEWixFQUVFQSxJQUZGLENBRU8sR0FGUCxFQVRlLGtCQUFBNE4sQ0FBQztBQUFBLGVBQUtBLENBQUMsR0FBRyxPQUFPLE9BQU9BLENBQUMsR0FBRyxFQUFYLEtBQWtCQSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVIsR0FBWSxDQUFDLENBQS9CLENBQVYsR0FBOEM3RCxVQUFwRDtBQUFBLE9BV0osQ0FBU2UsTUFBVCxDQUZaLEVBR0UzRixLQUhGLENBR1EsYUFIUixFQVh3QiwyQkFBQXlJLENBQUM7QUFBQSxlQUFNQSxDQUFELEdBQWlCQSxDQUFDLEdBQUcsQ0FBSixHQUFRLE9BQVIsR0FBa0IsS0FBbkMsR0FBSyxRQUFWO0FBQUEsT0FjRixDQUFrQjlDLE1BQWxCLENBSHZCLEVBSUU5SyxJQUpGLENBSU8sV0FKUCxFQVZvQix1QkFBQTROLENBQUM7QUFBQSxlQUFLQSxDQUFDLG9CQUFhQSxDQUFiLFNBQW9CLElBQTFCO0FBQUEsT0FjRCxDQUFjOUMsTUFBZCxDQUpwQixDQWhCNkMsSUFTdkNsQixNQVR1QyxLQXNCekMsS0F0QnlDLElBdUI3Q3NELFVBQVUsQ0FDUmxOLElBREYsQ0FDTyxJQURQLEVBQ2EsQ0FEYixFQUVFQSxJQUZGLENBRU8sSUFGUCxFQUVhLENBQUN5SixhQUZkLENBdkI2QyxFQTJCN0MwRCxVQUFVLENBQ1JuTixJQURGLENBQ08sR0FEUCxFQUNZLENBRFosRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWSxDQUFDK0osVUFBRCxHQUFjLENBRjFCLEVBR0U1RSxLQUhGLENBR1EsYUFIUixFQUd1QixRQUh2QixDQTNCNkMsSUFTdkN5RSxNQVR1QyxLQWdDekMsTUFoQ3lDLElBaUM3Q3NELFVBQVUsQ0FDUmxOLElBREYsQ0FDTyxJQURQLEVBQ2EsQ0FBQ3lKLGFBRGQsRUFFRXpKLElBRkYsQ0FFTyxJQUZQLEVBRWF5TixPQUFPLENBQUNwTixDQUZyQixFQUdFTCxJQUhGLENBR08sSUFIUCxFQUdheU4sT0FBTyxDQUFDcE4sQ0FIckIsQ0FqQzZDLEVBc0M3QzhNLFVBQVUsQ0FDUm5OLElBREYsQ0FDTyxHQURQLEVBQ1ksQ0FBQytKLFVBRGIsRUFFRS9KLElBRkYsQ0FFTyxHQUZQLEVBRVlzSSxVQUZaLEVBR0VuRCxLQUhGLENBR1EsYUFIUixFQUd1QixLQUh2QixDQXRDNkMsSUFTdkN5RSxNQVR1QyxLQTJDekMsT0EzQ3lDLElBNEM3Q3NELFVBQVUsQ0FDUmxOLElBREYsQ0FDTyxJQURQLEVBQ2F5SixhQURiLEVBRUV6SixJQUZGLENBRU8sSUFGUCxFQUVhLENBRmIsQ0E1QzZDLEVBZ0Q3Q21OLFVBQVUsQ0FDUm5OLElBREYsQ0FDTyxHQURQLEVBQ1krSixVQURaLEVBRUUvSixJQUZGLENBRU8sR0FGUCxFQUVZLENBRlosRUFHRW1GLEtBSEYsQ0FHUSxhQUhSLEVBR3VCLE9BSHZCLENBaEQ2QztBQXFEL0MsSyxDQUVEOzs7O2tDQUNjOUgsQyxFQUFHd0ssSyxFQUFPWSxLLEVBQU9nQyxXLEVBQWFvRCxTLEVBQVc7QUF1QnRELGVBQVNqTyxLQUFULENBQWVrTixRQUFmLEVBQXlCM1IsSUFBekIsRUFBK0I7QUFLOUIsaUJBSkkyUyxPQUlKLEVBSElDLFVBR0osRUFGSUMsU0FFSixFQUFTbE8sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzNFLElBQUksQ0FBQ3FDLE1BQXpCLEVBQWlDc0MsQ0FBQyxFQUFsQyxFQVFDO0FBQ0EsWUFSSTNFLElBQUksQ0FBQzRHLE1BQUwsQ0FBWWpDLENBQVosTUFBbUIsR0FRdkIsS0FQQ2lPLFVBQVUsR0FBR2pPLENBT2QsR0FKQWdPLE9BQU8sR0FBRzNTLElBQUksQ0FBQzhTLE1BQUwsQ0FBWSxDQUFaLEVBQWVuTyxDQUFDLEdBQUcsQ0FBbkIsQ0FJVixFQUhBa08sU0FBUyxHQUFHSCxTQUFTLEdBQUdDLE9BQU8sQ0FBQ3RRLE1BR2hDLEVBQUkwUSxTQUFTLEdBQUdGLFNBQWhCLEVBQ0MsT0FBT3BPLEtBQUssQ0FDWGtOLFFBQVEsQ0FBQ3RLLE1BQVQsQ0FBZ0JySCxJQUFJLENBQUM4UyxNQUFMLENBQVksQ0FBWixFQUFlRixVQUFVLElBQUlqTyxDQUE3QixDQUFoQixDQURXLEVBRVgzRSxJQUFJLENBQUM4RyxLQUFMLENBQVc4TCxVQUFVLEdBQUdBLFVBQVUsR0FBRyxDQUFoQixHQUFvQmpPLENBQXpDLENBRlcsQ0FBWjs7QUFPRixlQUFPZ04sUUFBUSxDQUFDdEssTUFBVCxDQUFnQnJILElBQWhCLENBQVA7QUFDQTs7QUE5Q3FELFVBQ2hEaUwsTUFBTSxHQUFHLEtBQUtBLE1BRGtDO0FBQUEsVUFFaEQrSCxRQUFRLEdBQUcsS0FBS2hFLE1BQUwsQ0FBWTBDLGFBQVosQ0FBMEJ4UCxDQUExQixDQUZxQztBQUFBLFVBR2hEeVAsUUFBUSxHQUFHcFEsUUFBUSxDQUFDeVIsUUFBRCxDQUFSLElBQXNCQSxRQUFRLENBQUN4WCxPQUFULENBQWlCLElBQWpCLElBQXlCLENBQUMsQ0FBaEQsR0FDaEJ3WCxRQUFRLENBQUN2TyxLQUFULENBQWUsSUFBZixDQURnQixHQUNPLEVBSjhCO0FBTXRELFVBQUlrTixRQUFRLENBQUN0UCxNQUFiLEVBQ0MsT0FBT3NQLFFBQVA7QUFHRCxVQUFJaFAsT0FBTyxDQUFDcVEsUUFBRCxDQUFYLEVBQ0MsT0FBT0EsUUFBUDtBQUdELFVBQUlELFNBQVMsR0FBRzlILE1BQU0sQ0FBQzhILFNBQXZCO0FBa0NBLGNBaENJLENBQUNBLFNBQUQsSUFBY0EsU0FBUyxJQUFJLENBZ0MvQixNQS9CQ0EsU0FBUyxHQUFHekQsV0FBVyxHQUFHLEVBQUgsR0FDdEJyRSxNQUFNLENBQUN3RixVQUFQLEdBQ0U1TyxJQUFJLENBQUNDLElBQUwsQ0FBVTRLLEtBQUssQ0FBQ1ksS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFMLEdBQWtCWixLQUFLLENBQUNZLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBakMsSUFBK0MsRUFEakQsR0FDdUQsR0E2QnpELEdBQU83SSxLQUFLLENBQUNrTixRQUFELEVBQWtCcUIsUUFBbEIsTUFBWjtBQUNBOzs7MEJBRUsvTixDLEVBQUc7QUFBQSxhQUNIZ08sU0FBUyxDQUFDNVEsTUFEUCxJQUtSLEtBQUsyTSxNQUFMLENBQVl0QyxLQUFaLEdBQW9CekgsQ0FMWixFQU9ELElBUEMsSUFFQSxLQUFLK0osTUFBTCxDQUFZdEMsS0FGWjtBQVFSOzs7MkJBRU16SCxDLEVBQUc7QUFBQSxhQUNKZ08sU0FBUyxDQUFDNVEsTUFETixJQUtULEtBQUtvSyxNQUFMLENBQVlnQyxNQUFaLEdBQXFCeEosQ0FBQyxJQUFJO0FBQ3pCaU8sV0FBRyxFQUFFLENBRG9CO0FBRXpCQyxhQUFLLEVBQUUsQ0FGa0I7QUFHekJDLGNBQU0sRUFBRSxDQUhpQjtBQUl6QkMsWUFBSSxFQUFFO0FBSm1CLE9BQUwsR0FLVnBPLENBTFUsUUFLTCxRQVZQLEVBWUYsSUFaRSxJQUVELEtBQUt3SCxNQUFMLENBQVlnQyxNQUZYO0FBYVQ7OzsrQkFFVTZFLE0sRUFBUTtBQUFBLGFBQ2JMLFNBQVMsQ0FBQzVRLE1BREcsSUFLbEIsS0FBS29LLE1BQUwsQ0FBWW1CLFVBQVosR0FBeUIwRixNQUxQLEVBT1gsSUFQVyxJQUVWLEtBQUs3RyxNQUFMLENBQVltQixVQUZGO0FBUWxCOzs7aUNBRVkyRixVLEVBQVk7QUFDeEIsVUFBTTlHLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUR3QixhQUduQndHLFNBQVMsQ0FBQzVRLE1BSFMsSUFPeEJvSyxNQUFNLENBQUNpQyxZQUFQLEdBQXNCNkUsVUFQRSxFQVNqQixJQVRpQixJQUloQjlHLE1BQU0sQ0FBQ2lDLFlBSlM7QUFVeEI7QUFFRDs7Ozs7Ozs7O2lDQU1hO0FBQ1osYUFBTyxLQUFLakMsTUFBTCxDQUFZVSxVQUFuQjtBQUNBO0FBRUQ7Ozs7Ozs7OztpQ0FNYWMsSSxFQUFNO0FBQ2xCLFVBQUl1RixRQUFKO0FBRUEsVUFBSSxLQUFLdkksTUFBTCxDQUFZd0YsVUFBaEIsRUFDQytDLFFBQVEsR0FBRyxLQUFLL0csTUFBTCxDQUFZVSxVQUFaLEdBQXlCLENBRHJDLE1BRU87QUFDTixZQUFNOUssTUFBTSxHQUFHLEtBQUs2TSxDQUFMLENBQU9qSixNQUFQLENBQWMsYUFBZCxFQUNiN0IsSUFEYSxHQUVicVAsY0FGYSxLQUVNLEtBQUtoSCxNQUFMLENBQVk4QixhQUFaLEdBQTRCLENBRmpEO0FBSUFpRixnQkFBUSxHQUFHblIsTUFBTSxJQUFJNEwsSUFBSSxJQUFJLEtBQUtpQixDQUFMLENBQU93QixTQUFQLENBQWlCLE1BQWpCLEVBQXlCekMsSUFBekIsRUFBWixDQUxYO0FBTU47QUFFRCxhQUFPdUYsUUFBUSxLQUFLRSxRQUFiLEdBQXdCLENBQXhCLEdBQTRCRixRQUFuQztBQUNBOzs7NEJBRWM7QUFBQSxlQUNSL0csTUFBTSxHQUFHLEtBQUtBLE1BRE4sMkJBQU4zSSxJQUFNLCtDQUFOQSxJQUFNOztBQUFBLGFBR1RBLElBQUksQ0FBQ3pCLE1BSEksSUFPZG9LLE1BQU0sQ0FBQ2MsYUFBUCxHQUF1QnhHLE9BQU8sQ0FBQ2pELElBQUQsQ0FQaEIsRUFTUCxJQVRPLElBSU4ySSxNQUFNLENBQUNjLGFBSkQ7QUFVZDs7O2dDQUVXb0csTyxFQUFTO0FBQ3BCLFVBQU1sSCxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFEb0IsYUFHZndHLFNBQVMsQ0FBQzVRLE1BSEssSUFPcEJvSyxNQUFNLENBQUNrQyxXQUFQLEdBQXFCZ0YsT0FQRCxFQVNiLElBVGEsSUFJWmxILE1BQU0sQ0FBQ2tDLFdBSks7QUFVcEI7OzsrQkFFVTFKLEMsRUFBRztBQUFBO0FBQUEsVUFDUHdILE1BQU0sR0FBRyxLQUFLQSxNQURQOztBQUdiLFVBQUluTCxVQUFVLENBQUMyRCxDQUFELENBQWQsRUFDQ3dILE1BQU0sQ0FBQ3FDLFVBQVAsR0FBb0I7QUFBQSxlQUFNN0osQ0FBQyxDQUFDLEtBQUksQ0FBQytKLE1BQUwsQ0FBWXRDLEtBQVosQ0FBa0JVLE1BQWxCLEVBQUQsQ0FBUDtBQUFBLE9BRHJCLE1BRU87QUFDTixZQUFJLENBQUM2RixTQUFTLENBQUM1USxNQUFmLEVBQ0MsT0FBT29LLE1BQU0sQ0FBQ3FDLFVBQWQ7QUFHRHJDLGNBQU0sQ0FBQ3FDLFVBQVAsR0FBb0I3SixDQUxkO0FBTU47QUFFRCxhQUFPLElBQVA7QUFDQTs7O2tDQUVhdUUsQyxFQUFHO0FBR2hCLGFBRkEsS0FBS2lELE1BQUwsQ0FBWXVCLFVBQVosR0FBeUJ4RSxDQUV6QixFQUFPLElBQVA7QUFDQTs7Ozs7Ozs7OztBQzNlRjs7OztBQUlBO0FBTUE7QUFDQTtBQUNBOztJQUVNb0ssWUFBWSxHQUFHLFVBQUNDLEVBQUQsRUFBS0MsYUFBTCxFQUF1QjtBQUMzQyxNQUFNQyxTQUFTLEdBQUdGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBQTVCO0FBRUEsU0FBT0YsYUFBYSxHQUFHQyxTQUFILEdBQWUsQ0FBQ0EsU0FBcEM7QUFDQSxDO0lBRUtFLGdCQUFnQixHQUFHLFVBQUFDLEVBQUU7QUFBQSxtQkFBT2hPLGNBQUssQ0FBQ3JLLElBQWIsY0FBcUJxSyxjQUFLLGVBQVFTLFVBQVUsQ0FBQ3VOLEVBQUQsQ0FBbEIsRUFBMUI7QUFBQSxDOztJQUVOQyxTOzs7QUFDcEIsZ0JBQVlDLEtBQVosRUFBbUI7QUFBQSwwQ0FDbEIsS0FBS0EsS0FBTCxHQUFhQSxLQURLLEVBRWxCLEtBQUtDLFNBQUwsRUFGa0I7QUFHbEI7Ozs7MkJBRU07QUFBQTtBQUFBLFVBQ0FSLEVBQUUsR0FBRyxLQUFLTyxLQURWO0FBQUEsVUFFQTNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlo7QUFBQSxVQUdBc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIbkI7QUFBQSxVQUlBbE8sSUFBSSxHQUFHK04sRUFBRSxDQUFDL04sSUFKVjtBQUFBLFVBS0EvRixNQUFNLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUxUOztBQU9OME0sWUFBTSxDQUFDNkgsWUFBUCxJQUF1QnZVLE1BQU0sQ0FBQ21KLElBQVAsQ0FBWSxJQUFaLENBUGpCLEVBU04ySyxFQUFFLENBQUNVLFFBQUgsR0FBYyxFQVRSLEVBV054VSxNQUFNLENBQUMyRCxPQUFQLENBQWUsVUFBQXJDLENBQUMsRUFBSTtBQUFBLFlBQ2JtVCxTQUFTLEdBQUdQLGdCQUFnQixDQUFDNVMsQ0FBRCxDQURmO0FBQUEsWUFFYm9ULFVBQVUsR0FBR3ZPLGNBQUssZUFBUVMsVUFBVSxDQUFDdEYsQ0FBRCxDQUFsQixXQUZMO0FBSW5Cd1MsVUFBRSxDQUFDYSxJQUFILENBQVFyVCxDQUFSLElBQWF5RSxJQUFJLENBQUNsQixNQUFMLENBQVksR0FBWixFQUNYQyxJQURXLENBQ04sT0FETSxFQUNHMlAsU0FESCxFQUVYM1AsSUFGVyxDQUVOLFdBRk0sRUFFTyxZQUFNO0FBQ3hCLGNBQUlnRSxHQUFHLEdBQUcsSUFBVjtBQVFBLGlCQU5JeEgsQ0FBQyxLQUFLLEdBTVYsR0FMQ3dILEdBQUcsR0FBR2dMLEVBQUUsQ0FBQ2MsZ0JBS1YsR0FKV3RULENBQUMsS0FBSyxHQUFOLElBQWFvTCxNQUFNLENBQUNtSSxZQUkvQixLQUhDL0wsR0FBRyxHQUFHZ0wsRUFBRSxDQUFDZ0IsZ0JBR1YsR0FBT2hNLEdBQVA7QUFDQSxTQVpXLEVBYVhoRSxJQWJXLENBYU4sV0FiTSxFQWFPZ1AsRUFBRSxDQUFDaUIsWUFBSCxDQUFnQnpULENBQWhCLENBYlAsRUFjWDJJLEtBZFcsQ0FjTCxZQWRLLEVBY1N5QyxNQUFNLGdCQUFTcEwsQ0FBVCxXQUFOLEdBQTJCLFNBQTNCLEdBQXVDLFFBZGhELENBSk0sRUFvQm5Cd1MsRUFBRSxDQUFDYSxJQUFILENBQVFyVCxDQUFSLEVBQVd1RCxNQUFYLENBQWtCLE1BQWxCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCNFAsVUFEaEIsRUFFRTVQLElBRkYsQ0FFTyxXQUZQLEVBRW9CLENBQUMsYUFBRCxFQUFnQixJQUFoQixFQUNsQnhELENBQUMsS0FBSyxHQUFOLEdBQVksQ0FBQyxDQUFDMFMsU0FBZCxHQUEwQixDQUFDQSxTQURULENBRnBCLEVBS0UvSixLQUxGLENBS1EsYUFMUixFQUt1QixLQUFJLENBQUMrSyx1QkFBTCxDQUE2QjFGLElBQTdCLENBQWtDLEtBQWxDLENBTHZCLENBcEJtQixFQTJCbkIsS0FBSSxDQUFDMkYsWUFBTCxDQUFrQjNULENBQWxCLENBM0JtQjtBQTRCbkIsT0E1QkQsQ0FYTTtBQXdDTjtBQUVEOzs7Ozs7O2dDQUlZO0FBQUEsVUFDTHdTLEVBQUUsR0FBRyxLQUFLTyxLQURMO0FBQUEsVUFFTDNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlA7QUFBQSxVQUdMc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIZDtBQUFBLFVBSUxpQixNQUFNLEdBQUd4SSxNQUFNLENBQUNtSSxZQUpYO0FBQUEsVUFLTE0sT0FBTyxHQUFHekksTUFBTSxDQUFDMEksYUFMWjtBQU9YdEIsUUFBRSxDQUFDdUIsT0FBSCxHQUFhckIsU0FBUyxHQUFHLE1BQUgsR0FBWSxRQVB2QixFQVFYRixFQUFFLENBQUN3QixPQUFILEdBQWF0QixTQUFTLEdBQUlrQixNQUFNLEdBQUcsS0FBSCxHQUFXLFFBQXJCLEdBQWtDQSxNQUFNLEdBQUcsT0FBSCxHQUFhLE1BUmhFLEVBU1hwQixFQUFFLENBQUN5QixRQUFILEdBQWN2QixTQUFTLEdBQUltQixPQUFPLEdBQUcsUUFBSCxHQUFjLEtBQXpCLEdBQW1DQSxPQUFPLEdBQUcsTUFBSCxHQUFZLE9BVGxFLEVBVVhyQixFQUFFLENBQUMwQixVQUFILEdBQWdCeEIsU0FBUyxHQUFHLE1BQUgsR0FBWSxRQVYxQjtBQVdYO0FBRUQ7Ozs7Ozs7OztpQ0FNYUcsRSxFQUFJO0FBQUEsVUFNWnNCLE1BTlk7QUFBQSxVQUNWM0IsRUFBRSxHQUFHLEtBQUtPLEtBREE7QUFBQSxVQUVWM0gsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGRjtBQUFBLFVBR1ZpSSxJQUFJLEdBQUcsRUFIRztBQUFBLFVBSVZlLFVBQVUsR0FBR2hKLE1BQU0sZ0JBQVN5SCxFQUFULFdBSlQ7QUFBQSxVQUtWSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUxUO0FBUVpFLFFBQUUsS0FBSyxHQVJLLEdBU2ZzQixNQUFNLEdBQUd6QixTQUFTLEdBQUcyQiw0RUFBSCxHQUFnQkMsOEVBVG5CLEdBVUx6QixFQUFFLEtBQUssR0FWRixHQVdmc0IsTUFBTSxHQUFHekIsU0FBUyxHQUFHNEIsOEVBQUgsR0FBa0JELDRFQVhyQixHQVlMeEIsRUFBRSxLQUFLLElBWkYsS0FhZnNCLE1BQU0sR0FBR3pCLFNBQVMsR0FBRzZCLDJFQUFILEdBQWVDLDZFQWJsQixHQWdCWkosVUFBVSxDQUFDcFQsTUFoQkMsSUFpQmZvVCxVQUFVLENBQUMvUixPQUFYLENBQW1CLFVBQUFyQyxDQUFDLEVBQUk7QUFDdkIsWUFBTTRPLElBQUksR0FBRzVPLENBQUMsQ0FBQzRPLElBQWY7QUFFQXlFLFlBQUksQ0FBQ3hMLElBQUwsQ0FDQ3NNLE1BQU0sQ0FBQzNCLEVBQUUsQ0FBQ0ssRUFBRCxDQUFILENBQU4sQ0FDRTVHLEtBREYsQ0FDUTJDLElBQUksQ0FBQzZGLEtBRGIsRUFFRWxJLFVBRkYsQ0FFYXFDLElBQUksQ0FBQ3FELE1BQUwsSUFBZ0IsVUFBQXJPLENBQUM7QUFBQSxpQkFBSUEsQ0FBSjtBQUFBLFNBRjlCLEVBR0U2SixVQUhGLENBR2FtQixJQUFJLENBQUM4RixNQUhsQixFQUlFQyxhQUpGLENBSWdCL0YsSUFBSSxDQUFDZ0csS0FBTCxVQUF1QixDQUF2QixHQUEyQixDQUozQyxDQURELENBSHVCO0FBVXZCLE9BVkQsQ0FqQmUsRUE4QmhCcEMsRUFBRSxDQUFDVSxRQUFILENBQVlMLEVBQVosSUFBa0JRLElBOUJGO0FBK0JoQjtBQUVEOzs7Ozs7O2lDQUlhO0FBQUEsVUFDTmIsRUFBRSxHQUFHLEtBQUtPLEtBREo7QUFBQSxVQUVOM0gsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGTjtBQUlabEssWUFBTSxDQUFDQyxJQUFQLENBQVlxUixFQUFFLENBQUNVLFFBQWYsRUFBeUI3USxPQUF6QixDQUFpQyxVQUFBd1EsRUFBRSxFQUFJO0FBQ3RDLFlBQU1uSCxLQUFLLEdBQUc4RyxFQUFFLENBQUNLLEVBQUQsQ0FBRixDQUFPbkgsS0FBUCxFQUFkO0FBRUE4RyxVQUFFLENBQUNVLFFBQUgsQ0FBWUwsRUFBWixFQUFnQnhRLE9BQWhCLENBQXdCLFVBQUNyQyxDQUFELEVBQUlzRCxDQUFKLEVBQVU7QUFDakMsY0FBTXVSLFNBQVMsR0FBRzdVLENBQUMsQ0FBQ3FMLEtBQUYsR0FBVUssS0FBVixFQUFsQixDQURpQyxDQUdqQztBQUNBOztBQUNLQSxlQUFLLENBQUN2RSxLQUFOLENBQVksVUFBQ25ILENBQUQsRUFBSXNELENBQUo7QUFBQSxtQkFBVXRELENBQUMsS0FBSzZVLFNBQVMsQ0FBQ3ZSLENBQUQsQ0FBekI7QUFBQSxXQUFaLENBTDRCLElBTWhDdEQsQ0FBQyxDQUFDcUwsS0FBRixHQUFVSyxLQUFWLENBQWdCQSxLQUFoQixDQU5nQztBQUFBLGNBUzNCb0osU0FBUyxhQUFNbEMsZ0JBQWdCLENBQUNDLEVBQUQsQ0FBdEIsY0FBOEJ2UCxDQUFDLEdBQUcsQ0FBbEMsQ0FUa0I7QUFBQSxjQVU3QnVLLENBQUMsR0FBRzJFLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQmtRLFNBQVMsQ0FBQ2pTLE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0IsR0FBeEIsQ0FBbkIsRUFWeUI7QUFZN0JnTCxXQUFDLENBQUNsUixLQUFGLEVBWjZCLEdBYWhDa1IsQ0FBQyxHQUFHMkUsRUFBRSxDQUFDL04sSUFBSCxDQUFRbEIsTUFBUixDQUFlLEdBQWYsRUFDRkMsSUFERSxDQUNHLE9BREgsRUFDWXNSLFNBRFosRUFFRm5NLEtBRkUsQ0FFSSxZQUZKLEVBRWtCeUMsTUFBTSxnQkFBU3lILEVBQVQsV0FBTixHQUE0QixTQUE1QixHQUF3QyxRQUYxRCxFQUdGblEsSUFIRSxDQUdHMUMsQ0FISCxDQWI0QixHQWtCaEN3UyxFQUFFLENBQUN1QyxLQUFILENBQVNwSCxNQUFULENBQWdCNkIsYUFBaEIsQ0FBOEIzQixDQUE5QixFQUNFbkwsSUFERixDQUNPMUMsQ0FBQyxDQUFDcUwsS0FBRixDQUFRbUgsRUFBRSxDQUFDSyxFQUFELENBQVYsQ0FEUCxDQWxCZ0MsRUFzQmpDaEYsQ0FBQyxDQUFDckssSUFBRixDQUFPLFdBQVAsRUFBb0JnUCxFQUFFLENBQUNpQixZQUFILENBQWdCWixFQUFoQixFQUFvQnZQLENBQUMsR0FBRyxDQUF4QixDQUFwQixDQXRCaUM7QUF1QmpDLFNBdkJELENBSHNDO0FBMkJ0QyxPQTNCRCxDQUpZO0FBZ0NaLEssQ0FFRDs7Ozs2QkFDU3FCLEksRUFBTTBHLEssRUFBTzhCLFMsRUFBVzVCLFksRUFBY3lKLGdCLEVBQWtCO0FBQUEsVUFDMUR4QyxFQUFFLEdBQUcsS0FBS08sS0FEZ0Q7QUFBQSxVQUUxRDNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRjhDO0FBQUEsVUFHMURnRSxVQUFVLEdBQUdvRCxFQUFFLENBQUN5QyxhQUFILEVBSDZDO0FBQUEsVUFJMUQ3SCxNQUFNLEdBQUdvRixFQUFFLFdBQUk3TixJQUFKLFlBSitDO0FBQUEsVUFLMUQ0SCxVQUFVLEdBQUdpRyxFQUFFLENBQUMwQyxlQUwwQztBQUFBLFVBTTFEekgsVUFBVSxHQUFHK0UsRUFBRSxDQUFDMkMsZUFOMEM7QUFBQSxVQVExREMsVUFBVSxHQUFHO0FBQ2xCaEcsa0JBQVUsRUFBVkEsVUFEa0I7QUFFbEJqQyxpQkFBUyxFQUFUQSxTQUZrQjtBQUdsQjVCLG9CQUFZLEVBQVpBLFlBSGtCO0FBSWxCSCxjQUFNLEVBQU5BLE1BSmtCO0FBS2xCekcsWUFBSSxFQUFKQSxJQUxrQjtBQU1sQnlMLHFCQUFhLEVBQUVoRixNQUFNLENBQUNpSyxxQkFOSjtBQU9sQjNELGlCQUFTLEVBQUV0RyxNQUFNLENBQUNrSyxpQkFQQTtBQVFsQi9HLHNCQUFjLEVBQUV5RyxnQkFBZ0IsR0FBRyxDQUFILEdBQU81SixNQUFNLENBQUNtSyxrQkFSNUI7QUFTbEIxRSxpQkFBUyxFQUFFekIsVUFBVSxJQUFJaEUsTUFBTSxDQUFDb0ssbUJBQXJCLElBQTRDaEQsRUFBRSxDQUFDaUQsR0FBSCxDQUFPQyxVQUFQLEVBVHJDO0FBVWxCN0osaUJBQVMsRUFBRTJHLEVBQUUsQ0FBQzVPO0FBVkksT0FSNkM7QUFBQSxVQXFCMURwSixJQUFJLEdBQUcsSUFBSXdTLHlCQUFKLENBQWlCb0ksVUFBakIsRUFDWC9KLEtBRFcsQ0FDTG1ILEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0J0SyxLQURYLEVBRVgrQixNQUZXLENBRUpBLE1BRkksQ0FyQm1EO0FBQUEsVUF5QjVEd0ksYUFBYSxHQUFHbkksVUF6QjRDO0FBNENoRSxhQWpCSStFLEVBQUUsQ0FBQ3FELFlBQUgsTUFBcUJwSSxVQUFyQixJQUFtQyxDQUFDeE4sVUFBVSxDQUFDd04sVUFBRCxDQWlCbEQsS0FoQkNtSSxhQUFhLEdBQUduSSxVQUFVLENBQUN2SyxHQUFYLENBQWUsVUFBQWxELENBQUM7QUFBQSxlQUFJd1MsRUFBRSxDQUFDc0QsU0FBSCxDQUFhOVYsQ0FBYixDQUFKO0FBQUEsT0FBaEIsQ0FnQmpCLEdBWkF4RixJQUFJLENBQUMrUixVQUFMLENBQWdCQSxVQUFoQixFQUE0QmtCLFVBQTVCLENBQXVDbUksYUFBdkMsQ0FZQSxFQVZJeEcsVUFVSixLQVRDNVUsSUFBSSxDQUFDNlMsWUFBTCxDQUFrQmpDLE1BQU0sQ0FBQzJLLG9CQUF6QixDQVNELEVBUEtoVixPQUFPLENBQUNxSyxNQUFNLENBQUM0SyxtQkFBUixDQU9aLEtBTkU1SyxNQUFNLENBQUM0SyxtQkFBUCxLQU1GLElBRkE1SyxNQUFNLENBQUM2SyxpQkFBUCxJQUE0QnpiLElBQUksQ0FBQ3lSLEtBQUwsQ0FBV2IsTUFBTSxDQUFDNkssaUJBQWxCLENBRTVCLEVBQU96YixJQUFQO0FBQ0EsSyxDQUVEOzs7OzZCQUNTbUssSSxFQUFNMEcsSyxFQUFPOEIsUyxFQUFXNUIsWSxFQUFjeUosZ0IsRUFBa0I7QUFBQSxVQUMxRHhDLEVBQUUsR0FBRyxLQUFLTyxLQURnRDtBQUFBLFVBRTFEM0gsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGOEM7QUFBQSxVQUcxRGdDLE1BQU0sR0FBR29GLEVBQUUsV0FBSTdOLElBQUosWUFIK0M7QUFBQSxVQUkxRDRILFVBQVUsR0FBR25CLE1BQU0sZ0JBQVN6RyxJQUFULGtCQUp1QztBQUFBLFVBSzFEOEksVUFBVSxHQUFHK0UsRUFBRSxXQUFJN04sSUFBSixvQkFMMkM7QUFBQSxVQU8xRHlRLFVBQVUsR0FBRztBQUNsQmpJLGlCQUFTLEVBQVRBLFNBRGtCO0FBRWxCNUIsb0JBQVksRUFBWkEsWUFGa0I7QUFHbEJILGNBQU0sRUFBTkEsTUFIa0I7QUFJbEJ6RyxZQUFJLEVBQUpBLElBSmtCO0FBS2xCNEosc0JBQWMsRUFBRXlHLGdCQUFnQixHQUFHLENBQUgsR0FBTzVKLE1BQU0sQ0FBQzhLO0FBTDVCLE9BUDZDO0FBQUEsVUFlMUQxYixJQUFJLEdBQUcsSUFBSXdTLHlCQUFKLENBQWlCb0ksVUFBakIsRUFDWC9KLEtBRFcsQ0FDTEEsS0FESyxFQUVYK0IsTUFGVyxDQUVKQSxNQUZJLEVBR1hiLFVBSFcsQ0FJWEEsVUFBVSxJQUFLaUcsRUFBRSxDQUFDMkQsaUJBQUgsTUFBMkIsVUFBQXZTLENBQUM7QUFBQSx5QkFBT0EsQ0FBUDtBQUFBLE9BSmhDLENBZm1EO0FBMkJoRSxhQUxBNE8sRUFBRSxDQUFDNEQsYUFBSCxLQUNDO0FBQ0E1YixVQUFJLENBQUN5UixLQUFMLENBQVdiLE1BQU0sQ0FBQ2lMLHNCQUFsQixDQUZELEdBR0M3YixJQUFJLENBQUNpVCxVQUFMLENBQWdCQSxVQUFoQixDQUVELEVBQU9qVCxJQUFQO0FBQ0E7OzswQ0FFcUI4YixPLEVBQVM5YixJLEVBQU07QUFBQSxVQUtoQ2thLE1BTGdDO0FBQUEsVUFDOUJsQyxFQUFFLEdBQUcsS0FBS08sS0FEb0I7QUFBQSxVQUU5QjNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmtCO0FBQUEsVUFHOUJtTCxHQUFHLEdBQUduTCxNQUFNLENBQUNvTCxlQUhpQjtBQUFBLFVBSTlCL0IsS0FBSyxHQUFHckosTUFBTSxDQUFDNkssaUJBSmU7QUFzQnBDLGNBZklNLEdBQUcsSUFBSzlCLEtBQUssSUFBSThCLEdBZXJCLE1BZEM3QixNQUFNLEdBQUcsS0FBSytCLGtCQUFMLENBQ1JqRSxFQUFFLENBQUNrRSxvQkFBSCxDQUF3QkosT0FBeEIsQ0FEUSxFQUVSN0IsS0FGUSxFQUdSakMsRUFBRSxDQUFDcUQsWUFBSCxFQUhRLENBY1YsR0FQSXJiLElBT0osR0FOQ0EsSUFBSSxDQUFDaVQsVUFBTCxDQUFnQmlILE1BQWhCLENBTUQsR0FMV2xDLEVBQUUsQ0FBQ3VDLEtBS2QsS0FKQ3ZDLEVBQUUsQ0FBQ3VDLEtBQUgsQ0FBU3RILFVBQVQsQ0FBb0JpSCxNQUFwQixDQUlELEVBSENsQyxFQUFFLENBQUNtRSxRQUFILENBQVlsSixVQUFaLENBQXVCaUgsTUFBdkIsQ0FHRCxHQUFPQSxNQUFQO0FBQ0E7OzswQkFFSzdCLEUsRUFBSTtBQUNULFVBQU16SCxNQUFNLEdBQUcsS0FBSzJILEtBQUwsQ0FBVzNILE1BQTFCO0FBRUEsYUFBT3lILEVBQUUsSUFBSXpILE1BQU0sQ0FBQ3dMLFNBQWIsR0FBeUJ4TCxNQUFNLENBQUN3TCxTQUFQLENBQWlCL0QsRUFBakIsQ0FBekIsR0FBZ0QsR0FBdkQ7QUFDQTs7O3lDQUVvQjtBQUFBLFVBTWhCWixNQU5nQjtBQUFBLFVBQ2RPLEVBQUUsR0FBRyxLQUFLTyxLQURJO0FBQUEsVUFFZDNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkU7QUFBQSxVQUdkbUIsVUFBVSxHQUFHbkIsTUFBTSxDQUFDeUwsa0JBSE47QUFBQSxVQUlkaEIsWUFBWSxHQUFHckQsRUFBRSxDQUFDcUQsWUFBSCxFQUpEO0FBQUEsVUFLZFosYUFBYSxHQUFHekMsRUFBRSxDQUFDeUMsYUFBSCxFQUxGO0FBcUJwQixhQWJJMUksVUFhSixHQVpLdE0sVUFBVSxDQUFDc00sVUFBRCxDQVlmLEdBWEUwRixNQUFNLEdBQUcxRixVQVdYLEdBVllzSixZQVVaLEtBVEU1RCxNQUFNLEdBQUcsVUFBQTZFLElBQUk7QUFBQSxlQUFLQSxJQUFJLEdBQUd0RSxFQUFFLENBQUN1RSxjQUFILENBQWtCeEssVUFBbEIsRUFBOEJ1SyxJQUE5QixDQUFILEdBQXlDLEVBQWxEO0FBQUEsT0FTZixJQU5DN0UsTUFBTSxHQUFHNEQsWUFBWSxHQUFHckQsRUFBRSxDQUFDd0UscUJBQU4sR0FDcEIvQixhQUFhLEdBQ1p6QyxFQUFFLENBQUN5RSxZQURTLEdBQ00sVUFBQWpYLENBQUM7QUFBQSxlQUFLQSxDQUFDLEdBQUcsQ0FBSixHQUFRQSxDQUFDLENBQUNrWCxPQUFGLENBQVUsQ0FBVixDQUFSLEdBQXVCbFgsQ0FBNUI7QUFBQSxPQUl0QixFQUFPQyxVQUFVLENBQUNnUyxNQUFELENBQVYsR0FBcUIsVUFBQWpTLENBQUM7QUFBQSxlQUM1QmlTLE1BQU0sQ0FBQ2tGLEtBQVAsQ0FBYTNFLEVBQWIsRUFBaUJ5QyxhQUFhLEdBQzdCLENBQUNqVixDQUFELEVBQUl3UyxFQUFFLENBQUN5RSxZQUFILENBQWdCalgsQ0FBaEIsQ0FBSixDQUQ2QixHQUNILENBQUNBLENBQUQsQ0FEM0IsQ0FENEI7QUFBQSxPQUF0QixHQUdGaVMsTUFITDtBQUlBOzs7a0NBRWFZLEUsRUFBSTtBQUFBLFVBQ1hMLEVBQUUsR0FBRyxLQUFLTyxLQURDO0FBQUEsVUFFWHRGLFVBQVUsR0FBRytFLEVBQUUsQ0FBQ3BILE1BQUgsZ0JBQWtCeUgsRUFBbEIsa0JBRkY7QUFBQSxVQUdYclksSUFBSSxHQUFHZ1ksRUFBRSxXQUFJSyxFQUFKLFVBSEU7QUFLakIsYUFBT3BGLFVBQVUsS0FBS2pULElBQUksR0FBR0EsSUFBSSxDQUFDaVQsVUFBTCxFQUFILEdBQXVCaEcsU0FBaEMsQ0FBakI7QUFDQTs7O3lDQUVvQjtBQUNwQixhQUFPLEtBQUsyUCxhQUFMLENBQW1CLEdBQW5CLENBQVA7QUFDQTs7O3lDQUVvQjtBQUNwQixhQUFPLEtBQUtBLGFBQUwsQ0FBbUIsR0FBbkIsQ0FBUDtBQUNBOzs7MENBRXFCO0FBQ3JCLGFBQU8sS0FBS0EsYUFBTCxDQUFtQixJQUFuQixDQUFQO0FBQ0E7OzsyQ0FFc0J2RSxFLEVBQUk7QUFDMUIsYUFBTyxLQUFLRSxLQUFMLENBQVczSCxNQUFYLGdCQUEwQnlILEVBQTFCLFlBQVA7QUFDQTs7O2lDQUVZQSxFLEVBQUk7QUFDaEIsVUFBTXdFLE1BQU0sR0FBRyxLQUFLQyxzQkFBTCxDQUE0QnpFLEVBQTVCLENBQWY7QUFFQSxhQUFPM1MsUUFBUSxDQUFDbVgsTUFBRCxDQUFSLEdBQW1CQSxNQUFuQixHQUNOQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQzFZLElBQVYsR0FBaUIsSUFEeEI7QUFHQTs7O2lDQUVZa1UsRSxFQUFJbFUsSSxFQUFNO0FBQUEsVUFDaEI2VCxFQUFFLEdBQUcsS0FBS08sS0FETTtBQUFBLFVBRWhCM0gsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSTtBQUFBLFVBR2hCaU0sTUFBTSxHQUFHLEtBQUtDLHNCQUFMLENBQTRCekUsRUFBNUIsQ0FITztBQUtsQjNTLGNBQVEsQ0FBQ21YLE1BQUQsQ0FMVSxHQU1yQmpNLE1BQU0sZ0JBQVN5SCxFQUFULFlBQU4sR0FBNkJsVSxJQU5SLEdBT1gwWSxNQVBXLEtBUXJCQSxNQUFNLENBQUMxWSxJQUFQLEdBQWNBLElBUk87QUFVdEI7OztxQ0FFZ0JrVSxFLEVBQUkwRSxlLEVBQWlCO0FBQUEsVUFDL0I3RSxTQUFTLEdBQUcsS0FBS0ssS0FBTCxDQUFXM0gsTUFBWCxDQUFrQnVILFlBREM7QUFBQSxVQUUvQjBFLE1BQU0sR0FBRyxLQUFLQyxzQkFBTCxDQUE0QnpFLEVBQTVCLENBRnNCO0FBQUEsVUFHL0IyRSxRQUFRLEdBQUkxVyxZQUFZLENBQUN1VyxNQUFELENBQVosSUFBd0JBLE1BQU0sQ0FBQ0csUUFBaEMsR0FDaEJILE1BQU0sQ0FBQ0csUUFEUyxHQUNFRCxlQUFlLENBQUMsQ0FBQyxDQUFDN0UsU0FBSCxDQUpHO0FBQUEsVUFNL0IrRSxHQUFHLEdBQUcsVUFBQXpYLENBQUM7QUFBQSxlQUFJLENBQUMsQ0FBQyxDQUFDd1gsUUFBUSxDQUFDcmQsT0FBVCxDQUFpQjZGLENBQWpCLENBQVA7QUFBQSxPQU53Qjs7QUFRckMsYUFBTztBQUNOMFgsZUFBTyxFQUFFRCxHQUFHLENBQUMsT0FBRCxDQUROO0FBRU5FLGVBQU8sRUFBRUYsR0FBRyxDQUFDLE9BQUQsQ0FGTjtBQUdORyxjQUFNLEVBQUVILEdBQUcsQ0FBQyxNQUFELENBSEw7QUFJTkksZ0JBQVEsRUFBRUosR0FBRyxDQUFDLFFBQUQsQ0FKUDtBQUtOSyxlQUFPLEVBQUVMLEdBQUcsQ0FBQyxPQUFELENBTE47QUFNTk0sYUFBSyxFQUFFTixHQUFHLENBQUMsS0FBRCxDQU5KO0FBT05PLGdCQUFRLEVBQUVQLEdBQUcsQ0FBQyxRQUFELENBUFA7QUFRTlEsZ0JBQVEsRUFBRVIsR0FBRyxDQUFDLFFBQUQ7QUFSUCxPQUFQO0FBVUE7Ozs0Q0FFdUI7QUFDdkIsYUFBTyxLQUFLUyxnQkFBTCxDQUFzQixHQUF0QixFQUEyQixDQUFDLFdBQUQsRUFBYyxhQUFkLENBQTNCLENBQVA7QUFDQTs7OzRDQUV1QjtBQUN2QixhQUFPLEtBQUtBLGdCQUFMLENBQXNCLEdBQXRCLEVBQTJCLENBQUMsYUFBRCxFQUFnQixXQUFoQixDQUEzQixDQUFQO0FBQ0E7Ozs2Q0FFd0I7QUFDeEIsYUFBTyxLQUFLQSxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixDQUFDLGFBQUQsRUFBZ0IsV0FBaEIsQ0FBNUIsQ0FBUDtBQUNBOzs7eUNBRW9CckYsRSxFQUFJO0FBQ3hCLGFBQU8sa0JBQVdBLEVBQUUsQ0FBQ3JOLFdBQUgsRUFBWCx5QkFBUDtBQUNBOzs7d0NBRW1CO0FBQ25CLGFBQU8sS0FBSzJTLFlBQUwsQ0FBa0IsR0FBbEIsQ0FBUDtBQUNBOzs7d0NBRW1CO0FBQ25CLGFBQU8sS0FBS0EsWUFBTCxDQUFrQixHQUFsQixDQUFQO0FBQ0E7Ozt5Q0FFb0I7QUFDcEIsYUFBTyxLQUFLQSxZQUFMLENBQWtCLElBQWxCLENBQVA7QUFDQTs7O2tDQUVhWCxRLEVBQWdDO0FBQUEsVUFBdEIvRSxhQUFzQjtBQUFBLFVBQ3ZDRCxFQUFFLEdBQUcsS0FBS08sS0FENkI7QUFBQSxVQUV6Q25QLENBQUMsR0FBRzRULFFBQVEsQ0FBQ1EsUUFBVCxHQUFvQixDQUFDeEYsRUFBRSxDQUFDek8sTUFBSixHQUFhLENBQWpDLEdBQXFDLENBRkE7QUFZN0MsYUFSSXdPLFlBQVksQ0FBQ0MsRUFBRCxFQUFLQyxhQUFMLENBUWhCLEdBUEM3TyxDQUFDLEdBQUc0VCxRQUFRLENBQUNJLE1BQVQsR0FBa0IsQ0FBbEIsR0FDSEosUUFBUSxDQUFDSyxRQUFULEdBQW9CckYsRUFBRSxDQUFDMU8sS0FBSCxHQUFXLENBQS9CLEdBQW1DME8sRUFBRSxDQUFDMU8sS0FNeEMsR0FKVzBULFFBQVEsQ0FBQ1MsUUFJcEIsS0FIQ3JVLENBQUMsR0FBRyxDQUFDNE8sRUFBRSxDQUFDek8sTUFHVCxHQUFPSCxDQUFQO0FBQ0E7OzttQ0FFYzRULFEsRUFBZ0M7QUFBQSxVQUF0Qi9FLGFBQXNCO0FBQUEsVUFDeENELEVBQUUsR0FBRyxLQUFLTyxLQUQ4QjtBQUFBLFVBRTFDeEMsRUFBRSxHQUFHaUgsUUFBUSxDQUFDUyxRQUFULEdBQW9CLE9BQXBCLEdBQThCLEdBRk87QUFZOUMsYUFSSTFGLFlBQVksQ0FBQ0MsRUFBRCxFQUFLQyxhQUFMLENBUWhCLEdBUENsQyxFQUFFLEdBQUdpSCxRQUFRLENBQUNJLE1BQVQsR0FBa0IsT0FBbEIsR0FDSkosUUFBUSxDQUFDTSxPQUFULEdBQW1CLFFBQW5CLEdBQThCLEdBTWhDLEdBSldOLFFBQVEsQ0FBQ08sS0FJcEIsS0FIQ3hILEVBQUUsR0FBRyxRQUdOLEdBQU9BLEVBQVA7QUFDQTs7OzJDQUVzQmlILFEsRUFBZ0M7QUFBQSxVQUF0Qi9FLGFBQXNCO0FBQUEsVUFDaERELEVBQUUsR0FBRyxLQUFLTyxLQURzQztBQUFBLFVBRWxEcUYsTUFBTSxHQUFHWixRQUFRLENBQUNRLFFBQVQsR0FBb0IsUUFBcEIsR0FBK0IsS0FGVTtBQVl0RCxhQVJJekYsWUFBWSxDQUFDQyxFQUFELEVBQUtDLGFBQUwsQ0FRaEIsR0FQQzJGLE1BQU0sR0FBR1osUUFBUSxDQUFDSSxNQUFULEdBQWtCLE9BQWxCLEdBQ1JKLFFBQVEsQ0FBQ0ssUUFBVCxHQUFvQixRQUFwQixHQUErQixLQU1qQyxHQUpXTCxRQUFRLENBQUNTLFFBSXBCLEtBSENHLE1BQU0sR0FBRyxPQUdWLEdBQU9BLE1BQVA7QUFDQTs7O3FDQUVnQjtBQUNoQixhQUFPLEtBQUtDLGFBQUwsQ0FBbUIsS0FBS0MscUJBQUwsRUFBbkIsS0FBUDtBQUNBOzs7cUNBRWdCO0FBQ2hCLGFBQU8sS0FBS0QsYUFBTCxDQUFtQixLQUFLRSxxQkFBTCxFQUFuQixDQUFQO0FBQ0E7OztzQ0FFaUI7QUFDakIsYUFBTyxLQUFLRixhQUFMLENBQW1CLEtBQUtHLHNCQUFMLEVBQW5CLENBQVA7QUFDQTs7O3NDQUVpQjtBQUNqQixhQUFPLEtBQUtDLGNBQUwsQ0FBb0IsS0FBS0gscUJBQUwsRUFBcEIsS0FBUDtBQUNBOzs7c0NBRWlCO0FBQ2pCLGFBQU8sS0FBS0csY0FBTCxDQUFvQixLQUFLRixxQkFBTCxFQUFwQixDQUFQO0FBQ0E7Ozt1Q0FFa0I7QUFDbEIsYUFBTyxLQUFLRSxjQUFMLENBQW9CLEtBQUtELHNCQUFMLEVBQXBCLENBQVA7QUFDQTs7O3NDQUVpQjtBQUFBLFVBQ1hoRyxFQUFFLEdBQUcsS0FBS08sS0FEQztBQUFBLFVBRVgzSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZEO0FBQUEsVUFHWHNNLE9BQU8sR0FBRyxLQUFLWSxxQkFBTCxHQUE2QlosT0FINUI7QUFBQSxVQUlYZ0IsT0FBTyxHQUFHdE4sTUFBTSxDQUFDdU4sYUFKTjtBQUFBLGFBTWJ2TixNQUFNLENBQUN1SCxZQU5NLEdBT1QrRSxPQUFPLEdBQUcsT0FBSCxHQUFhLENBQUMsRUFBRCxHQUFNLEtBQUtrQixlQUFMLENBQXFCLEdBQXJCLENBUGpCLEdBUU5sQixPQVJNLEdBU1QsUUFUUyxHQVVOZ0IsT0FWTSxHQVdUQSxPQUFPLEdBQUcsRUFYRCxHQWFULEtBYlM7QUFlakI7OztzQ0FFaUI7QUFBQSxVQUNYbEcsRUFBRSxHQUFHLEtBQUtPLEtBREM7QUFBQSxVQUVYMkUsT0FBTyxHQUFHLEtBQUthLHFCQUFMLEdBQTZCYixPQUY1QjtBQUFBLGFBSWJsRixFQUFFLENBQUNwSCxNQUFILENBQVV1SCxZQUpHLEdBS1QrRSxPQUFPLEdBQUcsUUFBSCxHQUFjLEtBTFosR0FPVEEsT0FBTyxHQUFHLE9BQUgsR0FBYSxDQUFDLEVBQUQsSUFBT2xGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVW1JLFlBQVYsR0FBeUIsQ0FBekIsR0FBOEIsS0FBS3FGLGVBQUwsQ0FBcUIsR0FBckIsSUFBNEIsRUFBakUsQ0FQWDtBQVNqQjs7O3VDQUVrQjtBQUFBLFVBQ1pwRyxFQUFFLEdBQUcsS0FBS08sS0FERTtBQUFBLFVBRVoyRSxPQUFPLEdBQUcsS0FBS2Msc0JBQUwsR0FBOEJkLE9BRjVCO0FBQUEsYUFJZGxGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBSkksR0FLVitFLE9BQU8sR0FBRyxPQUFILEdBQWEsUUFMVixHQU9WQSxPQUFPLEdBQUcsUUFBSCxHQUFjLE1BQU1sRixFQUFFLENBQUNwSCxNQUFILENBQVUwSSxhQUFWLEdBQTBCLENBQTFCLEdBQStCLEtBQUs4RSxlQUFMLENBQXFCLElBQXJCLElBQTZCLEVBQWxFLENBUFg7QUFTbEI7Ozs4Q0FFeUI7QUFDekIsYUFBTyxLQUFLQyxzQkFBTCxDQUE0QixLQUFLUCxxQkFBTCxFQUE1QixLQUFQO0FBQ0E7Ozs4Q0FFeUI7QUFDekIsYUFBTyxLQUFLTyxzQkFBTCxDQUE0QixLQUFLTixxQkFBTCxFQUE1QixDQUFQO0FBQ0E7OzsrQ0FFMEI7QUFDMUIsYUFBTyxLQUFLTSxzQkFBTCxDQUE0QixLQUFLTCxzQkFBTCxFQUE1QixDQUFQO0FBQ0E7OztvQ0FFZTNGLEUsRUFBSWlHLGdCLEVBQWtCO0FBQUEsVUFDL0J0RyxFQUFFLEdBQUcsS0FBS08sS0FEcUI7QUFBQSxVQUUvQjNILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRm1CO0FBQUEsVUFHL0IyTixjQUFjLEdBQUd2RyxFQUFFLENBQUN3RyxvQkFBSCxDQUF3Qm5HLEVBQXhCLENBSGM7QUFBQSxVQUlqQ29HLFFBQVEsR0FBRyxDQUpzQjtBQU1yQyxVQUFJSCxnQkFBZ0IsSUFBSSxDQUFDMU4sTUFBTSxnQkFBU3lILEVBQVQsV0FBL0IsRUFDQyxPQUFPa0csY0FBYyxDQUFDbk0sSUFBdEI7O0FBR0QsVUFBSTRGLEVBQUUsQ0FBQzBHLEdBQVAsRUFBWTtBQUFBLFlBQ0xDLE9BQU8sR0FBRyxRQUFRM00sSUFBUixDQUFhcUcsRUFBYixDQURMO0FBQUEsWUFFTHVHLGFBQWEsR0FBRzVHLEVBQUUsQ0FBQzZHLG1CQUFILENBQXVCN0csRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBL0IsQ0FGWDtBQUFBLFlBR0xnRCxPQUFPLEdBQUdILE9BQU8sR0FBRyxNQUFILEdBQVksTUFIeEI7QUFBQSxZQUtMOU4sS0FBSyxHQUFHbUgsRUFBRSxDQUFDSyxFQUFELENBQUYsQ0FBT3ZHLElBQVAsR0FBY1AsTUFBZCxDQUFxQnlHLEVBQUUsV0FBSThHLE9BQUosWUFBRixDQUF1QkYsYUFBdkIsRUFBc0N2RyxFQUF0QyxDQUFyQixDQUxIO0FBQUEsWUFNTDlHLE1BQU0sR0FBR1YsS0FBSyxDQUFDVSxNQUFOLEVBTko7QUFRWDtBQUNBLFlBQUl6SyxPQUFPLENBQUN5WCxjQUFjLENBQUNoTixNQUFoQixDQUFQLElBQWtDZ04sY0FBYyxDQUFDaE4sTUFBZixDQUFzQjVFLEtBQXRCLENBQTRCLFVBQUNuSCxDQUFELEVBQUlzRCxDQUFKO0FBQUEsaUJBQVV0RCxDQUFDLEtBQUsrTCxNQUFNLENBQUN6SSxDQUFELENBQXRCO0FBQUEsU0FBNUIsQ0FBdEMsRUFDQyxPQUFPeVYsY0FBYyxDQUFDbk0sSUFBdEI7QUFFQW1NLHNCQUFjLENBQUNoTixNQUFmLEdBQXdCQSxNQVpkO0FBQUEsWUFlTHZSLElBQUksR0FBRyxlQUFROGUsT0FBUixXQUF1QnpHLEVBQXZCLEVBQTJCeEgsS0FBM0IsYUFmRjtBQUFBLFlBZ0JMa08sU0FBUyxHQUFHbk8sTUFBTSxnQkFBU3lILEVBQVQsaUJBaEJiO0FBb0JQMEcsaUJBcEJPLElBcUJWL2UsSUFBSSxDQUFDaVQsVUFBTCxDQUNDLEtBQUtnSixrQkFBTCxDQUNDMUssTUFERCxFQUVDd04sU0FGRCxFQUdDSixPQUFPLEdBQUczRyxFQUFFLENBQUM0RCxhQUFILEVBQUgsR0FBd0I1RCxFQUFFLENBQUNxRCxZQUFILEVBSGhDLENBREQsQ0FyQlUsRUE2QlZzRCxPQUFELElBQVksS0FBS0sscUJBQUwsQ0FBMkJKLGFBQTNCLEVBQTBDNWUsSUFBMUMsQ0E3QkQ7QUErQlgsWUFBTWlmLEtBQUssR0FBR2pILEVBQUUsQ0FBQ2tILFdBQUgsQ0FBZW5XLE1BQWYsQ0FBc0IsS0FBdEIsRUFDWm9GLEtBRFksQ0FDTixZQURNLEVBQ1EsUUFEUixFQUVaQSxLQUZZLENBRU4sVUFGTSxFQUVNLE9BRk4sRUFHWkEsS0FIWSxDQUdOLEtBSE0sRUFHQyxLQUhELEVBSVpBLEtBSlksQ0FJTixNQUpNLEVBSUUsS0FKRixDQUFkO0FBTUFuTyxZQUFJLENBQUNtZixNQUFMLENBQVlGLEtBQVosQ0FyQ1csRUF1Q1hBLEtBQUssQ0FBQ3BLLFNBQU4sQ0FBZ0IsTUFBaEIsRUFDRVAsSUFERixDQUNPLFlBQVc7QUFDaEJtSyxrQkFBUSxHQUFHelksSUFBSSxDQUFDa04sR0FBTCxDQUFTdUwsUUFBVCxFQUFtQixLQUFLaFYscUJBQUwsR0FBNkJILEtBQWhELENBREs7QUFFaEIsU0FIRixDQXZDVyxFQTRDWDJWLEtBQUssQ0FBQzFKLE1BQU4sRUE1Q1c7QUE2Q1g7O0FBTUQsYUFKSWtKLFFBQVEsR0FBRyxDQUlmLEtBSENGLGNBQWMsQ0FBQ25NLElBQWYsR0FBc0JxTSxRQUd2QixHQUFPRixjQUFjLENBQUNuTSxJQUF0QjtBQUNBOzs7aUNBRVlnTixjLEVBQWdCO0FBQUE7QUFBQSxVQUN0QnBILEVBQUUsR0FBRyxLQUFLTyxLQURZO0FBQUEsVUFFdEI4RyxNQUFNLEdBQUc7QUFDZEMsU0FBQyxFQUFFdEgsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUNwSyxLQUF6QixlQUFtQ29LLGNBQUssQ0FBQ25LLFVBQXpDLEVBRFc7QUFFZHFmLFNBQUMsRUFBRXZILEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDbEssS0FBekIsZUFBbUNrSyxjQUFLLENBQUMvSixVQUF6QyxFQUZXO0FBR2RrZixVQUFFLEVBQUV4SCxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ2pLLE1BQXpCLGVBQW9DaUssY0FBSyxDQUFDaEssV0FBMUM7QUFIVSxPQUZhOztBQVE1QnFHLFlBQU0sQ0FBQ0MsSUFBUCxDQUFZMFksTUFBWixFQUFvQnJULE1BQXBCLENBQTJCLFVBQUFxTSxFQUFFO0FBQUEsZUFBSSxDQUFDZ0gsTUFBTSxDQUFDaEgsRUFBRCxDQUFOLENBQVdsVyxLQUFYLEVBQUw7QUFBQSxPQUE3QixFQUNFMEYsT0FERixDQUNVLFVBQUFyQyxDQUFDLEVBQUk7QUFBQSxZQUNQK0MsSUFBSSxHQUFHOFcsTUFBTSxDQUFDN1osQ0FBRCxDQUROO0FBQUEsWUFFUGlhLFNBQVMsYUFBTWphLENBQU4sY0FGRjtBQUliLFNBQUM0WixjQUFjLEdBQUc3VyxJQUFJLENBQUM0SixVQUFMLEVBQUgsR0FBdUI1SixJQUF0QyxFQUNFUyxJQURGLENBQ08sR0FEUCxFQUNZLE1BQUksZUFBUXlXLFNBQVIsRUFBSixDQUF5QmpNLElBQXpCLENBQThCLE1BQTlCLENBRFosRUFFRXhLLElBRkYsQ0FFTyxJQUZQLEVBRWEsTUFBSSxnQkFBU3lXLFNBQVQsRUFBSixDQUEwQmpNLElBQTFCLENBQStCLE1BQS9CLENBRmIsRUFHRXhLLElBSEYsQ0FHTyxJQUhQLEVBR2EsTUFBSSxnQkFBU3lXLFNBQVQsRUFBSixDQUEwQmpNLElBQTFCLENBQStCLE1BQS9CLENBSGIsRUFJRXJQLElBSkYsQ0FJTyxNQUFJLGtCQUFXc2IsU0FBWCxFQUFKLENBQTRCak0sSUFBNUIsQ0FBaUMsTUFBakMsQ0FKUCxDQUphO0FBU2IsT0FWRixDQVI0QjtBQW1CNUI7OzsrQkFFVWtNLE8sRUFBU25ZLEcsRUFBS0MsWSxFQUFjbVksWSxFQUFjO0FBQ3BELFVBQU05VSxDQUFDLEdBQUdsRixRQUFRLENBQUMrWixPQUFELENBQVIsR0FBb0JBLE9BQXBCLEdBQThCQSxPQUFPLENBQUNuWSxHQUFELENBQS9DO0FBRG9ELGFBRy9DaEMsT0FBTyxDQUFDc0YsQ0FBRCxDQUh3QyxHQU9oRDZVLE9BQU8sQ0FBQ0UsSUFBUixLQUFpQixPQVArQixHQVE1Q0YsT0FBTyxDQUFDblksR0FBRCxDQUFQLEdBQWVvWSxZQVI2QixHQVk3QyxLQUFLRSwwQkFBTCxDQUFnQ2hWLENBQWhDLEVBQW1DOFUsWUFBbkMsQ0FaNkMsR0FJNUNuWSxZQUo0QyxFQVdwRDtBQUVBOzs7K0NBRTBCc1ksTSxFQUFRSCxZLEVBQWM7QUFBQSxVQUMxQzNILEVBQUUsR0FBRyxLQUFLTyxLQURnQztBQUFBLFVBRTFDL1IsTUFBTSxHQUFHd1IsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdUgsWUFBVixHQUF5QkgsRUFBRSxDQUFDMU8sS0FBNUIsR0FBb0MwTyxFQUFFLENBQUN6TyxNQUZOO0FBSWhELGFBQU9vVyxZQUFZLElBQUlHLE1BQU0sR0FBR3RaLE1BQWIsQ0FBbkI7QUFDQTs7O3VDQUVrQjBULE0sRUFBUTZFLFMsRUFBV2dCLGEsRUFBZTtBQUFBLFVBRWhENVMsS0FGZ0Q7QUFBQSxVQUdoREMsR0FIZ0Q7QUFBQSxVQUloRDZNLEtBSmdEO0FBQUEsVUFLaER0QyxRQUxnRDtBQUFBLFVBTWhEN08sQ0FOZ0Q7QUFBQSxVQU9oRGtYLFNBUGdEO0FBQUEsVUFDaEQvTSxVQUFVLEdBQUdpSCxNQURtQzs7QUFTcEQsVUFBSTZFLFNBQUosRUFBZTtBQUNkLFlBQU1rQixXQUFXLEdBQUd4YSxVQUFVLENBQUNzWixTQUFELENBQVYsR0FBd0JBLFNBQVMsRUFBakMsR0FBc0NBLFNBQTFELENBRGMsQ0FHZDs7QUFDQSxZQUFJa0IsV0FBVyxLQUFLLENBQXBCLEVBQ0NoTixVQUFVLEdBQUcsQ0FBQ2lILE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FEZCxNQUVPLElBQUkrRixXQUFXLEtBQUssQ0FBcEIsRUFDTmhOLFVBQVUsR0FBRyxDQUFDaUgsTUFBTSxDQUFDLENBQUQsQ0FBUCxFQUFZQSxNQUFNLENBQUNBLE1BQU0sQ0FBQzFULE1BQVAsR0FBZ0IsQ0FBakIsQ0FBbEIsQ0FEUCxNQUVBLElBQUl5WixXQUFXLEdBQUcsQ0FBbEIsRUFBcUI7QUFTM0IsZUFSQWhHLEtBQUssR0FBR2dHLFdBQVcsR0FBRyxDQVF0QixFQVBBOVMsS0FBSyxHQUFHK00sTUFBTSxDQUFDLENBQUQsQ0FPZCxFQU5BOU0sR0FBRyxHQUFHOE0sTUFBTSxDQUFDQSxNQUFNLENBQUMxVCxNQUFQLEdBQWdCLENBQWpCLENBTVosRUFMQW1SLFFBQVEsR0FBRyxDQUFDdkssR0FBRyxHQUFHRCxLQUFQLEtBQWlCOE0sS0FBSyxHQUFHLENBQXpCLENBS1gsRUFGQWhILFVBQVUsR0FBRyxDQUFDOUYsS0FBRCxDQUViLEVBQUtyRSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdtUixLQUFoQixFQUF1Qm5SLENBQUMsRUFBeEIsRUFDQ2tYLFNBQVMsR0FBRyxDQUFDN1MsS0FBRCxHQUFTd0ssUUFBUSxJQUFJN08sQ0FBQyxHQUFHLENBQVIsQ0FEOUIsRUFFQ21LLFVBQVUsQ0FBQzVGLElBQVgsQ0FBZ0IwUyxhQUFhLEdBQUcsSUFBSXRaLElBQUosQ0FBU3VaLFNBQVQsQ0FBSCxHQUF5QkEsU0FBdEQsQ0FGRDs7QUFLQS9NLG9CQUFVLENBQUM1RixJQUFYLENBQWdCRCxHQUFoQixDQWQyQjtBQWUzQjtBQUNEOztBQU1ELGFBSksyUyxhQUlMLEtBSEM5TSxVQUFVLEdBQUdBLFVBQVUsQ0FBQ3BHLElBQVgsQ0FBZ0IsVUFBQ0osQ0FBRCxFQUFJQyxDQUFKO0FBQUEsZUFBVUQsQ0FBQyxHQUFHQyxDQUFkO0FBQUEsT0FBaEIsQ0FHZCxHQUFPdUcsVUFBUDtBQUNBOzs7d0NBRW1CaU4sUSxFQUFVO0FBQ3ZCLFVBQUFsSSxFQUFFLEdBQUcsS0FBS08sS0FBVjtBQUFBLFVBQ0FNLElBREEsR0FDT2IsRUFBRSxDQUFDYSxJQURWO0FBQUEsaUJBR21DLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxJQUFYLEVBQWlCLE1BQWpCLEVBQ3ZDblEsR0FEdUMsQ0FDbkMsVUFBQWxELENBQUMsRUFBSTtBQUNULFlBQUl4RixJQUFJLEdBQUc2WSxJQUFJLENBQUNyVCxDQUFELENBQWY7QUFNQSxlQUpJeEYsSUFBSSxJQUFJa2dCLFFBSVosS0FIQ2xnQixJQUFJLEdBQUdBLElBQUksQ0FBQ21TLFVBQUwsR0FBa0IrTixRQUFsQixDQUEyQkEsUUFBM0IsQ0FHUixHQUFPbGdCLElBQVA7QUFDQSxPQVR1QyxDQUhuQztBQUFBO0FBQUEsVUFHQ0MsS0FIRDtBQUFBLFVBR1FFLEtBSFI7QUFBQSxVQUdlQyxNQUhmO0FBQUEsVUFHdUIrZixRQUh2Qjs7QUFjTixhQUFPO0FBQUNsZ0IsYUFBSyxFQUFMQSxLQUFEO0FBQVFFLGFBQUssRUFBTEEsS0FBUjtBQUFlQyxjQUFNLEVBQU5BLE1BQWY7QUFBdUIrZixnQkFBUSxFQUFSQTtBQUF2QixPQUFQO0FBQ0E7OzsyQkFFTUMsVyxFQUFhQyxRLEVBQVVDLE0sRUFBUTtBQUFBLFVBQy9CdEksRUFBRSxHQUFHLEtBQUtPLEtBRHFCO0FBQUEsVUFFL0JnSSxPQUFPLEdBQUdGLFFBQVEsR0FBRyxHQUFILEdBQVMsR0FGSTtBQUlyQyxPQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFpQixNQUFqQixFQUF5QnhZLE9BQXpCLENBQWlDLFVBQUF3USxFQUFFLEVBQUk7QUFDdEMsWUFBTXJZLElBQUksR0FBR2dZLEVBQUUsV0FBSUssRUFBSixVQUFmO0FBRUlyWSxZQUhrQyxLQUlqQyxDQUFDc2dCLE1BSmdDLEtBS3BDdGdCLElBQUksQ0FBQzRRLE1BQUwsQ0FBWUssaUJBQVosR0FBZ0MsQ0FBQytHLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVUksbUJBTFAsR0FRckNnSCxFQUFFLENBQUNhLElBQUgsQ0FBUVIsRUFBRSxDQUFDbUksV0FBSCxFQUFSLEVBQTBCclMsS0FBMUIsQ0FBZ0MsU0FBaEMsRUFBMkNvUyxPQUEzQyxDQVJxQyxFQVNyQ3ZnQixJQUFJLENBQUNtZixNQUFMLENBQVlpQixXQUFXLGVBQVF0VixVQUFVLENBQUN1TixFQUFELENBQWxCLEVBQXZCLENBVHFDO0FBV3RDLE9BWEQsQ0FKcUMsRUFpQnJDLEtBQUtvSSxVQUFMLEVBakJxQztBQWtCckM7Ozs7Ozs7Ozs7Ozs7QUMxckJGOzs7OztBQUtBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0lBT3FCQywyQjs7O0FBQ3BCLHlCQUFZekYsR0FBWixFQUFpQjtBQUFBOztBQUNoQixRQUFNakQsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDaUQsR0FBSCxHQUFTQSxHQUhPLEVBSWhCakQsRUFBRSxDQUFDcEgsTUFBSCxHQUFZb0gsRUFBRSxDQUFDMkksVUFBSCxFQUpJLEVBS2hCM0ksRUFBRSxDQUFDak0sSUFBSCxHQUFVLEVBTE0sRUFNaEJpTSxFQUFFLENBQUM0SSxLQUFILEdBQVcsRUFOSyxFQU9oQjVJLEVBQUUsQ0FBQ2EsSUFBSCxHQUFVLEVBUE07QUFRaEI7Ozs7aUNBRVk7QUFDWixVQUFNYixFQUFFLEdBQUcsSUFBWDtBQUVBQSxRQUFFLENBQUNwSCxNQUFILENBQVVpUSxLQUFWLElBQW1CdlQsU0FBUyxFQUhoQixFQUlaMEssRUFBRSxDQUFDOEksY0FBSCxDQUFrQixhQUFsQixDQUpZLEVBT1poWixNQUFNLENBQUNrUSxFQUFFLENBQUNwSCxNQUFILENBQVVtUSxZQUFYLEVBQXlCL0ksRUFBekIsQ0FQTTtBQVFaOzs7Z0NBRVc7QUFDWCxVQUFNQSxFQUFFLEdBQUcsSUFBWDtBQUVBQSxRQUFFLENBQUM4SSxjQUFILENBQWtCLFlBQWxCLENBSFcsRUFNWGhaLE1BQU0sQ0FBQ2tRLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVW9RLFdBQVgsRUFBd0JoSixFQUF4QixDQU5LO0FBT1g7OzsyQkFFTTtBQUNOLFVBQU1BLEVBQUUsR0FBRyxJQUFYO0FBRUFBLFFBQUUsQ0FBQ2lKLFVBQUgsRUFITTtBQUtOLFVBQU1DLGFBQWEsR0FBR2xKLEVBQUUsQ0FBQ21KLFdBQUgsQ0FBZW5KLEVBQUUsQ0FBQ3BILE1BQWxCLEVBQTBCb0gsRUFBRSxDQUFDb0osWUFBN0IsQ0FBdEI7QUFFQUYsbUJBQWEsSUFBSWxKLEVBQUUsQ0FBQ29KLFlBQUgsQ0FBZ0JGLGFBQWhCLENBUFg7QUFRTjs7O2lDQUVZO0FBQUE7QUFBQSxVQUNObEosRUFBRSxHQUFHLElBREM7QUFBQSxVQUVOcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGTjtBQUFBLFVBR05zSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhiOztBQU1aSCxRQUFFLENBQUNxSixVQUFILGdCQUFzQixDQUFDLElBQUk1YSxJQUFKLEVBQXZCLENBTlksRUFPWnVSLEVBQUUsQ0FBQ3NKLFFBQUgsRUFQWSxFQVNadEosRUFBRSxDQUFDdUosU0FBSCxHQUFlLElBVEgsRUFVWnZKLEVBQUUsQ0FBQ3dKLFFBQUgsS0FWWSxFQVdaeEosRUFBRSxDQUFDeUosT0FBSCxLQVhZLEVBWVp6SixFQUFFLENBQUMwSixXQUFILEtBWlksRUFhWjFKLEVBQUUsQ0FBQzJKLFNBQUgsS0FiWSxFQWNaM0osRUFBRSxDQUFDNEosVUFBSCxLQWRZLEVBZ0JaNUosRUFBRSxDQUFDNkosS0FBSCxHQUFXN0osRUFBRSxDQUFDOEosYUFBSCxFQWhCQyxFQWlCWjlKLEVBQUUsQ0FBQytKLFVBQUgsR0FBZ0IvSixFQUFFLENBQUNnSyxrQkFBSCxFQWpCSixFQWtCWmhLLEVBQUUsQ0FBQ2lLLEtBQUgsR0FBV2pLLEVBQUUsQ0FBQ2tLLGFBQUgsRUFsQkMsRUFvQlpsSyxFQUFFLENBQUNtSyxnQkFBSCxHQUFzQm5LLEVBQUUsQ0FBQ29LLHNCQUFILEVBcEJWLEVBc0JacEssRUFBRSxDQUFDcUssY0FBSCxHQUFvQnpSLE1BQU0sQ0FBQzBSLGVBQVAsR0FBeUJDLGtHQUF6QixHQUF1Q0MsaUdBdEIvQyxFQXVCWnhLLEVBQUUsQ0FBQ3VFLGNBQUgsR0FBb0IzTCxNQUFNLENBQUM2UixnQkFBUCxHQUEwQkMsbUdBQTFCLEdBQXlDQyxrR0F2QmpEO0FBeUJaLFVBQU1DLFVBQVUsR0FBRzVLLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVWlTLFlBQVYsSUFBMEI3SyxFQUFFLENBQUNwSCxNQUFILENBQVVpUyxZQUFWLENBQXVCOVYsSUFBdkIsS0FBZ0MsTUFBN0U7QUFFQWlMLFFBQUUsQ0FBQ3dFLHFCQUFILEdBQTJCLFVBQUFuVyxDQUFDLEVBQUk7QUFBQSxZQUN6QnljLFFBQVEsR0FBR0YsVUFBVSxHQUFHLEtBQUksQ0FBQ3pILFNBQVIsR0FDMUIsS0FBSSxDQUFDQSxTQUFMLElBQWtCbkQsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLMlosU0FBTCxHQUFpQmxYLFFBQWpCLE9BQWdDLEtBQUksQ0FBQ3NQLFNBQUwsQ0FBZTVKLE1BQWYsR0FBd0IxRixRQUF4QixFQUZwQjtBQUFBLFlBSXpCbVgsU0FBUyxHQUFJM2MsQ0FBQyxDQUFDNGMsZUFBRixNQUF1QixLQUF4QixJQUNoQjVjLENBQUMsQ0FBQzZjLFVBQUYsTUFBa0IsTUFERixJQUVoQjdjLENBQUMsQ0FBQzhjLFVBQUYsTUFBa0IsT0FGRixJQUdoQjljLENBQUMsQ0FBQytjLFFBQUYsTUFBZ0IsT0FIQSxJQUloQi9jLENBQUMsQ0FBQ2dkLE9BQUYsT0FBZ0IsQ0FBaEIsSUFBcUIsT0FKTCxJQUtoQlAsUUFBUSxJQUFJemMsQ0FBQyxDQUFDZ2QsT0FBRixPQUFnQixDQUE1QixJQUFpQyxRQUxqQixJQU1oQmhkLENBQUMsQ0FBQ2lkLFFBQUYsTUFBZ0IsU0FOQSxJQU1jLElBVkQ7QUFZL0IsZUFBT3RMLEVBQUUsQ0FBQ3VFLGNBQUgsQ0FBa0J5RyxTQUFsQixFQUE2QjNjLENBQTdCLENBQVA7QUFDQSxPQXhDVyxFQTBDWjJSLEVBQUUsQ0FBQ3VMLGVBQUgsR0FBcUIsRUExQ1QsRUEyQ1p2TCxFQUFFLENBQUN3TCxlQUFILEdBQXFCLEVBM0NULEVBNENaeEwsRUFBRSxDQUFDeUwsZ0JBQUgsR0FBc0IsRUE1Q1YsRUE2Q1p6TCxFQUFFLENBQUMwTCxrQkFBSCxHQUF3QixFQTdDWixFQStDWjFMLEVBQUUsQ0FBQzJMLGFBQUgsR0FBbUIvUyxNQUFNLENBQUNnVCxlQUFQLEtBQTJCLE9BL0NsQyxFQWdEWjVMLEVBQUUsQ0FBQzZMLGFBQUgsR0FBbUJqVCxNQUFNLENBQUNnVCxlQUFQLEtBQTJCLE9BaERsQyxFQWtEWjVMLEVBQUUsQ0FBQzhMLFdBQUgsR0FBaUJsVCxNQUFNLENBQUNtVCxtQkFBUCxLQUErQixVQUEvQixJQUNoQm5ULE1BQU0sQ0FBQ21ULG1CQUFQLEtBQStCLFdBbkRwQixFQW9EWi9MLEVBQUUsQ0FBQ2dNLFlBQUgsR0FBa0JwVCxNQUFNLENBQUNtVCxtQkFBUCxLQUErQixVQUEvQixJQUNqQm5ULE1BQU0sQ0FBQ21ULG1CQUFQLEtBQStCLGFBckRwQixFQXVEWi9MLEVBQUUsQ0FBQ2lNLFVBQUgsR0FBZ0IsQ0F2REosRUF3RFpqTSxFQUFFLENBQUNrTSxlQUFILEdBQXFCLENBeERULEVBeURabE0sRUFBRSxDQUFDbU0sZ0JBQUgsR0FBc0IsQ0F6RFYsRUEyRFpuTSxFQUFFLENBQUN3RyxvQkFBSCxHQUEwQjtBQUN6QnBWLFNBQUMsRUFBRTtBQUFDZ0osY0FBSSxFQUFFLENBQVA7QUFBVWIsZ0JBQU0sRUFBRTtBQUFsQixTQURzQjtBQUV6QmxJLFNBQUMsRUFBRTtBQUFDK0ksY0FBSSxFQUFFLENBQVA7QUFBVWIsZ0JBQU0sRUFBRTtBQUFsQixTQUZzQjtBQUd6QjZTLFVBQUUsRUFBRTtBQUFDaFMsY0FBSSxFQUFFLENBQVA7QUFBVWIsZ0JBQU0sRUFBRTtBQUFsQjtBQUhxQixPQTNEZCxFQWlFWnlHLEVBQUUsQ0FBQ3FNLG9CQUFILEdBQTBCLEVBakVkLEVBa0Vack0sRUFBRSxDQUFDc00scUJBQUgsR0FBMkJwTSxTQUFTLElBQUksQ0FBQ3RILE1BQU0sQ0FBQzJULFdBQXJCLEdBQW1DLENBQW5DLEdBQXVDLEVBbEV0RCxFQW1FWnZNLEVBQUUsQ0FBQ3dNLG1CQUFILEdBQXlCLENBbkViLEVBcUVaeE0sRUFBRSxDQUFDeU0sYUFBSCxHQUFtQixFQXJFUCxFQXNFWnpNLEVBQUUsQ0FBQzBNLFNBQUgsR0FBZTFNLEVBQUUsQ0FBQzJNLGdCQUFILEVBdEVILEVBd0VaM00sRUFBRSxDQUFDYSxJQUFILENBQVErTCxJQUFSLEdBQWVDLG9HQUFXLENBQUMsRUFBRCxDQXhFZDtBQXlFWjs7O2lDQUVZOVksSSxFQUFNO0FBQUEsVUFDWmlNLEVBQUUsR0FBRyxJQURPO0FBQUEsVUFFWnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkE7QUFPbEJvSCxRQUFFLENBQUNoWSxJQUFILEdBQVUsSUFBSXNZLFNBQUosQ0FBU04sRUFBVCxDQVBRLEVBUWxCcEgsTUFBTSxDQUFDaVMsWUFBUCxJQUF1QjdLLEVBQUUsQ0FBQzhNLFFBQUgsRUFSTDtBQVVsQixVQUFNQyxNQUFNLEdBQUc7QUFDZEMsZUFBTyxFQUFFcFUsTUFBTSxDQUFDbVUsTUFERjtBQUVkRSxpQkFBUyxFQUFFO0FBRkcsT0FBZjs7QUEyRUEsVUF0RUkvZCxRQUFRLENBQUMwSixNQUFNLENBQUNtVSxNQUFSLENBc0VaLEtBckVDQSxNQUFNLENBQUNDLE9BQVAsR0FBaUJwVSxNQUFNLENBQUNtVSxNQUFQLENBQWNDLE9BQWQsSUFBeUIsUUFxRTNDLEVBcEVDRCxNQUFNLENBQUNFLFNBQVAsR0FBbUJyVSxNQUFNLENBQUNtVSxNQUFQLENBQWNFLFNBQWQsSUFBMkJGLE1BQU0sQ0FBQ0UsU0FvRXRELEdBaEVBak4sRUFBRSxDQUFDa0gsV0FBSCxHQUFpQnpaLFVBQVUsQ0FBQ3NmLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlemMsSUFBaEIsQ0FBVixHQUNoQnFJLE1BQU0sQ0FBQ21VLE1BQVAsQ0FBY0MsT0FERSxHQUNRelEsaUdBQVEsQ0FBQ3dRLE1BQU0sQ0FBQ0MsT0FBUCxJQUFrQixFQUFuQixDQStEakMsRUE3REloTixFQUFFLENBQUNrSCxXQUFILENBQWUvYyxLQUFmLEVBNkRKLEtBNURDNlYsRUFBRSxDQUFDa0gsV0FBSCxHQUFpQjNLLGlHQUFRLENBQUNoVixRQUFRLENBQUM4TyxJQUFULENBQWNDLFdBQWQsQ0FBMEIvTyxRQUFRLENBQUMybEIsYUFBVCxDQUF1QixLQUF2QixDQUExQixDQUFELENBNEQxQixHQXpEQWxOLEVBQUUsQ0FBQ2tILFdBQUgsQ0FBZXJXLElBQWYsQ0FBb0IsRUFBcEIsRUFBd0JzYyxPQUF4QixDQUFnQ0osTUFBTSxDQUFDRSxTQUF2QyxLQXlEQSxFQXREQWpOLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQVIsR0FBYSxFQXNEYixFQXJEQXBOLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsR0FBa0I5RCxFQUFFLENBQUNxTixvQkFBSCxDQUF3QnRaLElBQXhCLENBcURsQixFQW5ESTZFLE1BQU0sQ0FBQzBVLFdBbURYLEtBbERDdE4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixHQUFrQjlELEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0I5UCxNQUFoQixDQUF1QjRFLE1BQU0sQ0FBQzBVLFdBQTlCLENBa0RuQixHQTlDSTFVLE1BQU0sQ0FBQzJVLFNBOENYLElBN0NDdk4sRUFBRSxDQUFDd04sa0JBQUgsQ0FDQzVVLE1BQU0sQ0FBQzJVLFNBQVAsVUFDQ3ZOLEVBQUUsQ0FBQ3lOLFFBQUgsQ0FBWXpOLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXBCLENBREQsR0FDZ0NsTCxNQUFNLENBQUMyVSxTQUZ4QyxDQTZDRCxFQXhDSTNVLE1BQU0sQ0FBQzhVLFdBd0NYLElBdkNDMU4sRUFBRSxDQUFDMk4sa0JBQUgsQ0FDQy9VLE1BQU0sQ0FBQzhVLFdBQVAsVUFDQzFOLEVBQUUsQ0FBQ3lOLFFBQUgsQ0FBWXpOLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXBCLENBREQsR0FDZ0NsTCxNQUFNLENBQUM4VSxXQUZ4QyxDQXVDRCxFQWhDSTFOLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLENBZ0NKLEtBL0JDaFYsTUFBTSxDQUFDaVYsV0FBUCxLQStCRCxHQTNCQTdOLEVBQUUsQ0FBQzhOLFdBQUgsRUEyQkEsRUExQkE5TixFQUFFLENBQUMrTixZQUFILElBMEJBLEVBdkJJL04sRUFBRSxDQUFDNU8sQ0F1QlAsS0F0QkM0TyxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLENBQVloRixTQUFTLENBQUN5TCxFQUFFLENBQUNnTyxVQUFILENBQWNoTyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUF0QixDQUFELENBQXJCLENBc0JELEVBckJDOUQsRUFBRSxDQUFDaU8sSUFBSCxDQUFRMVUsTUFBUixDQUFleUcsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxFQUFmLENBcUJELEVBbEJDeUcsRUFBRSxDQUFDa08sVUFBSCxHQUFnQmxPLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS21JLE1BQUwsRUFrQmpCLEdBZkl5RyxFQUFFLENBQUMzTyxDQWVQLEtBZEMyTyxFQUFFLENBQUMzTyxDQUFILENBQUtrSSxNQUFMLENBQVl5RyxFQUFFLENBQUNtTyxVQUFILENBQWNuTyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUF0QixFQUErQixHQUEvQixDQUFaLENBY0QsRUFiQzlELEVBQUUsQ0FBQ29PLElBQUgsQ0FBUTdVLE1BQVIsQ0FBZXlHLEVBQUUsQ0FBQzNPLENBQUgsQ0FBS2tJLE1BQUwsRUFBZixDQWFELEdBVkl5RyxFQUFFLENBQUNvTSxFQVVQLEtBVENwTSxFQUFFLENBQUNvTSxFQUFILENBQU03UyxNQUFOLENBQWF5RyxFQUFFLENBQUNtTyxVQUFILENBQWNuTyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUF0QixFQUErQixJQUEvQixDQUFiLENBU0QsRUFSQzlELEVBQUUsQ0FBQ3FPLEtBQUgsSUFBWXJPLEVBQUUsQ0FBQ3FPLEtBQUgsQ0FBUzlVLE1BQVQsQ0FBZ0J5RyxFQUFFLENBQUNvTSxFQUFILENBQU03UyxNQUFOLEVBQWhCLENBUWIsR0FKQXlHLEVBQUUsQ0FBQzBHLEdBQUgsR0FBUzFHLEVBQUUsQ0FBQ2tILFdBQUgsQ0FBZW5XLE1BQWYsQ0FBc0IsS0FBdEIsRUFDUG9GLEtBRE8sQ0FDRCxVQURDLEVBQ1csUUFEWCxFQUVQQSxLQUZPLENBRUQsU0FGQyxFQUVVLE9BRlYsQ0FJVCxFQUFJeUMsTUFBTSxDQUFDMFYsbUJBQVAsSUFBOEJ0TyxFQUFFLENBQUMwTSxTQUFyQyxFQUFnRDtBQUMvQyxZQUFNNkIsT0FBTyxHQUFHdk8sRUFBRSxDQUFDME0sU0FBSCxLQUFpQixPQUFqQztBQUVBMU0sVUFBRSxDQUFDMEcsR0FBSCxDQUNFOEgsRUFERixDQUNLRCxPQUFPLEdBQUcsWUFBSCxHQUFrQixZQUQ5QixFQUM0QztBQUFBLGlCQUFNemUsTUFBTSxDQUFDOEksTUFBTSxDQUFDNlYsTUFBUixFQUFnQnpPLEVBQWhCLENBQVo7QUFBQSxTQUQ1QyxFQUVFd08sRUFGRixDQUVLRCxPQUFPLEdBQUcsVUFBSCxHQUFnQixZQUY1QixFQUUwQztBQUFBLGlCQUFNemUsTUFBTSxDQUFDOEksTUFBTSxDQUFDOFYsS0FBUixFQUFlMU8sRUFBZixDQUFaO0FBQUEsU0FGMUMsQ0FIK0M7QUFNL0M7O0FBRURwSCxZQUFNLENBQUMrVixhQUFQLElBQXdCM08sRUFBRSxDQUFDMEcsR0FBSCxDQUFPMVYsSUFBUCxDQUFZLE9BQVosRUFBcUI0SCxNQUFNLENBQUMrVixhQUE1QixDQTdGTixFQWdHbEIzTyxFQUFFLENBQUM0TyxJQUFILEdBQVU1TyxFQUFFLENBQUMwRyxHQUFILENBQU8zVixNQUFQLENBQWMsTUFBZCxDQWhHUSxFQWtHbEJpUCxFQUFFLENBQUM2TyxTQUFILEdBQWU3TyxFQUFFLENBQUM4TyxVQUFILENBQWM5TyxFQUFFLENBQUM0TyxJQUFqQixFQUF1QjVPLEVBQUUsQ0FBQytPLE1BQTFCLENBbEdHLEVBbUdsQi9PLEVBQUUsQ0FBQ2dQLFNBQUgsR0FBZWhQLEVBQUUsQ0FBQzhPLFVBQUgsQ0FBYzlPLEVBQUUsQ0FBQzRPLElBQWpCLEVBQXVCNU8sRUFBRSxDQUFDaVAsY0FBMUIsQ0FuR0csRUFvR2xCalAsRUFBRSxDQUFDa1AsU0FBSCxHQUFlbFAsRUFBRSxDQUFDOE8sVUFBSCxDQUFjOU8sRUFBRSxDQUFDNE8sSUFBakIsRUFBdUI1TyxFQUFFLENBQUNtUCxjQUExQixDQXBHRyxFQXFHbEJuUCxFQUFFLENBQUNvUCxRQUFILEdBQWNwUCxFQUFFLENBQUM4TyxVQUFILENBQWM5TyxFQUFFLENBQUM0TyxJQUFqQixFQUF1QjVPLEVBQUUsQ0FBQ3FQLGFBQTFCLENBckdJLEVBd0dkNWhCLFVBQVUsQ0FBQ21MLE1BQU0sQ0FBQzBXLFdBQVIsQ0FBVixJQUFrQ3RQLEVBQUUsQ0FBQ3VQLFFBeEd2QixJQXlHakJ2UCxFQUFFLENBQUN1UCxRQUFILENBQVkxZixPQUFaLENBQW9CLFVBQUFnRCxDQUFDO0FBQUEsZUFBSW1OLEVBQUUsQ0FBQzRPLElBQUgsQ0FBUTdkLE1BQVIsQ0FBZTtBQUFBLGlCQUFNOEIsQ0FBQyxDQUFDdEMsSUFBUjtBQUFBLFNBQWYsQ0FBSjtBQUFBLE9BQXJCLENBekdpQixFQTRHbEJ5UCxFQUFFLENBQUN3UCxhQUFILEVBNUdrQjtBQThHbEI7QUFDQSxVQUFNdmQsSUFBSSxHQUFHK04sRUFBRSxDQUFDMEcsR0FBSCxDQUFPM1YsTUFBUCxDQUFjLEdBQWQsRUFBbUJDLElBQW5CLENBQXdCLFdBQXhCLEVBQXFDZ1AsRUFBRSxDQUFDaUIsWUFBSCxDQUFnQixNQUFoQixDQUFyQyxDQUFiOztBQXdFQTtBQUNBLFVBdkVBakIsRUFBRSxDQUFDL04sSUFBSCxHQUFVQSxJQXVFVixFQXBFQTJHLE1BQU0sQ0FBQzZXLGFBQVAsSUFBd0J6UCxFQUFFLENBQUMwUCxZQUFILEVBb0V4QixFQWxFQTFQLEVBQUUsQ0FBQzJQLFdBQUgsSUFBa0IzUCxFQUFFLENBQUMyUCxXQUFILEVBa0VsQixFQWpFQTNQLEVBQUUsQ0FBQzRQLFVBQUgsSUFBaUI1UCxFQUFFLENBQUM0UCxVQUFILEVBaUVqQixFQWhFQTVQLEVBQUUsQ0FBQzZQLFNBQUgsSUFBZ0I3UCxFQUFFLENBQUM2UCxTQUFILEVBZ0VoQixFQTNESWpYLE1BQU0sQ0FBQ2tYLHFCQTJEWCxJQTFEQzdkLElBQUksQ0FBQ2xCLE1BQUwsQ0FBWSxNQUFaLEVBQ0VDLElBREYsQ0FDTyxPQURQLFlBQ21CcUIsY0FBSyxDQUFDbEcsSUFEekIsY0FDaUNrRyxjQUFLLENBQUNsSSxLQUR2QyxHQUVFNkcsSUFGRixDQUVPLGFBRlAsRUFFc0IsUUFGdEIsRUFFZ0M7QUFGaEMsT0FHRUEsSUFIRixDQUdPLG1CQUhQLEVBRzRCLFFBSDVCLENBMERELEVBbkRBZ1AsRUFBRSxDQUFDK1AsVUFBSCxFQW1EQSxFQWhEQ25YLE1BQU0sQ0FBQ29YLFFBQVIsSUFBb0JoUSxFQUFFLENBQUNoWSxJQUFILENBQVFpb0IsSUFBUixFQWdEcEIsRUE3Q0FoZSxJQUFJLENBQUNsQixNQUFMLENBQVksR0FBWixFQUFpQkMsSUFBakIsQ0FBc0IsT0FBdEIsRUFBK0JxQixjQUFLLENBQUN6SixLQUFyQyxFQUNFb0ksSUFERixDQUNPLFdBRFAsRUFDb0JnUCxFQUFFLENBQUNnUSxRQUR2QixDQTZDQSxFQTFDQWhRLEVBQUUsQ0FBQzhJLGNBQUgsQ0FBa0IsT0FBbEIsQ0EwQ0EsRUF2Q0E5SSxFQUFFLENBQUNrUSxhQUFILEVBdUNBLEVBcENBbFEsRUFBRSxDQUFDbVEsaUJBQUgsRUFvQ0EsRUFqQ0FuUSxFQUFFLENBQUNvUSxRQUFILEVBaUNBLEVBN0JBbmUsSUFBSSxDQUFDbUwsTUFBTCxDQUFZLE1BQVosRUFBb0J4RSxNQUFNLENBQUN5WCxlQUFQLEdBQXlCLElBQXpCLGVBQXFDaGUsY0FBSyxDQUFDN0csT0FBM0MsQ0FBcEIsRUFDRXdGLElBREYsQ0FDTyxPQURQLEVBQ2dCcUIsY0FBSyxDQUFDbEYsUUFEdEIsRUFFRTZELElBRkYsQ0FFTyxPQUZQLEVBRWdCZ1AsRUFBRSxDQUFDMU8sS0FGbkIsRUFHRU4sSUFIRixDQUdPLFFBSFAsRUFHaUJnUCxFQUFFLENBQUN6TyxNQUhwQixFQUlFNEUsS0FKRixDQUlRLFNBSlIsRUFJbUIsR0FKbkIsRUFLRXFZLEVBTEYsQ0FLSyxlQUxMLEVBS3NCLElBTHRCLENBNkJBLEVBckJBNVYsTUFBTSxDQUFDb1gsUUFBUCxJQUFtQmhRLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUWlvQixJQUFSLEVBcUJuQixFQWxCQWpRLEVBQUUsQ0FBQ3NRLGFBQUgsQ0FBaUJ0USxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUF6QixDQWtCQSxFQWZBOUQsRUFBRSxDQUFDdVEsZUFBSCxFQWVBLEVBWkEzWCxNQUFNLENBQUM0WCxNQUFQLENBQWN0Z0IsSUFBZCxDQUFtQjhQLEVBQW5CLENBWUEsRUFWQUEsRUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1RySixzQkFBYyxJQURMO0FBRVRzSixxQkFBYSxJQUZKO0FBR1RDLHlCQUFpQixJQUhSO0FBSVRDLDRCQUFvQixJQUpYO0FBS1RDLDZCQUFxQixJQUxaO0FBTVRDLG9CQUFZO0FBTkgsT0FBVixDQVVBLEVBQUlsWSxNQUFNLENBQUNtWSxVQUFQLElBQXFCblksTUFBTSxDQUFDb1ksVUFBaEMsRUFBNEM7QUFDM0MsWUFBTUMsTUFBTSxHQUFHalIsRUFBRSxDQUFDa1IsYUFBSCxFQUFmO0FBRUFwaEIsY0FBTSxDQUFDOEksTUFBTSxDQUFDbVksVUFBUixFQUFvQi9RLEVBQXBCLEVBQXdCaVIsTUFBTSxDQUFDdGYsR0FBL0IsQ0FIcUMsRUFJM0M3QixNQUFNLENBQUM4SSxNQUFNLENBQUNvWSxVQUFSLEVBQW9CaFIsRUFBcEIsRUFBd0JpUixNQUFNLENBQUMvVixHQUEvQixDQUpxQztBQUszQyxPQTdMaUIsQ0ErTGxCOzs7QUFDQThFLFFBQUUsQ0FBQ21SLFVBQUgsRUFoTWtCLEVBbU1sQm5SLEVBQUUsQ0FBQ2lELEdBQUgsQ0FBTytKLE9BQVAsR0FBaUJoTixFQUFFLENBQUNrSCxXQUFILENBQWUzVyxJQUFmLEVBbk1DO0FBb01sQjs7O3dDQUVtQjtBQUNuQixVQUFNeVAsRUFBRSxHQUFHLElBQVg7QUFFQSxPQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLFFBQWhCLEVBQTBCLEtBQTFCLEVBQWlDLE9BQWpDLEVBQTBDLEtBQTFDLEVBQWlELE9BQWpELEVBQTBEblEsT0FBMUQsQ0FBa0UsVUFBQXJDLENBQUMsRUFBSTtBQUN0RXdTLFVBQUUsZUFBUXhTLENBQVIsRUFBRixFQURzRTtBQUV0RSxPQUZELENBSG1CLEVBT25CcUIsUUFBUSxDQUFDbVIsRUFBRSxDQUFDcEgsTUFBSCxDQUFVd1ksV0FBWCxDQUFSLElBQW1DcFIsRUFBRSxDQUFDcVIsUUFBSCxFQVBoQjtBQVFuQjs7O3VDQUVrQjtBQUNsQixVQUFNclIsRUFBRSxHQUFHLElBQVg7QUFFQSxhQUFPO0FBQ05wWCxhQUFLLEVBQUVvWCxFQUFFLENBQUNrSCxXQURKO0FBRU5SLFdBQUcsRUFBRTFHLEVBQUUsQ0FBQzBHLEdBRkY7QUFHTmtJLFlBQUksRUFBRTVPLEVBQUUsQ0FBQzRPLElBSEg7QUFJTjNjLFlBQUksRUFBRStOLEVBQUUsQ0FBQy9OLElBSkg7QUFLTjNGLGVBQU8sRUFBRTBULEVBQUUsQ0FBQzFULE9BTE47QUFNTmdsQixjQUFNLEVBQUV0UixFQUFFLENBQUNzUixNQU5MO0FBT05qbEIsYUFBSyxFQUFFMlQsRUFBRSxDQUFDM1QsS0FQSjtBQVFOM0IsWUFBSSxFQUFFc1YsRUFBRSxDQUFDdFYsSUFSSDtBQVNOOUMsV0FBRyxFQUFFb1ksRUFBRSxDQUFDblksSUFURjtBQVVOVSxXQUFHLEVBQUU7QUFDSkMsY0FBSSxFQUFFd1gsRUFBRSxDQUFDdVI7QUFETCxTQVZDO0FBYU5sbUIsWUFBSSxFQUFFO0FBQ0xDLGVBQUssRUFBRTBVLEVBQUUsQ0FBQ3dSLFFBREw7QUFFTHpwQixlQUFLLEVBQUVpWSxFQUFFLENBQUN5UixRQUZMO0FBR0wzbkIsaUJBQU8sRUFBRWtXLEVBQUUsQ0FBQzBSO0FBSFAsU0FiQTtBQWtCTnZsQixZQUFJLEVBQUU7QUFDTEMsZUFBSyxFQUFFNFQsRUFBRSxDQUFDMlI7QUFETDtBQWxCQSxPQUFQO0FBc0JBOzs7Z0NBRVd6YSxFLEVBQUluQyxJLEVBQU07QUFDakJBLFVBQUksS0FBSyxNQURRLElBRXBCbUMsRUFBRSxDQUFDb0YsSUFBSCxDQUFRLFlBQVc7QUFDWixZQUFBakIsQ0FBQyxHQUFHa0IsaUdBQVEsQ0FBQyxJQUFELENBQVo7QUFBQSxtQkFDbUIsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFDdkI3TCxHQUR1QixDQUNuQixVQUFBbEQsQ0FBQztBQUFBLGlCQUFJUSxJQUFJLENBQUNDLElBQUwsQ0FBVW9OLENBQUMsQ0FBQ3JLLElBQUYsQ0FBT3hELENBQVAsQ0FBVixDQUFKO0FBQUEsU0FEa0IsQ0FEbkI7QUFBQTtBQUFBLFlBQ0Nva0IsRUFERDtBQUFBLFlBQ0tDLEVBREw7QUFBQSxZQUNTQyxFQURUO0FBQUEsWUFDYTFGLEVBRGI7O0FBSU4vUSxTQUFDLENBQUNySyxJQUFGLENBQU87QUFBQzRnQixZQUFFLEVBQUZBLEVBQUQ7QUFBS0MsWUFBRSxFQUFGQSxFQUFMO0FBQVNDLFlBQUUsRUFBRkEsRUFBVDtBQUFhMUYsWUFBRSxFQUFGQTtBQUFiLFNBQVAsQ0FMa0I7QUFNbEIsT0FORCxDQUZvQjtBQVVyQjtBQUVEOzs7Ozs7OztnQ0FLWTlELE0sRUFBUTtBQUFBLFVBQ2J0SSxFQUFFLEdBQUcsSUFEUTtBQUFBLFVBRWJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZDO0FBQUEsVUFHYnNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSE47QUFBQSxVQUliNFIsTUFBTSxHQUFHL1IsRUFBRSxDQUFDZ1MsVUFBSCxFQUpJO0FBQUEsVUFNYlYsTUFBTSxHQUFHO0FBQ2RoZ0IsYUFBSyxFQUFFME8sRUFBRSxDQUFDc1IsTUFBSCxHQUFZdFIsRUFBRSxDQUFDaVMsY0FBSCxFQUFaLEdBQWtDLENBRDNCO0FBRWQxZ0IsY0FBTSxFQUFFeU8sRUFBRSxDQUFDc1IsTUFBSCxHQUFZdFIsRUFBRSxDQUFDa1MsZUFBSCxFQUFaLEdBQW1DO0FBRjdCLE9BTkk7QUFBQSxVQVdiQyxxQkFBcUIsR0FBR25TLEVBQUUsQ0FBQzJMLGFBQUgsSUFBb0IzTCxFQUFFLENBQUM2TCxhQUF2QixHQUF1QyxDQUF2QyxHQUEyQ3lGLE1BQU0sQ0FBQy9mLE1BWDdEO0FBQUEsVUFZYjZnQixXQUFXLEdBQUdsUyxTQUFTLElBQUk2UixNQUFiLEdBQXNCLENBQXRCLEdBQTBCL1IsRUFBRSxDQUFDcVMsdUJBQUgsQ0FBMkIsR0FBM0IsQ0FaM0I7QUFBQSxVQWNiQyxtQkFBbUIsR0FBRzFaLE1BQU0sQ0FBQzJaLG9CQUFQLElBQStCM1osTUFBTSxDQUFDNFosOEJBQXRDLEdBQzNCSixXQUQyQixHQUNiLEVBZkk7QUFBQSxVQWdCYkssY0FBYyxHQUFHN1osTUFBTSxDQUFDNlcsYUFBUCxJQUF3QixDQUFDc0MsTUFBekIsR0FDckJuWixNQUFNLENBQUM4WixvQkFBUCxHQUE4QkosbUJBRFQsR0FDZ0MsQ0FqQnBDO0FBbUJsQmhLLFlBQUQsSUFBV3RJLEVBQUUsQ0FBQzJTLGdCQUFILEVBbkJRLEVBc0JuQjNTLEVBQUUsQ0FBQzRTLE1BQUgsR0FBWTFTLFNBQVMsR0FBRztBQUN2QmIsV0FBRyxFQUFFVyxFQUFFLENBQUNxUyx1QkFBSCxDQUEyQixJQUEzQixJQUFtQ3JTLEVBQUUsQ0FBQzZTLG9CQUFILEVBRGpCO0FBRXZCdlQsYUFBSyxFQUFFeVMsTUFBTSxHQUFHLENBQUgsR0FBTy9SLEVBQUUsQ0FBQzhTLHNCQUFILEVBRkc7QUFHdkJ2VCxjQUFNLEVBQUVTLEVBQUUsQ0FBQ3FTLHVCQUFILENBQTJCLEdBQTNCLElBQWtDRixxQkFBbEMsR0FBMERuUyxFQUFFLENBQUMrUyx1QkFBSCxFQUgzQztBQUl2QnZULFlBQUksRUFBRWlULGNBQWMsSUFBSVYsTUFBTSxHQUFHLENBQUgsR0FBTy9SLEVBQUUsQ0FBQ2dULHFCQUFILEVBQWpCO0FBSkcsT0FBSCxHQUtqQjtBQUNIM1QsV0FBRyxFQUFFLElBQUlXLEVBQUUsQ0FBQzZTLG9CQUFILEVBRE47QUFDaUM7QUFDcEN2VCxhQUFLLEVBQUV5UyxNQUFNLEdBQUcsQ0FBSCxHQUFPL1IsRUFBRSxDQUFDOFMsc0JBQUgsRUFGakI7QUFHSHZULGNBQU0sRUFBRTZTLFdBQVcsR0FBR0ssY0FBZCxHQUErQk4scUJBQS9CLEdBQXVEblMsRUFBRSxDQUFDK1MsdUJBQUgsRUFINUQ7QUFJSHZULFlBQUksRUFBRXVTLE1BQU0sR0FBRyxDQUFILEdBQU8vUixFQUFFLENBQUNnVCxxQkFBSDtBQUpoQixPQTNCZSxFQW1DbkJoVCxFQUFFLENBQUNpVCxPQUFILEdBQWEvUyxTQUFTLEdBQUc7QUFDeEJiLFdBQUcsRUFBRVcsRUFBRSxDQUFDNFMsTUFBSCxDQUFVdlQsR0FEUztBQUV4QkMsYUFBSyxFQUFFNFQsR0FGaUI7QUFHeEIzVCxjQUFNLEVBQUUsS0FBSzRTLHFCQUhXO0FBSXhCM1MsWUFBSSxFQUFFUSxFQUFFLENBQUNxTTtBQUplLE9BQUgsR0FLbEI7QUFDSGhOLFdBQUcsRUFBRVcsRUFBRSxDQUFDbVQsYUFBSCxHQUFtQlYsY0FBbkIsR0FBb0NOLHFCQUR0QztBQUVIN1MsYUFBSyxFQUFFNFQsR0FGSjtBQUdIM1QsY0FBTSxFQUFFK1MsbUJBQW1CLEdBQUdILHFCQUgzQjtBQUlIM1MsWUFBSSxFQUFFUSxFQUFFLENBQUM0UyxNQUFILENBQVVwVDtBQUpiLE9BeENlLEVBZ0RuQlEsRUFBRSxDQUFDb1QsT0FBSCxHQUFhO0FBQ1ovVCxXQUFHLEVBQUUsQ0FETztBQUVaQyxhQUFLLEVBQUU0VCxHQUZLO0FBR1ozVCxjQUFNLEVBQUUsQ0FISTtBQUlaQyxZQUFJLEVBQUU7QUFKTSxPQWhETSxFQXVEbkJRLEVBQUUsQ0FBQ3FULG1CQUFILElBQTBCclQsRUFBRSxDQUFDcVQsbUJBQUgsQ0FBdUIvQixNQUF2QixDQXZEUCxFQXlEbkJ0UixFQUFFLENBQUMxTyxLQUFILEdBQVcwTyxFQUFFLENBQUNzVCxZQUFILEdBQWtCdFQsRUFBRSxDQUFDNFMsTUFBSCxDQUFVcFQsSUFBNUIsR0FBbUNRLEVBQUUsQ0FBQzRTLE1BQUgsQ0FBVXRULEtBekRyQyxFQTBEbkJVLEVBQUUsQ0FBQ3pPLE1BQUgsR0FBWXlPLEVBQUUsQ0FBQ21ULGFBQUgsR0FBbUJuVCxFQUFFLENBQUM0UyxNQUFILENBQVV2VCxHQUE3QixHQUFtQ1csRUFBRSxDQUFDNFMsTUFBSCxDQUFVclQsTUExRHRDLEVBNERmUyxFQUFFLENBQUMxTyxLQUFILEdBQVcsQ0E1REksS0E2RGxCME8sRUFBRSxDQUFDMU8sS0FBSCxHQUFXLENBN0RPLEdBZ0VmME8sRUFBRSxDQUFDek8sTUFBSCxHQUFZLENBaEVHLEtBaUVsQnlPLEVBQUUsQ0FBQ3pPLE1BQUgsR0FBWSxDQWpFTSxHQW9FbkJ5TyxFQUFFLENBQUN1VCxNQUFILEdBQVlyVCxTQUFTLEdBQ3BCRixFQUFFLENBQUM0UyxNQUFILENBQVVwVCxJQUFWLEdBQWlCUSxFQUFFLENBQUNxTSxvQkFBcEIsR0FBMkNyTSxFQUFFLENBQUNzTSxxQkFEMUIsR0FDa0R0TSxFQUFFLENBQUMxTyxLQXJFdkQsRUF1RW5CME8sRUFBRSxDQUFDd1QsT0FBSCxHQUFhdFQsU0FBUyxHQUNyQkYsRUFBRSxDQUFDek8sTUFEa0IsR0FDVHlPLEVBQUUsQ0FBQ21ULGFBQUgsR0FBbUJuVCxFQUFFLENBQUNpVCxPQUFILENBQVc1VCxHQUE5QixHQUFvQ1csRUFBRSxDQUFDaVQsT0FBSCxDQUFXMVQsTUF4RXpDLEVBMEVmUyxFQUFFLENBQUN1VCxNQUFILEdBQVksQ0ExRUcsS0EyRWxCdlQsRUFBRSxDQUFDdVQsTUFBSCxHQUFZLENBM0VNLEdBOEVmdlQsRUFBRSxDQUFDd1QsT0FBSCxHQUFhLENBOUVFLEtBK0VsQnhULEVBQUUsQ0FBQ3dULE9BQUgsR0FBYSxDQS9FSyxHQW1GbkJ4VCxFQUFFLENBQUN5VCxRQUFILEdBQWN6VCxFQUFFLENBQUMxTyxLQUFILElBQVkwTyxFQUFFLENBQUMyTCxhQUFILEdBQW1CMkYsTUFBTSxDQUFDaGdCLEtBQVAsR0FBZSxFQUFsQyxHQUF1QyxDQUFuRCxDQW5GSyxFQW9GbkIwTyxFQUFFLENBQUMwVCxTQUFILEdBQWUxVCxFQUFFLENBQUN6TyxNQUFILElBQWF5TyxFQUFFLENBQUMyTCxhQUFILEdBQW1CLENBQW5CLEdBQXVCLEVBQXBDLENBcEZJLEVBc0ZmM0wsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsS0FBdUIsQ0FBQ2hWLE1BQU0sQ0FBQythLGdCQXRGaEIsS0F1RmxCM1QsRUFBRSxDQUFDMFQsU0FBSCxJQUFnQjFULEVBQUUsQ0FBQ3pPLE1BQUgsR0FBWXlPLEVBQUUsQ0FBQzRULG1CQUFILEVBdkZWLEdBMEZuQjVULEVBQUUsQ0FBQzZULFlBQUgsSUFBbUI3VCxFQUFFLENBQUM2VCxZQUFILEVBMUZBLEVBNEZmN1QsRUFBRSxDQUFDMkwsYUFBSCxJQUFvQm9HLE1BNUZMLEtBNkZsQi9SLEVBQUUsQ0FBQ29ULE9BQUgsQ0FBVzVULElBQVgsR0FBa0JRLEVBQUUsQ0FBQ3lULFFBQUgsR0FBYyxDQUFkLEdBQWtCelQsRUFBRSxDQUFDOFQsY0FBSCxHQUFvQixHQTdGdEM7QUErRm5CO0FBRUQ7Ozs7Ozs7O2tDQUtjaFEsTyxFQUFTO0FBQ3RCLFVBQU05RCxFQUFFLEdBQUcsSUFBWCxDQURzQixDQUd0Qjs7QUFDQUEsUUFBRSxDQUFDK1Qsb0JBQUgsQ0FBd0JqUSxPQUF4QixDQUpzQixFQU90QjlELEVBQUUsQ0FBQ2dVLG1CQUFILENBQXVCbFEsT0FBdkIsQ0FQc0IsRUFVdEI5RCxFQUFFLENBQUNpVSxvQkFBSCxDQUF3Qm5RLE9BQXhCLENBVnNCLEVBYXRCOUQsRUFBRSxDQUFDZ1MsVUFBSCxDQUFjbE8sT0FBZCxNQUNDOUQsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsSUFDQzVOLEVBQUUsQ0FBQ2tVLHFCQUFILENBQXlCcFEsT0FBekIsQ0FERCxHQUVDOUQsRUFBRSxDQUFDbVUsbUJBQUgsQ0FBdUJyUSxPQUF2QixDQUhGLENBYnNCLEVBb0J0QjlELEVBQUUsQ0FBQ29VLHdCQUFILElBQ0NwVSxFQUFFLENBQUNvVSx3QkFBSCxDQUE0QnRRLE9BQTVCLENBckJxQixFQXdCdEI5RCxFQUFFLENBQUNxVSxXQUFILEVBeEJzQjtBQXlCdEI7QUFFRDs7Ozs7OztrQ0FJYztBQUNiLFVBQU1yVSxFQUFFLEdBQUcsSUFBWDtBQUVBQSxRQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLFlBQXFCeEssY0FBSyxDQUFDbkcsTUFBM0IsR0FDRThILE1BREYsQ0FDUyxVQUFBM0YsQ0FBQztBQUFBLGVBQUkyUixFQUFFLENBQUNzVSxjQUFILENBQWtCam1CLENBQUMsQ0FBQ2dTLEVBQXBCLENBQUo7QUFBQSxPQURWLEVBRUVsRyxVQUZGLEdBR0UrTixRQUhGLENBR1dsSSxFQUFFLENBQUNwSCxNQUFILENBQVVJLG1CQUhyQixFQUlFN0MsS0FKRixDQUlRLFNBSlIsRUFJbUIsR0FKbkIsQ0FIYTtBQVFiOzs7a0NBRWE3RyxPLEVBQVM7QUFDdEIsVUFBTWlsQixXQUFXLEdBQUc7QUFDbkJoTixTQUFDLElBRGtCO0FBRW5CaU4sZ0JBQVEsSUFGVztBQUduQkMsa0JBQVUsSUFIUztBQUluQkMsaUJBQVMsSUFKVTtBQUtuQkMsaUJBQVMsSUFMVTtBQU1uQkMsbUJBQVcsSUFOUTtBQU9uQkMsaUJBQVMsSUFQVTtBQVFuQkMscUJBQWEsSUFSTTtBQVNuQkMsd0JBQWdCLElBVEc7QUFVbkJDLGNBQU0sSUFWYTtBQVduQkMsbUJBQVcsRUFBRSxlQVhNO0FBWW5CQyx5QkFBaUIsRUFBRSxZQVpBO0FBYW5CQyx5QkFBaUIsRUFBRTtBQWJBLE9BQXBCO0FBMEJBLGFBVkF6bUIsTUFBTSxDQUFDQyxJQUFQLENBQVk0bEIsV0FBWixFQUF5QjFrQixPQUF6QixDQUFpQyxVQUFBTixHQUFHLEVBQUk7QUFDdkMsWUFBSTZsQixNQUFNLEdBQUdiLFdBQVcsQ0FBQ2hsQixHQUFELENBQXhCO0FBRUk3QixnQkFBUSxDQUFDMG5CLE1BQUQsQ0FIMkIsS0FJdENBLE1BQU0sR0FBR2IsV0FBVyxDQUFDYSxNQUFELENBSmtCLEdBT3ZDYixXQUFXLENBQUNobEIsR0FBRCxDQUFYLEdBQW1CRixTQUFTLENBQUNDLE9BQUQsZ0JBQWlCQyxHQUFqQixHQUF3QjZsQixNQUF4QixDQVBXO0FBUXZDLE9BUkQsQ0FVQSxFQUFPYixXQUFQO0FBQ0E7Ozs2QkFFc0M7QUFBQSxVQUFoQ2psQixPQUFnQyx1RUFBdEIsRUFBc0I7QUFBQSxVQUFsQitsQixnQkFBa0I7QUFBQSxVQUNoQ3JWLEVBQUUsR0FBRyxJQUQyQjtBQUFBLFVBRWhDL04sSUFBSSxHQUFHK04sRUFBRSxDQUFDL04sSUFGc0I7QUFBQSxVQUdoQzJHLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BSG9CO0FBQUEsVUFJaENnTyxhQUFhLEdBQUc1RyxFQUFFLENBQUM2RyxtQkFBSCxDQUF1QjdHLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQS9CLENBSmdCO0FBQUEsVUFNaENnTixZQUFZLEdBQUd4aEIsT0FBTyxDQUFDd2hCLFlBTlM7QUFBQSxVQU9oQ3dFLElBQUksR0FBR2htQixPQUFPLENBQUNnbUIsSUFQaUI7QUFBQSxVQVFoQ0MsR0FBRyxHQUFHdlYsRUFBRSxDQUFDd1YsYUFBSCxDQUFpQmxtQixPQUFqQixDQVIwQjtBQUFBLFVBU2hDNFksUUFBUSxHQUFHcU4sR0FBRyxDQUFDZCxVQUFKLEdBQWlCN2IsTUFBTSxDQUFDSSxtQkFBeEIsR0FBOEMsQ0FUekI7QUFBQSxVQVVoQ3ljLGVBQWUsR0FBR0YsR0FBRyxDQUFDTCxpQkFBSixHQUF3QmhOLFFBQXhCLEdBQW1DLENBVnJCO0FBQUEsVUFXaEN3TixlQUFlLEdBQUdILEdBQUcsQ0FBQ0osaUJBQUosR0FBd0JqTixRQUF4QixHQUFtQyxDQVhyQjtBQUFBLFVBWWhDRSxXQUFXLEdBQUdpTixnQkFBZ0IsSUFBSXJWLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUTJ0QixtQkFBUixDQUE0QkQsZUFBNUIsQ0FaRjtBQWNwQzVFLGtCQUFZLElBQUlsWSxNQUFNLENBQUNnZCxpQkFBekIsSUFDQzVWLEVBQUUsQ0FBQzBNLFNBQUgsS0FBaUIsT0FEbEIsSUFDNkIxTSxFQUFFLENBQUM2VixXQUFILEVBZlMsRUFpQnRDN1YsRUFBRSxDQUFDOE4sV0FBSCxDQUFlZ0QsWUFBZixDQWpCc0MsRUFxQmxDeUUsR0FBRyxDQUFDUCxNQUFKLElBQWNwYyxNQUFNLENBQUNpVixXQXJCYSxHQXNCckM3TixFQUFFLENBQUM4VixZQUFILENBQWdCOVYsRUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsQ0FBaEIsRUFBOEN4VSxPQUE5QyxFQUF1RDhZLFdBQXZELENBdEJxQyxHQXVCM0JtTixHQUFHLENBQUNaLFNBdkJ1QixJQTBCckMzVSxFQUFFLENBQUN1USxlQUFILElBMUJxQyxFQStCdEN2USxFQUFFLENBQUMrVixVQUFILENBQWNuUCxhQUFkLEVBQTZCMk8sR0FBN0IsRUFBa0NuTixXQUFsQyxFQUErQ2tOLElBQS9DLEVBQXFEeEUsWUFBckQsQ0EvQnNDLEVBa0N0QzlRLEVBQUUsQ0FBQ2dXLGFBQUgsRUFsQ3NDLEVBcUN0Q2hXLEVBQUUsQ0FBQ2lXLGdCQUFILEVBckNzQyxFQXdDdENyZCxNQUFNLENBQUNrWCxxQkFBUCxJQUFnQzdkLElBQUksQ0FBQ0csTUFBTCxnQkFBb0JDLGNBQUssQ0FBQ2xHLElBQTFCLGNBQWtDa0csY0FBSyxDQUFDbEksS0FBeEMsR0FDOUI2RyxJQUQ4QixDQUN6QixHQUR5QixFQUNwQmdQLEVBQUUsQ0FBQzFPLEtBQUgsR0FBVyxDQURTLEVBRTlCTixJQUY4QixDQUV6QixHQUZ5QixFQUVwQmdQLEVBQUUsQ0FBQ3pPLE1BQUgsR0FBWSxDQUZRLEVBRzlCcEYsSUFIOEIsQ0FHekJ5TSxNQUFNLENBQUNrWCxxQkFIa0IsRUFJOUIzWixLQUo4QixDQUl4QixTQUp3QixFQUlieVEsYUFBYSxDQUFDcFksTUFBZCxHQUF1QixNQUF2QixHQUFnQyxJQUpuQixDQXhDTSxFQStDdEN3UixFQUFFLENBQUNrVyxVQUFILENBQWNoTyxRQUFkLENBL0NzQyxFQWtEdENsSSxFQUFFLENBQUNtVyxZQUFILENBQWdCak8sUUFBaEIsQ0FsRHNDLEVBcUR0Q2xJLEVBQUUsQ0FBQ29XLFNBQUgsQ0FBYVgsZUFBYixDQXJEc0MsRUF3RHRDelYsRUFBRSxDQUFDcVcsVUFBSCxDQUFjWixlQUFkLENBeERzQyxFQXlEdEN6VixFQUFFLENBQUNzVyxVQUFILENBQWNiLGVBQWQsQ0F6RHNDLEVBMER0Q3pWLEVBQUUsQ0FBQ3VXLFlBQUgsRUExRHNDLEVBNkR0Q3ZXLEVBQUUsQ0FBQ3dXLFlBQUgsTUFBcUJ4VyxFQUFFLENBQUN5VyxVQUFILENBQWNoQixlQUFkLENBN0RpQixFQWdFdEN6VixFQUFFLENBQUMwVyxXQUFILElBQWtCMVcsRUFBRSxDQUFDMFcsV0FBSCxFQWhFb0IsRUFtRXRDMVcsRUFBRSxDQUFDblksSUFBSCxJQUFXbVksRUFBRSxDQUFDMlcsU0FBSCxDQUFhek8sUUFBYixFQUF1QnVOLGVBQXZCLEVBQXdDRixHQUFHLENBQUNWLFNBQTVDLENBbkUyQixFQXNFdEM3VSxFQUFFLENBQUM0VyxNQUFILElBQWE1VyxFQUFFLENBQUM2VyxXQUFILENBQWUzTyxRQUFmLEVBQXlCdU4sZUFBekIsQ0F0RXlCLEVBeUV0Q3pWLEVBQUUsQ0FBQzJSLFFBQUgsSUFBZTFmLElBQUksQ0FBQzRLLFNBQUwsWUFBbUJ4SyxjQUFLLENBQUMzRyxlQUF6QixHQUNic0ksTUFEYSxDQUNOZ00sRUFBRSxDQUFDOFcsU0FBSCxDQUFhdGIsSUFBYixDQUFrQndFLEVBQWxCLENBRE0sRUFFYm5ELFNBRmEsQ0FFSCxRQUZHLEVBR2JVLE1BSGEsRUF6RXVCLEVBK0VsQzNFLE1BQU0sQ0FBQzBWLG1CQUFQLElBQThCLENBQUNnSCxJQUEvQixJQUF1Q0MsR0FBRyxDQUFDYixTQS9FVCxLQWdGckMxVSxFQUFFLENBQUMrVyxlQUFILEVBaEZxQyxFQWlGckMvVyxFQUFFLENBQUNnWCxhQUFILEVBakZxQyxHQW9GdENoWCxFQUFFLENBQUNpWCxrQkFBSCxDQUFzQnJRLGFBQXRCLEVBQXFDME8sSUFBckMsRUFBMkNwTixRQUEzQyxFQUFxRHFOLEdBQUcsQ0FBQ2YsUUFBekQsQ0FwRnNDLEVBcUZ0Q3hVLEVBQUUsQ0FBQzhJLGNBQUgsQ0FBa0IsU0FBbEIsRUFBNkJ4WixPQUE3QixFQUFzQzRZLFFBQXRDLENBckZzQztBQXNGdEM7QUFFRDs7Ozs7Ozs7Ozs7K0JBUVd0QixhLEVBQWUyTyxHLEVBQUtuTixXLEVBQWFrTixJLEVBQU1oTixNLEVBQVE7QUFBQSxVQUtyRHJOLFVBTHFEO0FBQUEsVUFNckRpYyxrQkFOcUQ7QUFBQSxVQU9yREMsY0FQcUQ7QUFBQSxVQUNuRG5YLEVBQUUsR0FBRyxJQUQ4QztBQUFBLFVBRW5EcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGdUM7QUFBQSxVQUduRG9aLFVBQVUsR0FBR2hTLEVBQUUsQ0FBQ2dTLFVBQUgsRUFIc0M7QUFBQSxVQUluRG9GLE9BQU8sR0FBRyxDQUFDLENBQUNwWCxFQUFFLENBQUNtRCxTQUpvQztBQTBEekQ7QUFDQSxVQWxESSxDQUFDaVUsT0FBRCxJQUFZcFgsRUFBRSxDQUFDeUMsYUFBSCxFQUFaLElBQWtDbUUsYUFBYSxDQUFDcFksTUFBZCxLQUF5QixDQWtEL0QsSUFqREN3UixFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLENBQVksQ0FBQyxDQUFELEVBQUl5RyxFQUFFLENBQUNhLElBQUgsQ0FBUXpQLENBQVIsQ0FBVXlMLFNBQVYsQ0FBb0IsT0FBcEIsRUFBNkJ6QyxJQUE3QixFQUFKLENBQVosQ0FpREQsRUE5Q0k0RixFQUFFLENBQUM1TyxDQUFILElBQVF3VixhQUFhLENBQUNwWSxNQThDMUIsSUE3Q0MsQ0FBQzRvQixPQUFELElBQ0NwWCxFQUFFLENBQUNxWCxhQUFILENBQWlCelEsYUFBakIsRUFBZ0MyTyxHQUFHLENBQUNULGFBQXBDLEVBQW1EUyxHQUFHLENBQUNSLGdCQUF2RCxFQUF5RVEsR0FBRyxDQUFDWCxXQUE3RSxDQTRDRixFQTFDSyxDQUFDaGMsTUFBTSxDQUFDMGUsa0JBMENiLEtBekNFcmMsVUFBVSxHQUFHK0UsRUFBRSxDQUFDaFksSUFBSCxDQUFRZ2YscUJBQVIsQ0FBOEJKLGFBQTlCLENBeUNmLEtBdkNXNUcsRUFBRSxDQUFDdUMsS0F1Q2QsS0F0Q0N2QyxFQUFFLENBQUN1QyxLQUFILENBQVN0SCxVQUFULENBQW9CLEVBQXBCLENBc0NELEVBckNDK0UsRUFBRSxDQUFDbUUsUUFBSCxDQUFZbEosVUFBWixDQUF1QixFQUF2QixDQXFDRCxHQWxDSXJDLE1BQU0sQ0FBQzJlLFlBQVAsSUFBdUIsQ0FBQ2pDLElBa0M1QixLQWpDQzZCLGNBQWMsR0FBR25YLEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzJaLFNBQUwsRUFpQ2xCLEdBOUJBLENBQUMsR0FBRCxFQUFNLElBQU4sRUFBWWxiLE9BQVosQ0FBb0IsVUFBQU4sR0FBRyxFQUFJO0FBQzFCLFlBQU12SCxJQUFJLEdBQUdnWSxFQUFFLENBQUN6USxHQUFELENBQWY7O0FBRUEsWUFBSXZILElBQUosRUFBVTtBQUFBLGNBQ0hpVCxVQUFVLEdBQUdyQyxNQUFNLGdCQUFTckosR0FBVCxrQkFEaEI7QUFBQSxjQUVId1gsU0FBUyxHQUFHbk8sTUFBTSxnQkFBU3JKLEdBQVQsaUJBRmY7O0FBTVQsY0FGQXZILElBQUksQ0FBQ3VSLE1BQUwsQ0FBWXlHLEVBQUUsQ0FBQ21PLFVBQUgsQ0FBY3ZILGFBQWQsRUFBNkJyWCxHQUE3QixFQUFrQzRuQixjQUFsQyxDQUFaLENBRUEsRUFBSSxDQUFDbGMsVUFBRCxJQUFlOEwsU0FBbkIsRUFBOEI7QUFDN0IsZ0JBQU14TixNQUFNLEdBQUd2UixJQUFJLENBQUN1UixNQUFMLEVBQWY7QUFFQXlHLGNBQUUsV0FBSXpRLEdBQUosVUFBRixDQUFpQjBMLFVBQWpCLENBQ0MrRSxFQUFFLENBQUNoWSxJQUFILENBQVFpYyxrQkFBUixDQUNDMUssTUFERCxFQUVDQSxNQUFNLENBQUM1RSxLQUFQLENBQWEsVUFBQW5ILENBQUM7QUFBQSxxQkFBSUEsQ0FBQyxLQUFLLENBQVY7QUFBQSxhQUFkLElBQTZCLENBQTdCLEdBQWlDdVosU0FGbEMsRUFHQy9HLEVBQUUsQ0FBQzRELGFBQUgsRUFIRCxDQURELENBSDZCO0FBVTdCO0FBQ0Q7QUFDRCxPQXJCRCxDQThCQSxFQU5BNUQsRUFBRSxDQUFDaFksSUFBSCxDQUFReW9CLE1BQVIsQ0FBZXJJLFdBQWYsRUFBNEI0SixVQUE1QixFQUF3QzFKLE1BQXhDLENBTUEsRUFIQXRJLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUXd2QixZQUFSLENBQXFCakMsR0FBRyxDQUFDZCxVQUF6QixDQUdBLEVBQUksQ0FBQ2MsR0FBRyxDQUFDVCxhQUFKLElBQXFCUyxHQUFHLENBQUNOLFdBQTFCLEtBQTBDck8sYUFBYSxDQUFDcFksTUFBNUQsRUFDQyxJQUFJb0ssTUFBTSxDQUFDNEssbUJBQVAsSUFBOEJ2SSxVQUFsQyxFQUE4QztBQUM3QyxhQUFLLElBQUluSyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbUssVUFBVSxDQUFDek0sTUFBL0IsRUFBdUNzQyxDQUFDLEVBQXhDLEVBQ0MsSUFBSW1LLFVBQVUsQ0FBQ3pNLE1BQVgsR0FBb0JzQyxDQUFwQixHQUF3QjhILE1BQU0sQ0FBQzZlLHVCQUFuQyxFQUE0RDtBQUMzRFAsNEJBQWtCLEdBQUdwbUIsQ0FEc0M7QUFFM0Q7QUFDQTs7QUFHRmtQLFVBQUUsQ0FBQzBHLEdBQUgsQ0FBTzdKLFNBQVAsWUFBcUJ4SyxjQUFLLENBQUNwSyxLQUEzQixrQkFBK0NxVSxJQUEvQyxDQUFvRCxVQUFTak8sQ0FBVCxFQUFZO0FBQy9ELGNBQU1zUCxLQUFLLEdBQUcxQyxVQUFVLENBQUN0VCxPQUFYLENBQW1CMEcsQ0FBbkIsQ0FBZDtBQUVBc1AsZUFBSyxJQUFJLENBQVQsSUFDQ3BCLGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWVwRyxLQUFmLENBQXFCLFNBQXJCLEVBQWdDd0gsS0FBSyxHQUFHdVosa0JBQVIsR0FBNkIsTUFBN0IsR0FBc0MsT0FBdEUsQ0FKOEQ7QUFLL0QsU0FMRCxDQVI2QztBQWM3QyxPQWRELE1BZUNsWCxFQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLFlBQXFCeEssY0FBSyxDQUFDcEssS0FBM0Isa0JBQStDa08sS0FBL0MsQ0FBcUQsU0FBckQsRUFBZ0UsT0FBaEUsQ0FmRCxDQTVEd0QsQ0ErRXpEOztBQUNJb2YsU0FBRyxDQUFDaE8sQ0FoRmlELEtBaUZ4RHZILEVBQUUsQ0FBQ29PLElBQUgsSUFBV3BPLEVBQUUsQ0FBQ29PLElBQUgsQ0FBUTdVLE1BQVIsQ0FBZXlHLEVBQUUsQ0FBQ21PLFVBQUgsQ0FBY3ZILGFBQWQsRUFBNkIsR0FBN0IsQ0FBZixDQWpGNkMsRUFrRnhENUcsRUFBRSxDQUFDcU8sS0FBSCxJQUFZck8sRUFBRSxDQUFDcU8sS0FBSCxDQUFTOVUsTUFBVCxDQUFnQnlHLEVBQUUsQ0FBQ21PLFVBQUgsQ0FBY3ZILGFBQWQsRUFBNkIsSUFBN0IsQ0FBaEIsQ0FsRjRDO0FBb0Z6RDtBQUVEOzs7Ozs7Ozs7Ozt1Q0FRbUJBLGEsRUFBZTBPLEksRUFBTXBOLFEsRUFBVXdQLFksRUFBYztBQUFBLFVBQ3pEMVgsRUFBRSxHQUFHLElBRG9EO0FBQUEsVUFFekRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUY2QztBQUFBLFVBR3pEak4sS0FBSyxHQUFHcVUsRUFBRSxDQUFDMlgsWUFBSCxFQUhpRDtBQU0vRC9lLFlBQU0sQ0FBQzZXLGFBQVAsSUFBd0J6UCxFQUFFLENBQUM0WCxjQUFILENBQWtCRixZQUFsQixFQUFnQ3hQLFFBQWhDLEVBQTBDdmMsS0FBMUMsQ0FOdUM7QUFRL0Q7QUFSK0QsVUFTekRrc0IsTUFBTSxHQUFHdkMsSUFBSSxJQUFJdFYsRUFBRSxDQUFDOFgsWUFBSCxDQUFnQjtBQUN0Q2hVLGVBQU8sRUFBRThDLGFBRDZCO0FBRXRDME8sWUFBSSxFQUFFQSxJQUZnQztBQUd0Q3BOLGdCQUFRLEVBQUVvTixJQUFJLENBQUNwTixRQUh1QjtBQUl0Q3ZjLGFBQUssRUFBTEEsS0FKc0M7QUFLdENvc0IsVUFBRSxFQUFFL1gsRUFBRSxDQUFDK1gsRUFBSCxDQUFNdmMsSUFBTixDQUFXd0UsRUFBWDtBQUxrQyxPQUFoQixDQVR3QztBQUFBLFVBZ0J6RGdZLFlBQVksR0FBRyxDQUFDOVAsUUFBUSxJQUFJMlAsTUFBYixLQUF3QjdYLEVBQUUsQ0FBQ2lZLFlBQUgsRUFoQmtCO0FBQUEsVUFtQnpEQyxVQUFVLEdBQUdsWSxFQUFFLENBQUNtWSxhQUFILENBQWlCeHNCLEtBQWpCLEVBQXdCMnBCLElBQXhCLEVBQThCdUMsTUFBOUIsRUFBc0NHLFlBQXRDLENBbkI0QztBQUFBLFVBc0J6REksV0FBVyxHQUFHOUMsSUFBSSxJQUFJMWMsTUFBTSxDQUFDeWYsVUFBZixHQUE0QixZQUFNO0FBQ3JEUixjQUFNLElBQUlBLE1BQU0sRUFEcUMsRUFFckQvbkIsTUFBTSxDQUFDOEksTUFBTSxDQUFDeWYsVUFBUixFQUFvQnJZLEVBQXBCLENBRitDO0FBR3JELE9BSG1CLEdBR2hCLElBekIyRDtBQTJCL0QsVUFBSW9ZLFdBQUosRUFDQztBQUNBLFlBQUlKLFlBQUosRUFBa0I7QUFDakI7QUFDQSxjQUFNTSxXQUFXLEdBQUd0WSxFQUFFLENBQUN1WSxZQUFILEVBQXBCLENBRmlCLENBSWpCOztBQUNBQyxrSEFBWSxHQUFHdFEsUUFBZixDQUF3QkEsUUFBeEIsRUFDRTVMLElBREYsQ0FDTyxZQUFNO0FBQ1g0YixzQkFBVSxDQUNSaGtCLE1BREYsQ0FDUyxVQUFDdWtCLEdBQUQsRUFBTUMsRUFBTjtBQUFBLHFCQUFhRCxHQUFHLENBQUNqbEIsTUFBSixDQUFXa2xCLEVBQVgsQ0FBYjtBQUFBLGFBRFQsRUFDc0MsRUFEdEMsRUFFRTdvQixPQUZGLENBRVUsVUFBQThGLENBQUM7QUFBQSxxQkFBSTJpQixXQUFXLENBQUNLLEdBQVosQ0FBZ0JoakIsQ0FBaEIsQ0FBSjtBQUFBLGFBRlgsQ0FEVztBQUlYLFdBTEYsRUFNRXpGLElBTkYsQ0FNT29vQixXQU5QLEVBTW9CRixXQU5wQixDQUxpQjtBQVlqQixTQVpELE1BYUNBLFdBQVcsRUFiWixDQTdCOEQsQ0E4Qy9EOztBQUNBcFksUUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsRUFBNkJqVSxPQUE3QixDQUFxQyxVQUFBd1EsRUFBRSxFQUFJO0FBQzFDTCxVQUFFLENBQUN5TSxhQUFILENBQWlCcE0sRUFBakIsTUFEMEM7QUFFMUMsT0FGRCxDQS9DK0Q7QUFrRC9EO0FBRUQ7Ozs7Ozs7O21DQUtlO0FBQUEsVUFDUkwsRUFBRSxHQUFHLElBREc7QUFBQSxVQUVSRSxTQUFTLEdBQUdGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBRmQ7QUFBQSxVQUdSeVksUUFBUSxHQUFHNVksRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsQ0FISDtBQUFBLFVBSVJqaUIsS0FBSyxHQUFHO0FBQUNvSixZQUFJLEVBQUUsRUFBUDtBQUFXOGpCLGVBQU8sRUFBRTtBQUFwQixPQUpBOztBQU1kO0FBQ0EsVUFBSTdZLEVBQUUsQ0FBQzhZLFNBQUgsQ0FBYSxNQUFiLEtBQXdCOVksRUFBRSxDQUFDNE4sT0FBSCxDQUFXLFFBQVgsQ0FBeEIsSUFBZ0Q1TixFQUFFLENBQUM0TixPQUFILENBQVcsU0FBWCxDQUFwRCxFQUEyRTtBQUMxRSxZQUFNaUwsT0FBTyxHQUFHN1ksRUFBRSxDQUFDK1ksZUFBSCxDQUFtQi9ZLEVBQUUsQ0FBQ2daLFVBQXRCLENBQWhCOztBQUtBLFlBSEFydEIsS0FBSyxDQUFDa3RCLE9BQU4sQ0FBY3h0QixJQUFkLEdBQXFCd3RCLE9BR3JCLEVBRkFsdEIsS0FBSyxDQUFDb0osSUFBTixDQUFXMUosSUFBWCxHQUFrQjJVLEVBQUUsQ0FBQ2laLGdCQUFILEdBQXNCalosRUFBRSxDQUFDaVosZ0JBQUgsQ0FBb0JKLE9BQXBCLEtBQXRCLEdBQTRENWpCLFNBRTlFLEVBQUkrSyxFQUFFLENBQUM4WSxTQUFILENBQWEsTUFBYixDQUFKLEVBQTBCO0FBQ3pCLGNBQU1ELFFBQU8sR0FBRzdZLEVBQUUsQ0FBQytZLGVBQUgsQ0FBbUIvWSxFQUFFLENBQUNrWixVQUF0QixDQUFoQjs7QUFFQXZ0QixlQUFLLENBQUNrdEIsT0FBTixDQUFjL3dCLElBQWQsR0FBcUIrd0IsUUFISSxFQUl6Qmx0QixLQUFLLENBQUNvSixJQUFOLENBQVdqTixJQUFYLEdBQWtCa1ksRUFBRSxDQUFDbVosZ0JBQUgsR0FBc0JuWixFQUFFLENBQUNtWixnQkFBSCxDQUFvQk4sUUFBcEIsS0FBdEIsR0FBNEQ1akIsU0FKckQ7QUFLekI7QUFDRDs7QUFFRCxVQUFJK0ssRUFBRSxDQUFDNE4sT0FBSCxDQUFXLEtBQVgsQ0FBSixFQUF1QjtBQUN0QixZQUFNaUwsU0FBTyxHQUFHN1ksRUFBRSxDQUFDK1ksZUFBSCxDQUFtQi9ZLEVBQUUsQ0FBQzhXLFNBQXRCLENBQWhCOztBQUVBbnJCLGFBQUssQ0FBQ2t0QixPQUFOLENBQWN0d0IsR0FBZCxHQUFvQnN3QixTQUhFLEVBSXRCbHRCLEtBQUssQ0FBQ29KLElBQU4sQ0FBV3hNLEdBQVgsR0FBaUJ5WCxFQUFFLENBQUNvWixlQUFILEdBQXFCcFosRUFBRSxDQUFDb1osZUFBSCxDQUFtQlAsU0FBbkIsQ0FBckIsR0FBbUQ1akIsU0FKOUM7QUFLdEI7O0FBV0QsYUFUQXRKLEtBQUssQ0FBQzRTLEdBQU4sR0FBWTtBQUNYOGEsZ0JBQVEsRUFBRXJaLEVBQUUsQ0FBQ3NaLGlCQUFILENBQXFCM3RCLEtBQUssQ0FBQ2t0QixPQUEzQixLQURDO0FBRVhVLGdCQUFRLEVBQUV2WixFQUFFLENBQUNzWixpQkFBSCxDQUFxQjN0QixLQUFLLENBQUNrdEIsT0FBM0IsS0FGQztBQUlYO0FBQ0FXLFVBQUUsRUFBRSxDQUFDWixRQUFRLEdBQUc1WSxFQUFFLENBQUN5WixZQUFOLEdBQXNCdlosU0FBUyxHQUFHRixFQUFFLENBQUMwWixPQUFOLEdBQWdCMVosRUFBRSxDQUFDMlosT0FBM0QsRUFBcUVuZSxJQUFyRSxDQUEwRXdFLEVBQTFFLENBTE87QUFNWDRaLFVBQUUsRUFBRSxDQUFDaEIsUUFBUSxHQUFHNVksRUFBRSxDQUFDNlosWUFBTixHQUFzQjNaLFNBQVMsR0FBR0YsRUFBRSxDQUFDMlosT0FBTixHQUFnQjNaLEVBQUUsQ0FBQzBaLE9BQTNELEVBQXFFbGUsSUFBckUsQ0FBMEV3RSxFQUExRTtBQU5PLE9BU1osRUFBT3JVLEtBQVA7QUFDQTs7O2tDQUVhQSxLLEVBQU8ycEIsSSxFQUFNdUMsTSxFQUFRRyxZLEVBQWM7QUFDMUMsVUFBQWhZLEVBQUUsR0FBRyxJQUFMO0FBQUEsVUFDQXBILE1BREEsR0FDU29ILEVBQUUsQ0FBQ3BILE1BRFo7QUFBQSxVQUVBb1osVUFGQSxHQUVhaFMsRUFBRSxDQUFDZ1MsVUFBSCxFQUZiO0FBQUEsdUJBRytCcm1CLEtBQUssQ0FBQzRTLEdBSHJDO0FBQUEsVUFHQ2liLEVBSEQsY0FHQ0EsRUFIRDtBQUFBLFVBR0tJLEVBSEwsY0FHS0EsRUFITDtBQUFBLFVBR1NQLFFBSFQsY0FHU0EsUUFIVDtBQUFBLFVBR21CRSxRQUhuQixjQUdtQkEsUUFIbkI7QUFBQSxVQUlBTyxJQUpBLEdBSU8sRUFKUDs7QUFNTixVQUFJLENBQUM5SCxVQUFMLEVBQWlCO0FBQUEsMEJBQ1VybUIsS0FBSyxDQUFDb0osSUFEaEI7QUFBQSxZQUNUak4sSUFEUyxlQUNUQSxJQURTO0FBQUEsWUFDSFMsR0FERyxlQUNIQSxHQURHO0FBQUEsWUFDRThDLElBREYsZUFDRUEsSUFERjtBQUFBLFNBR1p1TixNQUFNLENBQUNtaEIsWUFBUCxDQUFvQnZyQixNQUFwQixJQUE4Qm9LLE1BQU0sQ0FBQ29oQixZQUFQLENBQW9CeHJCLE1BSHRDLEtBSWZzckIsSUFBSSxDQUFDemtCLElBQUwsQ0FBVTJLLEVBQUUsQ0FBQ2lhLFVBQUgsQ0FBY2pDLFlBQWQsQ0FBVixDQUplLEVBT1pwZixNQUFNLENBQUNwTixPQUFQLENBQWVnRCxNQVBILElBUWZzckIsSUFBSSxDQUFDemtCLElBQUwsQ0FBVTJLLEVBQUUsQ0FBQ2thLFlBQUgsQ0FBZ0JsQyxZQUFoQixDQUFWLENBUmUsRUFXWmhZLEVBQUUsQ0FBQzhZLFNBQUgsQ0FBYSxNQUFiLENBWFksS0FZZmdCLElBQUksQ0FBQ3prQixJQUFMLENBQVUySyxFQUFFLENBQUNtYSxVQUFILENBQWM5dUIsSUFBZCxFQUFvQjJzQixZQUFwQixDQUFWLENBWmUsRUFhZmhZLEVBQUUsQ0FBQzhZLFNBQUgsQ0FBYSxNQUFiLEtBQXdCZ0IsSUFBSSxDQUFDemtCLElBQUwsQ0FBVTJLLEVBQUUsQ0FBQ29hLFVBQUgsQ0FBY3R5QixJQUFkLEVBQW9Ca3dCLFlBQXBCLENBQVYsQ0FiVCxHQWdCaEJoWSxFQUFFLENBQUM0TixPQUFILENBQVcsS0FBWCxLQUFxQmtNLElBQUksQ0FBQ3prQixJQUFMLENBQVUySyxFQUFFLENBQUNxYSxTQUFILENBQWE5eEIsR0FBYixFQUFrQnl2QixZQUFsQixDQUFWLENBaEJMLEVBa0JoQm5wQixRQUFRLENBQUMrSixNQUFNLENBQUN3WSxXQUFSLENBQVIsSUFDQzBJLElBQUksQ0FBQ3prQixJQUFMLENBQVUySyxFQUFFLENBQUNzYSxVQUFILENBQWNqQixRQUFkLEVBQXdCRSxRQUF4QixFQUFrQ2pFLElBQWxDLEVBQXdDMEMsWUFBeEMsQ0FBVixDQW5CZTtBQW9CaEI7O0FBSUQsYUFGQSxDQUFDLENBQUNoRyxVQUFELElBQWVoUyxFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQUFoQixLQUF3Q2tNLElBQUksQ0FBQ3prQixJQUFMLENBQVUySyxFQUFFLENBQUN1YSxZQUFILENBQWdCZixFQUFoQixFQUFvQkksRUFBcEIsRUFBd0I1QixZQUF4QixFQUFzQ0gsTUFBdEMsQ0FBVixDQUV4QyxFQUFPaUMsSUFBUDtBQUNBOzs7c0NBRTZCO0FBQUEsVUFHekIxUixXQUh5QjtBQUFBLFVBQWQ5WSxPQUFjLHVFQUFKLEVBQUk7QUFBQSxVQUN2QjBRLEVBQUUsR0FBRyxJQURrQjtBQUFBLFVBRXZCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVztBQU03QnRKLGFBQU8sQ0FBQzhYLGNBQVIsR0FBeUIvWCxTQUFTLENBQUNDLE9BQUQsRUFBVSxnQkFBVixLQU5MLEVBTzdCQSxPQUFPLENBQUNvaEIsYUFBUixHQUF3QnJoQixTQUFTLENBQUNDLE9BQUQsRUFBVSxlQUFWLEtBUEosRUFRN0JBLE9BQU8sQ0FBQ2tyQixVQUFSLEdBQXFCbnJCLFNBQVMsQ0FBQ0MsT0FBRCxFQUFVLFlBQVYsS0FSRCxFQVc3QkEsT0FBTyxDQUFDcWhCLGlCQUFSLEtBWDZCLEVBWTdCcmhCLE9BQU8sQ0FBQ3NoQixvQkFBUixLQVo2QixFQWE3QnRoQixPQUFPLENBQUNtckIscUJBQVIsS0FiNkIsRUFjN0JuckIsT0FBTyxDQUFDb3JCLDBCQUFSLEdBQXFDcnJCLFNBQVMsQ0FBQ0MsT0FBRCxFQUFVLDRCQUFWLEVBQXdDQSxPQUFPLENBQUM4WCxjQUFoRCxDQWRqQixFQWlCdkI5WCxPQUFPLENBQUNrckIsVUFBUixJQUFzQjVoQixNQUFNLENBQUNpVixXQWpCTixLQWtCNUJ6RixXQUFXLEdBQUdwSSxFQUFFLENBQUNoWSxJQUFILENBQVEydEIsbUJBQVIsQ0FDYnJtQixPQUFPLENBQUN1aEIscUJBQVIsR0FBZ0NqWSxNQUFNLENBQUNJLG1CQUF2QyxHQUE2RCxDQURoRCxDQWxCYyxFQXVCNUJnSCxFQUFFLENBQUMrTixZQUFILEVBdkI0QixFQXdCNUIvTixFQUFFLENBQUN3UCxhQUFILEVBeEI0QixFQTJCNUJ4UCxFQUFFLENBQUMyYSxZQUFILENBQWdCcnJCLE9BQU8sQ0FBQ29yQiwwQkFBeEIsRUFBb0R0UyxXQUFwRCxDQTNCNEIsR0ErQjdCcEksRUFBRSxDQUFDeVEsTUFBSCxDQUFVbmhCLE9BQVYsRUFBbUI4WSxXQUFuQixDQS9CNkI7QUFnQzdCOzs7MkNBRXNCO0FBQ3RCLFdBQUtxSSxNQUFMLENBQVk7QUFDWG1LLGFBQUssSUFETTtBQUVYbEQsb0JBQVksSUFGRDtBQUdYbUQscUJBQWEsSUFIRjtBQUlYaEssNkJBQXFCO0FBSlYsT0FBWixDQURzQjtBQU90Qjs7O21DQUVjO0FBQ2QsYUFBTyxLQUFLalksTUFBTCxDQUFZa2lCLFdBQVosS0FBNEIsWUFBbkM7QUFDQTs7O29DQUVlO0FBQ2YsYUFBTyxLQUFLbGlCLE1BQUwsQ0FBWWtpQixXQUFaLENBQXdCbnpCLE9BQXhCLENBQWdDLFVBQWhDLEtBQStDLENBQS9DLElBQW9ELEtBQUtpbUIsT0FBTCxDQUFhLE9BQWIsQ0FBM0Q7QUFDQTs7O2dDQUVXO0FBQUEsVUFDTDVOLEVBQUUsR0FBRyxJQURBO0FBQUEsVUFFTHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlA7QUFJWCxhQUFPLENBQUNvSCxFQUFFLENBQUNxRCxZQUFILEVBQUQsS0FBdUJ6SyxNQUFNLENBQUNtaUIsTUFBUCxJQUFpQmxzQixRQUFRLENBQUMrSixNQUFNLENBQUNvaUIsT0FBUixDQUFoRCxDQUFQO0FBQ0E7OztvQ0FFZTtBQUNmLGFBQU8sS0FBS3BpQixNQUFMLENBQVlxaUIsV0FBWixLQUE0QixZQUFuQztBQUNBOzs7aUNBRVkvdUIsTSxFQUFtQjtBQUFBLFVBSzNCa0YsQ0FMMkI7QUFBQSxVQU0zQkMsQ0FOMkI7QUFBQSxVQUFYc00sS0FBVyx1RUFBSCxDQUFHO0FBQUEsVUFDekJxQyxFQUFFLEdBQUcsSUFEb0I7QUFBQSxVQUV6QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmE7QUFBQSxVQUd6QnNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSE07QUFBQSxVQUkzQnVILE9BQU8sR0FBRyxDQUppQjtBQVkvQixVQUpJL0osS0FBSyxJQUFJLFlBQVkzRCxJQUFaLENBQWlCOU4sTUFBakIsQ0FJYixLQUhDd2IsT0FBTyxHQUFHMUgsRUFBRSxDQUFDa2IsV0FBSCxDQUFlaHZCLE1BQWYsSUFBeUJ5UixLQUdwQyxHQUFJelIsTUFBTSxLQUFLLE1BQWYsRUFDQ2tGLENBQUMsR0FBR2xELFdBQVcsQ0FBQzhSLEVBQUUsQ0FBQzRTLE1BQUgsQ0FBVXBULElBQVgsQ0FEaEIsRUFFQ25PLENBQUMsR0FBR25ELFdBQVcsQ0FBQzhSLEVBQUUsQ0FBQzRTLE1BQUgsQ0FBVXZULEdBQVgsQ0FGaEIsTUFHTyxJQUFJblQsTUFBTSxLQUFLLFNBQWYsRUFDTmtGLENBQUMsR0FBR2xELFdBQVcsQ0FBQzhSLEVBQUUsQ0FBQ2lULE9BQUgsQ0FBV3pULElBQVosQ0FEVCxFQUVObk8sQ0FBQyxHQUFHbkQsV0FBVyxDQUFDOFIsRUFBRSxDQUFDaVQsT0FBSCxDQUFXNVQsR0FBWixDQUZULE1BR0EsSUFBSW5ULE1BQU0sS0FBSyxRQUFmLEVBQ05rRixDQUFDLEdBQUc0TyxFQUFFLENBQUNvVCxPQUFILENBQVc1VCxJQURULEVBRU5uTyxDQUFDLEdBQUcyTyxFQUFFLENBQUNvVCxPQUFILENBQVcvVCxHQUZULE1BR0EsSUFBSW5ULE1BQU0sS0FBSyxHQUFmLEVBQ05rRixDQUFDLEdBQUc4TyxTQUFTLEdBQUcsQ0FBQ3dILE9BQUosR0FBYyxDQURyQixFQUVOclcsQ0FBQyxHQUFHNk8sU0FBUyxHQUFHLENBQUgsR0FBT0YsRUFBRSxDQUFDek8sTUFBSCxHQUFZbVcsT0FGMUIsTUFHQSxJQUFJeGIsTUFBTSxLQUFLLEdBQWYsRUFDTmtGLENBQUMsR0FBRzhPLFNBQVMsR0FBRyxDQUFILEdBQU8sQ0FBQ3dILE9BRGYsRUFFTnJXLENBQUMsR0FBRzZPLFNBQVMsR0FBR0YsRUFBRSxDQUFDek8sTUFBSCxHQUFZbVcsT0FBZixHQUF5QixDQUZoQyxNQUdBLElBQUl4YixNQUFNLEtBQUssSUFBZixFQUNOa0YsQ0FBQyxHQUFHOE8sU0FBUyxHQUFHLENBQUgsR0FBT0YsRUFBRSxDQUFDMU8sS0FBSCxHQUFXb1csT0FEekIsRUFFTnJXLENBQUMsR0FBRzZPLFNBQVMsR0FBRyxJQUFJd0gsT0FBUCxHQUFpQixDQUZ4QixNQUdBLElBQUl4YixNQUFNLEtBQUssTUFBZixFQUNOa0YsQ0FBQyxHQUFHLENBREUsRUFFTkMsQ0FBQyxHQUFHNk8sU0FBUyxHQUFHLENBQUgsR0FBT0YsRUFBRSxDQUFDd1QsT0FGakIsTUFHQSxJQUFJdG5CLE1BQU0sS0FBSyxLQUFmLEVBQ05rRixDQUFDLEdBQUc0TyxFQUFFLENBQUN5VCxRQUFILEdBQWMsQ0FEWixFQUVOcGlCLENBQUMsR0FBRzJPLEVBQUUsQ0FBQzBULFNBQUgsR0FBZSxDQUZiLE1BR0EsSUFBSXhuQixNQUFNLEtBQUssT0FBZixFQUF3QjtBQUM5QixZQUFNdUUsSUFBSSxHQUFHLENBQUN1UCxFQUFFLENBQUN5VCxRQUFILEdBQWN6VCxFQUFFLENBQUMwVCxTQUFsQixJQUErQixDQUE1QztBQUVBdGlCLFNBQUMsR0FBR3BELElBQUksQ0FBQ2tOLEdBQUwsQ0FBU3pLLElBQVQsRUFBZSxDQUFmLElBQW9CLENBSE0sRUFJOUJZLENBQUMsR0FBR1osSUFBSSxHQUFHLENBQVAsR0FBV3pDLElBQUksQ0FBQ210QixHQUFMLENBQVMxcUIsSUFBVCxDQUFYLEdBQTRCdkMsV0FBVyxDQUFDOFIsRUFBRSxDQUFDNFMsTUFBSCxDQUFVdlQsR0FBWCxDQUpiO0FBSzlCO0FBRUQsaUNBQW9Cak8sQ0FBcEIsZUFBMEJDLENBQTFCO0FBQ0E7OzttQ0FFY2hELEMsRUFBRztBQUNqQixhQUFPLEtBQUsrc0IsWUFBTCxDQUFrQi9zQixDQUFsQixNQUF5QixJQUF6QixJQUNOLEtBQUtvZSxhQUFMLENBQW1CcGUsQ0FBQyxDQUFDZ1MsRUFBckIsQ0FETSxHQUNxQixHQURyQixHQUMyQixHQURsQztBQUVBOzs7NENBRXVCaFMsQyxFQUFHO0FBQzFCLGFBQU8sS0FBSytzQixZQUFMLENBQWtCL3NCLENBQWxCLE1BQXlCLElBQXpCLElBQ04sS0FBS29lLGFBQUwsQ0FBbUJwZSxDQUFDLENBQUNnUyxFQUFyQixDQURNLEdBQ3FCLEtBQUtnYixnQkFBTCxDQUFzQmh0QixDQUF0QixDQURyQixHQUNnRCxHQUR2RDtBQUVBOzs7cUNBRWdCQSxDLEVBQUc7QUFDbkIsVUFBTWthLE9BQU8sR0FBRyxLQUFLM1AsTUFBTCxDQUFZMGlCLFVBQVosR0FBeUIsR0FBekIsR0FBK0IsR0FBL0M7QUFFQSxhQUFPL3RCLE9BQU8sQ0FBQyxLQUFLNnRCLFlBQUwsQ0FBa0Ivc0IsQ0FBbEIsQ0FBRCxDQUFQLEdBQ0wsS0FBS2t0QixZQUFMLENBQWtCbHRCLENBQWxCLEtBQXdCLEtBQUttdEIsYUFBTCxDQUFtQm50QixDQUFuQixDQUF4QixHQUNBLEtBREEsR0FDUWthLE9BRkgsR0FFYyxHQUZyQjtBQUdBOzs7cUNBRWdCO0FBQ2hCLGFBQU8sS0FBS2lPLFlBQUwsS0FBc0IsR0FBdEIsR0FBNEIsR0FBbkM7QUFDQTs7O3VCQUVFbm9CLEMsRUFBRztBQUNMLFVBQU0wQixFQUFFLEdBQUcsS0FBSzZJLE1BQUwsQ0FBWWlTLFlBQVosSUFBNEIsS0FBSzFILFNBQWpDLEdBQ1YsS0FBS0EsU0FESyxHQUNPLEtBQUsvUixDQUR2QjtBQUdBLGFBQU8vQyxDQUFDLEdBQUcwQixFQUFFLENBQUMxQixDQUFDLENBQUMrQyxDQUFILENBQUwsR0FBYSxJQUFyQjtBQUNBOzs7dUJBRUUvQyxDLEVBQUc7QUFBQSxVQUNDMlIsRUFBRSxHQUFHLElBRE47QUFBQSxVQUVEclEsS0FBSyxHQUFHcVEsRUFBRSxDQUFDb2IsWUFBSCxDQUFnQi9zQixDQUFoQixDQUZQO0FBVUwsYUFOSTJSLEVBQUUsQ0FBQ3FELFlBQUgsRUFNSixHQUxDMVQsS0FBSyxHQUFHcVEsRUFBRSxDQUFDc0QsU0FBSCxDQUFhM1QsS0FBYixDQUtULEdBSldxUSxFQUFFLENBQUN5QyxhQUFILE1BQXNCL1UsUUFBUSxDQUFDaUMsS0FBRCxDQUl6QyxLQUhDQSxLQUFLLEdBQUdxUSxFQUFFLENBQUNwSCxNQUFILENBQVU2aUIsaUJBQVYsQ0FBNEI5ekIsT0FBNUIsQ0FBb0NnSSxLQUFwQyxDQUdULEdBQU8zQixJQUFJLENBQUNDLElBQUwsQ0FBVStSLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS3pCLEtBQUwsQ0FBVixDQUFQO0FBQ0E7Ozt1QkFFRXRCLEMsRUFBRztBQUFBLFVBQ0MyUixFQUFFLEdBQUcsSUFETjtBQUFBLFVBRUMwYixNQUFNLEdBQUdydEIsQ0FBQyxDQUFDckcsSUFBRixJQUFVcUcsQ0FBQyxDQUFDckcsSUFBRixLQUFXLElBQXJCLEdBQTRCZ1ksRUFBRSxDQUFDb00sRUFBL0IsR0FBb0NwTSxFQUFFLENBQUMzTyxDQUZqRDtBQUlMLGFBQU9yRCxJQUFJLENBQUNDLElBQUwsQ0FBVXl0QixNQUFNLENBQUMxYixFQUFFLENBQUNvYixZQUFILENBQWdCL3NCLENBQWhCLENBQUQsQ0FBaEIsQ0FBUDtBQUNBOzs7MEJBRUtBLEMsRUFBRztBQUNSLGFBQU9BLENBQUMsR0FBRyxLQUFLNGYsSUFBTCxDQUFVNWYsQ0FBQyxDQUFDK0MsQ0FBWixDQUFILEdBQW9CLElBQTVCO0FBQ0E7OztrQ0FFYWdXLGMsRUFBZ0JnQixXLEVBQWE7QUFBQSxVQUV0QzdGLEtBRnNDO0FBQUEsVUFHdENvWixLQUhzQztBQUFBLFVBSXRDQyxNQUpzQztBQUFBLFVBQ3BDNWIsRUFBRSxHQUFHLElBRCtCO0FBTXRDb0ksaUJBQVcsSUFBSUEsV0FBVyxDQUFDbmdCLEtBTlcsR0FPekNzYSxLQUFLLEdBQUc2RixXQUFXLENBQUNuZ0IsS0FQcUIsSUFTekNzYSxLQUFLLEdBQUd2QyxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3BLLEtBQXpCLEVBVGlDLEVBV3JDbWYsY0FYcUMsS0FZeEM3RSxLQUFLLEdBQUdBLEtBQUssQ0FBQ3BJLFVBQU4sRUFaZ0MsSUFnQnRDaU8sV0FBVyxJQUFJQSxXQUFXLENBQUNqZ0IsS0FoQlcsR0FpQnpDd3pCLEtBQUssR0FBR3ZULFdBQVcsQ0FBQ2pnQixLQWpCcUIsSUFtQnpDd3pCLEtBQUssR0FBRzNiLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDbEssS0FBekIsRUFuQmlDLEVBcUJyQ2lmLGNBckJxQyxLQXNCeEN1VSxLQUFLLEdBQUdBLEtBQUssQ0FBQ3hoQixVQUFOLEVBdEJnQyxJQTBCdENpTyxXQUFXLElBQUlBLFdBQVcsQ0FBQ2hnQixNQTFCVyxHQTJCekN3ekIsTUFBTSxHQUFHeFQsV0FBVyxDQUFDaGdCLE1BM0JvQixJQTZCekN3ekIsTUFBTSxHQUFHNWIsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUNqSyxNQUF6QixFQTdCZ0MsRUErQnJDZ2YsY0EvQnFDLEtBZ0N4Q3dVLE1BQU0sR0FBR0EsTUFBTSxDQUFDemhCLFVBQVAsRUFoQytCLElBb0MxQyxDQUFDaU4sY0FBYyxHQUFHcEgsRUFBRSxDQUFDL04sSUFBSCxDQUFRa0ksVUFBUixFQUFILEdBQTBCNkYsRUFBRSxDQUFDL04sSUFBNUMsRUFDRWpCLElBREYsQ0FDTyxXQURQLEVBQ29CZ1AsRUFBRSxDQUFDaUIsWUFBSCxDQUFnQixNQUFoQixDQURwQixDQXBDMEMsRUF1QzFDc0IsS0FBSyxDQUFDdlIsSUFBTixDQUFXLFdBQVgsRUFBd0JnUCxFQUFFLENBQUNpQixZQUFILENBQWdCLEdBQWhCLENBQXhCLENBdkMwQyxFQXdDMUMwYSxLQUFLLENBQUMzcUIsSUFBTixDQUFXLFdBQVgsRUFBd0JnUCxFQUFFLENBQUNpQixZQUFILENBQWdCLEdBQWhCLENBQXhCLENBeEMwQyxFQXlDMUMyYSxNQUFNLENBQUM1cUIsSUFBUCxDQUFZLFdBQVosRUFBeUJnUCxFQUFFLENBQUNpQixZQUFILENBQWdCLElBQWhCLENBQXpCLENBekMwQyxFQTJDMUNqQixFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3ZKLFNBQXpCLEdBQ0VrSSxJQURGLENBQ08sV0FEUCxFQUNvQmdQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsS0FBaEIsQ0FEcEIsQ0EzQzBDO0FBNkMxQzs7O2lDQUVZbUcsYyxFQUFnQmdCLFcsRUFBYTtBQUN6QyxVQUFNcEksRUFBRSxHQUFHLElBQVg7QUFFQUEsUUFBRSxDQUFDNmIsYUFBSCxDQUFpQnpVLGNBQWpCLEVBQWlDZ0IsV0FBakMsQ0FIeUMsRUFLekNwSSxFQUFFLENBQUNwSCxNQUFILENBQVU2VyxhQUFWLElBQ0N6UCxFQUFFLENBQUM4YixnQkFBSCxDQUFvQjFVLGNBQXBCLEVBQW9DZ0IsV0FBcEMsQ0FOd0MsRUFRekNwSSxFQUFFLENBQUNzUixNQUFILElBQWF0UixFQUFFLENBQUMrYixlQUFILENBQW1CM1UsY0FBbkIsQ0FSNEI7QUFTekM7OztvQ0FFZTtBQUFBLFVBQ1RwSCxFQUFFLEdBQUcsSUFESTtBQUFBLFVBRVR2WCxLQUFLLEdBQUd1WCxFQUFFLENBQUMwRyxHQUFILENBQU90VSxNQUFQLFlBQWtCQyxjQUFLLENBQUM1SixLQUF4QixlQUZDO0FBQUEsVUFHVHV6QixTQUFTLEdBQUc7QUFBQzFxQixhQUFLLEVBQUUsQ0FBUjtBQUFXQyxjQUFNLEVBQUU7QUFBbkIsT0FISDtBQUtYOUksV0FBSyxDQUFDMlIsSUFBTixFQUxXLEtBTWQ0aEIsU0FBUyxDQUFDMXFCLEtBQVYsR0FBa0IsQ0FBQzdJLEtBQUssQ0FBQ3VJLElBQU4sQ0FBVyxPQUFYLENBTkwsRUFPZGdyQixTQUFTLENBQUN6cUIsTUFBVixHQUFtQixDQUFDOUksS0FBSyxDQUFDdUksSUFBTixDQUFXLFFBQVgsQ0FQTixHQVVmZ1AsRUFBRSxDQUFDMEcsR0FBSCxDQUNFMVYsSUFERixDQUNPLE9BRFAsRUFDZ0JnUCxFQUFFLENBQUNzVCxZQURuQixFQUVFdGlCLElBRkYsQ0FFTyxRQUZQLEVBRWlCZ1AsRUFBRSxDQUFDbVQsYUFGcEIsQ0FWZSxFQWNmblQsRUFBRSxDQUFDMEcsR0FBSCxDQUFPN0osU0FBUCxDQUFpQixZQUFLbUQsRUFBRSxDQUFDK08sTUFBUixjQUFzQi9PLEVBQUUsQ0FBQ3FQLGFBQXpCLEVBQWpCLEVBQ0VqZCxNQURGLENBQ1MsTUFEVCxFQUVFcEIsSUFGRixDQUVPLE9BRlAsRUFFZ0JnUCxFQUFFLENBQUMxTyxLQUZuQixFQUdFTixJQUhGLENBR08sUUFIUCxFQUdpQmdQLEVBQUUsQ0FBQ3pPLE1BSHBCLENBZGUsRUFtQmZ5TyxFQUFFLENBQUMwRyxHQUFILENBQU90VSxNQUFQLFlBQWtCNE4sRUFBRSxDQUFDaVAsY0FBckIsR0FDRTdjLE1BREYsQ0FDUyxNQURULEVBRUVwQixJQUZGLENBRU8sR0FGUCxFQUVZZ1AsRUFBRSxDQUFDaWMsYUFBSCxDQUFpQnpnQixJQUFqQixDQUFzQndFLEVBQXRCLENBRlosRUFHRWhQLElBSEYsQ0FHTyxHQUhQLEVBR1lnUCxFQUFFLENBQUNrYyxhQUFILENBQWlCMWdCLElBQWpCLENBQXNCd0UsRUFBdEIsQ0FIWixFQUlFaFAsSUFKRixDQUlPLE9BSlAsRUFJZ0JnUCxFQUFFLENBQUNtYyxpQkFBSCxDQUFxQjNnQixJQUFyQixDQUEwQndFLEVBQTFCLENBSmhCLEVBS0VoUCxJQUxGLENBS08sUUFMUCxFQUtpQmdQLEVBQUUsQ0FBQ29jLGtCQUFILENBQXNCNWdCLElBQXRCLENBQTJCd0UsRUFBM0IsQ0FMakIsQ0FuQmUsRUEwQmZBLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsWUFBa0I0TixFQUFFLENBQUNtUCxjQUFyQixHQUNFL2MsTUFERixDQUNTLE1BRFQsRUFFRXBCLElBRkYsQ0FFTyxHQUZQLEVBRVlnUCxFQUFFLENBQUNxYyxhQUFILENBQWlCN2dCLElBQWpCLENBQXNCd0UsRUFBdEIsQ0FGWixFQUdFaFAsSUFIRixDQUdPLEdBSFAsRUFHWWdQLEVBQUUsQ0FBQ3NjLGFBQUgsQ0FBaUI5Z0IsSUFBakIsQ0FBc0J3RSxFQUF0QixDQUhaLEVBSUVoUCxJQUpGLENBSU8sT0FKUCxFQUlnQmdQLEVBQUUsQ0FBQ3VjLGlCQUFILENBQXFCL2dCLElBQXJCLENBQTBCd0UsRUFBMUIsQ0FKaEIsRUFLRWhQLElBTEYsQ0FLTyxRQUxQLEVBS2lCZ1AsRUFBRSxDQUFDd2Msa0JBQUgsQ0FBc0JoaEIsSUFBdEIsQ0FBMkJ3RSxFQUEzQixDQUxqQixDQTFCZSxFQWlDZkEsRUFBRSxDQUFDMEcsR0FBSCxDQUFPdFUsTUFBUCxZQUFrQjROLEVBQUUsQ0FBQ3ljLGlCQUFyQixHQUNFcnFCLE1BREYsQ0FDUyxNQURULEVBRUVwQixJQUZGLENBRU8sT0FGUCxFQUVnQmdQLEVBQUUsQ0FBQzFPLEtBRm5CLEVBR0VOLElBSEYsQ0FHTyxRQUhQLEVBR2lCZ3JCLFNBQVMsQ0FBQ3pxQixNQUgzQixDQWpDZSxFQXNDZnlPLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsWUFBa0JDLGNBQUssQ0FBQ2xGLFFBQXhCLEdBQ0U2RCxJQURGLENBQ08sT0FEUCxFQUNnQmdQLEVBQUUsQ0FBQzFPLEtBRG5CLEVBRUVOLElBRkYsQ0FFTyxRQUZQLEVBRWlCZ1AsRUFBRSxDQUFDek8sTUFGcEIsQ0F0Q2U7QUF5Q2Y7OztvQ0FFZW1yQixXLEVBQWE7QUFDNUIsVUFBTTFjLEVBQUUsR0FBRyxJQUFYO0FBRUswYyxpQkFIdUIsS0FJdkIxYyxFQUFFLENBQUN1QyxLQUFILElBQVl2QyxFQUFFLENBQUNwSCxNQUFILENBQVV1SCxZQUpDLElBSzFCSCxFQUFFLENBQUN1QyxLQUFILENBQVM0RSxNQUFULENBQWdCbkgsRUFBRSxDQUFDYSxJQUFILENBQVF6UCxDQUF4QixDQUwwQixFQU0xQjRPLEVBQUUsQ0FBQ21FLFFBQUgsQ0FBWWdELE1BQVosQ0FBbUJuSCxFQUFFLENBQUNhLElBQUgsQ0FBUStMLElBQTNCLENBTjBCLEtBUTFCNU0sRUFBRSxDQUFDMmIsS0FBSCxJQUFZM2IsRUFBRSxDQUFDMmIsS0FBSCxDQUFTeFUsTUFBVCxDQUFnQm5ILEVBQUUsQ0FBQ2EsSUFBSCxDQUFReFAsQ0FBeEIsQ0FSYyxFQVMxQjJPLEVBQUUsQ0FBQzRiLE1BQUgsSUFBYTViLEVBQUUsQ0FBQzRiLE1BQUgsQ0FBVXpVLE1BQVYsQ0FBaUJuSCxFQUFFLENBQUNhLElBQUgsQ0FBUXVMLEVBQXpCLENBVGEsSUFjNUJwTSxFQUFFLENBQUMrTixZQUFILENBQWdCMk8sV0FBaEIsQ0FkNEIsRUFlNUIxYyxFQUFFLENBQUN3UCxhQUFILEVBZjRCLEVBZ0I1QnhQLEVBQUUsQ0FBQzJhLFlBQUgsSUFoQjRCO0FBaUI1Qjs7O2lDQUVZO0FBQUEsVUFDTjNhLEVBQUUsR0FBRyxJQURDO0FBQUEsVUFFTnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRk47QUFJWm9ILFFBQUUsQ0FBQzJjLGNBQUgsR0FBb0IzYyxFQUFFLENBQUM0YyxjQUFILEVBSlIsRUFLWjVjLEVBQUUsQ0FBQzJjLGNBQUgsQ0FBa0JoRSxHQUFsQixDQUFzQi9mLE1BQU0sQ0FBQ2lrQixRQUFQLENBQWdCcmhCLElBQWhCLENBQXFCd0UsRUFBckIsQ0FBdEIsQ0FMWSxFQU9ScEgsTUFBTSxDQUFDa2tCLFdBUEMsSUFRWDljLEVBQUUsQ0FBQzJjLGNBQUgsQ0FBa0JoRSxHQUFsQixDQUFzQixZQUFNO0FBQ3ZCM1ksVUFBRSxDQUFDK2MsYUFEb0IsS0FFMUI3MUIsTUFBTSxDQUFDODFCLFlBQVAsQ0FBb0JoZCxFQUFFLENBQUMrYyxhQUF2QixDQUYwQixFQUcxQi9jLEVBQUUsQ0FBQytjLGFBQUgsR0FBbUIsSUFITyxHQU0zQi9jLEVBQUUsQ0FBQytjLGFBQUgsR0FBbUI3MUIsTUFBTSxDQUFDKzFCLFVBQVAsQ0FBa0IsWUFBTTtBQUMxQ2pkLFlBQUUsQ0FBQ2lELEdBQUgsQ0FBT2lhLEtBQVAsUUFEMEM7QUFFMUMsU0FGa0IsRUFFaEIsR0FGZ0IsQ0FOUTtBQVMzQixPQVRELENBUlcsRUFvQlpsZCxFQUFFLENBQUMyYyxjQUFILENBQWtCaEUsR0FBbEIsQ0FBc0IvZixNQUFNLENBQUN1a0IsU0FBUCxDQUFpQjNoQixJQUFqQixDQUFzQndFLEVBQXRCLENBQXRCLENBcEJZLEVBdUJaOVksTUFBTSxDQUFDazJCLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDcGQsRUFBRSxDQUFDMmMsY0FBckMsQ0F2Qlk7QUF3Qlo7OztxQ0FFZ0I7QUFHaEIsZUFBU1UsbUJBQVQsR0FBK0I7QUFDOUJDLHVCQUFlLENBQUN6dEIsT0FBaEIsQ0FBd0IsVUFBQTB0QixDQUFDO0FBQUEsaUJBQUlBLENBQUMsRUFBTDtBQUFBLFNBQXpCLENBRDhCO0FBRTlCOztBQUpELFVBQU1ELGVBQWUsR0FBRyxFQUF4QjtBQVNBLGFBSEFELG1CQUFtQixDQUFDMUUsR0FBcEIsR0FBMEIsVUFBQTRFLENBQUM7QUFBQSxlQUFJRCxlQUFlLENBQUNqb0IsSUFBaEIsQ0FBcUJrb0IsQ0FBckIsQ0FBSjtBQUFBLE9BRzNCLEVBRkFGLG1CQUFtQixDQUFDOWYsTUFBcEIsR0FBNkIsVUFBQWdnQixDQUFDO0FBQUEsZUFBSUQsZUFBZSxDQUFDRSxNQUFoQixDQUF1QkYsZUFBZSxDQUFDMzFCLE9BQWhCLENBQXdCNDFCLENBQXhCLENBQXZCLEVBQW1ELENBQW5ELENBQUo7QUFBQSxPQUU5QixFQUFPRixtQkFBUDtBQUNBOzs7MkJBRU1sakIsVSxFQUFZc2pCLFEsRUFBVTtBQUM1QixVQUFJdHZCLENBQUMsR0FBRyxDQUFSO0FBRUFnTSxnQkFBVSxDQUNSbUMsSUFERixDQUNPO0FBQUEsZUFBTSxFQUFFbk8sQ0FBUjtBQUFBLE9BRFAsRUFFRXFnQixFQUZGLENBRUssS0FGTCxFQUVZLFlBQWtCO0FBQUEsMENBQU52ZSxJQUFNLCtDQUFOQSxJQUFNOztBQUMzQixVQUFFOUIsQ0FBSCxJQUFRc3ZCLFFBQVEsQ0FBQzlZLEtBQVQsT0FBQThZLFFBQVEsR0FBTyxJQUFQLFNBQWdCeHRCLElBQWhCLEVBRFk7QUFFNUIsT0FKRixDQUg0QjtBQVE1Qjs7O21DQUVjO0FBQUEsVUFDVnl0QixpQkFBaUIsR0FBRyxFQURWO0FBQUEsVUFFUkgsQ0FBQyxHQUFHLFVBQVNwakIsVUFBVCxFQUFxQnNqQixRQUFyQixFQUErQjtBQUd4QyxpQkFBU0UsSUFBVCxHQUFnQjtBQUNmLGNBQUlDLElBQUksR0FBRyxDQUFYO0FBRUFGLDJCQUFpQixDQUFDN3RCLE9BQWxCLENBQTBCLFVBQUE4RixDQUFDLEVBQUk7QUFDOUIsZ0JBQUlBLENBQUMsQ0FBQ3hMLEtBQUYsRUFBSixFQUVDLFlBREF5ekIsSUFBSSxFQUNKOztBQUdELGdCQUFJO0FBQ0hqb0IsZUFBQyxDQUFDd0UsVUFBRixFQURHO0FBRUgsYUFGRCxDQUVFLE9BQU8xRyxDQUFQLEVBQVU7QUFDWG1xQixrQkFBSSxFQURPO0FBRVg7QUFDRCxXQVhELENBSGUsRUFnQmZDLEtBQUssSUFBSWIsWUFBWSxDQUFDYSxLQUFELENBaEJOLEVBa0JYRCxJQUFJLEtBQUtGLGlCQUFpQixDQUFDbHZCLE1BbEJoQixHQW1CZGl2QixRQUFRLElBQUlBLFFBQVEsRUFuQk4sR0FxQmRJLEtBQUssR0FBR1osVUFBVSxDQUFDVSxJQUFELEVBQU8sRUFBUCxDQXJCSjtBQXVCZjs7QUF6QkQsWUFBSUUsS0FBSjtBQTJCQUYsWUFBSSxFQTVCb0M7QUE2QnhDLE9BL0JhOztBQXVDZCxhQU5BSixDQUFDLENBQUM1RSxHQUFGLEdBQVEsVUFBU3hlLFVBQVQsRUFBcUI7QUFDNUJyTCxlQUFPLENBQUNxTCxVQUFELENBQVAsR0FDRXVqQixpQkFBaUIsR0FBR0EsaUJBQWlCLENBQUNscUIsTUFBbEIsQ0FBeUIyRyxVQUF6QixDQUR0QixHQUVDdWpCLGlCQUFpQixDQUFDcm9CLElBQWxCLENBQXVCOEUsVUFBdkIsQ0FIMkI7QUFJNUIsT0FFRCxFQUFPb2pCLENBQVA7QUFDQTs7OzhCQUVTalosSSxFQUFNO0FBQUEsVUFFWHdaLFVBRlc7QUFBQSxVQUNUOWQsRUFBRSxHQUFHLElBREk7QUFpQmYsYUFiSXNFLElBQUksWUFBWTdWLElBYXBCLEdBWkNxdkIsVUFBVSxHQUFHeFosSUFZZCxHQVhXNVcsUUFBUSxDQUFDNFcsSUFBRCxDQVduQixHQVZDd1osVUFBVSxHQUFHOWQsRUFBRSxDQUFDcUssY0FBSCxDQUFrQnJLLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVW1sQixZQUE1QixFQUEwQ3paLElBQTFDLENBVWQsR0FUVzNXLFFBQVEsQ0FBQzJXLElBQUQsQ0FBUixJQUFrQixDQUFDMVYsS0FBSyxDQUFDMFYsSUFBRCxDQVNuQyxLQVJDd1osVUFBVSxHQUFHLElBQUlydkIsSUFBSixDQUFTLENBQUM2VixJQUFWLENBUWQsSUFMSSxDQUFDd1osVUFBRCxJQUFlbHZCLEtBQUssQ0FBQyxDQUFDa3ZCLFVBQUYsQ0FLeEIsS0FKQ3BxQixPQUFPLElBQUlBLE9BQU8sQ0FBQ0MsS0FBbkIsSUFDQ0QsT0FBTyxDQUFDQyxLQUFSLDhCQUFvQzJRLElBQXBDLHNCQUdGLEVBQU93WixVQUFQO0FBQ0E7OzttQ0FFYztBQUNkLGFBQU8sQ0FBQ3YyQixRQUFRLENBQUN5MkIsTUFBakI7QUFDQTs7O3VDQUVrQjtBQUFBLFVBQ1poZSxFQUFFLEdBQUcsSUFETztBQUFBLFVBRVpwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZBO0FBQUEsVUFHWnFsQixRQUFRLEdBQUdybEIsTUFBTSxDQUFDc2xCLDJCQUFQLEtBQXVDMTJCLG1CQUExQyxJQUFzRCxpQkFBaUJOLE1BSG5FO0FBQUEsVUFJZGkzQixRQUFRLEtBSk07QUFZbEIsYUFOSXZsQixNQUFNLENBQUN3bEIsMkJBTVgsS0FIQ0QsUUFBUSxHQUFJLGlCQUFpQmozQixNQUFsQixJQUE4QkEsTUFBTSxDQUFDbTNCLGFBQVAsSUFBd0I5MkIsUUFBUSxZQUFZTCxNQUFNLENBQUNtM0IsYUFHN0YsR0FBUUosUUFBUSxJQUFJLE9BQWIsSUFBMEJFLFFBQVEsSUFBSSxPQUF0QyxJQUFrRCxJQUF6RDtBQUNBO0FBRUQ7Ozs7Ozs7O21DQUtlRyxLLEVBQWdCO0FBQUEsd0RBQU5ydUIsSUFBTSx3RUFBTkEsSUFBTTs7QUFDOUIsV0FBSzJJLE1BQUwsQ0FBWTJsQixPQUFaLENBQW9CMXVCLE9BQXBCLENBQTRCLFVBQUFyQyxDQUFDLEVBQUk7QUFDNUI4d0IsYUFBSyxLQUFLLGFBRGtCLEtBRS9COXdCLENBQUMsQ0FBQ3dTLEVBQUYsR0FBTyxNQUZ3QixFQUcvQixNQUFJLENBQUNpRCxHQUFMLENBQVNzYixPQUFULENBQWlCbHBCLElBQWpCLENBQXNCN0gsQ0FBdEIsQ0FIK0IsR0FNaENBLENBQUMsQ0FBQzh3QixLQUFELENBQUQsT0FBQTl3QixDQUFDLEVBQVd5QyxJQUFYLENBTitCO0FBT2hDLE9BUEQsQ0FEOEI7QUFTOUI7Ozs7Ozs7O0FDbHlDRjs7OztBQUlBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQThCcUJ1dUIsVyxHQUNwQixlQUFZNWxCLE1BQVosRUFBb0I7QUFBQTs7QUFDbkIsTUFBTW9ILEVBQUUsR0FBRyxJQUFJMEksMkJBQUosQ0FBa0IsSUFBbEIsQ0FBWDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7QUFaQSxPQUFLNlYsT0FBTCxHQUFlLEVBcEJJLEVBc0JuQixLQUFLRSxRQUFMLEdBQWdCemUsRUF0QkcsRUF3Qm5CQSxFQUFFLENBQUMwZSxVQUFILENBQWM5bEIsTUFBZCxDQXhCbUIsRUF5Qm5Cb0gsRUFBRSxDQUFDMmUsVUFBSCxDQUFjL2xCLE1BQWQsQ0F6Qm1CLEVBMEJuQm9ILEVBQUUsQ0FBQ2lRLElBQUgsRUExQm1CLEVBNEJuQixLQUFLMk8sQ0FBTCxHQUFTNWUsRUFBRSxDQUFDNmUsZ0JBQUgsRUE1QlUsRUE4Qm5CN2UsRUFBRSxDQUFDOGUsU0FBSCxDQUFhbG1CLE1BQWIsQ0E5Qm1CLEVBaUNsQixTQUFTbW1CLFFBQVQsQ0FBa0JodkIsRUFBbEIsRUFBc0I3RCxNQUF0QixFQUE4Qjh5QixPQUE5QixFQUF1QztBQUN2Q3R3QixVQUFNLENBQUNDLElBQVAsQ0FBWW9CLEVBQVosRUFBZ0JGLE9BQWhCLENBQXdCLFVBQUFOLEdBQUcsRUFBSTtBQUM5QnJELFlBQU0sQ0FBQ3FELEdBQUQsQ0FBTixHQUFjUSxFQUFFLENBQUNSLEdBQUQsQ0FBRixDQUFRaU0sSUFBUixDQUFhd2pCLE9BQWIsQ0FEZ0IsRUFHOUJ0d0IsTUFBTSxDQUFDQyxJQUFQLENBQVlvQixFQUFFLENBQUNSLEdBQUQsQ0FBZCxFQUFxQmYsTUFBckIsSUFDQ3V3QixRQUFRLENBQUNodkIsRUFBRSxDQUFDUixHQUFELENBQUgsRUFBVXJELE1BQU0sQ0FBQ3FELEdBQUQsQ0FBaEIsRUFBdUJ5dkIsT0FBdkIsQ0FKcUI7QUFLOUIsS0FMRCxDQUR1QztBQU92QyxHQVBELENBT0dSLEtBQUssQ0FBQ1MsU0FQVCxFQU9vQixJQVBwQixFQU8wQixJQVAxQixDQWpDbUI7QUF5Q25CLEM7Ozs7OztBQzdGRjs7Ozs7QUFJQTs7Ozs7O0lBTXFCQyxlLEdBQ3BCLG1CQUFjO0FBQ2Isa0RBQU87QUFDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkFuUyxVQUFNLEVBQUUsUUEzQkY7O0FBNkJOOzs7Ozs7Ozs7Ozs7OztBQWNBaUQsWUFBUSxJQTNDRjs7QUE2Q047Ozs7Ozs7Ozs7O0FBV0FyQixpQkFBYSxFQUFFMVosU0F4RFQ7O0FBMEROOzs7Ozs7Ozs7Ozs7Ozs7QUFlQWtxQixjQUFVLEVBQUVscUIsU0F6RU47QUEwRU5tcUIsZUFBVyxFQUFFbnFCLFNBMUVQOztBQTRFTjs7Ozs7Ozs7Ozs7Ozs7QUFjQTRULFNBQUssSUExRkM7O0FBNEZOOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQXdXLGdCQUFZLEVBQUVwcUIsU0E3R1I7QUE4R05xcUIsaUJBQWEsRUFBRXJxQixTQTlHVDtBQStHTnNxQixlQUFXLEVBQUV0cUIsU0EvR1A7QUFnSE51cUIsa0JBQWMsRUFBRXZxQixTQWhIVjs7QUFrSE47Ozs7Ozs7Ozs7O0FBV0E2bkIsZUFBVyxJQTdITDs7QUErSE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREFqUyxnQkFBWSxFQUFFNVYsU0FoTFI7QUFpTE53cUIsZUFBVyxFQUFFeHFCLFNBakxQO0FBa0xOb2IsbUJBQWUsSUFsTFQ7QUFtTE5rSCxnQkFBWSxJQW5MTjtBQW9MTm1JLGVBQVcsRUFBRXpxQixTQXBMUDtBQXFMTjBxQixvQkFBZ0IsRUFBRTFxQixTQXJMWjtBQXNMTjJxQixrQkFBYyxFQUFFM3FCLFNBdExWO0FBdUxONHFCLG9CQUFnQixJQXZMVjtBQXdMTkMsY0FBVSxFQUFFN3FCLFNBeExOO0FBeUxOOHFCLGNBQVUsRUFBRTlxQixTQXpMTjs7QUEyTE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkFxWix1QkFBbUIsSUExTmI7QUEyTk4wUix3QkFBb0IsSUEzTmQ7QUE0Tk45QiwrQkFBMkIsSUE1TnJCO0FBNk5ORSwrQkFBMkIsRUFBRSxFQTdOdkI7O0FBK05OOzs7Ozs7Ozs7OztBQVdBM1AsVUFBTSxFQUFFLGtCQUFNLENBQUUsQ0ExT1Y7O0FBNE9OOzs7Ozs7Ozs7OztBQVdBQyxTQUFLLEVBQUUsaUJBQU0sQ0FBRSxDQXZQVDs7QUF5UE47Ozs7Ozs7Ozs7O0FBV0FtTyxZQUFRLEVBQUUsb0JBQU0sQ0FBRSxDQXBRWjs7QUFzUU47Ozs7Ozs7Ozs7O0FBV0FNLGFBQVMsRUFBRSxxQkFBTSxDQUFFLENBalJiOztBQW1STjs7Ozs7Ozs7Ozs7QUFXQXBVLGdCQUFZLEVBQUU5VCxTQTlSUjs7QUFnU047Ozs7Ozs7Ozs7O0FBV0F1YixVQUFNLEVBQUUsa0JBQU0sQ0FBRSxDQTNTVjs7QUE2U047Ozs7Ozs7Ozs7O0FBV0F4SCxlQUFXLEVBQUUvVCxTQXhUUDs7QUEwVE47Ozs7Ozs7Ozs7O0FBV0FvakIsY0FBVSxFQUFFcGpCLFNBclVOOztBQXVVTjs7Ozs7Ozs7Ozs7O0FBWUErRCx1QkFBbUIsRUFBRSxHQW5WZjs7QUFxVk47Ozs7Ozs7Ozs7OztBQVlBK2hCLFVBQU0sRUFBRTlsQixTQWpXRjs7QUFtV047Ozs7Ozs7Ozs7Ozs7OztBQWVBK2xCLFdBQU8sRUFBRSxFQWxYSDs7QUFvWE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBK0MsZ0JBQVksRUFBRSxVQTNZUjs7QUE2WU47Ozs7Ozs7Ozs7O0FBV0F6VCxtQkFBZSxJQXhaVDs7QUEwWk47Ozs7Ozs7Ozs7O0FBV0EyVixjQUFVLElBcmFKOztBQXVhTjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQUMsb0JBQWdCLEVBQUUsMEJBQUE3ZixFQUFFO0FBQUEsYUFBSUEsRUFBSjtBQUFBLEtBMWJkOztBQTRiTjs7Ozs7Ozs7Ozs7Ozs7O0FBZUE4ZixjQUFVLEVBQUUsRUEzY047O0FBNmNOOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsZ0JBQVksRUFBRSxFQTVkUjs7QUE4ZE47Ozs7Ozs7Ozs7Ozs7O0FBY0FDLGVBQVcsRUFBRSxFQTVlUDs7QUE4ZU47Ozs7Ozs7Ozs7Ozs7O0FBY0FqYyxhQUFTLEVBQUUsRUE1Zkw7O0FBOGZOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBa2MsYUFBUyxFQUFFcnJCLFNBMWhCTDs7QUE0aEJOOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBc3JCLGNBQVUsRUFBRSxFQTVpQk47O0FBOGlCTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyREFuUCxlQUFXLEVBQUUsRUF6bUJQO0FBMG1CTm9QLHNCQUFrQixFQUFFdnJCLFNBMW1CZDtBQTJtQk53ckIsd0JBQW9CLEVBQUUsRUEzbUJoQjs7QUE2bUJOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQUMsY0FBVSxFQUFFLE1BbnBCTjs7QUFxcEJOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBQyxnQkFBWSxFQUFFLEVBanJCUjs7QUFtckJOOzs7Ozs7Ozs7Ozs7O0FBYUFDLGNBQVUsRUFBRTNyQixTQWhzQk47O0FBa3NCTjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE0ckIsZUFBVyxFQUFFLEVBbnRCUDs7QUFxdEJOOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBdFQsYUFBUyxJQXJ1Qkg7O0FBdXVCTjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBRCxlQUFXLEVBQUVyWSxTQXp2QlA7O0FBMnZCTjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBNnJCLHdCQUFvQixJQTd3QmQ7O0FBOHdCTjs7Ozs7Ozs7Ozs7Ozs7O0FBZUFDLDBCQUFzQixJQTd4QmhCOztBQSt4Qk47Ozs7Ozs7Ozs7Ozs7O0FBY0FDLDBCQUFzQixJQTd5QmhCOztBQSt5Qk47Ozs7Ozs7Ozs7Ozs7O0FBY0FDLCtCQUEyQixFQUFFO0FBQUE7QUFBQSxLQTd6QnZCOztBQSt6Qk47Ozs7Ozs7Ozs7Ozs7O0FBY0FDLDJCQUF1QixJQTcwQmpCOztBQSswQk47Ozs7Ozs7Ozs7Ozs7OztBQWVBQyw0QkFBd0IsSUE5MUJsQjs7QUFnMkJOOzs7Ozs7Ozs7Ozs7QUFZQUMsZ0JBQVksRUFBRSx3QkFBTSxDQUFFLENBNTJCaEI7O0FBODJCTjs7Ozs7Ozs7Ozs7O0FBWUFDLGVBQVcsRUFBRSx1QkFBTSxDQUFFLENBMTNCZjs7QUE0M0JOOzs7Ozs7Ozs7Ozs7QUFZQUMsY0FBVSxFQUFFLHNCQUFNLENBQUUsQ0F4NEJkOztBQTA0Qk47Ozs7Ozs7Ozs7Ozs7OztBQWVBQyxtQkFBZSxFQUFFLDJCQUFNLENBQUUsQ0F6NUJuQjs7QUEyNUJOOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMscUJBQWlCLEVBQUUsNkJBQU0sQ0FBRSxDQTE2QnJCOztBQTQ2Qk47Ozs7Ozs7Ozs7Ozs7O0FBY0F6USxjQUFVLEVBQUU5YixTQTE3Qk47O0FBNDdCTjs7Ozs7Ozs7Ozs7Ozs7QUFjQStiLGNBQVUsRUFBRS9iLFNBMThCTjs7QUE0OEJOOzs7Ozs7Ozs7Ozs7QUFZQXdzQixZQUFRLEVBQUV4c0IsU0F4OUJKOztBQTA5Qk47Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBeXNCLGdCQUFZLEVBQUV6c0IsU0EzK0JSOztBQTYrQk47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEwc0IsYUFBUyxFQUFFMXNCLFNBbmdDTDs7QUFxZ0NOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0Eyc0IsYUFBUyxFQUFFM3NCLFNBNWlDTDs7QUE4aUNOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE0c0IsZ0JBQVksRUFBRTVzQixTQTVrQ1I7O0FBOGtDTjs7Ozs7Ozs7Ozs7QUFXQTZzQixpQkFBYSxFQUFFN3NCLFNBemxDVDs7QUEybENOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE4c0IsYUFBUyxFQUFFOXNCLFNBaG5DTDs7QUFrbkNOOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBNmEseUJBQXFCLEVBQUUsRUFsb0NqQjs7QUFvb0NOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0FMLGlCQUFhLElBcnFDUDtBQXNxQ05pRCx3QkFBb0IsRUFBRSxFQXRxQ2hCO0FBdXFDTkgsd0JBQW9CLElBdnFDZDtBQXdxQ055UCw2QkFBeUIsSUF4cUNuQjtBQXlxQ054UCxrQ0FBOEIsSUF6cUN4QjtBQTBxQ055UCxvQkFBZ0IsRUFBRSw0QkFBTSxDQUFFLENBMXFDcEI7O0FBNHFDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1FQUMsaUJBQWEsRUFBRSxFQS91Q1Q7QUFndkNONVMsZUFBVyxFQUFFcmEsU0FodkNQO0FBaXZDTmt0QixtQkFBZSxFQUFFLEVBanZDWDtBQWt2Q05DLGdCQUFZLEVBQUVudEIsU0FsdkNSOztBQW92Q047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9GQTRZLGVBQVcsSUF4MENMO0FBeTBDTkgsZUFBVyxJQXowQ0w7QUEwMENOMlUsMEJBQXNCLEVBQUVwdEIsU0ExMENsQjtBQTIwQ05xdEIsNEJBQXdCLEVBQUVydEIsU0EzMENwQjtBQTQwQ04yVyxtQkFBZSxFQUFFLFFBNTBDWDtBQTYwQ05HLHVCQUFtQixFQUFFLFVBNzBDZjtBQTgwQ053VyxrQkFBYyxFQUFFLEVBOTBDVjtBQSswQ05DLGtCQUFjLEVBQUUsRUEvMENWO0FBZzFDTkMscUJBQWlCLEVBQUV4dEIsU0FoMUNiO0FBaTFDTnl0Qix1QkFBbUIsRUFBRXp0QixTQWoxQ2Y7QUFrMUNOMHRCLHNCQUFrQixFQUFFMXRCLFNBbDFDZDtBQW0xQ04ydEIscUJBQWlCLEVBQUUzdEIsU0FuMUNiO0FBbzFDTjR0QixrQkFBYyxJQXAxQ1I7QUFxMUNOQyxrQkFBYyxFQUFFLENBcjFDVjtBQXMxQ05DLDBCQUFzQixFQUFFLEVBdDFDbEI7QUF1MUNOQywyQkFBdUIsRUFBRSxFQXYxQ25CO0FBdzFDTkMsbUJBQWUsSUF4MUNUOztBQTAxQ047Ozs7Ozs7Ozs7O0FBV0E5aUIsZ0JBQVksSUFyMkNOOztBQXUyQ047Ozs7Ozs7Ozs7O0FBV0EraUIsbUJBQWUsSUFsM0NUOztBQW8zQ047Ozs7Ozs7Ozs7Ozs7QUFhQTNXLGVBQVcsSUFqNENMOztBQW00Q047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBdU8sZUFBVyxFQUFFLFNBdjVDUDs7QUF5NUNOOzs7Ozs7Ozs7Ozs7OztBQWNBclEsb0JBQWdCLElBdjZDVjs7QUF5NkNOOzs7Ozs7Ozs7Ozs7OztBQWNBZ1IscUJBQWlCLEVBQUUsRUF2N0NiOztBQXk3Q047Ozs7Ozs7Ozs7Ozs7OztBQWVBbFksd0JBQW9CLElBeDhDZDs7QUEwOENOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkFjLHNCQUFrQixFQUFFcFAsU0FyK0NkOztBQXUrQ047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkF1Tyx1QkFBbUIsRUFBRSxFQTEvQ2Y7O0FBNC9DTjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFpVSwyQkFBdUIsRUFBRSxFQTdnRG5COztBQStnRE47Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkFoVSxxQkFBaUIsRUFBRXhPLFNBL2hEYjs7QUFpaUROOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBa3VCLG9CQUFnQixJQWpqRFY7O0FBbWpETjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBQyx5QkFBcUIsSUFya0RmOztBQXVrRE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBQyw2QkFBeUIsRUFBRTtBQUFDanlCLE9BQUMsRUFBRSxDQUFKO0FBQU9DLE9BQUMsRUFBRTtBQUFWLEtBM2xEckI7O0FBNmxETjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTJTLG1CQUFlLElBaG5EVDs7QUFrbkROOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBc1Qsc0JBQWtCLEVBQUUsSUFsb0RkOztBQW9vRE47Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBdlUsc0JBQWtCLEVBQUUsQ0FycERkOztBQXVwRE47Ozs7Ozs7Ozs7Ozs7OztBQWVBdWdCLHFCQUFpQixJQXRxRFg7O0FBd3FETjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQXpnQix5QkFBcUIsSUFwc0RmOztBQXVzRE47Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBQyxxQkFBaUIsRUFBRSxJQXh0RGI7O0FBMHRETjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQUUsdUJBQW1CLElBMXVEYjs7QUE0dUROOzs7Ozs7Ozs7Ozs7O0FBYUF1Z0IsY0FBVSxFQUFFdHVCLFNBenZETjs7QUEydkROOzs7Ozs7Ozs7Ozs7O0FBYUF1dUIsY0FBVSxFQUFFdnVCLFNBeHdETjs7QUEwd0ROOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQXd1QixrQkFBYyxFQUFFLEVBdnlEVjs7QUF5eUROOzs7Ozs7Ozs7Ozs7OztBQWNBdGQsaUJBQWEsRUFBRWxSLFNBdnpEVDs7QUF5ekROOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBeXVCLGlCQUFhLEVBQUV6dUIsU0FyMURUOztBQXUxRE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0EwdUIsZ0JBQVksRUFBRSxFQTUzRFI7O0FBODNETjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBQyxlQUFXLEVBQUUsRUEvNURQOztBQWk2RE47Ozs7Ozs7Ozs7QUFVQUMsbUJBQWUsSUEzNkRUOztBQTY2RE47Ozs7Ozs7Ozs7Ozs7QUFhQUMsZUFBVyxJQTE3REw7O0FBNDdETjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE3SSxlQUFXLEVBQUVobUIsU0E3OERQOztBQSs4RE47Ozs7Ozs7Ozs7Ozs7O0FBY0E4dUIsY0FBVSxFQUFFOXVCLFNBNzlETjs7QUErOUROOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSt1QixjQUFVLEVBQUUvdUIsU0E5K0ROOztBQWcvRE47Ozs7Ozs7Ozs7Ozs7O0FBY0FndkIsbUJBQWUsSUE5L0RUOztBQWdnRU47Ozs7Ozs7Ozs7Ozs7QUFhQUMsaUJBQWEsRUFBRWp2QixTQTdnRVQ7O0FBK2dFTjs7Ozs7Ozs7Ozs7OztBQWFBOEwsZ0JBQVksSUE1aEVOOztBQThoRU47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBb2pCLGdCQUFZLEVBQUUsRUFyakVSOztBQXVqRU47Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsc0JBQWtCLEVBQUVudkIsU0F6a0VkOztBQTJrRU47Ozs7Ozs7Ozs7Ozs7OztBQWVBb3ZCLHFCQUFpQixJQTFsRVg7O0FBNGxFTjs7Ozs7Ozs7Ozs7Ozs7O0FBZUFDLHNCQUFrQixFQUFFLElBM21FZDtBQTRtRU41Z0Isc0JBQWtCLEVBQUUsQ0E1bUVkOztBQThtRU47Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE2Z0IscUJBQWlCLEVBQUV0dkIsU0E5bkViOztBQWdvRU47Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkF1dkIsb0JBQWdCLElBaHBFVjs7QUFrcEVOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkFDLHlCQUFxQixJQXBxRWY7O0FBc3FFTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkFDLDZCQUF5QixFQUFFO0FBQUN0ekIsT0FBQyxFQUFFLENBQUo7QUFBT0MsT0FBQyxFQUFFO0FBQVYsS0ExckVyQjs7QUE0ckVOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQXdTLDBCQUFzQixFQUFFNU8sU0FsdEVsQjs7QUFvdEVOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTB2QixrQkFBYyxFQUFFLEVBeHVFVjs7QUEwdUVOOzs7Ozs7Ozs7Ozs7OztBQWNBQyxrQkFBYyxFQUFFM3ZCLFNBeHZFVjs7QUEwdkVOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E0dkIsZUFBVyxFQUFFLEVBM3hFUDs7QUE2eEVOOzs7Ozs7Ozs7Ozs7O0FBYUFwa0IsZ0JBQVksSUExeUVOOztBQTR5RU47Ozs7Ozs7Ozs7Ozs7QUFhQXFrQixlQUFXLEVBQUU3dkIsU0F6ekVQOztBQTJ6RU47Ozs7Ozs7Ozs7Ozs7QUFhQTh2QixlQUFXLEVBQUU5dkIsU0F4MEVQOztBQTAwRU47Ozs7Ozs7Ozs7Ozs7O0FBY0ErdkIsb0JBQWdCLElBeDFFVjs7QUEwMUVOOzs7Ozs7Ozs7Ozs7O0FBYUFDLGtCQUFjLEVBQUVod0IsU0F2MkVWOztBQXkyRU47Ozs7Ozs7Ozs7Ozs7QUFhQXFNLGlCQUFhLElBdDNFUDs7QUF3M0VOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTRqQixpQkFBYSxFQUFFLEVBLzRFVDs7QUFpNUVOOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQUMsdUJBQW1CLEVBQUVsd0IsU0FsNkVmOztBQW82RU47Ozs7Ozs7Ozs7Ozs7OztBQWVBbXdCLHNCQUFrQixJQW43RVo7O0FBcTdFTjs7Ozs7Ozs7Ozs7Ozs7O0FBZUFDLHVCQUFtQixFQUFFLElBcDhFZjs7QUFzOEVOOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBQyxzQkFBa0IsRUFBRXJ3QixTQXQ5RWQ7O0FBdzlFTjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQXN3QixxQkFBaUIsSUF4K0VYOztBQTArRU47Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQUMsMEJBQXNCLElBNS9FaEI7O0FBOC9FTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkFDLDhCQUEwQixFQUFFO0FBQUNyMEIsT0FBQyxFQUFFLENBQUo7QUFBT0MsT0FBQyxFQUFFO0FBQVYsS0FsaEZ0Qjs7QUFvaEZOOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQXEwQixtQkFBZSxFQUFFLEVBcmlGWDs7QUF1aUZOOzs7Ozs7Ozs7Ozs7OztBQWNBQyxtQkFBZSxFQUFFMXdCLFNBcmpGWDs7QUF1akZOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0Eyd0IsZ0JBQVksRUFBRSxFQXhsRlI7O0FBMGxGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0RBQyxlQUFXLElBMW9GTDtBQTJvRk5DLGVBQVcsRUFBRSxNQTNvRlA7QUE0b0ZOL0wsZ0JBQVksRUFBRSxFQTVvRlI7QUE2b0ZOZ00sZUFBVyxJQTdvRkw7QUE4b0ZOL0wsZ0JBQVksRUFBRSxFQTlvRlI7QUErb0ZOZ00sZ0JBQVksRUFBRSxFQS9vRlI7QUFncEZOQyxtQkFBZSxJQWhwRlQ7QUFpcEZOQyxjQUFVLElBanBGSjtBQWtwRk5DLG9CQUFnQixJQWxwRlY7O0FBb3BGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0VBN0ssY0FBVSxJQXR0Rko7QUF1dEZOOEssV0FBTyxFQUFFLEdBdnRGSDtBQXd0Rk5DLHFCQUFpQixFQUFFLEVBeHRGYjtBQXl0Rk5DLDhCQUEwQixJQXp0RnBCO0FBMHRGTkMsd0JBQW9CLEVBQUV0eEIsU0ExdEZoQjtBQTJ0Rk51eEIsaUJBQWEsRUFBRSxFQTN0RlQ7QUE0dEZOQyxrQkFBYyxFQUFFeHhCLFNBNXRGVjtBQTZ0Rk55eEIsY0FBVSxFQUFFLFFBN3RGTjs7QUErdEZOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBQyxvQkFBZ0IsSUFqd0ZWO0FBa3dGTkMsa0JBQWMsRUFBRSxNQWx3RlY7QUFtd0ZOQyxnQkFBWSxFQUFFNXhCLFNBbndGUjtBQW93Rk42eEIsY0FBVSxJQXB3Rko7O0FBc3dGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQUMsZUFBVyxFQUFFLENBaDBGUDtBQWkwRk5DLGNBQVUsRUFBRS94QixTQWowRk47QUFrMEZOZ3lCLG9CQUFnQixFQUFFaHlCLFNBbDBGWjtBQW0wRk5peUIsbUJBQWUsRUFBRSxDQW4wRlg7QUFvMEZOQyxhQUFTLEVBQUVseUIsU0FwMEZMO0FBcTBGTm15QixtQkFBZSxFQUFFLEVBcjBGWDtBQXMwRk5DLGlCQUFhLEVBQUVweUIsU0F0MEZUO0FBdTBGTnF5QixpQkFBYSxJQXYwRlA7O0FBeTBGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkFDLGVBQVcsRUFBRSxFQTcxRlA7O0FBKzFGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQUMsa0JBQWMsSUE3NEZSO0FBODRGTkMsY0FBVSxJQTk0Rko7QUErNEZOQyx1QkFBbUIsSUEvNEZiOztBQWk1Rk47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1REFDLGtCQUFjLElBeDhGUjtBQXk4Rk5DLG9CQUFnQixFQUFFM3lCLFNBejhGWjtBQTA4Rk40eUIsdUJBQW1CLEVBQUUsR0ExOEZmO0FBMjhGTkMsbUJBQWUsRUFBRTd5QixTQTM4Rlg7QUE0OEZOOHlCLGNBQVUsRUFBRSxFQTU4Rk47QUE2OEZOQyx1QkFBbUIsRUFBRSxFQTc4RmY7QUE4OEZOQyxtQkFBZSxFQUFFLENBOThGWDtBQSs4Rk5DLGdCQUFZLEVBQUUsQ0EvOEZSO0FBZzlGTkMsZUFBVyxFQUFFLENBaDlGUDs7QUFrOUZOOzs7Ozs7Ozs7Ozs7QUFZQTVKLFdBQU8sRUFBRSxFQTk5Rkg7O0FBZytGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBNUssb0JBQWdCLElBN2dHVjtBQThnR055VSxvQkFBZ0IsSUE5Z0dWO0FBK2dHTkMsc0JBQWtCLEVBQUVwekIsU0EvZ0dkO0FBZ2hHTnF6QixhQUFTLEVBQUUsQ0FoaEdMO0FBaWhHTkMsYUFBUyxFQUFFLEdBamhHTDtBQWtoR05DLHVCQUFtQixFQUFFLENBQUMsQ0FBRCxHQUFLeDZCLElBQUksQ0FBQ2lRLEVBQVYsR0FBZSxDQWxoRzlCO0FBbWhHTndxQix1QkFBbUIsRUFBRXh6QixTQW5oR2Y7QUFvaEdOeXpCLGVBQVcsRUFBRSxFQXBoR1A7QUFxaEdOQyxlQUFXLEVBQUUxekIsU0FyaEdQO0FBc2hHTjJ6QixlQUFXLEVBQUUzekIsU0F0aEdQO0FBdWhHTjR6QixnQkFBWSxFQUFFLEVBdmhHUjtBQXdoR05DLHlCQUFxQixFQUFFLEVBeGhHakI7O0FBMmhHTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBQyxvQkFBZ0IsSUFya0dWO0FBc2tHTkMsc0JBQWtCLEVBQUUvekIsU0F0a0dkO0FBdWtHTmcwQix5QkFBcUIsRUFBRSxHQXZrR2pCO0FBd2tHTkMscUJBQWlCLEVBQUVqMEIsU0F4a0diO0FBeWtHTmswQixlQUFXLEVBQUVsMEIsU0F6a0dQO0FBMGtHTm0wQixlQUFXLEVBQUUsRUExa0dQO0FBMmtHTkMsZ0JBQVksRUFBRSxFQTNrR1I7QUE0a0dOQyx5QkFBcUIsRUFBRSxFQTVrR2pCO0FBNmtHTkMsa0JBQWMsRUFBRSxDQTdrR1Y7O0FBK2tHTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBQyw2QkFBeUIsRUFBRSxVQWhuR3JCOztBQWtuR047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREFDLGtCQUFjLEVBQUV4MEIsU0FucUdWO0FBb3FHTnkwQix3QkFBb0IsSUFwcUdkO0FBcXFHTkMsd0JBQW9CLElBcnFHZDtBQXNxR05DLHFCQUFpQixFQUFFLENBdHFHYjtBQXVxR05DLG9CQUFnQixJQXZxR1Y7QUF3cUdOQywyQkFBdUIsRUFBRSxpQ0FBQTE0QixDQUFDO0FBQUEsYUFBS0EsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQUMsQ0FBQ3NULE9BQUYsQ0FBVSxDQUFWLENBQXZCO0FBQUEsS0F4cUdwQjtBQXlxR05xbEIseUJBQXFCLElBenFHZjtBQTBxR05DLG9CQUFnQixFQUFFLEdBMXFHWjtBQTJxR05DLDZCQUF5QixJQTNxR25COztBQTZxR047Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQXorQixXQUFPLEVBQUUsRUEvckdIOztBQWlzR047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1KQTArQixnQkFBWSxJQXAxR047QUFxMUdOQyxxQkFBaUIsSUFyMUdYO0FBczFHTkMsbUJBQWUsSUF0MUdUO0FBdTFHTkMsd0JBQW9CLEVBQUVwMUIsU0F2MUdoQjtBQXcxR05xMUIsdUJBQW1CLEVBQUVyMUIsU0F4MUdmO0FBeTFHTnMxQix3QkFBb0IsRUFBRXQxQixTQXoxR2hCO0FBMDFHTnUxQixvQkFBZ0IsRUFBRXYxQixTQTExR1o7QUEyMUdOdzFCLG9CQUFnQixFQUFFLEVBMzFHWjtBQTQxR043VSxxQkFBaUIsSUE1MUdYO0FBNjFHTjhVLGtCQUFjLEVBQUUsQ0E3MUdWO0FBODFHTkMseUJBQXFCLEVBQUU7QUFDdEJ0ckIsU0FBRyxFQUFFLEtBRGlCO0FBRXRCRyxVQUFJLEVBQUU7QUFGZ0IsS0E5MUdqQjtBQWsyR05vckIsa0JBQWMsSUFsMkdSO0FBbTJHTkMsdUJBQW1CLEVBQUUsRUFuMkdmO0FBbzJHTkMsa0JBQWMsRUFBRSwwQkFBTSxDQUFFLENBcDJHbEI7QUFxMkdOQyxrQkFBYyxFQUFFLDBCQUFNLENBQUUsQ0FyMkdsQjtBQXMyR05DLG1CQUFlLEVBQUUsMkJBQU0sQ0FBRSxDQXQyR25CO0FBdTJHTkMsb0JBQWdCLEVBQUUsNEJBQU0sQ0FBRSxDQXYyR3BCO0FBdzJHTkMsaUJBQWEsRUFBRSxJQXgyR1Q7O0FBMDJHTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQUMsY0FBVSxFQUFFbDJCLFNBdDRHTjtBQXU0R05tMkIsaUJBQWEsRUFBRTtBQUNkL3JCLFNBQUcsRUFBRSxDQURTO0FBRWRDLFdBQUssRUFBRSxDQUZPO0FBR2RDLFlBQU0sRUFBRSxDQUhNO0FBSWRDLFVBQUksRUFBRTtBQUpRLEtBdjRHVDtBQTY0R042ckIsa0JBQWMsRUFBRTtBQTc0R1YsR0FBUDtBQSs0R0EsQzs7OztBQzM1R0Y7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTE0QixNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQnRXLFlBRCtCLHdCQUNsQjtBQUNaLFdBQU8sSUFBSXVXLGVBQUosRUFBUDtBQUNBLEdBSDhCOztBQUsvQjs7Ozs7QUFLQVIsWUFWK0Isc0JBVXBCOWxCLE1BVm9CLEVBVVo7QUFBQSxRQUVkMU0sTUFGYztBQUFBLFFBR2R5QyxJQUhjO0FBQUEsUUFJZDI4QixJQUpjO0FBQUEsUUFDWkMsVUFBVSxHQUFHLEtBQUszeUIsTUFETjtBQUFBLFFBTVo0eUIsSUFBSSxHQUFHLFlBQU07QUFDbEIsVUFBTWo4QixHQUFHLEdBQUdaLElBQUksQ0FBQzJGLEtBQUwsRUFBWjtBQURrQixhQUdkL0UsR0FBRyxJQUFJckQsTUFBUCxJQUFpQm9DLFlBQVksQ0FBQ3BDLE1BQUQsQ0FBN0IsSUFBeUNxRCxHQUFHLElBQUlyRCxNQUhsQyxJQUlqQkEsTUFBTSxHQUFHQSxNQUFNLENBQUNxRCxHQUFELENBSkUsRUFLVmk4QixJQUFJLEVBTE0sSUFNTmo4QixHQU5NLEdBVVgwRixTQVZXLEdBT1YvSSxNQVBVO0FBV2xCLEtBakJpQjs7QUFtQmxCd0MsVUFBTSxDQUFDQyxJQUFQLENBQVk0OEIsVUFBWixFQUF3QjE3QixPQUF4QixDQUFnQyxVQUFBTixHQUFHLEVBQUk7QUFDdENyRCxZQUFNLEdBQUcwTSxNQUQ2QixFQUV0Q2pLLElBQUksR0FBR1ksR0FBRyxDQUFDcUIsS0FBSixDQUFVLEdBQVYsQ0FGK0IsRUFHdEMwNkIsSUFBSSxHQUFHRSxJQUFJLEVBSDJCLEVBS2xDMzlCLFNBQVMsQ0FBQ3k5QixJQUFELENBTHlCLEtBTXJDQyxVQUFVLENBQUNoOEIsR0FBRCxDQUFWLEdBQWtCKzdCLElBTm1CO0FBUXRDLEtBUkQsQ0FuQmtCO0FBNEJsQjtBQXRDOEIsQ0FBMUIsQzs7QUNSTjs7OztBQUlBO0FBSUE7QUFDQTtBQUVBMzRCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9Cd00sVUFEK0Isb0JBQ3RCOTVCLEdBRHNCLEVBQ2pCdUosR0FEaUIsRUFDWnd3QixhQURZLEVBQ0c7QUFDakMsV0FBTyxDQUFDQSxhQUFhLEdBQ3BCQyx3RkFBVyxFQURTLEdBQ0o3eUIsMEZBQWEsRUFEdkIsRUFFTEksS0FGSyxDQUVDLENBQUN2SCxHQUFELEVBQU11SixHQUFOLENBRkQsQ0FBUDtBQUdBLEdBTDhCOztBQU8vQjs7Ozs7Ozs7O0FBU0Ewd0IsTUFoQitCLGdCQWdCMUJqNkIsR0FoQjBCLEVBZ0JyQnVKLEdBaEJxQixFQWdCaEIzQixNQWhCZ0IsRUFnQlJzeUIsTUFoQlEsRUFnQkE7QUFBQSxRQUN4QjdyQixFQUFFLEdBQUcsSUFEbUI7QUFBQSxRQUV4Qm5ILEtBQUssR0FBR21ILEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0JuRCxFQUFFLENBQUN5ckIsUUFBSCxDQUFZOTVCLEdBQVosRUFBaUJ1SixHQUFqQixFQUFzQjhFLEVBQUUsQ0FBQ3FELFlBQUgsRUFBdEIsQ0FGQTtBQUk5QixXQUFPckQsRUFBRSxDQUFDOHJCLGtCQUFILENBQ052eUIsTUFBTSxHQUFHVixLQUFLLENBQUNVLE1BQU4sQ0FBYUEsTUFBYixDQUFILEdBQTBCVixLQUQxQixFQUVOZ3pCLE1BRk0sQ0FBUDtBQUlBLEdBeEI4Qjs7QUEwQi9COzs7Ozs7OztBQVFBRSxNQWxDK0IsZ0JBa0MxQnA2QixHQWxDMEIsRUFrQ3JCdUosR0FsQ3FCLEVBa0NoQjNCLE1BbENnQixFQWtDUjtBQUN0QixRQUFNVixLQUFLLEdBQUcsS0FBSzR5QixRQUFMLENBQWM5NUIsR0FBZCxFQUFtQnVKLEdBQW5CLEVBQXdCLEtBQUswSSxhQUFMLEVBQXhCLENBQWQ7QUFJQSxXQUZBckssTUFBTSxJQUFJVixLQUFLLENBQUNVLE1BQU4sQ0FBYUEsTUFBYixDQUVWLEVBQU9WLEtBQVA7QUFDQSxHQXhDOEI7O0FBMEMvQjs7Ozs7OztBQU9BaXpCLG9CQWpEK0IsOEJBaURaRSxVQWpEWSxFQWlEQUMsV0FqREEsRUFpRGE7QUFBQSxRQUNyQ2pzQixFQUFFLEdBQUcsSUFEZ0M7QUFBQSxRQUVyQzZyQixNQUFNLEdBQUdJLFdBQVcsSUFBSztBQUFBLGFBQU1qc0IsRUFBRSxDQUFDdUMsS0FBSCxDQUFTakosVUFBVCxFQUFOO0FBQUEsS0FGWTtBQUFBLFFBR3JDVCxLQUFLLEdBQUcsVUFBU3hLLENBQVQsRUFBWTY5QixHQUFaLEVBQWlCO0FBQzlCLFVBQU0xK0IsQ0FBQyxHQUFHdytCLFVBQVUsQ0FBQzM5QixDQUFELENBQVYsR0FBZ0J3OUIsTUFBTSxFQUFoQztBQUVBLGFBQU9LLEdBQUcsR0FBRzErQixDQUFILEdBQU9RLElBQUksQ0FBQ0MsSUFBTCxDQUFVVCxDQUFWLENBQWpCO0FBQ0EsS0FQMEM7O0FBUzNDO0FBQ0EsU0FBSyxJQUFNK0IsR0FBWCxJQUFrQnk4QixVQUFsQixFQUNDbnpCLEtBQUssQ0FBQ3RKLEdBQUQsQ0FBTCxHQUFheThCLFVBQVUsQ0FBQ3o4QixHQUFELENBRHhCOztBQXdCQSxXQXBCQXNKLEtBQUssQ0FBQ2tTLFNBQU4sR0FBa0I7QUFBQSxhQUFNaWhCLFVBQVUsQ0FBQ3p5QixNQUFYLEVBQU47QUFBQSxLQW9CbEIsRUFuQkFWLEtBQUssQ0FBQ3N6QixRQUFOLEdBQWlCO0FBQUEsYUFBTUgsVUFBTjtBQUFBLEtBbUJqQixFQWhCSWhzQixFQUFFLENBQUN5QyxhQUFILEVBZ0JKLEtBZkM1SixLQUFLLENBQUNVLE1BQU4sR0FBZSxVQUFTNnlCLFdBQVQsRUFBc0I7QUFDcEMsVUFBSTd5QixNQUFNLEdBQUc2eUIsV0FBYjtBQURvQyxhQUcvQmh0QixTQUFTLENBQUM1USxNQUhxQixJQVNwQ3c5QixVQUFVLENBQUN6eUIsTUFBWCxDQUFrQkEsTUFBbEIsQ0FUb0MsRUFXN0JWLEtBWDZCLEtBSW5DVSxNQUFNLEdBQUcsS0FBS3dSLFNBQUwsRUFKMEIsRUFNNUIsQ0FBQ3hSLE1BQU0sQ0FBQyxDQUFELENBQVAsRUFBWUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZLENBQXhCLENBTjRCO0FBWXBDLEtBR0YsR0FBT1YsS0FBUDtBQUNBLEdBcEY4QjtBQXNGL0J3ekIsV0F0RitCLHFCQXNGckJoc0IsRUF0RnFCLEVBc0ZqQjtBQUNiLFdBQU8sS0FBS3JZLElBQUwsQ0FBVXNrQyxLQUFWLENBQWdCanNCLEVBQWhCLE1BQXdCLElBQXhCLEdBQStCLEtBQUsrTCxFQUFwQyxHQUF5QyxLQUFLL2EsQ0FBckQ7QUFDQSxHQXhGOEI7QUEwRi9CazdCLGNBMUYrQix3QkEwRmxCbHNCLEVBMUZrQixFQTBGZDtBQUNoQixXQUFPLEtBQUtyWSxJQUFMLENBQVVza0MsS0FBVixDQUFnQmpzQixFQUFoQixNQUF3QixJQUF4QixHQUErQixLQUFLZ08sS0FBcEMsR0FBNEMsS0FBS0QsSUFBeEQ7QUFDQSxHQTVGOEI7O0FBOEYvQjs7Ozs7QUFLQUwsY0FuRytCLHdCQW1HbEJ6RixNQW5Ha0IsRUFtR1k7QUFBQSxRQUF0QitPLGFBQXNCO0FBQUEsUUFDcENyWCxFQUFFLEdBQUcsSUFEK0I7QUFBQSxRQUVwQ3BILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRndCO0FBQUEsUUFHcENzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhpQjtBQU0xQ0gsTUFBRSxDQUFDd3NCLElBQUgsR0FBVXRzQixTQUFTLEdBQUcsQ0FBSCxHQUFPLENBTmdCLEVBTzFDRixFQUFFLENBQUN5c0IsSUFBSCxHQUFVdnNCLFNBQVMsR0FBR0YsRUFBRSxDQUFDek8sTUFBTixHQUFleU8sRUFBRSxDQUFDMU8sS0FQSyxFQVExQzBPLEVBQUUsQ0FBQzBzQixJQUFILEdBQVV4c0IsU0FBUyxHQUFHLENBQUgsR0FBT0YsRUFBRSxDQUFDek8sTUFSYSxFQVMxQ3lPLEVBQUUsQ0FBQzJzQixJQUFILEdBQVV6c0IsU0FBUyxHQUFHRixFQUFFLENBQUMxTyxLQUFOLEdBQWMsQ0FUUyxFQVUxQzBPLEVBQUUsQ0FBQzRzQixPQUFILEdBQWE1c0IsRUFBRSxDQUFDd3NCLElBVjBCLEVBVzFDeHNCLEVBQUUsQ0FBQzZzQixPQUFILEdBQWE3c0IsRUFBRSxDQUFDeXNCLElBWDBCLEVBWTFDenNCLEVBQUUsQ0FBQzhzQixPQUFILEdBQWE1c0IsU0FBUyxHQUFHLENBQUgsR0FBT0YsRUFBRSxDQUFDd1QsT0FaVSxFQWExQ3hULEVBQUUsQ0FBQytzQixPQUFILEdBQWE3c0IsU0FBUyxHQUFHRixFQUFFLENBQUN1VCxNQUFOLEdBQWUsQ0FiSztBQWUxQztBQUNBO0FBaEIwQyxRQWlCcEN5WixPQUFPLEdBQUczVixhQUFhLElBQUlyWCxFQUFFLENBQUM1TyxDQUFwQixJQUF5QjRPLEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzJaLFNBQUwsRUFqQkM7QUFBQSxRQWtCcENraUIsVUFBVSxHQUFHNVYsYUFBYSxJQUFJclgsRUFBRSxDQUFDa08sVUFsQkc7QUFnQzFDO0FBcUJBO0FBakNBbE8sTUFBRSxDQUFDNU8sQ0FBSCxHQUFPNE8sRUFBRSxDQUFDNHJCLElBQUgsQ0FBUTVyQixFQUFFLENBQUN3c0IsSUFBWCxFQUFpQnhzQixFQUFFLENBQUN5c0IsSUFBcEIsRUFBMEJPLE9BQTFCLEVBQW1DO0FBQUEsYUFBTWh0QixFQUFFLENBQUN1QyxLQUFILENBQVNqSixVQUFULEVBQU47QUFBQSxLQUFuQyxDQXBCbUMsRUFxQjFDMEcsRUFBRSxDQUFDaU8sSUFBSCxHQUFVak8sRUFBRSxDQUFDNHJCLElBQUgsQ0FBUTVyQixFQUFFLENBQUN3c0IsSUFBWCxFQUFpQnhzQixFQUFFLENBQUN5c0IsSUFBcEIsRUFBMEJRLFVBQTFCLEVBQXNDLFVBQUE1K0IsQ0FBQztBQUFBLGFBQUtBLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBUixHQUFZMlIsRUFBRSxDQUFDbUUsUUFBSCxDQUFZN0ssVUFBWixFQUFqQjtBQUFBLEtBQXZDLENBckJnQyxFQXVCMUMwRyxFQUFFLENBQUMwQyxlQUFILEdBQXFCMUMsRUFBRSxDQUFDaFksSUFBSCxDQUFRa2xDLGtCQUFSLEVBdkJxQixFQXdCMUNsdEIsRUFBRSxDQUFDMkMsZUFBSCxHQUFxQjNDLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUW1sQyxrQkFBUixFQXhCcUIsRUEwQjFDbnRCLEVBQUUsQ0FBQ3VDLEtBQUgsR0FBV3ZDLEVBQUUsQ0FBQ2hZLElBQUgsQ0FDVG9sQyxRQURTLENBQ0EsR0FEQSxFQUNLcHRCLEVBQUUsQ0FBQzVPLENBRFIsRUFDV3dILE1BQU0sQ0FBQzBxQixpQkFEbEIsRUFDcUNoYixNQURyQyxDQTFCK0IsRUE2QjFDdEksRUFBRSxDQUFDbUUsUUFBSCxHQUFjbkUsRUFBRSxDQUFDaFksSUFBSCxDQUNab2xDLFFBRFksQ0FDSCxNQURHLEVBQ0twdEIsRUFBRSxDQUFDaU8sSUFEUixFQUNjclYsTUFBTSxDQUFDMHFCLGlCQURyQixFQUN3Q2hiLE1BRHhDLENBN0I0QixFQWlDMUN0SSxFQUFFLENBQUMzTyxDQUFILEdBQU8yTyxFQUFFLENBQUMrckIsSUFBSCxDQUFRL3JCLEVBQUUsQ0FBQzBzQixJQUFYLEVBQWlCMXNCLEVBQUUsQ0FBQzJzQixJQUFwQixFQUEwQjNzQixFQUFFLENBQUMzTyxDQUFILEdBQU8yTyxFQUFFLENBQUMzTyxDQUFILENBQUtrSSxNQUFMLEVBQVAsR0FBdUJYLE1BQU0sQ0FBQ2dzQixjQUF4RCxDQWpDbUMsRUFrQzFDNWtCLEVBQUUsQ0FBQ29PLElBQUgsR0FBVXBPLEVBQUUsQ0FBQytyQixJQUFILENBQVEvckIsRUFBRSxDQUFDOHNCLE9BQVgsRUFBb0I5c0IsRUFBRSxDQUFDK3NCLE9BQXZCLEVBQWdDL3NCLEVBQUUsQ0FBQ29PLElBQUgsR0FBVXBPLEVBQUUsQ0FBQ29PLElBQUgsQ0FBUTdVLE1BQVIsRUFBVixHQUE2QlgsTUFBTSxDQUFDZ3NCLGNBQXBFLENBbENnQyxFQW9DMUM1a0IsRUFBRSxDQUFDcXRCLGVBQUgsR0FBcUJydEIsRUFBRSxDQUFDaFksSUFBSCxDQUFRc2xDLGtCQUFSLEVBcENxQixFQXNDMUN0dEIsRUFBRSxDQUFDMmIsS0FBSCxHQUFXM2IsRUFBRSxDQUFDaFksSUFBSCxDQUNUdWxDLFFBRFMsQ0FDQSxHQURBLEVBQ0t2dEIsRUFBRSxDQUFDM08sQ0FEUixFQUNXdUgsTUFBTSxDQUFDeXJCLGlCQURsQixFQUNxQy9iLE1BRHJDLENBdEMrQixFQTBDdEMxUCxNQUFNLENBQUM2SCxZQTFDK0IsS0EyQ3pDVCxFQUFFLENBQUNvTSxFQUFILEdBQVFwTSxFQUFFLENBQUMrckIsSUFBSCxDQUFRL3JCLEVBQUUsQ0FBQzBzQixJQUFYLEVBQWlCMXNCLEVBQUUsQ0FBQzJzQixJQUFwQixFQUEwQjNzQixFQUFFLENBQUNvTSxFQUFILEdBQVFwTSxFQUFFLENBQUNvTSxFQUFILENBQU03UyxNQUFOLEVBQVIsR0FBeUJYLE1BQU0sQ0FBQytzQixlQUExRCxDQTNDaUMsRUE0Q3pDM2xCLEVBQUUsQ0FBQ3FPLEtBQUgsR0FBV3JPLEVBQUUsQ0FBQytyQixJQUFILENBQVEvckIsRUFBRSxDQUFDOHNCLE9BQVgsRUFBb0I5c0IsRUFBRSxDQUFDK3NCLE9BQXZCLEVBQ1Yvc0IsRUFBRSxDQUFDcU8sS0FBSCxHQUFXck8sRUFBRSxDQUFDcU8sS0FBSCxDQUFTOVUsTUFBVCxFQUFYLEdBQStCWCxNQUFNLENBQUMrc0IsZUFENUIsQ0E1QzhCLEVBK0N6QzNsQixFQUFFLENBQUN3dEIsZ0JBQUgsR0FBc0J4dEIsRUFBRSxDQUFDaFksSUFBSCxDQUFReWxDLG1CQUFSLEVBL0NtQixFQWlEekN6dEIsRUFBRSxDQUFDNGIsTUFBSCxHQUFZNWIsRUFBRSxDQUFDaFksSUFBSCxDQUNWdWxDLFFBRFUsQ0FDRCxJQURDLEVBQ0t2dEIsRUFBRSxDQUFDb00sRUFEUixFQUNZeFQsTUFBTSxDQUFDd3NCLGtCQURuQixFQUN1QzljLE1BRHZDLENBakQ2QixHQXNEMUN0SSxFQUFFLENBQUMwdEIsU0FBSCxJQUFnQjF0QixFQUFFLENBQUMwdEIsU0FBSCxFQXREMEI7QUF1RDFDO0FBMUo4QixDQUExQixDOzs7O0FDWE47Ozs7QUFJQTtBQUNBO0FBRUEvNkIsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0IwTyxrQkFEK0IsNEJBQ2Q3cEIsT0FEYyxFQUNML08sSUFESyxFQUNDO0FBQUEsUUFDekJpTCxFQUFFLEdBQUcsSUFEb0I7QUFBQSxRQUV6QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmE7QUFBQSxRQUd6QmcxQixLQUFLLEdBQUc3NEIsSUFBSSxLQUFLLEtBSFE7QUFBQSxRQUt6Qjg0QixVQUFVLEdBQUdqMUIsTUFBTSxDQUFDeW5CLFdBTEs7QUFBQSxRQU16QnlOLEdBQUcsR0FBRzl0QixFQUFFLENBQUN5TixRQUFILENBQVkzSixPQUFaLENBTm1CO0FBQUEsUUFPekJpcUIsRUFBRSxHQUFHL3RCLEVBQUUsQ0FBQ2d1QixrQkFBSCxDQUFzQmxxQixPQUF0QixDQVBvQjtBQWlEL0IsV0F4Q0krcEIsVUFBVSxDQUFDci9CLE1BQVgsR0FBb0IsQ0F3Q3hCO0FBckNDLGVBQWdCeS9CLFVBQWhCLFFBRk14K0IsUUFBUSxHQUFHdVEsRUFBRSxjQUFPNHRCLEtBQUssR0FBRyxVQUFILEdBQWdCLFVBQTVCLG9CQUFGLENBQTBEOXBCLE9BQTFELENBRWpCLG9CQUFTb3FCLENBQVQ7QUFJQyxZQUZBRCxXQUFVLEdBQUdBLFdBQVUsQ0FBQ2o2QixNQUFYLENBQWtCLFVBQUF4RyxDQUFDO0FBQUEsaUJBQUlzZ0MsR0FBRyxDQUFDbm1DLE9BQUosQ0FBWTZGLENBQVosS0FBa0IsQ0FBdEI7QUFBQSxTQUFuQixDQUViLEVBQUl5Z0MsV0FBVSxDQUFDei9CLE1BQVgsS0FBc0IsQ0FBMUIsRUFDQztBQUxGLFlBUU8yL0IsTUFBTSxHQUFHRixXQUFVLENBQUMsQ0FBRCxDQVIxQjtBQUFBLFlBU09HLFVBQVUsR0FBR3B1QixFQUFFLENBQUNoWSxJQUFILENBQVFza0MsS0FBUixDQUFjNkIsTUFBZCxDQVRwQjtBQVlLMStCLGdCQUFRLElBQUlzK0IsRUFBRSxDQUFDSSxNQUFELENBWm5CLEtBYUVKLEVBQUUsQ0FBQ0ksTUFBRCxDQUFGLEdBQWFKLEVBQUUsQ0FBQ0ksTUFBRCxDQUFGLENBQVd6OUIsR0FBWCxDQUFlLFVBQUFsRCxDQUFDO0FBQUEsaUJBQzVCLENBQUNvZ0MsS0FBSyxHQUFHcGdDLENBQUMsR0FBRyxDQUFQLEdBQVdBLENBQUMsR0FBRyxDQUFyQixJQUEwQkEsQ0FBMUIsR0FBOEIsQ0FERjtBQUFBLFNBQWhCLENBYmY7O0FBa0JDLGlCQUFnQjZTLEVBQWhCLDRCQUFTZ3VCLENBQVQsRUFBZ0JodUIsRUFBaEI7QUFDQyxjQUFJLENBQUMwdEIsRUFBRSxDQUFDMXRCLEVBQUQsQ0FBUCxFQUNDO0FBR0QsY0FBTWl1QixNQUFNLEdBQUd0dUIsRUFBRSxDQUFDaFksSUFBSCxDQUFRc2tDLEtBQVIsQ0FBY2pzQixFQUFkLENBQWY7QUFFQTB0QixZQUFFLENBQUMxdEIsRUFBRCxDQUFGLENBQU94USxPQUFQLENBQWUsVUFBQ3JDLENBQUQsRUFBSXNELENBQUosRUFBVTtBQUFBLGdCQUNsQnk5QixHQUFHLEdBQUcsQ0FBQy9nQyxDQURXO0FBQUEsZ0JBRWxCZ2hDLGFBQWEsR0FBR1osS0FBSyxHQUFHVyxHQUFHLEdBQUcsQ0FBVCxHQUFhQSxHQUFHLEdBQUcsQ0FGdEI7QUFJcEJELGtCQUFNLEtBQUtGLFVBQVgsSUFBMkIzK0IsUUFBUSxJQUFJKytCLGFBSm5CLEtBS3ZCVCxFQUFFLENBQUNJLE1BQUQsQ0FBRixDQUFXcjlCLENBQVgsS0FBaUJ5OUIsR0FMTTtBQU94QixXQVBELENBUEQ7QUFBQSxXQUFTRixDQUFDLEdBQUcsQ0FBYixFQUFxQmh1QixFQUFFLEdBQUc0dEIsV0FBVSxDQUFDSSxDQUFELENBQXBDLEVBQTBDQSxDQUFDLEVBQTNDLGlCQUFTQSxDQUFULEVBQWdCaHVCLEVBQWhCOztBQWxCRDtBQUFBLFNBQVM2dEIsQ0FBQyxHQUFHLENBQWIsRUFBNkJELFVBQVUsR0FBR0osVUFBVSxDQUFDSyxDQUFELENBQXBELEVBQTBEQSxDQUFDLEVBQTNELGVBQVNBLENBQVQsRUFBZ0JELFVBQWhCO0FBcUNELFNBQU9uNUIsU0FBUyxDQUFDQyxJQUFELEVBQU9yRyxNQUFNLENBQUNDLElBQVAsQ0FBWW8vQixFQUFaLEVBQWdCcjlCLEdBQWhCLENBQW9CLFVBQUFuQixHQUFHO0FBQUEsYUFBSXVGLFNBQVMsQ0FBQ0MsSUFBRCxFQUFPZzVCLEVBQUUsQ0FBQ3grQixHQUFELENBQVQsQ0FBYjtBQUFBLEtBQXZCLENBQVAsQ0FBaEI7QUFDQSxHQW5EOEI7QUFxRC9Cay9CLGVBckQrQix5QkFxRGpCM3FCLE9BckRpQixFQXFEUjtBQUN0QixXQUFPLEtBQUs2cEIsZ0JBQUwsQ0FBc0I3cEIsT0FBdEIsRUFBK0IsS0FBL0IsQ0FBUDtBQUNBLEdBdkQ4QjtBQXlEL0I0cUIsZUF6RCtCLHlCQXlEakI1cUIsT0F6RGlCLEVBeURSO0FBQ3RCLFdBQU8sS0FBSzZwQixnQkFBTCxDQUFzQjdwQixPQUF0QixFQUErQixLQUEvQixDQUFQO0FBQ0EsR0EzRDhCO0FBNkQvQnFLLFlBN0QrQixzQkE2RHBCckssT0E3RG9CLEVBNkRYd3FCLE1BN0RXLEVBNkRIdEIsT0E3REcsRUE2RE07QUFBQSxRQUM5Qmh0QixFQUFFLEdBQUcsSUFEeUI7QUFBQSxRQUU5QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmtCO0FBSXBDLFFBQUlvSCxFQUFFLENBQUMyRCxpQkFBSCxFQUFKLEVBQ0MsT0FBTyxDQUFDLENBQUQsRUFBSSxHQUFKLENBQVA7QUFMbUMsUUFROUJnckIsZUFBZSxHQUFHN3FCLE9BQU8sQ0FBQzlQLE1BQVIsQ0FBZSxVQUFBMkIsQ0FBQztBQUFBLGFBQUlxSyxFQUFFLENBQUNoWSxJQUFILENBQVFza0MsS0FBUixDQUFjMzJCLENBQUMsQ0FBQzBLLEVBQWhCLE1BQXdCaXVCLE1BQTVCO0FBQUEsS0FBaEIsQ0FSWTtBQUFBLFFBUzlCTSxRQUFRLEdBQUc1QixPQUFPLEdBQUdodEIsRUFBRSxDQUFDNnVCLGVBQUgsQ0FBbUJGLGVBQW5CLEVBQW9DM0IsT0FBcEMsQ0FBSCxHQUFrRDJCLGVBVHRDO0FBQUEsUUFVOUJqQyxJQUFJLEdBQUc5ekIsTUFBTSxnQkFBUzAxQixNQUFULFVBVmlCO0FBQUEsUUFXOUIzQixJQUFJLEdBQUcvekIsTUFBTSxnQkFBUzAxQixNQUFULFVBWGlCO0FBQUEsUUFZaENRLFVBQVUsR0FBRzl1QixFQUFFLENBQUN5dUIsYUFBSCxDQUFpQkcsUUFBakIsQ0FabUI7QUFBQSxRQWFoQ0csVUFBVSxHQUFHL3VCLEVBQUUsQ0FBQzB1QixhQUFILENBQWlCRSxRQUFqQixDQWJtQjtBQUFBLFFBZTlCSSxNQUFNLEdBQUdwMkIsTUFBTSxnQkFBUzAxQixNQUFULGFBZmU7QUFBQSxRQWdCaENXLFdBQVcsR0FBSWp2QixFQUFFLENBQUM0TixPQUFILENBQVcsS0FBWCxFQUFrQmdoQixRQUFsQixLQUErQmgyQixNQUFNLENBQUMwdUIsYUFBdkMsSUFBMER0bkIsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE1BQVgsRUFBbUJnaEIsUUFBbkIsS0FBZ0NoMkIsTUFBTSxDQUFDNHVCLGNBaEIvRTtBQUFBLFFBaUI5QjBILFVBQVUsR0FBR3QyQixNQUFNLGdCQUFTMDFCLE1BQVQsZUFqQlc7QUFBQSxRQWtCOUJhLHVCQUF1QixHQUFHbnZCLEVBQUUsQ0FBQ3dXLFlBQUgsTUFBcUI1ZCxNQUFNLENBQUN1SCxZQWxCeEI7QUFBQSxRQW1COUJpdkIscUJBQXFCLEdBQUdwdkIsRUFBRSxDQUFDd1csWUFBSCxNQUFxQixDQUFDNWQsTUFBTSxDQUFDdUgsWUFuQnZCO0FBMkJwQyxRQUxBMnVCLFVBQVUsR0FBR3ZoQyxPQUFPLENBQUNtL0IsSUFBRCxDQUFQLEdBQWdCQSxJQUFoQixHQUNYbi9CLE9BQU8sQ0FBQ28vQixJQUFELENBQVAsR0FBaUJtQyxVQUFVLEdBQUduQyxJQUFiLEdBQW9CbUMsVUFBcEIsR0FBaUNuQyxJQUFJLEdBQUcsRUFBekQsR0FBK0RtQyxVQUlqRSxFQUhBQyxVQUFVLEdBQUd4aEMsT0FBTyxDQUFDby9CLElBQUQsQ0FBUCxHQUFnQkEsSUFBaEIsR0FDWHAvQixPQUFPLENBQUNtL0IsSUFBRCxDQUFQLEdBQWlCQSxJQUFJLEdBQUdxQyxVQUFQLEdBQW9CQSxVQUFwQixHQUFpQ3JDLElBQUksR0FBRyxFQUF6RCxHQUErRHFDLFVBRWpFLEVBQUlILFFBQVEsQ0FBQ3BnQyxNQUFULEtBQW9CLENBQXhCLEVBQTZCO0FBQzVCLGFBQU93UixFQUFFLENBQUNzdUIsTUFBRCxDQUFGLENBQVcvMEIsTUFBWCxFQUFQO0FBR0czSyxTQUFLLENBQUNrZ0MsVUFBRCxDQS9CMkIsS0FnQ25DQSxVQUFVLEdBQUcsQ0FoQ3NCLEdBbUNoQ2xnQyxLQUFLLENBQUNtZ0MsVUFBRCxDQW5DMkIsS0FvQ25DQSxVQUFVLEdBQUdELFVBcENzQixHQXVDaENBLFVBQVUsS0FBS0MsVUF2Q2lCLEtBd0NuQ0QsVUFBVSxHQUFHLENBQWIsR0FBaUJDLFVBQVUsR0FBRyxDQUE5QixHQUFrQ0QsVUFBVSxHQUFHLENBeENaO0FBQUEsUUEyQzlCTyxhQUFhLEdBQUdQLFVBQVUsSUFBSSxDQUFkLElBQW1CQyxVQUFVLElBQUksQ0EzQ25CO0FBQUEsUUE0QzlCTyxhQUFhLEdBQUdSLFVBQVUsSUFBSSxDQUFkLElBQW1CQyxVQUFVLElBQUksQ0E1Q25CO0FBQUEsS0ErQy9CeGhDLE9BQU8sQ0FBQ20vQixJQUFELENBQVAsSUFBaUIyQyxhQUFsQixJQUFxQzloQyxPQUFPLENBQUNvL0IsSUFBRCxDQUFQLElBQWlCMkMsYUEvQ3RCLE1BZ0RuQ0wsV0FBVyxLQWhEd0IsR0FvRGhDQSxXQXBEZ0MsS0FxRG5DSSxhQUFhLEtBQUtQLFVBQVUsR0FBRyxDQUFsQixDQXJEc0IsRUFzRG5DUSxhQUFhLEtBQUtQLFVBQVUsR0FBRyxDQUFsQixDQXREc0I7QUFBQSxRQXlEOUJwbkIsWUFBWSxHQUFHM1osSUFBSSxDQUFDbXRCLEdBQUwsQ0FBUzRULFVBQVUsR0FBR0QsVUFBdEIsQ0F6RGU7QUFBQSxRQTBEOUJwbkIsT0FBTyxHQUFHO0FBQUNySSxTQUFHLEVBQUVzSSxZQUFZLEdBQUcsRUFBckI7QUFBMEJwSSxZQUFNLEVBQUVvSSxZQUFZLEdBQUc7QUFBakQsS0ExRG9COztBQTREcEMsUUFBSTlaLFNBQVMsQ0FBQ21oQyxNQUFELENBQWIsRUFBdUI7QUFDdEIsVUFBTU8sVUFBVSxHQUFHdmhDLElBQUksQ0FBQ2tOLEdBQUwsQ0FBU2xOLElBQUksQ0FBQ210QixHQUFMLENBQVMyVCxVQUFULENBQVQsRUFBK0I5Z0MsSUFBSSxDQUFDbXRCLEdBQUwsQ0FBUzRULFVBQVQsQ0FBL0IsQ0FBbkI7QUFFQUEsZ0JBQVUsR0FBR0MsTUFBTSxHQUFHTyxVQUhBLEVBSXRCVCxVQUFVLEdBQUdFLE1BQU0sR0FBR08sVUFKQTtBQUt0QixLQWpFbUMsQ0FtRXBDOzs7QUFDQSxRQUFJSix1QkFBSixFQUE2QjtBQUFBLFVBQ3RCMStCLElBQUksR0FBR3JDLFVBQVUsQ0FBQzRSLEVBQUUsQ0FBQzNPLENBQUgsQ0FBSzZILEtBQUwsRUFBRCxDQURLO0FBQUEsVUFFdEJzMkIsS0FBSyxHQUFHeHZCLEVBQUUsQ0FBQ3l2QixrQkFBSCxDQUFzQlgsVUFBdEIsRUFBa0NDLFVBQWxDLEVBQThDLE9BQTlDLEVBQ1pyK0IsR0FEWSxDQUNSLFVBQUFsRCxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxHQUFHaUQsSUFBUjtBQUFBLE9BRE8sQ0FGYztBQUs1QixPQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCWixPQUFsQixDQUEwQixVQUFDckMsQ0FBRCxFQUFJc0QsQ0FBSixFQUFVO0FBQ25DNFcsZUFBTyxDQUFDbGEsQ0FBRCxDQUFQLElBQWNtYSxZQUFZLElBQUk2bkIsS0FBSyxDQUFDMStCLENBQUQsQ0FBTCxJQUFZLElBQUkwK0IsS0FBSyxDQUFDLENBQUQsQ0FBVCxHQUFlQSxLQUFLLENBQUMsQ0FBRCxDQUFoQyxDQUFKLENBRFM7QUFFbkMsT0FGRCxDQUw0QjtBQVE1QixLQVJELE1BUU8sSUFBSUoscUJBQUosRUFBMkI7QUFDakMsVUFBTU0sT0FBTyxHQUFHMXZCLEVBQUUsQ0FBQ3l2QixrQkFBSCxDQUFzQlgsVUFBdEIsRUFBa0NDLFVBQWxDLEVBQThDLFFBQTlDLENBQWhCO0FBRUEsT0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQmwvQixPQUFsQixDQUEwQixVQUFDckMsQ0FBRCxFQUFJc0QsQ0FBSixFQUFVO0FBQ25DNFcsZUFBTyxDQUFDbGEsQ0FBRCxDQUFQLElBQWN3UyxFQUFFLENBQUNoWSxJQUFILENBQVE2ZiwwQkFBUixDQUFtQzZuQixPQUFPLENBQUM1K0IsQ0FBRCxDQUExQyxFQUErQzZXLFlBQS9DLENBRHFCO0FBRW5DLE9BRkQsQ0FIaUM7QUFNakM7O0FBRUQsUUFBSSxRQUFRM04sSUFBUixDQUFhczBCLE1BQWIsQ0FBSixFQUEwQjtBQUN6QixVQUFNejdCLENBQUMsR0FBRytGLE1BQU0sZ0JBQVMwMUIsTUFBVCxjQUFoQjtBQUVJei9CLGNBQVEsQ0FBQ2dFLENBQUQsQ0FIYSxJQUl4QixDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCaEQsT0FBbEIsQ0FBMEIsVUFBQXJDLENBQUMsRUFBSTtBQUM5QmthLGVBQU8sQ0FBQ2xhLENBQUQsQ0FBUCxHQUFhd1MsRUFBRSxDQUFDaFksSUFBSCxDQUFRMm5DLFVBQVIsQ0FBbUI5OEIsQ0FBbkIsRUFBc0JyRixDQUF0QixFQUF5QmthLE9BQU8sQ0FBQ2xhLENBQUQsQ0FBaEMsRUFBcUNtYSxZQUFyQyxDQURpQjtBQUU5QixPQUZELENBSndCO0FBUXpCLEtBNUZtQyxDQThGcEM7OztBQUNJc25CLGVBL0ZnQyxLQWdHbkNJLGFBQWEsS0FBSzNuQixPQUFPLENBQUNuSSxNQUFSLEdBQWlCdXZCLFVBQXRCLENBaEdzQixFQWlHbkNRLGFBQWEsS0FBSzVuQixPQUFPLENBQUNySSxHQUFSLEdBQWMsQ0FBQzB2QixVQUFwQixDQWpHc0I7QUFvR3BDLFFBQU14MUIsTUFBTSxHQUFHLENBQUN1MUIsVUFBVSxHQUFHcG5CLE9BQU8sQ0FBQ25JLE1BQXRCLEVBQThCd3ZCLFVBQVUsR0FBR3JuQixPQUFPLENBQUNySSxHQUFuRCxDQUFmO0FBRUEsV0FBTzZ2QixVQUFVLEdBQUczMUIsTUFBTSxDQUFDcTJCLE9BQVAsRUFBSCxHQUFzQnIyQixNQUF2QztBQUNBLEdBcEs4QjtBQXNLL0JzMkIsa0JBdEsrQiw0QkFzS2QvckIsT0F0S2MsRUFzS0wvTyxJQXRLSyxFQXNLQztBQUFBLFFBQ3pCaUwsRUFBRSxHQUFHLElBRG9CO0FBQUEsUUFFekJyUSxLQUFLLEdBQUdxUSxFQUFFLENBQUNwSCxNQUFILGtCQUFvQjdELElBQXBCLEVBRmlCO0FBSS9CLFdBQU9sSCxTQUFTLENBQUM4QixLQUFELENBQVQsR0FDTHFRLEVBQUUsQ0FBQ3FELFlBQUgsS0FBb0JyRCxFQUFFLENBQUNzRCxTQUFILENBQWEzVCxLQUFiLENBQXBCLEdBQTBDQSxLQURyQyxHQUVObUYsU0FBUyxDQUFDQyxJQUFELEVBQU8rTyxPQUFPLENBQUNwVCxHQUFSLENBQVksVUFBQWlGLENBQUM7QUFBQSxhQUFJYixTQUFTLENBQUNDLElBQUQsRUFBT1ksQ0FBQyxDQUFDdU0sTUFBRixDQUFTeFIsR0FBVCxDQUFhLFVBQUFsRCxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDNEQsQ0FBTjtBQUFBLE9BQWQsQ0FBUCxDQUFiO0FBQUEsS0FBYixDQUFQLENBRlY7QUFHQSxHQTdLOEI7QUErSy9CMCtCLGVBL0srQix5QkErS2pCaHNCLE9BL0tpQixFQStLUjtBQUN0QixXQUFPLEtBQUsrckIsZ0JBQUwsQ0FBc0IvckIsT0FBdEIsRUFBK0IsS0FBL0IsQ0FBUDtBQUNBLEdBakw4QjtBQW1ML0Jpc0IsZUFuTCtCLHlCQW1MakJqc0IsT0FuTGlCLEVBbUxSO0FBQ3RCLFdBQU8sS0FBSytyQixnQkFBTCxDQUFzQi9yQixPQUF0QixFQUErQixLQUEvQixDQUFQO0FBQ0EsR0FyTDhCO0FBdUwvQmtzQixtQkF2TCtCLDZCQXVMYnoyQixNQXZMYSxFQXVMTDtBQUFBLFFBS3JCMDJCLFlBTHFCO0FBQUEsUUFNckJ2b0IsT0FOcUI7QUFBQSxRQUNuQjFILEVBQUUsR0FBRyxJQURjO0FBQUEsUUFFbkJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZPO0FBQUEsUUFHbkJuSSxJQUFJLEdBQUc4SSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlBLE1BQU0sQ0FBQyxDQUFELENBSE47QUFBQSxRQUluQjIyQixRQUFRLEdBQUd0M0IsTUFBTSxDQUFDNnFCLGNBSkM7QUFRckJ6akIsTUFBRSxDQUFDeUMsYUFBSCxFQVJxQixHQVN4QmlGLE9BQU8sR0FBRyxDQVRjLEdBVWQxSCxFQUFFLENBQUM0TixPQUFILENBQVcsS0FBWCxDQVZjLElBV3hCcWlCLFlBQVksR0FBR2p3QixFQUFFLENBQUNtd0IsZUFBSCxFQVhTLEVBWXhCem9CLE9BQU8sR0FBR3VvQixZQUFZLEdBQUcsQ0FBZixHQUFvQngvQixJQUFJLElBQUl3L0IsWUFBWSxHQUFHLENBQW5CLENBQUwsR0FBOEIsQ0FBakQsR0FBcUQsRUFadkMsSUFjeEJ2b0IsT0FBTyxHQUFHalgsSUFBSSxHQUFHLEdBZE87QUFBQSxRQWlCckIrTyxJQUFJLEdBQUdrSSxPQWpCYztBQUFBLFFBa0JyQnBJLEtBQUssR0FBR29JLE9BbEJhO0FBNEJ6QixXQVJJeFksUUFBUSxDQUFDZ2hDLFFBQUQsQ0FBUixJQUFzQnJoQyxRQUFRLENBQUNxaEMsUUFBRCxDQVFsQyxJQVBDMXdCLElBQUksR0FBR2pTLE9BQU8sQ0FBQzJpQyxRQUFRLENBQUMxd0IsSUFBVixDQUFQLEdBQXlCMHdCLFFBQVEsQ0FBQzF3QixJQUFsQyxHQUF5Q2tJLE9BT2pELEVBTkNwSSxLQUFLLEdBQUcvUixPQUFPLENBQUMyaUMsUUFBUSxDQUFDNXdCLEtBQVYsQ0FBUCxHQUEwQjR3QixRQUFRLENBQUM1d0IsS0FBbkMsR0FBMkNvSSxPQU1wRCxJQUxXL1osUUFBUSxDQUFDaUwsTUFBTSxDQUFDNnFCLGNBQVIsQ0FLbkIsS0FKQ2prQixJQUFJLEdBQUcwd0IsUUFJUixFQUhDNXdCLEtBQUssR0FBRzR3QixRQUdULEdBQU87QUFBQzF3QixVQUFJLEVBQUpBLElBQUQ7QUFBT0YsV0FBSyxFQUFMQTtBQUFQLEtBQVA7QUFDQSxHQXBOOEI7QUFzTi9CME8sWUF0TitCLHNCQXNOcEJsSyxPQXROb0IsRUFzTlg7QUFBQSxRQUNiOUQsRUFBRSxHQUFHLElBRFE7QUFBQSxRQUViZ3RCLE9BQU8sR0FBRyxDQUFDaHRCLEVBQUUsQ0FBQzh2QixhQUFILENBQWlCaHNCLE9BQWpCLENBQUQsRUFBNEI5RCxFQUFFLENBQUMrdkIsYUFBSCxDQUFpQmpzQixPQUFqQixDQUE1QixDQUZHO0FBQUEsUUFHZnNzQixNQUFNLEdBQUdwRCxPQUFPLENBQUMsQ0FBRCxDQUhEO0FBQUEsUUFJZnFELEtBQUssR0FBR3JELE9BQU8sQ0FBQyxDQUFELENBSkE7QUFBQSxRQUtidGxCLE9BQU8sR0FBRzFILEVBQUUsQ0FBQ2d3QixpQkFBSCxDQUFxQmhELE9BQXJCLENBTEc7QUFBQSxRQU1mcjdCLEdBQUcsR0FBRyxDQU5TO0FBQUEsUUFPZnVKLEdBQUcsR0FBRyxDQVBTO0FBNEJuQixXQWxCS2sxQixNQUFNLEdBQUdDLEtBQVYsS0FBcUIsQ0FBckIsSUFBMkJyd0IsRUFBRSxDQUFDeUMsYUFBSCxFQWtCL0IsS0FqQkt6QyxFQUFFLENBQUNxRCxZQUFILEVBaUJMLElBaEJFK3NCLE1BQU0sR0FBRyxJQUFJM2hDLElBQUosQ0FBUzJoQyxNQUFNLENBQUNFLE9BQVAsS0FBbUIsRUFBNUIsQ0FnQlgsRUFmRUQsS0FBSyxHQUFHLElBQUk1aEMsSUFBSixDQUFTNGhDLEtBQUssQ0FBQ0MsT0FBTixLQUFrQixHQUEzQixDQWVWLEtBYkVGLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQVgsR0FBZSxDQUFmLEdBQW9CQSxNQUFNLEdBQUcsRUFheEMsRUFaRUMsS0FBSyxHQUFHQSxLQUFLLEtBQUssQ0FBVixHQUFjLENBQUMsQ0FBZixHQUFvQkEsS0FBSyxHQUFHLEdBWXRDLEtBUklELE1BQU0sSUFBSUEsTUFBTSxLQUFLLENBUXpCLE1BUEN6K0IsR0FBRyxHQUFHcU8sRUFBRSxDQUFDcUQsWUFBSCxLQUFvQixJQUFJNVUsSUFBSixDQUFTMmhDLE1BQU0sQ0FBQ0UsT0FBUCxLQUFtQjVvQixPQUFPLENBQUNsSSxJQUFwQyxDQUFwQixHQUFnRTR3QixNQUFNLEdBQUcxb0IsT0FBTyxDQUFDbEksSUFPeEYsSUFKSTZ3QixLQUFLLElBQUlBLEtBQUssS0FBSyxDQUl2QixNQUhDbjFCLEdBQUcsR0FBRzhFLEVBQUUsQ0FBQ3FELFlBQUgsS0FBb0IsSUFBSTVVLElBQUosQ0FBUzRoQyxLQUFLLENBQUNDLE9BQU4sS0FBa0I1b0IsT0FBTyxDQUFDcEksS0FBbkMsQ0FBcEIsR0FBZ0Urd0IsS0FBSyxHQUFHM29CLE9BQU8sQ0FBQ3BJLEtBR3ZGLEdBQU8sQ0FBQzNOLEdBQUQsRUFBTXVKLEdBQU4sQ0FBUDtBQUNBLEdBblA4QjtBQXFQL0JtYyxlQXJQK0IseUJBcVBqQnZULE9BclBpQixFQXFQUjZNLGlCQXJQUSxFQXFQV0Msb0JBclBYLEVBcVBpQzJmLFFBclBqQyxFQXFQMkNoM0IsTUFyUDNDLEVBcVBtRDtBQUFBLFFBQzNFeUcsRUFBRSxHQUFHLElBRHNFO0FBQUEsUUFFM0VwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUYrRDtBQUFBLFFBRzNFNDNCLFdBQVcsR0FBRzUzQixNQUFNLENBQUNpUyxZQUhzRDs7QUFlakYsUUFWSStGLG9CQVVKLEtBVEM1USxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLENBQVlBLE1BQU0sSUFBSWhGLFNBQVMsQ0FBQ3lMLEVBQUUsQ0FBQ2dPLFVBQUgsQ0FBY2xLLE9BQWQsQ0FBRCxDQUEvQixDQVNELEVBUkM5RCxFQUFFLENBQUNrTyxVQUFILEdBQWdCbE8sRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxFQVFqQixFQU5DaTNCLFdBQVcsSUFBSXh3QixFQUFFLENBQUN5d0IsSUFBSCxDQUFRQyxpQkFBUixFQU1oQixFQUpDMXdCLEVBQUUsQ0FBQ2lPLElBQUgsQ0FBUTFVLE1BQVIsQ0FBZXlHLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS21JLE1BQUwsRUFBZixDQUlELEVBSEN5RyxFQUFFLENBQUN2WCxLQUFILElBQVl1WCxFQUFFLENBQUN2WCxLQUFILENBQVNvUSxLQUFULENBQWVtSCxFQUFFLENBQUNpTyxJQUFsQixDQUdiLEdBQUkwQyxpQkFBSixFQUF1QjtBQUN0QixVQUFNeWIsV0FBVyxHQUFHN3lCLE1BQU0sSUFBSyxDQUFDeUcsRUFBRSxDQUFDdlgsS0FBSixJQUFhaUssVUFBVSxDQUFDc04sRUFBRCxDQUFsQyxHQUNuQkEsRUFBRSxDQUFDa08sVUFEZ0IsR0FDSHRjLGlCQUFpQixDQUFDb08sRUFBRCxDQUFqQixDQUFzQnRQLEdBQXRCLENBQTBCc1AsRUFBRSxDQUFDaU8sSUFBSCxDQUFRMGlCLE1BQWxDLENBRGpCO0FBR0Ezd0IsUUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxDQUFZNnlCLFdBQVosQ0FKc0IsRUFLdEJvRSxXQUFXLElBQUl4d0IsRUFBRSxDQUFDeXdCLElBQUgsQ0FBUUMsaUJBQVIsRUFMTztBQU10QixLQXJCZ0YsQ0F1QmpGOzs7QUFHQSxXQUZBSCxRQUFRLElBQUl2d0IsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxDQUFZeUcsRUFBRSxDQUFDNHdCLFdBQUgsQ0FBZTV3QixFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFMLEVBQWYsQ0FBWixDQUVaLEVBQU8vSyxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLEVBQVA7QUFDQSxHQWhSOEI7QUFrUi9CcTNCLGFBbFIrQix1QkFrUm5CcjNCLE1BbFJtQixFQWtSWDtBQUNiLFFBQUFzM0IsVUFBVSxHQUFHLEtBQUtDLGFBQUwsRUFBYjtBQUFBLDhDQUNhRCxVQURiO0FBQUEsUUFDQ2wvQixHQUREO0FBQUEsUUFDTXVKLEdBRE47O0FBYU4sV0FWSTNCLE1BQU0sQ0FBQyxDQUFELENBQU4sSUFBYTVILEdBVWpCLEtBVEM0SCxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVksQ0FBQ0EsTUFBTSxDQUFDLENBQUQsQ0FBUCxJQUFjNUgsR0FBRyxHQUFHNEgsTUFBTSxDQUFDLENBQUQsQ0FBMUIsQ0FTYixFQVJDQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVk1SCxHQVFiLEdBTEl1SixHQUFHLElBQUkzQixNQUFNLENBQUMsQ0FBRCxDQUtqQixLQUpDQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVksQ0FBQ0EsTUFBTSxDQUFDLENBQUQsQ0FBUCxJQUFjQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVkyQixHQUExQixDQUliLEVBSEMzQixNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVkyQixHQUdiLEdBQU8zQixNQUFQO0FBQ0E7QUFqUzhCLENBQTFCLEM7Ozs7QUNQTjs7OztBQUlBO0FBQ0E7QUFDQTtBQW1CQTVHLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COFIsS0FEK0IsZUFDM0J4aEMsR0FEMkIsRUFDdEI7QUFBQSxRQUNGeVEsRUFBRSxHQUFHLElBREg7QUFBQSxRQUVGcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVjtBQUFBLFFBR0ZvNEIsT0FBTyxHQUFHcDRCLE1BQU0sQ0FBQ21pQixNQUFQLElBQWlCeHJCLEdBQUcsS0FBS3FKLE1BQU0sQ0FBQ21pQixNQUh4QztBQUFBLFFBSUZrVyxVQUFVLEdBQUdwaUMsUUFBUSxDQUFDK0osTUFBTSxDQUFDb2lCLE9BQVIsQ0FBUixJQUE0QnZyQixhQUFRLENBQUNtSixNQUFNLENBQUNvaUIsT0FBUixFQUFpQnpyQixHQUFqQixDQUovQztBQU1SLFdBQU95aEMsT0FBTyxJQUFJQyxVQUFsQjtBQUNBLEdBUjhCO0FBVS9CQyxRQVYrQixrQkFVeEIzaEMsR0FWd0IsRUFVbkI7QUFDWCxXQUFPLENBQUMsS0FBS3doQyxHQUFMLENBQVN4aEMsR0FBVCxDQUFSO0FBQ0EsR0FaOEI7QUFjL0JvVSxtQkFkK0IsK0JBY1g7QUFDbkIsUUFBTS9LLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUVBLFdBQU9BLE1BQU0sQ0FBQ2tvQixvQkFBUCxJQUErQmxvQixNQUFNLENBQUN5bkIsV0FBUCxDQUFtQjd4QixNQUF6RDtBQUNBLEdBbEI4QjtBQW9CL0IyaUMsV0FwQitCLHFCQW9CckI5d0IsRUFwQnFCLEVBb0JqQjtBQUNiLFdBQU8sS0FBS3pILE1BQUwsQ0FBWXluQixXQUFaLENBQ0wzdkIsR0FESyxDQUNELFVBQUFsRCxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDN0YsT0FBRixDQUFVMFksRUFBVixLQUFpQixDQUFyQjtBQUFBLEtBREEsRUFDd0IsQ0FEeEIsQ0FBUDtBQUVBLEdBdkI4QjtBQXlCL0Ird0IsU0F6QitCLG1CQXlCdkIvd0IsRUF6QnVCLEVBeUJuQjtBQUFBLFFBQ0xMLEVBQUUsR0FBRyxJQURBO0FBQUEsUUFFTHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlA7QUFJWCxXQUFPQSxNQUFNLENBQUNtaUIsTUFBUCxHQUNObmlCLE1BQU0sQ0FBQ21pQixNQURELEdBQ1dsc0IsUUFBUSxDQUFDK0osTUFBTSxDQUFDb2lCLE9BQVIsQ0FBUixHQUEyQnBpQixNQUFNLENBQUNvaUIsT0FBUCxDQUFlM2EsRUFBZixDQUEzQixHQUFnRCxJQURsRTtBQUVBLEdBL0I4QjtBQWlDL0JneEIsa0JBakMrQiw0QkFpQ2Q5aEMsR0FqQ2MsRUFpQ1R1VSxPQWpDUyxFQWlDQTtBQUFBLFFBRzFCd3RCLE9BSDBCO0FBQUEsUUFDeEJ0eEIsRUFBRSxHQUFHLElBRG1CO0FBQUEsUUFFeEI4dEIsR0FBRyxHQUFHaHFCLE9BQU8sSUFBSWpWLFFBQVEsQ0FBQ2lWLE9BQUQsQ0FBbkIsR0FBK0I5RCxFQUFFLENBQUN5TixRQUFILENBQVkzSixPQUFaLENBQS9CLEdBQXNELEVBRnBDO0FBVzlCLFdBTkFncUIsR0FBRyxDQUFDaitCLE9BQUosQ0FBWSxVQUFBd1EsRUFBRSxFQUFJO0FBQ2JMLFFBQUUsQ0FBQ294QixPQUFILENBQVcvd0IsRUFBWCxNQUFtQjlRLEdBRE4sS0FFaEIraEMsT0FBTyxHQUFHdHhCLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQVIsQ0FBVy9NLEVBQVgsQ0FGTTtBQUlqQixLQUpELENBTUEsRUFBT2l4QixPQUFQO0FBQ0EsR0E3QzhCOztBQStDL0I7Ozs7Ozs7QUFPQUMsYUF0RCtCLHVCQXNEbkJuZ0MsQ0F0RG1CLEVBc0RoQm9nQyxNQXREZ0IsRUFzRFI7QUFDdEIsUUFBTXh4QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU93eEIsTUFBTSxHQUNaQSxNQUFNLENBQUM3cEMsT0FBUCxDQUFlK0YsUUFBUSxDQUFDMEQsQ0FBRCxDQUFSLEdBQWNBLENBQWQsR0FBa0IsQ0FBQ0EsQ0FBbEMsQ0FEWSxHQUVaLENBQUM0TyxFQUFFLENBQUN5eEIsU0FBSCxDQUFhenhCLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXJCLEVBQThCMVMsQ0FBOUIsRUFBaUMsQ0FBakMsS0FBdUM7QUFBQ3VNLFdBQUssRUFBRTtBQUFSLEtBQXhDLEVBQXVEQSxLQUZ4RDtBQUdBLEdBNUQ4QjtBQThEL0IrekIsV0E5RCtCLHFCQThEckJyeEIsRUE5RHFCLEVBOERqQnZQLENBOURpQixFQThEZDtBQUNoQixRQUFNa1AsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPSyxFQUFFLElBQUlMLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQWQsSUFDTnBOLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQVIsQ0FBVy9NLEVBQVgsQ0FETSxJQUVOOVMsT0FBTyxDQUFDeVMsRUFBRSxDQUFDak0sSUFBSCxDQUFRcVosRUFBUixDQUFXL00sRUFBWCxFQUFldlAsQ0FBZixDQUFELENBRkQsR0FFdUJrUCxFQUFFLENBQUNqTSxJQUFILENBQVFxWixFQUFSLENBQVcvTSxFQUFYLEVBQWV2UCxDQUFmLENBRnZCLEdBRTJDQSxDQUZsRDtBQUdBLEdBcEU4QjtBQXNFL0I2Z0Msa0JBdEUrQiw4QkFzRVo7QUFBQSxRQUNaM3hCLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFWjR4QixPQUFPLEdBQUdsakMsTUFBTSxDQUFDQyxJQUFQLENBQVlxUixFQUFFLENBQUNqTSxJQUFILENBQVFxWixFQUFwQixDQUZFO0FBSWxCLFdBQU93a0IsT0FBTyxDQUFDcGpDLE1BQVIsR0FBaUJ3UixFQUFFLENBQUNqTSxJQUFILENBQVFxWixFQUFSLENBQVd3a0IsT0FBTyxDQUFDLENBQUQsQ0FBbEIsQ0FBakIsR0FBMEMsSUFBakQ7QUFDQSxHQTNFOEI7QUE2RS9CQyxpQkE3RStCLDJCQTZFZmwwQixLQTdFZSxFQTZFUjtBQUN0QixRQUFNeVAsRUFBRSxHQUFHLEtBQUt1a0IsZ0JBQUwsRUFBWDtBQUVBLFdBQU92a0IsRUFBRSxJQUFJelAsS0FBSyxHQUFHeVAsRUFBRSxDQUFDNWUsTUFBakIsR0FBMEI0ZSxFQUFFLENBQUN6UCxLQUFELENBQTVCLEdBQXNDLElBQTdDO0FBQ0EsR0FqRjhCO0FBbUYvQm0wQixPQW5GK0IsaUJBbUZ6QjFrQixFQW5GeUIsRUFtRnJCO0FBQ1QsUUFBTXBOLEVBQUUsR0FBRyxJQUFYO0FBRUF0UixVQUFNLENBQUNDLElBQVAsQ0FBWXllLEVBQVosRUFBZ0J2ZCxPQUFoQixDQUF3QixVQUFBd1EsRUFBRSxFQUFJO0FBQzdCTCxRQUFFLENBQUNwSCxNQUFILENBQVVvaUIsT0FBVixDQUFrQjNhLEVBQWxCLElBQXdCK00sRUFBRSxDQUFDL00sRUFBRCxDQURHO0FBRTdCLEtBRkQsQ0FIUztBQU1ULEdBekY4QjtBQTJGL0IweEIsY0EzRitCLHdCQTJGbEIza0IsRUEzRmtCLEVBMkZkO0FBQ2hCLFdBQU8xZSxNQUFNLENBQUNDLElBQVAsQ0FBWXllLEVBQVosRUFBZ0IxYyxHQUFoQixDQUFvQixVQUFBMlAsRUFBRTtBQUFBLGFBQUkrTSxFQUFFLENBQUMvTSxFQUFELENBQU47QUFBQSxLQUF0QixFQUFrQzdSLE1BQWxDLEdBQTJDLENBQWxEO0FBQ0EsR0E3RjhCO0FBK0YvQndqQyxhQS9GK0IseUJBK0ZqQjtBQUNiLFdBQU9uakMsUUFBUSxDQUFDLEtBQUsrSixNQUFMLENBQVlvaUIsT0FBYixDQUFSLElBQ04sQ0FBQyxLQUFLcGlCLE1BQUwsQ0FBWXFuQixVQURQLElBRU4sS0FBS3JTLE9BQUwsQ0FBYSxRQUFiLENBRk0sSUFHTixLQUFLQSxPQUFMLENBQWEsU0FBYixDQUhEO0FBSUEsR0FwRzhCO0FBc0cvQnFrQixTQXRHK0IsbUJBc0d2QmwrQixJQXRHdUIsRUFzR2pCO0FBQUEsUUFFVDVCLElBRlM7QUFBQSxRQUNQNk4sRUFBRSxHQUFHLElBREU7QUFTYixXQUxJak0sSUFLSixLQUpDNUIsSUFBSSxHQUFHNk4sRUFBRSxDQUFDcEgsTUFBSCxDQUFVdW5CLFVBQVYsQ0FBcUJwc0IsSUFBSSxDQUFDc00sRUFBMUIsQ0FJUixFQUhDdE0sSUFBSSxDQUFDNUIsSUFBTCxHQUFZQSxJQUFJLEtBQUs4QyxTQUFULEdBQTRCbEIsSUFBSSxDQUFDc00sRUFBakMsR0FBcUJsTyxJQUdsQyxHQUFPNEIsSUFBUDtBQUNBLEdBaEg4QjtBQWtIL0JtK0IscUJBbEgrQiwrQkFrSFh2MEIsS0FsSFcsRUFrSEo7QUFDMUIsUUFBTXFDLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDNkcsbUJBQUgsQ0FBdUI3RyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUEvQixFQUNMcFQsR0FESyxDQUNELFVBQUFpRixDQUFDO0FBQUEsYUFBSXFLLEVBQUUsQ0FBQ2l5QixPQUFILENBQVdqeUIsRUFBRSxDQUFDbXlCLGVBQUgsQ0FBbUJ4OEIsQ0FBQyxDQUFDdU0sTUFBckIsRUFBNkJ2RSxLQUE3QixDQUFYLENBQUo7QUFBQSxLQURBLENBQVA7QUFFQSxHQXZIOEI7QUF5SC9CdzBCLGlCQXpIK0IsMkJBeUhmandCLE1BekhlLEVBeUhQdkUsS0F6SE8sRUF5SEE7QUFDOUIsUUFBTXkwQixZQUFZLEdBQUdsd0IsTUFBTSxDQUFDbE8sTUFBUCxDQUFjLFVBQUF4RyxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDbVEsS0FBRixLQUFZQSxLQUFoQjtBQUFBLEtBQWYsQ0FBckI7QUFFQSxXQUFPeTBCLFlBQVksQ0FBQzVqQyxNQUFiLEdBQXNCNGpDLFlBQVksQ0FBQyxDQUFELENBQWxDLEdBQXdDLElBQS9DO0FBQ0EsR0E3SDhCO0FBK0gvQkMsZUEvSCtCLHlCQStIakJ2dUIsT0EvSGlCLEVBK0hSMVMsQ0EvSFEsRUErSEw7QUFDekIsUUFBTTRPLEVBQUUsR0FBRyxJQUFYO0FBRUE4RCxXQUFPLENBQUNqVSxPQUFSLENBQWdCLFVBQUE4RixDQUFDLEVBQUk7QUFDcEJBLE9BQUMsQ0FBQ3VNLE1BQUYsQ0FBU3JTLE9BQVQsQ0FBaUIsVUFBQ3JDLENBQUQsRUFBSXNELENBQUosRUFBVTtBQUMxQnRELFNBQUMsQ0FBQzRELENBQUYsR0FBTTRPLEVBQUUsQ0FBQ3N5QixlQUFILENBQW1CbGhDLENBQUMsQ0FBQ04sQ0FBRCxDQUFwQixFQUF5QjZFLENBQUMsQ0FBQzBLLEVBQTNCLEVBQStCdlAsQ0FBL0IsQ0FEb0I7QUFFMUIsT0FGRCxDQURvQixFQUtwQmtQLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQVIsQ0FBV3pYLENBQUMsQ0FBQzBLLEVBQWIsSUFBbUJqUCxDQUxDO0FBTXBCLEtBTkQsQ0FIeUI7QUFVekIsR0F6SThCO0FBMkkvQm1oQyxnQkEzSStCLDBCQTJJaEJ6dUIsT0EzSWdCLEVBMklQc0osRUEzSU8sRUEySUg7QUFDM0IsUUFBTXBOLEVBQUUsR0FBRyxJQUFYO0FBRUE4RCxXQUFPLENBQUNqVSxPQUFSLENBQWdCLFVBQUE4RixDQUFDLEVBQUk7QUFDcEJ5WCxRQUFFLENBQUN6WCxDQUFDLENBQUMwSyxFQUFILENBQUYsSUFBWUwsRUFBRSxDQUFDcXlCLGFBQUgsQ0FBaUIsQ0FBQzE4QixDQUFELENBQWpCLEVBQXNCeVgsRUFBRSxDQUFDelgsQ0FBQyxDQUFDMEssRUFBSCxDQUF4QixDQURRO0FBRXBCLEtBRkQsQ0FIMkI7QUFNM0IsR0FqSjhCO0FBbUovQml5QixpQkFuSitCLDJCQW1KZkUsSUFuSmUsRUFtSlRueUIsRUFuSlMsRUFtSkwxQyxLQW5KSyxFQW1KRTtBQUFBLFFBQzFCcUMsRUFBRSxHQUFHLElBRHFCO0FBQUEsUUFFNUI1TyxDQUFDLEdBQUc0TyxFQUFFLENBQUN5QyxhQUFILEtBQXFCOUUsS0FBckIsR0FBOEI2MEIsSUFBSSxJQUFJNzBCLEtBRmQ7QUFVaEMsV0FOSXFDLEVBQUUsQ0FBQ3FELFlBQUgsRUFNSixHQUxDalMsQ0FBQyxHQUFHb2hDLElBQUksR0FBR3h5QixFQUFFLENBQUNzRCxTQUFILENBQWFrdkIsSUFBYixDQUFILEdBQXdCeHlCLEVBQUUsQ0FBQ3NELFNBQUgsQ0FBYXRELEVBQUUsQ0FBQzB4QixTQUFILENBQWFyeEIsRUFBYixFQUFpQjFDLEtBQWpCLENBQWIsQ0FLakMsR0FKV3FDLEVBQUUsQ0FBQ3l5QixTQUFILE1BQWtCLENBQUN6eUIsRUFBRSxDQUFDeUMsYUFBSCxFQUk5QixLQUhDclIsQ0FBQyxHQUFHN0QsT0FBTyxDQUFDaWxDLElBQUQsQ0FBUCxHQUFnQixDQUFDQSxJQUFqQixHQUF3Qnh5QixFQUFFLENBQUMweEIsU0FBSCxDQUFhcnhCLEVBQWIsRUFBaUIxQyxLQUFqQixDQUc3QixHQUFPdk0sQ0FBUDtBQUNBLEdBOUo4QjtBQWdLL0JzaEMsYUFoSytCLHVCQWdLbkJ4bUMsTUFoS21CLEVBZ0tYO0FBQ25CLFdBQU87QUFDTm1VLFFBQUUsRUFBRW5VLE1BQU0sQ0FBQ21VLEVBREw7QUFFTnN5QixZQUFNLEVBQUV6bUMsTUFBTSxDQUFDeW1DLE1BRlQ7QUFHTnp3QixZQUFNLEVBQUVoVyxNQUFNLENBQUNnVyxNQUFQLENBQWN4UixHQUFkLENBQWtCLFVBQUFyQyxDQUFDO0FBQUEsZUFBSztBQUFDK0MsV0FBQyxFQUFFL0MsQ0FBQyxDQUFDK0MsQ0FBTjtBQUFTekIsZUFBSyxFQUFFdEIsQ0FBQyxDQUFDc0IsS0FBbEI7QUFBeUIwUSxZQUFFLEVBQUVoUyxDQUFDLENBQUNnUztBQUEvQixTQUFMO0FBQUEsT0FBbkI7QUFIRixLQUFQO0FBS0EsR0F0SzhCO0FBd0svQnV5QixVQXhLK0Isc0JBd0twQjtBQUFBLFFBQ0o1eUIsRUFBRSxHQUFHLElBREQ7QUFBQSxRQUVKOEQsT0FBTyxHQUFHOUQsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FGZDtBQUlOQSxXQUFPLENBQUN0VixNQUpGLEtBS1R3UixFQUFFLENBQUNvTixFQUFILEdBQVEsRUFMQyxFQU9UdEosT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXNUIsTUFBWCxDQUFrQnJTLE9BQWxCLENBQTBCLFVBQUFyQyxDQUFDLEVBQUk7QUFDOUJ3UyxRQUFFLENBQUNvTixFQUFILENBQU01ZixDQUFDLENBQUNtUSxLQUFSLElBQWlCblEsQ0FBQyxDQUFDNEQsQ0FEVztBQUU5QixLQUZELENBUFM7QUFXVixHQW5MOEI7QUFxTC9CeWhDLFVBckwrQixvQkFxTHRCL2hDLENBckxzQixFQXFMbkI7QUFDWCxRQUFNTSxDQUFDLEdBQUcsS0FBS2djLEVBQUwsQ0FBUXRjLENBQUMsR0FBRyxDQUFaLENBQVY7QUFFQSxXQUFPakQsU0FBUyxDQUFDdUQsQ0FBRCxDQUFULEdBQWVBLENBQWYsR0FBbUIsSUFBMUI7QUFDQSxHQXpMOEI7QUEyTC9CMGhDLFVBM0wrQixvQkEyTHRCaGlDLENBM0xzQixFQTJMbkI7QUFDWCxRQUFNTSxDQUFDLEdBQUcsS0FBS2djLEVBQUwsQ0FBUXRjLENBQUMsR0FBRyxDQUFaLENBQVY7QUFFQSxXQUFPakQsU0FBUyxDQUFDdUQsQ0FBRCxDQUFULEdBQWVBLENBQWYsR0FBbUIsSUFBMUI7QUFDQSxHQS9MOEI7O0FBaU0vQjs7Ozs7O0FBTUFncUIsY0F2TStCLHdCQXVNbEJybkIsSUF2TWtCLEVBdU1aO0FBQUEsUUFDWmlNLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFZHJRLEtBQUssR0FBR29FLElBQUksQ0FBQ3BFLEtBRkM7QUFVbEIsV0FKSUEsS0FBSyxJQUFJcVEsRUFBRSxDQUFDK3lCLGVBQUgsQ0FBbUJoL0IsSUFBbkIsQ0FJYixLQUhDcEUsS0FBSyxHQUFHcVEsRUFBRSxDQUFDZ3pCLGdCQUFILENBQW9Cai9CLElBQXBCLEVBQTBCLEtBQTFCLENBR1QsR0FBT3BFLEtBQVA7QUFDQSxHQWxOOEI7O0FBb04vQjs7Ozs7O0FBTUFzakMsZ0JBMU4rQiwwQkEwTmhCbC9CLElBMU5nQixFQTBOVjtBQUFBLFFBRWhCcEMsR0FGZ0I7QUFBQSxRQUdoQnVKLEdBSGdCO0FBQUEsUUFDZGtnQixZQUFZLEdBQUcsS0FBS0EsWUFBTCxDQUFrQjVmLElBQWxCLENBQXVCLElBQXZCLENBREQ7QUFhcEIsV0FSQSxDQUFDekgsSUFBSSxJQUFJLEtBQUtBLElBQUwsQ0FBVStQLE9BQVYsQ0FBa0JwVCxHQUFsQixDQUFzQixVQUFBaUYsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3VNLE1BQU47QUFBQSxLQUF2QixDQUFULEVBQ0VyUyxPQURGLENBQ1UsVUFBQ3JDLENBQUQsRUFBSXNELENBQUosRUFBVTtBQUNsQixVQUFNbkIsS0FBSyxHQUFHbkMsQ0FBQyxDQUFDa0QsR0FBRixDQUFNMHFCLFlBQU4sRUFBb0JwbkIsTUFBcEIsQ0FBMkJyRyxRQUEzQixDQUFkO0FBRUFnRSxTQUFHLEdBQUczRCxJQUFJLENBQUMyRCxHQUFMLE9BQUEzRCxJQUFJLEdBQUs4QyxDQUFDLEdBQUdhLEdBQUgsR0FBU2tPLFFBQWYscUNBQTRCbFEsS0FBNUIsR0FIUSxFQUlsQnVMLEdBQUcsR0FBR2xOLElBQUksQ0FBQ2tOLEdBQUwsT0FBQWxOLElBQUksR0FBSzhDLENBQUMsR0FBR29LLEdBQUgsR0FBUyxDQUFDMkUsUUFBaEIscUNBQTZCbFEsS0FBN0IsR0FKUTtBQUtsQixLQU5GLENBUUEsRUFBTztBQUFDZ0MsU0FBRyxFQUFIQSxHQUFEO0FBQU11SixTQUFHLEVBQUhBO0FBQU4sS0FBUDtBQUNBLEdBeE84Qjs7QUEwTy9COzs7OztBQUtBZ1csZUEvTytCLDJCQStPZjtBQUFBLFFBQ1RsUixFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRrekIsUUFBUSxHQUFHLGFBRkY7QUFBQSxRQUdYQyxVQUFVLEdBQUduekIsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsUUFBWixDQUhGOztBQUtmLFFBQUksQ0FBQ0MsVUFBTCxFQUFpQjtBQUFBLFVBQ1ZwL0IsSUFBSSxHQUFHaU0sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQnBULEdBQWhCLENBQW9CLFVBQUFpRixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDdU0sTUFBTjtBQUFBLE9BQXJCLENBREc7QUFBQSxVQUVWK08sTUFBTSxHQUFHalIsRUFBRSxDQUFDaXpCLGNBQUgsQ0FBa0JsL0IsSUFBbEIsQ0FGQztBQUFBLFVBSVpwQyxHQUFHLEdBQUcsRUFKTTtBQUFBLFVBS1p1SixHQUFHLEdBQUcsRUFMTTtBQW9CaEI7QUFiQW5ILFVBQUksQ0FBQ2xFLE9BQUwsQ0FBYSxVQUFBckMsQ0FBQyxFQUFJO0FBQUEsWUFDWDZsQyxPQUFPLEdBQUdyekIsRUFBRSxDQUFDc3pCLHNCQUFILENBQTBCOWxDLENBQTFCLEVBQTZCeWpCLE1BQU0sQ0FBQ3RmLEdBQXBDLENBREM7QUFBQSxZQUVYNGhDLE9BQU8sR0FBR3Z6QixFQUFFLENBQUNzekIsc0JBQUgsQ0FBMEI5bEMsQ0FBMUIsRUFBNkJ5akIsTUFBTSxDQUFDL1YsR0FBcEMsQ0FGQztBQUlibTRCLGVBQU8sQ0FBQzdrQyxNQUpLLEtBS2hCbUQsR0FBRyxHQUFHQSxHQUFHLENBQUM2QixNQUFKLENBQVc2L0IsT0FBWCxDQUxVLEdBUWJFLE9BQU8sQ0FBQy9rQyxNQVJLLEtBU2hCME0sR0FBRyxHQUFHQSxHQUFHLENBQUMxSCxNQUFKLENBQVcrL0IsT0FBWCxDQVRVO0FBV2pCLE9BWEQsQ0FQZ0IsRUFxQmhCdnpCLEVBQUUsQ0FBQ3d6QixRQUFILENBQVlOLFFBQVosRUFBc0JDLFVBQVUsR0FBRztBQUFDeGhDLFdBQUcsRUFBSEEsR0FBRDtBQUFNdUosV0FBRyxFQUFIQTtBQUFOLE9BQW5DLENBckJnQjtBQXNCaEI7O0FBRUQsV0FBT2k0QixVQUFQO0FBQ0EsR0E3UThCOztBQStRL0I7Ozs7O0FBS0FNLGtCQXBSK0IsOEJBb1JaO0FBQUEsUUFDWnp6QixFQUFFLEdBQUcsSUFETztBQUFBLFFBR2QwekIsR0FBRyxHQUFHMXpCLEVBQUUsQ0FBQ296QixRQUFILENBRE8sZ0JBQ1AsQ0FIUTtBQW1CbEIsV0FkSXB6QixFQUFFLENBQUMyRCxpQkFBSCxNQUEwQixDQUFDK3ZCLEdBYy9CLEtBYkNBLEdBQUcsR0FBRyxFQWFQLEVBWEMxekIsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQmpVLE9BQWhCLENBQXdCLFVBQUE4akMsR0FBRyxFQUFJO0FBQzlCQSxTQUFHLENBQUN6eEIsTUFBSixDQUFXclMsT0FBWCxDQUFtQixVQUFDckMsQ0FBRCxFQUFJc0QsQ0FBSixFQUFVO0FBQ3ZCNGlDLFdBQUcsQ0FBQzVpQyxDQUFELENBRG9CLEtBRTNCNGlDLEdBQUcsQ0FBQzVpQyxDQUFELENBQUgsR0FBUyxDQUZrQixHQUs1QjRpQyxHQUFHLENBQUM1aUMsQ0FBRCxDQUFILElBQVVuRCxRQUFRLENBQUNILENBQUMsQ0FBQ21DLEtBQUgsQ0FBUixHQUFvQm5DLENBQUMsQ0FBQ21DLEtBQXRCLEdBQThCLENBTFo7QUFNNUIsT0FORCxDQUQ4QjtBQVE5QixLQVJELENBV0QsR0FBTytqQyxHQUFQO0FBQ0EsR0F4UzhCOztBQTBTL0I7Ozs7O0FBS0FFLGlCQS9TK0IsNkJBK1NiO0FBQUEsUUFDWDV6QixFQUFFLEdBQUcsSUFETTtBQUFBLFFBRVhrekIsUUFBUSxHQUFHLGVBRkE7QUFBQSxRQUdiVyxZQUFZLEdBQUc3ekIsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsUUFBWixDQUhGOztBQUtqQixRQUFJLENBQUNXLFlBQUwsRUFBbUI7QUFDbEIsVUFBTUMsS0FBSyxHQUFHNy9CLFVBQVUsQ0FBQytMLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0JwVCxHQUFoQixDQUFvQixVQUFBaUYsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ3VNLE1BQU47QUFBQSxPQUFyQixDQUFELENBQVYsQ0FDWnhSLEdBRFksQ0FDUixVQUFBbEQsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ21DLEtBQU47QUFBQSxPQURPLEVBRVp1RSxNQUZZLENBRUwsVUFBQ3JCLENBQUQsRUFBSXNCLENBQUo7QUFBQSxlQUFVdEIsQ0FBQyxHQUFHc0IsQ0FBZDtBQUFBLE9BRkssQ0FBZDtBQUlBNkwsUUFBRSxDQUFDd3pCLFFBQUgsQ0FBWU4sUUFBWixFQUFzQlcsWUFBWSxHQUFHQyxLQUFyQyxDQUxrQjtBQU1sQjs7QUFFRCxXQUFPRCxZQUFQO0FBQ0EsR0E3VDhCOztBQStUL0I7Ozs7Ozs7QUFPQVAsd0JBdFUrQixrQ0FzVVJ2L0IsSUF0VVEsRUFzVUZwRSxLQXRVRSxFQXNVSztBQUFBOztBQUNuQyxXQUFPb0UsSUFBSSxDQUFDQyxNQUFMLENBQVksVUFBQTJCLENBQUM7QUFBQSxhQUFJLEtBQUksQ0FBQ3lsQixZQUFMLENBQWtCemxCLENBQWxCLE1BQXlCaEcsS0FBN0I7QUFBQSxLQUFiLENBQVA7QUFDQSxHQXhVOEI7O0FBMFUvQjs7Ozs7QUFLQXdnQyxpQkEvVStCLDZCQStVYjtBQUNqQixXQUFPbmlDLElBQUksQ0FBQ2tOLEdBQUwsT0FBQWxOLElBQUksOEJBQVEsS0FBSytGLElBQUwsQ0FBVStQLE9BQVYsQ0FBa0JwVCxHQUFsQixDQUFzQixVQUFBaUYsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBUzFULE1BQWI7QUFBQSxLQUF2QixDQUFSLEVBQVg7QUFDQSxHQWpWOEI7QUFtVi9CdWxDLHVCQW5WK0IsaUNBbVZUandCLE9BblZTLEVBbVZBO0FBQUEsUUFHMUJrd0IsU0FIMEI7QUFBQSxRQUN4QnhsQyxNQUFNLEdBQUdzVixPQUFPLENBQUN0VixNQURPO0FBQUEsUUFFMUIwTSxHQUFHLEdBQUcsQ0FGb0I7QUFnQjlCLFdBWEkxTSxNQUFNLEdBQUcsQ0FXYixHQVZDc1YsT0FBTyxDQUFDalUsT0FBUixDQUFnQixVQUFBOEYsQ0FBQyxFQUFJO0FBQ2hCQSxPQUFDLENBQUN1TSxNQUFGLENBQVMxVCxNQUFULEdBQWtCME0sR0FERixLQUVuQjg0QixTQUFTLEdBQUdyK0IsQ0FGTyxFQUduQnVGLEdBQUcsR0FBR3ZGLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBUzFULE1BSEk7QUFLcEIsS0FMRCxDQVVELEdBSEN3bEMsU0FBUyxHQUFHeGxDLE1BQU0sR0FBR3NWLE9BQU8sQ0FBQyxDQUFELENBQVYsR0FBZ0IsSUFHbkMsRUFBT2t3QixTQUFQO0FBQ0EsR0FwVzhCO0FBc1cvQnZtQixVQXRXK0Isb0JBc1d0QjNKLE9BdFdzQixFQXNXYjtBQUNqQixXQUFPQSxPQUFPLENBQUNwVCxHQUFSLENBQVksVUFBQXJDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNnUyxFQUFOO0FBQUEsS0FBYixDQUFQO0FBQ0EsR0F4VzhCO0FBMFcvQjR6QixnQkExVytCLDBCQTBXaEJuRyxHQTFXZ0IsRUEwV1g7QUFDbkIsUUFBTTl0QixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU84dEIsR0FBRyxHQUFJaC9CLE9BQU8sQ0FBQ2cvQixHQUFELENBQVAsR0FBZUEsR0FBRyxDQUFDdDZCLE1BQUosRUFBZixHQUE4QixDQUFDczZCLEdBQUQsQ0FBbEMsR0FBMkM5dEIsRUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsQ0FBckQ7QUFDQSxHQTlXOEI7QUFnWC9Cb3dCLFdBaFgrQixxQkFnWHJCcHdCLE9BaFhxQixFQWdYWnpELEVBaFhZLEVBZ1hSO0FBQ3RCLFFBQU15dEIsR0FBRyxHQUFHLEtBQUtyZ0IsUUFBTCxDQUFjM0osT0FBZCxDQUFaOztBQUVBLFNBQUssSUFBV3lxQixHQUFYLEVBQUl6OUIsQ0FBQyxHQUFHLENBQWIsRUFBc0J5OUIsR0FBRyxHQUFHVCxHQUFHLENBQUNoOUIsQ0FBRCxDQUEvQixFQUFxQ0EsQ0FBQyxFQUF0QyxFQUNDLElBQUl5OUIsR0FBRyxLQUFLbHVCLEVBQVosRUFDQzs7QUFJRjtBQUNBLEdBMVg4QjtBQTRYL0JpVSxnQkE1WCtCLDBCQTRYaEI2ZixRQTVYZ0IsRUE0WE47QUFDeEIsV0FBTyxLQUFLNW9CLGVBQUwsQ0FBcUI1akIsT0FBckIsQ0FBNkJ3c0MsUUFBN0IsSUFBeUMsQ0FBaEQ7QUFDQSxHQTlYOEI7QUFnWS9CQyxnQkFoWStCLDBCQWdZaEJELFFBaFlnQixFQWdZTjtBQUN4QixXQUFPLEtBQUszb0IsZUFBTCxDQUFxQjdqQixPQUFyQixDQUE2QndzQyxRQUE3QixJQUF5QyxDQUFoRDtBQUNBLEdBbFk4QjtBQW9ZL0J0dEIscUJBcFkrQiwrQkFvWVgvQyxPQXBZVyxFQW9ZRjtBQUM1QixRQUFNOUQsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPLENBQUM4RCxPQUFPLElBQUk5RCxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFwQixFQUE2QjlQLE1BQTdCLENBQW9DLFVBQUEyQixDQUFDO0FBQUEsYUFBSXFLLEVBQUUsQ0FBQ3NVLGNBQUgsQ0FBa0IzZSxDQUFDLENBQUMwSyxFQUFwQixDQUFKO0FBQUEsS0FBckMsQ0FBUDtBQUNBLEdBeFk4QjtBQTBZL0I2RCxzQkExWStCLGdDQTBZVkosT0ExWVUsRUEwWUQ7QUFBQSxRQUN2QjlELEVBQUUsR0FBRyxJQURrQjtBQUFBLFFBRXpCb04sRUFBRSxHQUFHLEVBRm9CO0FBWTdCLFdBUkl0SixPQUFPLElBQUlBLE9BQU8sQ0FBQ3RWLE1BUXZCLEtBUEM0ZSxFQUFFLEdBQUd0WixTQUFTLENBQ2JHLFVBQVUsQ0FBQzZQLE9BQU8sQ0FBQ3BULEdBQVIsQ0FBWSxVQUFBaUYsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBU3hSLEdBQVQsQ0FBYSxVQUFBbEQsQ0FBQztBQUFBLGVBQUksQ0FBQ0EsQ0FBQyxDQUFDNEQsQ0FBUDtBQUFBLE9BQWQsQ0FBSjtBQUFBLEtBQWIsQ0FBRCxDQURHLENBT2YsRUFIQ2djLEVBQUUsR0FBR3BOLEVBQUUsQ0FBQ3FELFlBQUgsS0FBb0IrSixFQUFFLENBQUMxYyxHQUFILENBQU8sVUFBQVUsQ0FBQztBQUFBLGFBQUksSUFBSTNDLElBQUosQ0FBUyxDQUFDMkMsQ0FBVixDQUFKO0FBQUEsS0FBUixDQUFwQixHQUFnRGdjLEVBQUUsQ0FBQzFjLEdBQUgsQ0FBTyxVQUFBVSxDQUFDO0FBQUEsYUFBSSxDQUFDQSxDQUFMO0FBQUEsS0FBUixDQUd0RCxHQUFPbUQsU0FBUyxDQUFDNlksRUFBRCxDQUFoQjtBQUNBLEdBdlo4QjtBQXlaL0JJLG9CQXpaK0IsOEJBeVpaNm1CLFNBelpZLEVBeVpEO0FBQzdCLFNBQUs5b0IsZUFBTCxHQUF1QixLQUFLQSxlQUFMLENBQXFCL1gsTUFBckIsQ0FBNEI2Z0MsU0FBNUIsQ0FETTtBQUU3QixHQTNaOEI7QUE2Wi9CQyx1QkE3WitCLGlDQTZaVEQsU0E3WlMsRUE2WkU7QUFDaEMsU0FBSzlvQixlQUFMLEdBQXVCLEtBQUtBLGVBQUwsQ0FBcUJ2WCxNQUFyQixDQUE0QixVQUFBcU0sRUFBRTtBQUFBLGFBQUlnMEIsU0FBUyxDQUFDMXNDLE9BQVYsQ0FBa0IwWSxFQUFsQixJQUF3QixDQUE1QjtBQUFBLEtBQTlCLENBRFM7QUFFaEMsR0EvWjhCO0FBaWEvQnNOLG9CQWphK0IsOEJBaWFaMG1CLFNBamFZLEVBaWFEO0FBQzdCLFNBQUs3b0IsZUFBTCxHQUF1QixLQUFLQSxlQUFMLENBQXFCaFksTUFBckIsQ0FBNEI2Z0MsU0FBNUIsQ0FETTtBQUU3QixHQW5hOEI7QUFxYS9CRSx1QkFyYStCLGlDQXFhVEYsU0FyYVMsRUFxYUU7QUFDaEMsU0FBSzdvQixlQUFMLEdBQXVCLEtBQUtBLGVBQUwsQ0FBcUJ4WCxNQUFyQixDQUE0QixVQUFBcU0sRUFBRTtBQUFBLGFBQUlnMEIsU0FBUyxDQUFDMXNDLE9BQVYsQ0FBa0IwWSxFQUFsQixJQUF3QixDQUE1QjtBQUFBLEtBQTlCLENBRFM7QUFFaEMsR0F2YThCO0FBeWEvQjJ0QixvQkF6YStCLDhCQXlhWmxxQixPQXphWSxFQXlhSDtBQUFBLFFBQ3JCOUQsRUFBRSxHQUFHLElBRGdCO0FBQUEsUUFFckIrdEIsRUFBRSxHQUFHLEVBRmdCO0FBQUEsUUFHckJpRSxXQUFXLEdBQUdoeUIsRUFBRSxDQUFDZ3lCLFdBQUgsRUFITztBQUFBLFFBSXJCNWtCLEVBQUUsR0FBRzRrQixXQUFXLEdBQUdoeUIsRUFBRSxDQUFDa0Usb0JBQUgsQ0FBd0JKLE9BQXhCLEVBQ3ZCcFQsR0FEdUIsQ0FDbkIsVUFBQWxELENBQUM7QUFBQSxhQUFLRSxRQUFRLENBQUNGLENBQUQsQ0FBUixHQUFjQSxDQUFkLEdBQWtCLENBQUNBLENBQXhCO0FBQUEsS0FEa0IsQ0FBSCxHQUNlLElBTFY7QUE2QjNCLFdBdEJBc1csT0FBTyxDQUFDalUsT0FBUixDQUFnQixVQUFBOEYsQ0FBQyxFQUFJO0FBQ3BCLFVBQU01QixJQUFJLEdBQUcsRUFBYjtBQUVBNEIsT0FBQyxDQUFDdU0sTUFBRixDQUFTclMsT0FBVCxDQUFpQixVQUFBckMsQ0FBQyxFQUFJO0FBQ3JCLFlBQU1tQyxLQUFLLEdBQUduQyxDQUFDLENBQUNtQyxLQUFoQjtBQUVJYixlQUFPLENBQUNhLEtBQUQsQ0FIVSxHQUlwQm9FLElBQUksQ0FBQ3NCLElBQUwsT0FBQXRCLElBQUksOEJBQVNwRSxLQUFULEVBSmdCLEdBS1ZULFFBQVEsQ0FBQ1MsS0FBRCxDQUFSLElBQW1CLFVBQVVBLEtBTG5CLEdBTXBCb0UsSUFBSSxDQUFDc0IsSUFBTCxPQUFBdEIsSUFBSSw4QkFBU3JGLE1BQU0sQ0FBQ3dULE1BQVAsQ0FBY3ZTLEtBQWQsQ0FBVCxFQU5nQixHQVFoQnFpQyxXQVJnQixHQVNuQmorQixJQUFJLENBQUNpTSxFQUFFLENBQUN1eEIsV0FBSCxDQUFlL2pDLENBQUMsQ0FBQzRELENBQWpCLEVBQW9CZ2MsRUFBcEIsQ0FBRCxDQUFKLEdBQWdDemQsS0FUYixHQVduQm9FLElBQUksQ0FBQ3NCLElBQUwsQ0FBVTFGLEtBQVYsQ0FYbUI7QUFjckIsT0FkRCxDQUhvQixFQW1CcEJvK0IsRUFBRSxDQUFDcDRCLENBQUMsQ0FBQzBLLEVBQUgsQ0FBRixHQUFXdE0sSUFuQlM7QUFvQnBCLEtBcEJELENBc0JBLEVBQU9nNkIsRUFBUDtBQUNBLEdBdmM4QjtBQXljL0J5RyxxQkF6YytCLCtCQXljWDF3QixPQXpjVyxFQXljRjJ3QixPQXpjRSxFQXljTztBQUFBLFFBRWpDdnlCLE1BRmlDO0FBQUEsUUFDL0I0ckIsR0FBRyxHQUFHcC9CLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbVYsT0FBWixDQUR5Qjs7QUFJckMsU0FBSyxJQUFJaFQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2c5QixHQUFHLENBQUN0L0IsTUFBeEIsRUFBZ0NzQyxDQUFDLEVBQWpDLEVBQXFDO0FBQ3BDb1IsWUFBTSxHQUFHNEIsT0FBTyxDQUFDZ3FCLEdBQUcsQ0FBQ2g5QixDQUFELENBQUosQ0FBUCxDQUFnQm9SLE1BRFc7O0FBR3BDLFdBQUssSUFBSWdzQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaHNCLE1BQU0sQ0FBQzFULE1BQTNCLEVBQW1DMC9CLENBQUMsRUFBcEMsRUFDQyxJQUFJdUcsT0FBTyxDQUFDdnlCLE1BQU0sQ0FBQ2dzQixDQUFELENBQU4sQ0FBVXYrQixLQUFYLENBQVgsRUFDQztBQUdGOztBQUVEO0FBQ0EsR0F4ZDhCO0FBMGQvQitrQyxpQkExZCtCLDZCQTBkYjtBQUNqQixXQUFPLEtBQUs3dEIsbUJBQUwsR0FBMkJyWSxNQUEzQixHQUFvQyxDQUEzQztBQUNBLEdBNWQ4QjtBQThkL0JtbUMsMkJBOWQrQixxQ0E4ZEw3d0IsT0E5ZEssRUE4ZEk7QUFDbEMsV0FBTyxLQUFLMHdCLG1CQUFMLENBQXlCMXdCLE9BQXpCLEVBQWtDLFVBQUF0VyxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxHQUFHLENBQVI7QUFBQSxLQUFuQyxDQUFQO0FBQ0EsR0FoZThCO0FBa2UvQm9uQywyQkFsZStCLHFDQWtlTDl3QixPQWxlSyxFQWtlSTtBQUNsQyxXQUFPLEtBQUswd0IsbUJBQUwsQ0FBeUIxd0IsT0FBekIsRUFBa0MsVUFBQXRXLENBQUM7QUFBQSxhQUFJQSxDQUFDLEdBQUcsQ0FBUjtBQUFBLEtBQW5DLENBQVA7QUFDQSxHQXBlOEI7QUFzZS9CcW5DLGFBdGUrQix1QkFzZW5COS9CLElBdGVtQixFQXNlYjtBQUFBLFFBQ1g2RCxNQUFNLEdBQUcsS0FBS0EsTUFESDtBQUFBLFFBRVhrOEIsS0FBSyxHQUFHbDhCLE1BQU0sQ0FBQzhuQixVQUZKO0FBSWpCLFdBQU9oekIsUUFBUSxDQUFDb25DLEtBQUQsQ0FBUixJQUFtQkEsS0FBSyxDQUFDdHNCLFdBQU4sT0FBd0J6VCxJQUFsRDtBQUNBLEdBM2U4QjtBQTZlL0JnZ0MsYUE3ZStCLHlCQTZlakI7QUFDYixXQUFPLEtBQUtGLFdBQUwsQ0FBaUIsTUFBakIsQ0FBUDtBQUNBLEdBL2U4QjtBQWlmL0JHLFlBamYrQix3QkFpZmxCO0FBQ1osV0FBTyxLQUFLSCxXQUFMLENBQWlCLEtBQWpCLENBQVA7QUFDQSxHQW5mOEI7O0FBcWYvQjs7Ozs7O0FBTUFJLGNBM2YrQix3QkEyZmxCQyxZQTNma0IsRUEyZko7QUFBQSxRQUNwQmwxQixFQUFFLEdBQUcsSUFEZTtBQUFBLFFBRXBCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGUTtBQUFBLFFBR3BCa0wsT0FBTyxHQUFHLDRCQUFJb3hCLFlBQVAsQ0FIYTtBQUFBLFFBSXBCQyxRQUFRLEdBQUduMUIsRUFBRSxDQUFDZzFCLFVBQUgsRUFKUztBQUFBLFFBS3BCSSxTQUFTLEdBQUdwMUIsRUFBRSxDQUFDKzBCLFdBQUgsRUFMUTs7QUFpQnhCO0FBRUYsV0FaSUksUUFBUSxJQUFJQyxTQVloQixHQVhDdHhCLE9BQU8sQ0FBQ2pQLElBQVIsQ0FBYSxVQUFDNmpCLEVBQUQsRUFBSzJjLEVBQUwsRUFBWTtBQUFBLFVBQ2xCQyxPQUFPLEdBQUcsVUFBQ3ppQyxDQUFELEVBQUlzQixDQUFKO0FBQUEsZUFBVXRCLENBQUMsR0FBRzdFLElBQUksQ0FBQ210QixHQUFMLENBQVNobkIsQ0FBQyxDQUFDeEUsS0FBWCxDQUFkO0FBQUEsT0FEUTtBQUFBLFVBRWxCNGxDLEtBQUssR0FBRzdjLEVBQUUsQ0FBQ3hXLE1BQUgsQ0FBVWhPLE1BQVYsQ0FBaUJvaEMsT0FBakIsRUFBMEIsQ0FBMUIsQ0FGVTtBQUFBLFVBR2xCRSxLQUFLLEdBQUdILEVBQUUsQ0FBQ256QixNQUFILENBQVVoTyxNQUFWLENBQWlCb2hDLE9BQWpCLEVBQTBCLENBQTFCLENBSFU7O0FBS3hCLGFBQU9ILFFBQVEsR0FBR0ssS0FBSyxHQUFHRCxLQUFYLEdBQW1CQSxLQUFLLEdBQUdDLEtBQTFDO0FBQ0EsS0FORCxDQVdELEdBSlcvbkMsVUFBVSxDQUFDbUwsTUFBTSxDQUFDOG5CLFVBQVIsQ0FJckIsSUFIQzVjLE9BQU8sQ0FBQ2pQLElBQVIsQ0FBYStELE1BQU0sQ0FBQzhuQixVQUFwQixDQUdELEVBQU81YyxPQUFQO0FBQ0EsR0EvZ0I4QjtBQWloQi9CMnRCLFdBamhCK0IscUJBaWhCckIzdEIsT0FqaEJxQixFQWloQloxUyxDQWpoQlksRUFpaEJUO0FBQ3JCLFdBQU82QyxVQUFVLENBQUM2UCxPQUFPLENBQUNwVCxHQUFSLENBQVksVUFBQWlGLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUN1TSxNQUFOO0FBQUEsS0FBYixDQUFELENBQVYsQ0FBdUNsTyxNQUF2QyxDQUE4QyxVQUFBeEcsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQzRELENBQUYsR0FBTUEsQ0FBTixLQUFZLENBQWhCO0FBQUEsS0FBL0MsQ0FBUDtBQUNBLEdBbmhCOEI7QUFxaEIvQnFrQyxrQkFyaEIrQiw0QkFxaEJkMWhDLElBcmhCYyxFQXFoQlI7QUFBQTs7QUFDdEIsV0FBT0EsSUFBSSxDQUFDQyxNQUFMLENBQVksVUFBQTNGLENBQUM7QUFBQSxhQUFJZCxPQUFPLENBQUMsTUFBSSxDQUFDNnRCLFlBQUwsQ0FBa0Ivc0IsQ0FBbEIsQ0FBRCxDQUFYO0FBQUEsS0FBYixDQUFQO0FBQ0EsR0F2aEI4QjtBQXloQi9Cd2dDLGlCQXpoQitCLDJCQXloQmYvcUIsT0F6aEJlLEVBeWhCTmtwQixPQXpoQk0sRUF5aEJHO0FBQ2pDLFdBQU9scEIsT0FBTyxDQUFDcFQsR0FBUixDQUFZLFVBQUFpRixDQUFDO0FBQUEsYUFBSztBQUN4QjBLLFVBQUUsRUFBRTFLLENBQUMsQ0FBQzBLLEVBRGtCO0FBRXhCc3lCLGNBQU0sRUFBRWg5QixDQUFDLENBQUNnOUIsTUFGYztBQUd4Qnp3QixjQUFNLEVBQUV2TSxDQUFDLENBQUN1TSxNQUFGLENBQVNsTyxNQUFULENBQWdCLFVBQUF4RyxDQUFDO0FBQUEsaUJBQUl3L0IsT0FBTyxDQUFDLENBQUQsQ0FBUCxJQUFjeC9CLENBQUMsQ0FBQzRELENBQWhCLElBQXFCNUQsQ0FBQyxDQUFDNEQsQ0FBRixJQUFPNDdCLE9BQU8sQ0FBQyxDQUFELENBQXZDO0FBQUEsU0FBakI7QUFIZ0IsT0FBTDtBQUFBLEtBQWIsQ0FBUDtBQUtBLEdBL2hCOEI7QUFpaUIvQnhXLGNBamlCK0IsMEJBaWlCaEI7QUFDZCxRQUFNa2YsVUFBVSxHQUFHLEtBQUs5OEIsTUFBTCxDQUFZd1ksV0FBL0I7QUFFQSxXQUFRdGpCLFNBQVMsQ0FBQzRuQyxVQUFELENBQVQsSUFBeUJBLFVBQTFCLElBQ0xwbkMsWUFBWSxDQUFDb25DLFVBQUQsQ0FBWixJQUE0QjdtQyxRQUFRLENBQUM2bUMsVUFBRCxDQUR0QztBQUVBLEdBdGlCOEI7QUF3aUIvQmpHLG9CQXhpQitCLDhCQXdpQlo5OUIsR0F4aUJZLEVBd2lCUHVKLEdBeGlCTyxFQXdpQkYzTCxHQXhpQkUsRUF3aUJHO0FBQUEsUUFDM0J5USxFQUFFLEdBQUcsSUFEc0I7QUFBQSxRQUUzQjB2QixPQUFPLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZpQjtBQWVqQyxXQVZBMXZCLEVBQUUsQ0FBQ2tILFdBQUgsQ0FBZTlVLE1BQWYsQ0FBc0IsS0FBdEIsRUFBNkJ5SyxTQUE3QixDQUF1QyxRQUF2QyxFQUNFOUksSUFERixDQUNPLENBQUNwQyxHQUFELEVBQU11SixHQUFOLENBRFAsRUFFRTRCLEtBRkYsR0FHRS9MLE1BSEYsQ0FHUyxNQUhULEVBSUU1RSxJQUpGLENBSU8sVUFBQWtDLENBQUM7QUFBQSxhQUFJMlIsRUFBRSxDQUFDMjFCLGVBQUgsQ0FBbUJ0bkMsQ0FBQyxDQUFDZ1MsRUFBckIsRUFBeUJoUyxDQUF6QixDQUFKO0FBQUEsS0FKUixFQUtFaU8sSUFMRixDQUtPLFVBQVNqTyxDQUFULEVBQVl5QyxDQUFaLEVBQWU7QUFDcEI0K0IsYUFBTyxDQUFDNStCLENBQUQsQ0FBUCxHQUFhLEtBQUtXLHFCQUFMLEdBQTZCbEMsR0FBN0IsSUFSSyxHQU9FO0FBRXBCLEtBUEYsRUFRRWdPLE1BUkYsRUFVQSxFQUFPbXlCLE9BQVA7QUFDQSxHQXhqQjhCO0FBMGpCL0JrRyxXQTFqQitCLHFCQTBqQnJCdm5DLENBMWpCcUIsRUEwakJsQjtBQUNaLFdBQU8sS0FBSzZsQyxTQUFMLENBQWUsS0FBS25nQyxJQUFMLENBQVUrUCxPQUF6QixFQUFrQ3pWLENBQUMsQ0FBQ2dTLEVBQXBDLENBQVA7QUFDQSxHQTVqQjhCO0FBOGpCL0J3MUIsT0E5akIrQixpQkE4akJ6QnhuQyxDQTlqQnlCLEVBOGpCdEI7QUFDUixXQUFPLFVBQVVBLENBQVYsSUFBZSxLQUFLNmxDLFNBQUwsQ0FBZSxLQUFLbmdDLElBQUwsQ0FBVStQLE9BQXpCLEVBQWtDelYsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFBekMsQ0FBdEI7QUFDQSxHQWhrQjhCO0FBa2tCL0J5MUIsbUJBbGtCK0IsNkJBa2tCYjV6QixNQWxrQmEsRUFra0JMdkUsS0Fsa0JLLEVBa2tCRTtBQUFBLFFBRzVCN00sQ0FINEI7QUFBQSxRQUMxQmlsQyxPQUFPLEdBQUc3ekIsTUFBTSxDQUFDdkUsS0FBRCxDQUFOLENBQWN2TSxDQURFO0FBQUEsUUFFMUI0a0MsS0FBSyxHQUFHLEVBRmtCOztBQUtoQyxTQUFLbGxDLENBQUMsR0FBRzZNLEtBQUssR0FBRyxDQUFqQixFQUFvQjdNLENBQUMsSUFBSSxDQUF6QixNQUNLaWxDLE9BQU8sS0FBSzd6QixNQUFNLENBQUNwUixDQUFELENBQU4sQ0FBVU0sQ0FEM0IsR0FBNEJOLENBQUMsRUFBN0IsRUFLQ2tsQyxLQUFLLENBQUMzZ0MsSUFBTixDQUFXNk0sTUFBTSxDQUFDcFIsQ0FBRCxDQUFqQixDQUxEOztBQVFBLFNBQUtBLENBQUMsR0FBRzZNLEtBQVQsRUFBZ0I3TSxDQUFDLEdBQUdvUixNQUFNLENBQUMxVCxNQUEzQixNQUNLdW5DLE9BQU8sS0FBSzd6QixNQUFNLENBQUNwUixDQUFELENBQU4sQ0FBVU0sQ0FEM0IsR0FBbUNOLENBQUMsRUFBcEMsRUFLQ2tsQyxLQUFLLENBQUMzZ0MsSUFBTixDQUFXNk0sTUFBTSxDQUFDcFIsQ0FBRCxDQUFqQixDQUxEOztBQVFBLFdBQU9rbEMsS0FBUDtBQUNBLEdBeGxCOEI7QUEwbEIvQkMsd0JBMWxCK0Isa0NBMGxCUm55QixPQTFsQlEsRUEwbEJDdkYsR0ExbEJELEVBMGxCTTtBQUFBLFFBQzlCeUIsRUFBRSxHQUFHLElBRHlCO0FBQUEsUUFFOUJrMkIsVUFBVSxHQUFHcHlCLE9BQU8sQ0FBQ3BULEdBQVIsQ0FBWSxVQUFBeEUsTUFBTTtBQUFBLGFBQUk4VCxFQUFFLENBQUNtMkIsV0FBSCxDQUFlanFDLE1BQU0sQ0FBQ2dXLE1BQXRCLEVBQThCM0QsR0FBOUIsQ0FBSjtBQUFBLEtBQWxCLENBRmlCO0FBRTBDO0FBRTlFO0FBQ0EsV0FBT3lCLEVBQUUsQ0FBQ20yQixXQUFILENBQWVELFVBQWYsRUFBMkIzM0IsR0FBM0IsQ0FBUDtBQUNBLEdBaG1COEI7QUFrbUIvQjQzQixhQWxtQitCLHVCQWttQm5CajBCLE1BbG1CbUIsRUFrbUJYM0QsR0FsbUJXLEVBa21CTjtBQUFBLFFBR3BCNjNCLE9BSG9CO0FBQUEsUUFDbEJwMkIsRUFBRSxHQUFHLElBRGE7QUFBQSxRQUVwQnEyQixPQUFPLEdBQUdyMkIsRUFBRSxDQUFDcEgsTUFBSCxDQUFVeXRCLGlCQUZBO0FBNEJ4QixXQXRCQW5rQixNQUFNLENBQ0psTyxNQURGLENBQ1MsVUFBQXhHLENBQUM7QUFBQSxhQUFJQSxDQUFDLElBQUl3UyxFQUFFLENBQUM4VyxTQUFILENBQWF0cEIsQ0FBQyxDQUFDNlMsRUFBZixDQUFUO0FBQUEsS0FEVixFQUVFeFEsT0FGRixDQUVVLFVBQUFyQyxDQUFDLEVBQUk7QUFDYixVQUFNN0IsS0FBSyxHQUFHcVUsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUM3SixJQUF6QixTQUFnQ3dYLEVBQUUsQ0FBQ3MyQix1QkFBSCxDQUEyQjlvQyxDQUFDLENBQUM2UyxFQUE3QixDQUFoQyxlQUFxRWhPLGNBQUssQ0FBQzlKLEdBQTNFLGNBQWtGaUYsQ0FBQyxDQUFDbVEsS0FBcEYsR0FBNkZwTixJQUE3RixFQUFkO0FBRUksT0FBQzZsQyxPQUFELElBQVlwMkIsRUFBRSxDQUFDdTJCLFdBQUgsQ0FBZTVxQyxLQUFmLENBSEgsS0FJWnlxQyxPQUFPLEdBQUc1b0MsQ0FKRTtBQU1iLEtBUkYsQ0FzQkEsRUFYQTBVLE1BQU0sQ0FDSmxPLE1BREYsQ0FDUyxVQUFBeEcsQ0FBQztBQUFBLGFBQUlBLENBQUMsSUFBSSxDQUFDd1MsRUFBRSxDQUFDOFcsU0FBSCxDQUFhdHBCLENBQUMsQ0FBQzZTLEVBQWYsQ0FBVjtBQUFBLEtBRFYsRUFFRXhRLE9BRkYsQ0FFVSxVQUFBckMsQ0FBQyxFQUFJO0FBQ2IsVUFBTWEsQ0FBQyxHQUFHMlIsRUFBRSxDQUFDdzJCLElBQUgsQ0FBUWhwQyxDQUFSLEVBQVcrUSxHQUFYLENBQVY7QUFFSWxRLE9BQUMsR0FBR2dvQyxPQUhLLEtBSVpBLE9BQU8sR0FBR2hvQyxDQUpFLEVBS1orbkMsT0FBTyxHQUFHNW9DLENBTEU7QUFPYixLQVRGLENBV0EsRUFBTzRvQyxPQUFQO0FBQ0EsR0EvbkI4QjtBQWlvQi9CSSxNQWpvQitCLGdCQWlvQjFCemlDLElBam9CMEIsRUFpb0JwQndLLEdBam9Cb0IsRUFpb0JmO0FBQUEsUUFDVHlCLEVBQUUsR0FBRyxJQURJO0FBQUEsUUFFVEUsU0FBUyxHQUFHRixFQUFFLENBQUNwSCxNQUFILENBQVV1SCxZQUZiO0FBQUEsUUFJVHMyQixNQUFNLEdBQUd2MkIsU0FBUyxHQUFHLENBQUgsR0FBTyxDQUpoQjtBQUFBLFFBS1R3MkIsTUFBTSxHQUFHeDJCLFNBQVMsR0FBRyxDQUFILEdBQU8sQ0FMaEI7QUFBQSxRQU1UN08sQ0FBQyxHQUFHMk8sRUFBRSxDQUFDMFosT0FBSCxDQUFXM2xCLElBQVgsRUFBaUJBLElBQUksQ0FBQzRKLEtBQXRCLENBTks7QUFBQSxRQU9Udk0sQ0FBQyxHQUFHLENBQUM0TyxFQUFFLENBQUNtRCxTQUFILElBQWdCbkQsRUFBRSxDQUFDNU8sQ0FBcEIsRUFBdUIyQyxJQUFJLENBQUMzQyxDQUE1QixDQVBLO0FBU2YsV0FBT3BELElBQUksQ0FBQzJvQyxJQUFMLENBQVUzb0MsSUFBSSxDQUFDNG9DLEdBQUwsQ0FBU3hsQyxDQUFDLEdBQUdtTixHQUFHLENBQUNrNEIsTUFBRCxDQUFoQixFQUEwQixDQUExQixJQUErQnpvQyxJQUFJLENBQUM0b0MsR0FBTCxDQUFTdmxDLENBQUMsR0FBR2tOLEdBQUcsQ0FBQ200QixNQUFELENBQWhCLEVBQTBCLENBQTFCLENBQXpDLENBQVA7QUFDQSxHQTNvQjhCOztBQTZvQi9COzs7Ozs7QUFNQUcscUJBbnBCK0IsK0JBbXBCWDMwQixNQW5wQlcsRUFtcEJIO0FBQUEsUUFDckJsQyxFQUFFLEdBQUcsSUFEZ0I7QUFBQSxRQUVyQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlM7QUFBQSxRQUlyQnNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSkU7QUFBQSxRQUtyQjIyQixRQUFRLEdBQUdsK0IsTUFBTSxDQUFDZ3VCLGNBTEc7QUFBQSxRQU1yQm5rQixhQUFhLEdBQUd6QyxFQUFFLENBQUN5QyxhQUFILEVBTks7QUFBQSxRQVFyQnMwQixTQUFTLEdBQUdqb0MsT0FBTyxDQUFDb1QsTUFBRCxDQUFQLEdBQWtCQSxNQUFNLENBQUMxTyxNQUFQLEVBQWxCLEdBQW9DLENBQUMwTyxNQUFELENBUjNCO0FBVTNCLFFBQUksQ0FBQ2hDLFNBQUQsSUFBYyxDQUFDdUMsYUFBbkIsRUFDQyxPQUFPUCxNQUFQLENBWDBCLENBYzNCOztBQWQyQixRQWVyQjdCLEVBQUUsR0FBRzAyQixTQUFTLENBQUMsQ0FBRCxDQUFULENBQWExMkIsRUFmRztBQUFBLFFBa0J2QmpQLENBQUMsR0FBRzJsQyxTQUFTLENBQUMsQ0FBRCxDQUFULENBQWEzbEMsQ0FBYixHQUFpQixDQWxCRTtBQUFBLFFBbUJ2QnpCLEtBQUssR0FBR29uQyxTQUFTLENBQUMsQ0FBRCxDQUFULENBQWFwbkMsS0FuQkUsRUFpQjNCOztBQWtCQSxXQWRBOFMsYUFBYSxJQUFJczBCLFNBQVMsQ0FBQ245QixPQUFWLENBQWtCO0FBQUN4SSxPQUFDLEVBQURBLENBQUQ7QUFBSXpCLFdBQUssRUFBTEEsS0FBSjtBQUFXMFEsUUFBRSxFQUFGQTtBQUFYLEtBQWxCLENBY2pCLEVBWkF5MkIsUUFBUSxLQUFLLFlBQWIsSUFDQ0MsU0FBUyxDQUFDbjlCLE9BQVYsQ0FBa0I7QUFBQ3hJLE9BQUMsRUFBRUEsQ0FBQyxHQUFHLENBQVI7QUFBV3pCLFdBQUssRUFBTEEsS0FBWDtBQUFrQjBRLFFBQUUsRUFBRkE7QUFBbEIsS0FBbEIsQ0FXRCxFQVJBalAsQ0FBQyxHQUFHMmxDLFNBQVMsQ0FBQ3ZvQyxNQVFkLEVBUEFtQixLQUFLLEdBQUdvbkMsU0FBUyxDQUFDM2xDLENBQUMsR0FBRyxDQUFMLENBQVQsQ0FBaUJ6QixLQU96QixFQUxBOFMsYUFBYSxJQUFJczBCLFNBQVMsQ0FBQzFoQyxJQUFWLENBQWU7QUFBQ2pFLE9BQUMsRUFBREEsQ0FBRDtBQUFJekIsV0FBSyxFQUFMQSxLQUFKO0FBQVcwUSxRQUFFLEVBQUZBO0FBQVgsS0FBZixDQUtqQixFQUhBeTJCLFFBQVEsS0FBSyxhQUFiLElBQ0NDLFNBQVMsQ0FBQzFoQyxJQUFWLENBQWU7QUFBQ2pFLE9BQUMsRUFBRUEsQ0FBQyxHQUFHLENBQVI7QUFBV3pCLFdBQUssRUFBTEEsS0FBWDtBQUFrQjBRLFFBQUUsRUFBRkE7QUFBbEIsS0FBZixDQUVELEVBQU8wMkIsU0FBUDtBQUNBLEdBdnJCOEI7QUF5ckIvQkMsc0JBenJCK0IsZ0NBeXJCVjkwQixNQXpyQlUsRUF5ckJGO0FBQUEsUUFDdEI2MEIsU0FBUyxHQUFHam9DLE9BQU8sQ0FBQ29ULE1BQUQsQ0FBUCxHQUFrQkEsTUFBTSxDQUFDMU8sTUFBUCxFQUFsQixHQUFvQyxDQUFDME8sTUFBRCxDQUQxQjtBQUFBLFFBRXRCKzBCLE1BQU0sR0FBRyxFQUZhO0FBb0I1QixXQWhCQUYsU0FBUyxDQUFDbG5DLE9BQVYsQ0FBa0IsVUFBQXFKLEtBQUssRUFBSTtBQUFBLFVBQ25COUgsQ0FEbUIsR0FDVjhILEtBRFUsQ0FDbkI5SCxDQURtQjtBQUFBLFVBQ2hCaVAsRUFEZ0IsR0FDVm5ILEtBRFUsQ0FDaEJtSCxFQURnQjtBQUcxQjQyQixZQUFNLENBQUM1aEMsSUFBUCxDQUFZO0FBQ1hqRSxTQUFDLEVBQURBLENBRFc7QUFFWGlQLFVBQUUsRUFBRkEsRUFGVztBQUdYMVEsYUFBSyxFQUFFdUosS0FBSyxDQUFDdkosS0FBTixDQUFZLENBQVo7QUFISSxPQUFaLENBSDBCLEVBUzFCc25DLE1BQU0sQ0FBQzVoQyxJQUFQLENBQVk7QUFDWGpFLFNBQUMsRUFBREEsQ0FEVztBQUVYaVAsVUFBRSxFQUFGQSxFQUZXO0FBR1gxUSxhQUFLLEVBQUV1SixLQUFLLENBQUN2SixLQUFOLENBQVksQ0FBWjtBQUhJLE9BQVosQ0FUMEI7QUFjMUIsS0FkRCxDQWdCQSxFQUFPc25DLE1BQVA7QUFDQSxHQTlzQjhCO0FBZ3RCL0JDLHNCQWh0QitCLGdDQWd0QlYva0MsSUFodEJVLEVBZ3RCSmdsQyxLQWh0QkksRUFndEJHO0FBQUEsUUFDM0JuM0IsRUFBRSxHQUFHLElBRHNCO0FBQUEsUUFFM0JwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZlO0FBQUEsUUFHM0J3K0IsT0FBTyxHQUFHeCtCLE1BQU0sZ0JBQVN6RyxJQUFULEVBSFc7QUFBQSxXQUs3QnZFLFdBQVcsQ0FBQ3VwQyxLQUFELENBTGtCLEdBTXpCQyxPQU55QixJQVNqQzFvQyxNQUFNLENBQUNDLElBQVAsQ0FBWXdvQyxLQUFaLEVBQW1CdG5DLE9BQW5CLENBQTJCLFVBQUF3USxFQUFFLEVBQUk7QUFDaEMrMkIsYUFBTyxDQUFDLzJCLEVBQUQsQ0FBUCxHQUFjODJCLEtBQUssQ0FBQzkyQixFQUFELENBRGE7QUFFaEMsS0FGRCxDQVRpQyxFQWFqQ0wsRUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQUMrSixnQkFBVTtBQUFYLEtBQVYsQ0FiaUMsRUFlMUI0YyxPQWYwQjtBQWdCakMsR0FodUI4QjtBQWt1Qi9CcEUsa0JBbHVCK0IsNEJBa3VCZDNrQyxDQWx1QmMsRUFrdUJYMEcsSUFsdUJXLEVBa3VCTDtBQUN6QixRQUFNcEYsS0FBSyxHQUFHdEIsQ0FBQyxDQUFDc0IsS0FBaEI7O0FBRUEsUUFBSWIsT0FBTyxDQUFDYSxLQUFELENBQVgsRUFBb0I7QUFDbkIsVUFBTWdPLEtBQUssR0FBRyxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXVCaFcsT0FBdkIsQ0FBK0JvTixJQUEvQixDQUFkO0FBRUEsYUFBTzRJLEtBQUssS0FBSyxDQUFDLENBQVgsR0FBZSxJQUFmLEdBQXNCaE8sS0FBSyxDQUFDZ08sS0FBRCxDQUFsQztBQUNBOztBQUVELFdBQU9oTyxLQUFLLENBQUNvRixJQUFELENBQVo7QUFDQSxHQTV1QjhCOztBQTh1Qi9COzs7Ozs7OztBQVFBc2lDLFVBdHZCK0Isb0JBc3ZCdEJ0aUMsSUF0dkJzQixFQXN2QmhCMUcsQ0F0dkJnQixFQXN2QmJpcEMsU0F0dkJhLEVBc3ZCRjtBQUFBLFFBQ3RCdDNCLEVBQUUsR0FBRyxJQURpQjtBQUFBLFFBRXRCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVTtBQUFBLFFBR3RCcUssR0FBRyxHQUFHakQsRUFBRSxDQUFDaUQsR0FIYTtBQUFBLFFBSXhCdXNCLEtBQUssR0FBRyxDQUpnQjs7QUFNNUIsUUFBSW5oQyxDQUFDLElBQUk0VSxHQUFHLENBQUNsUCxJQUFKLENBQVN3akMsS0FBVCxDQUFlcm5DLElBQWYsQ0FBb0IrUyxHQUFwQixFQUF5QnpVLE1BQWxDLEVBQTBDO0FBQ3pDLFVBQU1ncEMsVUFBVSxHQUFHdjBCLEdBQUcsQ0FBQ2xQLElBQUosQ0FBU21PLE1BQVQsQ0FBZ0IxRyxJQUFoQixDQUFxQnlILEdBQXJCLENBQW5CO0FBSUEsVUFGQXVzQixLQUFLLEdBQUduaEMsQ0FBQyxDQUFDbWhDLEtBQUYsSUFBV25oQyxDQUFDLENBQUNzQixLQUVyQixFQUFJb0YsSUFBSSxLQUFLLEtBQWI7QUFDQztBQUNBLGNBQUlpTCxFQUFFLENBQUN5M0IsR0FBSCxDQUFPQyxRQUFQLElBQUosRUFBeUI7QUFDeEIsZ0JBQUk1RCxLQUFLLEdBQUc5ekIsRUFBRSxDQUFDNHpCLGVBQUgsRUFBWjtBQUVJNXpCLGNBQUUsQ0FBQ3VMLGVBQUgsQ0FBbUIvYyxNQUhDLEtBSXZCc2xDLEtBQUssSUFBSTBELFVBQVUsQ0FBQ3gzQixFQUFFLENBQUN1TCxlQUFKLENBQVYsQ0FBK0JyWCxNQUEvQixDQUFzQyxVQUFDckIsQ0FBRCxFQUFJc0IsQ0FBSjtBQUFBLHFCQUFVdEIsQ0FBQyxHQUFHc0IsQ0FBZDtBQUFBLGFBQXRDLENBSmMsR0FPeEJxN0IsS0FBSyxHQUFHbmhDLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVW1rQyxLQVBNO0FBVXhCLFdBVkQsTUFXQ3RFLEtBQUssR0FBRyxDQUFDbmhDLENBQUMsQ0FBQ3NwQyxRQUFGLEdBQWF0cEMsQ0FBQyxDQUFDdXBDLFVBQWhCLEtBQ1A1cEMsSUFBSSxDQUFDaVEsRUFBTCxJQUFXK0IsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsS0FBdUIsQ0FBQ2hWLE1BQU0sQ0FBQythLGdCQUEvQixHQUFrRCxDQUFsRCxHQUFzRCxDQUFqRSxDQURPLENBWFQ7QUFGRCxhQWlCTyxJQUFJNWUsSUFBSSxLQUFLLE9BQWIsRUFBc0I7QUFDNUIsWUFBSSsrQixNQUFLLEdBQUcsS0FBS0wsZ0JBQUwsRUFBWjs7QUFFQSxZQUFJenpCLEVBQUUsQ0FBQ3VMLGVBQUgsQ0FBbUIvYyxNQUF2QixFQUErQjtBQUM5QixjQUFJcXBDLFNBQVMsR0FBR0wsVUFBVSxDQUFDeDNCLEVBQUUsQ0FBQ3VMLGVBQUosS0FBMUI7QUFFSXNzQixtQkFBUyxDQUFDcnBDLE1BSGdCLEtBSTdCcXBDLFNBQVMsR0FBR0EsU0FBUyxDQUNuQjNqQyxNQURVLENBQ0gsVUFBQ3VrQixHQUFELEVBQU1xZixJQUFOO0FBQUEsbUJBQWVyZixHQUFHLENBQUMvbkIsR0FBSixDQUFRLFVBQUNsRCxDQUFELEVBQUlzRCxDQUFKO0FBQUEscUJBQVUsQ0FBQ25ELFFBQVEsQ0FBQ0gsQ0FBRCxDQUFSLEdBQWNBLENBQWQsR0FBa0IsQ0FBbkIsSUFBd0JzcUMsSUFBSSxDQUFDaG5DLENBQUQsQ0FBdEM7QUFBQSxhQUFSLENBQWY7QUFBQSxXQURHLENBSmlCLEVBTzdCZ2pDLE1BQUssR0FBR0EsTUFBSyxDQUFDcGpDLEdBQU4sQ0FBVSxVQUFDbEQsQ0FBRCxFQUFJc0QsQ0FBSjtBQUFBLG1CQUFVdEQsQ0FBQyxHQUFHcXFDLFNBQVMsQ0FBQy9tQyxDQUFELENBQXZCO0FBQUEsV0FBVixDQVBxQjtBQVM5Qjs7QUFFRHpDLFNBQUMsQ0FBQ21oQyxLQUFGLEdBQVU3aEMsUUFBUSxDQUFDVSxDQUFDLENBQUNzQixLQUFILENBQVIsSUFBcUJta0MsTUFBckIsSUFBOEJBLE1BQUssQ0FBQ3psQyxDQUFDLENBQUNzUCxLQUFILENBQUwsR0FBaUIsQ0FBL0MsR0FDVHRQLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVW1rQyxNQUFLLENBQUN6bEMsQ0FBQyxDQUFDc1AsS0FBSCxDQUROLEdBQ2tCLENBZkEsRUFpQjVCNnhCLEtBQUssR0FBR25oQyxDQUFDLENBQUNtaEMsS0FqQmtCO0FBa0I1QixPQWxCTSxNQWtCSXo2QixJQUFJLEtBQUssT0FsQmIsS0FtQk55NkIsS0FBSyxHQUFJdUksVUFBVSxDQUFDL3BDLElBQUksQ0FBQ2tOLEdBQUwsQ0FBUzdNLENBQUMsQ0FBQ3NCLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBRCxDQUFWLEdBQW1DcVEsRUFBRSxDQUFDZzRCLFFBQXZDLEdBQW1EcC9CLE1BQU0sQ0FBQ294QixnQkFuQjVEO0FBcUJQOztBQUVELFdBQU9zTixTQUFTLElBQUk5SCxLQUFiLEdBQXFCQSxLQUFLLEdBQUcsR0FBN0IsR0FBbUNBLEtBQTFDO0FBQ0E7QUExeUI4QixDQUExQixDOzs7OztBQ3pCTjs7OztBQUlBO0FBTUE7QUFDQTtBQUVBNzhCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7Ozs7O0FBT0E5VixhQVIrQix1QkFRbkJsWixJQVJtQixFQVFid3RCLFFBUmEsRUFRSDtBQUFBLFFBRXZCMXBCLElBRnVCO0FBQUEsUUFDckJpTSxFQUFFLEdBQUcsSUFEZ0I7QUFtQjNCLFFBZkkvUCxJQUFJLENBQUM4YyxNQWVULElBZENoWixJQUFJLEdBQUcsRUFjUixFQVpDLENBQUMsS0FBRCxFQUFRLFVBQVIsRUFBb0IsU0FBcEIsRUFBK0IsTUFBL0IsRUFBdUMsTUFBdkMsRUFBK0MsTUFBL0MsRUFBdUQsTUFBdkQsRUFBK0QsU0FBL0QsRUFDRWxFLE9BREYsQ0FDVSxVQUFBckMsQ0FBQyxFQUFJO0FBQ2IsVUFBTStCLEdBQUcsa0JBQVcvQixDQUFYLENBQVQ7QUFFSStCLFNBQUcsSUFBSVUsSUFIRSxLQUlaOEQsSUFBSSxDQUFDdkcsQ0FBRCxDQUFKLEdBQVV5QyxJQUFJLENBQUNWLEdBQUQsQ0FKRjtBQU1iLEtBUEYsQ0FZRCxJQUhDd0UsSUFBSSxHQUFHOUQsSUFHUixFQUFJOEQsSUFBSSxDQUFDeUIsR0FBTCxJQUFZaW9CLFFBQWhCLEVBQ0N6ZCxFQUFFLENBQUNpNEIsZ0JBQUgsQ0FBb0Jsa0MsSUFBSSxDQUFDeUIsR0FBekIsRUFBOEJ6QixJQUFJLENBQUNta0MsUUFBbkMsRUFBNkNua0MsSUFBSSxDQUFDb2tDLE9BQWxELEVBQTJEcGtDLElBQUksQ0FBQ3BGLElBQWhFLEVBQXNFOHVCLFFBQXRFLENBREQsTUFFTyxJQUFJMXBCLElBQUksQ0FBQ3FrQyxJQUFULEVBQ05ya0MsSUFBSSxHQUFHaU0sRUFBRSxDQUFDcTRCLGlCQUFILENBQXFCdGtDLElBQUksQ0FBQ3FrQyxJQUExQixFQUFnQ3JrQyxJQUFJLENBQUNwRixJQUFyQyxDQURELE1BRUEsSUFBSW9GLElBQUksQ0FBQ3VrQyxJQUFULEVBQ052a0MsSUFBSSxHQUFHaU0sRUFBRSxDQUFDdTRCLGlCQUFILENBQXFCeGtDLElBQUksQ0FBQ3VrQyxJQUExQixDQURELE1BRUEsSUFBSXZrQyxJQUFJLENBQUN5a0MsT0FBVCxFQUNOemtDLElBQUksR0FBR2lNLEVBQUUsQ0FBQ3k0QixvQkFBSCxDQUF3QjFrQyxJQUFJLENBQUN5a0MsT0FBN0IsQ0FERCxNQUVBLElBQUl2b0MsSUFBSSxDQUFDOGMsTUFBVCxFQUNOLE1BQU0yckIsS0FBSyxDQUFDLDZDQUFELENBQVg7QUFHRCxXQUFPM2tDLElBQVA7QUFDQSxHQXhDOEI7QUEwQy9Ca2tDLGtCQTFDK0IsNEJBMENkemlDLEdBMUNjLEVBMEM4QjtBQUFBO0FBQUEsUUFBdkMwaUMsUUFBdUMsdUVBQTVCLEtBQTRCO0FBQUEsUUFBckJDLE9BQXFCO0FBQUEsUUFBWnhwQyxJQUFZO0FBQUEsUUFBTml2QixJQUFNO0FBQUEsUUFDdEQrYSxHQUFHLEdBQUcsSUFBSUMsY0FBSixFQURnRDs7QUFHeERULFdBSHdELElBSTNEenBDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZd3BDLE9BQVosRUFBcUJ0b0MsT0FBckIsQ0FBNkIsVUFBQU4sR0FBRyxFQUFJO0FBQ25Db3BDLFNBQUcsQ0FBQ0UsZ0JBQUosQ0FBcUJ0cEMsR0FBckIsRUFBMEI0b0MsT0FBTyxDQUFDNW9DLEdBQUQsQ0FBakMsQ0FEbUM7QUFFbkMsS0FGRCxDQUoyRCxFQVM1RG9wQyxHQUFHLENBQUNHLElBQUosQ0FBUyxLQUFULEVBQWdCdGpDLEdBQWhCLENBVDRELEVBVTVEbWpDLEdBQUcsQ0FBQ0ksa0JBQUosR0FBeUIsWUFBTTtBQUM5QixVQUFJSixHQUFHLENBQUNLLFVBQUosS0FBbUIsQ0FBdkIsRUFDQyxJQUFJTCxHQUFHLENBQUNNLE1BQUosS0FBZSxHQUFuQixFQUF3QjtBQUN2QixZQUFNQyxRQUFRLEdBQUdQLEdBQUcsQ0FBQ1EsWUFBckI7QUFFQUQsZ0JBQVEsSUFBSXRiLElBQUksQ0FBQzF0QixJQUFMLENBQVUsS0FBVixFQUNYLEtBQUksa0JBQVc0QyxVQUFVLENBQUNvbEMsUUFBRCxDQUFyQixZQUFKLENBQ0NBLFFBQVEsS0FBSyxNQUFiLEdBQXNCa0IsSUFBSSxDQUFDQyxLQUFMLENBQVdILFFBQVgsQ0FBdEIsR0FBNkNBLFFBRDlDLEVBRUN2cUMsSUFGRCxDQURXLENBSFc7QUFRdkIsT0FSRCxNQVNDLE1BQU0sSUFBSStwQyxLQUFKLFdBQWFsakMsR0FBYixxQ0FBTjtBQUdGLEtBeEIyRCxFQTBCNURtakMsR0FBRyxDQUFDVyxJQUFKLEVBMUI0RDtBQTJCNUQsR0FyRThCO0FBdUUvQkMsc0JBdkUrQixnQ0F1RVZDLE1BdkVVLEVBdUVGQyxHQXZFRSxFQXVFRztBQUFBLFFBRTdCcHJDLENBRjZCO0FBQUEsUUFDM0JpcUMsSUFBSSxHQUFHa0IsTUFBTSxDQUFDbEIsSUFBUCxDQUFZbUIsR0FBWixDQURvQjtBQWNqQyxXQVZJbkIsSUFBSSxDQUFDOXBDLE1BQUwsS0FBZ0IsQ0FVcEIsSUFUQ0gsQ0FBQyxHQUFHLENBQUMsRUFBRCxDQVNMLEVBUENpcUMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRem9DLE9BQVIsQ0FBZ0IsVUFBQXdRLEVBQUUsRUFBSTtBQUNyQmhTLE9BQUMsQ0FBQyxDQUFELENBQUQsQ0FBS2dTLEVBQUwsSUFBVyxJQURVO0FBRXJCLEtBRkQsQ0FPRCxJQUhDaFMsQ0FBQyxHQUFHbXJDLE1BQU0sQ0FBQ0gsS0FBUCxDQUFhSSxHQUFiLENBR0wsRUFBT3ByQyxDQUFQO0FBQ0EsR0F0RjhCO0FBd0YvQnFyQyxrQkF4RitCLDRCQXdGZEQsR0F4RmMsRUF3RlQ7QUFDckIsV0FBTyxLQUFLRixvQkFBTCxDQUEwQjtBQUNoQ2pCLFVBQUksRUFBRXFCLDZFQUQwQjtBQUVoQ04sV0FBSyxFQUFFTyx5RUFBVUE7QUFGZSxLQUExQixFQUdKSCxHQUhJLENBQVA7QUFJQSxHQTdGOEI7QUErRi9CSSxrQkEvRitCLDRCQStGZEMsR0EvRmMsRUErRlQ7QUFDckIsV0FBTyxLQUFLUCxvQkFBTCxDQUEwQjtBQUNoQ2pCLFVBQUksRUFBRXlCLDZFQUQwQjtBQUVoQ1YsV0FBSyxFQUFFVyx5RUFBVUE7QUFGZSxLQUExQixFQUdKRixHQUhJLENBQVA7QUFJQSxHQXBHOEI7QUFzRy9CekIsbUJBdEcrQiw2QkFzR2JELElBdEdhLEVBc0dQNkIsU0F0R08sRUFzR0k7QUFBQSxRQUc5QkMsVUFIOEI7QUFBQSxRQUk5Qm5tQyxJQUo4QjtBQUFBO0FBQUEsUUFDNUI2RSxNQUFNLEdBQUcsS0FBS0EsTUFEYztBQUFBLFFBRTVCdWhDLE9BQU8sR0FBRyxFQUZrQjs7QUFNbEMsUUFBSXJyQyxPQUFPLENBQUNzcEMsSUFBRCxDQUFYLEVBQW1CO0FBQ2xCLFVBQU16cEMsSUFBSSxHQUFHc3JDLFNBQVMsSUFBSXJoQyxNQUFNLENBQUNtcEIsU0FBakM7QUFFSXB6QixVQUFJLENBQUN5QyxDQUhTLElBSWpCOG9DLFVBQVUsR0FBR3ZyQyxJQUFJLENBQUNnQixLQUFMLENBQVc2RCxNQUFYLENBQWtCN0UsSUFBSSxDQUFDeUMsQ0FBdkIsQ0FKSSxFQUtqQndILE1BQU0sQ0FBQ21pQixNQUFQLEdBQWdCcHNCLElBQUksQ0FBQ3lDLENBTEosSUFPakI4b0MsVUFBVSxHQUFHdnJDLElBQUksQ0FBQ2dCLEtBUEQsRUFVbEJ3cUMsT0FBTyxDQUFDOWtDLElBQVIsQ0FBYTZrQyxVQUFiLENBVmtCLEVBWWxCOUIsSUFBSSxDQUFDdm9DLE9BQUwsQ0FBYSxVQUFBN0ksQ0FBQyxFQUFJO0FBQ2pCLFlBQU1vekMsTUFBTSxHQUFHRixVQUFVLENBQUN4cEMsR0FBWCxDQUFlLFVBQUFuQixHQUFHLEVBQUk7QUFDcEM7QUFDQSxjQUFJL0IsQ0FBQyxHQUFHLE1BQUksQ0FBQzZzQyxlQUFMLENBQXFCcnpDLENBQXJCLEVBQXdCdUksR0FBeEIsQ0FBUjs7QUFNQSxpQkFKSTNCLFdBQVcsQ0FBQ0osQ0FBRCxDQUlmLEtBSENBLENBQUMsR0FBRyxJQUdMLEdBQU9BLENBQVA7QUFDQSxTQVRjLENBQWY7QUFXQTJzQyxlQUFPLENBQUM5a0MsSUFBUixDQUFhK2tDLE1BQWIsQ0FaaUI7QUFhakIsT0FiRCxDQVprQixFQTJCbEJybUMsSUFBSSxHQUFHLEtBQUt3a0MsaUJBQUwsQ0FBdUI0QixPQUF2QixDQTNCVztBQTRCbEIsS0E1QkQsTUE2QkN6ckMsTUFBTSxDQUFDQyxJQUFQLENBQVl5cEMsSUFBWixFQUFrQnZvQyxPQUFsQixDQUEwQixVQUFBTixHQUFHLEVBQUk7QUFDaEMsVUFBTStxQyxHQUFHLEdBQUdsQyxJQUFJLENBQUM3b0MsR0FBRCxDQUFKLENBQVVpRSxNQUFWLEVBQVo7QUFFQThtQyxTQUFHLENBQUMxZ0MsT0FBSixDQUFZckssR0FBWixDQUhnQyxFQUloQzRxQyxPQUFPLENBQUM5a0MsSUFBUixDQUFhaWxDLEdBQWIsQ0FKZ0M7QUFLaEMsS0FMRCxDQTdCRCxFQW9DQ3ZtQyxJQUFJLEdBQUcsS0FBSzBrQyxvQkFBTCxDQUEwQjBCLE9BQTFCLENBcENSOztBQXVDQSxXQUFPcG1DLElBQVA7QUFDQSxHQXBKOEI7QUFzSi9Cc21DLGlCQXRKK0IsMkJBc0pmRSxNQXRKZSxFQXNKUHJwQyxJQXRKTyxFQXNKRDtBQUM3QixRQUFJcXBDLE1BQU0sQ0FBQ3JwQyxJQUFELENBQU4sS0FBaUIrRCxTQUFyQixFQUNDLE9BQU9zbEMsTUFBTSxDQUFDcnBDLElBQUQsQ0FBYjtBQUY0QixRQUt2QnNwQyxhQUFhLEdBQUd0cEMsSUFBSSxDQUFDYixPQUFMLENBQWEsWUFBYixFQUEyQixLQUEzQixDQUxPO0FBQUEsUUFNdkJvcUMsU0FBUyxHQUFHRCxhQUFhLENBQUNucUMsT0FBZCxDQUFzQixLQUF0QixFQUE2QixFQUE3QixFQUFpQ08sS0FBakMsQ0FBdUMsR0FBdkMsQ0FOVztBQUFBLFFBT3pCMUUsTUFBTSxHQUFHcXVDLE1BUGdCLEVBSzRCOztBQVN6RCxXQUxBRSxTQUFTLENBQUNDLElBQVYsQ0FBZSxVQUFBck0sQ0FBQztBQUFBLGFBQUksRUFDbkJuaUMsTUFBTSxHQUFHQSxNQUFNLElBQUltaUMsQ0FBQyxJQUFJbmlDLE1BQWYsR0FDUkEsTUFBTSxDQUFDbWlDLENBQUQsQ0FERSxHQUNJcDVCLFNBRk0sQ0FBSjtBQUFBLEtBQWhCLENBS0EsRUFBTy9JLE1BQVA7QUFDQSxHQXJLOEI7QUF1Sy9CcXNDLG1CQXZLK0IsNkJBdUtiRCxJQXZLYSxFQXVLUDtBQUFBLFFBQ2pCM3BDLElBQUksR0FBRzJwQyxJQUFJLENBQUMsQ0FBRCxDQURNO0FBQUEsUUFFakI2QixPQUFPLEdBQUcsRUFGTzs7QUFJdkIsU0FBSyxJQUFJcnBDLENBQUMsR0FBRyxDQUFSLEVBQVc2cEMsSUFBSSxHQUFHckMsSUFBSSxDQUFDOXBDLE1BQTVCLEVBQW9Dc0MsQ0FBQyxHQUFHNnBDLElBQXhDLEVBQThDN3BDLENBQUMsRUFBL0MsRUFBbUQ7QUFDbEQsVUFBTXNwQyxNQUFNLEdBQUcsRUFBZjs7QUFFQSxXQUFLLElBQUlsTSxDQUFDLEdBQUcsQ0FBUixFQUFXME0sSUFBSSxHQUFHdEMsSUFBSSxDQUFDeG5DLENBQUQsQ0FBSixDQUFRdEMsTUFBL0IsRUFBdUMwL0IsQ0FBQyxHQUFHME0sSUFBM0MsRUFBaUQxTSxDQUFDLEVBQWxELEVBQXNEO0FBQ3JELFlBQUl0Z0MsV0FBVyxDQUFDMHFDLElBQUksQ0FBQ3huQyxDQUFELENBQUosQ0FBUW85QixDQUFSLENBQUQsQ0FBZixFQUNDLE1BQU0sSUFBSXdLLEtBQUosa0RBQW9ENW5DLENBQXBELGVBQTBEbzlCLENBQTFELFFBQU47QUFHRGtNLGNBQU0sQ0FBQ3pyQyxJQUFJLENBQUN1L0IsQ0FBRCxDQUFMLENBQU4sR0FBa0JvSyxJQUFJLENBQUN4bkMsQ0FBRCxDQUFKLENBQVFvOUIsQ0FBUixDQUxtQztBQU1yRDs7QUFFRGlNLGFBQU8sQ0FBQzlrQyxJQUFSLENBQWEra0MsTUFBYixDQVhrRDtBQVlsRDs7QUFFRCxXQUFPRCxPQUFQO0FBQ0EsR0ExTDhCO0FBNEwvQjFCLHNCQTVMK0IsZ0NBNExWRCxPQTVMVSxFQTRMRDtBQUM3QixRQUFNMkIsT0FBTyxHQUFHLEVBQWhCOztBQUVBLFNBQUssSUFBSXJwQyxDQUFDLEdBQUcsQ0FBUixFQUFXNnBDLElBQUksR0FBR25DLE9BQU8sQ0FBQ2hxQyxNQUEvQixFQUF1Q3NDLENBQUMsR0FBRzZwQyxJQUEzQyxFQUFpRDdwQyxDQUFDLEVBQWxELEVBQXNEO0FBQ3JELFVBQU12QixHQUFHLEdBQUdpcEMsT0FBTyxDQUFDMW5DLENBQUQsQ0FBUCxDQUFXLENBQVgsQ0FBWjs7QUFFQSxXQUFLLElBQUlvOUIsQ0FBQyxHQUFHLENBQVIsRUFBVzBNLElBQUksR0FBR3BDLE9BQU8sQ0FBQzFuQyxDQUFELENBQVAsQ0FBV3RDLE1BQWxDLEVBQTBDMC9CLENBQUMsR0FBRzBNLElBQTlDLEVBQW9EMU0sQ0FBQyxFQUFyRCxFQUF5RDtBQUt4RCxZQUpJdGdDLFdBQVcsQ0FBQ3VzQyxPQUFPLENBQUNqTSxDQUFDLEdBQUcsQ0FBTCxDQUFSLENBSWYsS0FIQ2lNLE9BQU8sQ0FBQ2pNLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUIsRUFHbEIsR0FBSXRnQyxXQUFXLENBQUM0cUMsT0FBTyxDQUFDMW5DLENBQUQsQ0FBUCxDQUFXbzlCLENBQVgsQ0FBRCxDQUFmLEVBQ0MsTUFBTSxJQUFJd0ssS0FBSixrREFBb0Q1bkMsQ0FBcEQsZUFBMERvOUIsQ0FBMUQsUUFBTjtBQUdEaU0sZUFBTyxDQUFDak0sQ0FBQyxHQUFHLENBQUwsQ0FBUCxDQUFlMytCLEdBQWYsSUFBc0JpcEMsT0FBTyxDQUFDMW5DLENBQUQsQ0FBUCxDQUFXbzlCLENBQVgsQ0FUa0M7QUFVeEQ7QUFDRDs7QUFFRCxXQUFPaU0sT0FBUDtBQUNBLEdBaE44QjtBQWtOL0I5c0Isc0JBbE4rQixnQ0FrTlZ0WixJQWxOVSxFQWtOSjhtQyxRQWxOSSxFQWtOTTtBQUFBLFFBTWhDQyxNQU5nQztBQUFBO0FBQUEsUUFDOUI5NkIsRUFBRSxHQUFHLElBRHlCO0FBQUEsUUFFOUJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZrQjtBQUFBLFFBRzlCbWlDLFFBQVEsR0FBR3JzQyxNQUFNLENBQUNDLElBQVAsQ0FBWW9GLElBQUksQ0FBQyxDQUFELENBQUosSUFBVyxFQUF2QixDQUhtQjtBQUFBLFFBSTlCKzVCLEdBQUcsR0FBR2lOLFFBQVEsQ0FBQ3ZzQyxNQUFULEdBQWtCdXNDLFFBQVEsQ0FBQy9tQyxNQUFULENBQWdCZ00sRUFBRSxDQUFDa3hCLE1BQW5CLEVBQTJCbHhCLEVBQTNCLENBQWxCLEdBQW1ELEVBSjNCO0FBQUEsUUFLOUJvTixFQUFFLEdBQUcydEIsUUFBUSxDQUFDdnNDLE1BQVQsR0FBa0J1c0MsUUFBUSxDQUFDL21DLE1BQVQsQ0FBZ0JnTSxFQUFFLENBQUMrd0IsR0FBbkIsRUFBd0Ivd0IsRUFBeEIsQ0FBbEIsR0FBZ0QsRUFMdkI7O0FBU3BDOHRCLE9BQUcsQ0FBQ2orQixPQUFKLENBQVksVUFBQXdRLEVBQUUsRUFBSTtBQUNqQixVQUFNMjZCLElBQUksR0FBRyxNQUFJLENBQUM1SixPQUFMLENBQWEvd0IsRUFBYixDQUFiOztBQUVJLFlBQUksQ0FBQ295QixTQUFMLE1BQW9CLE1BQUksQ0FBQ3B2QixZQUFMLEVBSFAsR0FLWitKLEVBQUUsQ0FBQ3psQixPQUFILENBQVdxekMsSUFBWCxLQUFvQixDQUxSLEdBTWZGLE1BQU0sR0FBRyxDQUFFRCxRQUFRLElBQUk3NkIsRUFBRSxDQUFDak0sSUFBSCxDQUFRcVosRUFBUixDQUFXL00sRUFBWCxDQUFiLElBQWdDLEVBQWpDLEVBQ1A3TSxNQURPLENBRVBPLElBQUksQ0FBQ3JELEdBQUwsQ0FBUyxVQUFBckMsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQzJzQyxJQUFELENBQUw7QUFBQSxPQUFWLEVBQ0VobkMsTUFERixDQUNTekcsT0FEVCxFQUVFbUQsR0FGRixDQUVNLFVBQUM4aEMsSUFBRCxFQUFPMWhDLENBQVA7QUFBQSxlQUFha1AsRUFBRSxDQUFDc3lCLGVBQUgsQ0FBbUJFLElBQW5CLEVBQXlCbnlCLEVBQXpCLEVBQTZCdlAsQ0FBN0IsQ0FBYjtBQUFBLE9BRk4sQ0FGTyxDQU5NLEdBWUw4SCxNQUFNLENBQUNtaUIsTUFaRixHQWNmK2YsTUFBTSxHQUFHLE1BQUksQ0FBQ25KLGdCQUFMLEVBZE0sR0FlTDlpQyxRQUFRLENBQUMrSixNQUFNLENBQUNvaUIsT0FBUixDQWZILEtBaUJmOGYsTUFBTSxHQUFHOTZCLEVBQUUsQ0FBQ3F4QixnQkFBSCxDQUFvQjJKLElBQXBCLEVBQTBCaDdCLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQWxDLENBakJNLElBcUJoQmczQixNQUFNLEdBQUcvbUMsSUFBSSxDQUFDckQsR0FBTCxDQUFTLFVBQUNyQyxDQUFELEVBQUl5QyxDQUFKO0FBQUEsZUFBVUEsQ0FBVjtBQUFBLE9BQVQsQ0FyQk8sRUF3QmpCZ3FDLE1BQU0sS0FBSyxNQUFJLENBQUMvbUMsSUFBTCxDQUFVcVosRUFBVixDQUFhL00sRUFBYixJQUFtQnk2QixNQUF4QixDQXhCVztBQXlCakIsS0F6QkQsQ0FUb0MsRUFxQ3BDaE4sR0FBRyxDQUFDaitCLE9BQUosQ0FBWSxVQUFBd1EsRUFBRSxFQUFJO0FBQ2pCLFVBQUksQ0FBQ3k2QixNQUFMLEVBQ0MsTUFBTSxJQUFJcEMsS0FBSix1Q0FBd0NyNEIsRUFBeEMsU0FBTjtBQUVELEtBSkQsQ0FyQ29DO0FBMkNwQztBQUNBLFFBQU15RCxPQUFPLEdBQUdncUIsR0FBRyxDQUFDcDlCLEdBQUosQ0FBUSxVQUFDMlAsRUFBRCxFQUFLMUMsS0FBTCxFQUFlO0FBQUEsVUFDaENzOUIsV0FBVyxHQUFHcmlDLE1BQU0sQ0FBQ3NuQixnQkFBUCxDQUF3QjdmLEVBQXhCLENBRGtCO0FBQUEsVUFFaEMyNkIsSUFBSSxHQUFHaDdCLEVBQUUsQ0FBQ294QixPQUFILENBQVcvd0IsRUFBWCxDQUZ5QjtBQUFBLFVBR2hDb0MsYUFBYSxHQUFHekMsRUFBRSxDQUFDeXlCLFNBQUgsTUFBa0J6eUIsRUFBRSxDQUFDeUMsYUFBSCxFQUhGO0FBQUEsVUFJaEN5NEIsV0FBVyxHQUFHejRCLGFBQWEsSUFBSTFPLElBQUksQ0FBQ3JELEdBQUwsQ0FBUyxVQUFBbEQsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQzRELENBQU47QUFBQSxPQUFWLEVBQ25DdUQsS0FEbUMsQ0FDN0IsVUFBQW5ILENBQUM7QUFBQSxlQUFJb0wsTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCOXpCLE9BQXpCLENBQWlDNkYsQ0FBakMsSUFBc0MsQ0FBQyxDQUEzQztBQUFBLE9BRDRCLENBSkM7QUFPdEMsYUFBTztBQUNONlMsVUFBRSxFQUFFNDZCLFdBREU7QUFFTnRJLGNBQU0sRUFBRXR5QixFQUZGO0FBR042QixjQUFNLEVBQUVuTyxJQUFJLENBQUNyRCxHQUFMLENBQVMsVUFBQ3JDLENBQUQsRUFBSXlDLENBQUosRUFBVTtBQUFBLGNBR3RCTSxDQUhzQjtBQUFBLGNBQ3BCb2hDLElBQUksR0FBR25rQyxDQUFDLENBQUMyc0MsSUFBRCxDQURZO0FBQUEsY0FFdEJyckMsS0FBSyxHQUFHdEIsQ0FBQyxDQUFDZ1MsRUFBRCxDQUZhO0FBNkIxQixpQkF4QkExUSxLQUFLLEdBQUdBLEtBQUssS0FBSyxJQUFWLElBQW1CZixLQUFLLENBQUNlLEtBQUQsQ0FBeEIsR0FDR2IsT0FBTyxDQUFDYSxLQUFELENBQVAsSUFBbUJULFFBQVEsQ0FBQ1MsS0FBRCxDQUFSLElBQW1CQSxLQUFLLENBQUN3ckMsSUFBNUMsR0FBb0R4ckMsS0FBcEQsR0FBNEQsSUFEL0QsR0FDUCxDQUFDdEIsQ0FBQyxDQUFDZ1MsRUFBRCxDQXVCSCxFQXBCSW9DLGFBQWEsSUFBSTlFLEtBQUssS0FBSyxDQUEzQixJQUFnQyxDQUFDL1AsV0FBVyxDQUFDNGtDLElBQUQsQ0FvQmhELElBbkJLLENBQUMwSSxXQUFELElBQWdCdjlCLEtBQUssS0FBSyxDQUExQixJQUErQjdNLENBQUMsS0FBSyxDQW1CMUMsS0FsQkU4SCxNQUFNLENBQUM2aUIsaUJBQVAsR0FBMkIsRUFrQjdCLEdBZkNycUIsQ0FBQyxHQUFHd0gsTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCOXpCLE9BQXpCLENBQWlDNnFDLElBQWpDLENBZUwsRUFiS3BoQyxDQUFDLEtBQUssQ0FBQyxDQWFaLEtBWkVBLENBQUMsR0FBR3dILE1BQU0sQ0FBQzZpQixpQkFBUCxDQUF5Qmp0QixNQVkvQixFQVhFb0ssTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCcG1CLElBQXpCLENBQThCbTlCLElBQTlCLENBV0YsS0FSQ3BoQyxDQUFDLEdBQUc0TyxFQUFFLENBQUNzeUIsZUFBSCxDQUFtQkUsSUFBbkIsRUFBeUJueUIsRUFBekIsRUFBNkJ2UCxDQUE3QixDQVFMLEdBSklsRCxXQUFXLENBQUNTLENBQUMsQ0FBQ2dTLEVBQUQsQ0FBRixDQUFYLElBQXNCTCxFQUFFLENBQUNqTSxJQUFILENBQVFxWixFQUFSLENBQVcvTSxFQUFYLEVBQWU3UixNQUFmLElBQXlCc0MsQ0FJbkQsTUFIQ00sQ0FBQyxHQUFHNkQsU0FHTCxHQUFPO0FBQUM3RCxhQUFDLEVBQURBLENBQUQ7QUFBSXpCLGlCQUFLLEVBQUxBLEtBQUo7QUFBVzBRLGNBQUUsRUFBRTQ2QjtBQUFmLFdBQVA7QUFDQSxTQTlCTyxFQThCTGpuQyxNQTlCSyxDQThCRSxVQUFBeEcsQ0FBQztBQUFBLGlCQUFJSyxTQUFTLENBQUNMLENBQUMsQ0FBQzRELENBQUgsQ0FBYjtBQUFBLFNBOUJIO0FBSEYsT0FBUDtBQW1DQSxLQTFDZSxDQUFoQixDQTVDb0MsQ0F3RnBDOztBQWdDQSxXQS9CQTBTLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQThGLENBQUMsRUFBSTtBQUVoQmlELFlBQU0sQ0FBQ3FuQixVQUZTLEtBR25CdHFCLENBQUMsQ0FBQ3VNLE1BQUYsR0FBV3ZNLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBU3JOLElBQVQsQ0FBYyxVQUFDdW1DLEVBQUQsRUFBS0MsRUFBTCxFQUFZO0FBQUEsWUFDOUJ6cEIsRUFBRSxHQUFHd3BCLEVBQUUsQ0FBQ2hxQyxDQUFILElBQVFncUMsRUFBRSxDQUFDaHFDLENBQUgsS0FBUyxDQUFqQixHQUFxQmdxQyxFQUFFLENBQUNocUMsQ0FBeEIsR0FBNEJ5TyxRQURIO0FBQUEsWUFFOUJnUyxFQUFFLEdBQUd3cEIsRUFBRSxDQUFDanFDLENBQUgsSUFBUWlxQyxFQUFFLENBQUNqcUMsQ0FBSCxLQUFTLENBQWpCLEdBQXFCaXFDLEVBQUUsQ0FBQ2pxQyxDQUF4QixHQUE0QnlPLFFBRkg7QUFJcEMsZUFBTytSLEVBQUUsR0FBR0MsRUFBWjtBQUNBLE9BTFUsQ0FIUSxHQVlwQmxjLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBU3JTLE9BQVQsQ0FBaUIsVUFBQ3JDLENBQUQsRUFBSXNELENBQUo7QUFBQSxlQUFXdEQsQ0FBQyxDQUFDbVEsS0FBRixHQUFVN00sQ0FBckI7QUFBQSxPQUFqQixDQVpvQixFQWVwQmtQLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQVIsQ0FBV3pYLENBQUMsQ0FBQzBLLEVBQWIsRUFBaUJ4TCxJQUFqQixDQUFzQixVQUFDdW1DLEVBQUQsRUFBS0MsRUFBTDtBQUFBLGVBQVlELEVBQUUsR0FBR0MsRUFBakI7QUFBQSxPQUF0QixDQWZvQjtBQWdCcEIsS0FoQkQsQ0ErQkEsRUFaQXI3QixFQUFFLENBQUNzN0IsZ0JBQUgsR0FBc0J0N0IsRUFBRSxDQUFDMjBCLHlCQUFILENBQTZCN3dCLE9BQTdCLENBWXRCLEVBWEE5RCxFQUFFLENBQUN1N0IsZ0JBQUgsR0FBc0J2N0IsRUFBRSxDQUFDNDBCLHlCQUFILENBQTZCOXdCLE9BQTdCLENBV3RCLEVBUklsTCxNQUFNLENBQUMwbkIsU0FRWCxJQVBDdGdCLEVBQUUsQ0FBQ3c3QixhQUFILENBQWlCeDdCLEVBQUUsQ0FBQ3lOLFFBQUgsQ0FBWTNKLE9BQVosRUFDZjlQLE1BRGUsQ0FDUixVQUFBcU0sRUFBRTtBQUFBLGFBQUksRUFBRUEsRUFBRSxJQUFJekgsTUFBTSxDQUFDMm5CLFVBQWYsQ0FBSjtBQUFBLEtBRE0sQ0FBakIsRUFDNEMzbkIsTUFBTSxDQUFDMG5CLFNBRG5ELENBT0QsRUFGQXhjLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQXhCLENBQUM7QUFBQSxhQUFJMlIsRUFBRSxDQUFDd3pCLFFBQUgsQ0FBWW5sQyxDQUFDLENBQUNza0MsTUFBZCxFQUFzQnRrQyxDQUF0QixLQUFKO0FBQUEsS0FBakIsQ0FFQSxFQUFPeVYsT0FBUDtBQUNBO0FBM1U4QixDQUExQixDOztBQ2JOOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUFuUixNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQndjLE1BRCtCLGdCQUMxQkMsVUFEMEIsRUFDZHpyQyxJQURjLEVBQ1I7QUFBQSxRQUNoQitQLEVBQUUsR0FBRyxJQURXO0FBQUEsUUFFbEI4RCxPQUFPLEdBQUc0M0IsVUFGUTtBQWlDdEI7QUFHQTtBQWhDSTUzQixXQUprQixLQU1qQjdULElBQUksQ0FBQytELE1BTlksS0FPcEI4UCxPQUFPLEdBQUdBLE9BQU8sQ0FBQzlQLE1BQVIsQ0FBZS9ELElBQUksQ0FBQytELE1BQXBCLENBUFUsSUFXakIvRCxJQUFJLENBQUM4RSxJQUFMLElBQWE5RSxJQUFJLENBQUMwckMsS0FYRCxLQVlwQjczQixPQUFPLENBQUNqVSxPQUFSLENBQWdCLFVBQUE4RixDQUFDLEVBQUk7QUFDcEIsVUFBTVosSUFBSSxHQUFJOUUsSUFBSSxDQUFDMHJDLEtBQUwsSUFBYzFyQyxJQUFJLENBQUMwckMsS0FBTCxDQUFXaG1DLENBQUMsQ0FBQzBLLEVBQWIsQ0FBZixJQUFvQ3BRLElBQUksQ0FBQzhFLElBQXREO0FBRUFpTCxRQUFFLENBQUN3N0IsYUFBSCxDQUFpQjdsQyxDQUFDLENBQUMwSyxFQUFuQixFQUF1QnRMLElBQXZCLENBSG9CO0FBSXBCLEtBSkQsQ0Fab0IsRUFvQnJCaUwsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQmpVLE9BQWhCLENBQXdCLFVBQUF4QixDQUFDLEVBQUk7QUFDNUIsV0FBSyxJQUFJeUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dULE9BQU8sQ0FBQ3RWLE1BQTVCLEVBQW9Dc0MsQ0FBQyxFQUFyQyxFQUNDLElBQUl6QyxDQUFDLENBQUNnUyxFQUFGLEtBQVN5RCxPQUFPLENBQUNoVCxDQUFELENBQVAsQ0FBV3VQLEVBQXhCLEVBQTRCO0FBQzNCaFMsU0FBQyxDQUFDNlQsTUFBRixHQUFXNEIsT0FBTyxDQUFDaFQsQ0FBRCxDQUFQLENBQVdvUixNQURLLEVBRTNCNEIsT0FBTyxDQUFDMFosTUFBUixDQUFlMXNCLENBQWYsRUFBa0IsQ0FBbEIsQ0FGMkI7QUFHM0I7QUFDQTtBQUVGLEtBUkQsQ0FwQnFCLEVBOEJyQmtQLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsR0FBa0I5RCxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQWdCdFEsTUFBaEIsQ0FBdUJzUSxPQUF2QixDQTlCRyxHQWtDdEI5RCxFQUFFLENBQUNzUSxhQUFILENBQWlCdFEsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBekIsQ0FsQ3NCLEVBcUN0QjlELEVBQUUsQ0FBQ3lRLE1BQUgsQ0FBVTtBQUNURywwQkFBb0IsSUFEWDtBQUVURCx1QkFBaUIsSUFGUjtBQUdUNkosZ0JBQVU7QUFIRCxLQUFWLENBckNzQixFQTJDdEJ2cUIsSUFBSSxDQUFDMnRCLElBQUwsSUFBYTN0QixJQUFJLENBQUMydEIsSUFBTCxFQTNDUztBQTRDdEIsR0E3QzhCO0FBK0MvQmdlLGNBL0MrQix3QkErQ2xCM3JDLElBL0NrQixFQStDWjtBQUNsQixRQUFNK1AsRUFBRSxHQUFHLElBQVgsQ0FEa0IsQ0FHbEI7O0FBQ0EsUUFBS0EsRUFBRSxDQUFDcEgsTUFBUjtBQUtBb0gsUUFBRSxDQUFDNjdCLFVBQUgsRUFMQTtBQU9BLFVBQU05bkMsSUFBSSxHQUFHOUQsSUFBSSxDQUFDOEQsSUFBTCxJQUFhaU0sRUFBRSxDQUFDbUosV0FBSCxDQUFlbFosSUFBZixFQUFxQixVQUFBNUIsQ0FBQztBQUFBLGVBQUkyUixFQUFFLENBQUN5N0IsSUFBSCxDQUFRejdCLEVBQUUsQ0FBQ3FOLG9CQUFILENBQXdCaGYsQ0FBeEIsQ0FBUixFQUFvQzRCLElBQXBDLENBQUo7QUFBQSxPQUF0QixDQUExQjtBQUVBK1AsUUFBRSxDQUFDeTdCLElBQUgsQ0FBUTFuQyxJQUFJLEdBQUdpTSxFQUFFLENBQUNxTixvQkFBSCxDQUF3QnRaLElBQXhCLENBQUgsR0FBbUMsSUFBL0MsRUFBcUQ5RCxJQUFyRCxDQVRBO0FBQUEsS0FKa0IsQ0FRbEI7O0FBTUEsR0E3RDhCO0FBK0QvQjZyQyxRQS9EK0Isa0JBK0R4QkMsWUEvRHdCLEVBK0RWQyxZQS9EVSxFQStESTtBQUFBLFFBQzVCaDhCLEVBQUUsR0FBRyxJQUR1QjtBQUFBLFFBRTlCNGQsSUFBSSxHQUFHb2UsWUFGdUI7QUFBQSxRQUc5QjNILFNBQVMsR0FBRzBILFlBSGtCO0FBZWxDO0FBZmtDLFdBTWxDLzdCLEVBQUUsQ0FBQzY3QixVQUFILEVBTmtDLEVBUTdCamUsSUFSNkIsS0FTakNBLElBQUksR0FBRyxZQUFNLENBQUUsQ0FUa0IsR0FhbEN5VyxTQUFTLEdBQUdBLFNBQVMsQ0FBQ3JnQyxNQUFWLENBQWlCLFVBQUFxTSxFQUFFO0FBQUEsYUFBSUwsRUFBRSxDQUFDazBCLFNBQUgsQ0FBYWwwQixFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFyQixFQUE4QnpELEVBQTlCLENBQUo7QUFBQSxLQUFuQixDQWJzQixFQWdCN0JnMEIsU0FBRCxJQUFjQSxTQUFTLENBQUM3bEMsTUFBVixLQUFxQixDQWhCTCxTQXFCbEN3UixFQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLENBQWlCdzNCLFNBQVMsQ0FBQzNqQyxHQUFWLENBQWMsVUFBQTJQLEVBQUU7QUFBQSxhQUFJTCxFQUFFLENBQUNpOEIsY0FBSCxDQUFrQjU3QixFQUFsQixDQUFKO0FBQUEsS0FBaEIsQ0FBakIsRUFDRWxHLFVBREYsR0FFRWhFLEtBRkYsQ0FFUSxTQUZSLEVBRW1CLEdBRm5CLEVBR0VvSCxNQUhGLEdBSUVyTixJQUpGLENBSU84UCxFQUFFLENBQUNrOEIsTUFKVixFQUlrQnRlLElBSmxCLENBckJrQyxFQTJCbEN5VyxTQUFTLENBQUN4a0MsT0FBVixDQUFrQixVQUFBd1EsRUFBRSxFQUFJO0FBRXZCTCxRQUFFLENBQUN5TSxhQUFILENBQWlCcE0sRUFBakIsTUFGdUIsRUFJbkJMLEVBQUUsQ0FBQ3NSLE1BSmdCLElBS3RCdFIsRUFBRSxDQUFDc1IsTUFBSCxDQUFVelUsU0FBVixZQUF3QnhLLGNBQUssQ0FBQ3hILFVBQTlCLFNBQTJDbVYsRUFBRSxDQUFDczJCLHVCQUFILENBQTJCajJCLEVBQTNCLENBQTNDLEdBQTZFOUMsTUFBN0UsRUFMc0IsRUFRdkJ5QyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLEdBQWtCOUQsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQjlQLE1BQWhCLENBQXVCLFVBQUEyQixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDMEssRUFBRixLQUFTQSxFQUFiO0FBQUEsT0FBeEIsQ0FSSztBQVN2QixLQVRELENBM0JrQyxTQWlCakN1ZCxJQUFJLEVBakI2QjtBQXFDbEM7QUFwRzhCLENBQTFCLEM7O0FDUk47Ozs7QUFJQTtBQUNBO0FBRUFqckIsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I7Ozs7OztBQU1BeGEsY0FQK0Isd0JBT2xCM1QsQ0FQa0IsRUFPZjtBQUNmLFFBQU04SCxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7QUFFQSxXQUFPOUgsQ0FBQyxHQUFHOEgsTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCanRCLE1BQTdCLEdBQXNDb0ssTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCM3FCLENBQXpCLENBQXRDLEdBQW9FQSxDQUEzRTtBQUNBO0FBWDhCLENBQTFCLEM7Ozs7O0FDUE47Ozs7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE2QixNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQjs7Ozs7QUFLQS9PLGVBTitCLDJCQU1mO0FBQ2YsUUFBTWxRLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDekosS0FBekIsR0FDRW1JLE1BREYsQ0FDUyxHQURULEVBRUVDLElBRkYsQ0FFTyxPQUZQLEVBRWdCcUIsY0FBSyxDQUFDaEksVUFGdEIsRUFHRThMLEtBSEYsQ0FHUSxjQUhSLEVBR3dCLEdBSHhCLENBSGU7QUFPZixHQWI4Qjs7QUFlL0I7Ozs7QUFJQTRnQixpQkFuQitCLDZCQW1CYjtBQUFBLFFBSWJvbEIsZUFKYTtBQUFBLFFBQ1huOEIsRUFBRSxHQUFHLElBRE07QUFBQSxRQUVYcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGRDtBQUFBLFFBR1hvNUIsV0FBVyxHQUFHaHlCLEVBQUUsQ0FBQ2d5QixXQUFILEVBSEg7QUFBQSxRQU1YeEIsV0FBVyxHQUFHNTNCLE1BQU0sQ0FBQ2lTLFlBTlY7QUFBQSxRQU9YeGdCLFVBQVUsR0FBRzJWLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDaEksVUFBekIsR0FDakI4TCxLQURpQixDQUNYLFFBRFcsRUFDRHE2QixXQUFXLElBQUlBLFdBQVcsQ0FBQ3o3QixJQUFaLEtBQXFCLE1BQXBDLEdBQ2hCNkQsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQixXQUF0QixHQUFvQyxXQURwQixHQUViLElBSGMsRUFJakJnTixPQUppQixDQUlUOWEsY0FBSyxDQUFDL0gsa0JBSkcsRUFJaUIwbkMsV0FKakIsRUFLakI3a0IsT0FMaUIsQ0FLVDlhLGNBQUssQ0FBQzlILGdCQUxHLEVBS2UsQ0FBQ3luQyxXQUxoQixDQVBGO0FBb0JqQixRQUxBM25DLFVBQVUsQ0FBQ3dTLFNBQVgsWUFBeUJ4SyxjQUFLLENBQUNqSSxTQUEvQixHQUE0Q21ULE1BQTVDLEVBS0EsRUFGQXlDLEVBQUUsQ0FBQzVWLFNBQUgsR0FBZUMsVUFBVSxDQUFDd1MsU0FBWCxZQUF5QnhLLGNBQUssQ0FBQ2pJLFNBQS9CLEVBRWYsRUFBSTRuQyxXQUFKLEVBQ0NtSyxlQUFlLEdBQUduOEIsRUFBRSxDQUFDNVYsU0FBSCxDQUFhMkosSUFBYixDQUFrQixDQUFDLENBQUQsQ0FBbEIsQ0FEbkIsRUFLQ29vQyxlQUFlLEdBQUduOEIsRUFBRSxDQUFDbzhCLCtCQUFILENBQW1DRCxlQUFlLENBQUNyL0IsS0FBaEIsRUFBbkMsRUFDaEJDLEtBRGdCLENBQ1ZvL0IsZUFEVSxDQUxuQixNQU9PO0FBQ047QUFDQSxVQUFNRSxrQkFBa0IsR0FBR3I4QixFQUFFLENBQUMrekIscUJBQUgsQ0FBeUIvekIsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBakMsQ0FBM0I7QUFFQXpaLGdCQUFVLENBQUNpeUMsS0FBWCxDQUFpQkQsa0JBQWtCLEdBQUdBLGtCQUFrQixDQUFDbjZCLE1BQXRCLEdBQStCLEVBQWxFLENBSk0sRUFLTmxDLEVBQUUsQ0FBQzVWLFNBQUgsR0FBZUMsVUFBVSxDQUFDd1MsU0FBWCxZQUF5QnhLLGNBQUssQ0FBQ2pJLFNBQS9CLEVBTFQsRUFNTit4QyxlQUFlLEdBQUduOEIsRUFBRSxDQUFDNVYsU0FBSCxDQUFhMkosSUFBYixDQUFrQixVQUFBMUYsQ0FBQztBQUFBLGVBQUlBLENBQUo7QUFBQSxPQUFuQixDQU5aLEVBU044dEMsZUFBZSxDQUFDNytCLElBQWhCLEdBQXVCQyxNQUF2QixFQVRNLEVBWU40K0IsZUFBZSxHQUFHbjhCLEVBQUUsQ0FBQ3U4Qiw0QkFBSCxDQUFnQ0osZUFBZSxDQUFDci9CLEtBQWhCLEVBQWhDLEVBQ2hCQyxLQURnQixDQUNWby9CLGVBRFUsQ0FaWjtBQWNOO0FBRURuOEIsTUFBRSxDQUFDdzhCLGVBQUgsQ0FBbUJMLGVBQW5CLENBM0NpQixFQTZDYm44QixFQUFFLENBQUMwTSxTQUFILEtBQWlCLE9BQWpCLElBQTZCMU0sRUFBRSxDQUFDMEcsR0FBSCxDQUFPOEgsRUFBUCxDQUFVLHNCQUFWLENBQTdCLElBQW1FeE8sRUFBRSxDQUFDZ1MsVUFBSCxFQTdDdEQsSUE4Q2hCaFMsRUFBRSxDQUFDeThCLG9CQUFILENBQXdCekssV0FBeEIsQ0E5Q2dCO0FBZ0RqQixHQW5FOEI7QUFxRS9CeUssc0JBckUrQixnQ0FxRVZ6SyxXQXJFVSxFQXFFRztBQUFBLFFBeUM3QjBLLE9BekM2QjtBQUFBLFFBQzNCMThCLEVBQUUsR0FBRyxJQURzQjtBQUFBLFFBRTNCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGZTtBQUFBLFFBSTNCK2pDLFlBQVksR0FBRyxZQUFNO0FBQzFCLFVBQU1sbEMsS0FBSyxHQUFHekYsd0ZBQU8sQ0FBQ3VHLGNBQVIsQ0FBdUIsQ0FBdkIsQ0FBZDtBQUVBLGFBQU9nRSxpR0FBUSxDQUFDaFYsUUFBUSxDQUFDcTFDLGdCQUFULENBQTBCbmxDLEtBQUssQ0FBQ1YsT0FBaEMsRUFBeUNVLEtBQUssQ0FBQ1QsT0FBL0MsQ0FBRCxDQUFmO0FBQ0EsS0FSZ0M7QUFBQSxRQVUzQjZsQyxRQUFRLEdBQUcsVUFBQXp5QyxTQUFTLEVBQUk7QUFDN0IsVUFBSXVULEtBQUssR0FBR3ZULFNBQVMsSUFBSUEsU0FBUyxDQUFDNEcsSUFBVixDQUFlLE9BQWYsQ0FBYixJQUF3QzVHLFNBQVMsQ0FBQzRHLElBQVYsQ0FBZSxPQUFmLEVBQ2xEWCxPQURrRCxDQUMxQyxJQUFJcUksTUFBSixZQUFlckcsY0FBSyxDQUFDakksU0FBckIsWUFBdUMsR0FBdkMsQ0FEMEMsRUFDRyxFQURILElBQ1MsQ0FEN0Q7QUFPQSxjQUpJd0UsS0FBSyxDQUFDK08sS0FBRCxDQUFMLElBQWdCQSxLQUFLLEtBQUssSUFJOUIsTUFIQ0EsS0FBSyxHQUFHLENBQUMsQ0FHVixHQUFPQSxLQUFQO0FBQ0EsS0FuQmdDO0FBQUEsUUFxQjNCbS9CLFVBQVUsR0FBRyxVQUFBNXFDLE9BQU8sRUFBSTtBQUM3QixVQUFJOC9CLFdBQUosRUFDQ2h5QixFQUFFLENBQUMrOEIsdUJBQUgsQ0FBMkI3cUMsT0FBM0IsQ0FERCxNQUVPO0FBQUEsWUFDQTlILFNBQVMsR0FBR3V5QyxZQUFZLEVBRHhCO0FBQUEsWUFFQWgvQixLQUFLLEdBQUdrL0IsUUFBUSxDQUFDenlDLFNBQUQsQ0FGaEI7QUFJTjRWLFVBQUUsQ0FBQ2c5QixtQkFBSCxDQUF1QnIvQixLQUF2QixDQUpNLEVBTU5BLEtBQUssS0FBSyxDQUFDLENBQVgsR0FDQ3FDLEVBQUUsQ0FBQ2k5QixZQUFILEVBREQsR0FFQ2o5QixFQUFFLENBQUNrOUIsbUJBQUgsQ0FBdUJockMsT0FBdkIsRUFBZ0M5SCxTQUFoQyxFQUEyQ3VULEtBQTNDLENBUks7QUFTTjtBQUNELEtBbENnQztBQUFBLFFBc0MzQncvQixjQUFjLEdBQUd2a0MsTUFBTSxDQUFDd2xCLDJCQUFQLENBQW1DK2UsY0F0Q3pCO0FBQUEsUUF1QzNCQyxXQUFXLEdBQUl0dkMsU0FBUyxDQUFDcXZDLGNBQUQsQ0FBVCxJQUE2QkEsY0FBOUIsTUF2Q2E7QUFBQSxRQXdDM0JFLGdCQUFnQixHQUFJLENBQUN6dUMsS0FBSyxDQUFDdXVDLGNBQUQsQ0FBTixJQUEwQkEsY0FBM0IsSUFBOEMsSUF4Q3RDO0FBQUEsUUEyQzNCRyxZQUFZLEdBQUcsVUFBQXZyQyxLQUFLLEVBQUk7QUFBQSxVQUN2Qm9GLFNBQVMsR0FBR3BGLEtBQUssQ0FBQ2dELElBREs7QUFBQSxVQUV2QjBDLEtBQUssR0FBRzFGLEtBQUssQ0FBQ3dHLGNBQU4sQ0FBcUIsQ0FBckIsQ0FGZTtBQUFBLFVBR3ZCZ2xDLFNBQVMsR0FBRzlsQyxLQUFLLGlCQUFVbUIsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQixHQUF0QixHQUE0QixHQUF0QyxFQUhNO0FBTXpCaEosZUFBUyxLQUFLLFlBTlcsR0FPeEJpbUMsV0FQd0IsR0FRM0JyckMsS0FBSyxDQUFDb3JDLGNBQU4sRUFSMkIsR0FTakJFLGdCQUFnQixLQUFLLElBVEosS0FVM0JYLE9BQU8sR0FBR2EsU0FWaUIsSUFZbEJwbUMsU0FBUyxLQUFLLFdBWkksS0FheEJpbUMsV0FBVyxJQUFJVixPQUFPLE9BQXRCLElBQ0hXLGdCQUFnQixLQUFLLElBQXJCLElBQTZCcnZDLElBQUksQ0FBQ210QixHQUFMLENBQVN1aEIsT0FBTyxHQUFHYSxTQUFuQixLQUFpQ0YsZ0JBZG5DLE1BaUIzQlgsT0FBTyxLQWpCb0IsRUFrQjNCM3FDLEtBQUssQ0FBQ29yQyxjQUFOLEVBbEIyQjtBQXFCN0IsS0FoRWdDOztBQWtFakM7QUFDQW45QixNQUFFLENBQUMwRyxHQUFILENBQ0U4SCxFQURGLENBQ0ssMENBREwsRUFDaUQsWUFBVztBQUMxRCxVQUFNcGtCLFNBQVMsR0FBR3V5QyxZQUFZLEVBQTlCOztBQUVBLFVBQUksQ0FBQ3Z5QyxTQUFTLENBQUNELEtBQVYsRUFBRCxJQUFzQkMsU0FBUyxDQUFDK2lCLE9BQVYsQ0FBa0I5YSxjQUFLLENBQUNqSSxTQUF4QixDQUExQixFQUE4RDtBQUM3RCxZQUFJNFYsRUFBRSxDQUFDd0osUUFBSCxJQUFleEosRUFBRSxDQUFDeUosT0FBbEIsSUFBNkJ6SixFQUFFLENBQUNnUyxVQUFILEVBQWpDLEVBQ0M7QUFHRHNyQixvQkFBWSxDQUFDdHJDLHdGQUFELENBTGlELEVBTTdEOHFDLFVBQVUsQ0FBQyxJQUFELENBTm1EO0FBTzdELE9BUEQsTUFRQzk4QixFQUFFLENBQUNpOUIsWUFBSCxFQVJELEVBU0NqOUIsRUFBRSxDQUFDZzlCLG1CQUFILEVBVEQ7QUFXQSxLQWZGLEVBZ0JFeHVCLEVBaEJGLENBZ0JLLG9CQWhCTCxFQWdCMkIsWUFBTTtBQUMvQixVQUFNcGtCLFNBQVMsR0FBR3V5QyxZQUFZLEVBQTlCO0FBRUksT0FBQ3Z5QyxTQUFTLENBQUNELEtBQVYsRUFBRCxJQUFzQkMsU0FBUyxDQUFDK2lCLE9BQVYsQ0FBa0I5YSxjQUFLLENBQUNqSSxTQUF4QixDQUhLLEtBSTFCNFYsRUFBRSxDQUFDZ1MsVUFBSCxNQUFtQixDQUFDaFMsRUFBRSxDQUFDdzlCLFdBQXZCLElBQXNDeDlCLEVBQUUsQ0FBQzBKLFdBSmYsS0FLN0IxSixFQUFFLENBQUMwSixXQUFILEtBQW1CMUosRUFBRSxDQUFDMEosV0FBSCxLQUFuQixDQUw2QjtBQVEvQixLQXhCRixDQW5FaUM7QUE0RmpDLEdBaks4Qjs7QUFtSy9COzs7OztBQUtBOHlCLGlCQXhLK0IsMkJBd0tmTCxlQXhLZSxFQXdLRTtBQUFBLFFBTTVCL3FDLENBTjRCO0FBQUEsUUFPNUJDLENBUDRCO0FBQUEsUUFRNUJnSixDQVI0QjtBQUFBLFFBUzVCQyxDQVQ0QjtBQUFBLFFBQzFCMEYsRUFBRSxHQUFHLElBRHFCO0FBQUEsUUFFMUJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZjO0FBQUEsUUFHMUI2a0MsTUFBTSxHQUFHejlCLEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0JuRCxFQUFFLENBQUM1TyxDQUhGO0FBQUEsUUFJMUJzc0MsYUFBYSxHQUFHdkIsZUFBZSxJQUFJbjhCLEVBQUUsQ0FBQzVWLFNBQUgsQ0FBYTJKLElBQWIsRUFKVDtBQUFBLFFBSzFCbU0sU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFMTztBQVdoQyxRQUFJSCxFQUFFLENBQUNneUIsV0FBSCxFQUFKLEVBQ0M7QUFDQTVnQyxLQUFDLEdBQUcsQ0FGTCxFQUdDQyxDQUFDLEdBQUcsQ0FITCxFQUlDZ0osQ0FBQyxHQUFHMkYsRUFBRSxDQUFDMU8sS0FKUixFQUtDZ0osQ0FBQyxHQUFHMEYsRUFBRSxDQUFDek8sTUFMUixNQU1PO0FBQUEsVUFDRm9zQyxLQURFLEVBRUZDLEtBRkU7QUFJTixVQUFJNTlCLEVBQUUsQ0FBQ3lDLGFBQUgsRUFBSixFQUNDazdCLEtBQUssR0FBRzM5QixFQUFFLENBQUM2OUIsaUJBQUgsRUFEVCxFQUVDRCxLQUFLLEdBQUcsVUFBQXZ2QyxDQUFDO0FBQUEsZUFBSW92QyxNQUFNLENBQUNwdkMsQ0FBQyxDQUFDK0MsQ0FBSCxDQUFOLEdBQWV1c0MsS0FBSyxHQUFHLENBQTNCO0FBQUEsT0FGVixNQUdPO0FBRU4zOUIsVUFBRSxDQUFDNHlCLFFBQUgsRUFGTTs7QUFJTixZQUFNa0wsWUFBWSxHQUFHLFVBQUF6dkMsQ0FBQyxFQUFJO0FBQ3pCLGNBQU1zUCxLQUFLLEdBQUd0UCxDQUFDLENBQUNzUCxLQUFoQjtBQUVBLGlCQUFPO0FBQ05vZ0MsZ0JBQUksRUFBRS85QixFQUFFLENBQUM2eUIsUUFBSCxDQUFZbDFCLEtBQVosQ0FEQTtBQUVOcWdDLGdCQUFJLEVBQUVoK0IsRUFBRSxDQUFDOHlCLFFBQUgsQ0FBWW4xQixLQUFaO0FBRkEsV0FBUDtBQUlBLFNBUEQ7O0FBU0FnZ0MsYUFBSyxHQUFHLFVBQUF0dkMsQ0FBQyxFQUFJO0FBQ1osY0FBTStDLENBQUMsR0FBRzBzQyxZQUFZLENBQUN6dkMsQ0FBRCxDQUF0QixDQURZLENBR1o7O0FBSFksaUJBSVIrQyxDQUFDLENBQUMyc0MsSUFBRixLQUFXLElBQVgsSUFBbUIzc0MsQ0FBQyxDQUFDNHNDLElBQUYsS0FBVyxJQUp0QixHQUtKOTlCLFNBQVMsR0FBR0YsRUFBRSxDQUFDek8sTUFBTixHQUFleU8sRUFBRSxDQUFDMU8sS0FMdkIsSUFRUkYsQ0FBQyxDQUFDMnNDLElBQUYsS0FBVyxJQVJILEtBU1gzc0MsQ0FBQyxDQUFDMnNDLElBQUYsR0FBU04sTUFBTSxDQUFDbGtDLE1BQVAsR0FBZ0IsQ0FBaEIsQ0FURSxHQVlSbkksQ0FBQyxDQUFDNHNDLElBQUYsS0FBVyxJQVpILEtBYVg1c0MsQ0FBQyxDQUFDNHNDLElBQUYsR0FBU1AsTUFBTSxDQUFDbGtDLE1BQVAsR0FBZ0IsQ0FBaEIsQ0FiRSxHQWdCTHZMLElBQUksQ0FBQ2tOLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQ3VpQyxNQUFNLENBQUNyc0MsQ0FBQyxDQUFDNHNDLElBQUgsQ0FBTixHQUFpQlAsTUFBTSxDQUFDcnNDLENBQUMsQ0FBQzJzQyxJQUFILENBQXhCLElBQW9DLENBQWhELENBaEJLO0FBaUJaLFNBOUJLLEVBZ0NOSCxLQUFLLEdBQUcsVUFBQXZ2QyxDQUFDLEVBQUk7QUFBQSxjQUNOK0MsQ0FBQyxHQUFHMHNDLFlBQVksQ0FBQ3p2QyxDQUFELENBRFY7QUFBQSxjQUVONHZDLEtBQUssR0FBR2orQixFQUFFLENBQUNqTSxJQUFILENBQVFxWixFQUFSLENBQVcvZSxDQUFDLENBQUNnUyxFQUFiLEVBQWlCaFMsQ0FBQyxDQUFDc1AsS0FBbkIsQ0FGRjtBQUlaO0FBSlksaUJBS1J2TSxDQUFDLENBQUMyc0MsSUFBRixLQUFXLElBQVgsSUFBbUIzc0MsQ0FBQyxDQUFDNHNDLElBQUYsS0FBVyxJQUx0QixHQU1KLENBTkksSUFTUjVzQyxDQUFDLENBQUMyc0MsSUFBRixLQUFXLElBVEgsS0FVWDNzQyxDQUFDLENBQUMyc0MsSUFBRixHQUFTTixNQUFNLENBQUNsa0MsTUFBUCxHQUFnQixDQUFoQixDQVZFLEdBYUwsQ0FBQ2trQyxNQUFNLENBQUNRLEtBQUQsQ0FBTixHQUFnQlIsTUFBTSxDQUFDcnNDLENBQUMsQ0FBQzJzQyxJQUFILENBQXZCLElBQW1DLENBYjlCO0FBY1osU0E5Q0s7QUErQ047QUFFRDNzQyxPQUFDLEdBQUc4TyxTQUFTLEdBQUcsQ0FBSCxHQUFPMDlCLEtBeERkLEVBeUROdnNDLENBQUMsR0FBRzZPLFNBQVMsR0FBRzA5QixLQUFILEdBQVcsQ0F6RGxCLEVBMEROdmpDLENBQUMsR0FBRzZGLFNBQVMsR0FBR0YsRUFBRSxDQUFDMU8sS0FBTixHQUFjcXNDLEtBMURyQixFQTJETnJqQyxDQUFDLEdBQUc0RixTQUFTLEdBQUd5OUIsS0FBSCxHQUFXMzlCLEVBQUUsQ0FBQ3pPLE1BM0RyQjtBQTRETjtBQUVEbXNDLGlCQUFhLENBQUMxc0MsSUFBZCxDQUFtQixPQUFuQixFQUE0QmdQLEVBQUUsQ0FBQ2srQixVQUFILENBQWMxaUMsSUFBZCxDQUFtQndFLEVBQW5CLENBQTVCLEVBQ0VoUCxJQURGLENBQ08sR0FEUCxFQUNZSSxDQURaLEVBRUVKLElBRkYsQ0FFTyxHQUZQLEVBRVlLLENBRlosRUFHRUwsSUFIRixDQUdPLE9BSFAsRUFHZ0JxSixDQUhoQixFQUlFckosSUFKRixDQUlPLFFBSlAsRUFJaUJzSixDQUpqQixDQS9FZ0M7QUFvRmhDLEdBNVA4QjtBQThQL0I0aUMscUJBOVArQiwrQkE4UFhockMsT0E5UFcsRUE4UEY5SCxTQTlQRSxFQThQU3VULEtBOVBULEVBOFBnQjtBQUFBLFFBQ3hDcUMsRUFBRSxHQUFHLElBRG1DO0FBQUEsUUFFeENwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUY0QjtBQUFBLFFBR3hDdWxDLGtCQUFrQixHQUFHdmxDLE1BQU0sQ0FBQ21vQixzQkFIWTtBQUFBLFFBSXhDcWQsa0JBQWtCLEdBQUd4bEMsTUFBTSxDQUFDb29CLHNCQUpZO0FBQUEsUUFLeENxZCxnQkFBZ0IsR0FBR3psQyxNQUFNLENBQUN3eEIsZUFMYztBQUFBLFFBTXhDa1UsWUFBWSxHQUFHdCtCLEVBQUUsQ0FBQ2t5QixtQkFBSCxDQUF1QnYwQixLQUF2QixDQU55QjtBQVExQzBnQyxvQkFSMEMsS0FTN0NyK0IsRUFBRSxDQUFDdStCLFdBQUgsQ0FBZUQsWUFBZixFQUE2QnBzQyxPQUE3QixDQVQ2QyxFQVU3QzhOLEVBQUUsQ0FBQ3crQixjQUFILENBQWtCRixZQUFsQixDQVY2QyxFQVl6QyxDQUFDSCxrQkFBRCxJQUF1QkMsa0JBWmtCLEtBaUI5Q3ArQixFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDMUcsS0FBNUIsY0FBcUNnUyxLQUFyQyxHQUNFckIsSUFERixDQUNPLFlBQVc7QUFDaEJDLHVHQUFRLENBQUMsSUFBRCxDQUFSLENBQWU0USxPQUFmLENBQXVCOWEsY0FBSyxDQUFDakYsUUFBN0IsS0FEZ0IsRUFHWit3QyxrQkFIWSxJQUlmL3pDLFNBQVMsQ0FBQytMLEtBQVYsQ0FBZ0IsUUFBaEIsRUFBMEJpb0Msa0JBQWtCLEdBQUcsU0FBSCxHQUFlLElBQTNELENBSmUsRUFPWEMsZ0JBUFcsS0FRZnIrQixFQUFFLENBQUN5K0IsY0FBSCxFQVJlLEVBU2Z6K0IsRUFBRSxDQUFDNlYsV0FBSCxFQVRlLEVBV2YsQ0FBQ3VvQixrQkFBRCxJQUF1QnArQixFQUFFLENBQUMwK0IsaUJBQUgsQ0FBcUIvZ0MsS0FBckIsQ0FYUjtBQWFoQixLQWRGLEVBZUUzSixNQWZGLENBZVMsVUFBUzNGLENBQVQsRUFBWTtBQUNuQixhQUFPMlIsRUFBRSxDQUFDMitCLGFBQUgsQ0FBaUIsSUFBakIsRUFBdUJ0d0MsQ0FBdkIsQ0FBUDtBQUNBLEtBakJGLEVBa0JFNkIsSUFsQkYsQ0FrQk8sVUFBQTB1QyxRQUFRLEVBQUk7QUFDakIsVUFBTXZ3QyxDQUFDLEdBQUd1d0MsUUFBUSxDQUFDN3FDLElBQVQsRUFBVjtBQUVJb3FDLHdCQUFrQixLQUFLQyxrQkFBa0IsSUFBSXhsQyxNQUFNLENBQUNxb0IsMkJBQVAsQ0FBbUM1eUIsQ0FBbkMsQ0FBM0IsQ0FITCxJQUloQmpFLFNBQVMsQ0FBQytMLEtBQVYsQ0FBZ0IsUUFBaEIsRUFBMEIsU0FBMUIsQ0FKZ0IsRUFPWmtvQyxnQkFQWSxLQVFoQnIrQixFQUFFLENBQUN1K0IsV0FBSCxDQUFlbHdDLENBQWYsRUFBa0I2RCxPQUFsQixDQVJnQixFQVNoQjhOLEVBQUUsQ0FBQ3crQixjQUFILENBQWtCbndDLENBQWxCLENBVGdCLEVBV2hCMlIsRUFBRSxDQUFDNitCLGVBQUgsRUFYZ0IsRUFZaEJELFFBQVEsQ0FBQ3RpQyxJQUFULENBQWMsVUFBQWpPLENBQUM7QUFBQSxlQUFJMlIsRUFBRSxDQUFDMCtCLGlCQUFILENBQXFCL2dDLEtBQXJCLEVBQTRCdFAsQ0FBQyxDQUFDZ1MsRUFBOUIsQ0FBSjtBQUFBLE9BQWYsQ0FaZ0I7QUFjakIsS0FoQ0YsQ0FqQjhDO0FBa0Q5QyxHQWhUOEI7QUFrVC9CcStCLG1CQWxUK0IsNkJBa1RiL2dDLEtBbFRhLEVBa1ROMEMsRUFsVE0sRUFrVEZ5K0IsS0FsVEUsRUFrVEs7QUFBQSxRQUM3QjkrQixFQUFFLEdBQUcsSUFEd0I7QUFBQSxRQUU3QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmlCO0FBSW5DQSxVQUFNLENBQUMwdEIsMEJBQVAsSUFDQ3RtQixFQUFFLENBQUMrK0IsYUFBSCxDQUFpQnBoQyxLQUFqQixFQUF3QjBDLEVBQXhCLEVBQTRCeStCLEtBQTVCLENBTGtDLEVBT25DOStCLEVBQUUsQ0FBQ2cvQixVQUFILENBQWNyaEMsS0FBZCxFQUFxQjBDLEVBQXJCLEVBQXlCeStCLEtBQXpCLENBUG1DO0FBUW5DLEdBMVQ4QjtBQTRUL0IvQix5QkE1VCtCLG1DQTRUUDdxQyxPQTVUTyxFQTRURTtBQUFBLFFBQzFCOE4sRUFBRSxHQUFHLElBRHFCO0FBQUEsUUFFMUJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZjO0FBQUEsUUFHMUJnTyxhQUFhLEdBQUc1RyxFQUFFLENBQUM2RyxtQkFBSCxDQUF1QjdHLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQS9CLENBSFU7O0FBS2hDO0FBQ0EsVUFBSTlELEVBQUUsQ0FBQ3dKLFFBQUgsSUFBZXhKLEVBQUUsQ0FBQ2dTLFVBQUgsQ0FBY3BMLGFBQWQsQ0FBbkI7QUFBQSxVQUlNblEsS0FBSyxHQUFHd29DLGdHQUFPLENBQUMvc0MsT0FBRCxDQUpyQjtBQUFBLFVBS01ra0MsT0FBTyxHQUFHcDJCLEVBQUUsQ0FBQ2kyQixzQkFBSCxDQUEwQnJ2QixhQUExQixFQUF5Q25RLEtBQXpDLENBTGhCO0FBWUEsVUFMSXVKLEVBQUUsQ0FBQzJKLFNBQUgsS0FBaUIsQ0FBQ3lzQixPQUFELElBQVlBLE9BQU8sQ0FBQy8xQixFQUFSLEtBQWVMLEVBQUUsQ0FBQzJKLFNBQUgsQ0FBYXRKLEVBQXpELENBS0osS0FKQ3pILE1BQU0sQ0FBQzBvQixVQUFQLENBQWtCcHhCLElBQWxCLENBQXVCOFAsRUFBRSxDQUFDaUQsR0FBMUIsRUFBK0JqRCxFQUFFLENBQUMySixTQUFsQyxDQUlELEVBSEMzSixFQUFFLENBQUMySixTQUFILEdBQWUxVSxTQUdoQixHQUFJLENBQUNtaEMsT0FBTCxFQUVDLFlBREFwMkIsRUFBRSxDQUFDaTlCLFlBQUgsRUFDQTtBQWRELFVBaUJNaUMsU0FBUyxHQUNkbC9CLEVBQUUsQ0FBQ3ViLFlBQUgsQ0FBZ0I2YSxPQUFoQixLQUE0QnAyQixFQUFFLENBQUN3YixhQUFILENBQWlCNGEsT0FBakIsQ0FBNUIsSUFBeUQsQ0FBQ3g5QixNQUFNLENBQUN3eEIsZUFEaEQsR0FFZCxDQUFDZ00sT0FBRCxDQUZjLEdBRUZwMkIsRUFBRSxDQUFDeXhCLFNBQUgsQ0FBYTdxQixhQUFiLEVBQTRCd3ZCLE9BQU8sQ0FBQ2hsQyxDQUFwQyxDQW5CaEI7QUFBQSxVQXNCTWt0QyxZQUFZLEdBQUdZLFNBQVMsQ0FBQ3h1QyxHQUFWLENBQWMsVUFBQXJDLENBQUM7QUFBQSxlQUFJMlIsRUFBRSxDQUFDaXlCLE9BQUgsQ0FBVzVqQyxDQUFYLENBQUo7QUFBQSxPQUFmLENBdEJyQixFQXFCQTs7QUFHQTJSLFFBQUUsQ0FBQ3UrQixXQUFILENBQWVELFlBQWYsRUFBNkJwc0MsT0FBN0IsQ0F4QkEsRUEyQkE4TixFQUFFLENBQUMwK0IsaUJBQUgsQ0FBcUJ0SSxPQUFPLENBQUN6NEIsS0FBN0IsRUFBb0N5NEIsT0FBTyxDQUFDLzFCLEVBQTVDLEtBM0JBLEVBOEJBTCxFQUFFLENBQUN3K0IsY0FBSCxDQUFrQkYsWUFBbEIsQ0E5QkEsR0FpQ0l0K0IsRUFBRSxDQUFDOFcsU0FBSCxDQUFhc2YsT0FBTyxDQUFDLzFCLEVBQXJCLEtBQTRCTCxFQUFFLENBQUN3MkIsSUFBSCxDQUFRSixPQUFSLEVBQWlCMy9CLEtBQWpCLElBQTBCbUMsTUFBTSxDQUFDeXRCLGlCQWpDakUsTUFrQ0NybUIsRUFBRSxDQUFDMEcsR0FBSCxDQUFPdFUsTUFBUCxZQUFrQkMsY0FBSyxDQUFDakksU0FBeEIsR0FBcUMrTCxLQUFyQyxDQUEyQyxRQUEzQyxFQUFxRCxTQUFyRCxDQWxDRCxFQW9DSyxDQUFDNkosRUFBRSxDQUFDMkosU0FwQ1QsS0FxQ0UvUSxNQUFNLENBQUN5b0IsV0FBUCxDQUFtQm54QixJQUFuQixDQUF3QjhQLEVBQUUsQ0FBQ2lELEdBQTNCLEVBQWdDbXpCLE9BQWhDLENBckNGLEVBc0NFcDJCLEVBQUUsQ0FBQzJKLFNBQUgsR0FBZXlzQixPQXRDakI7QUFBQTtBQXlDQSxHQTNXOEI7O0FBNlcvQjs7OztBQUlBNkcsY0FqWCtCLDBCQWlYaEI7QUFDZCxRQUFNajlCLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsWUFBa0JDLGNBQUssQ0FBQ2pJLFNBQXhCLEdBQXFDK0wsS0FBckMsQ0FBMkMsUUFBM0MsRUFBcUQsSUFBckQsQ0FIYyxFQUlkNkosRUFBRSxDQUFDeStCLGNBQUgsRUFKYyxFQUtkeitCLEVBQUUsQ0FBQzZWLFdBQUgsRUFMYyxFQU1kN1YsRUFBRSxDQUFDbS9CLG1CQUFILElBTmMsRUFPZG4vQixFQUFFLENBQUM2K0IsZUFBSCxFQVBjLEVBUWQ3K0IsRUFBRSxDQUFDby9CLFlBQUgsRUFSYztBQVNkLEdBMVg4Qjs7QUE0WC9COzs7Ozs7QUFNQUMsWUFsWStCLHNCQWtZcEJDLE1BbFlvQixFQWtZWmp4QyxDQWxZWSxFQWtZVDtBQUFBLFFBQ2YyUixFQUFFLEdBQUcsSUFEVTtBQUFBLFFBRWZwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZHO0FBQUEsUUFHZmk5QixLQUFLLEdBQUczbUMsUUFBUSxDQUFDYixDQUFELENBSEQ7O0FBS3JCO0FBQ0EsUUFBSXduQyxLQUFLLElBQUl4bkMsQ0FBQyxLQUFLLENBQUMsQ0FBcEIsRUFBdUI7QUFDdEIsVUFBTW92QixRQUFRLEdBQUc3a0IsTUFBTSxDQUFDMG1DLE1BQU0sR0FBRyxhQUFILEdBQW1CLFlBQTFCLENBQU4sQ0FBOEM5akMsSUFBOUMsQ0FBbUR3RSxFQUFFLENBQUNpRCxHQUF0RCxDQUFqQjtBQUVBckssWUFBTSxDQUFDd3BCLFlBQVAsSUFBdUJwaUIsRUFBRSxDQUFDdS9CLFlBQUgsQ0FBZ0JELE1BQWhCLEVBQXdCanhDLENBQXhCLEVBQTJCd25DLEtBQTNCLENBSEQsRUFLbEJBLEtBTGtCLEdBTXJCcFksUUFBUSxDQUFDcHZCLENBQUQsQ0FOYSxJQVFyQml4QyxNQUFNLElBQUl0L0IsRUFBRSxDQUFDMCtCLGlCQUFILENBQXFCcndDLENBQXJCLEVBQXdCLElBQXhCLEtBUlcsRUFTckIsQ0FBQzJSLEVBQUUsQ0FBQ2d5QixXQUFILEVBQUQsSUFBcUJoeUIsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQzFHLEtBQTVCLGNBQXFDMEMsQ0FBckMsR0FBMENpTyxJQUExQyxDQUErQ21oQixRQUEvQyxDQVRBO0FBV3RCO0FBQ0QsR0FwWjhCOztBQXNaL0I7Ozs7O0FBS0F1ZixxQkEzWitCLCtCQTJaWDN1QyxDQTNaVyxFQTJaUjtBQUFBLFFBQ2hCMlIsRUFBRSxHQUFHLElBRFc7QUFBQSxRQUVoQncvQixNQUFNLEdBQUd4L0IsRUFBRSxDQUFDZzlCLG1CQUZJO0FBQUEsUUFHaEJwbkMsSUFBSSxHQUFHNHBDLE1BQU0sQ0FBQzVwQyxJQUhFO0FBQUEsS0FLbEIxRyxRQUFRLENBQUNiLENBQUQsQ0FBUixJQUFldUgsSUFBZixHQUFzQnZILENBQUMsQ0FBQ2dTLEVBQUYsS0FBU3pLLElBQUksQ0FBQ3lLLEVBQXBDLEdBQTBDaFMsQ0FBQyxLQUFLdUgsSUFMOUIsTUFNckIsQ0FBQ0EsSUFBSSxJQUFJakksUUFBUSxDQUFDaUksSUFBRCxDQUFqQixLQUE0Qm9LLEVBQUUsQ0FBQ3EvQixVQUFILEtBQXFCenBDLElBQXJCLENBTlAsRUFPckIsQ0FBQ3ZILENBQUMsSUFBSVYsUUFBUSxDQUFDVSxDQUFELENBQWQsS0FBc0IyUixFQUFFLENBQUNxL0IsVUFBSCxLQUFvQmh4QyxDQUFwQixDQVBELEVBU3JCbXhDLE1BQU0sQ0FBQzVwQyxJQUFQLEdBQWN2SCxDQVRPO0FBV3RCLEdBdGE4Qjs7QUF3YS9COzs7OztBQUtBb3hDLHVCQTdhK0IsbUNBNmFQO0FBQUEsUUFDakJ6L0IsRUFBRSxHQUFHLElBRFk7QUFBQSxRQUVqQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRks7QUFJdkIsV0FBT0EsTUFBTSxDQUFDMFYsbUJBQVAsSUFBOEIxVixNQUFNLENBQUN1b0Isd0JBQXJDLElBQWlFbmhCLEVBQUUsQ0FBQzAvQixJQUFwRSxHQUNOQyxnRkFBTSxHQUNKbnhCLEVBREYsQ0FDSyxNQURMLEVBQ2EsWUFBVztBQUFFeE8sUUFBRSxDQUFDMC9CLElBQUgsQ0FBUVQsZ0dBQU8sQ0FBQyxJQUFELENBQWYsQ0FBRjtBQUEyQixLQURuRCxFQUVFendCLEVBRkYsQ0FFSyxPQUZMLEVBRWMsWUFBVztBQUFFeE8sUUFBRSxDQUFDNC9CLFNBQUgsQ0FBYVgsZ0dBQU8sQ0FBQyxJQUFELENBQXBCLENBQUY7QUFBZ0MsS0FGekQsRUFHRXp3QixFQUhGLENBR0ssS0FITCxFQUdZLFlBQU07QUFBRXhPLFFBQUUsQ0FBQzYvQixPQUFILEVBQUY7QUFBaUIsS0FIbkMsQ0FETSxHQUlpQyxZQUFNLENBQUUsQ0FKaEQ7QUFLQSxHQXRiOEI7O0FBd2IvQjs7Ozs7OztBQU9BdEQsOEJBL2IrQix3Q0ErYkZ1RCxjQS9iRSxFQStiYztBQUFBLFFBQ3RDOS9CLEVBQUUsR0FBRyxJQURpQztBQUFBLFFBRXRDcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGMEI7QUFBQSxRQUl0Q21uQyxJQUFJLEdBQUdELGNBQWMsQ0FBQy91QyxNQUFmLENBQXNCLE1BQXRCLEVBQ1hDLElBRFcsQ0FDTixPQURNLEVBQ0dnUCxFQUFFLENBQUNrK0IsVUFBSCxDQUFjMWlDLElBQWQsQ0FBbUJ3RSxFQUFuQixDQURILEVBRVg3SixLQUZXLENBRUwsUUFGSyxFQUVLeUMsTUFBTSxDQUFDbW9CLHNCQUFQLElBQWlDbm9CLE1BQU0sQ0FBQ29vQixzQkFBeEMsR0FBaUUsU0FBakUsR0FBNkUsSUFGbEYsRUFHWHhTLEVBSFcsQ0FHUixPQUhRLEVBR0MsVUFBU25nQixDQUFULEVBQVk7QUFDeEIyUixRQUFFLENBQUNnZ0Msc0JBQUgsQ0FBMEJ4a0MsSUFBMUIsQ0FBK0IsSUFBL0IsRUFBcUNuTixDQUFyQyxFQUF3QzJSLEVBQXhDLENBRHdCO0FBRXhCLEtBTFcsRUFNWDlQLElBTlcsQ0FNTjhQLEVBQUUsQ0FBQ3kvQixxQkFBSCxFQU5NLENBSitCO0FBb0Q1QyxXQXhDSXovQixFQUFFLENBQUMwTSxTQUFILEtBQWlCLE9Bd0NyQixJQXZDQ3F6QixJQUFJLENBQ0Z2eEIsRUFERixDQUNLLFdBREwsRUFDa0IsVUFBQW5nQixDQUFDLEVBQUk7QUFFakIyUixRQUFFLENBQUN3SixRQUFILElBQWV4SixFQUFFLENBQUN5SixPQUFsQixJQUE2QnpKLEVBQUUsQ0FBQ2dTLFVBQUgsRUFGWixJQU1yQmhTLEVBQUUsQ0FBQ3EvQixVQUFILEtBQW9CaHhDLENBQUMsQ0FBQ3NQLEtBQXRCLENBTnFCO0FBT3JCLEtBUkYsRUFTRTZRLEVBVEYsQ0FTSyxXQVRMLEVBU2tCLFVBQVNuZ0IsQ0FBVCxFQUFZO0FBQzVCO0FBQ0EsWUFBSTJSLEVBQUUsQ0FBQ3dKLFFBQUgsSUFBZXhKLEVBQUUsQ0FBQ3lKLE9BQWxCLElBQTZCekosRUFBRSxDQUFDZ1MsVUFBSCxFQUFqQztBQUFBLFlBSUlyVSxLQUFLLEdBQUd0UCxDQUFDLENBQUNzUCxLQUpkO0FBQUEsWUFLTXZULFNBQVMsR0FBRzRWLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsWUFBa0JDLGNBQUssQ0FBQ2pJLFNBQXhCLGNBQXFDdVQsS0FBckMsRUFMbEI7QUFPSXFDLFVBQUUsQ0FBQ2lnQyxVQUFILENBQWM1eEMsQ0FBZCxLQUNIMlIsRUFBRSxDQUFDcEgsTUFBSCxDQUFVZ3VCLGNBQVYsS0FBNkIsWUFEMUIsSUFFSHFZLGdHQUFPLENBQUMsSUFBRCxDQUFQLENBQWMsQ0FBZCxJQUFtQmovQixFQUFFLENBQUM1TyxDQUFILENBQUs0TyxFQUFFLENBQUMweEIsU0FBSCxDQUFhcmpDLENBQUMsQ0FBQ2dTLEVBQWYsRUFBbUIxQyxLQUFuQixDQUFMLENBVHBCLEtBV0NBLEtBQUssSUFBSSxDQVhWLEdBY0FBLEtBQUssS0FBSyxDQUFDLENBQVgsR0FDQ3FDLEVBQUUsQ0FBQ2k5QixZQUFILEVBREQsR0FDcUJqOUIsRUFBRSxDQUFDazlCLG1CQUFILENBQXVCLElBQXZCLEVBQTZCOXlDLFNBQTdCLEVBQXdDdVQsS0FBeEMsQ0FmckI7QUFBQTtBQWdCQSxLQTNCRixFQTRCRTZRLEVBNUJGLENBNEJLLFVBNUJMLEVBNEJpQixVQUFBbmdCLENBQUMsRUFBSTtBQUVoQixPQUFDMlIsRUFBRSxDQUFDcEgsTUFBSixJQUFjb0gsRUFBRSxDQUFDZ1MsVUFBSCxFQUZFLEtBTXBCaFMsRUFBRSxDQUFDaTlCLFlBQUgsRUFOb0IsRUFPcEJqOUIsRUFBRSxDQUFDcS9CLFVBQUgsS0FBcUJoeEMsQ0FBQyxDQUFDc1AsS0FBdkIsQ0FQb0I7QUFRcEIsS0FwQ0YsQ0F1Q0QsRUFBT29pQyxJQUFQO0FBQ0EsR0FwZjhCO0FBc2YvQkMsd0JBdGYrQixrQ0FzZlIzeEMsQ0F0ZlEsRUFzZkx3RCxHQXRmSyxFQXNmQTtBQUFBLFFBQ3hCbU8sRUFBRSxHQUFHbk8sR0FEbUI7QUFBQSxRQUV4QitHLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlk7QUFJOUIsUUFBSW9ILEVBQUUsQ0FBQ2dTLFVBQUgsTUFBbUIsQ0FBQ2hTLEVBQUUsQ0FBQ3c5QixXQUF2QixJQUFzQ3g5QixFQUFFLENBQUMwSixXQUE3QyxFQUdDLGFBRkExSixFQUFFLENBQUMwSixXQUFILEtBQW1CMUosRUFBRSxDQUFDMEosV0FBSCxLQUFuQixDQUVBO0FBR0QsUUFBTS9MLEtBQUssR0FBR3RQLENBQUMsQ0FBQ3NQLEtBQWhCO0FBRUFxQyxNQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDMUcsS0FBNUIsY0FBcUNnUyxLQUFyQyxHQUNFckIsSUFERixDQUNPLFVBQVM0akMsRUFBVCxFQUFhO0FBQUEsT0FDZHRuQyxNQUFNLENBQUNvb0Isc0JBQVAsSUFBaUNoaEIsRUFBRSxDQUFDMitCLGFBQUgsQ0FBaUIsSUFBakIsRUFBdUJ1QixFQUF2QixDQURuQixNQUVqQmxnQyxFQUFFLENBQUN3OUIsV0FBSCxDQUFlLElBQWYsRUFBcUIwQyxFQUFyQixFQUF5QnZpQyxLQUF6QixDQUZpQixFQUdqQi9FLE1BQU0sQ0FBQ3dvQixZQUFQLENBQW9CbHhCLElBQXBCLENBQXlCOFAsRUFBRSxDQUFDaUQsR0FBNUIsRUFBaUNpOUIsRUFBakMsRUFBcUMsSUFBckMsQ0FIaUI7QUFLbEIsS0FORixDQVo4QjtBQW1COUIsR0F6Z0I4Qjs7QUEyZ0IvQjs7Ozs7OztBQU9BOUQsaUNBbGhCK0IsMkNBa2hCQzBELGNBbGhCRCxFQWtoQmlCO0FBQUEsUUFDekM5L0IsRUFBRSxHQUFHLElBRG9DO0FBQUEsUUFHekMrL0IsSUFBSSxHQUFHRCxjQUFjLENBQ3pCL3VDLE1BRFcsQ0FDSixNQURJLEVBRVhDLElBRlcsQ0FFTixHQUZNLEVBRUQsQ0FGQyxFQUdYQSxJQUhXLENBR04sR0FITSxFQUdELENBSEMsRUFJWEEsSUFKVyxDQUlOLE9BSk0sRUFJR2dQLEVBQUUsQ0FBQzFPLEtBSk4sRUFLWE4sSUFMVyxDQUtOLFFBTE0sRUFLSWdQLEVBQUUsQ0FBQ3pPLE1BTFAsRUFNWFAsSUFOVyxDQU1OLE9BTk0sRUFNR3FCLGNBQUssQ0FBQ2pJLFNBTlQsRUFPWG9rQixFQVBXLENBT1IsT0FQUSxFQU9DLFlBQVc7QUFDdkJ4TyxRQUFFLENBQUNtZ0MseUJBQUgsQ0FBNkIza0MsSUFBN0IsQ0FBa0MsSUFBbEMsRUFBd0N3RSxFQUF4QyxDQUR1QjtBQUV2QixLQVRXLEVBVVg5UCxJQVZXLENBVU44UCxFQUFFLENBQUN5L0IscUJBQUgsRUFWTSxDQUhrQztBQThCL0MsV0FmSXovQixFQUFFLENBQUMwTSxTQUFILEtBQWlCLE9BZXJCLElBZENxekIsSUFBSSxDQUNGdnhCLEVBREYsQ0FDSyxxQkFETCxFQUM0QixZQUFXO0FBQ3JDeE8sUUFBRSxDQUFDKzhCLHVCQUFILENBQTJCLElBQTNCLENBRHFDO0FBRXJDLEtBSEYsRUFJRXZ1QixFQUpGLENBSUssVUFKTCxFQUlpQixZQUFNO0FBRWpCLE9BQUN4TyxFQUFFLENBQUNwSCxNQUFKLElBQWNvSCxFQUFFLENBQUNnUyxVQUFILEVBRkcsSUFNckJoUyxFQUFFLENBQUNpOUIsWUFBSCxFQU5xQjtBQU9yQixLQVhGLENBY0QsRUFBTzhDLElBQVA7QUFDQSxHQWpqQjhCO0FBbWpCL0JJLDJCQW5qQitCLHFDQW1qQkx0dUMsR0FuakJLLEVBbWpCQTtBQUFBLFFBQ3hCbU8sRUFBRSxHQUFHbk8sR0FEbUI7QUFBQSxRQUV4QitHLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlk7QUFBQSxRQUd4QmdPLGFBQWEsR0FBRzVHLEVBQUUsQ0FBQzZHLG1CQUFILENBQXVCN0csRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBL0IsQ0FIUTs7QUFLOUIsU0FBSTlELEVBQUUsQ0FBQ2dTLFVBQUgsQ0FBY3BMLGFBQWQsQ0FBSjtBQUFBLFVBSU1uUSxLQUFLLEdBQUd3b0MsZ0dBQU8sQ0FBQyxJQUFELENBSnJCO0FBQUEsVUFLTTdJLE9BQU8sR0FBR3AyQixFQUFFLENBQUNpMkIsc0JBQUgsQ0FBMEJydkIsYUFBMUIsRUFBeUNuUSxLQUF6QyxDQUxoQjtBQU9JLE9BQUMyL0IsT0FQTCxLQVlJcDJCLEVBQUUsQ0FBQzhXLFNBQUgsQ0FBYXNmLE9BQU8sQ0FBQy8xQixFQUFyQixLQUE0QkwsRUFBRSxDQUFDdzJCLElBQUgsQ0FBUUosT0FBUixFQUFpQjMvQixLQUFqQixJQUEwQm1DLE1BQU0sQ0FBQ3l0QixpQkFaakUsS0FhQ3JtQixFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDekcsTUFBNUIsU0FBcUNvVSxFQUFFLENBQUNzMkIsdUJBQUgsQ0FBMkJGLE9BQU8sQ0FBQy8xQixFQUFuQyxDQUFyQyxHQUNFeEQsU0FERixZQUNnQnhLLGNBQUssQ0FBQzFHLEtBRHRCLGNBQytCeXFDLE9BQU8sQ0FBQ3o0QixLQUR2QyxHQUVFckIsSUFGRixDQUVPLFlBQVc7QUFBQSxTQUNaMUQsTUFBTSxDQUFDb29CLHNCQUFQLElBQWlDaGhCLEVBQUUsQ0FBQzIrQixhQUFILENBQWlCLElBQWpCLEVBQXVCdkksT0FBdkIsQ0FEckIsTUFFZnAyQixFQUFFLENBQUN3OUIsV0FBSCxDQUFlLElBQWYsRUFBcUJwSCxPQUFyQixFQUE4QkEsT0FBTyxDQUFDejRCLEtBQXRDLENBRmUsRUFHZi9FLE1BQU0sQ0FBQ3dvQixZQUFQLENBQW9CbHhCLElBQXBCLENBQXlCOFAsRUFBRSxDQUFDaUQsR0FBNUIsRUFBaUNtekIsT0FBakMsRUFBMEMsSUFBMUMsQ0FIZTtBQUtoQixPQVBGLENBYkQ7QUFBQSxLQUw4QixDQWdCOUI7O0FBV0EsR0E5a0I4Qjs7QUFnbEIvQjs7Ozs7OztBQU9BLytCLGVBdmxCK0IseUJBdWxCakJ0QyxJQXZsQmlCLEVBdWxCWDRJLEtBdmxCVyxFQXVsQkpsSCxLQXZsQkksRUF1bEJHO0FBQzNCLFFBQUF1SixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0FneUIsV0FEQSxHQUNjaHlCLEVBQUUsQ0FBQ2d5QixXQUFILEVBRGQ7QUFBQSxRQUVBb08sUUFGQSxjQUVlcE8sV0FBVyxHQUFHMy9CLGNBQUssQ0FBQ2pJLFNBQVQsYUFBd0JpSSxjQUFLLENBQUNqSSxTQUE5QixjQUEyQ3VULEtBQTNDLENBRjFCO0FBQUEsUUFHQXZULFNBSEEsR0FHWTRWLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixDQUFlZ3VDLFFBQWYsRUFBeUI3dkMsSUFBekIsRUFIWjtBQUFBLGdDQUlxQm5HLFNBQVMsQ0FBQ3FILHFCQUFWLEVBSnJCO0FBQUEsUUFJQ0gsS0FKRCx5QkFJQ0EsS0FKRDtBQUFBLFFBSVFrTyxJQUpSLHlCQUlRQSxJQUpSO0FBQUEsUUFJY0gsR0FKZCx5QkFJY0EsR0FKZDtBQUFBLFFBS0FqTyxDQUxBLEdBS0lvTyxJQUFJLElBQUkvSSxLQUFLLEdBQUdBLEtBQUssQ0FBQyxDQUFELENBQVIsR0FBYyxDQUF2QixDQUFKLElBQWlDdTdCLFdBQVcsR0FBRyxDQUFILEdBQVExZ0MsS0FBSyxHQUFHLENBQTVELENBTEo7QUFBQSxRQU1BRCxDQU5BLEdBTUlnTyxHQUFHLElBQUk1SSxLQUFLLEdBQUdBLEtBQUssQ0FBQyxDQUFELENBQVIsR0FBYyxDQUF2QixDQU5QOztBQWNORCxnQkFBWSxDQUFDLGlCQUFpQndELElBQWpCLENBQXNCakYsSUFBdEIsSUFBOEIsT0FBOUIsR0FBd0MsT0FBekMsQ0FBWixDQUE4RDNLLFNBQTlELEVBQXlFMkssSUFBekUsRUFQZTtBQUNkOEIsYUFBTyxFQUFFekYsQ0FESztBQUVkMEYsYUFBTyxFQUFFekYsQ0FGSztBQUdkMEYsYUFBTyxFQUFFM0YsQ0FISztBQUlkNEYsYUFBTyxFQUFFM0Y7QUFKSyxLQU9mLENBZmlDO0FBZ0JqQztBQXZtQjhCLENBQTFCLEM7O0FDZE47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQXNCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7O0FBSUF0TSxrQkFMK0IsOEJBS1o7QUFDbEIsUUFBTTNTLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQ3NULFlBQUgsR0FBa0J0VCxFQUFFLENBQUNxZ0MsZUFBSCxFQUhBLEVBSWxCcmdDLEVBQUUsQ0FBQ21ULGFBQUgsR0FBbUJuVCxFQUFFLENBQUNzZ0MsZ0JBQUgsRUFKRDtBQUtsQixHQVY4QjtBQVkvQkQsaUJBWitCLDZCQVliO0FBQ2pCLFFBQU1yZ0MsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNwSCxNQUFILENBQVV1bUIsVUFBVixJQUF3Qm5mLEVBQUUsQ0FBQ3VnQyxjQUFILEVBQS9CO0FBQ0EsR0FoQjhCO0FBa0IvQkQsa0JBbEIrQiw4QkFrQlo7QUFBQSxRQUNadGdDLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFWnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkE7QUFBQSxRQUdaMEIsQ0FBQyxHQUFHMUIsTUFBTSxDQUFDd21CLFdBQVAsSUFBc0JwZixFQUFFLENBQUN3Z0MsZUFBSCxFQUhkO0FBS2xCLFdBQU9sbUMsQ0FBQyxHQUFHLENBQUosR0FBUUEsQ0FBUixHQUFZLE9BQU8wRixFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxLQUF1QixDQUFDaFYsTUFBTSxDQUFDK2EsZ0JBQS9CLEdBQWtELENBQWxELEdBQXNELENBQTdELENBQW5CO0FBQ0EsR0F4QjhCOztBQTBCL0I7Ozs7OztBQU1BdUgsYUFoQytCLHVCQWdDbkI3YSxFQWhDbUIsRUFnQ2Y7QUFBQSxRQUNUTCxFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZIO0FBQUEsUUFHVHNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSFY7QUFLZixXQUFRRCxTQUFTLElBQUlHLEVBQUUsS0FBSyxHQUFyQixJQUE4QixDQUFDSCxTQUFELElBQWMsTUFBTWxHLElBQU4sQ0FBV3FHLEVBQVgsQ0FBNUMsR0FDTkwsRUFBRSxDQUFDeWdDLG9CQUFILENBQXdCcGdDLEVBQXhCLEtBRE0sR0FFTkwsRUFBRSxDQUFDcVMsdUJBQUgsQ0FBMkJoUyxFQUEzQixDQUZEO0FBR0EsR0F4QzhCO0FBMEMvQndTLHNCQTFDK0Isa0NBMENSO0FBQUEsUUFDaEI3UyxFQUFFLEdBQUcsSUFEVztBQUFBLFFBRWhCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSTtBQUFBLFFBR2hCOG5DLE9BQU8sR0FBRzluQyxNQUFNLENBQUNndEIsWUFBUCxDQUFvQnAzQixNQUhkO0FBQUEsUUFLbEJrWixPQUFPLEdBQUduYSxPQUFPLENBQUNxTCxNQUFNLENBQUMybUIsV0FBUixDQUFQLEdBQ2IzbUIsTUFBTSxDQUFDMm1CLFdBRE0sR0FDUSxDQU5BO0FBZ0J0QixXQVJJdmYsRUFBRSxDQUFDM1QsS0FBSCxJQUFZMlQsRUFBRSxDQUFDM1QsS0FBSCxDQUFTa0UsSUFBVCxFQVFoQixLQVBDbVgsT0FBTyxJQUFJMUgsRUFBRSxDQUFDMmdDLGVBQUgsRUFPWixHQUpJRCxPQUFPLElBQUk5bkMsTUFBTSxDQUFDdUgsWUFJdEIsS0FIQ3VILE9BQU8sSUFBSTFILEVBQUUsQ0FBQ3FTLHVCQUFILENBQTJCLElBQTNCLElBQW1DcXVCLE9BRy9DLEdBQU9oNUIsT0FBUDtBQUNBLEdBM0Q4QjtBQTZEL0JxTCx5QkE3RCtCLHFDQTZETDtBQUFBLFFBQ25CL1MsRUFBRSxHQUFHLElBRGM7QUFBQSxRQUVuQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRk87QUFBQSxRQUduQjAxQixNQUFNLEdBQUcxMUIsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQixHQUF0QixHQUE0QixHQUhsQjtBQUFBLFFBSW5CdWdDLE9BQU8sR0FBRzluQyxNQUFNLGdCQUFTMDFCLE1BQVQsV0FBTixDQUE4QjkvQixNQUpyQjtBQUFBLFFBS25Ca1osT0FBTyxHQUFHbmEsT0FBTyxDQUFDcUwsTUFBTSxDQUFDNG1CLGNBQVIsQ0FBUCxHQUNmNW1CLE1BQU0sQ0FBQzRtQixjQURRLEdBQ1MsQ0FOQTtBQVF6QixXQUFPOVgsT0FBTyxJQUNiZzVCLE9BQU8sR0FBRzFnQyxFQUFFLENBQUNxUyx1QkFBSCxDQUEyQmljLE1BQTNCLElBQXFDb1MsT0FBeEMsR0FBa0QsQ0FENUMsQ0FBZDtBQUdBLEdBeEU4QjtBQTBFL0IxdEIsdUJBMUUrQixpQ0EwRVQxTSxnQkExRVMsRUEwRVM7QUFBQSxRQU9uQ29CLE9BUG1DO0FBQUEsUUFDakMxSCxFQUFFLEdBQUcsSUFENEI7QUFBQSxRQUVqQ3BILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRnFCO0FBQUEsUUFHakNzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhjO0FBQUEsUUFJakNtdUIsTUFBTSxHQUFHcHVCLFNBQVMsR0FBRyxHQUFILEdBQVMsR0FKTTtBQUFBLFFBS2pDd2dDLE9BQU8sR0FBRzluQyxNQUFNLGdCQUFTMDFCLE1BQVQsV0FBTixDQUE4QjkvQixNQUxQO0FBQUEsUUFNakNveUMsU0FBUyxHQUFHNWdDLEVBQUUsQ0FBQ3lnQyxvQkFBSCxDQUF3Qm5TLE1BQXhCLEVBQWdDaG9CLGdCQUFoQyxDQU5xQjtBQW9CdkMsV0FWQ29CLE9BVUQsR0FYSW5hLE9BQU8sQ0FBQ3FMLE1BQU0sQ0FBQ3ltQixZQUFSLENBV1gsR0FWV3ptQixNQUFNLENBQUN5bUIsWUFVbEIsR0FUV25mLFNBU1gsR0FSWXRILE1BQU0sQ0FBQzJULFdBQVIsR0FDTHZlLElBQUksQ0FBQ2tOLEdBQUwsQ0FBU25OLE1BQU0sQ0FBQzZ5QyxTQUFELENBQWYsRUFBNEIsRUFBNUIsQ0FESyxHQUNULENBT0YsR0FOVyxDQUFDaG9DLE1BQU0sQ0FBQ2tyQixXQUFSLElBQXVCbHJCLE1BQU0sQ0FBQ21JLFlBTXpDLEdBTFdmLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUStkLHFCQUFSLEdBQWdDWixPQUFoQyxHQUEwQyxFQUExQyxHQUErQyxDQUsxRCxHQUhXcFgsTUFBTSxDQUFDNnlDLFNBQUQsQ0FHakIsRUFBT2w1QixPQUFPLEdBQUlrNUIsU0FBUyxHQUFHRixPQUE5QjtBQUNBLEdBL0Y4QjtBQWlHL0I1dEIsd0JBakcrQixvQ0FpR047QUFBQSxRQU9wQnBMLE9BUG9CO0FBQUEsUUFDbEIxSCxFQUFFLEdBQUcsSUFEYTtBQUFBLFFBRWxCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGTTtBQUFBLFFBSWxCaW9DLGtCQUFrQixHQUFHN2dDLEVBQUUsQ0FBQzJMLGFBQUgsR0FBbUIzTCxFQUFFLENBQUNpUyxjQUFILEtBQXNCLEVBQXpDLEdBQThDLENBSmpEO0FBQUEsUUFLbEJ5dUIsT0FBTyxHQUFHOW5DLE1BQU0sQ0FBQ2d0QixZQUFQLENBQW9CcDNCLE1BTFo7QUFBQSxRQU1sQm95QyxTQUFTLEdBQUc1Z0MsRUFBRSxDQUFDeWdDLG9CQUFILENBQXdCLElBQXhCLENBTk07QUFvQnhCLFdBVkMvNEIsT0FVRCxHQVhJbmEsT0FBTyxDQUFDcUwsTUFBTSxDQUFDMG1CLGFBQVIsQ0FXWCxHQVZXMW1CLE1BQU0sQ0FBQzBtQixhQUFQLEdBQXVCLENBVWxDLEdBVFcxbUIsTUFBTSxDQUFDdUgsWUFTbEIsR0FqQnVCLEVBU1osR0FBaUIwZ0Msa0JBUTVCLEdBUFcsQ0FBQ2pvQyxNQUFNLENBQUM2SCxZQUFSLElBQXdCN0gsTUFBTSxDQUFDMEksYUFPMUMsR0FOVyxJQUFJdS9CLGtCQUFKLElBQ1I3Z0MsRUFBRSxDQUFDaFksSUFBSCxDQUFRZ2Usc0JBQVIsR0FBaUNiLE9BQWpDLEdBQTJDLEVBQTNDLEdBQWdELENBRHhDLENBTVgsR0FIV3BYLE1BQU0sQ0FBQzZ5QyxTQUFELENBQU4sR0FBb0JDLGtCQUcvQixFQUFPbjVCLE9BQU8sR0FBSWs1QixTQUFTLEdBQUdGLE9BQTlCO0FBQ0EsR0F0SDhCOztBQXdIL0I7Ozs7O0FBS0FJLG9CQTdIK0IsOEJBNkhadnhDLEdBN0hZLEVBNkhQO0FBQUEsYUFHbkIvQixDQUhtQixFQUNqQnV6QyxVQUFVLG1CQUFZanVDLFVBQVUsQ0FBQ3ZELEdBQUQsQ0FBdEIsQ0FETyxFQUVuQnl4QyxNQUFNLEdBQUcsS0FBSzk1QixXQUFMLENBQWlCM1csSUFBakIsRUFGVSxFQUtoQixDQUFDL0MsQ0FBRCxJQUFNd3pDLE1BQU4sSUFBZ0JBLE1BQU0sQ0FBQ0MsT0FBUCxLQUFtQixNQUxuQixHQUsyQjtBQUNqRCxVQUFJO0FBQ0h6ekMsU0FBQyxHQUFHd3pDLE1BQU0sQ0FBQ3Z2QyxxQkFBUCxHQUErQmxDLEdBQS9CLENBREQ7QUFFSCxPQUZELENBRUUsT0FBT2tFLENBQVAsRUFBVTtBQUNQc3RDLGtCQUFVLElBQUlDLE1BRFAsS0FJVnh6QyxDQUFDLEdBQUd3ekMsTUFBTSxDQUFDRCxVQUFELENBSkE7QUFNWDs7QUFFREMsWUFBTSxHQUFHQSxNQUFNLENBQUNFLFVBWGlDO0FBWWpEOztBQUVELFFBQUkzeEMsR0FBRyxLQUFLLE9BQVosRUFBcUI7QUFDcEI7QUFDQTtBQUNBLFVBQU00eEMsU0FBUyxHQUFHNTVDLFFBQVEsQ0FBQzhPLElBQVQsQ0FBYytxQyxXQUFoQztBQUVBNXpDLE9BQUMsR0FBRzJ6QyxTQUFKLEtBQWtCM3pDLENBQUMsR0FBRzJ6QyxTQUF0QixDQUxvQjtBQU1wQjs7QUFFRCxXQUFPM3pDLENBQVA7QUFDQSxHQXpKOEI7QUEySi9CK3lDLGdCQTNKK0IsNEJBMkpkO0FBQ2hCLFdBQU8sS0FBS08sa0JBQUwsQ0FBd0IsT0FBeEIsQ0FBUDtBQUNBLEdBN0o4QjtBQStKL0JOLGlCQS9KK0IsNkJBK0piO0FBQ2pCLFFBQU1sbUMsQ0FBQyxHQUFHLEtBQUs0TSxXQUFMLENBQWlCL1EsS0FBakIsQ0FBdUIsUUFBdkIsQ0FBVjtBQUVBLFdBQU9tRSxDQUFDLENBQUMzUyxPQUFGLENBQVUsSUFBVixJQUFrQixDQUFsQixHQUFzQjA1QyxRQUFRLENBQUMvbUMsQ0FBRCxFQUFJLEVBQUosQ0FBOUIsR0FBd0MsQ0FBL0M7QUFDQSxHQW5LOEI7QUFxSy9CZ25DLFlBcksrQixzQkFxS3BCaDdCLGdCQXJLb0IsRUFxS0Y7QUFBQSxRQUN0QnRHLEVBQUUsR0FBRyxJQURpQjtBQUFBLFFBRXRCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVTtBQUFBLFFBR3RCMm9DLGVBQWUsR0FBRzNvQyxNQUFNLENBQUN1SCxZQUFQLElBQXdCLENBQUN2SCxNQUFNLENBQUN1SCxZQUFSLElBQXdCLENBQUN2SCxNQUFNLENBQUNtSSxZQUhwRDtBQUFBLFFBSXRCeWdDLGFBQWEsR0FBRzVvQyxNQUFNLENBQUN1SCxZQUFQLEdBQXNCOU4sY0FBSyxDQUFDcEssS0FBNUIsR0FBb0NvSyxjQUFLLENBQUNsSyxLQUpwQztBQUFBLFFBS3RCczVDLFFBQVEsR0FBR3poQyxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJvdkMsYUFBbkIsR0FBb0NqeEMsSUFBcEMsRUFMVztBQUFBLFFBTXRCbXhDLE9BQU8sR0FBR0QsUUFBUSxJQUFJRixlQUFaLEdBQThCRSxRQUFRLENBQUNod0MscUJBQVQsRUFBOUIsR0FBaUU7QUFBQzZOLFdBQUssRUFBRTtBQUFSLEtBTnJEO0FBQUEsUUFPdEJxaUMsU0FBUyxHQUFHM2hDLEVBQUUsQ0FBQ2tILFdBQUgsQ0FBZTNXLElBQWYsR0FBc0JrQixxQkFBdEIsRUFQVTtBQUFBLFFBUXRCc2dCLE1BQU0sR0FBRy9SLEVBQUUsQ0FBQ2dTLFVBQUgsRUFSYTtBQUFBLFFBU3RCNHZCLE9BQU8sR0FBR0YsT0FBTyxDQUFDcGlDLEtBQVIsR0FBZ0JxaUMsU0FBUyxDQUFDbmlDLElBQTFCLElBQ2R1UyxNQUFNLEdBQUcsQ0FBSCxHQUFPL1IsRUFBRSxDQUFDZ1QscUJBQUgsQ0FBeUIxTSxnQkFBekIsQ0FEQyxDQVRZO0FBWTVCLFdBQU9zN0IsT0FBTyxHQUFHLENBQVYsR0FBY0EsT0FBZCxHQUF3QixDQUEvQjtBQUNBLEdBbEw4QjtBQW9ML0JuQixzQkFwTCtCLGdDQW9MVnBnQyxFQXBMVSxFQW9MTmlHLGdCQXBMTSxFQW9MWTtBQUFBLFFBQ3BDdEcsRUFBRSxHQUFHLElBRCtCO0FBQUEsUUFFcENnRixRQUFRLEdBQUdoRixFQUFFLENBQUNoWSxJQUFILENBQVE2NUMsb0JBQVIsQ0FBNkJ4aEMsRUFBN0IsQ0FGeUI7QUFJMUMsV0FBT0wsRUFBRSxDQUFDaFksSUFBSCxDQUFRb2UsZUFBUixDQUF3Qi9GLEVBQXhCLEVBQTRCaUcsZ0JBQTVCLEtBQ0x0QixRQUFRLENBQUNFLE9BQVQsR0FBbUIsRUFBbkIsR0FBd0IsRUFEbkIsQ0FBUDtBQUVBLEdBMUw4QjtBQTRML0JtTix5QkE1TCtCLG1DQTRMUGhTLEVBNUxPLEVBNExIO0FBQUEsUUFDckJMLEVBQUUsR0FBRyxJQURnQjtBQUFBLFFBRXJCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGUztBQUFBLFFBR3JCc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIRTtBQUFBLFFBSXZCN0YsQ0FBQyxHQUFHLEVBSm1CO0FBQUEsV0FNdkIrRixFQUFFLEtBQUssR0FBUCxJQUFlekgsTUFBTSxDQUFDMlQsV0FOQyxHQVV2QmxNLEVBQUUsS0FBSyxHQUFQLElBQWN6SCxNQUFNLENBQUN1TixhQVZFLEdBV25Cdk4sTUFBTSxDQUFDdU4sYUFYWSxHQWN2QjlGLEVBQUUsS0FBSyxHQUFQLElBQWV6SCxNQUFNLENBQUNrckIsV0FkQyxHQW9CdkJ6akIsRUFBRSxLQUFLLElBQVAsSUFBZ0J6SCxNQUFNLENBQUM2SCxZQXBCQSxLQXlCdEJKLEVBQUUsS0FBSyxHQUFQLElBQWMsQ0FBQ0gsU0FBZixJQUE0QnRILE1BQU0sQ0FBQ21LLGtCQUFwQyxJQUNGMUMsRUFBRSxLQUFLLEdBQVAsSUFBY0gsU0FBZCxJQUEyQnRILE1BQU0sQ0FBQzhLLGtCQTFCVCxNQTJCMUJwSixDQUFDLEdBQUcsS0FDSDBGLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUW9lLGVBQVIsQ0FBd0IvRixFQUF4QixJQUNBclMsSUFBSSxDQUFDOHpDLEdBQUwsQ0FBUzl6QyxJQUFJLENBQUNpUSxFQUFMLElBQVcsS0FBS3JGLE1BQU0sZ0JBQVN5SCxFQUFULGtCQUF0QixJQUFvRCxHQUE3RCxDQTdCeUIsR0FnQ3BCL0YsQ0FBQyxJQUNOMEYsRUFBRSxDQUFDaFksSUFBSCxDQUFRNjVDLG9CQUFSLENBQTZCeGhDLEVBQTdCLEVBQWlDNkUsT0FBakMsR0FBMkMsQ0FBM0MsR0FBK0MsRUFEekMsQ0FBRCxJQUVMN0UsRUFBRSxLQUFLLElBQVAsSUFBZ0JILFNBQWhCLEdBQWtDLENBQWxDLEdBQTRCLENBQUMsRUFGeEIsQ0FoQ29CLElBcUJuQkYsRUFBRSxDQUFDd00sbUJBckJnQixHQWVuQixDQUFBNVQsTUFBTSxDQUFDaVYsV0FBUCxJQUNMN04sRUFBRSxDQUFDMkwsYUFERSxJQUVMM0wsRUFBRSxDQUFDNkwsYUFGRSxHQUVtQixDQUZuQixHQUVjLEVBakJLLEdBT25CLENBUG1CLEVBd0IzQjtBQVdBLEdBL044QjtBQWlPL0JneUIsbUJBak8rQiwrQkFpT1g7QUFDbkIsV0FBTzd2QyxJQUFJLENBQUNrTixHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUtxSCxLQUFMLENBQVd3L0IsWUFBWCxFQUFaLENBQVA7QUFDQTtBQW5POEIsQ0FBMUIsQzs7Ozs7QUNSTjs7OztBQUlBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUFwdkMsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0JsRyxpQkFEK0IsMkJBQ2ZpcEIsVUFEZSxFQUNIO0FBQUEsUUFDckJoaUMsRUFBRSxHQUFHLElBRGdCO0FBQUEsUUFFckJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZTO0FBQUEsUUFHckJpZ0IsT0FBTyxHQUFHLEVBSFc7QUFBQSxRQUl2Qi9uQixDQUFDLEdBQUcsQ0FKbUI7QUE2QjNCLFdBdkJBa1AsRUFBRSxDQUFDNkcsbUJBQUgsQ0FBdUI3RyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQ3JCOVAsTUFEcUIsQ0FDZGd1QyxVQURjLEVBQ0ZoaUMsRUFERSxDQUF2QixFQUVFblEsT0FGRixDQUVVLFVBQUF4QixDQUFDLEVBQUk7QUFDYixXQUFLLElBQVc0ekMsTUFBWCxFQUFJL1QsQ0FBQyxHQUFHLENBQWIsRUFBeUIrVCxNQUFNLEdBQUdycEMsTUFBTSxDQUFDeW5CLFdBQVAsQ0FBbUI2TixDQUFuQixDQUFsQyxFQUEwREEsQ0FBQyxFQUEzRCxFQUNDLE1BQUkrVCxNQUFNLENBQUN0NkMsT0FBUCxDQUFlMEcsQ0FBQyxDQUFDZ1MsRUFBakIsSUFBdUIsQ0FBM0IsR0FJQSxLQUFLLElBQVdzekIsS0FBWCxFQUFJdEYsR0FBQyxHQUFHLENBQWIsRUFBc0JzRixLQUFHLEdBQUdzTyxNQUFNLENBQUM1VCxHQUFELENBQWxDLEVBQXdDQSxHQUFDLEVBQXpDLEVBQ0MsSUFBSXNGLEtBQUcsSUFBSTlhLE9BQVgsRUFBb0I7QUFDbkJBLGVBQU8sQ0FBQ3hxQixDQUFDLENBQUNnUyxFQUFILENBQVAsR0FBZ0J3WSxPQUFPLENBQUM4YSxLQUFELENBREo7QUFFbkI7QUFDQTs7QUFJQy9sQyxpQkFBVyxDQUFDaXJCLE9BQU8sQ0FBQ3hxQixDQUFDLENBQUNnUyxFQUFILENBQVIsQ0FkRixLQWVad1ksT0FBTyxDQUFDeHFCLENBQUMsQ0FBQ2dTLEVBQUgsQ0FBUCxHQUFnQnZQLENBQUMsRUFmTDtBQWlCYixLQW5CRixDQXVCQSxFQUZBK25CLE9BQU8sQ0FBQ3FwQixPQUFSLEdBQWtCcHhDLENBQUMsR0FBRyxDQUV0QixFQUFPK25CLE9BQVA7QUFDQSxHQS9COEI7QUFpQy9Cc3BCLFdBakMrQixxQkFpQ3JCdFcsTUFqQ3FCLEVBaUNidVcsVUFqQ2EsRUFpQ0R2cEIsT0FqQ0MsRUFpQ1F3cEIsS0FqQ1IsRUFpQ2U7QUFBQSxRQUN2Q3JpQyxFQUFFLEdBQUcsSUFEa0M7QUFBQSxRQUV2Q25ILEtBQUssR0FBR3dwQyxLQUFLLEdBQUdyaUMsRUFBRSxDQUFDaU8sSUFBTixHQUFjak8sRUFBRSxDQUFDbUQsU0FBSCxJQUFnQm5ELEVBQUUsQ0FBQzVPLENBRlA7QUFBQSxRQUd2Q2t4QyxVQUFVLEdBQUd0aUMsRUFBRSxDQUFDcEgsTUFBSCxDQUFVbXVCLFdBSGdCO0FBQUEsUUFJdkMyTSxHQUFHLEdBQUcsVUFBQzdnQyxDQUFELEVBQUlzQixDQUFKO0FBQUEsYUFBVXRCLENBQUMsR0FBR3NCLENBQWQ7QUFBQSxLQUppQztBQUFBLFFBS3ZDb3VDLFNBQVMsR0FBR2owQyxZQUFZLENBQUN1OUIsTUFBRCxDQUFaLElBQXdCQSxNQUFNLENBQUNpSSxLQUFQLENBQWF0bEMsTUFBckMsR0FBOENxOUIsTUFBTSxDQUFDaUksS0FBUCxDQUFhNS9CLE1BQWIsQ0FBb0J3L0IsR0FBcEIsSUFBMkIsQ0FBekUsR0FBNkUsQ0FMbEQ7O0FBTzdDLFdBQU8sVUFBQXJsQyxDQUFDLEVBQUk7QUFBQSxVQUNMc1AsS0FBSyxHQUFHdFAsQ0FBQyxDQUFDZ1MsRUFBRixJQUFRd1ksT0FBUixHQUFrQkEsT0FBTyxDQUFDeHFCLENBQUMsQ0FBQ2dTLEVBQUgsQ0FBekIsR0FBa0MsQ0FEckM7QUFBQSxVQUVQalAsQ0FBQyxHQUFHLENBRkc7O0FBSVgsVUFBSXZDLFFBQVEsQ0FBQ1IsQ0FBQyxDQUFDK0MsQ0FBSCxDQUFaLEVBQW1CO0FBQ2xCLFlBQU1veEMsSUFBSSxHQUFHM3BDLEtBQUssQ0FBQ3hLLENBQUMsQ0FBQytDLENBQUgsQ0FBbEI7QUFHQ0EsU0FKaUIsR0FHZG14QyxTQUhjLEdBSWJDLElBQUksSUFBSTNXLE1BQU0sQ0FBQ3g5QixDQUFDLENBQUNnUyxFQUFILENBQU4sSUFBZ0J3ckIsTUFBTSxDQUFDdjZCLEtBQTNCLENBQUosR0FDSHU2QixNQUFNLENBQUNpSSxLQUFQLENBQWE3Z0MsS0FBYixDQUFtQixDQUFuQixFQUFzQjBLLEtBQUssR0FBRyxDQUE5QixFQUFpQ3pKLE1BQWpDLENBQXdDdy9CLEdBQXhDLENBREcsR0FFSDZPLFNBTmdCLEdBUWJDLElBQUksR0FBRyxDQUFDNzBDLFFBQVEsQ0FBQ2srQixNQUFELENBQVIsR0FBbUJBLE1BQW5CLEdBQTRCQSxNQUFNLENBQUN2NkIsS0FBcEMsS0FBOEM4d0MsVUFBVSxHQUFHLENBQWIsR0FBaUJ6a0MsS0FBL0QsQ0FSTTtBQVVsQixPQWRVLENBZ0JYOzs7QUFhQSxhQVpJa3VCLE1BQU0sSUFBSXo2QixDQUFWLElBQWVneEMsVUFBVSxHQUFHLENBQTVCLElBQWlDRSxVQVlyQyxLQVhLM2tDLEtBV0wsS0FWRXZNLENBQUMsSUFBSWt4QyxVQUFVLEdBQUcza0MsS0FVcEIsR0FQS3lrQyxVQUFVLEdBQUcsQ0FPbEIsR0FORWh4QyxDQUFDLElBQUksQ0FBQ2d4QyxVQUFVLEdBQUcsQ0FBZCxJQUFtQkUsVUFBbkIsR0FBZ0MsQ0FNdkMsR0FMWUYsVUFBVSxLQUFLLENBSzNCLEtBSkVoeEMsQ0FBQyxJQUFJa3hDLFVBQVUsR0FBRyxDQUlwQixJQUFPbHhDLENBQVA7QUFDQSxLQTlCRDtBQStCQSxHQXZFOEI7QUF5RS9CcXhDLFdBekUrQixxQkF5RXJCSixLQXpFcUIsRUF5RWQ7QUFBQSxRQUNWcmlDLEVBQUUsR0FBRyxJQURLO0FBQUEsUUFFVjJELGlCQUFpQixHQUFHM0QsRUFBRSxDQUFDMkQsaUJBQUgsRUFGVjtBQUloQixXQUFPLFVBQUF0VixDQUFDO0FBQUEsYUFBSSxDQUFDZzBDLEtBQUssR0FBR3JpQyxFQUFFLENBQUN1c0IsWUFBSCxDQUFnQmwrQixDQUFDLENBQUNnUyxFQUFsQixDQUFILEdBQTJCTCxFQUFFLENBQUNxc0IsU0FBSCxDQUFhaCtCLENBQUMsQ0FBQ2dTLEVBQWYsQ0FBakMsRUFDWHNELGlCQUFpQixHQUFHM0QsRUFBRSxDQUFDcTNCLFFBQUgsQ0FBWSxPQUFaLEVBQXFCaHBDLENBQXJCLEtBQUgsR0FBbUNBLENBQUMsQ0FBQ3NCLEtBRDNDLENBQUo7QUFBQSxLQUFSO0FBR0EsR0FoRjhCO0FBa0YvQit5QyxnQkFsRitCLDBCQWtGaEJWLFVBbEZnQixFQWtGSm5wQixPQWxGSSxFQWtGS3dwQixLQWxGTCxFQWtGWTtBQUFBLFFBQ3BDcmlDLEVBQUUsR0FBRyxJQUQrQjtBQUFBLFFBRXBDOEQsT0FBTyxHQUFHOUQsRUFBRSxDQUFDaTFCLFlBQUgsQ0FBZ0JqMUIsRUFBRSxDQUFDNkcsbUJBQUgsQ0FBdUI3RyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQWdCOVAsTUFBaEIsQ0FBdUJndUMsVUFBdkIsRUFBbUNoaUMsRUFBbkMsQ0FBdkIsQ0FBaEIsQ0FGMEI7QUFBQSxRQUdwQ3EwQixTQUFTLEdBQUd2d0IsT0FBTyxDQUFDcFQsR0FBUixDQUFZLFVBQUFpRixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDMEssRUFBTjtBQUFBLEtBQWIsQ0FId0I7QUFLMUMsV0FBTyxVQUFDaFMsQ0FBRCxFQUFJczBDLEdBQUosRUFBWTtBQUFBLFVBQ1o5cEMsS0FBSyxHQUFHd3BDLEtBQUssR0FBR3JpQyxFQUFFLENBQUN1c0IsWUFBSCxDQUFnQmwrQixDQUFDLENBQUNnUyxFQUFsQixDQUFILEdBQTJCTCxFQUFFLENBQUNxc0IsU0FBSCxDQUFhaCtCLENBQUMsQ0FBQ2dTLEVBQWYsQ0FENUI7QUFBQSxVQUVadWlDLEVBQUUsR0FBRy9wQyxLQUFLLENBQUMsQ0FBRCxDQUZFO0FBQUEsVUFHZGd6QixNQUFNLEdBQUcrVyxFQUhLO0FBQUEsVUFJZDl4QyxDQUFDLEdBQUc2eEMsR0FKVTtBQXFDbEIsYUEvQkE3K0IsT0FBTyxDQUNMalUsT0FERixDQUNVLFVBQUE4RixDQUFDLEVBQUk7QUFBQSxZQUNQa3RDLFNBQVMsR0FBRzdpQyxFQUFFLENBQUNpZ0MsVUFBSCxDQUFjNXhDLENBQWQsSUFBbUIyUixFQUFFLENBQUM2MkIsbUJBQUgsQ0FBdUJsaEMsQ0FBQyxDQUFDdU0sTUFBekIsQ0FBbkIsR0FBc0R2TSxDQUFDLENBQUN1TSxNQUQ3RDtBQUFBLFlBRVBBLE1BQU0sR0FBRzJnQyxTQUFTLENBQUNueUMsR0FBVixDQUFjLFVBQUFsRCxDQUFDO0FBQUEsaUJBQUt3UyxFQUFFLENBQUMyRCxpQkFBSCxLQUF5QjNELEVBQUUsQ0FBQ3EzQixRQUFILENBQVksT0FBWixFQUFxQjdwQyxDQUFyQixLQUF6QixHQUF5REEsQ0FBQyxDQUFDbUMsS0FBaEU7QUFBQSxTQUFmLENBRkY7QUFJVGdHLFNBQUMsQ0FBQzBLLEVBQUYsS0FBU2hTLENBQUMsQ0FBQ2dTLEVBQVgsSUFBaUJ3WSxPQUFPLENBQUNsakIsQ0FBQyxDQUFDMEssRUFBSCxDQUFQLEtBQWtCd1ksT0FBTyxDQUFDeHFCLENBQUMsQ0FBQ2dTLEVBQUgsQ0FKakMsSUFRVGcwQixTQUFTLENBQUMxc0MsT0FBVixDQUFrQmdPLENBQUMsQ0FBQzBLLEVBQXBCLElBQTBCZzBCLFNBQVMsQ0FBQzFzQyxPQUFWLENBQWtCMEcsQ0FBQyxDQUFDZ1MsRUFBcEIsQ0FSakIsTUFVUnpTLFdBQVcsQ0FBQ2kxQyxTQUFTLENBQUMveEMsQ0FBRCxDQUFWLENBQVgsSUFBNkIsQ0FBQyt4QyxTQUFTLENBQUMveEMsQ0FBRCxDQUFULENBQWFNLENBQWQsS0FBb0IsQ0FBQy9DLENBQUMsQ0FBQytDLENBVjVDLE1BWVhOLENBQUMsR0FBRyxDQUFDLENBWk0sRUFjWCt4QyxTQUFTLENBQUNoekMsT0FBVixDQUFrQixVQUFDckMsQ0FBRCxFQUFJMGdDLENBQUosRUFBVTtBQUFBLGNBQ3JCdGMsRUFBRSxHQUFHcGtCLENBQUMsQ0FBQzRELENBQUYsQ0FBSXBDLFdBQUosS0FBb0JQLElBQXBCLEdBQTJCLENBQUNqQixDQUFDLENBQUM0RCxDQUE5QixHQUFrQzVELENBQUMsQ0FBQzRELENBRHBCO0FBQUEsY0FFckJ5Z0IsRUFBRSxHQUFHeGpCLENBQUMsQ0FBQytDLENBQUYsQ0FBSXBDLFdBQUosS0FBb0JQLElBQXBCLEdBQTJCLENBQUNKLENBQUMsQ0FBQytDLENBQTlCLEdBQWtDL0MsQ0FBQyxDQUFDK0MsQ0FGcEI7QUFJdkJ3Z0IsWUFBRSxLQUFLQyxFQUpnQixLQUsxQi9nQixDQUFDLEdBQUdvOUIsQ0FMc0I7QUFPM0IsU0FQRCxDQWRXLEdBd0JScDlCLENBQUMsSUFBSSt4QyxTQUFMLElBQWtCQSxTQUFTLENBQUMveEMsQ0FBRCxDQUFULENBQWFuQixLQUFiLEdBQXFCdEIsQ0FBQyxDQUFDc0IsS0FBdkIsSUFBZ0MsQ0F4QjFDLEtBeUJYazhCLE1BQU0sSUFBSWh6QixLQUFLLENBQUNxSixNQUFNLENBQUNwUixDQUFELENBQVAsQ0FBTCxHQUFtQjh4QyxFQXpCbEI7QUE0QmIsT0E3QkYsQ0ErQkEsRUFBTy9XLE1BQVA7QUFDQSxLQXRDRDtBQXVDQSxHQTlIOEI7QUFnSS9COFMsZUFoSStCLHlCQWdJakJtRSxJQWhJaUIsRUFnSVh6MEMsQ0FoSVcsRUFnSVI7QUFBQSxRQUdsQjAwQyxRQUhrQjtBQUFBLFFBQ2hCL2lDLEVBQUUsR0FBRyxJQURXO0FBQUEsUUFFaEJyVSxLQUFLLEdBQUc0USxpR0FBUSxDQUFDdW1DLElBQUQsQ0FGQTtBQWV0QixXQVZLOWlDLEVBQUUsQ0FBQ3NVLGNBQUgsQ0FBa0JqbUIsQ0FBQyxDQUFDZ1MsRUFBcEIsQ0FVTCxHQVJXTCxFQUFFLENBQUNnakMsaUJBQUgsQ0FBcUJGLElBQUksQ0FBQ0csUUFBMUIsQ0FRWCxHQVBDRixRQUFRLEdBQUcvaUMsRUFBRSxDQUFDaWdDLFVBQUgsQ0FBYzV4QyxDQUFkLElBQ1YyUixFQUFFLENBQUNrakMsWUFBSCxDQUFnQkosSUFBaEIsRUFBc0I5aUMsRUFBRSxDQUFDcXNCLFNBQUgsQ0FBYWgrQixDQUFDLENBQUNnUyxFQUFmLEVBQW1CaFMsQ0FBQyxDQUFDc0IsS0FBckIsQ0FBdEIsQ0FEVSxHQUVWcVEsRUFBRSxDQUFDbWpDLGNBQUgsQ0FBa0JMLElBQWxCLEVBQXdCOWlDLEVBQUUsQ0FBQ3ViLFlBQUgsQ0FBZ0JsdEIsQ0FBaEIsSUFBcUIyUixFQUFFLENBQUNvakMsWUFBSCxDQUFnQi8wQyxDQUFoQixJQUFxQixHQUExQyxHQUFnRCxDQUF4RSxDQUtGLEdBSld5MEMsSUFBSSxDQUFDRyxRQUFMLEtBQWtCLE1BSTdCLEtBSENGLFFBQVEsSUFBR3AzQyxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDOUosR0FBcEIsQ0FBSCxJQUE4QnlYLEVBQUUsQ0FBQ3UyQixXQUFILENBQWV1TSxJQUFmLENBR3ZDLElBVENDLFFBQVEsS0FTVCxFQUFPQSxRQUFQO0FBQ0EsR0FoSjhCO0FBa0ovQk0sZ0JBbEorQiwwQkFrSmhCaDFDLENBbEpnQixFQWtKYjtBQUFBLFFBQ1gyUixFQUFFLEdBQUcsSUFETTtBQUFBLFFBRVhzakMsYUFBYSxHQUFHdGpDLEVBQUUsQ0FBQ3VqQyxrQkFBSCxDQUFzQmwxQyxDQUF0QixDQUZMO0FBSWpCLFdBQU87QUFDTixlQUFTbTFDLGlGQURIO0FBRU4sc0JBQWdCQyx1RkFGVjtBQUdOLG9CQUFjQyxxRkFIUjtBQUlOLGdCQUFVQyxrRkFKSjtBQUtOLGtCQUFZQyxvRkFMTjtBQU1OLHlCQUFtQkMsMEZBTmI7QUFPTix1QkFBaUJDLHdGQVBYO0FBUU4scUJBQWVDLHNGQVJUO0FBU04sNEJBQXNCQyw0RkFUaEI7QUFVTiwwQkFBb0JDLDBGQVZkO0FBV04sb0JBQWNDLHFGQVhSO0FBWU4sb0JBQWNDLHFGQVpSO0FBYU4saUJBQVdDLG1GQWJMO0FBY04sdUJBQWlCQyx3RkFkWDtBQWVOLGdCQUFVQyxrRkFmSjtBQWdCTixjQUFRQyxnRkFoQkY7QUFpQk4sb0JBQWNDLHFGQWpCUjtBQWtCTixxQkFBZUMsc0ZBQWlCQTtBQWxCMUIsTUFtQkxuQixhQW5CSyxDQUFQO0FBb0JBLEdBMUs4QjtBQTRLL0JDLG9CQTVLK0IsOEJBNEtabDFDLENBNUtZLEVBNEtUO0FBQUEsUUFDZjJSLEVBQUUsR0FBRyxJQURVO0FBQUEsUUFFZmpMLElBQUksR0FBR2lMLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTR3Qix5QkFGRjtBQUFBLFFBR2Y4WixhQUFhLEdBQUd0akMsRUFBRSxDQUFDMGtDLG1CQUFILENBQXVCM3ZDLElBQXZCLElBQStCQSxJQUEvQixHQUFzQyxVQUh2QztBQUtyQixXQUFPaUwsRUFBRSxDQUFDMmtDLFlBQUgsQ0FBZ0J0MkMsQ0FBaEIsSUFDTmkxQyxhQURNLEdBRUx0akMsRUFBRSxDQUFDaWdDLFVBQUgsQ0FBYzV4QyxDQUFkLElBQ0MyUixFQUFFLENBQUNwSCxNQUFILENBQVVndUIsY0FEWCxHQUM0QixRQUg5QjtBQUtBO0FBdEw4QixDQUExQixDOzs7OztBQzdCTjs7OztBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBajBCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9CMmxCLFNBRCtCLHFCQUNyQjtBQUFBLFFBQ0g1a0MsRUFBRSxHQUFHLElBREY7QUFBQSxRQUVIcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVDtBQUFBLFFBR0g4TyxPQUFPLEdBQUc5TyxNQUFNLENBQUN1dkIsV0FIZDtBQUFBLFFBS0h1UCxRQUFRLEdBQUcxM0IsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLEtBQVgsS0FBcUJsRyxPQUFyQixHQUNoQkEsT0FBTyxHQUFHLEdBRE0sR0FDQzlPLE1BQU0sV0FBSUEsTUFBTSxDQUFDMG5CLFNBQVgsZUFBTixHQUNoQjFuQixNQUFNLFdBQUlBLE1BQU0sQ0FBQzBuQixTQUFYLGVBRFUsR0FDeUIsQ0FQbEM7QUFTVHRnQixNQUFFLENBQUN5M0IsR0FBSCxHQUFTb04sa0ZBQUssR0FDWm5OLFFBRE8sQ0FDRUEsUUFERixFQUVQb04sVUFGTyxDQUdQOWtDLEVBQUUsQ0FBQ2cxQixVQUFILE1BQW1CaDFCLEVBQUUsQ0FBQyswQixXQUFILEVBQW5CLEdBQ0MsVUFBQ3RnQyxDQUFELEVBQUlDLENBQUo7QUFBQSxhQUFXc0wsRUFBRSxDQUFDZzFCLFVBQUgsS0FBa0J2Z0MsQ0FBQyxHQUFHQyxDQUF0QixHQUEwQkEsQ0FBQyxHQUFHRCxDQUF6QztBQUFBLEtBREQsR0FDK0MsSUFKeEMsRUFNUDlFLEtBTk8sQ0FNRCxVQUFBdEIsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQzZULE1BQUYsQ0FBU2hPLE1BQVQsQ0FBZ0IsVUFBQ08sQ0FBRCxFQUFJQyxDQUFKO0FBQUEsZUFBVUQsQ0FBQyxHQUFHQyxDQUFDLENBQUMvRSxLQUFoQjtBQUFBLE9BQWhCLEVBQXVDLENBQXZDLENBQUo7QUFBQSxLQU5BLENBVEE7QUFnQlQsR0FqQjhCO0FBbUIvQmtrQixjQW5CK0IsMEJBbUJoQjtBQUFBLFFBQ1I3VCxFQUFFLEdBQUcsSUFERztBQUFBLFFBRVJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZKO0FBQUEsUUFHUm1zQyxNQUFNLEdBQUduc0MsTUFBTSxDQUFDcXZCLGVBSFI7QUFBQSxRQUlSdmdCLE9BQU8sR0FBRzlPLE1BQU0sQ0FBQ3V2QixXQUpUO0FBQUEsUUFLUjl0QixDQUFDLEdBQUd6QixNQUFNLENBQUNnd0IsV0FBUCxJQUFzQmh3QixNQUFNLENBQUN1d0IsV0FMekI7QUFPZG5wQixNQUFFLENBQUM4VCxjQUFILEdBQW9COWxCLElBQUksQ0FBQzJELEdBQUwsQ0FBU3FPLEVBQUUsQ0FBQ3lULFFBQVosRUFBc0J6VCxFQUFFLENBQUMwVCxTQUF6QixJQUFzQyxDQVA1QyxFQVFkMVQsRUFBRSxDQUFDK2tDLE1BQUgsR0FBWS9rQyxFQUFFLENBQUM4VCxjQUFILEdBQW9CLEdBUmxCLEVBU2Q5VCxFQUFFLENBQUNnbEMsZ0JBQUgsR0FBc0IzcUMsQ0FBQyxHQUFHLENBQUMyRixFQUFFLENBQUMra0MsTUFBSCxHQUFZMXFDLENBQWIsSUFBa0IyRixFQUFFLENBQUMra0MsTUFBeEIsR0FBaUMsRUFUMUM7QUFXZCxRQUFNRSxXQUFXLEdBQUdGLE1BQU0sS0FDekJyOUIsT0FBTyxHQUFHQSxPQUFPLElBQUkxSCxFQUFFLENBQUNnbEMsZ0JBQUgsR0FBc0IsRUFBMUIsQ0FBVixHQUEyQyxDQUR6QixDQUExQixDQVhjLENBZWQ7O0FBQ0FobEMsTUFBRSxDQUFDaWxDLFdBQUgsR0FBaUJqbEMsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsS0FBdUI1TixFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQUF2QixHQUNoQjVOLEVBQUUsQ0FBQytrQyxNQUFILEdBQVkva0MsRUFBRSxDQUFDZ2xDLGdCQURDLEdBQ2tCQyxXQWpCckI7QUFrQmQsR0FyQzhCO0FBdUMvQkMsZ0JBdkMrQiwwQkF1Q2hCNzJDLENBdkNnQixFQXVDYjtBQUFBLFFBQ1gyUixFQUFFLEdBQUcsSUFETTtBQUFBLFFBRWIra0MsTUFBTSxHQUFHL2tDLEVBQUUsQ0FBQ2lsQyxXQUZDO0FBUWpCLFdBSkksQ0FBQ3QzQyxRQUFRLENBQUNvM0MsTUFBRCxDQUFULElBQXFCMTJDLENBSXpCLEtBSEMwMkMsTUFBTSxHQUFHQSxNQUFNLENBQUMxMkMsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFBUixDQUFOLElBQXFCLENBRy9CLEdBQU8wa0MsTUFBUDtBQUNBLEdBaEQ4QjtBQWtEL0JyWCxXQWxEK0IsdUJBa0RuQjtBQUNYLFFBQU0xdEIsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDbWxDLE1BQUgsR0FBWW5sQyxFQUFFLENBQUNvbEMsU0FBSCxFQUhELEVBSVhwbEMsRUFBRSxDQUFDcWxDLGNBQUgsR0FBb0JybEMsRUFBRSxDQUFDc2xDLGlCQUFILEVBSlQsRUFLWHRsQyxFQUFFLENBQUN1bEMsaUJBQUgsR0FBdUJ2bEMsRUFBRSxDQUFDc2xDLGlCQUFILENBQXFCLEdBQXJCLENBTFo7QUFNWCxHQXhEOEI7QUEwRC9CRSxhQTFEK0IsdUJBMERuQkMsTUExRG1CLEVBMERYO0FBQUEsUUFDYnpsQyxFQUFFLEdBQUcsSUFEUTtBQUFBLFFBRWJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZDO0FBQUEsUUFHZjYrQixHQUFHLEdBQUd6M0IsRUFBRSxDQUFDeTNCLEdBSE07QUFBQSxRQUlmcHBDLENBQUMsR0FBR28zQyxNQUpXO0FBQUEsUUFLZjcxQyxLQUFLLEtBTFU7QUFPbkIsUUFBSSxDQUFDZ0osTUFBTCxFQUNDLE9BQU8sSUFBUDs7QUFHRCxRQUFJdkssQ0FBQyxDQUFDMEYsSUFBRixJQUFVaU0sRUFBRSxDQUFDMGxDLFdBQUgsQ0FBZXIzQyxDQUFDLENBQUMwRixJQUFqQixDQUFkLEVBQXNDO0FBQ3JDLFVBQU00eEMsUUFBUSxHQUFHM2xDLEVBQUUsQ0FBQzR6QixlQUFILEVBQWpCLENBRHFDLENBR3JDOztBQUNJK1IsY0FBUSxHQUFHL3NDLE1BQU0sQ0FBQzJ2QixTQUplLEtBS3BDM3ZCLE1BQU0sQ0FBQzJ2QixTQUFQLEdBQW1Cb2QsUUFMaUI7QUFBQSxVQVEvQlosTUFBTSxHQUFHLzJDLElBQUksQ0FBQ2lRLEVBQUwsSUFBV3JGLE1BQU0sQ0FBQythLGdCQUFQLEdBQTBCLENBQTFCLEdBQThCLENBQXpDLENBUnNCO0FBQUEsVUFTL0JpeUIsTUFBTSxHQUFHaHRDLE1BQU0sQ0FBQzR2QixtQkFUZTtBQUFBLFVBVS9CcWQsSUFBSSxHQUFHZCxNQUFNLElBQUlZLFFBQVEsSUFBSS9zQyxNQUFNLENBQUMydkIsU0FBUCxHQUFtQjN2QixNQUFNLENBQUMwdkIsU0FBOUIsQ0FBWixDQVZrQjtBQVlyQ21QLFNBQUcsR0FBR3ozQixFQUFFLENBQUN5M0IsR0FBSCxDQUNKRyxVQURJLENBQ09nTyxNQURQLEVBRUpqTyxRQUZJLENBRUtrTyxJQUFJLEdBQUdELE1BRlosQ0FaK0I7QUFlckM7O0FBaUJELFdBZkFuTyxHQUFHLENBQUN6M0IsRUFBRSxDQUFDNkcsbUJBQUgsRUFBRCxDQUFILENBQThCaFgsT0FBOUIsQ0FBc0MsVUFBQThGLENBQUMsRUFBSTtBQUNyQy9GLFdBQUQsSUFBVStGLENBQUMsQ0FBQzVCLElBQUYsQ0FBT3NNLEVBQVAsS0FBY2hTLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBRE8sS0FFekN6USxLQUFLLEtBRm9DLEVBR3pDdkIsQ0FBQyxHQUFHc0gsQ0FIcUM7QUFLMUMsS0FMRCxDQWVBLEVBUkkvRyxLQUFLLENBQUNQLENBQUMsQ0FBQ3VwQyxVQUFILENBUVQsS0FQQ3ZwQyxDQUFDLENBQUN1cEMsVUFBRixHQUFlLENBT2hCLEdBSklocEMsS0FBSyxDQUFDUCxDQUFDLENBQUNzcEMsUUFBSCxDQUlULEtBSEN0cEMsQ0FBQyxDQUFDc3BDLFFBQUYsR0FBYXRwQyxDQUFDLENBQUN1cEMsVUFHaEIsR0FBT2hvQyxLQUFLLEdBQUd2QixDQUFILEdBQU8sSUFBbkI7QUFDQSxHQXRHOEI7QUF3Ry9CKzJDLFdBeEcrQix1QkF3R25CO0FBQUEsUUFDTHBsQyxFQUFFLEdBQUcsSUFEQTtBQUFBLFFBRUw4bEMsRUFBRSxHQUFHOWxDLEVBQUUsQ0FBQ2tsQyxjQUFILEVBRkE7QUFBQSxRQUdQdDlDLEdBQUcsR0FBR20rQyxrRkFBSyxHQUNiQyxXQURRLENBQ0lobUMsRUFBRSxDQUFDK2tDLE1BRFAsRUFFUkUsV0FGUSxDQUVJdDNDLFFBQVEsQ0FBQ200QyxFQUFELENBQVIsR0FBZUEsRUFBZixHQUFvQixDQUZ4QixDQUhDO0FBQUEsUUFPTEcsTUFBTSxHQUFHLFVBQUM1M0MsQ0FBRCxFQUFJNjNDLGFBQUosRUFBc0I7QUFDcEMsVUFBSWgxQyxJQUFJLEdBQUcsT0FBWDs7QUFFQSxVQUFJN0MsQ0FBQyxDQUFDc0IsS0FBRixJQUFXdEIsQ0FBQyxDQUFDMEYsSUFBakIsRUFBdUI7QUFDakJwRyxnQkFBUSxDQUFDbTRDLEVBQUQsQ0FEUyxLQUVyQmwrQyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3E5QyxXQUFKLENBQWdCamxDLEVBQUUsQ0FBQ2tsQyxjQUFILENBQWtCNzJDLENBQWxCLENBQWhCLENBRmU7QUFLdEIsWUFBTTgzQyxPQUFPLEdBQUcsQ0FBQ0QsYUFBRCxJQUFrQmxtQyxFQUFFLENBQUN3bEMsV0FBSCxDQUFlbjNDLENBQWYsQ0FBbEM7QUFFSTYzQyxxQkFQa0IsR0FRckJoMUMsSUFBSSxHQUFHdEosR0FBRyxDQUFDeUcsQ0FBRCxDQVJXLEdBU1g4M0MsT0FUVyxLQVVyQmoxQyxJQUFJLEdBQUd0SixHQUFHLENBQUN1K0MsT0FBRCxDQVZXO0FBWXRCOztBQUVELGFBQU9qMUMsSUFBUDtBQUNBLEtBekJVOztBQThCWCxXQUZBKzBDLE1BQU0sQ0FBQ0csUUFBUCxHQUFrQngrQyxHQUFHLENBQUN3K0MsUUFFdEIsRUFBT0gsTUFBUDtBQUNBLEdBdkk4QjtBQXlJL0JYLG1CQXpJK0IsNkJBeUliZSxJQXpJYSxFQXlJUDtBQUFBLFFBQ2pCcm1DLEVBQUUsR0FBRyxJQURZO0FBQUEsUUFFakJwWSxHQUFHLEdBQUdtK0Msa0ZBQUssR0FDZkMsV0FEVSxDQUNFaG1DLEVBQUUsQ0FBQzhULGNBQUgsSUFBcUJ1eUIsSUFBSSxJQUFJLENBQTdCLENBREYsQ0FGVztBQUt2QixXQUFPLFVBQVNoNEMsQ0FBVCxFQUFZO0FBQ2xCLFVBQU04M0MsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQ3dsQyxXQUFILENBQWVuM0MsQ0FBZixDQUFoQjtBQUVBLGFBQU84M0MsT0FBTyxHQUFHditDLEdBQUcsQ0FBQ3E5QyxXQUFKLENBQWdCamxDLEVBQUUsQ0FBQ2tsQyxjQUFILENBQWtCNzJDLENBQWxCLENBQWhCLEVBQXNDODNDLE9BQXRDLENBQUgsR0FBb0QsT0FBbEU7QUFDQSxLQUpEO0FBS0EsR0FuSjhCO0FBcUovQkcsUUFySitCLGtCQXFKeEJqNEMsQ0FySndCLEVBcUpyQjYzQyxhQXJKcUIsRUFxSk5odUMsS0FySk0sRUFxSkM7QUFDL0IsV0FBT0EsS0FBSyxJQUFJLEtBQUtxdUMsU0FBTCxDQUFlbDRDLENBQUMsQ0FBQzBGLElBQWpCLENBQVQsR0FBa0MsS0FBS294QyxNQUFMLENBQVk5MkMsQ0FBWixFQUFlNjNDLGFBQWYsQ0FBbEMsR0FBa0UsT0FBekU7QUFDQSxHQXZKOEI7QUF5Si9CTSxzQkF6SitCLGdDQXlKVm40QyxDQXpKVSxFQXlKUDtBQUFBLFFBQ2pCMlIsRUFBRSxHQUFHLElBRFk7QUFBQSxRQUVqQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRks7QUFBQSxRQUdqQnV0QyxPQUFPLEdBQUdubUMsRUFBRSxDQUFDd2xDLFdBQUgsQ0FBZW4zQyxDQUFmLENBSE87QUFBQSxRQUluQm80QyxTQUFTLEdBQUcsRUFKTzs7QUFNdkIsUUFBSU4sT0FBTyxLQUFLLENBQUNubUMsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsQ0FBRCxJQUF3QjVOLEVBQUUsQ0FBQzAwQixlQUFILEVBQTdCLENBQVgsRUFBK0Q7QUFBQSxVQUN4RHZnQyxDQUFDLEdBQUcsS0FBS2d4QyxNQUFMLENBQVlpQixRQUFaLENBQXFCRCxPQUFyQixDQURvRDtBQUFBLFVBRXhELzBDLENBQUMsR0FBR3hDLEtBQUssQ0FBQ3VGLENBQUMsQ0FBQyxDQUFELENBQUYsQ0FBTCxHQUFjLENBQWQsR0FBa0JBLENBQUMsQ0FBQyxDQUFELENBRmlDO0FBQUEsVUFHeEQ5QyxDQUFDLEdBQUd6QyxLQUFLLENBQUN1RixDQUFDLENBQUMsQ0FBRCxDQUFGLENBQUwsR0FBYyxDQUFkLEdBQWtCQSxDQUFDLENBQUMsQ0FBRCxDQUhpQztBQUFBLFVBSXhEbUcsQ0FBQyxHQUFHdE0sSUFBSSxDQUFDMm9DLElBQUwsQ0FBVXZsQyxDQUFDLEdBQUdBLENBQUosR0FBUUMsQ0FBQyxHQUFHQSxDQUF0QixDQUpvRDtBQUFBLFVBTTFEbStCLEtBQUssR0FBSXh2QixFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxLQUF1QmhWLE1BQU0sQ0FBQ3N3QixpQkFBL0IsSUFDVmxwQixFQUFFLENBQUM0TixPQUFILENBQVcsS0FBWCxLQUFxQmhWLE1BQU0sQ0FBQ2t2QixlQVBnQztBQVU3RDBILFdBVjZELEdBUzFEQSxLQVQwRCxHQVVyRC9oQyxVQUFVLENBQUMraEMsS0FBRCxDQUFWLEdBQW9CQSxLQUFLLENBQUNuaEMsQ0FBRCxFQUFJMlIsRUFBRSxDQUFDK2tDLE1BQVAsRUFBZXpxQyxDQUFmLENBQXpCLEdBQTZDazFCLEtBVlEsR0FZckR4dkIsRUFBRSxDQUFDK2tDLE1BQUgsS0FDTnpxQyxDQUFDLEdBQUcsQ0FBQyxLQUFLMEYsRUFBRSxDQUFDK2tDLE1BQVIsR0FBaUIsSUFBakIsR0FBeUIsUUFBUSxLQUFLL2tDLEVBQUUsQ0FBQytrQyxNQUF6QyxHQUFrRCxFQUFuRCxJQUEwRC9rQyxFQUFFLENBQUMra0MsTUFBN0QsR0FBc0V6cUMsQ0FBekUsR0FBNkUsQ0FEeEUsQ0FacUQsRUFnQjlEbXNDLFNBQVMsdUJBQWdCcjFDLENBQUMsR0FBR28rQixLQUFwQixjQUE2Qm4rQixDQUFDLEdBQUdtK0IsS0FBakMsTUFoQnFEO0FBaUI5RDs7QUFFRCxXQUFPaVgsU0FBUDtBQUNBLEdBbkw4QjtBQXFML0JDLGtCQXJMK0IsNEJBcUxkcjRDLENBckxjLEVBcUxYO0FBQ25CLFdBQU8sS0FBSzRqQyxPQUFMLENBQWE7QUFDbkI1eEIsUUFBRSxFQUFFaFMsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFEUTtBQUVuQjFRLFdBQUssRUFBRXRCLENBQUMsQ0FBQ3NCLEtBRlU7QUFHbkI2L0IsV0FBSyxFQUFFLEtBQUs2SCxRQUFMLENBQWMsS0FBZCxFQUFxQmhwQyxDQUFyQixDQUhZO0FBSW5Cc1AsV0FBSyxFQUFFdFAsQ0FBQyxDQUFDc1A7QUFKVSxLQUFiLENBQVA7QUFNQSxHQTVMOEI7QUE4TC9CZ3BDLGlCQTlMK0IsMkJBOExmNzBDLFNBOUxlLEVBOExKO0FBQzFCLFFBQU1rTyxFQUFFLEdBQUcsSUFBWDtBQUVJQSxNQUFFLENBQUM0bUMsa0JBQUgsRUFIc0IsSUFJekI5MEMsU0FBUyxDQUFDd0ssSUFBVixDQUFlLFVBQVNqTyxDQUFULEVBQVk7QUFBQSxVQUNwQmtDLElBQUksR0FBR2dNLGlHQUFRLENBQUMsSUFBRCxDQURLO0FBQUEsVUFFcEI0cEMsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQ3dsQyxXQUFILENBQWVuM0MsQ0FBZixDQUZVO0FBQUEsVUFHcEJzQixLQUFLLEdBQUd3MkMsT0FBTyxHQUFHQSxPQUFPLENBQUN4MkMsS0FBWCxHQUFtQixJQUhkO0FBQUEsVUFJcEI2L0IsS0FBSyxHQUFHeHZCLEVBQUUsQ0FBQ3EzQixRQUFILENBQVksS0FBWixFQUFtQjhPLE9BQW5CLENBSlk7QUFBQSxVQUtwQjlsQyxFQUFFLEdBQUdoUyxDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUxRO0FBQUEsVUFNcEJ3bUMsZ0JBQWdCLEdBQ3BCN21DLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLENBQUQsSUFBeUI1TixFQUFFLENBQUM4bUMsc0JBQUgsQ0FBMEJ0WCxLQUExQixDQVBBOztBQVUxQixVQUFJcVgsZ0JBQUosRUFBc0I7QUFDckIsWUFBTTE2QyxJQUFJLEdBQUcsQ0FDWjZULEVBQUUsQ0FBQyttQyxpQkFBSCxNQUEwQi9tQyxFQUFFLENBQUNnbkMscUJBRGpCLEVBRVhyM0MsS0FGVyxFQUVKNi9CLEtBRkksRUFFR252QixFQUZILEVBRU94TSxRQUZQLEVBQWI7QUFJQXZELG9CQUFZLENBQUNDLElBQUQsRUFBT3BFLElBQVAsQ0FMUztBQU1yQjtBQUNELEtBakJELENBSnlCO0FBdUIxQixHQXJOOEI7QUF1Ti9CODZDLG9CQXZOK0IsOEJBdU5adDNDLEtBdk5ZLEVBdU5MdTNDLEtBdk5LLEVBdU5FO0FBQ2hDLFFBQU16bkMsTUFBTSxHQUFHLEtBQUswbkMsb0JBQUwsRUFBZjtBQUVBLFdBQU8xbkMsTUFBTSxHQUFHQSxNQUFNLENBQUM5UCxLQUFELEVBQVF1M0MsS0FBUixDQUFULEdBQTBCdjNDLEtBQXZDO0FBQ0EsR0EzTjhCO0FBNk4vQnkzQyxXQTdOK0IscUJBNk5yQi9TLFNBN05xQixFQTZOVjtBQUNwQixRQUFNcjBCLEVBQUUsR0FBRyxJQUFYLENBRG9CLENBR3BCOztBQUNBLFFBQUlBLEVBQUUsQ0FBQzRKLFVBQVAsRUFBbUI7QUFDbEIsVUFBTWpLLFFBQVEsR0FBRzBuQyxXQUFXLENBQUMsWUFBTTtBQUM3QnJuQyxVQUFFLENBQUM0SixVQUQwQixLQUVqQzA5QixhQUFhLENBQUMzbkMsUUFBRCxDQUZvQixFQUlqQ0ssRUFBRSxDQUFDc1IsTUFBSCxDQUFVelUsU0FBVixZQUF3QnhLLGNBQUssQ0FBQ3RILGlCQUE5QixHQUFtRHFQLElBQW5ELEtBQTRELENBQTVELElBQ0M0RixFQUFFLENBQUNvbkMsU0FBSCxDQUFhL1MsU0FBYixDQUxnQztBQU9sQyxPQVAyQixFQU96QixFQVB5QixDQUE1QjtBQVNBO0FBQ0E7O0FBRUQsUUFBTWtULFlBQVksR0FBR3ZuQyxFQUFFLENBQUNpMEIsY0FBSCxDQUFrQkksU0FBbEIsQ0FBckI7QUFFQXIwQixNQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLENBQWlCbUQsRUFBRSxDQUFDd25DLGVBQUgsQ0FBbUJELFlBQW5CLGFBQXFDbDFDLGNBQUssQ0FBQ3hKLFFBQTNDLEVBQWpCLEVBQ0V5VCxJQURGLENBQ08sVUFBU2pPLENBQVQsRUFBWTtBQUNqQixVQUFLMlIsRUFBRSxDQUFDeW5DLFlBQUgsQ0FBZ0JwNUMsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFBdkIsQ0FBRCxJQUErQmhTLENBQUMsQ0FBQ3NCLEtBQUYsS0FBWSxDQUEvQztBQUlBLFlBQU0rM0MsY0FBYyxHQUFHMW5DLEVBQUUsQ0FBQzBuQyxjQUFILENBQWtCcjVDLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBQXpCLENBQXZCO0FBRUE5RCx5R0FBUSxDQUFDLElBQUQsQ0FBUixDQUFlTSxTQUFmLENBQXlCLE1BQXpCLEVBQ0UxQyxVQURGLEdBRUUrTixRQUZGLENBRVd3L0IsY0FGWCxFQUdFMTJDLElBSEYsQ0FHTyxHQUhQLEVBR1lnUCxFQUFFLENBQUNxbEMsY0FIZixFQUlFbHJDLFVBSkYsR0FLRStOLFFBTEYsQ0FLV3cvQixjQUFjLEdBQUcsQ0FMNUIsRUFNRTEyQyxJQU5GLENBTU8sR0FOUCxFQU1ZZ1AsRUFBRSxDQUFDdWxDLGlCQU5mLENBTkE7QUFBQTtBQWFBLEtBZkYsQ0FuQm9CO0FBbUNwQixHQWhROEI7QUFrUS9Cb0MsYUFsUStCLHVCQWtRbkJ0VCxTQWxRbUIsRUFrUVI7QUFDdEIsUUFBTXIwQixFQUFFLEdBQUcsSUFBWDs7QUFFQSxTQUFJQSxFQUFFLENBQUM0SixVQUFQO0FBSUEsVUFBTTI5QixZQUFZLEdBQUd2bkMsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JJLFNBQWxCLENBQXJCO0FBRUFyMEIsUUFBRSxDQUFDMEcsR0FBSCxDQUFPN0osU0FBUCxDQUFpQm1ELEVBQUUsQ0FBQ3duQyxlQUFILENBQW1CRCxZQUFuQixhQUFxQ2wxQyxjQUFLLENBQUN4SixRQUEzQyxFQUFqQixFQUNFZ1UsU0FERixDQUNZLE1BRFosRUFFRTFDLFVBRkYsR0FHRStOLFFBSEYsQ0FHVyxVQUFBN1osQ0FBQztBQUFBLGVBQUkyUixFQUFFLENBQUMwbkMsY0FBSCxDQUFrQnI1QyxDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUF6QixDQUFKO0FBQUEsT0FIWixFQUlFclAsSUFKRixDQUlPLEdBSlAsRUFJWWdQLEVBQUUsQ0FBQ21sQyxNQUpmLENBTkEsRUFZQW5sQyxFQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLFdBQW9CeEssY0FBSyxDQUFDekssR0FBMUIsR0FDRXVPLEtBREYsQ0FDUSxTQURSLEVBQ21CLEdBRG5CLENBWkE7QUFBQTtBQWNBLEdBblI4QjtBQXFSL0J1eEMsZ0JBclIrQiwwQkFxUmhCcm5DLEVBclJnQixFQXFSWjtBQUFBLFFBR2R0TCxJQUhjO0FBQUEsUUFDWmlMLEVBQUUsR0FBRyxJQURPO0FBQUEsUUFFWnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkE7QUFhbEIsV0FSSW9ILEVBQUUsQ0FBQzRuQyxXQUFILENBQWV2bkMsRUFBZixDQVFKLEdBUEN0TCxJQUFJLEdBQUcsT0FPUixHQU5XaUwsRUFBRSxDQUFDMGxDLFdBQUgsQ0FBZXJsQyxFQUFmLENBTVgsR0FMQ3RMLElBQUksR0FBRyxPQUtSLEdBSldpTCxFQUFFLENBQUM2bkMsU0FBSCxDQUFheG5DLEVBQWIsQ0FJWCxLQUhDdEwsSUFBSSxHQUFHLEtBR1IsR0FBT0EsSUFBSSxHQUFHNkQsTUFBTSxXQUFJN0QsSUFBSixzQkFBVCxHQUF1QyxFQUFsRDtBQUNBLEdBblM4QjtBQXFTL0IweUMsY0FyUytCLHdCQXFTbEJwbkMsRUFyU2tCLEVBcVNkO0FBQUEsUUFDVkwsRUFBRSxHQUFHLElBREs7QUFBQSxRQUVWcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGRjtBQUloQixXQUFRb0gsRUFBRSxDQUFDNG5DLFdBQUgsQ0FBZXZuQyxFQUFmLEtBQXNCekgsTUFBTSxDQUFDeXdCLFlBQTlCLElBQ0xycEIsRUFBRSxDQUFDMGxDLFdBQUgsQ0FBZXJsQyxFQUFmLEtBQXNCekgsTUFBTSxDQUFDaXdCLFlBRHhCLElBRUw3b0IsRUFBRSxDQUFDNm5DLFNBQUgsQ0FBYXhuQyxFQUFiLEtBQW9CekgsTUFBTSxDQUFDbXZCLFVBRjdCO0FBR0EsR0E1UzhCO0FBOFMvQjZlLG9CQTlTK0IsZ0NBOFNWO0FBQUEsUUFDZDVtQyxFQUFFLEdBQUcsSUFEUztBQUFBLFFBRWRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZFO0FBSXBCLFdBQU8sQ0FBQyxLQUFELEVBQVEsT0FBUixFQUFpQixPQUFqQixFQUNMOGhDLElBREssQ0FDQSxVQUFBbHRDLENBQUM7QUFBQSxhQUFJd1MsRUFBRSxDQUFDNE4sT0FBSCxDQUFXcGdCLENBQVgsS0FBaUJvTCxNQUFNLFdBQUlwTCxDQUFKLGlCQUEzQjtBQUFBLEtBREQsQ0FBUDtBQUVBLEdBcFQ4QjtBQXNUL0JzNUMsd0JBdFQrQixrQ0FzVFJ0WCxLQXRUUSxFQXNURDtBQUFBLFFBQ3ZCeHZCLEVBQUUsR0FBRyxJQURrQjtBQUFBLFFBRXZCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVztBQUFBLFFBR3ZCa3ZDLFNBQVMsR0FBRzluQyxFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxJQUFzQmhWLE1BQU0sQ0FBQ3F3QixxQkFBN0IsR0FBcURyd0IsTUFBTSxDQUFDaXZCLG1CQUhqRDtBQUs3QixXQUFPMkgsS0FBSyxJQUFJc1ksU0FBaEI7QUFDQSxHQTVUOEI7QUE4VC9CZixtQkE5VCtCLCtCQThUWDtBQUFBLFFBQ2IvbUMsRUFBRSxHQUFHLElBRFE7QUFBQSxRQUVicEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQztBQUFBLFFBR2Y2RyxNQUFNLEdBQUc3RyxNQUFNLENBQUNndkIsZ0JBSEQ7QUFXbkIsV0FOSTVuQixFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQU1KLEdBTENuTyxNQUFNLEdBQUc3RyxNQUFNLENBQUN5dkIsa0JBS2pCLEdBSldyb0IsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsQ0FJWCxLQUhDbk8sTUFBTSxHQUFHN0csTUFBTSxDQUFDb3dCLGtCQUdqQixHQUFPdnBCLE1BQVA7QUFDQSxHQTFVOEI7QUE0VS9CMG5DLHNCQTVVK0Isa0NBNFVSO0FBQ3RCLFFBQU12dUMsTUFBTSxHQUFHLEtBQUtBLE1BQXBCO0FBRUEsV0FBT0EsTUFBTSxDQUFDNnZCLG1CQUFkO0FBQ0EsR0FoVjhCO0FBa1YvQnNmLGFBbFYrQix5QkFrVmpCO0FBQUEsUUFDUC9uQyxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVBqTCxJQUFJLEdBQUlpTCxFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxLQUF1QixPQUF4QixJQUFxQzVOLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLEtBQXVCLE9BRjVEO0FBSWIsV0FBTzdZLElBQUksR0FBR2lMLEVBQUUsQ0FBQ3BILE1BQUgsV0FBYTdELElBQWIsWUFBSCxHQUFnQyxFQUEzQztBQUNBLEdBdlY4QjtBQXlWL0JvZixxQkF6VitCLCtCQXlWWHJRLE9BelZXLEVBeVZGO0FBQUEsUUFDdEI5RCxFQUFFLEdBQUcsSUFEaUI7QUFBQSxRQUV0Qi9OLElBQUksR0FBRytOLEVBQUUsQ0FBQy9OLElBRlk7QUFBQSxRQUd0QisxQyxRQUFRLEdBQUdob0MsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsQ0FIVztBQUFBLFFBSXRCcTZCLGFBQWEsR0FBR2pvQyxFQUFFLENBQUNpb0MsYUFBSCxDQUFpQnpzQyxJQUFqQixDQUFzQndFLEVBQXRCLENBSk07QUFBQSxRQUt0QmtvQyxTQUFTLEdBQUdsb0MsRUFBRSxDQUFDa29DLFNBQUgsQ0FBYTFzQyxJQUFiLENBQWtCd0UsRUFBbEIsQ0FMVTtBQUFBLFFBTXRCbW9DLFVBQVUsR0FBR25vQyxFQUFFLENBQUNtb0MsVUFBSCxDQUFjM3NDLElBQWQsQ0FBbUJ3RSxFQUFuQixDQU5TO0FBQUEsUUFPdEJvb0MsYUFBYSxHQUFHbjJDLElBQUksQ0FBQ0csTUFBTCxZQUFnQkMsY0FBSyxDQUFDdkosU0FBdEIsR0FDcEIrVCxTQURvQixZQUNOeEssY0FBSyxDQUFDeEosUUFEQSxHQUVwQmtMLElBRm9CLENBRWZpTSxFQUFFLENBQUN5M0IsR0FBSCxDQUFPM3pCLE9BQVAsQ0FGZSxFQUdwQjlTLElBSG9CLENBR2YsT0FIZSxFQUdOLFVBQUEzQyxDQUFDO0FBQUEsYUFBSTQ1QyxhQUFhLENBQUM1NUMsQ0FBRCxDQUFiLEdBQW1CODVDLFVBQVUsQ0FBQzk1QyxDQUFDLENBQUMwRixJQUFILENBQWpDO0FBQUEsS0FISyxDQVBNO0FBQUEsUUFZdEJzMEMsWUFBWSxHQUFHRCxhQUFhLENBQUN0ckMsS0FBZCxHQUFzQi9MLE1BQXRCLENBQTZCLEdBQTdCLEVBQ25CQyxJQURtQixDQUNkLE9BRGMsRUFDTGkzQyxhQURLLENBWk87QUFlNUJJLGdCQUFZLENBQUN0M0MsTUFBYixDQUFvQixHQUFwQixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQmszQyxTQURoQixFQUVFbnJDLEtBRkYsQ0FFUXFyQyxhQUZSLENBZjRCLEVBbUI1QkMsWUFBWSxDQUFDdDNDLE1BQWIsQ0FBb0IsTUFBcEIsRUFDRUMsSUFERixDQUNPLElBRFAsRUFDYWczQyxRQUFRLElBQUksQ0FBQ2hvQyxFQUFFLENBQUMwMEIsZUFBSCxFQUFiLEdBQW9DLE9BQXBDLEdBQThDLE9BRDNELEVBRUV2K0IsS0FGRixDQUVRLFNBRlIsRUFFbUIsR0FGbkIsRUFHRUEsS0FIRixDQUdRLGFBSFIsRUFHdUIsUUFIdkIsRUFJRUEsS0FKRixDQUlRLGdCQUpSLEVBSTBCLE1BSjFCLENBbkI0QjtBQTBCNUIsR0FuWDhCO0FBcVgvQm15QyxTQXJYK0IscUJBcVhyQjtBQUNULFFBQU10b0MsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDblksSUFBSCxHQUFVbVksRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUN6SixLQUF6QixHQUNSbUksTUFEUSxDQUNELEdBREMsRUFFUkMsSUFGUSxDQUVILE9BRkcsRUFFTXFCLGNBQUssQ0FBQ3ZKLFNBRlosRUFHUmtJLElBSFEsQ0FHSCxXQUhHLEVBR1VnUCxFQUFFLENBQUNpQixZQUFILENBQWdCLEtBQWhCLENBSFYsQ0FIRCxFQVFUakIsRUFBRSxDQUFDdW9DLFdBQUgsRUFSUztBQVNULEdBOVg4Qjs7QUFnWS9COzs7O0FBSUFBLGFBcFkrQix5QkFvWWpCO0FBQUEsUUFDUHZvQyxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVAzVCxLQUFLLEdBQUcyVCxFQUFFLENBQUMrbkMsV0FBSCxFQUZEO0FBQUEsUUFHUEMsUUFBUSxHQUFHaG9DLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLENBSEo7O0FBS2IsUUFBSXZoQixLQUFKLEVBQVc7QUFDVixVQUFNRixJQUFJLEdBQUc2VCxFQUFFLENBQUNuWSxJQUFILENBQVFrSixNQUFSLENBQWUsTUFBZixFQUNYQyxJQURXLENBQ04sT0FETSxFQUNHcUIsY0FBSyxDQUFDMjFDLFFBQVEsR0FBRyxxQkFBSCxHQUEyQixnQkFBcEMsQ0FEUixFQUVYN3hDLEtBRlcsQ0FFTCxhQUZLLEVBRVUsUUFGVixDQUFiO0FBSUk2eEMsY0FMTSxJQU1UNzdDLElBQUksQ0FDRjZFLElBREYsQ0FDTyxJQURQLEVBQ2EsUUFEYixFQUVFbUYsS0FGRixDQUVRLFdBRlIsRUFFcUIsTUFGckIsQ0FOUyxFQVdWN0YsWUFBWSxDQUFDbkUsSUFBRCxFQUFPRSxLQUFQLEVBQWMyN0MsUUFBUSxHQUFHL3lDLFNBQUgsR0FBZSxDQUFDLENBQUMsR0FBRixFQUFPLEdBQVAsQ0FBckMsQ0FYRjtBQVlWO0FBQ0QsR0F0WjhCO0FBd1ovQjBoQixXQXhaK0IscUJBd1pyQnpPLFFBeFpxQixFQXdaWHVOLGVBeFpXLEVBd1pNL0UsYUF4Wk4sRUF3WnFCO0FBQUEsUUFDN0MxUSxFQUFFLEdBQUcsSUFEd0M7QUFBQSxRQUU3Q3BILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmlDO0FBQUEsUUFHN0MzRyxJQUFJLEdBQUcrTixFQUFFLENBQUMvTixJQUhtQztBQUFBLFFBSTdDdTJDLGNBQWMsR0FBRzV2QyxNQUFNLENBQUMwVixtQkFKcUI7QUFBQSxRQU0vQ202QixPQUFPLEdBQUd4MkMsSUFBSSxDQUFDNEssU0FBTCxZQUFtQnhLLGNBQUssQ0FBQ3hLLElBQXpCLEdBQ1pnVixTQURZLFlBQ0V4SyxjQUFLLENBQUN6SyxHQURSLEdBRVptTSxJQUZZLENBRVBpTSxFQUFFLENBQUMwb0MsT0FBSCxDQUFXbHRDLElBQVgsQ0FBZ0J3RSxFQUFoQixDQUZPLENBTnFDO0FBNEVuRDtBQWxFQXlvQyxXQUFPLENBQUNuckMsSUFBUixHQUFlbkQsVUFBZixHQUNFK04sUUFERixDQUNXdU4sZUFEWCxFQUVFdGYsS0FGRixDQUVRLFNBRlIsRUFFbUIsR0FGbkIsRUFHRW9ILE1BSEYsRUFWbUQsRUFlbkRrckMsT0FBTyxHQUFHQSxPQUFPLENBQUMzckMsS0FBUixHQUFnQi9MLE1BQWhCLENBQXVCLE1BQXZCLEVBQ1JDLElBRFEsQ0FDSCxPQURHLEVBQ01nUCxFQUFFLENBQUMyb0MsUUFBSCxDQUFZbnRDLElBQVosQ0FBaUJ3RSxFQUFqQixDQUROLEVBRVI3SixLQUZRLENBRUYsTUFGRSxFQUVNLFVBQUE5SCxDQUFDO0FBQUEsYUFBSTJSLEVBQUUsQ0FBQzZKLEtBQUgsQ0FBU3hiLENBQUMsQ0FBQzBGLElBQVgsQ0FBSjtBQUFBLEtBRlAsRUFHUm9DLEtBSFEsQ0FHRixRQUhFLEVBR1EsVUFBQTlILENBQUM7QUFBQSxhQUFJbTZDLGNBQWMsS0FBSzV2QyxNQUFNLENBQUNxb0IsMkJBQVAsQ0FBbUM1eUIsQ0FBbkMsSUFBd0MsU0FBeEMsR0FBb0QsSUFBekQsQ0FBbEI7QUFBQSxLQUhULEVBSVI4SCxLQUpRLENBSUYsU0FKRSxFQUlTLEdBSlQsRUFLUm1HLElBTFEsQ0FLSCxVQUFTak8sQ0FBVCxFQUFZO0FBQ2IyUixRQUFFLENBQUMwbEMsV0FBSCxDQUFlcjNDLENBQUMsQ0FBQzBGLElBQWpCLENBRGEsS0FFaEIxRixDQUFDLENBQUN1cEMsVUFBRixHQUFlaC9CLE1BQU0sQ0FBQzR2QixtQkFGTixFQUdoQm42QixDQUFDLENBQUNzcEMsUUFBRixHQUFhLytCLE1BQU0sQ0FBQzR2QixtQkFISixHQU1qQixLQUFLb2dCLFFBQUwsR0FBZ0J2NkMsQ0FOQztBQU9qQixLQVpRLEVBYVIwTyxLQWJRLENBYUYwckMsT0FiRSxDQWZ5QyxFQThCbkRBLE9BQU8sQ0FDTHozQyxJQURGLENBQ08sV0FEUCxFQUNvQixVQUFBM0MsQ0FBQztBQUFBLGFBQUssQ0FBQzJSLEVBQUUsQ0FBQzBsQyxXQUFILENBQWVyM0MsQ0FBQyxDQUFDMEYsSUFBakIsQ0FBRCxJQUEyQjJjLGFBQTNCLEdBQTJDLFVBQTNDLEdBQXdELEVBQTdEO0FBQUEsS0FEckIsRUFFRXZhLEtBRkYsQ0FFUSxTQUZSLEVBRW1CLFVBQVM5SCxDQUFULEVBQVk7QUFDN0IsYUFBT0EsQ0FBQyxLQUFLLEtBQUt1NkMsUUFBWCxHQUFzQixHQUF0QixHQUE0QixHQUFuQztBQUNBLEtBSkYsRUFLRXRzQyxJQUxGLENBS08sWUFBTTtBQUNYMEQsUUFBRSxDQUFDNEosVUFBSCxLQURXO0FBRVgsS0FQRixFQVFFelAsVUFSRixHQVNFK04sUUFURixDQVNXQSxRQVRYLEVBVUUyZ0MsU0FWRixDQVVZLEdBVlosRUFVaUIsVUFBU3g2QyxDQUFULEVBQVk7QUFDM0IsVUFBTTgzQyxPQUFPLEdBQUdubUMsRUFBRSxDQUFDd2xDLFdBQUgsQ0FBZW4zQyxDQUFmLENBQWhCO0FBRUEsVUFBSSxDQUFDODNDLE9BQUwsRUFDQyxPQUFPO0FBQUEsZUFBTSxPQUFOO0FBQUEsT0FBUDtBQUdHdjNDLFdBQUssQ0FBQyxLQUFLZzZDLFFBQUwsQ0FBY2hSLFVBQWYsQ0FQa0IsS0FRMUIsS0FBS2dSLFFBQUwsQ0FBY2hSLFVBQWQsR0FBMkIsQ0FSRCxHQVd2QmhwQyxLQUFLLENBQUMsS0FBS2c2QyxRQUFMLENBQWNqUixRQUFmLENBWGtCLEtBWTFCLEtBQUtpUixRQUFMLENBQWNqUixRQUFkLEdBQXlCLEtBQUtpUixRQUFMLENBQWNoUixVQVpiO0FBZTNCLFVBQU1rUixXQUFXLEdBQUdDLDRHQUFhLENBQUMsS0FBS0gsUUFBTixFQUFnQnpDLE9BQWhCLENBQWpDO0FBSUEsYUFGQSxLQUFLeUMsUUFBTCxHQUFnQkUsV0FBVyxDQUFDLENBQUQsQ0FFM0IsRUFBTyxVQUFTbnpDLENBQVQsRUFBWTtBQUNsQixZQUFNcXpDLFlBQVksR0FBR0YsV0FBVyxDQUFDbnpDLENBQUQsQ0FBaEM7QUFFNEI7QUFDNUIsZUFEQXF6QyxZQUFZLENBQUNqMUMsSUFBYixHQUFvQjFGLENBQUMsQ0FBQzBGLElBQ3RCLEVBQU9pTSxFQUFFLENBQUNzbUMsTUFBSCxDQUFVMEMsWUFBVixLQUFQO0FBQ0EsT0FMRDtBQU1BLEtBbkNGLEVBb0NFaDRDLElBcENGLENBb0NPLFdBcENQLEVBb0NvQjBmLGFBQWEsR0FBRyxVQUFILEdBQWdCLEVBcENqRCxFQXFDRXZhLEtBckNGLENBcUNRLE1BckNSLEVBcUNnQixVQUFBOUgsQ0FBQztBQUFBLGFBQUsyUixFQUFFLENBQUMrSixVQUFILEdBQ3BCL0osRUFBRSxDQUFDK0osVUFBSCxDQUFjMWIsQ0FBQyxDQUFDMEYsSUFBRixDQUFPbU8sTUFBUCxDQUFjLENBQWQsRUFBaUJ2UyxLQUEvQixDQURvQixHQUNvQnFRLEVBQUUsQ0FBQzZKLEtBQUgsQ0FBU3hiLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBQWhCLENBRHpCO0FBQUEsS0FyQ2pCLEVBd0NDO0FBeENELEtBeUNFbEssS0F6Q0YsQ0F5Q1EsU0F6Q1IsRUF5Q21CLEdBekNuQixFQTBDRWpHLElBMUNGLENBMENPOFAsRUFBRSxDQUFDazhCLE1BMUNWLEVBMENrQixZQUFNO0FBQ3RCbDhCLFFBQUUsQ0FBQzRKLFVBQUgsS0FEc0I7QUFFdEIsS0E1Q0YsQ0E5Qm1ELEVBNkVuRDQrQixjQUFjLElBQUl4b0MsRUFBRSxDQUFDaXBDLFlBQUgsQ0FBZ0JSLE9BQWhCLENBN0VpQyxFQStFbkR6b0MsRUFBRSxDQUFDa3BDLGFBQUgsQ0FBaUJoaEMsUUFBakIsQ0EvRW1EO0FBZ0ZuRCxHQXhlOEI7QUEwZS9CK2dDLGNBMWUrQix3QkEwZWxCcmhELEdBMWVrQixFQTBlYjtBQUtqQixhQUFTdWhELFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCVixPQUExQixFQUFtQ3JvQyxFQUFuQyxFQUF1QztBQUV0Q0wsUUFBRSxDQUFDb25DLFNBQUgsQ0FBYS9tQyxFQUFiLENBRnNDLEVBR3RDTCxFQUFFLENBQUNpRCxHQUFILENBQU9vbUMsS0FBUCxDQUFhaHBDLEVBQWIsQ0FIc0MsRUFJdENMLEVBQUUsQ0FBQ3NwQyxpQkFBSCxDQUFxQmpwQyxFQUFyQixLQUpzQyxFQUt0Q0wsRUFBRSxDQUFDdStCLFdBQUgsQ0FBZSxDQUFDbUssT0FBRCxDQUFmLEVBQTBCVSxLQUExQixDQUxzQztBQU10Qzs7QUFFRCxhQUFTRyxXQUFULENBQXFCYixPQUFyQixFQUE4QjtBQUM3QixVQUFNcm9DLEVBQUUsR0FBSXFvQyxPQUFPLElBQUlBLE9BQU8sQ0FBQ3JvQyxFQUFwQixJQUEyQnBMLFNBQXRDO0FBRUErSyxRQUFFLENBQUMybkMsV0FBSCxDQUFldG5DLEVBQWYsQ0FINkIsRUFJN0JMLEVBQUUsQ0FBQ2lELEdBQUgsQ0FBT3VtQyxNQUFQLEVBSjZCLEVBSzdCeHBDLEVBQUUsQ0FBQ3lwQyxZQUFILEVBTDZCLEVBTTdCenBDLEVBQUUsQ0FBQzZWLFdBQUgsRUFONkI7QUFPN0I7O0FBcEJnQixRQUNYN1YsRUFBRSxHQUFHLElBRE07QUFBQSxRQUVYdU8sT0FBTyxHQUFHdk8sRUFBRSxDQUFDME0sU0FBSCxLQUFpQixPQUZoQjtBQUFBLFFBR1hnOUIsT0FBTyxHQUFHMXBDLEVBQUUsQ0FBQzBNLFNBQUgsS0FBaUIsT0FIaEI7O0FBcUVqQjtBQUNBLFFBaERBOWtCLEdBQUcsQ0FDRDRtQixFQURGLENBQ0ssT0FETCxFQUNjLFVBQVNuZ0IsQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQUEsVUFFdkI0M0MsT0FGdUI7QUFBQSxVQUNyQnZDLE9BQU8sR0FBR25tQyxFQUFFLENBQUN3bEMsV0FBSCxDQUFlbjNDLENBQWYsQ0FEVztBQUl2QjgzQyxhQUp1QixLQUsxQnVDLE9BQU8sR0FBRzFvQyxFQUFFLENBQUMwbUMsZ0JBQUgsQ0FBb0JQLE9BQXBCLENBTGdCLEVBTzFCbm1DLEVBQUUsQ0FBQ3c5QixXQUFILElBQWtCeDlCLEVBQUUsQ0FBQ3c5QixXQUFILENBQWUsSUFBZixFQUFxQmtMLE9BQXJCLEVBQThCNTNDLENBQTlCLENBUFEsRUFRMUJrUCxFQUFFLENBQUNwSCxNQUFILENBQVV3b0IsWUFBVixDQUF1Qmx4QixJQUF2QixDQUE0QjhQLEVBQUUsQ0FBQ2lELEdBQS9CLEVBQW9DeWxDLE9BQXBDLEVBQTZDLElBQTdDLENBUjBCO0FBVTNCLEtBWEYsQ0FnREEsRUFsQ0lnQixPQWtDSixJQWpDQzloRCxHQUFHLENBQ0Q0bUIsRUFERixDQUNLLFdBREwsRUFDa0IsVUFBU25nQixDQUFULEVBQVk7QUFDNUIsV0FBSTJSLEVBQUUsQ0FBQzRKLFVBQVAsRUFBcUI7QUFBckI7QUFBQSxjQUlNdThCLE9BQU8sR0FBR25tQyxFQUFFLENBQUN3bEMsV0FBSCxDQUFlbjNDLENBQWYsQ0FKaEI7QUFBQSxjQUtNcTZDLE9BQU8sR0FBR3ZDLE9BQU8sR0FBR25tQyxFQUFFLENBQUMwbUMsZ0JBQUgsQ0FBb0JQLE9BQXBCLENBQUgsR0FBa0MsSUFMekQ7QUFBQSxjQU1NOWxDLEVBQUUsR0FBSXFvQyxPQUFPLElBQUlBLE9BQU8sQ0FBQ3JvQyxFQUFwQixJQUEyQnBMLFNBTnRDO0FBUUFrMEMsbUJBQVMsQ0FBQyxJQUFELEVBQU9ULE9BQVAsRUFBZ0Jyb0MsRUFBaEIsQ0FSVCxFQVNBTCxFQUFFLENBQUNxL0IsVUFBSCxLQUFvQnFKLE9BQXBCLENBVEE7QUFBQTtBQVVBLEtBWkYsRUFhRWw2QixFQWJGLENBYUssVUFiTCxFQWFpQixVQUFBbmdCLENBQUMsRUFBSTtBQUNwQixXQUFJMlIsRUFBRSxDQUFDNEosVUFBUCxFQUFxQjtBQUFyQjtBQUFBLGNBSU11OEIsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQ3dsQyxXQUFILENBQWVuM0MsQ0FBZixDQUpoQjtBQUFBLGNBS01xNkMsT0FBTyxHQUFHdkMsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQzBtQyxnQkFBSCxDQUFvQlAsT0FBcEIsQ0FBSCxHQUFrQyxJQUx6RDtBQU9Bb0QscUJBQVcsRUFQWCxFQVFBdnBDLEVBQUUsQ0FBQ3EvQixVQUFILEtBQXFCcUosT0FBckIsQ0FSQTtBQUFBO0FBU0EsS0F2QkYsRUF3QkVsNkIsRUF4QkYsQ0F3QkssV0F4QkwsRUF3QmtCLFVBQVNuZ0IsQ0FBVCxFQUFZO0FBQUEsVUFDdEI4M0MsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQ3dsQyxXQUFILENBQWVuM0MsQ0FBZixDQURZO0FBQUEsVUFFdEJxNkMsT0FBTyxHQUFHdkMsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQzBtQyxnQkFBSCxDQUFvQlAsT0FBcEIsQ0FBSCxHQUFrQyxJQUY3QjtBQUk1Qm5tQyxRQUFFLENBQUN1K0IsV0FBSCxDQUFlLENBQUNtSyxPQUFELENBQWYsRUFBMEIsSUFBMUIsQ0FKNEI7QUFLNUIsS0E3QkYsQ0FpQ0QsRUFBSW42QixPQUFPLElBQUl2TyxFQUFFLENBQUNnUyxVQUFILEVBQVgsSUFBOEIsQ0FBQ2hTLEVBQUUsQ0FBQzRXLE1BQXRDLEVBQThDO0FBQUEsVUFDdkMreUIsV0FBVyxHQUFHLFlBQU07QUFBQSxZQUNuQmx5QyxLQUFLLEdBQUd6Rix3RkFBTyxDQUFDdUcsY0FBUixDQUF1QixDQUF2QixDQURXO0FBQUEsWUFFbkJxeEMsUUFBUSxHQUFHcnRDLGlHQUFRLENBQUNoVixRQUFRLENBQUNxMUMsZ0JBQVQsQ0FBMEJubEMsS0FBSyxDQUFDVixPQUFoQyxFQUF5Q1UsS0FBSyxDQUFDVCxPQUEvQyxDQUFELENBRkE7QUFJekIsZUFBTzR5QyxRQUFQO0FBQ0EsT0FONEM7QUFBQSxVQVF2Q0MsT0FBTyxHQUFHLFlBQVc7QUFDMUIsYUFBSTdwQyxFQUFFLENBQUM0SixVQUFQLEVBQXFCO0FBQXJCO0FBQUEsZ0JBSU1nZ0MsUUFBUSxHQUFHRCxXQUFXLEVBSjVCO0FBQUEsZ0JBS01yTixLQUFLLEdBQUdzTixRQUFRLENBQUN0TixLQUFULEVBTGQ7QUFBQSxnQkFNTTZKLE9BQU8sR0FBSTdKLEtBQUssSUFBSUEsS0FBSyxDQUFDdm9DLElBQWYsSUFBdUJ1b0MsS0FBSyxDQUFDdm9DLElBQU4sQ0FBV3NNLEVBQW5DLEdBQXlDTCxFQUFFLENBQUN3bEMsV0FBSCxDQUFlbEosS0FBZixDQUF6QyxHQUFpRSxJQU5qRjtBQUFBLGdCQU9Nb00sT0FBTyxHQUFHdkMsT0FBTyxHQUFHbm1DLEVBQUUsQ0FBQzBtQyxnQkFBSCxDQUFvQlAsT0FBcEIsQ0FBSCxHQUFrQyxJQVB6RDtBQUFBLGdCQVFNOWxDLEVBQUUsR0FBSXFvQyxPQUFPLElBQUlBLE9BQU8sQ0FBQ3JvQyxFQUFwQixJQUEyQnBMLFNBUnRDO0FBVUErSyxjQUFFLENBQUNnOUIsbUJBQUgsQ0FBdUIwTCxPQUF2QixDQVZBLEVBWUE5NkMsV0FBVyxDQUFDeVMsRUFBRCxDQUFYLEdBQ0NrcEMsV0FBVyxFQURaLEdBQ2lCSixTQUFTLENBQUMsSUFBRCxFQUFPVCxPQUFQLEVBQWdCcm9DLEVBQWhCLENBYjFCO0FBQUE7QUFjQSxPQXZCNEM7O0FBeUI3Q0wsUUFBRSxDQUFDMEcsR0FBSCxDQUNFOEgsRUFERixDQUNLLFlBREwsRUFDbUJxN0IsT0FEbkIsRUFFRXI3QixFQUZGLENBRUssV0FGTCxFQUVrQnE3QixPQUZsQixDQXpCNkM7QUE0QjdDO0FBQ0QsR0E3a0I4QjtBQStrQi9CWCxlQS9rQitCLHlCQStrQmpCaGhDLFFBL2tCaUIsRUEra0JQO0FBQUEsUUFDakJsSSxFQUFFLEdBQUcsSUFEWTtBQUFBLFFBRWpCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSztBQUFBLFFBR2pCM0csSUFBSSxHQUFHK04sRUFBRSxDQUFDL04sSUFITztBQUFBLFFBSWpCKzFDLFFBQVEsR0FBR2hvQyxFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQUpNO0FBQUEsUUFNakJ6aEIsSUFBSSxHQUFHOEYsSUFBSSxDQUFDNEssU0FBTCxZQUFtQnhLLGNBQUssQ0FBQ3hKLFFBQXpCLEdBQ1h1SixNQURXLENBQ0osTUFESSxFQUVYK0QsS0FGVyxDQUVMLFNBRkssRUFFTSxHQUZOLEVBR1huRixJQUhXLENBR04sT0FITSxFQUdHLFVBQUEzQyxDQUFDO0FBQUEsYUFBSzJSLEVBQUUsQ0FBQzBsQyxXQUFILENBQWVyM0MsQ0FBQyxDQUFDMEYsSUFBakIsSUFBeUIxQixjQUFLLENBQUM1SCxVQUEvQixHQUE0QyxJQUFqRDtBQUFBLEtBSEosRUFJWHlGLElBSlcsQ0FJTjhQLEVBQUUsQ0FBQzJtQyxlQUFILENBQW1CbnJDLElBQW5CLENBQXdCd0UsRUFBeEIsQ0FKTSxFQUtYaFAsSUFMVyxDQUtOLFdBTE0sRUFLT2dQLEVBQUUsQ0FBQ3dtQyxvQkFBSCxDQUF3QmhyQyxJQUF4QixDQUE2QndFLEVBQTdCLENBTFAsRUFNWDdKLEtBTlcsQ0FNTCxXQU5LLEVBTVEsVUFBQTlILENBQUM7QUFBQSxhQUFLMlIsRUFBRSxDQUFDMGxDLFdBQUgsQ0FBZXIzQyxDQUFDLENBQUMwRixJQUFqQixLQUEwQixDQUFDaU0sRUFBRSxDQUFDMDBCLGVBQUgsRUFBM0IsYUFBcUQxbUMsSUFBSSxDQUFDMkwsS0FBTCxDQUFXcUcsRUFBRSxDQUFDK2tDLE1BQUgsR0FBWSxDQUF2QixDQUFyRCxVQUFxRixFQUExRjtBQUFBLEtBTlQsRUFPWDVxQyxVQVBXLEdBUVgrTixRQVJXLENBUUZBLFFBUkUsRUFTWC9SLEtBVFcsQ0FTTCxTQVRLLEVBU00sVUFBQTlILENBQUM7QUFBQSxhQUFLMlIsRUFBRSxDQUFDc1UsY0FBSCxDQUFrQmptQixDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUF6QixLQUFnQ0wsRUFBRSxDQUFDdW1DLFNBQUgsQ0FBYWw0QyxDQUFDLENBQUMwRixJQUFmLENBQWhDLEdBQXVELEdBQXZELEdBQTZELEdBQWxFO0FBQUEsS0FUUCxDQU5VOztBQW9CdkIsUUFIQTlCLElBQUksQ0FBQ0csTUFBTCxZQUFnQkMsY0FBSyxDQUFDbEosY0FBdEIsR0FDRWdOLEtBREYsQ0FDUSxTQURSLEVBQ21CNkosRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsS0FBdUJvNkIsUUFBdkIsR0FBa0MsR0FBbEMsR0FBd0MsR0FEM0QsQ0FHQSxFQUFJQSxRQUFKLEVBQWM7QUFBQSxVQUNQOEIsWUFBWSxHQUFHbHhDLE1BQU0sQ0FBQythLGdCQURmO0FBQUEsVUFFUGdrQixRQUFRLEdBQUcsQ0FBQ21TLFlBQVksR0FBRyxDQUFDLENBQUosR0FBUSxDQUFDLENBQXRCLElBQTJCbHhDLE1BQU0sQ0FBQzR2QixtQkFGdEM7QUFJYnNoQixrQkFBWSxJQUFJMzlDLElBQUksQ0FBQzZFLElBQUwsQ0FBVSxJQUFWLFlBQW1CaEQsSUFBSSxDQUFDMkwsS0FBTCxDQUFXcUcsRUFBRSxDQUFDK2tDLE1BQUgsR0FBWSxFQUF2QixDQUFuQixFQUpILEVBTWIva0MsRUFBRSxDQUFDblksSUFBSCxDQUFRdUssTUFBUixZQUFtQkMsY0FBSyxDQUFDdEosbUJBQXpCLEdBQ0VpSSxJQURGLENBQ08sR0FEUCxFQUNZLFlBQU07QUFDaEIsWUFBTTNDLENBQUMsR0FBRztBQUNUMEYsY0FBSSxFQUFFLENBQUM7QUFBQ3BFLGlCQUFLLEVBQUVpSixNQUFNLENBQUMydkI7QUFBZixXQUFELENBREc7QUFFVHFQLG9CQUFVLEVBQUVoL0IsTUFBTSxDQUFDNHZCLG1CQUZWO0FBR1RtUCxrQkFBUSxFQUFFQTtBQUhELFNBQVY7QUFNQSxlQUFPMzNCLEVBQUUsQ0FBQ3NtQyxNQUFILENBQVVqNEMsQ0FBVixTQUFQO0FBQ0EsT0FURixDQU5hLEVBaUJiMlIsRUFBRSxDQUFDblksSUFBSCxDQUFRdUssTUFBUixZQUFtQkMsY0FBSyxDQUFDbkosa0JBQXpCLEdBQ0U4SCxJQURGLENBQ08sSUFEUCxFQUNhLE9BRGIsRUFFRTdFLElBRkYsQ0FFT3lNLE1BQU0sQ0FBQ3d2QixnQkFBUCxHQUEwQnh2QixNQUFNLENBQUMrdkIsV0FBakMsR0FBK0MsRUFGdEQsQ0FqQmEsRUFxQlQvdkIsTUFBTSxDQUFDd3ZCLGdCQXJCRSxLQXNCWnBvQixFQUFFLENBQUNuWSxJQUFILENBQVF1SyxNQUFSLFlBQW1CQyxjQUFLLENBQUNwSixpQkFBekIsR0FDRStILElBREYsQ0FDTyxJQURQLFlBQ2dCLENBQUMsQ0FBRCxJQUFNZ1AsRUFBRSxDQUFDaWxDLFdBQUgsR0FBa0IsQ0FBQ2psQyxFQUFFLENBQUMra0MsTUFBSCxHQUFZL2tDLEVBQUUsQ0FBQ2lsQyxXQUFoQixLQUFnQ3JzQyxNQUFNLENBQUMrYSxnQkFBUCxHQUEwQixDQUExQixHQUE4QixDQUE5RCxDQUF4QixDQURoQixTQUVFM2lCLElBRkYsQ0FFTyxJQUZQLEVBRWEsT0FGYixFQUdFN0UsSUFIRixDQUdPNlQsRUFBRSxDQUFDaW5DLGtCQUFILENBQXNCcnVDLE1BQU0sQ0FBQzB2QixTQUE3QixLQUhQLENBdEJZLEVBNEJaLENBQUN3aEIsWUFBRCxJQUFpQjlwQyxFQUFFLENBQUNuWSxJQUFILENBQVF1SyxNQUFSLFlBQW1CQyxjQUFLLENBQUNySixpQkFBekIsR0FDZmdJLElBRGUsQ0FDVixJQURVLFlBQ0RnUCxFQUFFLENBQUNpbEMsV0FBSCxHQUFrQixDQUFDamxDLEVBQUUsQ0FBQytrQyxNQUFILEdBQVkva0MsRUFBRSxDQUFDaWxDLFdBQWhCLElBQStCLENBRGhELFNBRWZqMEMsSUFGZSxDQUVWLElBRlUsRUFFSixPQUZJLEVBR2Y3RSxJQUhlLENBR1Y2VCxFQUFFLENBQUNpbkMsa0JBQUgsQ0FBc0JydUMsTUFBTSxDQUFDMnZCLFNBQTdCLEtBSFUsQ0E1Qkw7QUFpQ2I7QUFDRCxHQXJvQjhCO0FBdW9CL0J3aEIsV0F2b0IrQix1QkF1b0JuQjtBQUFBLFFBQ0wvcEMsRUFBRSxHQUFHLElBREE7QUFBQSxRQUVMcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGUDtBQUFBLFFBR0wvUSxJQUFJLEdBQUdtWSxFQUFFLENBQUNuWSxJQUhMO0FBQUEsUUFJTG1pRCxVQUFVLEdBQUcsVUFBQTFuQyxTQUFTLEVBQUk7QUFDL0J6YSxVQUFJLENBQUNrSixNQUFMLENBQVksTUFBWixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnNSLFNBRGhCLEVBRUVuTSxLQUZGLENBRVEsYUFGUixFQUV1QixRQUZ2QixFQUdFQSxLQUhGLENBR1EsZ0JBSFIsRUFHMEIsTUFIMUIsQ0FEK0I7QUFLL0IsS0FUVTs7QUFXUDZKLE1BQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLENBWE8sS0FZVi9sQixJQUFJLENBQUNrSixNQUFMLENBQVksTUFBWixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnFCLGNBQUssQ0FBQ3RKLG1CQUR0QixDQVpVLEVBZVY2UCxNQUFNLENBQUMrdkIsV0FBUCxJQUFzQnFoQixVQUFVLENBQUMzM0MsY0FBSyxDQUFDbkosa0JBQVAsQ0FmdEIsRUFpQk4wUCxNQUFNLENBQUN3dkIsZ0JBakJELEtBa0JUNGhCLFVBQVUsQ0FBQzMzQyxjQUFLLENBQUNwSixpQkFBUCxDQWxCRCxFQW1CVCxDQUFDMlAsTUFBTSxDQUFDK2EsZ0JBQVIsSUFBNEJxMkIsVUFBVSxDQUFDMzNDLGNBQUssQ0FBQ3JKLGlCQUFQLENBbkI3QjtBQXNCWCxHQTdwQjhCO0FBK3BCL0I0cUIscUJBL3BCK0IsaUNBK3BCVDtBQUNyQixXQUFPLEtBQUtoYixNQUFMLENBQVl3dkIsZ0JBQVosR0FBK0IsRUFBL0IsR0FBb0MsQ0FBM0M7QUFDQTtBQWpxQjhCLENBQTFCLEM7Ozs7QUNqQk47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBejFCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9CZ3JCLFNBRCtCLHFCQUNyQjtBQUNULFFBQU1qcUMsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUN6SixLQUF6QixHQUFrQ21JLE1BQWxDLENBQXlDLEdBQXpDLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCcUIsY0FBSyxDQUFDL0ksU0FEdEIsQ0FIUztBQUtULEdBTjhCO0FBUS9CMHFCLHFCQVIrQiwrQkFRWGxRLE9BUlcsRUFRRjtBQUFBLFFBQ3RCOUQsRUFBRSxHQUFHLElBRGlCO0FBQUEsUUFFdEJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZVO0FBQUEsUUFHdEJzeEMsYUFBYSxHQUFHbHFDLEVBQUUsQ0FBQ2txQyxhQUFILENBQWlCMXVDLElBQWpCLENBQXNCd0UsRUFBdEIsQ0FITTtBQUFBLFFBSXRCbXFDLFNBQVMsR0FBR25xQyxFQUFFLENBQUNtcUMsU0FBSCxDQUFhM3VDLElBQWIsQ0FBa0J3RSxFQUFsQixDQUpVO0FBQUEsUUFLdEJtb0MsVUFBVSxHQUFHbm9DLEVBQUUsQ0FBQ21vQyxVQUFILENBQWMzc0MsSUFBZCxDQUFtQndFLEVBQW5CLENBTFM7QUFBQSxRQU10Qm9xQyxhQUFhLEdBQUdwcUMsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUMvSSxTQUF6QixHQUNwQnVULFNBRG9CLFlBQ054SyxjQUFLLENBQUNoSixRQURBLEdBRXBCMEssSUFGb0IsQ0FFZitQLE9BRmUsRUFHcEI5UyxJQUhvQixDQUdmLE9BSGUsRUFHTixVQUFBM0MsQ0FBQztBQUFBLGFBQUk2N0MsYUFBYSxDQUFDNzdDLENBQUQsQ0FBYixHQUFtQjg1QyxVQUFVLENBQUM5NUMsQ0FBRCxDQUFqQztBQUFBLEtBSEssQ0FOTTtBQUFBLFFBVXRCZzhDLFlBQVksR0FBR0QsYUFBYSxDQUFDdHRDLEtBQWQsR0FBc0IvTCxNQUF0QixDQUE2QixHQUE3QixFQUNuQkMsSUFEbUIsQ0FDZCxPQURjLEVBQ0xrNUMsYUFESyxFQUVuQi96QyxLQUZtQixDQUViLFNBRmEsRUFFRixHQUZFLEVBR25CQSxLQUhtQixDQUdiLGdCQUhhLEVBR0ssTUFITCxDQVZPO0FBZTVCO0FBQ0FrMEMsZ0JBQVksQ0FBQ3Q1QyxNQUFiLENBQW9CLEdBQXBCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCbTVDLFNBRGhCLEVBRUVoMEMsS0FGRixDQUVRLFFBRlIsRUFFa0IsVUFBQTlILENBQUM7QUFBQSxhQUFLdUssTUFBTSxDQUFDcW9CLDJCQUFQLENBQW1DNXlCLENBQW5DLElBQXdDLFNBQXhDLEdBQW9ELElBQXpEO0FBQUEsS0FGbkIsQ0FoQjRCO0FBbUI1QixHQTNCOEI7QUE2Qi9CK25CLFdBN0IrQixxQkE2QnJCWCxlQTdCcUIsRUE2Qko7QUFBQSxRQUNwQnpWLEVBQUUsR0FBRyxJQURlO0FBQUEsUUFFcEJzcUMsT0FBTyxHQUFHdHFDLEVBQUUsQ0FBQ3NxQyxPQUFILENBQVc5dUMsSUFBWCxDQUFnQndFLEVBQWhCLENBRlU7QUFBQSxRQUdwQnVxQyxRQUFRLEdBQUd2cUMsRUFBRSxDQUFDdXFDLFFBQUgsQ0FBWS91QyxJQUFaLENBQWlCd0UsRUFBakIsQ0FIUztBQUFBLFFBSXBCd3FDLGNBQWMsR0FBR3hxQyxFQUFFLENBQUN3cUMsY0FBSCxDQUFrQmh2QyxJQUFsQixDQUF1QndFLEVBQXZCLENBSkc7QUFNMUJBLE1BQUUsQ0FBQ3VSLE9BQUgsR0FBYXZSLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsWUFBc0J4SyxjQUFLLENBQUM3SixJQUE1QixHQUFvQ3FVLFNBQXBDLFlBQWtEeEssY0FBSyxDQUFDOUosR0FBeEQsR0FDWHdMLElBRFcsQ0FDTnUyQyxPQURNLENBTmEsRUFTMUJ0cUMsRUFBRSxDQUFDdVIsT0FBSCxDQUFXalUsSUFBWCxHQUFrQm5ELFVBQWxCLEdBQ0UrTixRQURGLENBQ1d1TixlQURYLEVBRUV0ZixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFb0gsTUFIRixFQVQwQixFQWMxQnlDLEVBQUUsQ0FBQ3VSLE9BQUgsR0FBYXZSLEVBQUUsQ0FBQ3VSLE9BQUgsQ0FBV3pVLEtBQVgsR0FBbUIvTCxNQUFuQixDQUEwQixNQUExQixFQUNYQyxJQURXLENBQ04sT0FETSxFQUNHdTVDLFFBREgsRUFFWHAwQyxLQUZXLENBRUwsTUFGSyxFQUVHNkosRUFBRSxDQUFDNkosS0FGTixFQUdYOU0sS0FIVyxDQUdMaUQsRUFBRSxDQUFDdVIsT0FIRSxFQUlYcGIsS0FKVyxDQUlMLFNBSkssRUFJTXEwQyxjQUpOLENBZGE7QUFtQjFCLEdBaEQ4QjtBQWtEL0Jud0IsV0FsRCtCLHFCQWtEckJvd0IsT0FsRHFCLEVBa0RacmpDLGNBbERZLEVBa0RJO0FBQ2xDLFdBQU8sQ0FDTixDQUFDQSxjQUFjLEdBQUcsS0FBS21LLE9BQUwsQ0FBYXBYLFVBQWIsQ0FBd0I1SCxTQUFTLEVBQWpDLENBQUgsR0FBMEMsS0FBS2dmLE9BQTlELEVBQ0V2Z0IsSUFERixDQUNPLEdBRFAsRUFDWXk1QyxPQURaLEVBRUV0MEMsS0FGRixDQUVRLE1BRlIsRUFFZ0IsS0FBSzBULEtBRnJCLEVBR0UxVCxLQUhGLENBR1EsU0FIUixFQUdtQixHQUhuQixDQURNLENBQVA7QUFNQSxHQXpEOEI7QUEyRC9CdTBDLFNBM0QrQixtQkEyRHZCMWlELElBM0R1QixFQTJEakIyaUQsYUEzRGlCLEVBMkRGO0FBQUEsUUFLeEJDLE1BTHdCO0FBQUEsUUFDdEI1cUMsRUFBRSxHQUFHLElBRGlCO0FBQUEsUUFFdEJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZVO0FBQUEsUUFHdEJtcEMsWUFBWSxHQUFHLzVDLElBQUksQ0FBQys1QyxZQUFMLENBQWtCL2hDLEVBQUUsQ0FBQ213QixlQUFILEVBQWxCLENBSE87QUFBQSxRQUl0QmdCLFNBQVMsR0FBR3Y0QixNQUFNLENBQUN5bkIsV0FBUCxDQUFtQjd4QixNQUpUO0FBQUEsUUFPdEJxOEMsUUFBUSxHQUFHLFVBQUF4cUMsRUFBRSxFQUFJO0FBQUEsVUFDaEIvTyxLQUFLLEdBQUcrTyxFQUFFLEdBQUd6SCxNQUFNLENBQUN1dUIsU0FBUCxDQUFpQjltQixFQUFqQixDQUFILEdBQTBCekgsTUFBTSxDQUFDdXVCLFNBRDNCO0FBQUEsVUFFaEJxSSxLQUFLLEdBQUdudkIsRUFBRSxHQUFHL08sS0FBSyxDQUFDaytCLEtBQVQsR0FBaUI1MkIsTUFBTSxDQUFDd3VCLGVBRmxCO0FBQUEsVUFHaEJsc0IsR0FBRyxHQUFHbUYsRUFBRSxHQUFHL08sS0FBSyxDQUFDNEosR0FBVCxHQUFldEMsTUFBTSxDQUFDeXVCLGFBSGQ7QUFBQSxVQUloQmh0QixDQUFDLEdBQUcxTSxRQUFRLENBQUMyRCxLQUFELENBQVIsR0FDVEEsS0FEUyxHQUNEcTVDLGFBQWEsR0FBSTVJLFlBQVksR0FBR3ZTLEtBQWhCLEdBQXlCbWIsYUFBNUIsR0FBNEMsQ0FMNUM7QUFPdEIsYUFBT3p2QyxHQUFHLElBQUliLENBQUMsR0FBR2EsR0FBWCxHQUFpQkEsR0FBakIsR0FBdUJiLENBQTlCO0FBQ0EsS0FmMkI7O0FBOEI1QixXQWJBdXdDLE1BQU0sR0FBR0MsUUFBUSxFQWFqQixFQVhJLENBQUMxWixTQUFELElBQWM3aUMsWUFBWSxDQUFDc0ssTUFBTSxDQUFDdXVCLFNBQVIsQ0FXOUIsS0FWQ3lqQixNQUFNLEdBQUc7QUFBQ3Q1QyxXQUFLLEVBQUVzNUMsTUFBUjtBQUFnQjlXLFdBQUssRUFBRTtBQUF2QixLQVVWLEVBUkM5ekIsRUFBRSxDQUFDNkcsbUJBQUgsQ0FBdUI3RyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUEvQixFQUF3Q2pVLE9BQXhDLENBQWdELFVBQUFyQyxDQUFDLEVBQUk7QUFDaERvTCxZQUFNLENBQUN1dUIsU0FBUCxDQUFpQjM1QixDQUFDLENBQUM2UyxFQUFuQixDQURnRCxLQUVuRHVxQyxNQUFNLENBQUNwOUMsQ0FBQyxDQUFDNlMsRUFBSCxDQUFOLEdBQWV3cUMsUUFBUSxDQUFDcjlDLENBQUMsQ0FBQzZTLEVBQUgsQ0FGNEIsRUFHbkR1cUMsTUFBTSxDQUFDOVcsS0FBUCxDQUFheitCLElBQWIsQ0FBa0J1MUMsTUFBTSxDQUFDcDlDLENBQUMsQ0FBQzZTLEVBQUgsQ0FBTixJQUFnQnVxQyxNQUFNLENBQUN0NUMsS0FBekMsQ0FIbUQ7QUFLcEQsS0FMRCxDQVFELEdBQU9zNUMsTUFBUDtBQUNBLEdBMUY4QjtBQTRGL0JFLFNBNUYrQixtQkE0RnZCaDZDLENBNUZ1QixFQTRGcEJ1UCxFQTVGb0IsRUE0RmhCO0FBQUEsUUFDUkwsRUFBRSxHQUFHLElBREc7QUFBQSxRQUVSK3FDLE1BQU0sR0FBSXg5QyxPQUFPLENBQUN1RCxDQUFELENBQVAsY0FBaUJBLENBQWpCLE1BRkY7QUFJZCxXQUFPLENBQUN1UCxFQUFFLEdBQUdMLEVBQUUsQ0FBQy9OLElBQUgsQ0FDWDRLLFNBRFcsWUFDR3hLLGNBQUssQ0FBQzdKLElBRFQsU0FDZ0J3WCxFQUFFLENBQUNzMkIsdUJBQUgsQ0FBMkJqMkIsRUFBM0IsQ0FEaEIsRUFBSCxHQUN1REwsRUFBRSxDQUFDL04sSUFEN0QsRUFFTDRLLFNBRkssWUFFU3hLLGNBQUssQ0FBQzlKLEdBRmYsU0FFcUJ3aUQsTUFGckIsRUFBUDtBQUdBLEdBbkc4QjtBQXFHL0IvTCxZQXJHK0Isc0JBcUdwQmx1QyxDQXJHb0IsRUFxR2pCdVAsRUFyR2lCLEVBcUdieStCLEtBckdhLEVBcUdOO0FBQ3hCLFFBQU05K0IsRUFBRSxHQUFHLElBQVg7QUFFQTgrQixTQUFLLElBQUk5K0IsRUFBRSxDQUFDby9CLFlBQUgsRUFIZSxFQUl4QnAvQixFQUFFLENBQUM4cUMsT0FBSCxDQUFXaDZDLENBQVgsRUFBY3VQLEVBQWQsRUFBa0I4TSxPQUFsQixDQUEwQjlhLGNBQUssQ0FBQ2pGLFFBQWhDLEtBSndCO0FBS3hCLEdBMUc4QjtBQTRHL0JneUMsY0E1RytCLHdCQTRHbEJ0dUMsQ0E1R2tCLEVBNEdmO0FBQ2YsU0FBS2c2QyxPQUFMLENBQWFoNkMsQ0FBYixFQUFnQnFjLE9BQWhCLENBQXdCOWEsY0FBSyxDQUFDakYsUUFBOUIsS0FEZTtBQUVmLEdBOUc4QjtBQWdIL0Jnc0IsaUJBaEgrQiwyQkFnSGY0eEIsVUFoSGUsRUFnSEgzSSxLQWhIRyxFQWdISTtBQUFBLFFBQzVCcmlDLEVBQUUsR0FBRyxJQUR1QjtBQUFBLFFBRTVCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGZ0I7QUFBQSxRQUc1QnF5QyxTQUFTLEdBQUdqckMsRUFBRSxDQUFDa3JDLG9CQUFILENBQXdCRixVQUF4QixFQUFvQzNJLEtBQXBDLENBSGdCO0FBQUEsUUFJNUJuaUMsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFKUztBQUFBLFFBSzVCZ3hCLFNBQVMsR0FBR3Y0QixNQUFNLENBQUN5bkIsV0FBUCxDQUFtQjd4QixNQUxIO0FBQUEsUUFNNUIyOEMsU0FBUyxHQUFHdnlDLE1BQU0sQ0FBQ291QixVQU5TO0FBQUEsUUFPNUJva0IsY0FBYyxHQUFHeHlDLE1BQU0sQ0FBQ3F1QixnQkFQSTtBQUFBLFFBVTVCb2tCLFNBQVMsR0FBRzE5QyxRQUFRLENBQUN3OUMsU0FBRCxDQUFSLElBQXVCQSxTQUFTLEdBQUcsQ0FBbkMsR0FDakI7QUFBQSxhQUFNQSxTQUFOO0FBQUEsS0FEaUIsR0FFaEJ4OUMsUUFBUSxDQUFDeTlDLGNBQUQsQ0FBUixHQUEyQixVQUFBL3dDLENBQUM7QUFBQSxhQUFJQSxDQUFDLEdBQUcrd0MsY0FBUjtBQUFBLEtBQTVCLEdBQXFELElBWnJCO0FBZWxDLFdBQU8sVUFBQy84QyxDQUFELEVBQUl5QyxDQUFKLEVBQVU7QUFDaEI7QUFEZ0IsVUFFVnc2QyxNQUFNLEdBQUdMLFNBQVMsQ0FBQzU4QyxDQUFELEVBQUl5QyxDQUFKLENBRlI7QUFBQSxVQUtWeTZDLE1BQU0sR0FBRyxDQUFDcnJDLFNBTEE7QUFBQSxVQU1Wc3JDLE1BQU0sR0FBRyxDQUFDLENBQUNELE1BTkQ7QUFBQSxVQVFWRSxVQUFVLEdBQUdwOUMsQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBUmI7QUFBQSxVQVNWKzdDLFVBQVUsR0FBRyxDQUFDLEVBQUQsRUFBSyxFQUFMLENBVEg7QUFBQSxVQVVaM0csTUFBTSxHQUFHLENBVkcsRUFJaEI7O0FBUUEsVUFBSXNHLFNBQVMsSUFBSSxDQUFDbGEsU0FBbEIsRUFBNkI7QUFBQSxZQUN0Qnh6QixLQUFLLEdBQUd1QyxTQUFTLEdBQUdzckMsTUFBSCxHQUFZRCxNQURQO0FBQUEsWUFFdEJJLElBQUksR0FBR0wsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVM3RDLEtBQVYsSUFBbUIydEMsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVM3RDLEtBQVYsQ0FGSjtBQUk1Qm9uQyxjQUFNLEdBQUdzRyxTQUFTLENBQUNNLElBQUQsQ0FKVTtBQU01QixZQUFNL2pELEdBQUcsY0FBT205QyxNQUFQLGNBQWlCQSxNQUFqQixjQUEyQjBHLFVBQVUsb0JBQXJDLE1BQVQ7QUFFQUMsa0JBQVUsQ0FBQyxDQUFDLENBQUN4ckMsU0FBSCxDQUFWLGFBQTZCdFksR0FBN0IsU0FBbUNtOUMsTUFBbkMsY0FBNkNBLE1BQTdDLENBUjRCLEVBUzVCMkcsVUFBVSxDQUFDLENBQUN4ckMsU0FBRixDQUFWLGFBQTRCdFksR0FBNUIsU0FBa0MsQ0FBQyxDQUFDbTlDLE1BQUYsRUFBVUEsTUFBVixFQUFrQjdrQyxTQUFTLEdBQUcsTUFBSCxHQUFZLFNBQXZDLEdBQWxDLENBVDRCLEVBVzVCdXJDLFVBQVUsSUFBSUMsVUFBVSxDQUFDOWIsT0FBWCxFQVhjO0FBWTVCLE9BeEJlLENBMEJoQjtBQUNBOzs7QUFDQSxVQUFNMStCLElBQUksR0FBR2dQLFNBQVMsY0FDakJvckMsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVQyxNQUFWLElBQW9CeEcsTUFESCxjQUNhMkcsVUFBVSxDQUFDLENBQUQsQ0FEdkIsY0FDOEJKLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVUUsTUFBVixJQUFvQnpHLE1BRGxELGNBQzREMkcsVUFBVSxDQUFDLENBQUQsQ0FEdEUsY0FDNkVKLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVUMsTUFBVixDQUQ3RSxlQUVqQkQsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVRSxNQUFWLEtBQXFCQyxVQUFVLEdBQUcsQ0FBQzFHLE1BQUosR0FBYUEsTUFBNUMsQ0FGaUIsY0FFc0MyRyxVQUFVLENBQUMsQ0FBRCxDQUZoRCxjQUV1REosTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVQyxNQUFWLElBQW9CeEcsTUFGM0UsY0FFcUYyRyxVQUFVLENBQUMsQ0FBRCxDQUYvRixjQUVzR0osTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVRSxNQUFWLENBRnRHLENBQXRCO0FBSUEsd0JBQVdGLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVUMsTUFBVixDQUFYLGNBQWdDRCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVVFLE1BQVYsQ0FBaEMsU0FBb0R0NkMsSUFBcEQ7QUFDQSxLQWpDRDtBQWtDQSxHQWpLOEI7QUFtSy9CZzZDLHNCQW5LK0IsZ0NBbUtWRixVQW5LVSxFQW1LRTNJLEtBbktGLEVBbUtTO0FBQUEsUUFDakNyaUMsRUFBRSxHQUFHLElBRDRCO0FBQUEsUUFFakNoWSxJQUFJLEdBQUdxNkMsS0FBSyxHQUFHcmlDLEVBQUUsQ0FBQ21FLFFBQU4sR0FBaUJuRSxFQUFFLENBQUN1QyxLQUZDO0FBQUEsUUFHakNvb0MsYUFBYSxHQUFHSyxVQUFVLENBQUM5SSxPQUFYLEdBQXFCLENBSEo7QUFBQSxRQUlqQ3lKLElBQUksR0FBRzNyQyxFQUFFLENBQUMwcUMsT0FBSCxDQUFXMWlELElBQVgsRUFBaUIyaUQsYUFBakIsQ0FKMEI7QUFBQSxRQUtqQ2lCLElBQUksR0FBRzVyQyxFQUFFLENBQUNtaUMsU0FBSCxDQUFhd0osSUFBYixFQUFtQmhCLGFBQW5CLEVBQWtDSyxVQUFsQyxFQUE4QyxDQUFDLENBQUMzSSxLQUFoRCxDQUwwQjtBQUFBLFFBTWpDd0osSUFBSSxHQUFHN3JDLEVBQUUsQ0FBQ3lpQyxTQUFILENBQWEsQ0FBQyxDQUFDSixLQUFmLENBTjBCO0FBQUEsUUFPakN5SixTQUFTLEdBQUc5ckMsRUFBRSxDQUFDMGlDLGNBQUgsQ0FBa0IxaUMsRUFBRSxDQUFDOFcsU0FBckIsRUFBZ0NrMEIsVUFBaEMsRUFBNEMsQ0FBQyxDQUFDM0ksS0FBOUMsQ0FQcUI7QUFBQSxRQVFqQzNtQixNQUFNLEdBQUcybUIsS0FBSyxHQUFHcmlDLEVBQUUsQ0FBQ3VzQixZQUFOLEdBQXFCdnNCLEVBQUUsQ0FBQ3FzQixTQVJMO0FBVXZDLFdBQU8sVUFBQ2grQixDQUFELEVBQUl5QyxDQUFKLEVBQVU7QUFBQSxVQUNWOHhDLEVBQUUsR0FBR2xuQixNQUFNLENBQUN4ckIsSUFBUCxDQUFZOFAsRUFBWixFQUFnQjNSLENBQUMsQ0FBQ2dTLEVBQWxCLEVBQXNCLENBQXRCLENBREs7QUFBQSxVQUVWd3JCLE1BQU0sR0FBR2lnQixTQUFTLENBQUN6OUMsQ0FBRCxFQUFJeUMsQ0FBSixDQUFULElBQW1COHhDLEVBRmxCO0FBQUEsVUFHVnR4QyxLQUFLLEdBQUczRCxRQUFRLENBQUNnK0MsSUFBRCxDQUFSLEdBQWlCQSxJQUFqQixHQUF3QkEsSUFBSSxDQUFDdDlDLENBQUMsQ0FBQ2dTLEVBQUgsQ0FBSixJQUFjc3JDLElBQUksQ0FBQ3I2QyxLQUh6QztBQUFBLFVBSVZ5NkMsSUFBSSxHQUFHSCxJQUFJLENBQUN2OUMsQ0FBRCxDQUpEO0FBQUEsVUFLWjI5QyxJQUFJLEdBQUdILElBQUksQ0FBQ3g5QyxDQUFELENBTEM7QUFnQmhCO0FBQ0EsYUFUSTJSLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBQVYsS0FDRjlSLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVSxDQUFWLElBQWVxOEMsSUFBSSxHQUFHcEosRUFBdkIsSUFBK0J2MEMsQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBQVYsSUFBZWl6QyxFQUFFLEdBQUdvSixJQURoRCxDQVNKLEtBTkNBLElBQUksR0FBR3BKLEVBTVIsR0FIQW9KLElBQUksSUFBS3BKLEVBQUUsR0FBRy9XLE1BR2QsRUFBTyxDQUNOLENBQUNrZ0IsSUFBRCxFQUFPbGdCLE1BQVAsQ0FETSxFQUVOLENBQUNrZ0IsSUFBRCxFQUFPQyxJQUFQLENBRk0sRUFHTixDQUFDRCxJQUFJLEdBQUd6NkMsS0FBUixFQUFlMDZDLElBQWYsQ0FITSxFQUlOLENBQUNELElBQUksR0FBR3o2QyxLQUFSLEVBQWV1NkIsTUFBZixDQUpNLENBQVA7QUFNQSxLQXZCRDtBQXdCQSxHQXJNOEI7QUF1TS9CMEssYUF2TStCLHVCQXVNbkJ1TSxJQXZNbUIsRUF1TWI7QUFDWCxRQUFBcnNDLEtBQUssR0FBR3dvQyxnR0FBTyxDQUFDNkQsSUFBRCxDQUFmO0FBQUEsUUFDQWhwQixJQURBLEdBQ083b0IsY0FBYyxDQUFDNnhDLElBQUQsQ0FEckI7QUFBQSx5Q0FFZWhwQixJQUZmO0FBQUEsUUFFQ215QixJQUZEO0FBQUEsUUFFT0MsSUFGUDtBQUFBLFFBR0E5NkMsQ0FIQSxHQUdJcEQsSUFBSSxDQUFDMkQsR0FBTCxDQUFTczZDLElBQUksQ0FBQzc2QyxDQUFkLEVBQWlCODZDLElBQUksQ0FBQzk2QyxDQUF0QixDQUhKO0FBQUEsUUFJQUMsQ0FKQSxHQUlJckQsSUFBSSxDQUFDMkQsR0FBTCxDQUFTczZDLElBQUksQ0FBQzU2QyxDQUFkLEVBQWlCNjZDLElBQUksQ0FBQzc2QyxDQUF0QixDQUpKO0FBQUEsUUFLQXc2QixNQUxBLEdBS1MsS0FBS2p6QixNQUFMLENBQVlzdUIsZUFMckI7QUFBQSx3QkFNa0I0YixJQUFJLENBQUMzeEMsT0FBTCxFQU5sQjtBQUFBLFFBTUNHLEtBTkQsaUJBTUNBLEtBTkQ7QUFBQSxRQU1RQyxNQU5SLGlCQU1RQSxNQU5SOztBQVlOLFdBTFdILENBQUMsR0FBR3k2QixNQUtSLEdBQUtwMUIsS0FBSyxDQUFDLENBQUQsQ0FBVixJQUNOQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBTFVyRixDQUFDLEdBQUdFLEtBQUosR0FBWXU2QixNQUloQixJQUZJeDZCLENBQUMsR0FBR3c2QixNQUlkLEdBQUtwMUIsS0FBSyxDQUFDLENBQUQsQ0FGSixJQUdOQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBTlVwRixDQUFDLEdBQUdFLE1BQUosR0FBYXM2QixNQUd4QjtBQUlBO0FBeE44QixDQUExQixDOztBQ1ROOzs7O0FBSUE7QUFDQTtBQUVBbDVCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7O0FBSUFrdEIsWUFMK0Isd0JBS2xCO0FBQUEsUUFDTm5zQyxFQUFFLEdBQUcsSUFEQztBQUFBLFFBRU5wSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZOO0FBSVJvSCxNQUFFLENBQUM0TixPQUFILENBQVcsUUFBWCxDQUpRLEtBS1hoVixNQUFNLENBQUMwaUIsVUFBUCxLQUxXLEVBTVgxaUIsTUFBTSxDQUFDOHRCLFVBQVAsR0FBb0IsUUFOVCxFQU9YOXRCLE1BQU0sQ0FBQ3l0QixpQkFBUCxHQUEyQixFQVBoQjtBQVNaLEdBZDhCOztBQWdCL0I7Ozs7OztBQU1BK2xCLGVBdEIrQiwyQkFzQmY7QUFBQSxRQUNUcHNDLEVBQUUsR0FBRyxJQURJO0FBQUEsUUFFVGt6QixRQUFRLEdBQUcsYUFGRjtBQUFBLFFBR1htWixVQUFVLEdBQUdyc0MsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsUUFBWixDQUhGO0FBY2YsV0FUS21aLFVBU0wsSUFSQ3JzQyxFQUFFLENBQUN3ekIsUUFBSCxDQUFZTixRQUFaLEVBQXNCbVosVUFBVSxHQUFHdjNDLFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FDbkRrTCxFQUFFLENBQUNhLElBQUgsQ0FBUXpQLENBQVIsQ0FBVWdCLE1BQVYsQ0FBaUIsTUFBakIsRUFBeUI3QixJQUF6QixHQUNFcVAsY0FERixFQURtRCxFQUduREksRUFBRSxDQUFDYSxJQUFILENBQVF4UCxDQUFSLENBQVVlLE1BQVYsQ0FBaUIsTUFBakIsRUFBeUI3QixJQUF6QixHQUNFcVAsY0FERixFQUhtRCxDQUFSLENBQTVDLENBUUQsRUFBT3lzQyxVQUFQO0FBQ0EsR0FyQzhCOztBQXVDL0I7Ozs7OztBQU1BQyxZQTdDK0Isc0JBNkNwQmorQyxDQTdDb0IsRUE2Q2pCO0FBQUEsUUFDUDJSLEVBQUUsR0FBRyxJQURFO0FBQUEsUUFFVHVzQyxJQUFJLEdBQUd2c0MsRUFBRSxDQUFDcEgsTUFBSCxDQUFVMnVCLFdBRlI7QUFJVDk1QixjQUFVLENBQUM4K0MsSUFBRCxDQUpELEdBS1pBLElBQUksR0FBR0EsSUFBSSxDQUFDbCtDLENBQUQsQ0FMQyxHQU1GLENBQUNWLFFBQVEsQ0FBQzQrQyxJQUFELENBTlAsS0FPWkEsSUFBSSxHQUFJdnNDLEVBQUUsQ0FBQ29zQyxhQUFILE1BQXNCcHNDLEVBQUUsQ0FBQ213QixlQUFILEtBQXVCLENBQTdDLENBQUQsR0FBb0QsRUFQL0M7QUFBQSxRQVVQajFCLEdBQUcsR0FBR3BHLFNBQVMsQ0FBQyxLQUFELEVBQVFrTCxFQUFFLENBQUNrUixhQUFILEdBQW1CaFcsR0FBbkIsQ0FBdUJ4SyxHQUF2QixDQUEyQixVQUFBckMsQ0FBQztBQUFBLGFBQUthLFFBQVEsQ0FBQ2IsQ0FBQyxDQUFDc0IsS0FBSCxDQUFSLEdBQW9CdEIsQ0FBQyxDQUFDc0IsS0FBRixDQUFRNjhDLEdBQTVCLEdBQWtDbitDLENBQUMsQ0FBQ3NCLEtBQXpDO0FBQUEsS0FBNUIsQ0FBUixDQVZSO0FBQUEsUUFXUDg4QyxPQUFPLEdBQUdGLElBQUksR0FBR0EsSUFBUCxHQUFjditDLElBQUksQ0FBQ2lRLEVBWHRCO0FBQUEsUUFZUG5XLElBQUksR0FBR3VHLENBQUMsQ0FBQ3NCLEtBQUYsSUFBVzg4QyxPQUFPLEdBQUd2eEMsR0FBckIsQ0FaQTtBQWNiLFdBQU9sTixJQUFJLENBQUMyb0MsSUFBTCxDQUFVN3VDLElBQUksR0FBR2tHLElBQUksQ0FBQ2lRLEVBQXRCLENBQVA7QUFDQTtBQTVEOEIsQ0FBMUIsQzs7QUNQTjs7OztBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFFQXRMLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9CeXRCLFVBRCtCLHNCQUNwQjtBQUNWLFFBQU0xc0MsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUN6SixLQUF6QixHQUFrQ21JLE1BQWxDLENBQXlDLEdBQXpDLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCcUIsY0FBSyxDQUFDN0ksVUFEdEIsQ0FIVTtBQUtWLEdBTjhCO0FBUS9CeXFCLHNCQVIrQixnQ0FRVm5RLE9BUlUsRUFRRDtBQUFBLFFBQ3ZCOUQsRUFBRSxHQUFHLElBRGtCO0FBQUEsUUFFdkJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZXO0FBQUEsUUFHdkIrekMsY0FBYyxHQUFHM3NDLEVBQUUsQ0FBQzJzQyxjQUFILENBQWtCbnhDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FITTtBQUFBLFFBSXZCNHNDLFVBQVUsR0FBRzVzQyxFQUFFLENBQUM0c0MsVUFBSCxDQUFjcHhDLElBQWQsQ0FBbUJ3RSxFQUFuQixDQUpVO0FBQUEsUUFLdkI2c0MsVUFBVSxHQUFHN3NDLEVBQUUsQ0FBQzZzQyxVQUFILENBQWNyeEMsSUFBZCxDQUFtQndFLEVBQW5CLENBTFU7QUFBQSxRQU12QjhzQyxZQUFZLEdBQUc5c0MsRUFBRSxDQUFDOHNDLFlBQUgsQ0FBZ0J0eEMsSUFBaEIsQ0FBcUJ3RSxFQUFyQixDQU5RO0FBQUEsUUFPdkJtb0MsVUFBVSxHQUFHbm9DLEVBQUUsQ0FBQ21vQyxVQUFILENBQWMzc0MsSUFBZCxDQUFtQndFLEVBQW5CLENBUFU7QUFBQSxRQVN2QitzQyxjQUFjLEdBQUcvc0MsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUM3SSxVQUF6QixHQUNyQnFULFNBRHFCLFlBQ1B4SyxjQUFLLENBQUM5SSxTQURDLEdBRXJCd0ssSUFGcUIsQ0FFaEIrUCxPQUZnQixFQUdyQjlTLElBSHFCLENBR2hCLE9BSGdCLEVBR1AsVUFBQTNDLENBQUM7QUFBQSxhQUFJcytDLGNBQWMsQ0FBQ3QrQyxDQUFELENBQWQsR0FBb0I4NUMsVUFBVSxDQUFDOTVDLENBQUQsQ0FBbEM7QUFBQSxLQUhNLENBVE07QUFBQSxRQWN2QjIrQyxhQUFhLEdBQUdELGNBQWMsQ0FBQ2p3QyxLQUFmLEdBQXVCL0wsTUFBdkIsQ0FBOEIsR0FBOUIsRUFDcEJDLElBRG9CLENBQ2YsT0FEZSxFQUNOMjdDLGNBRE0sRUFFcEJ4MkMsS0FGb0IsQ0FFZCxTQUZjLEVBRUgsR0FGRyxFQUdwQkEsS0FIb0IsQ0FHZCxnQkFIYyxFQUdJLE1BSEosQ0FkTztBQW1CN0I7QUFJQTtBQWNBO0FBakJBNjJDLGlCQUFhLENBQUNqOEMsTUFBZCxDQUFxQixHQUFyQixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQjQ3QyxVQURoQixDQXBCNkIsRUF3QjdCSSxhQUFhLENBQUNqOEMsTUFBZCxDQUFxQixHQUFyQixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQjY3QyxVQURoQixDQXhCNkIsRUEyQnpCajBDLE1BQU0sQ0FBQzBpQixVQTNCa0IsS0E2QjVCMWlCLE1BQU0sQ0FBQ21vQixzQkFBUCxJQUFpQ2lzQixhQUFhLENBQUNqOEMsTUFBZCxDQUFxQixHQUFyQixFQUMvQkMsSUFEK0IsQ0FDMUIsT0FEMEIsRUFDakIsVUFBQTNDLENBQUM7QUFBQSxhQUFJMlIsRUFBRSxDQUFDaXRDLGFBQUgsQ0FBaUI1NkMsY0FBSyxDQUFDM0csZUFBdkIsRUFBd0MyQyxDQUFDLENBQUNnUyxFQUExQyxDQUFKO0FBQUEsS0FEZ0IsQ0E3QkwsRUFnQzVCMnNDLGFBQWEsQ0FBQ2o4QyxNQUFkLENBQXFCLEdBQXJCLEVBQ0VDLElBREYsQ0FDTyxPQURQLEVBQ2dCODdDLFlBRGhCLEVBRUUzMkMsS0FGRixDQUVRLFFBRlIsRUFFa0IsVUFBQTlILENBQUM7QUFBQSxhQUFLdUssTUFBTSxDQUFDcW9CLDJCQUFQLENBQW1DNXlCLENBQW5DLElBQXdDLFNBQXhDLEdBQW9ELElBQXpEO0FBQUEsS0FGbkIsQ0FoQzRCLEdBc0M3QnlWLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQThGLENBQUMsRUFBSTtBQUNwQnFLLFFBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsWUFBc0J4SyxjQUFLLENBQUMzRyxlQUE1QixTQUE4Q3NVLEVBQUUsQ0FBQ3MyQix1QkFBSCxDQUEyQjNnQyxDQUFDLENBQUMwSyxFQUE3QixDQUE5QyxHQUNFeEQsU0FERixXQUNleEssY0FBSyxDQUFDNUcsY0FEckIsR0FFRTZRLElBRkYsQ0FFTyxVQUFBak8sQ0FBQyxFQUFJO0FBQ1ZBLFNBQUMsQ0FBQ3NCLEtBQUYsR0FBVWdHLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBUzdULENBQUMsQ0FBQ3NQLEtBQVgsRUFBa0JoTyxLQURsQjtBQUVWLE9BSkYsQ0FEb0I7QUFNcEIsS0FORCxDQXRDNkI7QUFnRDdCLEdBeEQ4QjtBQTBEL0IwbUIsWUExRCtCLHNCQTBEcEJaLGVBMURvQixFQTBESDtBQUMzQixRQUFNelYsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDd1IsUUFBSCxHQUFjeFIsRUFBRSxDQUFDL04sSUFBSCxDQUNaNEssU0FEWSxZQUNFeEssY0FBSyxDQUFDL0csS0FEUixHQUVadVIsU0FGWSxZQUVFeEssY0FBSyxDQUFDaEgsSUFGUixHQUdaMEksSUFIWSxDQUdQaU0sRUFBRSxDQUFDa3RDLFFBQUgsQ0FBWTF4QyxJQUFaLENBQWlCd0UsRUFBakIsQ0FITyxDQUhhLEVBUTNCQSxFQUFFLENBQUN3UixRQUFILENBQVlsVSxJQUFaLEdBQW1CbkQsVUFBbkIsR0FDRStOLFFBREYsQ0FDV3VOLGVBRFgsRUFFRXRmLEtBRkYsQ0FFUSxTQUZSLEVBRW1CLEdBRm5CLEVBR0VvSCxNQUhGLEVBUjJCLEVBYTNCeUMsRUFBRSxDQUFDd1IsUUFBSCxHQUFjeFIsRUFBRSxDQUFDd1IsUUFBSCxDQUFZMVUsS0FBWixHQUNaL0wsTUFEWSxDQUNMLE1BREssRUFFWkMsSUFGWSxDQUVQLE9BRk8sRUFFRSxVQUFBM0MsQ0FBQztBQUFBLHVCQUFPMlIsRUFBRSxDQUFDbXRDLFNBQUgsQ0FBYTN4QyxJQUFiLENBQWtCd0UsRUFBbEIsRUFBc0IzUixDQUF0QixDQUFQLGNBQW1DMlIsRUFBRSxDQUFDbUssZ0JBQUgsQ0FBb0I5YixDQUFwQixLQUEwQixFQUE3RDtBQUFBLEtBRkgsRUFHWjhILEtBSFksQ0FHTixRQUhNLEVBR0k2SixFQUFFLENBQUM2SixLQUhQLEVBSVo5TSxLQUpZLENBSU5pRCxFQUFFLENBQUN3UixRQUpHLEVBS1pyYixLQUxZLENBS04sU0FMTSxFQUtLNkosRUFBRSxDQUFDd3FDLGNBQUgsQ0FBa0JodkMsSUFBbEIsQ0FBdUJ3RSxFQUF2QixDQUxMLEVBTVo3SixLQU5ZLENBTU4saUJBTk0sRUFNYSxVQUFBOUgsQ0FBQztBQUFBLGFBQUsyUixFQUFFLENBQUNpZ0MsVUFBSCxDQUFjNXhDLENBQWQsSUFBbUIsWUFBbkIsR0FBa0MsRUFBdkM7QUFBQSxLQU5kLEVBT1oyQyxJQVBZLENBT1AsV0FQTyxFQU9NLElBUE4sQ0FiYTtBQXFCM0IsR0EvRThCO0FBaUYvQm1wQixZQWpGK0Isc0JBaUZwQml6QixRQWpGb0IsRUFpRlZobUMsY0FqRlUsRUFpRk07QUFDcEMsV0FBTyxDQUNOLENBQUNBLGNBQWMsR0FBRyxLQUFLb0ssUUFBTCxDQUFjclgsVUFBZCxDQUF5QjVILFNBQVMsRUFBbEMsQ0FBSCxHQUEyQyxLQUFLaWYsUUFBL0QsRUFDRXhnQixJQURGLENBQ08sR0FEUCxFQUNZbzhDLFFBRFosRUFFRWozQyxLQUZGLENBRVEsUUFGUixFQUVrQixLQUFLMFQsS0FGdkIsRUFHRTFULEtBSEYsQ0FHUSxTQUhSLEVBR21CLEdBSG5CLENBRE0sQ0FBUDtBQU1BLEdBeEY4Qjs7QUEwRi9COzs7Ozs7QUFNQWszQyxVQWhHK0Isb0JBZ0d0QmgvQyxDQWhHc0IsRUFnR25CO0FBQUEsUUFDTDJSLEVBQUUsR0FBRyxJQURBO0FBQUEsUUFFTHN0QyxpQkFBaUIsR0FBR3R0QyxFQUFFLENBQUNwSCxNQUFILENBQVV1SCxZQUFWLElBQTBCSCxFQUFFLENBQUNpZ0MsVUFBSCxDQUFjNXhDLENBQWQsQ0FGekM7QUFJWDtBQUNBO0FBQ0EsV0FBT2kvQyxpQkFBaUIsR0FBRyxVQUFBcDdDLE9BQU8sRUFBSTtBQUNyQyxVQUFNcTdDLElBQUksR0FBR3Z0QyxFQUFFLENBQUNxakMsY0FBSCxDQUFrQmgxQyxDQUFsQixFQUFxQjZELE9BQXJCLENBQWIsQ0FEcUMsQ0FHckM7O0FBb0JBLGFBbkJBcTdDLElBQUksQ0FBQ0MsUUFBTCxHQUFnQkQsSUFBSSxDQUFDdGpDLEtBbUJyQixFQWhCQXNqQyxJQUFJLENBQUNFLFlBQUwsR0FBb0IsVUFBU3I4QyxDQUFULEVBQVlDLENBQVosRUFBZTtBQUNsQyxhQUFLcThDLE1BQUwsS0FBZ0IsQ0FBaEIsS0FBc0IsS0FBS0EsTUFBTCxHQUFjLENBQXBDLENBRGtDO0FBR2xDLFlBQU01N0IsRUFBRSxHQUFHLEtBQUs2N0IsRUFBTCxJQUFXLElBQUksS0FBS0MsRUFBcEIsSUFBMEJ2OEMsQ0FBQyxHQUFHLEtBQUt1OEMsRUFBOUM7QUFFQSxhQUFLQyxRQUFMLENBQWNDLE1BQWQsQ0FBcUIsS0FBS0MsRUFBMUIsRUFBOEJqOEIsRUFBOUIsQ0FMa0MsRUFNbEMsS0FBSys3QixRQUFMLENBQWNDLE1BQWQsQ0FBcUIxOEMsQ0FBckIsRUFBd0IwZ0IsRUFBeEIsQ0FOa0MsRUFRbEMsS0FBS2k4QixFQUFMLEdBQVUzOEMsQ0FSd0IsRUFTbEMsS0FBS3U4QyxFQUFMLEdBQVV0OEMsQ0FUd0I7QUFVbEMsT0FNRCxFQUpBazhDLElBQUksQ0FBQ3RqQyxLQUFMLEdBQWEsVUFBUzdZLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQzNCLGFBQUtxOEMsTUFBTCxLQUFnQixDQUFoQixHQUFvQixLQUFLRixRQUFMLENBQWNwOEMsQ0FBZCxFQUFpQkMsQ0FBakIsQ0FBcEIsR0FBMEMsS0FBS284QyxZQUFMLENBQWtCcjhDLENBQWxCLEVBQXFCQyxDQUFyQixDQURmO0FBRTNCLE9BRUQsRUFBT2s4QyxJQUFQO0FBQ0EsS0F4QnVCLEdBd0JwQnZ0QyxFQUFFLENBQUNxakMsY0FBSCxDQUFrQmgxQyxDQUFsQixDQXhCSjtBQXlCQSxHQS9IOEI7QUFpSS9CNHFCLGtCQWpJK0IsNEJBaUlkKzBCLFdBakljLEVBaUlEM0wsS0FqSUMsRUFpSU07QUFBQSxRQUM5QnJpQyxFQUFFLEdBQUcsSUFEeUI7QUFBQSxRQUU5QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmtCO0FBQUEsUUFHOUJxMUMsZUFBZSxHQUFHcjFDLE1BQU0sQ0FBQyt0QixnQkFISztBQUFBLFFBSTlCem1CLFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSlc7QUFBQSxRQU05QjhxQyxTQUFTLEdBQUdqckMsRUFBRSxDQUFDa3VDLHFCQUFILENBQXlCRixXQUF6QixFQUFzQzNMLEtBQXRDLENBTmtCO0FBQUEsUUFPOUI4TCxZQUFZLEdBQUc5TCxLQUFLLEdBQUdyaUMsRUFBRSxDQUFDdXNCLFlBQU4sR0FBcUJ2c0IsRUFBRSxDQUFDcXNCLFNBUGQ7QUFBQSxRQVM5QitoQixNQUFNLEdBQUcsVUFBQS8vQyxDQUFDO0FBQUEsYUFBSSxDQUFDZzBDLEtBQUssR0FBR3JpQyxFQUFFLENBQUNxdUMsS0FBTixHQUFjcnVDLEVBQUUsQ0FBQ3N1QyxFQUF2QixFQUEyQnArQyxJQUEzQixDQUFnQzhQLEVBQWhDLEVBQW9DM1IsQ0FBcEMsQ0FBSjtBQUFBLEtBVG9CO0FBQUEsUUFVOUJrZ0QsTUFBTSxHQUFHLFVBQUNsZ0QsQ0FBRCxFQUFJeUMsQ0FBSjtBQUFBLGFBQVdrUCxFQUFFLENBQUNteEIsU0FBSCxDQUFhOWlDLENBQUMsQ0FBQ2dTLEVBQWYsSUFDekI0cUMsU0FBUyxDQUFDNThDLENBQUQsRUFBSXlDLENBQUosQ0FBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUR5QixHQUV6QnE5QyxZQUFZLENBQUNqK0MsSUFBYixDQUFrQjhQLEVBQWxCLEVBQXNCM1IsQ0FBQyxDQUFDZ1MsRUFBeEIsRUFBNEJMLEVBQUUsQ0FBQ29iLFlBQUgsQ0FBZ0Ivc0IsQ0FBaEIsQ0FBNUIsQ0FGYztBQUFBLEtBVnFCO0FBQUEsUUFlaENoRCxJQUFJLEdBQUdtakQsbUZBQU0sRUFmbUI7O0FBaUJwQ25qRCxRQUFJLEdBQUc2VSxTQUFTLEdBQ2Y3VSxJQUFJLENBQUMrRixDQUFMLENBQU9tOUMsTUFBUCxFQUFlbDlDLENBQWYsQ0FBaUIrOEMsTUFBakIsQ0FEZSxHQUNZL2lELElBQUksQ0FBQytGLENBQUwsQ0FBT2c5QyxNQUFQLEVBQWUvOEMsQ0FBZixDQUFpQms5QyxNQUFqQixDQWxCUSxFQW9CL0JOLGVBcEIrQixLQXFCbkM1aUQsSUFBSSxHQUFHQSxJQUFJLENBQUNvakQsT0FBTCxDQUFhLFVBQUFwZ0QsQ0FBQztBQUFBLGFBQUkyUixFQUFFLENBQUNvYixZQUFILENBQWdCL3NCLENBQWhCLE1BQXVCLElBQTNCO0FBQUEsS0FBZCxDQXJCNEI7QUF3QnBDLFFBQU0rQyxDQUFDLEdBQUdpeEMsS0FBSyxHQUFHcmlDLEVBQUUsQ0FBQ2lPLElBQU4sR0FBYWpPLEVBQUUsQ0FBQzVPLENBQS9CO0FBRUEsV0FBTyxVQUFBL0MsQ0FBQyxFQUFJO0FBQUEsVUFLUDZDLElBTE87QUFBQSxVQUNMRyxDQUFDLEdBQUc4OEMsWUFBWSxDQUFDaitDLElBQWIsQ0FBa0I4UCxFQUFsQixFQUFzQjNSLENBQUMsQ0FBQ2dTLEVBQXhCLENBREM7QUFBQSxVQUVQNkIsTUFBTSxHQUFHK3JDLGVBQWUsR0FBR2p1QyxFQUFFLENBQUN5MUIsZ0JBQUgsQ0FBb0JwbkMsQ0FBQyxDQUFDNlQsTUFBdEIsQ0FBSCxHQUFtQzdULENBQUMsQ0FBQzZULE1BRnREO0FBQUEsVUFHUHdzQyxFQUFFLEdBQUcsQ0FIRTtBQUFBLFVBSVA5TCxFQUFFLEdBQUcsQ0FKRTs7QUFPWCxVQUFJNWlDLEVBQUUsQ0FBQ2daLFVBQUgsQ0FBYzNxQixDQUFkLENBQUosRUFBc0I7QUFDckIsWUFBTTdDLE9BQU8sR0FBR29OLE1BQU0sQ0FBQytuQixZQUFQLENBQW9CdHlCLENBQUMsQ0FBQ2dTLEVBQXRCLENBQWhCO0FBRUk3VSxlQUhpQixHQUlwQjBGLElBQUksR0FBRzhPLEVBQUUsQ0FBQzJ1QyxlQUFILENBQW1CenNDLE1BQW5CLEVBQTJCOVEsQ0FBM0IsRUFBOEJDLENBQTlCLEVBQWlDN0YsT0FBakMsQ0FKYSxJQU1oQndVLEVBQUUsQ0FBQ2lnQyxVQUFILENBQWM1eEMsQ0FBZCxDQU5nQixLQU9uQjZULE1BQU0sR0FBR2xDLEVBQUUsQ0FBQzYyQixtQkFBSCxDQUF1QjMwQixNQUF2QixDQVBVLEdBVXBCaFIsSUFBSSxHQUFHN0YsSUFBSSxDQUFDdWpELEtBQUwsQ0FBVzV1QyxFQUFFLENBQUNxdEMsUUFBSCxDQUFZaC9DLENBQVosQ0FBWCxFQUEyQjZULE1BQTNCLENBVmE7QUFZckIsT0FaRCxNQWFLQSxNQUFNLENBQUMsQ0FBRCxDQWJYLEtBY0V3c0MsRUFBRSxHQUFHdDlDLENBQUMsQ0FBQzhRLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVTlRLENBQVgsQ0FkUixFQWVFd3hDLEVBQUUsR0FBR3Z4QyxDQUFDLENBQUM2USxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVV2UyxLQUFYLENBZlIsR0FrQkN1QixJQUFJLEdBQUdnUCxTQUFTLGVBQVEwaUMsRUFBUixjQUFjOEwsRUFBZCxnQkFBMEJBLEVBQTFCLGNBQWdDOUwsRUFBaEMsQ0FsQmpCOztBQXFCQSxhQUFPMXhDLElBQUksSUFBSSxPQUFmO0FBQ0EsS0E3QkQ7QUE4QkEsR0F6TDhCO0FBMkwvQmc5Qyx1QkEzTCtCLGlDQTJMVEYsV0EzTFMsRUEyTElhLFVBM0xKLEVBMkxnQjtBQUFFO0FBQUYsUUFDeEM3dUMsRUFBRSxHQUFHLElBRG1DO0FBQUEsUUFFeENwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUY0QjtBQUFBLFFBR3hDazJDLGNBQWMsR0FBR2QsV0FBVyxDQUFDOUwsT0FBWixHQUFzQixDQUhDO0FBQUEsUUFJeENHLEtBQUssR0FBRyxDQUFDLENBQUN3TSxVQUo4QjtBQUFBLFFBS3hDejlDLENBQUMsR0FBRzRPLEVBQUUsQ0FBQ21pQyxTQUFILENBQWEsQ0FBYixFQUFnQjJNLGNBQWhCLEVBQWdDZCxXQUFoQyxFQUE2QzNMLEtBQTdDLENBTG9DO0FBQUEsUUFNeENoeEMsQ0FBQyxHQUFHMk8sRUFBRSxDQUFDeWlDLFNBQUgsQ0FBYUosS0FBYixDQU5vQztBQUFBLFFBT3hDME0sVUFBVSxHQUFHL3VDLEVBQUUsQ0FBQzBpQyxjQUFILENBQWtCMWlDLEVBQUUsQ0FBQ2daLFVBQXJCLEVBQWlDZzFCLFdBQWpDLEVBQThDM0wsS0FBOUMsQ0FQMkI7QUFBQSxRQVF4QzNtQixNQUFNLEdBQUcybUIsS0FBSyxHQUFHcmlDLEVBQUUsQ0FBQ3VzQixZQUFOLEdBQXFCdnNCLEVBQUUsQ0FBQ3FzQixTQVJFO0FBVTlDLFdBQU8sVUFBQ2grQixDQUFELEVBQUl5QyxDQUFKLEVBQVU7QUFBQSxVQUNWOHhDLEVBQUUsR0FBR2xuQixNQUFNLENBQUN4ckIsSUFBUCxDQUFZOFAsRUFBWixFQUFnQjNSLENBQUMsQ0FBQ2dTLEVBQWxCLEVBQXNCLENBQXRCLENBREs7QUFBQSxVQUVWd3JCLE1BQU0sR0FBR2tqQixVQUFVLENBQUMxZ0QsQ0FBRCxFQUFJeUMsQ0FBSixDQUFWLElBQW9COHhDLEVBRm5CO0FBQUEsVUFHVm1KLElBQUksR0FBRzM2QyxDQUFDLENBQUMvQyxDQUFELENBSEU7QUFBQSxVQUlaMjlDLElBQUksR0FBRzM2QyxDQUFDLENBQUNoRCxDQUFELENBSkk7QUFPWnVLLFlBQU0sQ0FBQ3VILFlBQVAsS0FDRjlSLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVSxDQUFWLElBQWVxOEMsSUFBSSxHQUFHcEosRUFBdkIsSUFBK0J2MEMsQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBQVYsSUFBZWl6QyxFQUFFLEdBQUdvSixJQURoRCxDQVBZLEtBVWZBLElBQUksR0FBR3BKLEVBVlE7QUFhaEI7QUFDQSxVQUFNMzRCLEtBQUssR0FBRyxDQUFDOGhDLElBQUQsRUFBT0MsSUFBSSxJQUFJcEosRUFBRSxHQUFHL1csTUFBVCxDQUFYLENBQWQ7QUFFQSxhQUFPLENBQ041aEIsS0FETSxFQUVOQSxLQUZNLEVBRUM7QUFDUEEsV0FITSxFQUlOQSxLQUpNLENBQVA7QUFNQSxLQXRCRDtBQXVCQSxHQTVOOEI7QUE4Ti9CMGtDLGlCQTlOK0IsMkJBOE5mdGdELENBOU5lLEVBOE5aK0MsQ0E5TlksRUE4TlRDLENBOU5TLEVBOE5OMjlDLFFBOU5NLEVBOE5JO0FBQUEsUUFTOUJDLEVBVDhCO0FBQUEsUUFVOUJDLEVBVjhCO0FBQUEsUUFXOUJ6K0MsSUFYOEI7QUFBQSxRQVk5QjArQyxNQVo4QjtBQUFBLFFBQzVCbnZDLEVBQUUsR0FBRyxJQUR1QjtBQUFBLFFBRTVCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGZ0I7QUFBQSxRQUc1QnNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSFM7QUFBQSxRQUk1QmtELFlBQVksR0FBR3JELEVBQUUsQ0FBQ3FELFlBQUgsRUFKYTtBQUFBLFFBSzVCK3JDLE9BQU8sR0FBR3B2QyxFQUFFLENBQUN5QyxhQUFILEtBQXFCLEVBQXJCLEdBQTJCLENBTFQ7QUFBQSxRQU01QmpYLE9BQU8sR0FBRyxFQU5rQjtBQUFBLFFBTzVCNmpELFNBQVMsR0FBRyxLQVBnQjtBQUFBLFFBZTVCQyxlQUFlLEdBQUcsVUFBQ0MsT0FBRCxFQUFVQyxhQUFWLEVBQTRCO0FBQ25ELFdBQUssSUFBV0MsR0FBWCxFQUFJMytDLENBQUMsR0FBRyxDQUFiLEVBQXNCMitDLEdBQUcsR0FBR0QsYUFBYSxDQUFDMStDLENBQUQsQ0FBekMsRUFBK0NBLENBQUMsRUFBaEQsRUFDQyxJQUFJMitDLEdBQUcsQ0FBQ3Q2QyxLQUFKLEdBQVlvNkMsT0FBWixJQUF1QkEsT0FBTyxJQUFJRSxHQUFHLENBQUNyNkMsR0FBMUMsRUFDQyxPQUFPcTZDLEdBQUcsQ0FBQ3Q1QyxLQUFYOztBQUlGO0FBQ0EsS0F2QmlDOztBQXlCbEM7QUFDQSxRQUFJdEksU0FBUyxDQUFDbWhELFFBQUQsQ0FBYixFQUF5QjtBQUN4QixVQUFNVSxRQUFRLEdBQUcsVUFBQ2xpRCxDQUFELEVBQUl6RyxHQUFKO0FBQUEsZUFDaEI2RyxXQUFXLENBQUNKLENBQUQsQ0FBWCxHQUFpQnpHLEdBQWpCLEdBQXdCc2MsWUFBWSxHQUFHckQsRUFBRSxDQUFDc0QsU0FBSCxDQUFhOVYsQ0FBYixDQUFILEdBQXFCQSxDQUR6QztBQUFBLE9BQWpCOztBQUlBLFdBQUssSUFBV2lpRCxHQUFYLEVBQUkzK0MsQ0FBQyxHQUFHLENBQWIsRUFBc0IyK0MsR0FBRyxHQUFHVCxRQUFRLENBQUNsK0MsQ0FBRCxDQUFwQyxFQUEwQ0EsQ0FBQyxFQUEzQyxFQUErQztBQUFBLFlBQ3hDcUUsS0FBSyxHQUFHdTZDLFFBQVEsQ0FBQ0QsR0FBRyxDQUFDdDZDLEtBQUwsRUFBWTlHLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSytDLENBQWpCLENBRHdCO0FBQUEsWUFFeENnRSxHQUFHLEdBQUdzNkMsUUFBUSxDQUFDRCxHQUFHLENBQUNyNkMsR0FBTCxFQUFVL0csQ0FBQyxDQUFDQSxDQUFDLENBQUNHLE1BQUYsR0FBVyxDQUFaLENBQUQsQ0FBZ0I0QyxDQUExQixDQUYwQjtBQUFBLFlBR3hDK0UsS0FBSyxHQUFHczVDLEdBQUcsQ0FBQ3Q1QyxLQUFKLElBQWE7QUFBQ2s1QyxtQkFBUyxFQUFUQTtBQUFELFNBSG1CO0FBSzlDN2pELGVBQU8sQ0FBQ3NGLENBQUQsQ0FBUCxHQUFhO0FBQUNxRSxlQUFLLEVBQUxBLEtBQUQ7QUFBUUMsYUFBRyxFQUFIQSxHQUFSO0FBQWFlLGVBQUssRUFBTEE7QUFBYixTQUxpQztBQU05QztBQUNELEtBdENpQyxDQXdDbEM7OztBQXhDa0MsUUF5QzVCaTRDLE1BQU0sR0FBR2x1QyxTQUFTLEdBQUcsVUFBQXl2QyxFQUFFO0FBQUEsYUFBSXQrQyxDQUFDLENBQUNzK0MsRUFBRSxDQUFDaGdELEtBQUosQ0FBTDtBQUFBLEtBQUwsR0FBdUIsVUFBQWdnRCxFQUFFO0FBQUEsYUFBSXYrQyxDQUFDLENBQUN1K0MsRUFBRSxDQUFDditDLENBQUosQ0FBTDtBQUFBLEtBekNmO0FBQUEsUUEwQzVCbTlDLE1BQU0sR0FBR3J1QyxTQUFTLEdBQUcsVUFBQXl2QyxFQUFFO0FBQUEsYUFBSXYrQyxDQUFDLENBQUN1K0MsRUFBRSxDQUFDditDLENBQUosQ0FBTDtBQUFBLEtBQUwsR0FBbUIsVUFBQXUrQyxFQUFFO0FBQUEsYUFBSXQrQyxDQUFDLENBQUNzK0MsRUFBRSxDQUFDaGdELEtBQUosQ0FBTDtBQUFBLEtBMUNYO0FBQUEsUUE2QzVCaWdELFNBQVMsR0FBRyxVQUFBdEUsTUFBTTtBQUFBLHdCQUFRQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUFSLGNBQXdCQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUF4QixjQUF3Q0EsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBeEMsY0FBd0RBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBQXhEO0FBQUEsS0E3Q1U7QUFBQSxRQStDNUJ1RSxXQUFXLEdBQUd4c0MsWUFBWSxHQUFHLFVBQUN5c0MsRUFBRCxFQUFLQyxFQUFMLEVBQVMxaEIsQ0FBVCxFQUFZMmhCLGNBQVosRUFBK0I7QUFBQSxVQUMzRHRCLEVBQUUsR0FBR29CLEVBQUUsQ0FBQzErQyxDQUFILENBQUtrL0IsT0FBTCxFQURzRDtBQUFBLFVBRTNEMmYsS0FBSyxHQUFHRixFQUFFLENBQUMzK0MsQ0FBSCxHQUFPMCtDLEVBQUUsQ0FBQzErQyxDQUZ5QztBQUFBLFVBRzNEOCtDLEdBQUcsR0FBRyxJQUFJemhELElBQUosQ0FBU2lnRCxFQUFFLEdBQUd1QixLQUFLLEdBQUc1aEIsQ0FBdEIsQ0FIcUQ7QUFBQSxVQUkzRDhoQixHQUFHLEdBQUcsSUFBSTFoRCxJQUFKLENBQVNpZ0QsRUFBRSxHQUFHdUIsS0FBSyxJQUFJNWhCLENBQUMsR0FBRzJoQixjQUFSLENBQW5CLENBSnFEO0FBQUEsVUFNM0QxRSxNQUFNLEdBQUdwckMsU0FBUyxHQUN2QixDQUFDLENBQUM3TyxDQUFDLENBQUM2OUMsRUFBRSxDQUFDN2dCLENBQUQsQ0FBSCxDQUFGLEVBQVdqOUIsQ0FBQyxDQUFDOCtDLEdBQUQsQ0FBWixDQUFELEVBQXFCLENBQUM3K0MsQ0FBQyxDQUFDNjlDLEVBQUUsQ0FBQzdnQixDQUFDLEdBQUc1OUIsSUFBTCxDQUFILENBQUYsRUFBa0JXLENBQUMsQ0FBQysrQyxHQUFELENBQW5CLENBQXJCLENBRHVCLEdBRXZCLENBQUMsQ0FBQy8rQyxDQUFDLENBQUM4K0MsR0FBRCxDQUFGLEVBQVM3K0MsQ0FBQyxDQUFDNjlDLEVBQUUsQ0FBQzdnQixDQUFELENBQUgsQ0FBVixDQUFELEVBQXFCLENBQUNqOUIsQ0FBQyxDQUFDKytDLEdBQUQsQ0FBRixFQUFTOStDLENBQUMsQ0FBQzY5QyxFQUFFLENBQUM3Z0IsQ0FBQyxHQUFHNTlCLElBQUwsQ0FBSCxDQUFWLENBQXJCLENBUmdFO0FBVWpFLGFBQU9tL0MsU0FBUyxDQUFDdEUsTUFBRCxDQUFoQjtBQUNBLEtBWCtCLEdBVzVCLFVBQUN3RSxFQUFELEVBQUtDLEVBQUwsRUFBUzFoQixDQUFULEVBQVkraEIsU0FBWixFQUEwQjtBQUM3QixVQUFNOUUsTUFBTSxHQUFHcHJDLFNBQVMsR0FDdkIsQ0FBQyxDQUFDN08sQ0FBQyxDQUFDNjlDLEVBQUUsQ0FBQzdnQixDQUFELENBQUgsS0FBRixFQUFpQmo5QixDQUFDLENBQUM2OUMsRUFBRSxDQUFDNWdCLENBQUQsQ0FBSCxDQUFsQixDQUFELEVBQTZCLENBQUNoOUIsQ0FBQyxDQUFDNjlDLEVBQUUsQ0FBQzdnQixDQUFDLEdBQUcraEIsU0FBTCxDQUFILEtBQUYsRUFBNkJoL0MsQ0FBQyxDQUFDNjlDLEVBQUUsQ0FBQzVnQixDQUFDLEdBQUcraEIsU0FBTCxDQUFILENBQTlCLENBQTdCLENBRHVCLEdBRXZCLENBQUMsQ0FBQ2gvQyxDQUFDLENBQUM2OUMsRUFBRSxDQUFDNWdCLENBQUQsQ0FBSCxLQUFGLEVBQWlCaDlCLENBQUMsQ0FBQzY5QyxFQUFFLENBQUM3Z0IsQ0FBRCxDQUFILENBQWxCLENBQUQsRUFBNkIsQ0FBQ2o5QixDQUFDLENBQUM2OUMsRUFBRSxDQUFDNWdCLENBQUMsR0FBRytoQixTQUFMLENBQUgsS0FBRixFQUE2Qi8rQyxDQUFDLENBQUM2OUMsRUFBRSxDQUFDN2dCLENBQUMsR0FBRytoQixTQUFMLENBQUgsQ0FBOUIsQ0FBN0IsQ0FGRDtBQUlBLGFBQU9SLFNBQVMsQ0FBQ3RFLE1BQUQsQ0FBaEI7QUFDQSxLQWhFaUM7QUFBQSxRQW1FOUJwNkMsSUFBSSxHQUFHLEdBbkV1Qjs7QUFxRWxDLFNBQUssSUFBVzZDLElBQVgsRUFBSWpELEVBQUMsR0FBRyxDQUFiLEVBQXVCaUQsSUFBSSxHQUFHMUYsQ0FBQyxDQUFDeUMsRUFBRCxDQUEvQixFQUFxQ0EsRUFBQyxFQUF0QyxFQUEwQztBQUFBLFVBQ25DdS9DLFFBQVEsR0FBR2hpRCxDQUFDLENBQUN5QyxFQUFDLEdBQUcsQ0FBTCxDQUR1QjtBQUFBLFVBRXJDcUYsS0FBSyxHQUFHbTVDLGVBQWUsQ0FBQ3Y3QyxJQUFJLENBQUMzQyxDQUFOLEVBQVM1RixPQUFULENBRmM7QUFJekM7QUFDQSxVQUFJb0MsV0FBVyxDQUFDcEMsT0FBRCxDQUFYLElBQXdCLENBQUMySyxLQUE3QixFQUNDakYsSUFBSSxjQUFPSixFQUFDLEdBQUcsR0FBSCxHQUFTLEVBQWpCLFNBQXNCczlDLE1BQU0sQ0FBQ3I2QyxJQUFELENBQTVCLGNBQXNDdzZDLE1BQU0sQ0FBQ3g2QyxJQUFELENBQTVDLENBREwsTUFFTztBQUNOLFlBQUk7QUFDSG9DLGVBQUssR0FBR0EsS0FBSyxDQUFDazVDLFNBQU4sQ0FBZ0J6K0MsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FETDtBQUVILFNBRkQsQ0FFRSxPQUFPNkMsQ0FBUCxFQUFVO0FBQ1gwQyxlQUFLLEdBQUdrNUMsU0FBUyxDQUFDeitDLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FERztBQUVYLFNBTEssQ0FPTjs7O0FBQ0FxK0MsVUFBRSxHQUFHanZDLEVBQUUsQ0FBQ3lyQixRQUFILENBQVk0a0IsUUFBUSxDQUFDai9DLENBQVQsR0FBYWcrQyxPQUF6QixFQUFrQ3I3QyxJQUFJLENBQUMzQyxDQUFMLEdBQVNnK0MsT0FBM0MsRUFBb0QvckMsWUFBcEQsQ0FSQyxFQVNONnJDLEVBQUUsR0FBR2x2QyxFQUFFLENBQUN5ckIsUUFBSCxDQUFZNGtCLFFBQVEsQ0FBQzFnRCxLQUFyQixFQUE0Qm9FLElBQUksQ0FBQ3BFLEtBQWpDLENBVEM7QUFBQSxZQVdBb08sRUFBRSxHQUFHM00sQ0FBQyxDQUFDMkMsSUFBSSxDQUFDM0MsQ0FBTixDQUFELEdBQVlBLENBQUMsQ0FBQ2kvQyxRQUFRLENBQUNqL0MsQ0FBVixDQVhsQjtBQUFBLFlBWUFaLEVBQUUsR0FBR2EsQ0FBQyxDQUFDMEMsSUFBSSxDQUFDcEUsS0FBTixDQUFELEdBQWdCMEIsQ0FBQyxDQUFDZy9DLFFBQVEsQ0FBQzFnRCxLQUFWLENBWnRCO0FBQUEsWUFhQTJnRCxFQUFFLEdBQUd0aUQsSUFBSSxDQUFDMm9DLElBQUwsQ0FBVTNvQyxJQUFJLENBQUM0b0MsR0FBTCxDQUFTNzRCLEVBQVQsRUFBYSxDQUFiLElBQWtCL1AsSUFBSSxDQUFDNG9DLEdBQUwsQ0FBU3BtQyxFQUFULEVBQWEsQ0FBYixDQUE1QixDQWJMO0FBZU5DLFlBQUksR0FBRzBGLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV202QyxFQWZaLEVBZ0JObkIsTUFBTSxHQUFHMStDLElBQUksR0FBRzBGLEtBQUssQ0FBQyxDQUFELENBaEJmOztBQWtCTixhQUFLLElBQUkrM0IsQ0FBQyxHQUFHejlCLElBQWIsRUFBbUJ5OUIsQ0FBQyxJQUFJLENBQXhCLEVBQTJCQSxDQUFDLElBQUlpaEIsTUFBaEMsRUFDQ2orQyxJQUFJLElBQUkyK0MsV0FBVyxDQUFDUSxRQUFELEVBQVd0OEMsSUFBWCxFQUFpQm02QixDQUFqQixFQUFvQno5QixJQUFwQixDQURwQixFQUlLeTlCLENBQUMsR0FBR2loQixNQUFKLElBQWMsQ0FKbkIsS0FLRWorQyxJQUFJLElBQUkyK0MsV0FBVyxDQUFDUSxRQUFELEVBQVd0OEMsSUFBWCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUxyQjtBQVFBO0FBQ0Q7O0FBRUQsV0FBTzdDLElBQVA7QUFDQSxHQXhVOEI7QUEwVS9CcS9DLG9CQTFVK0IsZ0NBMFVWO0FBQ3BCLFFBQU12d0MsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQmpVLE9BQWhCLENBQXdCLFVBQUF4QixDQUFDLEVBQUk7QUFDNUIsVUFBTWdTLEVBQUUsYUFBTUwsRUFBRSxDQUFDcUosVUFBVCwwQkFBbUNySixFQUFFLENBQUNzMkIsdUJBQUgsQ0FBMkJqb0MsQ0FBQyxDQUFDZ1MsRUFBN0IsQ0FBbkMsQ0FBUjs7QUFFQSxVQUFJTCxFQUFFLENBQUNrWixVQUFILENBQWM3cUIsQ0FBZCxLQUFvQjJSLEVBQUUsQ0FBQzRPLElBQUgsQ0FBUXhjLE1BQVIsWUFBbUJpTyxFQUFuQixHQUF5QmxXLEtBQXpCLEVBQXhCLEVBQTBEO0FBQ25ELFlBQUEwZixLQUFLLEdBQUc3SixFQUFFLENBQUM2SixLQUFILENBQVN4YixDQUFULENBQVI7QUFBQSxvQ0FLRjJSLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTh1QixtQkFMUjtBQUFBLDJEQUVMdDJCLENBRks7QUFBQSxZQUVMQSxDQUZLLHVDQUVELENBQUMsQ0FBRCxFQUFJLENBQUosQ0FGQztBQUFBLDJEQUdMQyxDQUhLO0FBQUEsWUFHTEEsQ0FISyx1Q0FHRCxDQUFDLENBQUQsRUFBSSxDQUFKLENBSEM7QUFBQSwyREFJTG0vQyxLQUpLO0FBQUEsWUFJTEEsS0FKSyx1Q0FJRyxDQUFDLENBQUMsQ0FBRCxFQUFJM21DLEtBQUosRUFBVyxDQUFYLENBQUQsRUFBZ0IsQ0FBQyxDQUFELEVBQUlBLEtBQUosRUFBVyxDQUFYLENBQWhCLENBSkg7QUFBQSxZQU9BNG1DLGNBUEEsR0FPaUJ6d0MsRUFBRSxDQUFDNE8sSUFBSCxDQUFRN2QsTUFBUixDQUFlLGdCQUFmLEVBQ3JCQyxJQURxQixDQUNoQixJQURnQixZQUNQcVAsRUFETyxHQUVyQnJQLElBRnFCLENBRWhCLElBRmdCLEVBRVZJLENBQUMsQ0FBQyxDQUFELENBRlMsRUFHckJKLElBSHFCLENBR2hCLElBSGdCLEVBR1ZJLENBQUMsQ0FBQyxDQUFELENBSFMsRUFJckJKLElBSnFCLENBSWhCLElBSmdCLEVBSVZLLENBQUMsQ0FBQyxDQUFELENBSlMsRUFLckJMLElBTHFCLENBS2hCLElBTGdCLEVBS1ZLLENBQUMsQ0FBQyxDQUFELENBTFMsQ0FQakI7QUFjTm0vQyxhQUFLLENBQUMzZ0QsT0FBTixDQUFjLFVBQUFyQyxDQUFDLEVBQUk7QUFDbEIsY0FBTWtqRCxTQUFTLEdBQUdqakQsVUFBVSxDQUFDRCxDQUFDLENBQUMsQ0FBRCxDQUFGLENBQVYsR0FBbUJBLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBS2EsQ0FBQyxDQUFDZ1MsRUFBUCxDQUFuQixHQUFnQzdTLENBQUMsQ0FBQyxDQUFELENBQW5EO0FBRUFpakQsd0JBQWMsQ0FBQzEvQyxNQUFmLENBQXNCLE1BQXRCLEVBQ0VDLElBREYsQ0FDTyxRQURQLEVBQ2lCeEQsQ0FBQyxDQUFDLENBQUQsQ0FEbEIsRUFFRXdELElBRkYsQ0FFTyxZQUZQLEVBRXFCMC9DLFNBQVMsSUFBSTdtQyxLQUZsQyxFQUdFN1ksSUFIRixDQUdPLGNBSFAsRUFHdUJ4RCxDQUFDLENBQUMsQ0FBRCxDQUh4QixDQUhrQjtBQU9sQixTQVBELENBZnlEO0FBdUJ6RDtBQUNELEtBM0JELENBSG9CO0FBK0JwQixHQXpXOEI7QUEyVy9CbWpELGlCQTNXK0IsMkJBMldmdGlELENBM1dlLEVBMldaO0FBQ2xCLFFBQU0yUixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTh1QixtQkFBVixrQkFDRTFuQixFQUFFLENBQUNxSixVQURMLDBCQUMrQnJKLEVBQUUsQ0FBQ3MyQix1QkFBSCxDQUEyQmpvQyxDQUFDLENBQUNnUyxFQUE3QixDQUQvQixTQUVOTCxFQUFFLENBQUM2SixLQUFILENBQVN4YixDQUFULENBRkQ7QUFHQSxHQWpYOEI7QUFtWC9CaW9CLFlBblgrQixzQkFtWHBCYixlQW5Yb0IsRUFtWEg7QUFDM0IsUUFBTXpWLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQ3BILE1BQUgsQ0FBVTh1QixtQkFBVixJQUFpQzFuQixFQUFFLENBQUN1d0Msa0JBQUgsRUFITixFQUszQnZ3QyxFQUFFLENBQUN5UixRQUFILEdBQWN6UixFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDdEssS0FBNUIsR0FDWjhVLFNBRFksWUFDRXhLLGNBQUssQ0FBQ3ZLLElBRFIsR0FFWmlNLElBRlksQ0FFUGlNLEVBQUUsQ0FBQ2t0QyxRQUFILENBQVkxeEMsSUFBWixDQUFpQndFLEVBQWpCLENBRk8sQ0FMYSxFQVMzQkEsRUFBRSxDQUFDeVIsUUFBSCxDQUFZblUsSUFBWixHQUFtQm5ELFVBQW5CLEdBQ0UrTixRQURGLENBQ1d1TixlQURYLEVBRUV0ZixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixFQUdFb0gsTUFIRixFQVQyQixFQWMzQnlDLEVBQUUsQ0FBQ3lSLFFBQUgsR0FBY3pSLEVBQUUsQ0FBQ3lSLFFBQUgsQ0FBWTNVLEtBQVosR0FBb0IvTCxNQUFwQixDQUEyQixNQUEzQixFQUNaQyxJQURZLENBQ1AsT0FETyxFQUNFZ1AsRUFBRSxDQUFDNHdDLFNBQUgsQ0FBYXAxQyxJQUFiLENBQWtCd0UsRUFBbEIsQ0FERixFQUVaN0osS0FGWSxDQUVOLE1BRk0sRUFFRTZKLEVBQUUsQ0FBQzJ3QyxlQUFILENBQW1CbjFDLElBQW5CLENBQXdCd0UsRUFBeEIsQ0FGRixFQUdaN0osS0FIWSxDQUdOLFNBSE0sRUFHSyxZQUFXO0FBRTVCLGFBREE2SixFQUFFLENBQUM2d0MsY0FBSCxHQUFvQnQwQyxpR0FBUSxDQUFDLElBQUQsQ0FBUixDQUFlcEcsS0FBZixDQUFxQixTQUFyQixDQUNwQixFQUFPLEdBQVA7QUFDQSxLQU5ZLEVBT1o0RyxLQVBZLENBT05pRCxFQUFFLENBQUN5UixRQVBHLENBZGEsRUF1QjNCelIsRUFBRSxDQUFDeVIsUUFBSCxDQUNFdGIsS0FERixDQUNRLFNBRFIsRUFDbUI2SixFQUFFLENBQUM2d0MsY0FEdEIsQ0F2QjJCO0FBeUIzQixHQTVZOEI7QUE4WS9CejJCLFlBOVkrQixzQkE4WXBCMDJCLFFBOVlvQixFQThZVjFwQyxjQTlZVSxFQThZTTtBQUNwQyxRQUFNcEgsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPLENBQ04sQ0FBQ29ILGNBQWMsR0FBR3BILEVBQUUsQ0FBQ3lSLFFBQUgsQ0FBWXRYLFVBQVosQ0FBdUI1SCxTQUFTLEVBQWhDLENBQUgsR0FBeUN5TixFQUFFLENBQUN5UixRQUEzRCxFQUNFemdCLElBREYsQ0FDTyxHQURQLEVBQ1k4L0MsUUFEWixFQUVFMzZDLEtBRkYsQ0FFUSxNQUZSLEVBRWdCNkosRUFBRSxDQUFDMndDLGVBQUgsQ0FBbUJuMUMsSUFBbkIsQ0FBd0J3RSxFQUF4QixDQUZoQixFQUdFN0osS0FIRixDQUdRLFNBSFIsRUFHbUIsVUFBQTlILENBQUM7QUFBQSxhQUFLMlIsRUFBRSxDQUFDK3lCLGVBQUgsQ0FBbUIxa0MsQ0FBbkIsSUFBd0IyUixFQUFFLENBQUM2d0MsY0FBSCxHQUFvQixJQUE1QyxHQUFtRDd3QyxFQUFFLENBQUM2d0MsY0FBM0Q7QUFBQSxLQUhwQixDQURNLENBQVA7QUFNQSxHQXZaOEI7O0FBeVovQjs7Ozs7OztBQU9BMTNCLGtCQWhhK0IsNEJBZ2FkNDNCLFdBaGFjLEVBZ2FEMU8sS0FoYUMsRUFnYU07QUFBQSxRQUM5QnJpQyxFQUFFLEdBQUcsSUFEeUI7QUFBQSxRQUU5QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmtCO0FBQUEsUUFHOUJxMUMsZUFBZSxHQUFHcjFDLE1BQU0sQ0FBQyt0QixnQkFISztBQUFBLFFBSTlCem1CLFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSlc7QUFBQSxRQU05QjhxQyxTQUFTLEdBQUdqckMsRUFBRSxDQUFDZ3hDLHFCQUFILENBQXlCRCxXQUF6QixFQUFzQzFPLEtBQXRDLENBTmtCO0FBQUEsUUFPOUI4TCxZQUFZLEdBQUc5TCxLQUFLLEdBQUdyaUMsRUFBRSxDQUFDdXNCLFlBQU4sR0FBcUJ2c0IsRUFBRSxDQUFDcXNCLFNBUGQ7QUFBQSxRQVM5QitoQixNQUFNLEdBQUcsVUFBQS8vQyxDQUFDO0FBQUEsYUFBSSxDQUFDZzBDLEtBQUssR0FBR3JpQyxFQUFFLENBQUNxdUMsS0FBTixHQUFjcnVDLEVBQUUsQ0FBQ3N1QyxFQUF2QixFQUEyQnArQyxJQUEzQixDQUFnQzhQLEVBQWhDLEVBQW9DM1IsQ0FBcEMsQ0FBSjtBQUFBLEtBVG9CO0FBQUEsUUFVOUI0aUQsTUFBTSxHQUFHLFVBQUM1aUQsQ0FBRCxFQUFJeUMsQ0FBSjtBQUFBLGFBQVdrUCxFQUFFLENBQUNteEIsU0FBSCxDQUFhOWlDLENBQUMsQ0FBQ2dTLEVBQWYsSUFDekI0cUMsU0FBUyxDQUFDNThDLENBQUQsRUFBSXlDLENBQUosQ0FBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUR5QixHQUV6QnE5QyxZQUFZLENBQUNqK0MsSUFBYixDQUFrQjhQLEVBQWxCLEVBQXNCM1IsQ0FBQyxDQUFDZ1MsRUFBeEIsRUFDQ0wsRUFBRSxDQUFDK3lCLGVBQUgsQ0FBbUIxa0MsQ0FBbkIsSUFDQzJSLEVBQUUsQ0FBQ2d6QixnQkFBSCxDQUFvQjNrQyxDQUFwQixFQUF1QixNQUF2QixDQURELEdBQ2tDLENBRm5DLENBRmM7QUFBQSxLQVZxQjtBQUFBLFFBZ0I5QjZpRCxNQUFNLEdBQUcsVUFBQzdpRCxDQUFELEVBQUl5QyxDQUFKO0FBQUEsYUFBV2tQLEVBQUUsQ0FBQ214QixTQUFILENBQWE5aUMsQ0FBQyxDQUFDZ1MsRUFBZixJQUN6QjRxQyxTQUFTLENBQUM1OEMsQ0FBRCxFQUFJeUMsQ0FBSixDQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBRHlCLEdBRXpCcTlDLFlBQVksQ0FBQ2orQyxJQUFiLENBQWtCOFAsRUFBbEIsRUFBc0IzUixDQUFDLENBQUNnUyxFQUF4QixFQUNDTCxFQUFFLENBQUMreUIsZUFBSCxDQUFtQjFrQyxDQUFuQixJQUNDMlIsRUFBRSxDQUFDZ3pCLGdCQUFILENBQW9CM2tDLENBQXBCLEVBQXVCLEtBQXZCLENBREQsR0FDaUNBLENBQUMsQ0FBQ3NCLEtBRnBDLENBRmM7QUFBQSxLQWhCcUI7O0FBdUJwQyxXQUFPLFVBQUF0QixDQUFDLEVBQUk7QUFBQSxVQUlQNkMsSUFKTztBQUFBLFVBQ1BnUixNQUFNLEdBQUcrckMsZUFBZSxHQUFHanVDLEVBQUUsQ0FBQ3kxQixnQkFBSCxDQUFvQnBuQyxDQUFDLENBQUM2VCxNQUF0QixDQUFILEdBQW1DN1QsQ0FBQyxDQUFDNlQsTUFEdEQ7QUFBQSxVQUVQd3NDLEVBQUUsR0FBRyxDQUZFO0FBQUEsVUFHUDlMLEVBQUUsR0FBRyxDQUhFOztBQU1YLFVBQUk1aUMsRUFBRSxDQUFDa1osVUFBSCxDQUFjN3FCLENBQWQsQ0FBSixFQUFzQjtBQUNyQixZQUFJdkcsSUFBSSxHQUFHcXBELG1GQUFNLEVBQWpCO0FBRUFycEQsWUFBSSxHQUFHb1ksU0FBUyxHQUNmcFksSUFBSSxDQUFDdUosQ0FBTCxDQUFPKzhDLE1BQVAsRUFDRU0sRUFERixDQUNLdUMsTUFETCxFQUVFci9CLEVBRkYsQ0FFS3MvQixNQUZMLENBRGUsR0FJZnBwRCxJQUFJLENBQUNzSixDQUFMLENBQU9nOUMsTUFBUCxFQUNFeEwsRUFERixDQUNLaHFDLE1BQU0sQ0FBQzZ1QixVQUFQLEdBQW9CLENBQXBCLEdBQXdCd3BCLE1BRDdCLEVBRUVuL0IsRUFGRixDQUVLby9CLE1BRkwsQ0FQb0IsRUFXaEJqRCxlQVhnQixLQVlwQm5tRCxJQUFJLEdBQUdBLElBQUksQ0FBQzJtRCxPQUFMLENBQWEsVUFBQXBnRCxDQUFDO0FBQUEsaUJBQUkyUixFQUFFLENBQUNvYixZQUFILENBQWdCL3NCLENBQWhCLE1BQXVCLElBQTNCO0FBQUEsU0FBZCxDQVphLEdBZWpCMlIsRUFBRSxDQUFDaWdDLFVBQUgsQ0FBYzV4QyxDQUFkLENBZmlCLEtBZ0JwQjZULE1BQU0sR0FBR2xDLEVBQUUsQ0FBQzYyQixtQkFBSCxDQUF1QjMwQixNQUF2QixDQWhCVyxHQW1CckJoUixJQUFJLEdBQUdwSixJQUFJLENBQUM4bUQsS0FBTCxDQUFXNXVDLEVBQUUsQ0FBQ3F0QyxRQUFILENBQVloL0MsQ0FBWixDQUFYLEVBQTJCNlQsTUFBM0IsQ0FuQmM7QUFvQnJCLE9BcEJELE1BcUJLQSxNQUFNLENBQUMsQ0FBRCxDQXJCWCxLQXNCRXdzQyxFQUFFLEdBQUcxdUMsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLOFEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVOVEsQ0FBZixDQXRCUCxFQXVCRXd4QyxFQUFFLEdBQUc1aUMsRUFBRSxDQUFDcXNCLFNBQUgsQ0FBYWgrQixDQUFDLENBQUNnUyxFQUFmLEVBQW1CNkIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVdlMsS0FBN0IsQ0F2QlAsR0EwQkN1QixJQUFJLEdBQUdnUCxTQUFTLGVBQVEwaUMsRUFBUixjQUFjOEwsRUFBZCxnQkFBMEJBLEVBQTFCLGNBQWdDOUwsRUFBaEMsQ0ExQmpCOztBQTZCQSxhQUFPMXhDLElBQUksSUFBSSxPQUFmO0FBQ0EsS0FwQ0Q7QUFxQ0EsR0E1ZDhCO0FBOGQvQjgvQyx1QkE5ZCtCLGlDQThkVEQsV0E5ZFMsRUE4ZEkxTyxLQTlkSixFQThkVztBQUN6QztBQUR5QyxRQUVuQ3JpQyxFQUFFLEdBQUcsSUFGOEI7QUFBQSxRQUduQ3BILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BSHVCO0FBQUEsUUFJbkN3NEMsY0FBYyxHQUFHTCxXQUFXLENBQUM3TyxPQUFaLEdBQXNCLENBSko7QUFBQSxRQUtuQzl3QyxDQUFDLEdBQUc0TyxFQUFFLENBQUNtaUMsU0FBSCxDQUFhLENBQWIsRUFBZ0JpUCxjQUFoQixFQUFnQ0wsV0FBaEMsRUFBNkMsQ0FBQyxDQUFDMU8sS0FBL0MsQ0FMK0I7QUFBQSxRQU1uQ2h4QyxDQUFDLEdBQUcyTyxFQUFFLENBQUN5aUMsU0FBSCxDQUFhLENBQUMsQ0FBQ0osS0FBZixDQU4rQjtBQUFBLFFBT25DZ1AsVUFBVSxHQUFHcnhDLEVBQUUsQ0FBQzBpQyxjQUFILENBQWtCMWlDLEVBQUUsQ0FBQ2taLFVBQXJCLEVBQWlDNjNCLFdBQWpDLEVBQThDLENBQUMsQ0FBQzFPLEtBQWhELENBUHNCO0FBQUEsUUFRbkMzbUIsTUFBTSxHQUFHMm1CLEtBQUssR0FBR3JpQyxFQUFFLENBQUN1c0IsWUFBTixHQUFxQnZzQixFQUFFLENBQUNxc0IsU0FSSDtBQVV6QyxXQUFPLFVBQVNoK0IsQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQUEsVUFDZjh4QyxFQUFFLEdBQUdsbkIsTUFBTSxDQUFDeHJCLElBQVAsQ0FBWThQLEVBQVosRUFBZ0IzUixDQUFDLENBQUNnUyxFQUFsQixFQUFzQixDQUF0QixDQURVO0FBQUEsVUFFZndyQixNQUFNLEdBQUd3bEIsVUFBVSxDQUFDaGpELENBQUQsRUFBSXlDLENBQUosQ0FBVixJQUFvQjh4QyxFQUZkO0FBQUEsVUFHZm1KLElBQUksR0FBRzM2QyxDQUFDLENBQUMvQyxDQUFELENBSE87QUFBQSxVQUlqQjI5QyxJQUFJLEdBQUczNkMsQ0FBQyxDQUFDaEQsQ0FBRCxDQUpTO0FBYXJCO0FBQ0EsYUFQSXVLLE1BQU0sQ0FBQ3VILFlBQVAsS0FDRjlSLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVSxDQUFWLElBQWVxOEMsSUFBSSxHQUFHcEosRUFBdkIsSUFBK0J2MEMsQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBQVYsSUFBZWl6QyxFQUFFLEdBQUdvSixJQURoRCxDQU9KLEtBSkNBLElBQUksR0FBR3BKLEVBSVIsR0FBTyxDQUNOLENBQUNtSixJQUFELEVBQU9sZ0IsTUFBUCxDQURNLEVBRU4sQ0FBQ2tnQixJQUFELEVBQU9DLElBQUksSUFBSXBKLEVBQUUsR0FBRy9XLE1BQVQsQ0FBWCxDQUZNLEVBR04sQ0FBQ2tnQixJQUFELEVBQU9DLElBQUksSUFBSXBKLEVBQUUsR0FBRy9XLE1BQVQsQ0FBWCxDQUhNLEVBR3dCO0FBQzlCLE9BQUNrZ0IsSUFBRCxFQUFPbGdCLE1BQVAsQ0FKTSxDQUlTO0FBSlQsT0FBUDtBQU1BLEtBcEJEO0FBcUJBLEdBN2Y4QjtBQStmL0J0VixjQS9mK0IsMEJBK2ZoQjtBQUNkLFFBQU12VyxFQUFFLEdBQUcsSUFBWDtBQUVLQSxNQUFFLENBQUNwSCxNQUFILENBQVUwaUIsVUFIRCxLQU9kdGIsRUFBRSxDQUFDMFIsVUFBSCxHQUFnQjFSLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsWUFBc0J4SyxjQUFLLENBQUN2SSxPQUE1QixHQUF1QytTLFNBQXZDLFlBQXFEeEssY0FBSyxDQUFDeEksTUFBM0QsR0FDZGtLLElBRGMsQ0FDVCxVQUFBMUYsQ0FBQztBQUFBLGFBQUksQ0FBQzJSLEVBQUUsQ0FBQzhXLFNBQUgsQ0FBYXpvQixDQUFiLENBQUQsS0FBcUIsQ0FBQzJSLEVBQUUsQ0FBQ2daLFVBQUgsQ0FBYzNxQixDQUFkLENBQUQsSUFBcUIyUixFQUFFLENBQUNzeEMsdUJBQUgsQ0FBMkJqakQsQ0FBM0IsQ0FBMUMsS0FDVjJSLEVBQUUsQ0FBQ3V4QyxZQUFILENBQWdCbGpELENBQWhCLENBRE07QUFBQSxLQURRLENBUEYsRUFXZDJSLEVBQUUsQ0FBQzBSLFVBQUgsQ0FBY3BVLElBQWQsR0FBcUJDLE1BQXJCLEVBWGMsRUFhZHlDLEVBQUUsQ0FBQzBSLFVBQUgsR0FBZ0IxUixFQUFFLENBQUMwUixVQUFILENBQWM1VSxLQUFkLEdBQ2QvTCxNQURjLENBQ1BpUCxFQUFFLENBQUNpSyxLQUFILENBQVMsUUFBVCxFQUFtQixJQUFuQixFQUF5QmpLLEVBQUUsQ0FBQ3d4QyxXQUFILENBQWVoMkMsSUFBZixDQUFvQndFLEVBQXBCLENBQXpCLEVBQWtEQSxFQUFFLENBQUN5eEMsTUFBSCxDQUFVajJDLElBQVYsQ0FBZXdFLEVBQWYsQ0FBbEQsRUFBc0VBLEVBQUUsQ0FBQzZKLEtBQXpFLENBRE8sRUFFZDlNLEtBRmMsQ0FFUmlELEVBQUUsQ0FBQzBSLFVBRkssRUFHZHZiLEtBSGMsQ0FHUixRQUhRLEVBR0U2SixFQUFFLENBQUM2SixLQUhMLEVBSWQxVCxLQUpjLENBSVIsU0FKUSxFQUlHNkosRUFBRSxDQUFDMHhDLHVCQUFILENBQTJCbDJDLElBQTNCLENBQWdDd0UsRUFBaEMsQ0FKSCxDQWJGO0FBa0JkLEdBamhCOEI7QUFtaEIvQnVhLGNBbmhCK0Isd0JBbWhCbEJmLEVBbmhCa0IsRUFtaEJkSSxFQW5oQmMsRUFtaEJWeFMsY0FuaEJVLEVBbWhCTWtPLElBbmhCTixFQW1oQlk7QUFBQSxRQUNwQ3RWLEVBQUUsR0FBRyxJQUQrQjtBQUFBLFFBRXBDdFUsZUFBZSxHQUFHc1UsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQzVHLGNBQTVCLEVBRmtCO0FBSTFDLFFBQUksQ0FBQ3VVLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTBpQixVQUFmLEVBQ0MsT0FBTyxFQUFQO0FBR0QsUUFBTXEyQixXQUFXLEdBQUcsRUFBcEI7QUFFQTN4QyxNQUFFLENBQUMwUixVQUFILENBQWNwVixJQUFkLENBQW1CLFVBQVNqTyxDQUFULEVBQVk7QUFBQSxVQUN4QjBCLEVBQUUsR0FBR2lRLEVBQUUsQ0FBQ2lLLEtBQUgsQ0FBUyxRQUFULEVBQW1CakssRUFBbkIsRUFBdUJ3WixFQUF2QixFQUEyQkksRUFBM0IsRUFBK0I1WixFQUFFLENBQUNxYixnQkFBSCxDQUFvQjdmLElBQXBCLENBQXlCd0UsRUFBekIsQ0FBL0IsRUFBNkRBLEVBQUUsQ0FBQzZKLEtBQWhFLEVBQXVFekMsY0FBdkUsRUFBdUZrTyxJQUF2RixFQUE2RjVwQixlQUE3RixFQUE4RzhQLElBQTlHLENBQW1ILElBQW5ILENBRG1CO0FBQUEsVUFFeEJvdkMsTUFBTSxHQUFHNzZDLEVBQUUsQ0FBQzFCLENBQUQsQ0FGYTtBQUk5QnNqRCxpQkFBVyxDQUFDdDhDLElBQVosQ0FBaUJ1MUMsTUFBakIsQ0FKOEI7QUFLOUIsS0FMRCxDQVYwQztBQWlCMUMsUUFBTWdILE9BQU8sR0FBRzV4QyxFQUFFLENBQUM2eEMsYUFBSCxLQUFxQixHQUFyQixHQUEyQixFQUEzQztBQUVBLFdBQU8sQ0FDTkYsV0FETSxFQUVOam1ELGVBQWUsQ0FDYnNGLElBREYsV0FDVTRnRCxPQURWLFFBQ3NCcDRCLEVBRHRCLEVBRUV4b0IsSUFGRixXQUVVNGdELE9BRlYsUUFFc0JoNEIsRUFGdEIsQ0FGTSxDQUFQO0FBTUEsR0E1aUI4QjtBQThpQi9CRCxTQTlpQitCLG1CQThpQnZCdHJCLENBOWlCdUIsRUE4aUJwQjtBQUFBLFFBQ0oyUixFQUFFLEdBQUcsSUFERDtBQUFBLFFBRUp2USxRQUFRLEdBQUdsQyxPQUFPLENBQUNjLENBQUMsQ0FBQytDLENBQUgsQ0FGZDtBQUlWLFdBQU80TyxFQUFFLENBQUNwSCxNQUFILENBQVVpUyxZQUFWLElBQTBCN0ssRUFBRSxDQUFDbUQsU0FBN0IsR0FDTDFULFFBQVEsR0FBR3VRLEVBQUUsQ0FBQ21ELFNBQUgsQ0FBYTlVLENBQUMsQ0FBQytDLENBQWYsQ0FBSCxHQUF1QixJQUQxQixHQUVMM0IsUUFBUSxHQUFHdVEsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLL0MsQ0FBQyxDQUFDK0MsQ0FBUCxDQUFILEdBQWUsSUFGekI7QUFHQSxHQXJqQjhCO0FBdWpCL0I0a0IsZUF2akIrQiwyQkF1akJmO0FBQ2YsUUFBTWhXLEVBQUUsR0FBRyxJQUFYOztBQUVBQSxNQUFFLENBQUMwWixPQUFILEdBQWEsVUFBQ3JyQixDQUFELEVBQUl5QyxDQUFKLEVBQVU7QUFDdEIsVUFBTXVQLEVBQUUsR0FBR2hTLENBQUMsQ0FBQ2dTLEVBQWI7QUFFQSxhQUFPTCxFQUFFLENBQUNteEIsU0FBSCxDQUFhOXdCLEVBQWIsSUFDTkwsRUFBRSxDQUFDa3VDLHFCQUFILENBQXlCbHVDLEVBQUUsQ0FBQytZLGVBQUgsQ0FBbUIvWSxFQUFFLENBQUNnWixVQUF0QixDQUF6QixFQUE0RDNxQixDQUE1RCxFQUErRHlDLENBQS9ELEVBQWtFLENBQWxFLEVBQXFFLENBQXJFLENBRE0sR0FFTmtQLEVBQUUsQ0FBQ3FzQixTQUFILENBQWFoc0IsRUFBYixFQUFpQkwsRUFBRSxDQUFDb2IsWUFBSCxDQUFnQi9zQixDQUFoQixDQUFqQixDQUZEO0FBR0EsS0FUYztBQVVmLEdBamtCOEI7QUFta0IvQnlqRCxZQW5rQitCLHNCQW1rQnBCaGhELENBbmtCb0IsRUFta0JqQnVQLEVBbmtCaUIsRUFta0JiO0FBQUEsUUFDWEwsRUFBRSxHQUFHLElBRE07QUFBQSxRQUVYK3FDLE1BQU0sR0FBSXg5QyxPQUFPLENBQUN1RCxDQUFELENBQVAsY0FBaUJBLENBQWpCLE1BRkM7QUFJakIsV0FBTyxDQUFDdVAsRUFBRSxHQUFHTCxFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDdkksT0FBNUIsU0FBc0NrVyxFQUFFLENBQUNzMkIsdUJBQUgsQ0FBMkJqMkIsRUFBM0IsQ0FBdEMsRUFBSCxHQUE2RUwsRUFBRSxDQUFDL04sSUFBbkYsRUFDTDRLLFNBREssWUFDU3hLLGNBQUssQ0FBQ3hJLE1BRGYsU0FDd0JraEQsTUFEeEIsRUFBUDtBQUVBLEdBemtCOEI7QUEya0IvQmhNLGVBM2tCK0IseUJBMmtCakJqdUMsQ0Eza0JpQixFQTJrQmR1UCxFQTNrQmMsRUEya0JWeStCLEtBM2tCVSxFQTJrQkg7QUFBQSxRQUNyQjkrQixFQUFFLEdBQUcsSUFEZ0I7QUFBQSxRQUVyQnBCLENBQUMsR0FBR29CLEVBQUUsQ0FBQyt4QyxjQUFILENBQWtCdjJDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FGaUI7QUFJM0I4K0IsU0FBSyxJQUFJOStCLEVBQUUsQ0FBQzYrQixlQUFILEVBSmtCO0FBQUEsUUFNckIvMEMsT0FBTyxHQUFHa1csRUFBRSxDQUFDOHhDLFVBQUgsQ0FBY2hoRCxDQUFkLEVBQWlCdVAsRUFBakIsRUFBcUI4TSxPQUFyQixDQUE2QjlhLGNBQUssQ0FBQ2pGLFFBQW5DLEtBTlc7QUFBQSxRQU9yQnlMLEtBQUssR0FBRytGLENBQUMsQ0FBQzlVLE9BQUQsQ0FBRCxHQUFha1csRUFBRSxDQUFDcEgsTUFBSCxDQUFVd3RCLE9BUFY7QUFBQSxRQVFyQm9KLEtBQUssR0FBRyxJQUFJMzJCLEtBUlM7QUFVdkJtSCxNQUFFLENBQUM2eEMsYUFBSCxFQVZ1QixHQVcxQi9uRCxPQUFPLENBQUNrSCxJQUFSLENBQWEsR0FBYixFQUFrQjROLENBQWxCLENBWDBCLEdBYzFCOVUsT0FBTyxDQUFDd1MsSUFBUixDQUFhLFlBQVc7QUFDdkIsVUFBTTJOLEtBQUssR0FBRzFOLGlHQUFRLENBQUMsSUFBRCxDQUF0QjtBQUVBLFVBQUksS0FBSzBrQyxPQUFMLEtBQWlCLFFBQXJCLEVBQ0NoM0IsS0FBSyxDQUFDalosSUFBTixDQUFXLEdBQVgsRUFBZ0I0TixDQUFoQixDQURELE1BRU87QUFBQSw0QkFDa0IsS0FBS3pOLE9BQUwsRUFEbEI7QUFBQSxZQUNDRyxLQURELGlCQUNDQSxLQUREO0FBQUEsWUFDUUMsTUFEUixpQkFDUUEsTUFEUjtBQUFBLFlBRUFILENBRkEsR0FFSW8rQixLQUFLLElBQUksQ0FBQ3ZsQixLQUFLLENBQUNqWixJQUFOLENBQVcsR0FBWCxDQUFELEdBQW1CTSxLQUFLLEdBQUcsQ0FBL0IsQ0FGVDtBQUFBLFlBR0FELENBSEEsR0FHSW0rQixLQUFLLElBQUksQ0FBQ3ZsQixLQUFLLENBQUNqWixJQUFOLENBQVcsR0FBWCxDQUFELEdBQW1CTyxNQUFNLEdBQUcsQ0FBaEMsQ0FIVDs7QUFLTjBZLGFBQUssQ0FBQ2paLElBQU4sQ0FBVyxXQUFYLHNCQUFxQ0ksQ0FBckMsY0FBMENDLENBQTFDLHFCQUFzRHdILEtBQXRELE9BTE07QUFNTjtBQUNELEtBWkQsQ0FkMEI7QUE0QjNCLEdBdm1COEI7QUF5bUIvQmdtQyxpQkF6bUIrQiwyQkF5bUJmL3RDLENBem1CZSxFQXltQlo7QUFBQSxRQUNaa1AsRUFBRSxHQUFHLElBRE87QUFBQSxRQUVacEIsQ0FBQyxHQUFHb0IsRUFBRSxDQUFDeXhDLE1BQUgsQ0FBVWoyQyxJQUFWLENBQWV3RSxFQUFmLENBRlE7QUFBQSxRQUlabFcsT0FBTyxHQUFHa1csRUFBRSxDQUFDOHhDLFVBQUgsQ0FBY2hoRCxDQUFkLEVBQ2RrRCxNQURjLENBQ1AsWUFBVztBQUNsQixhQUFPdUksaUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZTRRLE9BQWYsQ0FBdUI5YSxjQUFLLENBQUNqRixRQUE3QixDQUFQO0FBQ0EsS0FIYyxFQUlkK2YsT0FKYyxDQUlOOWEsY0FBSyxDQUFDakYsUUFKQSxLQUpFO0FBVWxCdEQsV0FBTyxDQUFDa0gsSUFBUixDQUFhLEdBQWIsRUFBa0I0TixDQUFsQixDQVZrQixFQVlqQm9CLEVBQUUsQ0FBQzZ4QyxhQUFILEVBQUQsSUFDQy9uRCxPQUFPLENBQUNrSCxJQUFSLENBQWEsV0FBYixrQkFBbUM0TixDQUFDLENBQUM5VSxPQUFELENBQUQsR0FBYWtXLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXd0QixPQUExRCxPQWJpQjtBQWNsQixHQXZuQjhCO0FBeW5CL0JxckIsUUF6bkIrQixZQXluQnhCcGpELENBem5Cd0IsRUF5bkJyQjtBQUFBLFFBQ0gyUixFQUFFLEdBQUcsSUFERjtBQUFBLFFBRUhwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZUO0FBQUEsUUFHSDY0QyxNQUFNLEdBQUc3NEMsTUFBTSxDQUFDd3RCLE9BSGI7QUFBQSxRQUlMeG5CLENBQUMsR0FBRzZ5QyxNQUpDO0FBY1QsV0FSSXp4QyxFQUFFLENBQUNpZ0MsVUFBSCxDQUFjNXhDLENBQWQsQ0FRSixHQVBDdVEsQ0FBQyxHQUFHLENBT0wsR0FOV29CLEVBQUUsQ0FBQ3ViLFlBQUgsQ0FBZ0JsdEIsQ0FBaEIsQ0FNWCxHQUxDdVEsQ0FBQyxHQUFHb0IsRUFBRSxDQUFDc3NDLFVBQUgsQ0FBY2orQyxDQUFkLENBS0wsR0FKV1osVUFBVSxDQUFDZ2tELE1BQUQsQ0FJckIsS0FIQzd5QyxDQUFDLEdBQUc2eUMsTUFBTSxDQUFDcGpELENBQUQsQ0FHWCxHQUFPdVEsQ0FBUDtBQUNBLEdBeG9COEI7QUEwb0IvQm16QyxnQkExb0IrQiwwQkEwb0JoQjFqRCxDQTFvQmdCLEVBMG9CYjtBQUFBLFFBQ1gyUixFQUFFLEdBQUcsSUFETTtBQUFBLFFBRVhwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZEO0FBQUEsUUFHWEMsS0FBSyxHQUFHbUgsRUFBRSxDQUFDdWIsWUFBSCxDQUFnQmx0QixDQUFoQixJQUFxQixJQUFyQixHQUE0QixJQUh6QjtBQUtqQixXQUFPdUssTUFBTSxDQUFDMHRCLDBCQUFQLEdBQ0wxdEIsTUFBTSxDQUFDMnRCLG9CQUFQLElBQStCdm1CLEVBQUUsQ0FBQ3l4QyxNQUFILENBQVVwakQsQ0FBVixJQUFld0ssS0FEekMsR0FDa0RtSCxFQUFFLENBQUN5eEMsTUFBSCxDQUFVcGpELENBQVYsQ0FEekQ7QUFFQSxHQWpwQjhCO0FBbXBCL0IrMEMsY0FucEIrQix3QkFtcEJsQi8wQyxDQW5wQmtCLEVBbXBCZjtBQUFBLFFBQ1QyUixFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRneUMsT0FBTyxHQUFHaHlDLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTZ0QixjQUZYO0FBSWYsV0FBT2g1QixVQUFVLENBQUN1a0QsT0FBRCxDQUFWLEdBQ05BLE9BQU8sQ0FBQzNqRCxDQUFELENBREQsR0FDUTJqRCxPQUFPLElBQUloeUMsRUFBRSxDQUFDeXhDLE1BQUgsQ0FBVXBqRCxDQUFWLElBQWUsQ0FEekM7QUFFQSxHQXpwQjhCO0FBMnBCL0I4MEMsZ0JBM3BCK0IsMEJBMnBCaEI1eUMsSUEzcEJnQixFQTJwQlZxTyxDQTNwQlUsRUEycEJQO0FBQUEsUUFDakJuSSxLQUFLLEdBQUd3b0MsZ0dBQU8sQ0FBQzF1QyxJQUFELENBREU7QUFBQSxRQUVqQnljLE9BQU8sR0FBR3pRLGlHQUFRLENBQUNoTSxJQUFELENBRkQ7QUFBQSxRQUdqQjBMLE1BQU0sR0FBRyxLQUFLNDFDLGFBQUwsS0FBdUIsR0FBdkIsR0FBNkIsRUFIckI7QUFBQSxRQUtuQnI0QixFQUFFLEdBQUcsQ0FBQ3hNLE9BQU8sQ0FBQ2hjLElBQVIsV0FBZ0JpTCxNQUFoQixPQUxhO0FBQUEsUUFNbkIyZCxFQUFFLEdBQUcsQ0FBQzVNLE9BQU8sQ0FBQ2hjLElBQVIsV0FBZ0JpTCxNQUFoQixPQU5hOztBQVF2QjtBQUNBLFFBQUksRUFBRXVkLEVBQUUsSUFBSUksRUFBUixLQUFlcnBCLElBQUksQ0FBQ25CLFFBQUwsS0FBa0IsQ0FBckMsRUFBd0M7QUFBQSxpQkFDeEJtQixJQUFJLENBQUNZLE9BQUwsR0FBZVosSUFBSSxDQUFDWSxPQUFMLEVBQWYsR0FBZ0NaLElBQUksQ0FBQ2tCLHFCQUFMLEVBRFI7QUFBQSxVQUNoQ0wsQ0FEZ0MsUUFDaENBLENBRGdDO0FBQUEsVUFDN0JDLENBRDZCLFFBQzdCQSxDQUQ2Qjs7QUFHdkNtb0IsUUFBRSxHQUFHcG9CLENBSGtDLEVBSXZDd29CLEVBQUUsR0FBR3ZvQixDQUprQztBQUt2Qzs7QUFFRCxRQUFNNGdELEVBQUUsR0FBR2prRCxJQUFJLENBQUMyb0MsSUFBTCxDQUNWM29DLElBQUksQ0FBQzRvQyxHQUFMLENBQVNwZCxFQUFFLEdBQUcvaUIsS0FBSyxDQUFDLENBQUQsQ0FBbkIsRUFBd0IsQ0FBeEIsSUFBNkJ6SSxJQUFJLENBQUM0b0MsR0FBTCxDQUFTaGQsRUFBRSxHQUFHbmpCLEtBQUssQ0FBQyxDQUFELENBQW5CLEVBQXdCLENBQXhCLENBRG5CLEtBRU5tSSxDQUFDLElBQUksS0FBS2hHLE1BQUwsQ0FBWXl0QixpQkFGWCxDQUFYO0FBSUEsV0FBTzRyQixFQUFQO0FBQ0EsR0FockI4QjtBQWtyQi9CL08sY0FsckIrQix3QkFrckJsQkosSUFsckJrQixFQWtyQlp6eEMsQ0FsckJZLEVBa3JCVDtBQUNyQixXQUFPckQsSUFBSSxDQUFDbXRCLEdBQUwsQ0FBUzlwQixDQUFDLEdBQUc0dEMsZ0dBQU8sQ0FBQzZELElBQUQsQ0FBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxFQUF4QztBQUNBLEdBcHJCOEI7QUFzckIvQndPLHlCQXRyQitCLG1DQXNyQlBqakQsQ0F0ckJPLEVBc3JCSjtBQUMxQixRQUFNNmpELFNBQVMsR0FBRyxLQUFLdDVDLE1BQUwsQ0FBWWt1QixVQUE5QjtBQUVBLFdBQU9vckIsU0FBUyxPQUFULElBQ0xwakQsT0FBTyxDQUFDb2pELFNBQUQsQ0FBUCxJQUFzQkEsU0FBUyxDQUFDdnFELE9BQVYsQ0FBa0IwRyxDQUFDLENBQUNnUyxFQUFwQixNQUE0QixDQUFDLENBRHJEO0FBRUE7QUEzckI4QixDQUExQixDOztBQ2hCTjs7OztBQUlBO0FBSUE7QUFDQTtBQUVBMU4sTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0IrakIsbUJBRCtCLDZCQUNianVDLElBRGEsRUFDUDtBQUN2QixXQUFPLCtDQUErQ2lGLElBQS9DLENBQW9EakYsSUFBSSxJQUFJLEtBQUs2RCxNQUFMLENBQVk4dEIsVUFBeEUsQ0FBUDtBQUNBLEdBSDhCO0FBSy9CeXJCLDBCQUwrQixvQ0FLTnA5QyxJQUxNLEVBS0E7QUFDOUIsUUFBTXE5QyxTQUFTLEdBQUdyOUMsSUFBSSxJQUFJLEtBQUs2RCxNQUFMLENBQVk4dEIsVUFBdEM7QUFFQSxXQUFPcDRCLFlBQVksQ0FBQzhqRCxTQUFELENBQVosSUFDTjNrRCxVQUFVLENBQUMya0QsU0FBUyxDQUFDanJDLE1BQVgsQ0FESixJQUMwQjFaLFVBQVUsQ0FBQzJrRCxTQUFTLENBQUNDLE1BQVgsQ0FEM0M7QUFFQSxHQVY4QjtBQVkvQkMscUJBWitCLCtCQVlYcm9DLEtBWlcsRUFZSjVKLEVBWkksRUFZQTtBQUFBLFFBQ3hCTCxFQUFFLEdBQUcsSUFEbUI7QUFBQSxRQUV4QnV5QyxRQUFRLEdBQUcsVUFBQ0MsSUFBRCxFQUFPdG1ELE1BQVAsRUFBa0I7QUFHbEMsZUFBZ0JpRyxJQUFoQixFQUZNc2dELE9BQU8sR0FBR0QsSUFBSSxDQUFDRSxVQUVyQixFQUFTNWhELENBQUMsR0FBRyxDQUFiLEVBQXVCcUIsSUFBSSxHQUFHc2dELE9BQU8sQ0FBQzNoRCxDQUFELENBQXJDLEVBQTJDQSxDQUFDLEVBQTVDLEVBQ0NxQixJQUFJLEdBQUdBLElBQUksQ0FBQ0EsSUFEYixFQUVDakcsTUFBTSxDQUFDeW1ELFlBQVAsQ0FBb0J4Z0QsSUFBcEIsRUFBMEJxZ0QsSUFBSSxDQUFDSSxZQUFMLENBQWtCemdELElBQWxCLENBQTFCLENBRkQ7QUFJQSxLQVQ2QjtBQUFBLFFBV3hCN0ssR0FBRyxHQUFHLElBQUl1ckQsU0FBSixHQUFnQkMsZUFBaEIsQ0FBZ0M3b0MsS0FBaEMsRUFBdUMsZUFBdkMsQ0FYa0I7QUFBQSxRQVl4QjFaLElBQUksR0FBR2pKLEdBQUcsQ0FBQ3lyRCxlQVphO0FBQUEsUUFheEJDLEtBQUssR0FBR3pyRCxRQUFRLENBQUMwckQsZUFBVCxDQUF5QkMsNkZBQVksQ0FBQ3hzQyxHQUF0QyxFQUEyQ25XLElBQUksQ0FBQzB5QyxRQUFMLENBQWN6NkIsV0FBZCxFQUEzQyxDQWJnQjs7QUFxQjlCLFFBTkF3cUMsS0FBSyxDQUFDM3lDLEVBQU4sR0FBV0EsRUFNWCxFQUxBMnlDLEtBQUssQ0FBQzc4QyxLQUFOLENBQVlnOUMsSUFBWixHQUFtQixTQUtuQixFQUpBSCxLQUFLLENBQUM3OEMsS0FBTixDQUFZaTlDLE1BQVosR0FBcUIsU0FJckIsRUFGQWIsUUFBUSxDQUFDaGlELElBQUQsRUFBT3lpRCxLQUFQLENBRVIsRUFBSXppRCxJQUFJLENBQUM4aUQsVUFBTCxJQUFtQjlpRCxJQUFJLENBQUM4aUQsVUFBTCxDQUFnQjdrRCxNQUF2QyxFQUErQztBQUM5QyxVQUFNd3lDLE1BQU0sR0FBR3prQyxpR0FBUSxDQUFDeTJDLEtBQUQsQ0FBdkI7QUFFSSxxQkFBZUEsS0FIMkIsR0FJN0NoUyxNQUFNLENBQUNud0MsSUFBUCxDQUFZTixJQUFJLENBQUMraUQsU0FBakIsQ0FKNkMsR0FNN0NwZ0QsT0FBTyxDQUFDM0MsSUFBSSxDQUFDOGlELFVBQU4sQ0FBUCxDQUF5QnhqRCxPQUF6QixDQUFpQyxVQUFBckMsQ0FBQyxFQUFJO0FBQ3JDK2tELGdCQUFRLENBQUMva0QsQ0FBRCxFQUFJd3pDLE1BQU0sQ0FBQ2p3QyxNQUFQLENBQWN2RCxDQUFDLENBQUN5ekMsT0FBaEIsRUFBeUIxd0MsSUFBekIsRUFBSixDQUQ2QjtBQUVyQyxPQUZELENBTjZDO0FBVTlDOztBQUVEeVAsTUFBRSxDQUFDNE8sSUFBSCxDQUFRcmUsSUFBUixHQUFlK0YsV0FBZixDQUEyQjA4QyxLQUEzQixDQWpDOEI7QUFrQzlCLEdBOUM4QjtBQWdEL0JPLGVBaEQrQix5QkFnRGpCbHpDLEVBaERpQixFQWdEYjtBQUNqQixXQUFPLEtBQUt1TyxJQUFMLENBQVV4YyxNQUFWLFlBQXFCaU8sRUFBckIsRUFBUDtBQUNBLEdBbEQ4QjtBQW9EL0I2SixlQXBEK0IsMkJBb0RmO0FBQUEsUUFDVGxLLEVBQUUsR0FBRyxJQURJO0FBQUEsUUFFVHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkg7QUFBQSxRQUdUazFCLEdBQUcsR0FBRyxFQUhHO0FBQUEsUUFJVDBsQixPQUFPLEdBQUcza0QsUUFBUSxDQUFDK0osTUFBTSxDQUFDNHRCLGFBQVIsQ0FBUixHQUFpQzV0QixNQUFNLENBQUM0dEIsYUFBeEMsR0FBd0QsQ0FBQzV0QixNQUFNLENBQUM4dEIsVUFBUixDQUp6RDtBQU1mLFdBQU8sVUFBUytzQixNQUFULEVBQWlCdmhELE9BQWpCLEVBQW1DO0FBQUEsd0NBQU5qQyxJQUFNLGtFQUFOQSxJQUFNOztBQUN6QyxhQUFPLFVBQVM1QixDQUFULEVBQVk7QUFBQSxZQUdkNGIsS0FIYztBQUFBLFlBQ1o1SixFQUFFLEdBQUdoUyxDQUFDLENBQUNnUyxFQUFGLElBQVNoUyxDQUFDLENBQUMwRixJQUFGLElBQVUxRixDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUExQixJQUFpQ2hTLENBRDFCO0FBQUEsWUFFWjJlLE9BQU8sR0FBR3pRLGlHQUFRLENBQUMsSUFBRCxDQUZOO0FBVWxCLFlBTEl1eEIsR0FBRyxDQUFDbm1DLE9BQUosQ0FBWTBZLEVBQVosSUFBa0IsQ0FLdEIsSUFKQ3l0QixHQUFHLENBQUN6NEIsSUFBSixDQUFTZ0wsRUFBVCxDQUlELEVBRkE0SixLQUFLLEdBQUd1cEMsT0FBTyxDQUFDMWxCLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwWSxFQUFaLElBQWtCbXpDLE9BQU8sQ0FBQ2hsRCxNQUEzQixDQUVmLEVBQUl3UixFQUFFLENBQUNnakMsaUJBQUgsQ0FBcUIvNEIsS0FBckIsQ0FBSixFQUNDQSxLQUFLLEdBQUdqSyxFQUFFLENBQUNpSyxLQUFELENBRFgsTUFFTyxJQUFJLENBQUNqSyxFQUFFLENBQUNteUMsd0JBQUgsQ0FBNEJsb0MsS0FBNUIsQ0FBTCxFQUF5QztBQUFBLGNBQ3pDeXBDLE9BQU8sYUFBTTF6QyxFQUFFLENBQUNxSixVQUFULG9CQUE2QmhKLEVBQTdCLENBRGtDO0FBQUEsY0FFekNrekMsYUFBYSxHQUFHdnpDLEVBQUUsQ0FBQ3V6QyxhQUFILENBQWlCRyxPQUFqQixDQUZ5QjtBQVEvQyxjQUpJSCxhQUFhLENBQUNuNUMsSUFBZCxLQUF1QixDQUkzQixJQUhDNEYsRUFBRSxDQUFDc3lDLG1CQUFILENBQXVCcm9DLEtBQXZCLEVBQThCeXBDLE9BQTlCLENBR0QsRUFBSUQsTUFBTSxLQUFLLFFBQWYsRUFDQyxPQUFPenpDLEVBQUUsQ0FBQzJ6QyxNQUFILENBQVV4c0MsTUFBVixDQUFpQjNMLElBQWpCLENBQXNCdEosT0FBdEIsaUJBQStCOGEsT0FBL0IsRUFBd0MwbUMsT0FBeEMsU0FBb0R6akQsSUFBcEQsRUFBUDtBQUNNLGNBQUl3akQsTUFBTSxLQUFLLFFBQWYsRUFDTixPQUFPenpDLEVBQUUsQ0FBQzJ6QyxNQUFILENBQVV0QixNQUFWLENBQWlCNzJDLElBQWpCLENBQXNCdEosT0FBdEIsaUJBQStCOGEsT0FBL0IsU0FBMkMvYyxJQUEzQyxFQUFQO0FBRUQ7QUFFRCxlQUFPZ2EsS0FBSyxDQUFDd3BDLE1BQUQsQ0FBTCxDQUFjajRDLElBQWQsQ0FBbUJ0SixPQUFuQixpQkFBNEI4YSxPQUE1QixTQUF3Qy9jLElBQXhDLEVBQVA7QUFDQSxPQTVCRDtBQTZCQSxLQTlCRDtBQStCQSxHQXpGOEI7QUEyRi9CMmpELG1CQTNGK0IsK0JBMkZYO0FBQ25CLFdBQU9yaEQsU0FBUyxFQUFoQjtBQUNBLEdBN0Y4QjtBQStGL0JvaEQsUUFBTSxFQUFFO0FBQ1B4c0MsVUFETyxrQkFDQTZGLE9BREEsRUFDUzNNLEVBRFQsRUFDYXd6QyxVQURiLEVBQ3lCQyxNQUR6QixFQUNpQ0MsV0FEakMsRUFDOEM7QUFDcEQsYUFBTy9tQyxPQUFPLENBQUNqYyxNQUFSLENBQWUsS0FBZixFQUNMQyxJQURLLENBQ0EsWUFEQSxhQUNrQnFQLEVBRGxCLEdBRUxyUCxJQUZLLENBRUEsT0FGQSxFQUVTNmlELFVBRlQsRUFHTDE5QyxLQUhLLENBR0MsTUFIRCxFQUdTNDlDLFdBSFQsRUFJTHhqRCxJQUpLLEVBQVA7QUFLQSxLQVBNO0FBU1A4aEQsVUFUTyxrQkFTQXJsQyxPQVRBLEVBU1NnbkMsTUFUVCxFQVNpQkMsTUFUakIsRUFTeUJDLGNBVHpCLEVBU3lDSCxXQVR6QyxFQVVOM3NDLGNBVk0sRUFVVWtPLElBVlYsRUFVZ0I1cEIsZUFWaEIsRUFVaUM7QUFDakMsVUFBQXNVLEVBQUUsR0FBRyxJQUFMO0FBQUEsa0NBQ2tCZ04sT0FBTyxDQUFDemMsSUFBUixHQUFlWSxPQUFmLEVBRGxCO0FBQUEsVUFDQ0csS0FERCx5QkFDQ0EsS0FERDtBQUFBLFVBQ1FDLE1BRFIseUJBQ1FBLE1BRFI7QUFBQSxVQUdBNGlELE9BSEEsR0FHVSxVQUFBOWxELENBQUM7QUFBQSxlQUFJMmxELE1BQU0sQ0FBQzNsRCxDQUFELENBQU4sR0FBWWlELEtBQUssR0FBRyxDQUF4QjtBQUFBLE9BSFg7QUFBQSxVQUlBOGlELE9BSkEsR0FJVSxVQUFBL2xELENBQUM7QUFBQSxlQUFJNGxELE1BQU0sQ0FBQzVsRCxDQUFELENBQU4sR0FBWWtELE1BQU0sR0FBRyxDQUF6QjtBQUFBLE9BSlg7QUFBQSxVQUtGb2dELFdBTEUsR0FLWTNrQyxPQUxaOztBQU9OLFVBQUk1RixjQUFKLEVBQW9CO0FBQ25CLFlBQU1pdEMsY0FBYyxHQUFHcjBDLEVBQUUsQ0FBQzR6QyxpQkFBSCxFQUF2QjtBQUVJdCtCLFlBSGUsS0FJbEJxOEIsV0FBVyxHQUFHM2tDLE9BQU8sQ0FDbkJoYyxJQURZLENBQ1AsR0FETyxFQUNGbWpELE9BREUsQ0FKSSxHQVFuQnhDLFdBQVcsR0FBRzNrQyxPQUFPLENBQ25CN1MsVUFEWSxDQUNEazZDLGNBREMsRUFFWnJqRCxJQUZZLENBRVAsR0FGTyxFQUVGbWpELE9BRkUsRUFHWm5qRCxJQUhZLENBR1AsR0FITyxFQUdGb2pELE9BSEUsRUFJWmo2QyxVQUpZLENBSURrNkMsY0FKQyxDQVJLLEVBY25CM29ELGVBQWUsQ0FBQ3lPLFVBQWhCLENBQTJCNkYsRUFBRSxDQUFDNHpDLGlCQUFILEVBQTNCLENBZG1CO0FBZW5CLE9BZkQsTUFnQkNqQyxXQUFXLEdBQUcza0MsT0FBTyxDQUNuQmhjLElBRFksQ0FDUCxHQURPLEVBQ0ZtakQsT0FERSxFQUVabmpELElBRlksQ0FFUCxHQUZPLEVBRUZvakQsT0FGRSxDQWhCZjs7QUFxQkEsYUFBT3pDLFdBQVcsQ0FDaEJ4N0MsS0FESyxDQUNDLFNBREQsRUFDWSs5QyxjQURaLEVBRUwvOUMsS0FGSyxDQUVDLE1BRkQsRUFFUzQ5QyxXQUZULENBQVA7QUFHQTtBQTFDTSxHQS9GdUI7QUE0SS9CO0FBQ0FscUQsUUFBTSxFQUFFO0FBQ1BzZCxVQURPLGtCQUNBNkYsT0FEQSxFQUNTNm1DLFVBRFQsRUFDcUJDLE1BRHJCLEVBQzZCQyxXQUQ3QixFQUMwQztBQUNoRCxhQUFPL21DLE9BQU8sQ0FBQ2pjLE1BQVIsQ0FBZSxRQUFmLEVBQ0xDLElBREssQ0FDQSxPQURBLEVBQ1M2aUQsVUFEVCxFQUVMN2lELElBRkssQ0FFQSxHQUZBLEVBRUs4aUQsTUFGTCxFQUdMMzlDLEtBSEssQ0FHQyxNQUhELEVBR1M0OUMsV0FIVCxFQUlMeGpELElBSkssRUFBUDtBQUtBLEtBUE07QUFTUDhoRCxVQVRPLGtCQVNBcmxDLE9BVEEsRUFTU2duQyxNQVRULEVBU2lCQyxNQVRqQixFQVN5QkMsY0FUekIsRUFTeUNILFdBVHpDLEVBVU4zc0MsY0FWTSxFQVVVa08sSUFWVixFQVVnQjVwQixlQVZoQixFQVVpQztBQUFBLFVBQ2pDc1UsRUFBRSxHQUFHLElBRDRCO0FBQUEsVUFFbkMyeEMsV0FBVyxHQUFHM2tDLE9BRnFCOztBQVV2QyxVQUxJaE4sRUFBRSxDQUFDNE4sT0FBSCxDQUFXLFFBQVgsQ0FLSixLQUpDK2pDLFdBQVcsR0FBR0EsV0FBVyxDQUN2QjNnRCxJQURZLENBQ1AsR0FETyxFQUNGZ1AsRUFBRSxDQUFDeXhDLE1BQUgsQ0FBVWoyQyxJQUFWLENBQWV3RSxFQUFmLENBREUsQ0FJZixHQUFJb0gsY0FBSixFQUFvQjtBQUNuQixZQUFNaXRDLGNBQWMsR0FBR3IwQyxFQUFFLENBQUM0ekMsaUJBQUgsRUFBdkI7QUFFSXQrQixZQUhlLEtBSWxCcThCLFdBQVcsR0FBR0EsV0FBVyxDQUN2QjNnRCxJQURZLENBQ1AsSUFETyxFQUNEZ2pELE1BREMsQ0FKSSxHQVFuQnJDLFdBQVcsR0FBRzNrQyxPQUFPLENBQUNoYyxJQUFSLENBQWEsSUFBYixJQUNiMmdELFdBQVcsQ0FBQ3gzQyxVQUFaLENBQXVCazZDLGNBQXZCLEVBQ0VyakQsSUFERixDQUNPLElBRFAsRUFDYWdqRCxNQURiLEVBRUVoakQsSUFGRixDQUVPLElBRlAsRUFFYWlqRCxNQUZiLEVBR0U5NUMsVUFIRixDQUdhazZDLGNBSGIsQ0FEYSxHQUtiMUMsV0FBVyxDQUFDM2dELElBQVosQ0FBaUIsSUFBakIsRUFBdUJnakQsTUFBdkIsRUFDRWhqRCxJQURGLENBQ08sSUFEUCxFQUNhaWpELE1BRGIsQ0Fia0IsRUFnQm5Cdm9ELGVBQWUsQ0FBQ3lPLFVBQWhCLENBQTJCNkYsRUFBRSxDQUFDNHpDLGlCQUFILEVBQTNCLENBaEJtQjtBQWlCbkIsT0FqQkQsTUFrQkNqQyxXQUFXLEdBQUdBLFdBQVcsQ0FDdkIzZ0QsSUFEWSxDQUNQLElBRE8sRUFDRGdqRCxNQURDLEVBRVpoakQsSUFGWSxDQUVQLElBRk8sRUFFRGlqRCxNQUZDLENBbEJmOztBQXVCQSxhQUFPdEMsV0FBVyxDQUNoQng3QyxLQURLLENBQ0MsU0FERCxFQUNZKzlDLGNBRFosRUFFTC85QyxLQUZLLENBRUMsTUFGRCxFQUVTNDlDLFdBRlQsQ0FBUDtBQUdBO0FBOUNNLEdBN0l1QjtBQThML0I7QUFDQU8sV0FBUyxFQUFFO0FBQ1ZudEMsVUFEVSxrQkFDSDZGLE9BREcsRUFDTTZtQyxVQUROLEVBQ2tCQyxNQURsQixFQUMwQkMsV0FEMUIsRUFDdUM7QUFDaEQsVUFBTVEsVUFBVSxHQUFHLFVBQUFsbUQsQ0FBQztBQUFBLGVBQUl5bEQsTUFBTSxDQUFDemxELENBQUQsQ0FBTixHQUFZLENBQWhCO0FBQUEsT0FBcEI7O0FBRUEsYUFBTzJlLE9BQU8sQ0FBQ2pjLE1BQVIsQ0FBZSxNQUFmLEVBQ0xDLElBREssQ0FDQSxPQURBLEVBQ1M2aUQsVUFEVCxFQUVMN2lELElBRkssQ0FFQSxPQUZBLEVBRVN1akQsVUFGVCxFQUdMdmpELElBSEssQ0FHQSxRQUhBLEVBR1V1akQsVUFIVixFQUlMcCtDLEtBSkssQ0FJQyxNQUpELEVBSVM0OUMsV0FKVCxFQUtMeGpELElBTEssRUFBUDtBQU1BLEtBVlM7QUFZVjhoRCxVQVpVLGtCQVlIcmxDLE9BWkcsRUFZTWduQyxNQVpOLEVBWWNDLE1BWmQsRUFZc0JDLGNBWnRCLEVBWXNDSCxXQVp0QyxFQWFUM3NDLGNBYlMsRUFhT2tPLElBYlAsRUFhYTVwQixlQWJiLEVBYThCO0FBQUEsVUFDakNzVSxFQUFFLEdBQUcsSUFENEI7QUFBQSxVQUVqQ3BCLENBQUMsR0FBR29CLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXd0QixPQUZtQjtBQUFBLFVBR2pDb3VCLFVBQVUsR0FBRyxVQUFBbm1ELENBQUM7QUFBQSxlQUFJMmxELE1BQU0sQ0FBQzNsRCxDQUFELENBQU4sR0FBWXVRLENBQWhCO0FBQUEsT0FIbUI7QUFBQSxVQUlqQzYxQyxVQUFVLEdBQUcsVUFBQXBtRCxDQUFDO0FBQUEsZUFBSTRsRCxNQUFNLENBQUM1bEQsQ0FBRCxDQUFOLEdBQVl1USxDQUFoQjtBQUFBLE9BSm1CO0FBQUEsVUFNbkMreUMsV0FBVyxHQUFHM2tDLE9BTnFCOztBQVF2QyxVQUFJNUYsY0FBSixFQUFvQjtBQUNuQixZQUFNaXRDLGNBQWMsR0FBR3IwQyxFQUFFLENBQUM0ekMsaUJBQUgsRUFBdkI7QUFFSXQrQixZQUhlLEtBSWxCcThCLFdBQVcsR0FBR0EsV0FBVyxDQUN2QjNnRCxJQURZLENBQ1AsR0FETyxFQUNGd2pELFVBREUsQ0FKSSxHQVFuQjdDLFdBQVcsR0FBR0EsV0FBVyxDQUN2QngzQyxVQURZLENBQ0RrNkMsY0FEQyxFQUVacmpELElBRlksQ0FFUCxHQUZPLEVBRUZ3akQsVUFGRSxFQUdaeGpELElBSFksQ0FHUCxHQUhPLEVBR0Z5akQsVUFIRSxFQUladDZDLFVBSlksQ0FJRGs2QyxjQUpDLENBUkssRUFjbkIzb0QsZUFBZSxDQUFDeU8sVUFBaEIsQ0FBMkI2RixFQUFFLENBQUM0ekMsaUJBQUgsRUFBM0IsQ0FkbUI7QUFlbkIsT0FmRCxNQWdCQ2pDLFdBQVcsR0FBR0EsV0FBVyxDQUN2QjNnRCxJQURZLENBQ1AsR0FETyxFQUNGd2pELFVBREUsRUFFWnhqRCxJQUZZLENBRVAsR0FGTyxFQUVGeWpELFVBRkUsQ0FoQmY7O0FBcUJBLGFBQU85QyxXQUFXLENBQ2hCeDdDLEtBREssQ0FDQyxTQURELEVBQ1krOUMsY0FEWixFQUVMLzlDLEtBRkssQ0FFQyxNQUZELEVBRVM0OUMsV0FGVCxDQUFQO0FBR0E7QUE3Q1M7QUEvTG9CLENBQTFCLEM7Ozs7QUNYTjs7OztBQUlBO0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVdBLFNBQVNXLFdBQVQsQ0FBcUJDLFdBQXJCLEVBQWtDNS9DLElBQWxDLEVBQXdDNi9DLElBQXhDLEVBQThDcjJDLEdBQTlDLEVBQW1EckYsS0FBbkQsRUFBMERzMkIsS0FBMUQsRUFBaUU7QUFBQSxNQUMxRDd4QixLQUFLLEdBQUdnM0MsV0FBVyxJQUFJcDJDLEdBQUcsR0FBRyxDQUFyQixHQUF5QnEyQyxJQUFJLEdBQUdyMkMsR0FBaEMsR0FBc0NBLEdBRFk7QUFBQSxNQUUxREssQ0FBQyxHQUFHLElBQUk1USxJQUFJLENBQUNpUSxFQUY2QztBQUFBLE1BRzFENDJDLElBQUksR0FBRzkvQyxJQUFJLEtBQUssR0FBVCxHQUFlL0csSUFBSSxDQUFDZ1EsR0FBcEIsR0FBMEJoUSxJQUFJLENBQUM4ekMsR0FIb0I7QUFLaEUsU0FBTzVvQyxLQUFLLElBQUksSUFBSXMyQixLQUFLLEdBQUdxbEIsSUFBSSxDQUFDbDNDLEtBQUssR0FBR2lCLENBQVIsR0FBWWcyQyxJQUFiLENBQXBCLENBQVo7QUFDQSxDLENBRUQ7OztBQUNBLElBQU0xaEIsY0FBUSxHQUFHLGNBQWpCO0FBRUF2Z0MsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I2MUIsV0FEK0IsdUJBQ25CO0FBQUEsUUFDTDkwQyxFQUFFLEdBQUcsSUFEQTtBQUFBLFFBRUxwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZQO0FBSVBvSCxNQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQUpPLEtBS1Y1TixFQUFFLENBQUM0VyxNQUFILEdBQVk1VyxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3pKLEtBQXpCLEdBQWtDbUksTUFBbEMsQ0FBeUMsR0FBekMsRUFDVkMsSUFEVSxDQUNMLE9BREssRUFDSXFCLGNBQUssQ0FBQzNJLFdBRFYsQ0FMRixFQVNWc1csRUFBRSxDQUFDNFcsTUFBSCxDQUFVeHJCLE1BQVYsR0FBbUI0VSxFQUFFLENBQUM0VyxNQUFILENBQVU3bEIsTUFBVixDQUFpQixHQUFqQixFQUNqQkMsSUFEaUIsQ0FDWixPQURZLEVBQ0hxQixjQUFLLENBQUNqSCxNQURILENBVFQsRUFhVjRVLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVS9WLElBQVYsR0FBaUJiLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVTdsQixNQUFWLENBQWlCLEdBQWpCLEVBQ2ZDLElBRGUsQ0FDVixPQURVLEVBQ0RxQixjQUFLLENBQUNySyxJQURMLENBYlAsRUFpQlZnWSxFQUFFLENBQUM0VyxNQUFILENBQVVockIsTUFBVixHQUFtQm9VLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVTdsQixNQUFWLENBQWlCLEdBQWpCLEVBQ2pCQyxJQURpQixDQUNaLE9BRFksRUFDSHFCLGNBQUssQ0FBQ3pHLE1BREgsQ0FqQlQsRUFvQlZvVSxFQUFFLENBQUNnNEIsUUFBSCxHQUFjcC9CLE1BQU0sQ0FBQzZ3QixjQUFQLElBQXlCenBCLEVBQUUsQ0FBQ2tSLGFBQUgsR0FBbUJoVyxHQUFuQixDQUF1QixDQUF2QixFQUEwQnZMLEtBcEJ2RDtBQXNCWCxHQXZCOEI7QUF5Qi9Cb2xELGNBekIrQiwwQkF5QmhCO0FBQUEsUUFDUi8wQyxFQUFFLEdBQUcsSUFERztBQUFBLFFBRVJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZKO0FBQUEsUUFJUjhPLE9BQU8sR0FBRzlPLE1BQU0sQ0FBQzZpQixpQkFBUCxDQUF5Qmp0QixNQUF6QixHQUFrQyxDQUFsQyxHQUFzQyxDQUFDLEVBQXZDLEdBQTRDLEVBSjlDO0FBQUEsUUFLUjRMLElBQUksR0FBRyxDQUFDcE0sSUFBSSxDQUFDMkQsR0FBTCxDQUFTcU8sRUFBRSxDQUFDeVQsUUFBWixFQUFzQnpULEVBQUUsQ0FBQzBULFNBQXpCLElBQXNDaE0sT0FBdkMsSUFBa0QsQ0FMakQ7QUFPZCxXQUFPLENBQUN0TixJQUFELEVBQU9BLElBQVAsQ0FBUDtBQUNBLEdBakM4QjtBQW1DL0I4Wix1QkFuQytCLGlDQW1DVHBRLE9BbkNTLEVBbUNBO0FBQUEsUUFDeEI5RCxFQUFFLEdBQUcsSUFEbUI7QUFBQSxRQUV4QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlk7QUFJMUJySyxXQUFPLENBQUNxSyxNQUFNLENBQUM2aUIsaUJBQVIsQ0FKbUIsS0FLN0I3aUIsTUFBTSxDQUFDNmlCLGlCQUFQLEdBQTJCdm1CLFFBQVEsQ0FBQyxDQUFELEVBQUlKLFNBQVMsQ0FBQyxLQUFELEVBQVFnUCxPQUFPLENBQUNwVCxHQUFSLENBQVksVUFBQWxELENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUMwVSxNQUFGLENBQVMxVCxNQUFiO0FBQUEsS0FBYixDQUFSLENBQWIsQ0FMTixHQVE5QndSLEVBQUUsQ0FBQ2cxQyxtQkFBSCxFQVI4QjtBQVM5QixHQTVDOEI7QUE4Qy9CQyxrQkE5QytCLDRCQThDZGxnRCxJQTlDYyxFQThDUjRJLEtBOUNRLEVBOENEekUsS0E5Q0MsRUE4Q01zMkIsS0E5Q04sRUE4Q2E7QUFDckMsUUFBQXh2QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0FwSCxNQURBLEdBQ1NvSCxFQUFFLENBQUNwSCxNQURaO0FBQUEsMkJBRWtCb0gsRUFBRSxDQUFDKzBDLFlBQUgsRUFGbEI7QUFBQTtBQUFBLFFBRUN6akQsS0FGRDtBQUFBLFFBRVFDLE1BRlI7QUFBQSxRQUdBcWpELElBSEEsR0FHT2g4QyxNQUFNLENBQUM2aUIsaUJBQVAsQ0FBeUJqdEIsTUFIaEM7QUFBQSxRQUlBbW1ELFdBSkEsR0FJYy83QyxNQUFNLENBQUNxeEIseUJBSnJCO0FBQUEsUUFNQTFyQixHQU5BLEdBTU1yTCxPQUFPLENBQUM2QixJQUFELENBQVAsQ0FBY3JFLEdBQWQsQ0FBa0IsVUFBQWxELENBQUM7QUFBQSxhQUFJa25ELFdBQVcsQ0FDN0NDLFdBRDZDLEVBRTdDbm5ELENBRjZDLEVBRzdDb25ELElBSDZDLEVBSTdDajNDLEtBSjZDLEVBSzdDOVAsU0FBUyxDQUFDcUwsS0FBRCxDQUFULEdBQW1CQSxLQUFuQixHQUE0Qm5FLElBQUksS0FBSyxHQUFULEdBQWV6RCxLQUFmLEdBQXVCQyxNQUxOLEVBTTdDNUQsUUFBUSxDQUFDNmhDLEtBQUQsQ0FBUixHQUFrQkEsS0FBbEIsR0FBMEI1MkIsTUFBTSxDQUFDb3hCLGdCQU5ZLENBQWY7QUFBQSxLQUFuQixDQU5OOztBQWVOLFdBQU96ckIsR0FBRyxDQUFDL1AsTUFBSixLQUFlLENBQWYsR0FBbUIrUCxHQUFHLENBQUMsQ0FBRCxDQUF0QixHQUE0QkEsR0FBbkM7QUFDQSxHQS9EOEI7O0FBaUUvQjs7OztBQUlBeTJDLHFCQXJFK0IsaUNBcUVUO0FBQ2YsUUFBQWgxQyxFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0E4RCxPQURBLEdBQ1U5RCxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQURsQjtBQUFBLDRCQUdrQjlELEVBQUUsQ0FBQyswQyxZQUFILEVBSGxCO0FBQUE7QUFBQSxRQUdDempELEtBSEQ7QUFBQSxRQUdRQyxNQUhSO0FBQUEsUUFJQSs1QyxNQUpBLEdBSVN0ckMsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsY0FBWixLQUF5QixFQUpsQztBQUFBLFFBS0E5NEIsSUFMQSxHQUtPa3hDLE1BQU0sQ0FBQzRKLEtBTGQ7O0FBUUQ5NkMsUUFBRCxLQUFVQSxJQUFJLENBQUM5SSxLQUFMLEtBQWVBLEtBQWYsSUFBd0I4SSxJQUFJLENBQUM3SSxNQUFMLEtBQWdCQSxNQUFsRCxDQVRpQixLQVVwQnVTLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQXhCLENBQUMsRUFBSTtBQUNwQmk5QyxZQUFNLENBQUNqOUMsQ0FBQyxDQUFDZ1MsRUFBSCxDQUFOLEdBQWVoUyxDQUFDLENBQUM2VCxNQUFGLENBQVN4UixHQUFULENBQWEsVUFBQ2xELENBQUQsRUFBSXNELENBQUo7QUFBQSxlQUMzQmtQLEVBQUUsQ0FBQ2kxQyxnQkFBSCxDQUFvQixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXBCLEVBQWdDbmtELENBQWhDLEVBQW1DbUUsU0FBbkMsRUFBOEMrSyxFQUFFLENBQUNxM0IsUUFBSCxDQUFZLE9BQVosRUFBcUI3cEMsQ0FBckIsQ0FBOUMsQ0FEMkI7QUFBQSxPQUFiLENBREs7QUFJcEIsS0FKRCxDQVZvQixFQWdCcEI4OUMsTUFBTSxDQUFDNEosS0FBUCxHQUFlO0FBQUM1akQsV0FBSyxFQUFMQSxLQUFEO0FBQVFDLFlBQU0sRUFBTkE7QUFBUixLQWhCSyxFQWlCcEJ5TyxFQUFFLENBQUN3ekIsUUFBSCxDQUFZTixjQUFaLEVBQXNCb1ksTUFBdEIsQ0FqQm9CO0FBbUJyQixHQXhGOEI7QUEwRi9CejBCLGFBMUYrQix1QkEwRm5CM08sUUExRm1CLEVBMEZUdU4sZUExRlMsRUEwRlE7QUFBQSxRQUNoQ3pWLEVBQUUsR0FBRyxJQUQyQjtBQUFBLFFBRWhDeW1DLFNBQVMsR0FBR3ptQyxFQUFFLENBQUNpQixZQUFILENBQWdCLE9BQWhCLENBRm9CO0FBS2xDd2xDLGFBTGtDLEtBTXJDem1DLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVTVsQixJQUFWLENBQWUsV0FBZixFQUE0QnkxQyxTQUE1QixDQU5xQyxFQU9yQ3ptQyxFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLFlBQXNCeEssY0FBSyxDQUFDdkksT0FBNUIsR0FBdUNrSCxJQUF2QyxDQUE0QyxXQUE1QyxFQUF5RHkxQyxTQUF6RCxDQVBxQyxFQVFyQ3ptQyxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3pJLFVBQXpCLEdBQXVDb0gsSUFBdkMsQ0FBNEMsV0FBNUMsRUFBeUR5MUMsU0FBekQsQ0FScUMsRUFVckN6bUMsRUFBRSxDQUFDZzFDLG1CQUFILEVBVnFDLEVBV3JDaDFDLEVBQUUsQ0FBQ20xQyxnQkFBSCxFQVhxQyxFQVlyQ24xQyxFQUFFLENBQUNvMUMsZUFBSCxFQVpxQyxFQWFyQ3AxQyxFQUFFLENBQUNxMUMsZ0JBQUgsQ0FBb0JudEMsUUFBcEIsRUFBOEJ1TixlQUE5QixDQWJxQztBQWV0QyxHQXpHOEI7QUEyRy9CNi9CLHdCQTNHK0Isb0NBMkdOO0FBQUEsUUFDbEJ0MUMsRUFBRSxHQUFHLElBRGE7QUFBQSxRQUVsQnNyQyxNQUFNLEdBQUd0ckMsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsY0FBWixDQUZTO0FBSXhCLFdBQU8sVUFBQzdrQyxDQUFELEVBQUl5QyxDQUFKLEVBQVU7QUFDaEIsVUFBTW1aLEtBQUssR0FBR3FoQyxNQUFNLENBQUNqOUMsQ0FBQyxDQUFDZ1MsRUFBSCxDQUFOLENBQWF2UCxDQUFiLENBQWQ7QUFFQSxhQUFPLENBQ05tWixLQURNLEVBRU5BLEtBRk0sRUFHTkEsS0FITSxFQUlOQSxLQUpNLENBQVA7QUFNQSxLQVREO0FBVUEsR0F6SDhCO0FBMkgvQmtyQyxrQkEzSCtCLDhCQTJIWjtBQUNaLFFBQUFuMUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNBcEgsTUFEQSxHQUNTb0gsRUFBRSxDQUFDcEgsTUFEWjtBQUFBLDRCQUVrQm9ILEVBQUUsQ0FBQyswQyxZQUFILEVBRmxCO0FBQUE7QUFBQSxRQUVDempELEtBRkQ7QUFBQSxRQUVRQyxNQUZSO0FBQUEsUUFHQWdrRCxLQUhBLEdBR1EzOEMsTUFBTSxDQUFDZ3hCLGlCQUhmO0FBQUEsUUFJQWdyQixJQUpBLEdBSU9oOEMsTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCanRCLE1BSmhDO0FBQUEsUUFLQWduRCxRQUxBLEdBS1c1OEMsTUFBTSxDQUFDbXhCLHFCQUxsQjtBQUFBLFFBT0EwckIsV0FQQSxHQU9jejFDLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVXhyQixNQVB4QjtBQUFBLFFBUUFzcUQsU0FSQSxHQVFZeGdELFFBQVEsQ0FBQyxDQUFELEVBQUlxZ0QsS0FBSixDQVJwQjtBQUFBLFFBVUF4USxNQVZBLEdBVVNuc0MsTUFBTSxDQUFDb3hCLGdCQUFQLEdBQTBCaDhCLElBQUksQ0FBQzJELEdBQUwsQ0FBU0wsS0FBVCxFQUFnQkMsTUFBaEIsQ0FWbkM7QUFBQSxRQVdBb2tELFVBWEEsR0FXYUQsU0FBUyxDQUFDaGxELEdBQVYsQ0FBYyxVQUFBa2xELENBQUM7QUFBQSxhQUFJN1EsTUFBTSxJQUFJLENBQUM2USxDQUFDLEdBQUcsQ0FBTCxJQUFVTCxLQUFkLENBQVY7QUFBQSxLQUFmLENBWGI7QUFBQSxRQVlBTSxlQVpBLEdBWWtCajlDLE1BQU0sQ0FBQ2t4Qix1QkFaekI7QUFBQSxRQWVBd2hCLE1BZkEsR0FlU29LLFNBQVMsQ0FBQ2hsRCxHQUFWLENBQWMsVUFBQWxELENBQUMsRUFBSTtBQUFBLFVBQzNCMEwsS0FBSyxHQUFHeThDLFVBQVUsQ0FBQ25vRCxDQUFELENBRFM7QUFBQSxVQUUzQitRLEdBQUcsR0FBR3JKLFFBQVEsQ0FBQyxDQUFELEVBQUkwL0MsSUFBSixDQUFSLENBQWtCbGtELEdBQWxCLENBQXNCLFVBQUFJLENBQUM7QUFBQSxlQUNsQ2tQLEVBQUUsQ0FBQ2kxQyxnQkFBSCxDQUFvQixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXBCLEVBQWdDbmtELENBQWhDLEVBQW1Db0ksS0FBbkMsRUFBMEMsQ0FBMUMsQ0FEc0MsQ0FDUTQ4QyxJQURSLENBQ2EsR0FEYixDQUFKO0FBQUEsT0FBdkIsQ0FGcUI7QUFNakMsYUFBT3YzQyxHQUFHLENBQUN1M0MsSUFBSixDQUFTLEdBQVQsQ0FBUDtBQUNBLEtBUGMsQ0FmVDtBQUFBLFFBd0JBM3FELEtBeEJBLEdBd0JRc3FELFdBQVcsQ0FDdkI1NEMsU0FEWSxZQUNFeEssY0FBSyxDQUFDbEgsS0FEUixHQUVaNEksSUFGWSxDQUVQMmhELFNBRk8sQ0F4QlI7O0FBNEJOdnFELFNBQUssQ0FBQ21TLElBQU4sR0FBYUMsTUFBYixFQTdCa0I7QUErQmxCLFFBQU13NEMsVUFBVSxHQUFHNXFELEtBQUssQ0FBQzJSLEtBQU4sR0FBYy9MLE1BQWQsQ0FBcUIsR0FBckIsRUFDakJDLElBRGlCLENBQ1osT0FEWSxFQUNILFVBQUMzQyxDQUFELEVBQUl5QyxDQUFKO0FBQUEsdUJBQWF1QixjQUFLLENBQUNsSCxLQUFuQixjQUE0QmtILGNBQUssQ0FBQ2xILEtBQWxDLGNBQTJDMkYsQ0FBM0M7QUFBQSxLQURHLENBQW5CO0FBR0FpbEQsY0FBVSxDQUFDaGxELE1BQVgsQ0FBa0IsU0FBbEIsRUFDRW9GLEtBREYsQ0FDUSxZQURSLEVBQ3NCeUMsTUFBTSxDQUFDaXhCLGdCQUFQLEdBQTBCLElBQTFCLEdBQWlDLFFBRHZELENBbENrQixFQXFDZDJyQixRQXJDYyxLQXNDYkMsV0FBVyxDQUFDcmpELE1BQVosQ0FBbUIsTUFBbkIsRUFBMkJqSSxLQUEzQixFQXRDYSxJQXVDaEJzckQsV0FBVyxDQUNUMWtELE1BREYsQ0FDUyxNQURULEVBRUVDLElBRkYsQ0FFTyxJQUZQLEVBRWEsT0FGYixFQUdFQSxJQUhGLENBR08sSUFIUCxFQUdhLE9BSGIsRUFJRW1GLEtBSkYsQ0FJUSxhQUpSLEVBSXVCLEtBSnZCLEVBS0VoSyxJQUxGLENBS087QUFBQSxhQUFNMHBELGVBQWUsQ0FBQyxDQUFELENBQXJCO0FBQUEsS0FMUCxDQXZDZ0IsRUErQ2pCRSxVQUFVLENBQUNobEQsTUFBWCxDQUFrQixNQUFsQixFQUNFQyxJQURGLENBQ08sSUFEUCxFQUNhLE9BRGIsRUFFRW1GLEtBRkYsQ0FFUSxhQUZSLEVBRXVCLEtBRnZCLEVBR0VoSyxJQUhGLENBR08sVUFBQWtDLENBQUM7QUFBQSxhQUFJd25ELGVBQWUsQ0FDekI3MUMsRUFBRSxDQUFDZzRCLFFBQUgsR0FBYzBkLFNBQVMsQ0FBQ2xuRCxNQUF4QixJQUFrQ0gsQ0FBQyxHQUFHLENBQXRDLENBRHlCLENBQW5CO0FBQUEsS0FIUixDQS9DaUIsR0F1RGxCMG5ELFVBQVUsQ0FDUmg1QyxLQURGLENBQ1E1UixLQURSLEVBRUU2RixJQUZGLENBRU8sV0FGUCxFQUVvQixVQUFBM0MsQ0FBQztBQUFBLGlDQUFpQmlELEtBQUssR0FBR3FrRCxVQUFVLENBQUN0bkQsQ0FBRCxDQUFuQyxlQUEyQ2tELE1BQU0sR0FBR29rRCxVQUFVLENBQUN0bkQsQ0FBRCxDQUE5RDtBQUFBLEtBRnJCLEVBR0V3TyxTQUhGLENBR1ksU0FIWixFQUlFN0wsSUFKRixDQUlPLFFBSlAsRUFJaUIsVUFBQTNDLENBQUM7QUFBQSxhQUFJaTlDLE1BQU0sQ0FBQ2o5QyxDQUFELENBQVY7QUFBQSxLQUpsQixDQXZEa0IsRUE4RGRtbkQsUUE5RGMsSUErRGpCQyxXQUFXLENBQUM1NEMsU0FBWixDQUFzQixNQUF0QixFQUNFN0wsSUFERixDQUNPLEdBRFAsRUFDWSxVQUFBM0MsQ0FBQztBQUFBLGFBQUtULFdBQVcsQ0FBQ1MsQ0FBRCxDQUFYLEdBQWlCaUQsS0FBakIsR0FBeUJnNkMsTUFBTSxDQUFDajlDLENBQUQsQ0FBTixDQUFVdUMsS0FBVixDQUFnQixHQUFoQixFQUFxQixDQUFyQixDQUE5QjtBQUFBLEtBRGIsRUFFRUksSUFGRixDQUVPLEdBRlAsRUFFWSxVQUFBM0MsQ0FBQztBQUFBLGFBQUtULFdBQVcsQ0FBQ1MsQ0FBRCxDQUFYLEdBQWlCa0QsTUFBakIsR0FBMEIsQ0FBL0I7QUFBQSxLQUZiLENBL0RpQjtBQW1FbEIsR0E5TDhCO0FBZ00vQjZqRCxpQkFoTStCLDZCQWdNYjtBQUNYLFFBQUFwMUMsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNBcEgsTUFEQSxHQUNTb0gsRUFBRSxDQUFDcEgsTUFEWjtBQUFBLDRCQUVrQm9ILEVBQUUsQ0FBQyswQyxZQUFILEVBRmxCO0FBQUE7QUFBQSxRQUVDempELEtBRkQ7QUFBQSxRQUVRQyxNQUZSO0FBQUEsUUFHQTJSLFVBSEEsR0FHYXRLLE1BQU0sQ0FBQzZpQixpQkFIcEI7QUFBQSxRQUtGenpCLElBTEUsR0FLS2dZLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVS9WLElBQVYsQ0FBZWhFLFNBQWYsQ0FBeUIsR0FBekIsRUFDVDlJLElBRFMsQ0FDSm1QLFVBREksQ0FMTDs7QUFRTmxiLFFBQUksQ0FBQ3NWLElBQUwsR0FBWUMsTUFBWixFQVRpQjtBQVdqQixRQUFNeTRDLFNBQVMsR0FBR2h1RCxJQUFJLENBQUM4VSxLQUFMLEdBQWEvTCxNQUFiLENBQW9CLEdBQXBCLEVBQ2hCQyxJQURnQixDQUNYLE9BRFcsRUFDRixVQUFDM0MsQ0FBRCxFQUFJeUMsQ0FBSjtBQUFBLHVCQUFhdUIsY0FBSyxDQUFDckssSUFBbkIsY0FBMkI4SSxDQUEzQjtBQUFBLEtBREUsQ0FBbEI7QUFHQThILFVBQU0sQ0FBQzh3QixvQkFBUCxJQUErQnNzQixTQUFTLENBQUNqbEQsTUFBVixDQUFpQixNQUFqQixDQWRkLEVBZWpCNkgsTUFBTSxDQUFDK3dCLG9CQUFQLElBQStCcXNCLFNBQVMsQ0FBQ2psRCxNQUFWLENBQWlCLE1BQWpCLENBZmQsRUFpQmpCL0ksSUFBSSxHQUFHZ3VELFNBQVMsQ0FBQ2o1QyxLQUFWLENBQWdCL1UsSUFBaEIsQ0FqQlUsRUFvQmI0USxNQUFNLENBQUM4d0Isb0JBcEJNLElBcUJoQjFoQyxJQUFJLENBQUNvSyxNQUFMLENBQVksTUFBWixFQUNFcEIsSUFERixDQUNPLElBRFAsRUFDYU0sS0FEYixFQUVFTixJQUZGLENBRU8sSUFGUCxFQUVhTyxNQUZiLEVBR0VQLElBSEYsQ0FHTyxJQUhQLEVBR2EsVUFBQzNDLENBQUQsRUFBSXlDLENBQUo7QUFBQSxhQUFVa1AsRUFBRSxDQUFDaTFDLGdCQUFILENBQW9CLEdBQXBCLEVBQXlCbmtELENBQXpCLENBQVY7QUFBQSxLQUhiLEVBSUVFLElBSkYsQ0FJTyxJQUpQLEVBSWEsVUFBQzNDLENBQUQsRUFBSXlDLENBQUo7QUFBQSxhQUFVa1AsRUFBRSxDQUFDaTFDLGdCQUFILENBQW9CLEdBQXBCLEVBQXlCbmtELENBQXpCLENBQVY7QUFBQSxLQUpiLENBckJnQixFQTZCYjhILE1BQU0sQ0FBQyt3QixvQkE3Qk0sSUE4QmhCM2hDLElBQUksQ0FBQ29LLE1BQUwsQ0FBWSxNQUFaLEVBQ0UrRCxLQURGLENBQ1EsYUFEUixFQUN1QixRQUR2QixFQUVFbkYsSUFGRixDQUVPLElBRlAsRUFFYSxNQUZiLEVBR0VkLElBSEYsQ0FHTyxVQUFBNEIsU0FBUyxFQUFJO0FBQ2xCQSxlQUFTLENBQUN3SyxJQUFWLENBQWUsVUFBU2pPLENBQVQsRUFBWTtBQUMxQmlDLG9CQUFZLENBQUNpTSxpR0FBUSxDQUFDLElBQUQsQ0FBVCxFQUFpQmxPLENBQWpCLEVBQW9CLENBQUMsQ0FBQyxHQUFGLEVBQU8sR0FBUCxDQUFwQixDQURjO0FBRTFCLE9BRkQsQ0FEa0I7QUFJbEIsS0FQRixFQVFFaXVDLEtBUkYsQ0FRUSxVQUFDanVDLENBQUQsRUFBSXlDLENBQUo7QUFBQSxhQUFXO0FBQUM2TSxhQUFLLEVBQUU3TTtBQUFSLE9BQVg7QUFBQSxLQVJSLEVBU0VFLElBVEYsQ0FTTyxXQVRQLEVBU29CLFVBQUMzQyxDQUFELEVBQUl5QyxDQUFKO0FBQUEsaUNBQXVCa1AsRUFBRSxDQUFDaTFDLGdCQUFILENBQW9CLEdBQXBCLEVBQXlCbmtELENBQXpCLEVBQTRCbUUsU0FBNUIsRUFBdUMsQ0FBdkMsQ0FBdkIsY0FBb0UrSyxFQUFFLENBQUNpMUMsZ0JBQUgsQ0FBb0IsR0FBcEIsRUFBeUJua0QsQ0FBekIsRUFBNEJtRSxTQUE1QixFQUF1QyxDQUF2QyxDQUFwRTtBQUFBLEtBVHBCLENBOUJnQixFQTBDakIrSyxFQUFFLENBQUNpMkMsU0FBSCxFQTFDaUI7QUEyQ2pCLEdBM084QjtBQTZPL0JBLFdBN08rQix1QkE2T25CO0FBQUE7QUFBQSxRQUNMajJDLEVBQUUsR0FBRyxJQURBO0FBQUEsUUFFTHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlA7O0FBSVgsUUFBSUEsTUFBTSxDQUFDMFYsbUJBQVgsRUFBZ0M7QUFBQSxVQUN6Qm83QixPQUFPLEdBQUcxcEMsRUFBRSxDQUFDME0sU0FBSCxLQUFpQixPQURGO0FBQUEsVUFFekJtd0IsUUFBUSxHQUFHLFlBQU07QUFDdEIsWUFBSTN3QyxNQUFNLEdBQUc4Rix3RkFBTyxDQUFDOUYsTUFBckIsQ0FEc0IsQ0FHdEI7O0FBQ0ksaUJBQVM4TixJQUFULENBQWM5TixNQUFNLENBQUMrMEMsT0FBckIsQ0FKa0IsS0FLckIvMEMsTUFBTSxHQUFHQSxNQUFNLENBQUNnMUMsVUFMSztBQVF0QixZQUFNN3lDLENBQUMsR0FBR2tPLGlHQUFRLENBQUNyUSxNQUFELENBQVIsQ0FBaUJvd0MsS0FBakIsRUFBVjtBQUVBLGVBQU9qdUMsQ0FBQyxJQUFJSyxNQUFNLENBQUNDLElBQVAsQ0FBWU4sQ0FBWixFQUFlRyxNQUFmLEtBQTBCLENBQS9CLEdBQW1DSCxDQUFDLENBQUNzUCxLQUFyQyxHQUE2QzFJLFNBQXBEO0FBQ0EsT0FiOEI7QUFBQSxVQWN6QmloRCxJQUFJLEdBQUcsWUFBTTtBQUFBLFlBQ1p2NEMsS0FBSyxHQUFHay9CLFFBQVEsRUFESjtBQUFBLFlBRVpzWixPQUFPLEdBQUd2b0QsV0FBVyxDQUFDK1AsS0FBRCxDQUZUO0FBQUEsU0FJZCtyQyxPQUFPLElBQUl5TSxPQUpHLE1BS2pCLEtBQUksQ0FBQ3RnQyxXQUFMLEVBTGlCLEVBTWpCLEtBQUksQ0FBQ2dwQixlQUFMLEVBTmlCLEVBUWI2SyxPQVJhLEdBU2hCMXBDLEVBQUUsQ0FBQ3EvQixVQUFILEtBQXFCMWhDLEtBQXJCLENBVGdCLEdBVU53NEMsT0FWTSxJQVdoQm4yQyxFQUFFLENBQUNnOUIsbUJBQUgsRUFYZ0I7QUFjbEIsT0E1QjhCOztBQThCL0JoOUIsUUFBRSxDQUFDNFcsTUFBSCxDQUFVeGtCLE1BQVYsWUFBcUJDLGNBQUssQ0FBQ3JLLElBQTNCLEdBQ0V3bUIsRUFERixDQUNLazdCLE9BQU8sR0FBRyxZQUFILEdBQWtCLFlBRDlCLEVBQzRDLFlBQU07QUFDaEQsYUFBSTFwQyxFQUFFLENBQUM0SixVQUFQLEVBQXFCO0FBQXJCO0FBSUEsZ0JBQU1qTSxLQUFLLEdBQUdrL0IsUUFBUSxFQUF0QjtBQUVBNzhCLGNBQUUsQ0FBQ2s5QixtQkFBSCxDQUF1Qmw5QixFQUFFLENBQUMwRyxHQUFILENBQU9uVyxJQUFQLEVBQXZCLEVBQXNDLElBQXRDLEVBQTRDb04sS0FBNUMsQ0FOQSxFQU9BK3JDLE9BQU8sR0FBRzFwQyxFQUFFLENBQUNxL0IsVUFBSCxLQUFvQjFoQyxLQUFwQixDQUFILEdBQWdDcUMsRUFBRSxDQUFDZzlCLG1CQUFILENBQXVCci9CLEtBQXZCLENBUHZDO0FBQUE7QUFRQSxPQVZGLEVBV0U2USxFQVhGLENBV0ssVUFYTCxFQVdpQms3QixPQUFPLEdBQUd3TSxJQUFILEdBQVUsSUFYbEMsQ0E5QitCLEVBMkMxQnhNLE9BM0MwQixJQTRDOUIxcEMsRUFBRSxDQUFDMEcsR0FBSCxDQUFPOEgsRUFBUCxDQUFVLFlBQVYsRUFBd0IwbkMsSUFBeEIsQ0E1QzhCO0FBOEMvQjtBQUNELEdBaFM4QjtBQWtTL0JiLGtCQWxTK0IsNEJBa1NkbnRDLFFBbFNjLEVBa1NKdU4sZUFsU0ksRUFrU2E7QUFBQSxRQUNyQ3pWLEVBQUUsR0FBRyxJQURnQztBQUFBLFFBRXJDOEQsT0FBTyxHQUFHOUQsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FGbUI7QUFBQSxRQUdyQ3duQyxNQUFNLEdBQUd0ckMsRUFBRSxDQUFDb3pCLFFBQUgsQ0FBWUYsY0FBWixDQUg0QjtBQUFBLFFBS3JDbnJDLEtBQUssR0FBR2lZLEVBQUUsQ0FBQzRXLE1BQUgsQ0FBVWhyQixNQUFWLENBQ1ppUixTQURZLENBQ0YsU0FERSxFQUVaOUksSUFGWSxDQUVQK1AsT0FGTyxDQUw2QjtBQUFBLFFBU3JDc3lDLFVBQVUsR0FBR3J1RCxLQUFLLENBQUMrVSxLQUFOLEdBQWMvTCxNQUFkLENBQXFCLEdBQXJCLEVBQ2pCQyxJQURpQixDQUNaLE9BRFksRUFDSGdQLEVBQUUsQ0FBQ3EyQyxlQUFILENBQW1CNzZDLElBQW5CLENBQXdCd0UsRUFBeEIsQ0FERyxDQVR3QjtBQVkzQ2pZLFNBQUssQ0FBQ3VWLElBQU4sR0FBYW5ELFVBQWIsR0FDRStOLFFBREYsQ0FDV3VOLGVBRFgsRUFFRWxZLE1BRkYsRUFaMkMsRUFnQjNDNjRDLFVBQVUsQ0FDUnJsRCxNQURGLENBQ1MsU0FEVCxFQUVFZ00sS0FGRixDQUVRaFYsS0FGUixFQUdFb1MsVUFIRixHQUlFK04sUUFKRixDQUlXQSxRQUpYLEVBS0UvUixLQUxGLENBS1EsTUFMUixFQUtnQixVQUFBOUgsQ0FBQztBQUFBLGFBQUkyUixFQUFFLENBQUM2SixLQUFILENBQVN4YixDQUFULENBQUo7QUFBQSxLQUxqQixFQU1FOEgsS0FORixDQU1RLFFBTlIsRUFNa0IsVUFBQTlILENBQUM7QUFBQSxhQUFJMlIsRUFBRSxDQUFDNkosS0FBSCxDQUFTeGIsQ0FBVCxDQUFKO0FBQUEsS0FObkIsRUFPRTJDLElBUEYsQ0FPTyxRQVBQLEVBT2lCLFVBQUEzQyxDQUFDO0FBQUEsYUFBSWk5QyxNQUFNLENBQUNqOUMsQ0FBQyxDQUFDZ1MsRUFBSCxDQUFOLENBQWF5MUMsSUFBYixDQUFrQixHQUFsQixDQUFKO0FBQUEsS0FQbEIsQ0FoQjJDO0FBd0IzQyxHQTFUOEI7O0FBNFQvQjs7Ozs7O0FBTUFyOEIsY0FsVStCLHdCQWtVbEJwckIsQ0FsVWtCLEVBa1VmO0FBQ2YsV0FBTyxLQUFLK2tDLFFBQUwsQ0FBY0YsY0FBZCxFQUF3QjdrQyxDQUFDLENBQUNnUyxFQUExQixFQUE4QmhTLENBQUMsQ0FBQ3NQLEtBQWhDLEVBQXVDLENBQXZDLENBQVA7QUFDQSxHQXBVOEI7O0FBc1UvQjs7Ozs7O0FBTUFrYyxjQTVVK0Isd0JBNFVsQnhyQixDQTVVa0IsRUE0VWY7QUFDZixXQUFPLEtBQUsra0MsUUFBTCxDQUFjRixjQUFkLEVBQXdCN2tDLENBQUMsQ0FBQ2dTLEVBQTFCLEVBQThCaFMsQ0FBQyxDQUFDc1AsS0FBaEMsRUFBdUMsQ0FBdkMsQ0FBUDtBQUNBO0FBOVU4QixDQUExQixDOztBQ2xDTjs7OztBQUlBO0FBSUE7QUFDQTtBQUNBO0FBRUFoTCxNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQjs7OztBQUlBNU4sVUFMK0Isc0JBS3BCO0FBQ1YsUUFBTXJSLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDekosS0FBekIsR0FBa0NtSSxNQUFsQyxDQUF5QyxHQUF6QyxFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnFCLGNBQUssQ0FBQ3pJLFVBRHRCLENBSFUsRUFNVm9XLEVBQUUsQ0FBQzJSLFFBQUgsR0FBYzlFLG9HQUFXLENBQUMsRUFBRCxDQU5mO0FBT1YsR0FaOEI7O0FBYy9COzs7OztBQUtBa0gsc0JBbkIrQixnQ0FtQlZqUSxPQW5CVSxFQW1CRDtBQUFBLFFBQ3ZCOUQsRUFBRSxHQUFHLElBRGtCO0FBQUEsUUFFdkJzMkMsY0FBYyxHQUFHdDJDLEVBQUUsQ0FBQ3MyQyxjQUFILENBQWtCOTZDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FGTTtBQUFBLFFBR3ZCdTJDLFVBQVUsR0FBR3YyQyxFQUFFLENBQUN1MkMsVUFBSCxDQUFjLzZDLElBQWQsQ0FBbUJ3RSxFQUFuQixDQUhVO0FBQUEsUUFJdkJtb0MsVUFBVSxHQUFHbm9DLEVBQUUsQ0FBQ21vQyxVQUFILENBQWMzc0MsSUFBZCxDQUFtQndFLEVBQW5CLENBSlU7QUFBQSxRQUt2QncyQyxjQUFjLEdBQUd4MkMsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUN6SSxVQUF6QixHQUF1Q2lULFNBQXZDLFlBQXFEeEssY0FBSyxDQUFDMUksU0FBM0QsR0FDckJvSyxJQURxQixDQUNoQitQLE9BRGdCLEVBRXJCOVMsSUFGcUIsQ0FFaEIsT0FGZ0IsRUFFUCxVQUFBM0MsQ0FBQztBQUFBLGFBQUlpb0QsY0FBYyxDQUFDam9ELENBQUQsQ0FBZCxHQUFvQjg1QyxVQUFVLENBQUM5NUMsQ0FBRCxDQUFsQztBQUFBLEtBRk0sQ0FMTTtBQUFBLFFBU3ZCb29ELGFBQWEsR0FBR0QsY0FBYyxDQUFDMTVDLEtBQWYsR0FBdUIvTCxNQUF2QixDQUE4QixHQUE5QixFQUNwQkMsSUFEb0IsQ0FDZixPQURlLEVBQ05zbEQsY0FETSxFQUVwQm5nRCxLQUZvQixDQUVkLFNBRmMsRUFFSCxHQUZHLEVBR3BCQSxLQUhvQixDQUdkLGdCQUhjLEVBR0ksTUFISixDQVRPO0FBYzdCc2dELGlCQUFhLENBQUMxbEQsTUFBZCxDQUFxQixHQUFyQixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnVsRCxVQURoQixDQWQ2QjtBQWdCN0IsR0FuQzhCOztBQXFDL0I7Ozs7O0FBS0E5L0IsWUExQytCLHNCQTBDcEJoQixlQTFDb0IsRUEwQ0g7QUFBQTtBQUFBLFFBQ3JCelYsRUFBRSxHQUFHLElBRGdCO0FBQUEsUUFFckJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZTO0FBQUEsUUFHckI4OUMsTUFBTSxHQUFHMTJDLEVBQUUsQ0FBQ3V4QyxZQUFILENBQWdCLzFDLElBQWhCLENBQXFCd0UsRUFBckIsQ0FIWTtBQUFBLFFBSXJCMjJDLFNBQVMsR0FBRzMyQyxFQUFFLENBQUMyMkMsU0FBSCxDQUFhbjdDLElBQWIsQ0FBa0J3RSxFQUFsQixDQUpTOztBQU0zQkEsTUFBRSxDQUFDMlIsUUFBSCxHQUFjM1IsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQ2pHLEtBQTVCLEdBQXFDeVEsU0FBckMsWUFBbUR4SyxjQUFLLENBQUNsRyxJQUF6RCxHQUNaNEgsSUFEWSxDQUNQLFVBQUExRixDQUFDO0FBQUEsYUFBSyxLQUFJLENBQUN1b0QsV0FBTCxDQUFpQnZvRCxDQUFqQixJQUFzQkEsQ0FBQyxDQUFDNlQsTUFBeEIsR0FBaUN3MEMsTUFBTSxDQUFDcm9ELENBQUQsQ0FBNUM7QUFBQSxLQURNLENBTmEsRUFTM0IyUixFQUFFLENBQUMyUixRQUFILENBQVlyVSxJQUFaLEdBQ0VuRCxVQURGLEdBRUUrTixRQUZGLENBRVd1TixlQUZYLEVBR0V0ZixLQUhGLENBR1EsY0FIUixFQUd3QixHQUh4QixFQUlFb0gsTUFKRixFQVQyQixFQWUzQnlDLEVBQUUsQ0FBQzJSLFFBQUgsR0FBYzNSLEVBQUUsQ0FBQzJSLFFBQUgsQ0FBWTdVLEtBQVosR0FDWi9MLE1BRFksQ0FDTCxNQURLLEVBRVpnTSxLQUZZLENBRU5pRCxFQUFFLENBQUMyUixRQUZHLEVBR1ozZ0IsSUFIWSxDQUdQLE9BSE8sRUFHRTJsRCxTQUhGLEVBSVozbEQsSUFKWSxDQUlQLGFBSk8sRUFJUSxVQUFBM0MsQ0FBQztBQUFBLGFBQUt1SyxNQUFNLENBQUN1SCxZQUFQLEdBQXVCOVIsQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBQVYsR0FBYyxLQUFkLEdBQXNCLE9BQTdDLEdBQXdELFFBQTdEO0FBQUEsS0FKVCxFQUtad0csS0FMWSxDQUtOLE1BTE0sRUFLRTZKLEVBQUUsQ0FBQzYyQyxlQUFILENBQW1CcjdDLElBQW5CLENBQXdCd0UsRUFBeEIsQ0FMRixFQU1aN0osS0FOWSxDQU1OLGNBTk0sRUFNVSxHQU5WLEVBT1poSyxJQVBZLENBT1AsVUFBQ2tDLENBQUQsRUFBSXlDLENBQUosRUFBT285QixDQUFQO0FBQUEsYUFBYWx1QixFQUFFLENBQUMyMUIsZUFBSCxDQUFtQnRuQyxDQUFDLENBQUNnUyxFQUFyQixFQUF5QmhTLENBQUMsQ0FBQ3NCLEtBQTNCLEVBQWtDdEIsQ0FBQyxDQUFDZ1MsRUFBcEMsRUFBd0N2UCxDQUF4QyxFQUEyQ285QixDQUEzQyxDQUFiO0FBQUEsS0FQTyxDQWZhO0FBdUIzQixHQWpFOEI7QUFtRS9CMm9CLGlCQW5FK0IsMkJBbUVmeG9ELENBbkVlLEVBbUVaO0FBQUEsUUFHZHdiLEtBSGM7QUFBQSxRQUNaN0osRUFBRSxHQUFHLElBRE87QUFBQSxRQUVaODJDLFdBQVcsR0FBRzkyQyxFQUFFLENBQUNwSCxNQUFILENBQVU0bkIsa0JBRlo7QUFXbEIsV0FOSTl5QixRQUFRLENBQUNvcEQsV0FBRCxDQU1aLEdBTENqdEMsS0FBSyxHQUFHaXRDLFdBS1QsR0FKVzVuRCxRQUFRLENBQUM0bkQsV0FBRCxDQUluQixLQUhDanRDLEtBQUssR0FBR2l0QyxXQUFXLENBQUN6b0QsQ0FBQyxDQUFDZ1MsRUFBSCxDQUdwQixHQUFPd0osS0FBSyxJQUFJN0osRUFBRSxDQUFDNkosS0FBSCxDQUFTeGIsQ0FBVCxDQUFoQjtBQUNBLEdBL0U4Qjs7QUFpRi9COzs7Ozs7OztBQVFBaXNCLFlBekYrQixzQkF5RnBCbHBCLENBekZvQixFQXlGakJDLENBekZpQixFQXlGZDBsRCxPQXpGYyxFQXlGTDN2QyxjQXpGSyxFQXlGVztBQUFBLFFBQ25DcEgsRUFBRSxHQUFHLElBRDhCO0FBQUEsUUFFbkNySyxDQUFDLEdBQUdwRCxTQUFTLEVBRnNCO0FBQUEsUUFHbkN5a0QsY0FBYyxHQUFHRCxPQUFPLEdBQUcsQ0FBSCxHQUFPLzJDLEVBQUUsQ0FBQ2czQyxjQUFILENBQWtCeDdDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FISTtBQUt6QyxXQUFPLENBQ04sS0FBSzJSLFFBQUwsQ0FBY3JWLElBQWQsQ0FBbUIsWUFBVztBQUM3QixVQUFNblEsSUFBSSxHQUFHb1EsaUdBQVEsQ0FBQyxJQUFELENBQXJCLENBRDZCLENBRzdCOztBQUNBLE9BQUM2SyxjQUFjLElBQUlqYixJQUFJLENBQUM2RSxJQUFMLENBQVUsR0FBVixDQUFsQixHQUFtQzdFLElBQUksQ0FBQ2dPLFVBQUwsQ0FBZ0J4RSxDQUFoQixDQUFuQyxHQUF3RHhKLElBQXpELEVBQ0U2RSxJQURGLENBQ08sR0FEUCxFQUNZSSxDQURaLEVBRUVKLElBRkYsQ0FFTyxHQUZQLEVBRVlLLENBRlosRUFHRThFLEtBSEYsQ0FHUSxNQUhSLEVBR2dCNkosRUFBRSxDQUFDNjJDLGVBQUgsQ0FBbUJyN0MsSUFBbkIsQ0FBd0J3RSxFQUF4QixDQUhoQixFQUlFN0osS0FKRixDQUlRLGNBSlIsRUFJd0I2Z0QsY0FKeEIsQ0FKNkI7QUFTN0IsS0FURCxDQURNLENBQVA7QUFZQSxHQTFHOEI7O0FBNEcvQjs7Ozs7OztBQU9BQyxhQW5IK0IsdUJBbUhuQmpxQyxPQW5IbUIsRUFtSFYxSyxTQW5IVSxFQW1IQztBQUFBLFFBQ3pCdEMsRUFBRSxHQUFHLElBRG9CO0FBQUEsUUFFM0JrM0MsSUFBSSxHQUFJbHFDLE9BQU8sQ0FBQ3pjLElBQVIsR0FBZXljLE9BQU8sQ0FBQ3pjLElBQVIsRUFBZixHQUFnQ3ljLE9BRmI7QUFJMUIsWUFBUWhULElBQVIsQ0FBYWs5QyxJQUFJLENBQUNqVyxPQUFsQixDQUowQixLQUs5QmlXLElBQUksR0FBR0EsSUFBSSxDQUFDQyxhQUFMLENBQW1CLE1BQW5CLENBTHVCO0FBQUEsUUFRekJockQsSUFBSSxHQUFHK3FELElBQUksQ0FBQ0UsV0FSYTtBQUFBLFFBU3pCbGtCLFFBQVEsY0FBTy9tQyxJQUFJLENBQUNrRSxPQUFMLENBQWEsS0FBYixFQUFvQixHQUFwQixDQUFQLENBVGlCO0FBQUEsUUFVM0IwdkMsSUFBSSxHQUFHLy9CLEVBQUUsQ0FBQ296QixRQUFILENBQVlGLFFBQVosQ0FWb0I7QUEwQi9CLFdBZEs2TSxJQWNMLEtBYkMvL0IsRUFBRSxDQUFDMEcsR0FBSCxDQUFPM1YsTUFBUCxDQUFjLE1BQWQsRUFDRW9GLEtBREYsQ0FDUSxZQURSLEVBQ3NCLFFBRHRCLEVBRUVBLEtBRkYsQ0FFUSxNQUZSLEVBRWdCb0csaUdBQVEsQ0FBQzI2QyxJQUFELENBQVIsQ0FBZS9nRCxLQUFmLENBQXFCLE1BQXJCLENBRmhCLEVBR0VnWCxPQUhGLENBR1U3SyxTQUhWLE1BSUVuVyxJQUpGLENBSU9BLElBSlAsRUFLRStELElBTEYsQ0FLTyxVQUFBMUMsQ0FBQyxFQUFJO0FBQ1Z1eUMsVUFBSSxHQUFHdnlDLENBQUMsQ0FBQytDLElBQUYsR0FBU2tCLHFCQUFULEVBREc7QUFFVixLQVBGLEVBUUU4TCxNQVJGLEVBYUQsRUFIQ3lDLEVBQUUsQ0FBQ3d6QixRQUFILENBQVlOLFFBQVosRUFBc0I2TSxJQUF0QixDQUdELEdBQU9BLElBQVA7QUFDQSxHQTlJOEI7O0FBZ0ovQjs7Ozs7OztBQU9Bem1CLG1CQXZKK0IsNkJBdUpiVCxPQXZKYSxFQXVKSncrQixJQXZKSSxFQXVKRTtBQUFBLFFBQzFCcjNDLEVBQUUsR0FBRyxJQURxQjtBQUFBLFFBRTFCMjdCLEtBQUssR0FBR2p0QyxNQUFNLENBQUNDLElBQVAsQ0FBWWtxQixPQUFaLENBRmtCO0FBQUEsUUFHMUJ5eUIsTUFBTSxHQUFHLEVBSGlCO0FBQUEsUUFJMUJnTSxNQUFNLEdBQUdELElBQUksR0FBR3IzQyxFQUFFLENBQUN1M0MsV0FBTixHQUFvQnYzQyxFQUFFLENBQUN3M0MsV0FKVjtBQVloQyxXQU5BeDNDLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxPQUFYLEtBQXVCK3RCLEtBQUssQ0FBQ3RtQyxJQUFOLENBQVcsT0FBWCxDQU12QixFQUpBc21DLEtBQUssQ0FBQzlyQyxPQUFOLENBQWMsVUFBQXJDLENBQUMsRUFBSTtBQUNsQjg5QyxZQUFNLENBQUM5OUMsQ0FBRCxDQUFOLEdBQVl3UyxFQUFFLHNCQUFlbE4sVUFBVSxDQUFDdEYsQ0FBRCxDQUF6QixZQUFGLENBQXdDcXJCLE9BQU8sQ0FBQ3JyQixDQUFELENBQS9DLEtBRE07QUFFbEIsS0FGRCxDQUlBLEVBQU8sVUFBU2EsQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQ3JCLFVBQU1pRSxJQUFJLEdBQUlpTCxFQUFFLENBQUNrWixVQUFILENBQWM3cUIsQ0FBZCxLQUFvQixNQUFyQixJQUNYMlIsRUFBRSxDQUFDOFcsU0FBSCxDQUFhem9CLENBQWIsS0FBbUIsS0FEUixJQUVYMlIsRUFBRSxDQUFDNDJDLFdBQUgsQ0FBZXZvRCxDQUFmLEtBQXFCLE9BRlYsSUFFc0IsTUFGbkM7QUFJQSxhQUFPaXBELE1BQU0sQ0FBQ3BuRCxJQUFQLENBQVk4UCxFQUFaLEVBQWdCc3JDLE1BQU0sQ0FBQ3YyQyxJQUFELENBQU4sQ0FBYTFHLENBQWIsRUFBZ0J5QyxDQUFoQixDQUFoQixFQUFvQ3pDLENBQXBDLEVBQXVDLElBQXZDLENBQVA7QUFDQSxLQU5EO0FBT0EsR0ExSzhCOztBQTRLL0I7Ozs7Ozs7O0FBUUFvcEQsb0JBcEwrQiw4QkFvTFpwcEQsQ0FwTFksRUFvTFRpOUMsTUFwTFMsRUFvTERvTSxXQXBMQyxFQW9MWTtBQUFBLFFBQ3BDMTNDLEVBQUUsR0FBRyxJQUQrQjtBQUFBLFFBRXBDcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGd0I7QUFBQSxRQUdwQ3NILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSGlCOztBQUsxQyxRQUFJdkgsTUFBTSxDQUFDd1ksV0FBUCxDQUFtQnVtQyxRQUFuQixJQUErQjMzQyxFQUFFLENBQUM4VyxTQUFILENBQWF6b0IsQ0FBYixDQUFuQyxFQUFvRDtBQUFBLFVBQzdDMHhDLElBQUksR0FBRzJYLFdBQVcsQ0FBQ2ptRCxxQkFBWixFQURzQztBQUFBLFVBRTdDbW1ELFVBQVUsR0FBR3ZwRCxDQUFDLENBQUNzQixLQUFGLElBQVcsQ0FGcUI7O0FBSW5ELFVBQUl1USxTQUFKLEVBQWU7QUFDZCxZQUFNN0YsQ0FBQyxHQUFHLENBQ1R1OUMsVUFBVSxHQUNUdE0sTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FETixHQUVUQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixJQUFlQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUhQLElBSU4sQ0FKTSxHQUlEdkwsSUFBSSxDQUFDenVDLEtBQUwsR0FBYSxDQUp0QjtBQU1BLGVBQU9zbUQsVUFBVSxHQUFHLENBQUN2OUMsQ0FBRCxHQUFLLENBQVIsR0FBWUEsQ0FBQyxHQUFHLENBQWpDO0FBQ0E7O0FBQ0EsVUFBTUMsQ0FBQyxHQUFHLENBQ1RzOUMsVUFBVSxHQUNUdE0sTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FETixHQUVUQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixJQUFlQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUhQLElBSU4sQ0FKTSxHQUlEdkwsSUFBSSxDQUFDeHVDLE1BQUwsR0FBYyxDQUp2QjtBQU1BLGFBQU9xbUQsVUFBVSxHQUFHdDlDLENBQUgsR0FBTyxDQUFDQSxDQUFELEdBQUssQ0FBN0I7QUFFRDs7QUFFRCxXQUFPLENBQVA7QUFDQSxHQWpOOEI7O0FBbU4vQjs7Ozs7Ozs7QUFRQWk5QyxhQTNOK0IsdUJBMk5uQmpNLE1BM05tQixFQTJOWGo5QyxDQTNOVyxFQTJOUnFwRCxXQTNOUSxFQTJOSztBQUFBLFFBSS9CbFYsSUFKK0I7QUFBQSxRQUsvQjk2QixPQUwrQjtBQUFBLFFBQzdCMUgsRUFBRSxHQUFHLElBRHdCO0FBQUEsUUFFN0JwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZpQjtBQUFBLFFBRzdCc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIVTtBQTBCbkMsV0FuQklELFNBbUJKLElBbEJDd0gsT0FBTyxHQUFHMUgsRUFBRSxDQUFDOFcsU0FBSCxDQUFhem9CLENBQWIsSUFBa0IsQ0FBbEIsR0FBc0IsQ0FrQmpDLEVBakJDbTBDLElBQUksR0FBRzhJLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLElBQWU1akMsT0FBTyxJQUFJclosQ0FBQyxDQUFDc0IsS0FBRixHQUFVLENBQVYsR0FBYyxDQUFDLENBQWYsR0FBbUIsQ0FBdkIsQ0FpQjlCLElBZkM2eUMsSUFBSSxHQUFHeGlDLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxLQUFYLElBQW9CLENBQUMwOUIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsSUFBZUEsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FBaEIsSUFBZ0MsQ0FBcEQsR0FBd0RBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLENBZWhFLEVBWklqOUMsQ0FBQyxDQUFDc0IsS0FBRixLQUFZLElBWWhCLEtBWEs2eUMsSUFBSSxHQUFHeGlDLEVBQUUsQ0FBQzFPLEtBV2YsR0FWRWt4QyxJQUFJLEdBQUd4aUMsRUFBRSxDQUFDMU8sS0FBSCxHQUFXb21ELFdBQVcsQ0FBQ2ptRCxxQkFBWixHQUFvQ0gsS0FVeEQsR0FUWWt4QyxJQUFJLEdBQUcsQ0FTbkIsS0FSRUEsSUFBSSxHQUFHLENBUVQsSUFKSXRpQyxTQUlKLEtBSENzaUMsSUFBSSxJQUFJeGlDLEVBQUUsQ0FBQ3kzQyxrQkFBSCxDQUFzQnBwRCxDQUF0QixFQUF5Qmk5QyxNQUF6QixFQUFpQ29NLFdBQWpDLENBR1QsR0FBT2xWLElBQUksSUFBSTVwQyxNQUFNLENBQUM2bkIsb0JBQVAsQ0FBNEJydkIsQ0FBNUIsSUFBaUMsQ0FBckMsQ0FBWDtBQUNBLEdBdFA4Qjs7QUF3UC9COzs7Ozs7OztBQVFBb21ELGFBaFErQix1QkFnUW5CbE0sTUFoUW1CLEVBZ1FYajlDLENBaFFXLEVBZ1FScXBELFdBaFFRLEVBZ1FLO0FBQUEsUUFPL0JHLElBUCtCO0FBQUEsUUFDN0I3M0MsRUFBRSxHQUFHLElBRHdCO0FBQUEsUUFFN0JwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZpQjtBQUFBLFFBRzdCc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIVTtBQUFBLFFBSTdCdkIsQ0FBQyxHQUFHaEcsTUFBTSxDQUFDd3RCLE9BSmtCO0FBQUEsUUFLN0IyWixJQUFJLEdBQUcyWCxXQUFXLENBQUNqbUQscUJBQVosRUFMc0I7QUFBQSxRQU0vQnFtRCxLQUFLLEdBQUcsQ0FOdUI7QUFTbkMsUUFBSTUzQyxTQUFKLEVBQ0MyM0MsSUFBSSxHQUFHLENBQUN2TSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixJQUFlQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixDQUFmLEdBQThCdkwsSUFBSSxDQUFDeHVDLE1BQUwsR0FBYyxFQUE3QyxJQUFvRCxDQUQ1RCxNQVNDLElBTkFzbUQsSUFBSSxHQUFHdk0sTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsQ0FNUCxFQUpJMzlDLFFBQVEsQ0FBQ2lSLENBQUQsQ0FBUixJQUFlQSxDQUFDLEdBQUcsQ0FBbkIsS0FBeUJvQixFQUFFLENBQUNnWixVQUFILENBQWMzcUIsQ0FBZCxLQUFvQjJSLEVBQUUsQ0FBQ3diLGFBQUgsQ0FBaUJudEIsQ0FBakIsQ0FBN0MsQ0FJSixLQUhDeXBELEtBQUssSUFBSWwvQyxNQUFNLENBQUN3dEIsT0FBUCxHQUFpQixHQUczQixHQUFJLzNCLENBQUMsQ0FBQ3NCLEtBQUYsR0FBVSxDQUFWLElBQWdCdEIsQ0FBQyxDQUFDc0IsS0FBRixLQUFZLENBQVosSUFBaUIsQ0FBQ3FRLEVBQUUsQ0FBQ3U3QixnQkFBekMsRUFDQ3NjLElBQUksSUFBSTlYLElBQUksQ0FBQ3h1QyxNQURkLEVBR0t5TyxFQUFFLENBQUM4VyxTQUFILENBQWF6b0IsQ0FBYixDQUhMLEdBSUV3cEQsSUFBSSxJQUFJQyxLQUpWLEdBS1ksQ0FBQzkzQyxFQUFFLENBQUM4VyxTQUFILENBQWF6b0IsQ0FBYixDQUxiLEtBTUV3cEQsSUFBSSxJQUFJQyxLQU5WLE9BUU87QUFDTixVQUFJcm5ELElBQUksR0FBRyxDQUFDcW5ELEtBQUQsR0FBUyxDQUFwQjtBQUVJOTNDLFFBQUUsQ0FBQzhXLFNBQUgsQ0FBYXpvQixDQUFiLENBSEUsR0FJTG9DLElBQUksR0FBRyxDQUFDcW5ELEtBSkgsR0FLSzkzQyxFQUFFLENBQUN1YixZQUFILENBQWdCbHRCLENBQWhCLENBTEwsS0FNTG9DLElBQUksR0FBR3FuRCxLQU5GLEdBU05ELElBQUksSUFBSXBuRCxJQVRGO0FBVU4sS0FwQ2lDLENBdUNuQzs7QUFDQSxRQUFJcEMsQ0FBQyxDQUFDc0IsS0FBRixLQUFZLElBQVosSUFBb0IsQ0FBQ3VRLFNBQXpCLEVBQW9DO0FBQ25DLFVBQU02M0MsU0FBUyxHQUFHaFksSUFBSSxDQUFDeHVDLE1BQXZCO0FBRUlzbUQsVUFBSSxHQUFHRSxTQUh3QixHQUlsQ0YsSUFBSSxHQUFHRSxTQUoyQixHQUt4QkYsSUFBSSxHQUFHLEtBQUt0bUQsTUFMWSxLQU1sQ3NtRCxJQUFJLEdBQUcsS0FBS3RtRCxNQUFMLEdBQWMsQ0FOYTtBQVFuQzs7QUFNRCxXQUpLMk8sU0FJTCxLQUhDMjNDLElBQUksSUFBSTczQyxFQUFFLENBQUN5M0Msa0JBQUgsQ0FBc0JwcEQsQ0FBdEIsRUFBeUJpOUMsTUFBekIsRUFBaUNvTSxXQUFqQyxDQUdULEdBQU9HLElBQUksSUFBSWovQyxNQUFNLENBQUM2bkIsb0JBQVAsQ0FBNEJwdkIsQ0FBNUIsSUFBaUMsQ0FBckMsQ0FBWDtBQUNBO0FBdlQ4QixDQUExQixDOztBQ1pOOzs7O0FBSUE7Q0FHQTs7QUFDQSxJQUFNMm1ELEtBQUssR0FBRztBQUNiQyxNQUFJLEVBQUUsQ0FBQyxNQUFELEVBQVMsYUFBVCxFQUF3QixtQkFBeEIsRUFBNkMsaUJBQTdDLEVBQWdFLFdBQWhFLENBRE87QUFFYkMsV0FBUyxFQUFFLENBQUMsbUJBQUQsRUFBc0IsaUJBQXRCLENBRkU7QUFHYkMsS0FBRyxFQUFFLENBQUMsS0FBRCxFQUFRLE9BQVIsRUFBaUIsT0FBakIsRUFBMEIsT0FBMUIsQ0FIUTtBQUliQyxNQUFJLEVBQUUsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixNQUFuQixFQUEyQixhQUEzQixFQUEwQyxtQkFBMUMsRUFBK0QsaUJBQS9ELEVBQWtGLE1BQWxGLEVBQTBGLFdBQTFGLENBSk87QUFLYkMsTUFBSSxFQUFFLENBQUMsTUFBRCxFQUFTLFdBQVQsQ0FMTztBQU1iQyxRQUFNLEVBQUUsQ0FBQyxRQUFELEVBQVcsYUFBWCxFQUEwQixtQkFBMUI7QUFOSyxDQUFkO0FBU0EzbEQsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0J1YyxlQUQrQix5QkFDakJuSCxTQURpQixFQUNOdC9CLElBRE0sRUFDQTtBQUFBLFFBQ3hCaUwsRUFBRSxHQUFHLElBRG1CO0FBQUEsUUFFeEJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZZO0FBSTlCb0gsTUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JJLFNBQWxCLEVBQTZCeGtDLE9BQTdCLENBQXFDLFVBQUF3USxFQUFFLEVBQUk7QUFDMUNMLFFBQUUsQ0FBQ3lNLGFBQUgsQ0FBaUJwTSxFQUFqQixJQUF3QnRMLElBQUksS0FBSzZELE1BQU0sQ0FBQzJuQixVQUFQLENBQWtCbGdCLEVBQWxCLENBRFMsRUFFMUN6SCxNQUFNLENBQUMybkIsVUFBUCxDQUFrQmxnQixFQUFsQixJQUF3QnRMLElBRmtCO0FBRzFDLEtBSEQsQ0FKOEIsRUFTekJzL0IsU0FUeUIsS0FVN0J6N0IsTUFBTSxDQUFDMG5CLFNBQVAsR0FBbUJ2ckIsSUFWVTtBQVk5QixHQWI4QjtBQWUvQjZZLFNBZitCLG1CQWV2QjdZLElBZnVCLEVBZWpCbWdDLFlBZmlCLEVBZUg7QUFBQSxRQUNyQmwxQixFQUFFLEdBQUcsSUFEZ0I7QUFBQSxRQUVyQjI3QixLQUFLLEdBQUczN0IsRUFBRSxDQUFDcEgsTUFBSCxDQUFVMm5CLFVBRkc7QUFBQSxRQUdyQnpjLE9BQU8sR0FBR294QixZQUFZLElBQUlsMUIsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FIYjtBQUFBLFFBSXZCbUIsR0FBRyxLQUpvQjtBQXdCM0IsV0FsQkluQixPQUFPLElBQUlBLE9BQU8sQ0FBQ3RWLE1Ba0J2QixHQWpCQ3NWLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQTNELE1BQU0sRUFBSTtBQUN6QixVQUFNeUosQ0FBQyxHQUFHZ21DLEtBQUssQ0FBQ3p2QyxNQUFNLENBQUNtVSxFQUFSLENBQWY7QUFEeUIsT0FHcEIxSyxDQUFDLElBQUlBLENBQUMsQ0FBQ2hPLE9BQUYsQ0FBVW9OLElBQVYsS0FBbUIsQ0FBekIsSUFBZ0MsQ0FBQ1ksQ0FBRCxJQUFNWixJQUFJLEtBQUssTUFIMUIsTUFJeEJrUSxHQUFHLEtBSnFCO0FBTXpCLEtBTkQsQ0FpQkQsR0FWV3ZXLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZZ3RDLEtBQVosRUFBbUJudEMsTUFVOUIsR0FUQ0UsTUFBTSxDQUFDQyxJQUFQLENBQVlndEMsS0FBWixFQUFtQjlyQyxPQUFuQixDQUEyQixVQUFBd1EsRUFBRSxFQUFJO0FBQzVCczdCLFdBQUssQ0FBQ3Q3QixFQUFELENBQUwsS0FBY3RMLElBRGMsS0FFL0JrUSxHQUFHLEtBRjRCO0FBSWhDLEtBSkQsQ0FTRCxHQUhDQSxHQUFHLEdBQUdqRixFQUFFLENBQUNwSCxNQUFILENBQVUwbkIsU0FBVixLQUF3QnZyQixJQUcvQixFQUFPa1EsR0FBUDtBQUNBLEdBeEM4Qjs7QUEwQy9COzs7Ozs7OztBQVFBNlQsV0FsRCtCLHFCQWtEckIvakIsSUFsRHFCLEVBa0RmK08sT0FsRGUsRUFrRFE7QUFBQTtBQUFBLFFBQWR5MEMsT0FBYyx1RUFBSixFQUFJOztBQUN0QyxXQUFPLENBQUNQLEtBQUssQ0FBQ2pqRCxJQUFELENBQUwsQ0FDTmYsTUFETSxDQUNDLFVBQUF4RyxDQUFDO0FBQUEsYUFBSStxRCxPQUFPLENBQUM1d0QsT0FBUixDQUFnQjZGLENBQWhCLE1BQXVCLENBQUMsQ0FBNUI7QUFBQSxLQURGLEVBRU5tSCxLQUZNLENBRUEsVUFBQW5ILENBQUM7QUFBQSxhQUFJLENBQUMsS0FBSSxDQUFDb2dCLE9BQUwsQ0FBYXBnQixDQUFiLEVBQWdCc1csT0FBaEIsQ0FBTDtBQUFBLEtBRkQsQ0FBUjtBQUdBLEdBdEQ4Qjs7QUF3RC9COzs7Ozs7O0FBT0EwMEMsVUEvRCtCLG9CQStEdEJucUQsQ0EvRHNCLEVBK0RuQjBHLElBL0RtQixFQStEYjtBQUFBLFFBQ1hzTCxFQUFFLEdBQUczUyxRQUFRLENBQUNXLENBQUQsQ0FBUixHQUFjQSxDQUFkLEdBQWtCQSxDQUFDLENBQUNnUyxFQURkO0FBQUEsUUFFWG80QyxRQUFRLEdBQUcsS0FBSzcvQyxNQUFMLENBQVkybkIsVUFBWixDQUF1QmxnQixFQUF2QixDQUZBO0FBSWpCLFdBQU92UixPQUFPLENBQUNpRyxJQUFELENBQVAsR0FDTkEsSUFBSSxDQUFDcE4sT0FBTCxDQUFhOHdELFFBQWIsS0FBMEIsQ0FEcEIsR0FDd0JBLFFBQVEsS0FBSzFqRCxJQUQ1QztBQUVBLEdBckU4Qjs7QUF1RS9COzs7Ozs7O0FBT0FpZCxZQTlFK0Isc0JBOEVwQmxPLE9BOUVvQixFQThFWHkwQyxPQTlFVyxFQThFRjtBQUM1QixXQUFPLEtBQUt6L0IsU0FBTCxDQUFlLEtBQWYsRUFBc0JoVixPQUF0QixFQUErQnkwQyxPQUEvQixDQUFQO0FBQ0EsR0FoRjhCO0FBa0YvQnYvQixZQWxGK0Isc0JBa0ZwQjNxQixDQWxGb0IsRUFrRmpCO0FBQ2IsUUFBTWdTLEVBQUUsR0FBRzNTLFFBQVEsQ0FBQ1csQ0FBRCxDQUFSLEdBQWNBLENBQWQsR0FBa0JBLENBQUMsQ0FBQ2dTLEVBQS9CO0FBRUEsV0FBTyxDQUFDLEtBQUt6SCxNQUFMLENBQVkybkIsVUFBWixDQUF1QmxnQixFQUF2QixDQUFELElBQ04sS0FBS200QyxRQUFMLENBQWNuNEMsRUFBZCxFQUFrQjIzQyxLQUFLLENBQUNJLElBQXhCLENBREQ7QUFFQSxHQXZGOEI7QUF5Ri9CblksWUF6RitCLHNCQXlGcEI1eEMsQ0F6Rm9CLEVBeUZqQjtBQUNiLFdBQU8sS0FBS21xRCxRQUFMLENBQWNucUQsQ0FBZCxFQUFpQjJwRCxLQUFLLENBQUNLLElBQXZCLENBQVA7QUFDQSxHQTNGOEI7QUE2Ri9CMVQsY0E3RitCLHdCQTZGbEJ0MkMsQ0E3RmtCLEVBNkZmO0FBQ2YsV0FBTyxLQUFLbXFELFFBQUwsQ0FBY25xRCxDQUFkLEVBQWlCMnBELEtBQUssQ0FBQ00sTUFBdkIsQ0FBUDtBQUNBLEdBL0Y4QjtBQWlHL0JwL0IsWUFqRytCLHNCQWlHcEI3cUIsQ0FqR29CLEVBaUdqQjtBQUNiLFdBQU8sS0FBS21xRCxRQUFMLENBQWNucUQsQ0FBZCxFQUFpQjJwRCxLQUFLLENBQUNDLElBQXZCLENBQVA7QUFDQSxHQW5HOEI7QUFxRy9CbGxCLGlCQXJHK0IsMkJBcUdmMWtDLENBckdlLEVBcUdaO0FBQ2xCLFdBQU8sS0FBS21xRCxRQUFMLENBQWNucUQsQ0FBZCxFQUFpQjJwRCxLQUFLLENBQUNFLFNBQXZCLENBQVA7QUFDQSxHQXZHOEI7QUF5Ry9CcGhDLFdBekcrQixxQkF5R3JCem9CLENBekdxQixFQXlHbEI7QUFDWixXQUFPLEtBQUttcUQsUUFBTCxDQUFjbnFELENBQWQsRUFBaUIsS0FBakIsQ0FBUDtBQUNBLEdBM0c4QjtBQTZHL0JrdEIsY0E3RytCLHdCQTZHbEJsdEIsQ0E3R2tCLEVBNkdmO0FBQ2YsV0FBTyxLQUFLbXFELFFBQUwsQ0FBY25xRCxDQUFkLEVBQWlCLFFBQWpCLENBQVA7QUFDQSxHQS9HOEI7QUFpSC9CbXRCLGVBakgrQix5QkFpSGpCbnRCLENBakhpQixFQWlIZDtBQUNoQixXQUFPLEtBQUttcUQsUUFBTCxDQUFjbnFELENBQWQsRUFBaUIsU0FBakIsQ0FBUDtBQUNBLEdBbkg4QjtBQXFIL0J3NUMsV0FySCtCLHFCQXFIckJ4NUMsQ0FySHFCLEVBcUhsQjtBQUNaLFdBQU8sS0FBS21xRCxRQUFMLENBQWNucUQsQ0FBZCxFQUFpQixLQUFqQixDQUFQO0FBQ0EsR0F2SDhCO0FBeUgvQnEzQyxhQXpIK0IsdUJBeUhuQnIzQyxDQXpIbUIsRUF5SGhCO0FBQ2QsV0FBTyxLQUFLbXFELFFBQUwsQ0FBY25xRCxDQUFkLEVBQWlCLE9BQWpCLENBQVA7QUFDQSxHQTNIOEI7QUE2SC9CdTVDLGFBN0grQix1QkE2SG5CdjVDLENBN0htQixFQTZIaEI7QUFDZCxXQUFPLEtBQUttcUQsUUFBTCxDQUFjbnFELENBQWQsRUFBaUIsT0FBakIsQ0FBUDtBQUNBLEdBL0g4QjtBQWlJL0J1b0QsYUFqSStCLHVCQWlJbkJ2b0QsQ0FqSW1CLEVBaUloQjtBQUNkLFdBQU8sS0FBS21xRCxRQUFMLENBQWNucUQsQ0FBZCxFQUFpQixPQUFqQixDQUFQO0FBQ0EsR0FuSThCO0FBcUkvQms0QyxXQXJJK0IscUJBcUlyQmw0QyxDQXJJcUIsRUFxSWxCO0FBQ1osV0FBTyxLQUFLdzVDLFNBQUwsQ0FBZXg1QyxDQUFmLEtBQ04sS0FBS3U1QyxXQUFMLENBQWlCdjVDLENBQWpCLENBRE0sSUFFTixLQUFLcTNDLFdBQUwsQ0FBaUJyM0MsQ0FBakIsQ0FGTSxJQUdOLEtBQUt1b0QsV0FBTCxDQUFpQnZvRCxDQUFqQixDQUhEO0FBSUEsR0ExSThCO0FBNEkvQjtBQUNBd2pELGVBN0krQiwyQkE2SWY7QUFBQSxRQUNUajVDLE1BQU0sR0FBRyxLQUFLQSxNQURMO0FBQUEsUUFFVDQ2QyxPQUFPLEdBQUc1NkMsTUFBTSxDQUFDNHRCLGFBRlI7QUFJZixXQUFPNXRCLE1BQU0sQ0FBQzh0QixVQUFQLEtBQXNCLFFBQXRCLEtBQ0wsQ0FBQzhzQixPQUFELElBQWExa0QsT0FBTyxDQUFDMGtELE9BQUQsQ0FBUCxJQUFvQkEsT0FBTyxDQUFDaGxELE1BQVIsS0FBbUIsQ0FEL0MsQ0FBUDtBQUVBLEdBbko4QjtBQXFKL0IwK0MsVUFySitCLG9CQXFKdEI3K0MsQ0FySnNCLEVBcUpuQjtBQUNYLFdBQU8sS0FBSzJxQixVQUFMLENBQWdCM3FCLENBQWhCLElBQXFCLENBQUNBLENBQUQsQ0FBckIsR0FBMkIsRUFBbEM7QUFDQSxHQXZKOEI7QUF5Si9CcTZDLFNBekorQixtQkF5SnZCcjZDLENBekp1QixFQXlKcEI7QUFDVixXQUFPLEtBQUtrNEMsU0FBTCxDQUFlbDRDLENBQUMsQ0FBQzBGLElBQWpCLElBQXlCLENBQUMxRixDQUFELENBQXpCLEdBQStCLEVBQXRDO0FBQ0EsR0EzSjhCO0FBNkovQmk4QyxTQTdKK0IsbUJBNkp2Qmo4QyxDQTdKdUIsRUE2SnBCO0FBQ1YsV0FBTyxLQUFLeW9CLFNBQUwsQ0FBZXpvQixDQUFmLElBQW9CQSxDQUFDLENBQUM2VCxNQUF0QixHQUErQixFQUF0QztBQUNBLEdBL0o4Qjs7QUFpSy9COzs7Ozs7QUFNQXF2QyxjQXZLK0Isd0JBdUtsQmxqRCxDQXZLa0IsRUF1S2Y7QUFDZixXQUFPLEtBQUt5b0IsU0FBTCxDQUFlem9CLENBQWYsS0FDTixLQUFLMnFCLFVBQUwsQ0FBZ0IzcUIsQ0FBaEIsQ0FETSxJQUVOLEtBQUttdEIsYUFBTCxDQUFtQm50QixDQUFuQixDQUZNLElBR04sS0FBS2t0QixZQUFMLENBQWtCbHRCLENBQWxCLENBSE0sSUFJTixLQUFLdW9ELFdBQUwsQ0FBaUJ2b0QsQ0FBakIsQ0FKTSxHQUlnQkEsQ0FBQyxDQUFDNlQsTUFKbEIsR0FJMkIsRUFKbEM7QUFLQSxHQTdLOEI7QUErSy9CdzJDLG1CQS9LK0IsNkJBK0ticnFELENBL0thLEVBK0tWO0FBQ3BCLFdBQU8sS0FBS3lvQixTQUFMLENBQWV6b0IsQ0FBZixLQUFxQixLQUFLMnFCLFVBQUwsQ0FBZ0IzcUIsQ0FBaEIsQ0FBckIsSUFBMkMsS0FBS2t0QixZQUFMLENBQWtCbHRCLENBQWxCLENBQTNDLEdBQ05BLENBQUMsQ0FBQzZULE1BREksR0FDSyxFQURaO0FBRUEsR0FsTDhCO0FBb0wvQjtBQUNBd2lDLHFCQXJMK0IsK0JBcUxYM3ZDLElBckxXLEVBcUxMO0FBQ3pCLFdBQU8sQ0FDTixPQURNLEVBRU4sY0FGTSxFQUdOLFlBSE0sRUFJTixRQUpNLEVBS04sVUFMTSxFQU1OLGlCQU5NLEVBT04sZUFQTSxFQVFOLGFBUk0sRUFTTixvQkFUTSxFQVVOLGtCQVZNLEVBV04sUUFYTSxFQVlOLGVBWk0sRUFhTixZQWJNLEVBY04sWUFkTSxFQWVOLFNBZk0sRUFnQkxwTixPQWhCSyxDQWdCR29OLElBaEJILEtBZ0JZLENBaEJuQjtBQWlCQTtBQXZNOEIsQ0FBMUIsQzs7QUNqQk47Ozs7QUFJQTtBQUlBO0FBQ0E7Q0FHQTs7SUFDTTRqRCxpQkFBaUIsR0FBRyxVQUFBdHFELENBQUM7QUFBQSxTQUFJZCxPQUFPLENBQUNjLENBQUMsQ0FBQzJXLFFBQUgsQ0FBUCxJQUF1QixLQUEzQjtBQUFBLEM7SUFDckI0ekMsYUFBYSxHQUFHLFVBQUF2cUQsQ0FBQztBQUFBLFNBQUtBLENBQUMsQ0FBQzJXLFFBQUYsS0FBZSxPQUFmLEdBQXlCLENBQXpCLEdBQThCM1csQ0FBQyxDQUFDMlcsUUFBRixLQUFlLFFBQWYsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBQyxDQUFsRTtBQUFBLEM7SUFDakI2ekMsWUFBWSxHQUFHLFVBQUM5bkIsR0FBRCxFQUFNei9CLEtBQU4sRUFBYUMsTUFBYjtBQUFBLFNBQXdCLFVBQUFsRCxDQUFDLEVBQUk7QUFDakQsUUFBSStDLENBQUMsR0FBRzIvQixHQUFHLEdBQUcsQ0FBSCxHQUFPei9CLEtBQWxCO0FBUUEsV0FOSWpELENBQUMsQ0FBQzJXLFFBQUYsS0FBZSxPQU1uQixHQUxDNVQsQ0FBQyxHQUFHMi9CLEdBQUcsR0FBRyxDQUFDeC9CLE1BQUosR0FBYSxDQUtyQixHQUpXbEQsQ0FBQyxDQUFDMlcsUUFBRixLQUFlLFFBSTFCLEtBSEM1VCxDQUFDLEdBQUcsQ0FBQzIvQixHQUFHLEdBQUcsQ0FBQ3gvQixNQUFKLEdBQWFELEtBQWpCLElBQTBCLENBRy9CLEdBQU9GLENBQVA7QUFDQSxHQVZvQjtBQUFBLEM7O0FBWXJCdUIsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I3TyxVQUQrQixzQkFDcEI7QUFDVixRQUFNcFEsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDdlQsS0FBSCxHQUFXb2dCLG9HQUFXLENBQUMsRUFBRCxDQUhaLEVBS1Y3TSxFQUFFLENBQUM4NEMsYUFBSCxFQUxVLEVBTVY5NEMsRUFBRSxDQUFDKzRDLGVBQUgsRUFOVTtBQU9WLEdBUjhCO0FBVS9CRCxlQVYrQiwyQkFVZjtBQUFBLFFBQ1Q5NEMsRUFBRSxHQUFHLElBREk7QUFBQSxRQUVUcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSDtBQUFBLEtBSVhBLE1BQU0sQ0FBQ21oQixZQUFQLENBQW9CdnJCLE1BQXBCLElBQThCb0ssTUFBTSxDQUFDb2hCLFlBQVAsQ0FBb0J4ckIsTUFKdkMsTUFLZHdSLEVBQUUsQ0FBQ3JWLFNBQUgsR0FBZXFWLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUW1MLE1BQVIsQ0FBZSxHQUFmLGFBQXdCL0ssY0FBSyxDQUFDekosS0FBOUIsU0FBc0NnUSxNQUFNLENBQUN1dEIsZ0JBQVAsR0FBMEIsTUFBMUIsR0FBbUMsRUFBekUsR0FDYm4xQixJQURhLENBQ1IsV0FEUSxFQUNLZ1AsRUFBRSxDQUFDZzVDLGVBRFIsRUFFYmhvRCxJQUZhLENBRVIsT0FGUSxZQUVJcUIsY0FBSyxDQUFDM0gsSUFGVixjQUVrQjJILGNBQUssQ0FBQzFILFNBRnhCLEVBTEQsRUFTZHFWLEVBQUUsQ0FBQ3JWLFNBQUgsQ0FBYW9HLE1BQWIsQ0FBb0IsR0FBcEIsRUFBeUJDLElBQXpCLENBQThCLE9BQTlCLEVBQXVDcUIsY0FBSyxDQUFDekYsVUFBN0MsQ0FUYyxFQVVkb1QsRUFBRSxDQUFDclYsU0FBSCxDQUFhb0csTUFBYixDQUFvQixHQUFwQixFQUF5QkMsSUFBekIsQ0FBOEIsT0FBOUIsRUFBdUNxQixjQUFLLENBQUNyRixVQUE3QyxDQVZjLEVBWWRnVCxFQUFFLENBQUNwVCxVQUFILEdBQWdCaWdCLG9HQUFXLENBQUMsRUFBRCxDQVpiO0FBY2YsR0F4QjhCO0FBMEIvQm9zQyxhQTFCK0IsdUJBMEJuQi9TLGFBMUJtQixFQTBCSjtBQUFBLFFBQ3BCbG1DLEVBQUUsR0FBRyxJQURlO0FBQUEsUUFFcEJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZRO0FBQUEsUUFHcEJzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhDO0FBQUEsUUFJcEIrNEMsU0FBUyxHQUFHbDVDLEVBQUUsQ0FBQ201QyxnQkFBSCxDQUFvQnZnRCxNQUFNLENBQUNrdEIsV0FBM0IsRUFBd0M5bEIsRUFBRSxDQUFDNU8sQ0FBM0MsQ0FKUTtBQUFBLFFBS3BCa0ksVUFBVSxHQUFHMEcsRUFBRSxDQUFDeUMsYUFBSCxLQUFxQnpDLEVBQUUsQ0FBQ3VDLEtBQUgsQ0FBU2pKLFVBQVQsRUFBckIsR0FBNkMsQ0FMdEM7QUFBQSxRQU1wQmlGLEdBQUcsR0FBRyxVQUFBbFEsQ0FBQztBQUFBLGFBQUksQ0FBQyxDQUFDMlIsRUFBRSxDQUFDbUQsU0FBSCxJQUFnQm5ELEVBQUUsQ0FBQzVPLENBQXBCLEVBQXVCL0MsQ0FBdkIsSUFBNEJpTCxVQUE3QixLQUE0QzRHLFNBQVMsR0FBRyxDQUFDLENBQUosR0FBUSxDQUE3RCxDQUFKO0FBQUEsS0FOYTs7QUFRMUJGLE1BQUUsQ0FBQ281QyxTQUFILEdBQWVsNUMsU0FBUyxHQUFHO0FBQzFCLFlBQU0sQ0FEb0I7QUFFMUIsWUFBTUYsRUFBRSxDQUFDMU8sS0FGaUI7QUFHMUIsWUFBTWlOLEdBSG9CO0FBSTFCLFlBQU1BO0FBSm9CLEtBQUgsR0FLcEI7QUFDSCxZQUFNQSxHQURIO0FBRUgsWUFBTUEsR0FGSDtBQUdILFlBQU0sQ0FISDtBQUlILFlBQU15QixFQUFFLENBQUN6TztBQUpOLEtBYnNCLEVBb0IxQnlPLEVBQUUsQ0FBQ3ZULEtBQUgsR0FBV3VULEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDeEYsTUFBekIsR0FDVGdRLFNBRFMsWUFDS3hLLGNBQUssQ0FBQzVGLEtBRFgsR0FFVHNILElBRlMsQ0FFSm1sRCxTQUZJLENBcEJlLEVBd0IxQmw1QyxFQUFFLENBQUN2VCxLQUFILENBQVM2USxJQUFULEdBQWdCQyxNQUFoQixFQXhCMEIsRUEwQjFCeUMsRUFBRSxDQUFDdlQsS0FBSCxHQUFXdVQsRUFBRSxDQUFDdlQsS0FBSCxDQUFTcVEsS0FBVCxHQUNUL0wsTUFEUyxDQUNGLE1BREUsRUFFVEMsSUFGUyxDQUVKLE9BRkksRUFFS3FCLGNBQUssQ0FBQzVGLEtBRlgsRUFHVHNRLEtBSFMsQ0FHSGlELEVBQUUsQ0FBQ3ZULEtBSEEsQ0ExQmUsRUErQnJCeTVDLGFBL0JxQixJQWdDekJsbUMsRUFBRSxDQUFDdlQsS0FBSCxDQUFTNlAsSUFBVCxDQUFjLFlBQVc7QUFDeEIsVUFBTTVSLElBQUksR0FBRzZSLGlHQUFRLENBQUMsSUFBRCxDQUFyQjtBQUVBN04sWUFBTSxDQUFDQyxJQUFQLENBQVlxUixFQUFFLENBQUNvNUMsU0FBZixFQUEwQnZwRCxPQUExQixDQUFrQyxVQUFBd1EsRUFBRSxFQUFJO0FBQ3ZDM1YsWUFBSSxDQUFDc0csSUFBTCxDQUFVcVAsRUFBVixFQUFjTCxFQUFFLENBQUNvNUMsU0FBSCxDQUFhLzRDLEVBQWIsQ0FBZCxFQUNFbEssS0FERixDQUNRLFNBRFIsRUFDbUI7QUFBQSxpQkFDakJ6TCxJQUFJLENBQUNzRyxJQUFMLENBQVVrUCxTQUFTLEdBQUcsSUFBSCxHQUFVLElBQTdCLE9BQXdDQSxTQUFTLEdBQUdGLEVBQUUsQ0FBQ3pPLE1BQU4sR0FBZSxDQUFoRSxJQUNDLEdBREQsR0FDTyxHQUZVO0FBQUEsU0FEbkIsQ0FEdUM7QUFNdkMsT0FORCxDQUh3QjtBQVV4QixLQVZELENBaEN5QjtBQTRDMUIsR0F0RThCO0FBd0UvQjhuRCxhQXhFK0IseUJBd0VqQjtBQUFBLFFBQ1ByNUMsRUFBRSxHQUFHLElBREU7QUFBQSxRQUVQcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGTDtBQUFBLFFBR1BzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhaO0FBQUEsUUFJUG01QyxVQUFVLEdBQUd0NUMsRUFBRSxDQUFDMmIsS0FBSCxDQUFTMWdCLFVBQVQsTUFBeUIrRSxFQUFFLENBQUMzTyxDQUFILENBQUtvSSxLQUFMLENBQVdiLE1BQU0sQ0FBQ290QixZQUFsQixDQUovQjtBQUFBLFFBS1B6bkIsR0FBRyxHQUFHLFVBQUFsUSxDQUFDO0FBQUEsYUFBSUwsSUFBSSxDQUFDQyxJQUFMLENBQVUrUixFQUFFLENBQUMzTyxDQUFILENBQUtoRCxDQUFMLENBQVYsQ0FBSjtBQUFBLEtBTEE7O0FBT2IyUixNQUFFLENBQUNsVCxLQUFILEdBQVdrVCxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3BGLE1BQXpCLEdBQ1Q0UCxTQURTLFlBQ0t4SyxjQUFLLENBQUN2RixLQURYLEdBRVRpSCxJQUZTLENBRUp1bEQsVUFGSSxDQVBFLEVBV2J0NUMsRUFBRSxDQUFDbFQsS0FBSCxDQUFTd1EsSUFBVCxHQUFnQkMsTUFBaEIsRUFYYSxFQWFieUMsRUFBRSxDQUFDbFQsS0FBSCxHQUFXa1QsRUFBRSxDQUFDbFQsS0FBSCxDQUNUZ1EsS0FEUyxHQUVUL0wsTUFGUyxDQUVGLE1BRkUsRUFHVEMsSUFIUyxDQUdKLE9BSEksRUFHS3FCLGNBQUssQ0FBQ3ZGLEtBSFgsRUFJVGlRLEtBSlMsQ0FJSGlELEVBQUUsQ0FBQ2xULEtBSkEsQ0FiRSxFQW1CYmtULEVBQUUsQ0FBQ2xULEtBQUgsQ0FBU2tFLElBQVQsQ0FBYyxJQUFkLEVBQW9Ca1AsU0FBUyxHQUFHM0IsR0FBSCxHQUFTLENBQXRDLEVBQ0V2TixJQURGLENBQ08sSUFEUCxFQUNha1AsU0FBUyxHQUFHM0IsR0FBSCxHQUFTeUIsRUFBRSxDQUFDMU8sS0FEbEMsRUFFRU4sSUFGRixDQUVPLElBRlAsRUFFYWtQLFNBQVMsR0FBRyxDQUFILEdBQU8zQixHQUY3QixFQUdFdk4sSUFIRixDQUdPLElBSFAsRUFHYWtQLFNBQVMsR0FBR0YsRUFBRSxDQUFDek8sTUFBTixHQUFlZ04sR0FIckMsQ0FuQmEsRUF3QmJ5QixFQUFFLENBQUN1NUMsV0FBSCxDQUFldjVDLEVBQUUsQ0FBQ2xULEtBQWxCLEVBQXlCLE1BQXpCLENBeEJhO0FBeUJiLEdBakc4QjtBQW1HL0JvcEIsWUFuRytCLHNCQW1HcEJoTyxRQW5Hb0IsRUFtR1Y7QUFDcEIsUUFBTWxJLEVBQUUsR0FBRyxJQUFYO0FBSUE7QUFGQ0EsTUFBRSxDQUFDclYsU0FBSixJQUFpQnFWLEVBQUUsQ0FBQzg0QyxhQUFILEVBSEcsRUFNcEI5NEMsRUFBRSxDQUFDdFYsSUFBSCxDQUFReUwsS0FBUixDQUFjLFlBQWQsRUFBNEI2SixFQUFFLENBQUNnUyxVQUFILEtBQWtCLFFBQWxCLEdBQTZCLFNBQXpELENBTm9CLEVBUXBCaFMsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLGdCQUF1QkMsY0FBSyxDQUFDM0YsVUFBN0IsR0FDRXlKLEtBREYsQ0FDUSxZQURSLEVBQ3NCLFFBRHRCLENBUm9CLEVBV3BCNkosRUFBRSxDQUFDdzVDLGdCQUFILENBQW9CdHhDLFFBQXBCLENBWG9CLEVBWXBCbEksRUFBRSxDQUFDeTVDLGdCQUFILENBQW9CdnhDLFFBQXBCLENBWm9CO0FBYXBCLEdBaEg4Qjs7QUFrSC9COzs7OztBQUtBc3hDLGtCQXZIK0IsNEJBdUhkdHhDLFFBdkhjLEVBdUhKO0FBQUEsUUFDcEJsSSxFQUFFLEdBQUcsSUFEZTtBQUFBLFFBRXBCL04sSUFBSSxHQUFHK04sRUFBRSxDQUFDL04sSUFGVTtBQUFBLFFBR3BCMkcsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFIUTtBQUFBLFFBSXBCc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFKQztBQU0xQnZILFVBQU0sQ0FBQ2l0QixXQUFQLElBQXNCN2xCLEVBQUUsQ0FBQ2k1QyxXQUFILEVBTkksRUFRMUJqNUMsRUFBRSxDQUFDcFQsVUFBSCxHQUFnQnFGLElBQUksQ0FBQ0csTUFBTCxZQUFnQkMsY0FBSyxDQUFDekYsVUFBdEIsR0FDZGlRLFNBRGMsWUFDQXhLLGNBQUssQ0FBQzFGLFNBRE4sR0FFZG9ILElBRmMsQ0FFVDZFLE1BQU0sQ0FBQ21oQixZQUZFLENBUlUsRUFhMUIvWixFQUFFLENBQUNwVCxVQUFILENBQWMwUSxJQUFkLEdBQXFCbkQsVUFBckIsR0FDRStOLFFBREYsQ0FDV0EsUUFEWCxFQUVFL1IsS0FGRixDQUVRLFNBRlIsRUFFbUIsR0FGbkIsRUFHRW9ILE1BSEYsRUFiMEI7QUFrQjFCO0FBQ0EsUUFBTTVRLFNBQVMsR0FBR3FULEVBQUUsQ0FBQ3BULFVBQUgsQ0FBY2tRLEtBQWQsR0FBc0IvTCxNQUF0QixDQUE2QixHQUE3QixDQUFsQjtBQUVBcEUsYUFBUyxDQUFDb0UsTUFBVixDQUFpQixNQUFqQixFQUNFb0YsS0FERixDQUNRLFNBRFIsRUFDbUIsR0FEbkIsQ0FyQjBCLEVBd0IxQnhKLFNBQVMsQ0FBQ29FLE1BQVYsQ0FBaUIsTUFBakIsRUFDRUMsSUFERixDQUNPLFdBRFAsRUFDb0JrUCxTQUFTLEdBQUcsRUFBSCxHQUFRLGFBRHJDLEVBRUVsUCxJQUZGLENBRU8sSUFGUCxFQUVhLENBQUMsQ0FGZCxFQUdFbUYsS0FIRixDQUdRLFNBSFIsRUFHbUIsR0FIbkIsQ0F4QjBCLEVBNkIxQjZKLEVBQUUsQ0FBQ3BULFVBQUgsR0FBZ0JELFNBQVMsQ0FBQ29RLEtBQVYsQ0FBZ0JpRCxFQUFFLENBQUNwVCxVQUFuQixDQTdCVSxFQStCMUJvVCxFQUFFLENBQUNwVCxVQUFILENBQ0VvRSxJQURGLENBQ08sT0FEUCxFQUNnQixVQUFBM0MsQ0FBQztBQUFBLGFBQUksVUFBR2dFLGNBQUssQ0FBQzFGLFNBQVQsY0FBc0IwQixDQUFDLFNBQUQsSUFBVyxFQUFqQyxFQUFzQ3FyRCxJQUF0QyxFQUFKO0FBQUEsS0FEakIsRUFFRXRuRCxNQUZGLENBRVMsTUFGVCxFQUdFcEIsSUFIRixDQUdPLGFBSFAsRUFHc0IybkQsaUJBSHRCLEVBSUUzbkQsSUFKRixDQUlPLElBSlAsRUFJYTRuRCxhQUpiLEVBS0V6K0MsVUFMRixHQU1FK04sUUFORixDQU1XQSxRQU5YLEVBT0UvYixJQVBGLENBT08sVUFBQWtDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNsQyxJQUFOO0FBQUEsS0FQUixFQVFFZ08sVUFSRixHQVNFaEUsS0FURixDQVNRLFNBVFIsRUFTbUIsR0FUbkIsQ0EvQjBCO0FBeUMxQixHQWhLOEI7O0FBa0svQjs7Ozs7QUFLQXNqRCxrQkF2SytCLDRCQXVLZHZ4QyxRQXZLYyxFQXVLSjtBQUFBLFFBQ3BCbEksRUFBRSxHQUFHLElBRGU7QUFBQSxRQUVwQi9OLElBQUksR0FBRytOLEVBQUUsQ0FBQy9OLElBRlU7QUFBQSxRQUdwQjJHLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BSFE7QUFBQSxRQUlwQnNILFNBQVMsR0FBR3RILE1BQU0sQ0FBQ3VILFlBSkM7QUFNMUJ2SCxVQUFNLENBQUNtdEIsV0FBUCxJQUFzQi9sQixFQUFFLENBQUNxNUMsV0FBSCxFQU5JLEVBUTFCcjVDLEVBQUUsQ0FBQ2hULFVBQUgsR0FBZ0JpRixJQUFJLENBQUNHLE1BQUwsWUFBZ0JDLGNBQUssQ0FBQ3JGLFVBQXRCLEdBQ2Q2UCxTQURjLFlBQ0F4SyxjQUFLLENBQUN0RixTQUROLEdBRWRnSCxJQUZjLENBRVQ2RSxNQUFNLENBQUNvaEIsWUFGRSxDQVJVLEVBYTFCaGEsRUFBRSxDQUFDaFQsVUFBSCxDQUFjc1EsSUFBZCxHQUNFbkQsVUFERixHQUVFK04sUUFGRixDQUVXQSxRQUZYLEVBR0UvUixLQUhGLENBR1EsU0FIUixFQUdtQixHQUhuQixFQUlFb0gsTUFKRixFQWIwQjtBQW1CMUI7QUFDQSxRQUFNeFEsU0FBUyxHQUFHaVQsRUFBRSxDQUFDaFQsVUFBSCxDQUFjOFAsS0FBZCxHQUFzQi9MLE1BQXRCLENBQTZCLEdBQTdCLENBQWxCO0FBRUFoRSxhQUFTLENBQUNnRSxNQUFWLENBQWlCLE1BQWpCLEVBQ0VvRixLQURGLENBQ1EsU0FEUixFQUNtQixHQURuQixDQXRCMEIsRUF5QjFCcEosU0FBUyxDQUFDZ0UsTUFBVixDQUFpQixNQUFqQixFQUNFQyxJQURGLENBQ08sV0FEUCxFQUNvQmtQLFNBQVMsR0FBRyxhQUFILEdBQW1CLEVBRGhELEVBRUUvSixLQUZGLENBRVEsU0FGUixFQUVtQixHQUZuQixDQXpCMEIsRUE2QjFCNkosRUFBRSxDQUFDaFQsVUFBSCxHQUFnQkQsU0FBUyxDQUFDZ1EsS0FBVixDQUFnQmlELEVBQUUsQ0FBQ2hULFVBQW5CLENBN0JVO0FBK0IxQjtBQUNBLFFBQU0yc0QsRUFBRSxHQUFHMzVDLEVBQUUsQ0FBQzI1QyxFQUFILENBQU1uK0MsSUFBTixDQUFXd0UsRUFBWCxDQUFYO0FBRUFBLE1BQUUsQ0FBQ2hULFVBQUgsQ0FDRWdFLElBREYsQ0FDTyxPQURQLEVBQ2dCLFVBQUEzQyxDQUFDO0FBQUEsYUFBSSxVQUFHZ0UsY0FBSyxDQUFDdEYsU0FBVCxjQUFzQnNCLENBQUMsU0FBRCxJQUFXLEVBQWpDLEVBQXNDcXJELElBQXRDLEVBQUo7QUFBQSxLQURqQixFQUVFdG5ELE1BRkYsQ0FFUyxNQUZULEVBR0UrSCxVQUhGLEdBSUUrTixRQUpGLENBSVdBLFFBSlgsRUFLRWxYLElBTEYsQ0FLTyxJQUxQLEVBS2FrUCxTQUFTLEdBQUd5NUMsRUFBSCxHQUFRLENBTDlCLEVBTUUzb0QsSUFORixDQU1PLElBTlAsRUFNYWtQLFNBQVMsR0FBR3k1QyxFQUFILEdBQVEzNUMsRUFBRSxDQUFDMU8sS0FOakMsRUFPRU4sSUFQRixDQU9PLElBUFAsRUFPYWtQLFNBQVMsR0FBRyxDQUFILEdBQU95NUMsRUFQN0IsRUFRRTNvRCxJQVJGLENBUU8sSUFSUCxFQVFha1AsU0FBUyxHQUFHRixFQUFFLENBQUN6TyxNQUFOLEdBQWVvb0QsRUFSckMsRUFTRXgvQyxVQVRGLEdBVUVoRSxLQVZGLENBVVEsU0FWUixFQVVtQixHQVZuQixDQWxDMEIsRUE4QzFCNkosRUFBRSxDQUFDaFQsVUFBSCxDQUFjb0YsTUFBZCxDQUFxQixNQUFyQixFQUNFcEIsSUFERixDQUNPLGFBRFAsRUFDc0IybkQsaUJBRHRCLEVBRUUzbkQsSUFGRixDQUVPLElBRlAsRUFFYTRuRCxhQUZiLEVBR0V6K0MsVUFIRixHQUlFK04sUUFKRixDQUlXQSxRQUpYLEVBS0VsWCxJQUxGLENBS08sSUFMUCxFQUthLENBQUMsQ0FMZCxFQU1FQSxJQU5GLENBTU8sR0FOUCxFQU1ZNm5ELFlBQVksQ0FBQzM0QyxTQUFELEVBQVlGLEVBQUUsQ0FBQzFPLEtBQWYsRUFBc0IwTyxFQUFFLENBQUN6TyxNQUF6QixDQU54QixFQU9FUCxJQVBGLENBT08sR0FQUCxFQU9ZMm9ELEVBUFosRUFRRXh0RCxJQVJGLENBUU8sVUFBQWtDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNsQyxJQUFOO0FBQUEsS0FSUixFQVNFZ08sVUFURixHQVVFaEUsS0FWRixDQVVRLFNBVlIsRUFVbUIsR0FWbkIsQ0E5QzBCO0FBeUQxQixHQWhPOEI7QUFrTy9COGpCLFlBbE8rQixzQkFrT3BCN1MsY0FsT29CLEVBa09KO0FBQUEsUUFDcEJwSCxFQUFFLEdBQUcsSUFEZTtBQUFBLFFBRXBCRSxTQUFTLEdBQUdGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBRkY7QUFBQSxRQUdwQjRYLEVBQUUsR0FBRy9YLEVBQUUsQ0FBQytYLEVBQUgsQ0FBTXZjLElBQU4sQ0FBV3dFLEVBQVgsQ0FIZTtBQUFBLFFBS3RCMVUsS0FBSyxHQUFHMFUsRUFBRSxDQUFDcFQsVUFBSCxDQUFjd0YsTUFBZCxDQUFxQixNQUFyQixDQUxjO0FBQUEsUUFNdEJoRyxLQUFLLEdBQUc0VCxFQUFFLENBQUNwVCxVQUFILENBQWN3RixNQUFkLENBQXFCLE1BQXJCLENBTmM7QUFtQjFCLFdBWEE5RyxLQUFLLEdBQUcsQ0FBQzhiLGNBQWMsR0FBRzliLEtBQUssQ0FBQzZPLFVBQU4sRUFBSCxHQUF3QjdPLEtBQXZDLEVBQ04wRixJQURNLENBQ0QsSUFEQyxFQUNLa1AsU0FBUyxHQUFHLENBQUgsR0FBTzZYLEVBRHJCLEVBRU4vbUIsSUFGTSxDQUVELElBRkMsRUFFS2tQLFNBQVMsR0FBR0YsRUFBRSxDQUFDMU8sS0FBTixHQUFjeW1CLEVBRjVCLEVBR04vbUIsSUFITSxDQUdELElBSEMsRUFHS2tQLFNBQVMsR0FBRzZYLEVBQUgsR0FBUSxDQUh0QixFQUlOL21CLElBSk0sQ0FJRCxJQUpDLEVBSUtrUCxTQUFTLEdBQUc2WCxFQUFILEdBQVEvWCxFQUFFLENBQUN6TyxNQUp6QixDQVdSLEVBTEFuRixLQUFLLEdBQUcsQ0FBQ2diLGNBQWMsR0FBR2hiLEtBQUssQ0FBQytOLFVBQU4sRUFBSCxHQUF3Qi9OLEtBQXZDLEVBQ040RSxJQURNLENBQ0QsR0FEQyxFQUNJNm5ELFlBQVksQ0FBQyxDQUFDMzRDLFNBQUYsRUFBYUYsRUFBRSxDQUFDMU8sS0FBaEIsRUFBdUIwTyxFQUFFLENBQUN6TyxNQUExQixDQURoQixFQUVOUCxJQUZNLENBRUQsR0FGQyxFQUVJK21CLEVBRkosRUFHTjVyQixJQUhNLENBR0QsVUFBQWtDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNsQyxJQUFOO0FBQUEsS0FIQSxDQUtSLEVBQU8sQ0FDTixDQUFDaWIsY0FBYyxHQUFHOWIsS0FBSyxDQUFDNk8sVUFBTixFQUFILEdBQXdCN08sS0FBdkMsRUFBOEM2SyxLQUE5QyxDQUFvRCxTQUFwRCxFQUErRCxHQUEvRCxDQURNLEVBRU4sQ0FBQ2lSLGNBQWMsR0FBR2hiLEtBQUssQ0FBQytOLFVBQU4sRUFBSCxHQUF3Qi9OLEtBQXZDLEVBQThDK0osS0FBOUMsQ0FBb0QsU0FBcEQsRUFBK0QsR0FBL0QsQ0FGTSxDQUFQO0FBSUEsR0F6UDhCO0FBMlAvQjRpRCxpQkEzUCtCLDZCQTJQYjtBQUFBLFFBQ1gvNEMsRUFBRSxHQUFHLElBRE07QUFBQSxRQUVYcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGRDtBQUFBLFFBR1hnaEQsT0FBTyxHQUFHaGhELE1BQU0sQ0FBQ3N0QixVQUhOO0FBQUEsUUFJWDVqQixTQUFTLGNBQU9qUSxjQUFLLENBQUN1bkQsT0FBTyxJQUFJNTVDLEVBQUUsQ0FBQ3JWLFNBQWQsR0FBMEIsV0FBMUIsR0FBd0MsT0FBekMsQ0FBWixTQUFnRWl2RCxPQUFPLEdBQUcsTUFBSCxHQUFZLEVBQW5GLENBSkU7QUFNakI1NUMsTUFBRSxDQUFDdFYsSUFBSCxHQUFVc1YsRUFBRSxDQUFDL04sSUFBSCxDQUFRbUwsTUFBUixDQUFlLEdBQWYsRUFBb0JrRixTQUFwQixFQUNSdFIsSUFEUSxDQUNILFdBREcsRUFDVWdQLEVBQUUsQ0FBQ2c1QyxlQURiLEVBRVJob0QsSUFGUSxDQUVILE9BRkcsRUFFTXFCLGNBQUssQ0FBQzNILElBRlosQ0FOTyxFQVVqQmtPLE1BQU0sQ0FBQ2l0QixXQUFQLElBQ0M3bEIsRUFBRSxDQUFDdFYsSUFBSCxDQUFRcUcsTUFBUixDQUFlLEdBQWYsRUFBb0JDLElBQXBCLENBQXlCLE9BQXpCLEVBQWtDcUIsY0FBSyxDQUFDeEYsTUFBeEMsQ0FYZ0IsRUFhakIrTCxNQUFNLENBQUNtdEIsV0FBUCxJQUNDL2xCLEVBQUUsQ0FBQ3RWLElBQUgsQ0FBUXFHLE1BQVIsQ0FBZSxHQUFmLEVBQW9CQyxJQUFwQixDQUF5QixPQUF6QixFQUFrQ3FCLGNBQUssQ0FBQ3BGLE1BQXhDLENBZGdCLEVBZ0JiMkwsTUFBTSxDQUFDcXRCLGVBaEJNLElBaUJoQmptQixFQUFFLENBQUN0VixJQUFILENBQVFxRyxNQUFSLENBQWUsR0FBZixFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnFCLGNBQUssQ0FBQzNGLFVBRHRCLEVBRUVxRSxNQUZGLENBRVMsTUFGVCxFQUdFQyxJQUhGLENBR08sT0FIUCxFQUdnQnFCLGNBQUssQ0FBQzNGLFVBSHRCLENBakJnQjtBQXNCakIsR0FqUjhCO0FBbVIvQjh4QyxnQkFuUitCLDBCQW1SaEJGLFlBblJnQixFQW1SRjtBQUFBLFFBQ3RCdCtCLEVBQUUsR0FBRyxJQURpQjtBQUFBLFFBRXRCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVTtBQUFBLFFBR3RCc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFIRztBQUFBLFFBSXRCMDVDLFVBQVUsR0FBR3ZiLFlBQVksQ0FBQ3RxQyxNQUFiLENBQW9CLFVBQUEzRixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxJQUFJZCxPQUFPLENBQUN5UyxFQUFFLENBQUNvYixZQUFILENBQWdCL3NCLENBQWhCLENBQUQsQ0FBaEI7QUFBQSxLQUFyQixDQUpTO0FBQUEsUUFLdEJ5ckQsT0FBTyxHQUFHOTVDLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsZ0JBQTBCeEssY0FBSyxDQUFDM0YsVUFBaEMsRUFMWTtBQUFBLFFBTXRCNGhELEVBQUUsR0FBR3R1QyxFQUFFLENBQUNzdUMsRUFBSCxDQUFNOXlDLElBQU4sQ0FBV3dFLEVBQVgsQ0FOaUI7QUFReEIsS0FBQ3BILE1BQU0sQ0FBQ3N4QixZQVJnQixJQWF4QmxxQixFQUFFLENBQUM0TixPQUFILENBQVcsUUFBWCxLQUF3QjVOLEVBQUUsQ0FBQzROLE9BQUgsQ0FBVyxTQUFYLENBQXhCLElBQWlENU4sRUFBRSxDQUFDZ1MsVUFBSCxFQWJ6QixLQWlCNUI4bkMsT0FBTyxDQUNMM2pELEtBREYsQ0FDUSxZQURSLEVBQ3NCLFNBRHRCLEVBRUVwQyxJQUZGLENBRU8sQ0FBQzhsRCxVQUFVLENBQUMsQ0FBRCxDQUFYLENBRlAsRUFHRTdvRCxJQUhGLENBR09rUCxTQUFTLEdBQUcsSUFBSCxHQUFVLElBSDFCLEVBR2dDb3VDLEVBSGhDLEVBSUV0OUMsSUFKRixDQUlPa1AsU0FBUyxHQUFHLElBQUgsR0FBVSxJQUoxQixFQUlnQ291QyxFQUpoQyxDQWpCNEIsRUF1QjVCdHVDLEVBQUUsQ0FBQ3U1QyxXQUFILENBQWVPLE9BQWYsRUFBd0IsTUFBeEIsQ0F2QjRCLEdBWTVCO0FBWUEsR0EzUzhCO0FBNlMvQnJiLGdCQTdTK0IsNEJBNlNkO0FBQ2hCLFNBQUt4c0MsSUFBTCxDQUFVRyxNQUFWLGdCQUF5QkMsY0FBSyxDQUFDM0YsVUFBL0IsR0FBNkN5SixLQUE3QyxDQUFtRCxZQUFuRCxFQUFpRSxRQUFqRSxDQURnQjtBQUVoQixHQS9TOEI7QUFpVC9COGYsa0JBalQrQiw4QkFpVFo7QUFBQSxRQUNaalcsRUFBRSxHQUFHLElBRE87QUFBQSxRQUVaRSxTQUFTLEdBQUdGLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBRlY7QUFJbEJILE1BQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixnQkFBdUJDLGNBQUssQ0FBQzNGLFVBQTdCLEdBQ0VzRSxJQURGLENBQ08sSUFEUCxFQUNha1AsU0FBUyxHQUFHLENBQUgsR0FBTyxDQUFDLEVBRDlCLEVBRUVsUCxJQUZGLENBRU8sSUFGUCxFQUVha1AsU0FBUyxHQUFHRixFQUFFLENBQUMxTyxLQUFOLEdBQWMsQ0FBQyxFQUZyQyxFQUdFTixJQUhGLENBR08sSUFIUCxFQUdha1AsU0FBUyxHQUFHLENBQUMsRUFBSixHQUFTLENBSC9CLEVBSUVsUCxJQUpGLENBSU8sSUFKUCxFQUlha1AsU0FBUyxHQUFHLENBQUMsRUFBSixHQUFTRixFQUFFLENBQUN6TyxNQUpsQyxDQUprQjtBQVNsQixHQTFUOEI7QUE0VC9CNG5ELGtCQTVUK0IsNEJBNFRkcGtELElBNVRjLEVBNFRSOEQsS0E1VFEsRUE0VEQ7QUFBQSxRQUN2Qm1ILEVBQUUsR0FBRyxJQURrQjtBQUFBLFFBRXZCKzVDLE9BQU8sR0FBRy81QyxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3BLLEtBQXpCLEdBQ2Q0VSxTQURjLENBQ0osT0FESSxFQUVkekMsSUFGYyxFQUZhO0FBQUEsUUFLekI0L0MsUUFBUSxHQUFHLEVBTGM7O0FBTzdCLFFBQUlqbEQsSUFBSSxLQUFLLE1BQWIsRUFBcUI7QUFBQSxVQUNkaTRCLE9BQU8sR0FBR2h0QixFQUFFLENBQUNnTyxVQUFILEVBREk7QUFBQSxVQUVkaXNDLFNBQVMsR0FBR2p0QixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdrdEIsV0FBWCxFQUZFO0FBQUEsVUFHZEMsUUFBUSxHQUFHbnRCLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV2t0QixXQUFYLEVBSEc7O0FBS3BCLFdBQUssSUFBSXBwRCxDQUFDLEdBQUdtcEQsU0FBYixFQUF3Qm5wRCxDQUFDLElBQUlxcEQsUUFBN0IsRUFBdUNycEQsQ0FBQyxFQUF4QyxFQUNDa3BELFFBQVEsQ0FBQzNrRCxJQUFULENBQWMsSUFBSTVHLElBQUosV0FBWXFDLENBQVoscUJBQWQsQ0FERDtBQUdBLEtBUkQsTUFTQ2twRCxRQUFRLEdBQUduaEQsS0FBSyxDQUFDWSxLQUFOLENBQVksRUFBWixDQVRaLEVBV0t1Z0QsUUFBUSxDQUFDeHJELE1BQVQsR0FBa0J1ckQsT0FYdkIsS0FZRUMsUUFBUSxHQUFHQSxRQUFRLENBQUNobUQsTUFBVCxDQUFnQixVQUFBM0YsQ0FBQztBQUFBLGFBQUksQ0FBT0EsQ0FBUCxPQUFVMUcsT0FBVixDQUFrQixHQUFsQixJQUF5QixDQUE3QjtBQUFBLEtBQWpCLENBWmI7O0FBZ0JBLFdBQU9xeUQsUUFBUDtBQUNBLEdBcFY4QjtBQXNWL0JJLHVCQXRWK0IsaUNBc1ZUaGpELE1BdFZTLEVBc1ZEO0FBQzdCLFdBQU9BLE1BQU0sR0FBRyxVQUFBL0wsSUFBSSxFQUFJO0FBQ3ZCLFVBQUl1RSxLQUFLLEtBQVQ7QUFRQSxhQU5BLENBQUNkLE9BQU8sQ0FBQ3NJLE1BQUQsQ0FBUCxHQUFrQkEsTUFBTSxDQUFDNUQsTUFBUCxFQUFsQixHQUFvQyxDQUFDNEQsTUFBRCxDQUFyQyxFQUErQ3ZILE9BQS9DLENBQXVELFVBQUF3cUQsS0FBSyxFQUFJO0FBQUEsU0FDekQsV0FBV0EsS0FBWCxJQUFvQmh2RCxJQUFJLENBQUNzRSxLQUFMLEtBQWUwcUQsS0FBSyxDQUFDMXFELEtBQTFDLElBQXFELFdBQVcwcUQsS0FBWCxJQUFvQmh2RCxJQUFJLFNBQUosS0FBZWd2RCxLQUFLLFNBRG5DLE1BRTlEenFELEtBQUssS0FGeUQ7QUFJL0QsT0FKRCxDQU1BLEVBQU9BLEtBQVA7QUFDQSxLQVZZLEdBVVQ7QUFBQTtBQUFBLEtBVko7QUFXQSxHQWxXOEI7QUFvVy9CMHFELGlCQXBXK0IsMkJBb1dmbGpELE1BcFdlLEVBb1dQaWdELElBcFdPLEVBb1dEO0FBQUEsUUFDdkJyM0MsRUFBRSxHQUFHLElBRGtCO0FBQUEsUUFFdkJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZXO0FBQUEsUUFHdkIyaEQsUUFBUSxHQUFHdjZDLEVBQUUsQ0FBQ282QyxxQkFBSCxDQUF5QmhqRCxNQUF6QixDQUhZO0FBQUEsUUFLdkJ3MUMsVUFBVSxHQUFHeUssSUFBSSxHQUFHaGxELGNBQUssQ0FBQ3pGLFVBQVQsR0FBc0J5RixjQUFLLENBQUNyRixVQUx0QjtBQUFBLFFBTXZCbWdELFNBQVMsR0FBR2tLLElBQUksR0FBR2hsRCxjQUFLLENBQUMxRixTQUFULEdBQXFCMEYsY0FBSyxDQUFDdEYsU0FOcEI7QUFRN0JpVCxNQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJ3NkMsVUFBbkIsR0FDRS92QyxTQURGLFlBQ2dCc3dDLFNBRGhCLEdBRUVuNUMsTUFGRixDQUVTdW1ELFFBRlQsRUFHRXBnRCxVQUhGLEdBSUUrTixRQUpGLENBSVd0UCxNQUFNLENBQUNJLG1CQUpsQixFQUtFN0MsS0FMRixDQUtRLFNBTFIsRUFLbUIsR0FMbkIsRUFNRW9ILE1BTkYsRUFSNkI7QUFnQjdCLFFBQU01UyxTQUFTLGtCQUFXMHNELElBQUksR0FBRyxHQUFILEdBQVMsR0FBeEIsV0FBZjtBQUVBeitDLFVBQU0sQ0FBQ2pPLFNBQUQsQ0FBTixHQUFvQmlPLE1BQU0sQ0FBQ2pPLFNBQUQsQ0FBTixDQUFrQnFKLE1BQWxCLENBZEwsZ0JBQUEzSSxJQUFJO0FBQUEsYUFBSSxDQUFDa3ZELFFBQVEsQ0FBQ2x2RCxJQUFELENBQWI7QUFBQSxLQWNDLENBbEJTO0FBbUI3QjtBQXZYOEIsQ0FBMUIsQzs7Ozs7QUMzQk47Ozs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUVBc0gsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I7Ozs7QUFJQXRQLGFBTCtCLHlCQUtqQjtBQUFBLFFBQ1AzUCxFQUFFLEdBQUcsSUFERTtBQUFBLFFBRVBwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZMO0FBQUEsUUFHUG1VLE1BQU0sR0FBR25VLE1BQU0sQ0FBQzZ4QixnQkFBUCxDQUF3QjFkLE1BSDFCOztBQWlCYjtBQUNBLFFBYkEvTSxFQUFFLENBQUMxVCxPQUFILEdBQWFpUSxpR0FBUSxDQUFDd1EsTUFBRCxDQWFyQixFQVhJL00sRUFBRSxDQUFDMVQsT0FBSCxDQUFXbkMsS0FBWCxFQVdKLEtBVkM2VixFQUFFLENBQUMxVCxPQUFILEdBQWEwVCxFQUFFLENBQUNrSCxXQUFILENBQ1gvUSxLQURXLENBQ0wsVUFESyxFQUNPLFVBRFAsRUFFWHBGLE1BRlcsQ0FFSixLQUZJLEVBR1hDLElBSFcsQ0FHTixPQUhNLEVBR0dxQixjQUFLLENBQUM5RixnQkFIVCxFQUlYNEosS0FKVyxDQUlMLFVBSkssRUFJTyxVQUpQLEVBS1hBLEtBTFcsQ0FLTCxnQkFMSyxFQUthLE1BTGIsRUFNWEEsS0FOVyxDQU1MLFNBTkssRUFNTSxNQU5OLENBVWQsR0FBSXlDLE1BQU0sQ0FBQ2dkLGlCQUFYLEVBQThCO0FBQzdCLFVBQUk1VixFQUFFLENBQUNxRCxZQUFILE1BQXFCM1YsUUFBUSxDQUFDa0wsTUFBTSxDQUFDOHhCLGNBQVIsQ0FBakMsRUFBMEQ7QUFBQSxZQUVyRDU1QixDQUZxRDtBQUFBLFlBR3JEeTlCLEdBSHFEO0FBQUEsWUFDbkR6cUIsT0FBTyxHQUFHOUQsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQixDQUFoQixDQUR5Qzs7QUFPekQsYUFGQWxMLE1BQU0sQ0FBQzh4QixjQUFQLEdBQXdCMXFCLEVBQUUsQ0FBQ3NELFNBQUgsQ0FBYTFLLE1BQU0sQ0FBQzh4QixjQUFwQixDQUV4QixFQUFLNTVCLENBQUMsR0FBRyxDQUFULEdBQWF5OUIsR0FBRyxHQUFHenFCLE9BQU8sQ0FBQzVCLE1BQVIsQ0FBZXBSLENBQWYsQ0FBbkIsS0FDTXk5QixHQUFHLENBQUNuOUIsQ0FBSixHQUFRd0gsTUFBTSxDQUFDOHhCLGNBQWhCLEtBQW9DLENBRHpDLEVBQXVDNTVCLENBQUMsRUFBeEM7O0FBTUE4SCxjQUFNLENBQUM4eEIsY0FBUCxHQUF3QjU1QixDQWJpQztBQWN6RDs7QUFFRGtQLFFBQUUsQ0FBQzFULE9BQUgsQ0FBV3VFLElBQVgsQ0FBZ0JtUCxFQUFFLENBQUN3NkMsY0FBSCxDQUNmeDZDLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0JwVCxHQUFoQixDQUFvQixVQUFBckMsQ0FBQztBQUFBLGVBQUkyUixFQUFFLENBQUNpeUIsT0FBSCxDQUFXNWpDLENBQUMsQ0FBQzZULE1BQUYsQ0FBU3RKLE1BQU0sQ0FBQzh4QixjQUFoQixDQUFYLENBQUo7QUFBQSxPQUFyQixDQURlLEVBRWYxcUIsRUFBRSxDQUFDaFksSUFBSCxDQUFRa2xDLGtCQUFSLEVBRmUsRUFHZmx0QixFQUFFLENBQUN5NkMsVUFBSCxDQUFjejZDLEVBQUUsQ0FBQ2dTLFVBQUgsQ0FBYyxJQUFkLEVBQW9CLENBQUMsT0FBRCxDQUFwQixDQUFkLENBSGUsRUFJZmhTLEVBQUUsQ0FBQzZKLEtBSlksQ0FBaEIsQ0FqQjZCLEVBd0J4QmtELE1BeEJ3QixJQXlCNUIvTSxFQUFFLENBQUMxVCxPQUFILENBQVc2SixLQUFYLENBQWlCLEtBQWpCLEVBQXdCeUMsTUFBTSxDQUFDK3hCLHFCQUFQLENBQTZCdHJCLEdBQXJELEVBQ0VsSixLQURGLENBQ1EsTUFEUixFQUNnQnlDLE1BQU0sQ0FBQyt4QixxQkFBUCxDQUE2Qm5yQixJQUQ3QyxFQUVFckosS0FGRixDQUVRLFNBRlIsRUFFbUIsT0FGbkIsQ0F6QjRCO0FBNkI3QjtBQUNELEdBckQ4Qjs7QUF1RC9COzs7Ozs7QUFNQXFrRCxnQkE3RCtCLDRCQTZEUDtBQUFBLHlDQUNqQng2QyxFQUFFLEdBQUcsSUFEWSxFQUVqQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkssMkJBQU4zSSxJQUFNLCtDQUFOQSxJQUFNOztBQUl2QixXQUFPeEMsVUFBVSxDQUFDbUwsTUFBTSxDQUFDNnhCLGdCQUFSLENBQVYsR0FDTix5QkFBQTd4QixNQUFNLENBQUM2eEIsZ0JBQVAsRUFBd0J2NkIsSUFBeEIsK0JBQTZCOFAsRUFBN0IsU0FBb0MvUCxJQUFwQyxFQURNLEdBQ3NDLE9BQUErUCxFQUFFLEVBQUMwNkMsaUJBQUgsWUFBd0J6cUQsSUFBeEIsQ0FEN0M7QUFFQSxHQW5FOEI7O0FBcUUvQjs7Ozs7Ozs7O0FBU0F5cUQsbUJBOUUrQiw2QkE4RWJyc0QsQ0E5RWEsRUE4RVZzc0Qsa0JBOUVVLEVBOEVVQyxrQkE5RVYsRUE4RThCL3dDLEtBOUU5QixFQThFcUM7QUFBQSxRQUM3RDdKLEVBQUUsR0FBRyxJQUR3RDtBQUFBLFFBRTdEcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGaUQ7QUFBQSxRQUc3RGlpRCxXQUFXLEdBQUdqaUQsTUFBTSxDQUFDeXhCLG9CQUFQLElBQStCc3dCLGtCQUhnQjtBQUFBLFFBSTdERyxVQUFVLEdBQUdsaUQsTUFBTSxDQUFDMHhCLG1CQUFQLElBQStCLFVBQUFuNEIsSUFBSTtBQUFBLGFBQUlBLElBQUo7QUFBQSxLQUphO0FBQUEsUUFLN0Q0b0QsV0FBVyxHQUFHbmlELE1BQU0sQ0FBQzJ4QixvQkFBUCxLQUFnQ3ZxQixFQUFFLENBQUMyRCxpQkFBSCxLQUEwQixVQUFDblcsQ0FBRCxFQUFJZ2lDLEtBQUo7QUFBQSx1QkFBaUIsQ0FBQ0EsS0FBSyxHQUFHLEdBQVQsRUFBYzlxQixPQUFkLENBQXNCLENBQXRCLENBQWpCO0FBQUEsS0FBMUIsR0FBMEVrMkMsa0JBQTFHLENBTCtDO0FBQUEsUUFNN0Q5bEIsS0FBSyxHQUFHbDhCLE1BQU0sQ0FBQ3N5QixhQU44QztBQUFBLFFBTzdEOHZCLFdBQVcsR0FBRyxVQUFBcm5CLEdBQUc7QUFBQSxhQUFJM3pCLEVBQUUsQ0FBQ29iLFlBQUgsQ0FBZ0J1WSxHQUFoQixDQUFKO0FBQUEsS0FQNEM7QUFBQSxRQVE3RHNuQixVQUFVLEdBQUdqN0MsRUFBRSxDQUFDK0osVUFBSCxHQUFnQixVQUFBNHBCLEdBQUc7QUFBQSxhQUFJM3pCLEVBQUUsQ0FBQytKLFVBQUgsQ0FBYzRwQixHQUFHLENBQUNoa0MsS0FBbEIsQ0FBSjtBQUFBLEtBQW5CLEdBQWtELFVBQUFna0MsR0FBRztBQUFBLGFBQUk5cEIsS0FBSyxDQUFDOHBCLEdBQUQsQ0FBVDtBQUFBLEtBUkw7QUFBQSxRQVM3RHVuQixRQUFRLEdBQUd0aUQsTUFBTSxDQUFDNnhCLGdCQVQyQztBQUFBLFFBVTdEMHdCLE1BQU0sR0FBR0QsUUFBUSxDQUFDRSxRQVYyQzs7QUFZbkUsUUFBSXRtQixLQUFLLEtBQUssSUFBVixJQUFrQmw4QixNQUFNLENBQUN5bkIsV0FBUCxDQUFtQjd4QixNQUF6QyxFQUFpRDtBQUNoRDtBQUNBLFVBQU1zL0IsR0FBRyxHQUFHOXRCLEVBQUUsQ0FBQ2kxQixZQUFILENBQWdCajFCLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXhCLEVBQ1ZwVCxHQURVLENBQ04sVUFBQTJxRCxFQUFFO0FBQUEsZUFBSUEsRUFBRSxDQUFDaDdDLEVBQVA7QUFBQSxPQURJLEVBRVZ1dkIsT0FGVSxFQUFaO0FBSUF2aEMsT0FBQyxDQUFDd0csSUFBRixDQUFPLFVBQUNKLENBQUQsRUFBSUMsQ0FBSixFQUFVO0FBQUEsWUFDWjBtQyxFQUFFLEdBQUczbUMsQ0FBQyxHQUFHQSxDQUFDLENBQUM5RSxLQUFMLEdBQWEsSUFEUDtBQUFBLFlBRVowckMsRUFBRSxHQUFHM21DLENBQUMsR0FBR0EsQ0FBQyxDQUFDL0UsS0FBTCxHQUFhLElBRlA7QUFTaEIsZUFMSXlyQyxFQUFFLEdBQUcsQ0FBTCxJQUFVQyxFQUFFLEdBQUcsQ0FLbkIsS0FKQ0QsRUFBRSxHQUFHM21DLENBQUMsQ0FBQzRMLEVBQUYsR0FBT3l0QixHQUFHLENBQUNubUMsT0FBSixDQUFZOE0sQ0FBQyxDQUFDNEwsRUFBZCxDQUFQLEdBQTJCLElBSWpDLEVBSENnN0IsRUFBRSxHQUFHM21DLENBQUMsQ0FBQzJMLEVBQUYsR0FBT3l0QixHQUFHLENBQUNubUMsT0FBSixDQUFZK00sQ0FBQyxDQUFDMkwsRUFBZCxDQUFQLEdBQTJCLElBR2pDLEdBQU8rNkIsRUFBRSxHQUFHQyxFQUFaO0FBQ0EsT0FWRCxDQU5nRDtBQWlCaEQsS0FqQkQsTUFpQk8sSUFBSSxlQUFlcmhDLElBQWYsQ0FBb0I4NkIsS0FBcEIsQ0FBSixFQUFnQztBQUd0Q3ptQyxPQUFDLENBQUN3RyxJQUFGLENBQU8sVUFBQ0osQ0FBRCxFQUFJQyxDQUFKLEVBQVU7QUFBQSxZQUNWMG1DLEVBQUUsR0FBRzNtQyxDQUFDLEdBQUd1bUQsV0FBVyxDQUFDdm1ELENBQUQsQ0FBZCxHQUFvQixJQURoQjtBQUFBLFlBRVY0bUMsRUFBRSxHQUFHM21DLENBQUMsR0FBR3NtRCxXQUFXLENBQUN0bUQsQ0FBRCxDQUFkLEdBQW9CLElBRmhCO0FBSWhCLGVBTm1Cb2dDLEtBQUssS0FBSyxLQU10QixHQUFjc0csRUFBRSxHQUFHQyxFQUFuQixHQUF3QkEsRUFBRSxHQUFHRCxFQUFwQztBQUNBLE9BTEQsQ0FIc0M7QUFTdEMsS0FUTSxNQVNJM3RDLFVBQVUsQ0FBQ3FuQyxLQUFELENBVGQsSUFVTnptQyxDQUFDLENBQUN3RyxJQUFGLENBQU9pZ0MsS0FBUCxDQVZNOztBQTdCNEQsUUEyQy9EM29DLElBM0MrRDtBQUFBLFFBNEMvRHduQyxHQTVDK0Q7QUFBQSxRQTZDL0QwbUIsS0E3QytEO0FBQUEsUUE4Qy9EMXFELEtBOUMrRDtBQUFBLFFBK0MvRG1CLENBL0MrRDtBQUFBLFFBMEM3RDJILEdBQUcsR0FBR3VILEVBQUUsQ0FBQ3M3Qyx5QkFBSCxDQUE2QkgsTUFBN0IsQ0ExQ3VEOztBQWlEbkUsU0FBS3JxRCxDQUFDLEdBQUcsQ0FBVCxFQUFhNmlDLEdBQUcsR0FBR3RsQyxDQUFDLENBQUN5QyxDQUFELENBQXBCLEVBQTBCQSxDQUFDLEVBQTNCLEVBQ0MsSUFBTWtxRCxXQUFXLENBQUNybkIsR0FBRCxDQUFYLElBQW9CcW5CLFdBQVcsQ0FBQ3JuQixHQUFELENBQVgsS0FBcUIsQ0FBL0M7QUFJQSxVQUFJL2xDLFdBQVcsQ0FBQ3pCLElBQUQsQ0FBZixFQUF1QjtBQUN0QixZQUFNRSxLQUFLLEdBQUc4RCxRQUFRLENBQUMwcUQsV0FBVyxHQUFHQSxXQUFXLENBQUNsbkIsR0FBRyxDQUFDdmlDLENBQUwsQ0FBZCxHQUF3QnVpQyxHQUFHLENBQUN2aUMsQ0FBeEMsQ0FBdEI7QUFFQWpGLFlBQUksR0FBR3FNLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDLENBQUQsQ0FBSixFQUFTO0FBQ3pCOGlELHVCQUFhLEVBQUVscEQsY0FBSyxDQUFDL0YsT0FESTtBQUV6Qmt2RCxlQUFLLEVBQUVqdUQsT0FBTyxDQUFDbEIsS0FBRCxDQUFQLEdBQ044dUQsTUFBTSxHQUFHOXVELEtBQUgsbUNBQWtDQSxLQUFsQyxlQURBLEdBRUg7QUFKcUIsU0FBVCxDQUhLO0FBU3RCOztBQUtELFVBSEFndUQsS0FBSyxHQUFHLENBQUMxbUIsR0FBRyxDQUFDbkUsS0FBTCxFQUFZbUUsR0FBRyxDQUFDdHpCLEVBQWhCLEVBQW9Cc3pCLEdBQUcsQ0FBQ2gyQixLQUF4QixFQUErQnRQLENBQS9CLENBR1IsRUFGQXNCLEtBQUssR0FBR1EsUUFBUSxDQUFDNHFELFdBQVcsTUFBWCxVQUFZQyxXQUFXLENBQUNybkIsR0FBRCxDQUF2QixxQ0FBaUMwbUIsS0FBakMsR0FBRCxDQUVoQixFQUFJcjZDLEVBQUUsQ0FBQyt5QixlQUFILENBQW1CWSxHQUFuQixDQUFKLEVBQTZCO0FBQUEsbUJBQ1IsQ0FBQyxNQUFELEVBQVMsS0FBVCxFQUFnQmpqQyxHQUFoQixDQUFvQixVQUFBbEQsQ0FBQztBQUFBLGlCQUFJMkMsUUFBUSxDQUNwRDRxRCxXQUFXLE1BQVgsVUFBWS82QyxFQUFFLENBQUNnekIsZ0JBQUgsQ0FBb0JXLEdBQXBCLEVBQXlCbm1DLENBQXpCLENBQVoscUNBQTRDNnNELEtBQTVDLEdBRG9ELENBQVo7QUFBQSxTQUFyQixDQURRO0FBQUE7QUFBQSxZQUNyQmxmLElBRHFCO0FBQUEsWUFDZnNnQixHQURlOztBQUs1QjlyRCxhQUFLLHlCQUFrQkEsS0FBbEIsMkJBQXdDd3JDLElBQXhDLDBCQUE0RHNnQixHQUE1RCxDQUx1QjtBQU01Qjs7QUFFRCxVQUFJOXJELEtBQUssS0FBS3NGLFNBQWQsRUFBeUI7QUFBQTtBQUN4QjtBQUNBLGNBQUkwK0IsR0FBRyxDQUFDeGhDLElBQUosS0FBYSxJQUFqQixFQUNDO0FBSHVCLGNBTWxCQSxJQUFJLEdBQUdoQyxRQUFRLENBQUMycUQsVUFBVSxNQUFWLFVBQVdubkIsR0FBRyxDQUFDeGhDLElBQWYscUNBQXdCa29ELEtBQXhCLEdBQUQsQ0FORztBQUFBLGNBT2xCeHdDLEtBQUssR0FBR294QyxVQUFVLENBQUN0bkIsR0FBRCxDQVBBO0FBQUEsY0FRbEIrbkIsWUFBWSxHQUFHO0FBQ3BCQyw4QkFBa0IsRUFBRXRwRCxjQUFLLENBQUM3RixXQUFOLEdBQW9Cd1QsRUFBRSxDQUFDczJCLHVCQUFILENBQTJCM0MsR0FBRyxDQUFDdHpCLEVBQS9CLENBRHBCO0FBRXBCdTdDLGlCQUFLLEVBQUdULE1BQU0sSUFBSSxDQUFDbjdDLEVBQUUsQ0FBQ3VQLFFBQWYsR0FBMkIxRixLQUEzQixxQ0FBNkRBLEtBQTdELGdEQUZhO0FBR3BCZ3lDLGdCQUFJLEVBQUUxcEQsSUFIYztBQUlwQjJwRCxpQkFBSyxFQUFFbnNEO0FBSmEsV0FSRztBQWVwQndyRCxnQkFBTSxJQUFJanNELFFBQVEsQ0FBQ2dzRCxRQUFRLENBQUMvdUQsSUFBVixDQWZFLElBZ0J2QnVDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZdXNELFFBQVEsQ0FBQy91RCxJQUFyQixFQUEyQjBELE9BQTNCLENBQW1DLFVBQUFOLEdBQUcsRUFBSTtBQUN6Q21zRCx3QkFBWSxDQUFDbnNELEdBQUQsQ0FBWixHQUFvQjJyRCxRQUFRLENBQUMvdUQsSUFBVCxDQUFjb0QsR0FBZCxFQUFtQnVCLENBQW5CLENBRHFCO0FBRXpDLFdBRkQsQ0FoQnVCLEVBcUJ4QjNFLElBQUksSUFBSXFNLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDLENBQUQsQ0FBSixFQUFTaWpELFlBQVQsQ0FyQk07QUFBQTs7QUFBQSxpQ0FHdkI7QUFtQkQ7QUFoREQ7O0FBbURELHFCQUFVdnZELElBQVY7QUFDQSxHQXBMOEI7O0FBc0wvQjs7Ozs7O0FBTUFtdkQsMkJBNUwrQixxQ0E0TExILE1BNUxLLEVBNExHO0FBQ2pDLFdBQU8sQ0FBQ0EsTUFBTSx3SkFHUSxLQUFLNXJDLFFBQUwsbUVBSFIsdUdBQVAsRUFPTGxmLE9BUEssQ0FPRyxhQVBILEVBT2tCLEVBUGxCLEVBUUxPLEtBUkssQ0FRQyxVQVJELENBQVA7QUFTQSxHQXRNOEI7O0FBd00vQjs7Ozs7Ozs7O0FBU0FtckQsaUJBak4rQiwyQkFpTmZsQyxVQWpOZSxFQWlOSG1DLE1Bak5HLEVBaU5LQyxPQWpOTCxFQWlOY2p2QyxPQWpOZCxFQWlOdUI7QUFDL0MsUUFBQWhOLEVBQUUsR0FBRyxJQUFMO0FBQUEsUUFDQXBILE1BREEsR0FDU29ILEVBQUUsQ0FBQ3BILE1BRFo7QUFBQSxtQkFFWXFtQyxnR0FBTyxDQUFDanlCLE9BQUQsQ0FGbkI7QUFBQTtBQUFBLFFBRUR4TixJQUZDO0FBQUEsUUFFS0gsR0FGTDtBQUFBLFFBSUF1aUMsT0FKQSxHQUlVNWhDLEVBQUUsQ0FBQ3NoQyxVQUFILElBSlY7QUFBQSxRQUtGNGEsVUFMRSxHQUtXdGEsT0FBTyxHQUFHNWhDLEVBQUUsQ0FBQ3NULFlBQWIsR0FBNEJ0VCxFQUFFLENBQUM4UyxzQkFBSCxFQUx2Qzs7QUFTTjtBQUNBLFFBSEF6VCxHQUFHLElBQUksRUFHUCxFQUFJVyxFQUFFLENBQUNnUyxVQUFILEVBQUosRUFBcUI7QUFDcEIsVUFBTWthLEdBQUcsR0FBR2xzQixFQUFFLENBQUMwTSxTQUFILEtBQWlCLE9BQWpCLElBQTRCMU0sRUFBRSxDQUFDNE4sT0FBSCxDQUFXLE9BQVgsQ0FBeEM7QUFFS3NlLFNBSGUsS0FJbkI3c0IsR0FBRyxJQUFJVyxFQUFFLENBQUN6TyxNQUFILEdBQVksQ0FKQSxFQUtuQmlPLElBQUksSUFBSSxDQUFDUSxFQUFFLENBQUMxTyxLQUFILElBQVkwTyxFQUFFLENBQUMyTCxhQUFILEdBQW1CM0wsRUFBRSxDQUFDaVMsY0FBSCxFQUFuQixHQUF5QyxDQUFyRCxDQUFELElBQTRELENBTGpEO0FBT3BCLEtBUEQsTUFPTztBQUNOLFVBQU1rcUMsU0FBUyxHQUFHbjhDLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS3lvRCxVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWN6b0QsQ0FBbkIsQ0FBbEI7QUFFSXdILFlBQU0sQ0FBQ3VILFlBSEwsSUFJTGQsR0FBRyxHQUFHODhDLFNBQVMsR0FBRyxFQUpiLEVBS0wzOEMsSUFBSSxJQUFJb2lDLE9BQU8sR0FBRyxHQUxiLEVBTUxzYSxVQUFVLElBQUl0YSxPQU5ULEtBUUx2aUMsR0FBRyxJQUFJLENBUkYsRUFTTEcsSUFBSSxHQUFHb2lDLE9BQU8sR0FBRzVoQyxFQUFFLENBQUNnVCxxQkFBSCxJQUFWLEdBQTJDLEVBQTNDLElBQWlEaFQsRUFBRSxDQUFDbUQsU0FBSCxHQUFlM0QsSUFBZixHQUFzQjI4QyxTQUF2RSxDQVRGO0FBV047O0FBRUQsUUFBTTc4QyxLQUFLLEdBQUdFLElBQUksR0FBR3c4QyxNQUFyQjtBQWVBLFdBYkkxOEMsS0FBSyxHQUFHNDhDLFVBYVosS0FYQzE4QyxJQUFJLElBQUlGLEtBQUssR0FBRzQ4QyxVQUFSLEdBQXFCLEVBVzlCLEdBUkk3OEMsR0FBRyxHQUFHNDhDLE9BQU4sR0FBZ0JqOEMsRUFBRSxDQUFDbVQsYUFRdkIsS0FQQzlULEdBQUcsSUFBSTQ4QyxPQUFPLEdBQUcsRUFPbEIsR0FKSTU4QyxHQUFHLEdBQUcsQ0FJVixLQUhDQSxHQUFHLEdBQUcsQ0FHUCxHQUFPO0FBQUNBLFNBQUcsRUFBSEEsR0FBRDtBQUFNRyxVQUFJLEVBQUpBO0FBQU4sS0FBUDtBQUNBLEdBaFE4Qjs7QUFrUS9COzs7Ozs7QUFNQSsrQixhQXhRK0IsdUJBd1FuQkQsWUF4UW1CLEVBd1FMdHhCLE9BeFFLLEVBd1FJO0FBQUEsUUFDNUJoTixFQUFFLEdBQUcsSUFEdUI7QUFBQSxRQUU1QnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmdCO0FBQUEsUUFHNUJtVSxNQUFNLEdBQUduVSxNQUFNLENBQUM2eEIsZ0JBQVAsQ0FBd0IxZCxNQUhMO0FBQUEsUUFJNUJxdkMsTUFBTSxHQUFHcDhDLEVBQUUsQ0FBQ2dTLFVBQUgsQ0FBYyxJQUFkLEVBQW9CLENBQUMsT0FBRCxDQUFwQixDQUptQjtBQUFBLFFBSzVCNm5DLFVBQVUsR0FBR3ZiLFlBQVksQ0FBQ3RxQyxNQUFiLENBQW9CLFVBQUEzRixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxJQUFJZCxPQUFPLENBQUN5UyxFQUFFLENBQUNvYixZQUFILENBQWdCL3NCLENBQWhCLENBQUQsQ0FBaEI7QUFBQSxLQUFyQixDQUxlO0FBQUEsUUFNNUJndUQsZ0JBQWdCLEdBQUd6akQsTUFBTSxDQUFDNHhCLGdCQUFQLElBQTJCeHFCLEVBQUUsQ0FBQys3QyxlQU5yQjs7QUFRbEMsUUFBSWxDLFVBQVUsQ0FBQ3JyRCxNQUFYLEtBQXNCLENBQXRCLElBQTRCb0ssTUFBTSxDQUFDc3hCLFlBQXZDO0FBQUEsVUFJTW9TLEtBQUssR0FBR3Q4QixFQUFFLENBQUMxVCxPQUFILENBQVdnd0MsS0FBWCxFQUpkO0FBQUEsVUFLTWdnQixPQUFPLEdBQUdsakIsSUFBSSxDQUFDbWpCLFNBQUwsQ0FBZWplLFlBQWYsQ0FMaEI7QUFBQSxVQU1JaHRDLEtBQUssR0FBSWdyQyxLQUFLLElBQUlBLEtBQUssQ0FBQ2hyQyxLQUFoQixJQUEwQixDQU50QztBQUFBLFVBT0lDLE1BQU0sR0FBSStxQyxLQUFLLElBQUlBLEtBQUssQ0FBQy9xQyxNQUFoQixJQUEyQixDQVB4Qzs7QUFTQSxVQUFJLENBQUMrcUMsS0FBRCxJQUFVQSxLQUFLLENBQUNsRixPQUFOLEtBQWtCa2xCLE9BQWhDLEVBQXlDO0FBQ3hDLFlBQU0zK0MsS0FBSyxHQUFHMmdDLFlBQVksQ0FBQzlxQyxNQUFiLEdBQXNCcUIsSUFBdEIsR0FBNkIsQ0FBN0IsRUFBZ0M4SSxLQUE5QztBQUVBN04sY0FBTSxDQUFDOEksTUFBTSxDQUFDa3lCLGNBQVIsRUFBd0I5cUIsRUFBeEIsQ0FIa0MsRUFNeENBLEVBQUUsQ0FBQzFULE9BQUgsQ0FDRXVFLElBREYsQ0FDT21QLEVBQUUsQ0FBQ3c2QyxjQUFILENBQ0xsYyxZQURLLEVBRUx0K0IsRUFBRSxDQUFDaFksSUFBSCxDQUFRa2xDLGtCQUFSLEVBRkssRUFHTGx0QixFQUFFLENBQUN5NkMsVUFBSCxDQUFjMkIsTUFBZCxDQUhLLEVBSUxwOEMsRUFBRSxDQUFDNkosS0FKRSxDQURQLEVBT0UxVCxLQVBGLENBT1EsU0FQUixFQU9tQixJQVBuQixFQVFFQSxLQVJGLENBUVEsWUFSUixFQVFzQixJQVJ0QixFQVE0QjtBQVI1QixTQVNFbW1DLEtBVEYsQ0FTUTtBQUNOMytCLGVBQUssRUFBTEEsS0FETTtBQUVOeTVCLGlCQUFPLEVBQUVrbEIsT0FGSDtBQUdOaHJELGVBQUssRUFBRUEsS0FBSyxHQUFHME8sRUFBRSxDQUFDMVQsT0FBSCxDQUFXa3dELFFBQVgsQ0FBb0IsYUFBcEIsQ0FIVDtBQUlOanJELGdCQUFNLEVBQUVBLE1BQU0sR0FBR3lPLEVBQUUsQ0FBQzFULE9BQUgsQ0FBV2t3RCxRQUFYLENBQW9CLGNBQXBCO0FBSlgsU0FUUixDQU53QyxFQXNCeEMxc0QsTUFBTSxDQUFDOEksTUFBTSxDQUFDb3lCLGVBQVIsRUFBeUJockIsRUFBekIsQ0F0QmtDLEVBdUJ4Q0EsRUFBRSxDQUFDbS9CLG1CQUFILEtBQTZCeGhDLEtBQTdCLENBdkJ3QztBQXdCeEM7O0FBRUQsVUFBSSxDQUFDb1AsTUFBTCxFQUFhO0FBQ1o7QUFDQSxZQUFNL0gsUUFBUSxHQUFHcTNDLGdCQUFnQixDQUFDbnNELElBQWpCLENBQXNCLElBQXRCLEVBQTRCMnBELFVBQTVCLEVBQXdDdm9ELEtBQXhDLEVBQStDQyxNQUEvQyxFQUF1RHliLE9BQXZELENBQWpCLENBRlksQ0FJWjs7QUFDQWhOLFVBQUUsQ0FBQzFULE9BQUgsQ0FDRTZKLEtBREYsQ0FDUSxLQURSLFlBQ2tCNk8sUUFBUSxDQUFDM0YsR0FEM0IsU0FFRWxKLEtBRkYsQ0FFUSxNQUZSLFlBRW1CNk8sUUFBUSxDQUFDeEYsSUFGNUIsUUFMWTtBQVFaO0FBM0NEO0FBNENBLEdBNVQ4Qjs7QUE4VC9COzs7OztBQUtBcVcsYUFuVStCLHVCQW1VbkIzZCxLQW5VbUIsRUFtVVo7QUFBQSxRQUNaOEgsRUFBRSxHQUFHLElBRE87QUFBQSxRQUVacEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQTtBQUFBLEtBSWQsQ0FBQ0EsTUFBTSxDQUFDdXhCLGlCQUFSLElBQTZCanlCLEtBSmYsTUFLakJwSSxNQUFNLENBQUM4SSxNQUFNLENBQUNteUIsY0FBUixFQUF3Qi9xQixFQUF4QixDQUxXLEVBUWpCLEtBQUsxVCxPQUFMLENBQ0U2SixLQURGLENBQ1EsU0FEUixFQUNtQixNQURuQixFQUVFQSxLQUZGLENBRVEsWUFGUixFQUVzQixRQUZ0QixFQUVnQztBQUZoQyxLQUdFbW1DLEtBSEYsQ0FHUSxJQUhSLENBUmlCLEVBYWpCeHNDLE1BQU0sQ0FBQzhJLE1BQU0sQ0FBQ3F5QixnQkFBUixFQUEwQmpyQixFQUExQixDQWJXO0FBZWxCLEdBbFY4Qjs7QUFvVi9COzs7Ozs7QUFNQW0vQixxQkExVitCLCtCQTBWWHNkLElBMVZXLEVBMFZMOStDLEtBMVZLLEVBMFZFO0FBQ2hDLFFBQU1xQyxFQUFFLEdBQUcsSUFBWDs7QUFFQSxRQUFJQSxFQUFFLENBQUNwSCxNQUFILENBQVVneUIsY0FBZCxFQUE4QjtBQUM3QixVQUFNOHhCLFVBQVUsR0FBRzE4QyxFQUFFLENBQUNwSCxNQUFILENBQVVpeUIsbUJBQTdCO0FBRUEsT0FBQzdxQixFQUFFLENBQUNpRCxHQUFILENBQU93YixRQUFQLENBQWdCaytCLE1BQWhCLElBQTBCLEVBQTNCLEVBQStCOXNELE9BQS9CLENBQXVDLFVBQUFzRSxDQUFDLEVBQUk7QUFDM0MsWUFBSUEsQ0FBQyxLQUFLNkwsRUFBRSxDQUFDaUQsR0FBYixFQUFrQjtBQUFBLGNBQ1hySyxPQUFNLEdBQUd6RSxDQUFDLENBQUNzcUIsUUFBRixDQUFXN2xCLE1BRFQ7QUFBQSxjQUVYZ2tELFFBQVEsR0FBR2hrRCxPQUFNLENBQUNneUIsY0FGUDtBQUFBLGNBR1h6NEIsSUFBSSxHQUFHeUcsT0FBTSxDQUFDaXlCLG1CQUhIO0FBQUEsY0FJWGd5QixPQUFPLEdBQUd0MUQsUUFBUSxDQUFDOE8sSUFBVCxDQUFjeW1ELFFBQWQsQ0FBdUIzb0QsQ0FBQyxDQUFDNlksT0FBekIsQ0FKQzs7QUFNakIsY0FBSTR2QyxRQUFRLElBQUlGLFVBQVUsS0FBS3ZxRCxJQUEzQixJQUFtQzBxRCxPQUF2QyxFQUFnRDtBQUFBLGdCQUN6QzlvRCxJQUFJLEdBQUdJLENBQUMsQ0FBQ3NxQixRQUFGLENBQVdueUIsT0FBWCxDQUFtQnlILElBQW5CLEdBQTBCLENBQTFCLENBRGtDO0FBQUEsZ0JBRXpDZ3BELGNBQWMsR0FBR3AvQyxLQUFLLE1BQU01SixJQUFJLElBQUlBLElBQUksQ0FBQzRKLEtBQW5CLENBRm1COztBQUkvQztBQUNBLGdCQUFJO0FBQ0M4K0Msa0JBQUksSUFBSU0sY0FEVCxHQUVGNW9ELENBQUMsQ0FBQzdILE9BQUYsQ0FBVW13RCxJQUFWLENBQWU7QUFBQzkrQyxxQkFBSyxFQUFMQTtBQUFELGVBQWYsQ0FGRSxHQUdRLENBQUM4K0MsSUFIVCxJQUlGdG9ELENBQUMsQ0FBQzdILE9BQUYsQ0FBVTRwRCxJQUFWLEVBSkU7QUFNSCxhQU5ELENBTUUsT0FBT3ppRCxDQUFQLEVBQVUsQ0FBRTtBQUNkO0FBQ0Q7QUFDRCxPQXJCRCxDQUg2QjtBQXlCN0I7QUFDRDtBQXZYOEIsQ0FBMUIsQzs7QUNaTjs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRUFkLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7O0FBSUFyUCxZQUwrQix3QkFLbEI7QUFBQSxRQUNONVAsRUFBRSxHQUFHLElBREM7QUFBQSxRQUVOcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGTjtBQUlab0gsTUFBRSxDQUFDZzlDLGlCQUFILEdBQXVCLEVBSlgsRUFLWmg5QyxFQUFFLENBQUNpOUMsaUJBQUgsS0FMWSxFQU1aajlDLEVBQUUsQ0FBQ3NSLE1BQUgsR0FBWXRSLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBTzNWLE1BQVAsQ0FBYyxHQUFkLENBTkEsRUFRUjZILE1BQU0sQ0FBQ2lWLFdBUkMsSUFTWDdOLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVXRnQixJQUFWLENBQWUsV0FBZixFQUE0QmdQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsUUFBaEIsQ0FBNUIsQ0FUVyxFQWFYakIsRUFBRSxDQUFDOFYsWUFBSCxFQWJXLEtBZVg5VixFQUFFLENBQUNzUixNQUFILENBQVVuYixLQUFWLENBQWdCLFlBQWhCLEVBQThCLFFBQTlCLENBZlcsRUFnQlg2SixFQUFFLENBQUN3TCxlQUFILEdBQXFCeEwsRUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsQ0FoQlY7QUFrQlosR0F2QjhCOztBQXlCL0I7Ozs7Ozs7QUFPQWdTLGNBaEMrQix3QkFnQ2xCdWUsU0FoQ2tCLEVBZ0NQL2tDLE9BaENPLEVBZ0NFOFksV0FoQ0YsRUFnQ2U7QUFBQSxRQUN2Q3BJLEVBQUUsR0FBRyxJQURrQztBQUFBLFFBRXZDcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGMkI7QUFBQSxRQUd2Q3NrRCxPQUFPLEdBQUc1dEQsT0FBTyxJQUFJO0FBQzFCb2hCLG1CQUFhLElBRGE7QUFFMUJnSyxnQ0FBMEIsSUFGQTtBQUcxQnRULG9CQUFjO0FBSFksS0FIa0I7QUFzQjdDO0FBSUE7QUFJQTtBQXJCQTgxQyxXQUFPLENBQUM5MUMsY0FBUixHQUF5Qi9YLFNBQVMsQ0FBQzZ0RCxPQUFELEVBQVUsZ0JBQVYsS0FUVyxFQVU3Q0EsT0FBTyxDQUFDeGlDLDBCQUFSLEdBQXFDcnJCLFNBQVMsQ0FBQzZ0RCxPQUFELEVBQVUsNEJBQVYsS0FWRCxFQVl6Q3RrRCxNQUFNLENBQUN5cEIsc0JBQVAsSUFBaUN6cEIsTUFBTSxDQUFDMHBCLHdCQVpDLEdBYTVDdGlCLEVBQUUsQ0FBQ205QyxvQkFBSCxFQWI0QyxHQWU1Q245QyxFQUFFLENBQUNvOUMsbUJBQUgsQ0FDQy9vQixTQUFTLElBQUlyMEIsRUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsQ0FEZCxFQUVDbzVDLE9BRkQsRUFHQzkwQyxXQUhELENBZjRDLEVBdUI3Q3BJLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVXpVLFNBQVYsWUFBd0J4SyxjQUFLLENBQUN4SCxVQUE5QixHQUNFc2lCLE9BREYsQ0FDVTlhLGNBQUssQ0FBQ3JILGdCQURoQixFQUNrQyxVQUFBcVYsRUFBRTtBQUFBLGFBQUksQ0FBQ0wsRUFBRSxDQUFDc1UsY0FBSCxDQUFrQmpVLEVBQWxCLENBQUw7QUFBQSxLQURwQyxDQXZCNkMsRUEyQjdDTCxFQUFFLENBQUMrTixZQUFILEtBQXVCLENBQUMvTixFQUFFLENBQUNtRCxTQUEzQixDQTNCNkMsRUE0QjdDbkQsRUFBRSxDQUFDd1AsYUFBSCxFQTVCNkMsRUErQjdDeFAsRUFBRSxDQUFDMmEsWUFBSCxDQUFnQnVpQyxPQUFPLENBQUN4aUMsMEJBQXhCLEVBQW9EdFMsV0FBcEQsQ0EvQjZDLEVBaUM3Q3BJLEVBQUUsQ0FBQ2k5QyxpQkFBSCxLQWpDNkM7QUFrQzdDLEdBbEU4Qjs7QUFvRS9COzs7O0FBSUFFLHNCQXhFK0Isa0NBd0VSO0FBQUEsUUFDaEJuOUMsRUFBRSxHQUFHLElBRFc7QUFBQSxRQUVoQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkk7QUFBQSxRQUdoQnlrRCxPQUFPLEdBQUc5Z0QsaUdBQVEsQ0FBQzNELE1BQU0sQ0FBQ3lwQixzQkFBUixDQUhGO0FBQUEsUUFJaEIrNEIsUUFBUSxHQUFHeGlELE1BQU0sQ0FBQzBwQix3QkFKRjs7QUFNdEIsUUFBSSxDQUFDKzZCLE9BQU8sQ0FBQ2x6RCxLQUFSLEVBQUwsRUFBc0I7QUFBQSxVQUNmMlosT0FBTyxHQUFHOUQsRUFBRSxDQUFDeU4sUUFBSCxDQUFZek4sRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBcEIsQ0FESztBQUFBLFVBRWZncUIsR0FBRyxHQUFHLEVBRlM7QUFBQSxVQUdqQmo5QixJQUFJLEdBQUcsRUFIVTtBQUtyQmlULGFBQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQXJDLENBQUMsRUFBSTtBQUNwQixZQUFNOHZELE9BQU8sR0FBRzd2RCxVQUFVLENBQUMydEQsUUFBRCxDQUFWLEdBQ2ZBLFFBQVEsQ0FBQ2xyRCxJQUFULENBQWM4UCxFQUFkLEVBQWtCeFMsQ0FBbEIsRUFBcUJ3UyxFQUFFLENBQUM2SixLQUFILENBQVNyYyxDQUFULENBQXJCLEVBQWtDd1MsRUFBRSxDQUFDaUQsR0FBSCxDQUFPbFAsSUFBUCxDQUFZdkcsQ0FBWixFQUFlLENBQWYsRUFBa0IwVSxNQUFwRCxDQURlLEdBRWYxSixVQUFVLENBQUM0aUQsUUFBRCxFQUFXO0FBQ3BCUSxlQUFLLEVBQUU1N0MsRUFBRSxDQUFDNkosS0FBSCxDQUFTcmMsQ0FBVCxDQURhO0FBRXBCZ3VELGVBQUssRUFBRWh1RDtBQUZhLFNBQVgsQ0FGWDtBQU9JOHZELGVBUmdCLEtBU25CeHZCLEdBQUcsQ0FBQ3o0QixJQUFKLENBQVM3SCxDQUFULENBVG1CLEVBVW5CcUQsSUFBSSxJQUFJeXNELE9BVlc7QUFZcEIsT0FaRCxDQUxxQjtBQW1CckIsVUFBTXp5RCxVQUFVLEdBQUd3eUQsT0FBTyxDQUFDeHNELElBQVIsQ0FBYUEsSUFBYixFQUNqQmdNLFNBRGlCLENBQ1AsWUFBVztBQUFFLGVBQU8sS0FBS3cyQyxVQUFaO0FBQXlCLE9BRC9CLEVBRWpCdC9DLElBRmlCLENBRVorNUIsR0FGWSxDQUFuQjtBQUlBOXRCLFFBQUUsQ0FBQ3U5QyxhQUFILENBQWlCMXlELFVBQWpCLENBdkJxQixFQXlCckJtVixFQUFFLENBQUNzUixNQUFILEdBQVkrckMsT0F6QlM7QUEwQnJCO0FBQ0QsR0F6RzhCOztBQTJHL0I7Ozs7O0FBS0FocUMscUJBaEgrQiwrQkFnSFhqWixJQWhIVyxFQWdITDtBQUNuQixRQUFBNEYsRUFBRSxHQUFHLElBQUw7QUFBQSxRQUNBcEgsTUFEQSxHQUNTb0gsRUFBRSxDQUFDcEgsTUFEWjtBQUFBLFFBRUN0SCxLQUZELEdBRWtCOEksSUFGbEIsQ0FFQzlJLEtBRkQ7QUFBQSxRQUVRQyxNQUZSLEdBRWtCNkksSUFGbEIsQ0FFUTdJLE1BRlI7QUFBQSxRQUlBaXNELG1CQUpBLEdBSXNCO0FBQzNCbitDLFNBQUcsRUFBRVcsRUFBRSxDQUFDOEwsV0FBSCxHQUNKOUwsRUFBRSxDQUFDNlMsb0JBQUgsS0FBNEJqYSxNQUFNLENBQUM0cEIsY0FBbkMsR0FBb0QsR0FEaEQsR0FFSnhpQixFQUFFLENBQUNtVCxhQUFILEdBQW1CNWhCLE1BQW5CLEdBQTRCeU8sRUFBRSxDQUFDK1MsdUJBQUgsRUFBNUIsR0FBMkRuYSxNQUFNLENBQUM0cEIsY0FIeEM7QUFJM0JoakIsVUFBSSxFQUFFUSxFQUFFLENBQUNnTSxZQUFILEdBQ0xoTSxFQUFFLENBQUNnVCxxQkFBSCxLQUE2QnBhLE1BQU0sQ0FBQzJwQixjQUFwQyxHQUFxRCxFQURoRCxHQUVMdmlCLEVBQUUsQ0FBQ3NULFlBQUgsR0FBa0JoaUIsS0FBbEIsR0FBMEIwTyxFQUFFLENBQUM4UyxzQkFBSCxFQUExQixHQUF3RGxhLE1BQU0sQ0FBQzJwQixjQUEvRCxHQUFnRjtBQU50RCxLQUp0QjtBQWFOdmlCLE1BQUUsQ0FBQ29ULE9BQUgsR0FBYTtBQUNaL1QsU0FBRyxFQUFFVyxFQUFFLENBQUMyTCxhQUFILEdBQ0osQ0FESSxHQUNBM0wsRUFBRSxDQUFDNkwsYUFBSCxHQUFtQjJ4QyxtQkFBbUIsQ0FBQ24rQyxHQUF2QyxHQUE2Q1csRUFBRSxDQUFDbVQsYUFBSCxHQUFtQjVoQixNQUZ6RDtBQUdaK04sV0FBSyxFQUFFNFQsR0FISztBQUlaM1QsWUFBTSxFQUFFLENBSkk7QUFLWkMsVUFBSSxFQUFFUSxFQUFFLENBQUMyTCxhQUFILEdBQ0wzTCxFQUFFLENBQUNzVCxZQUFILEdBQWtCaGlCLEtBRGIsR0FDcUIwTyxFQUFFLENBQUM2TCxhQUFILEdBQW1CMnhDLG1CQUFtQixDQUFDaCtDLElBQXZDLEdBQThDO0FBTjdELEtBZFk7QUFzQnpCLEdBdEk4Qjs7QUF3SS9COzs7OztBQUtBdWMsaUJBN0krQiwyQkE2SWYzVSxjQTdJZSxFQTZJQztBQUMvQixRQUFNcEgsRUFBRSxHQUFHLElBQVg7QUFFQSxLQUFDb0gsY0FBYyxHQUFHcEgsRUFBRSxDQUFDc1IsTUFBSCxDQUFVblgsVUFBVixFQUFILEdBQTRCNkYsRUFBRSxDQUFDc1IsTUFBOUMsRUFDRXRnQixJQURGLENBQ08sV0FEUCxFQUNvQmdQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsUUFBaEIsQ0FEcEIsQ0FIK0I7QUFLL0IsR0FsSjhCOztBQW9KL0I7Ozs7O0FBS0F3OEMsa0JBekorQiw0QkF5SmRsUSxJQXpKYyxFQXlKUjtBQUN0QixTQUFLdGhDLFVBQUwsR0FBa0JzaEMsSUFESTtBQUV0QixHQTNKOEI7O0FBNkovQjs7Ozs7QUFLQW1RLHVCQWxLK0IsaUNBa0tUcmpELENBbEtTLEVBa0tOO0FBQ3hCLFNBQUs2UixlQUFMLEdBQXVCN1IsQ0FEQztBQUV4QixHQXBLOEI7O0FBc0svQjs7Ozs7QUFLQXNqRCx3QkEzSytCLGtDQTJLUnJqRCxDQTNLUSxFQTJLTDtBQUN6QixTQUFLNlIsZ0JBQUwsR0FBd0I3UixDQURDO0FBRXpCLEdBN0s4Qjs7QUErSy9COzs7OztBQUtBMlgsZ0JBcEwrQiw0QkFvTGQ7QUFDaEIsUUFBTWpTLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDcEgsTUFBSCxDQUFVaVYsV0FBVixHQUNON04sRUFBRSxDQUFDMkwsYUFBSCxJQUFvQjNMLEVBQUUsQ0FBQzZMLGFBQXZCLEdBQ0M3TCxFQUFFLENBQUNrTSxlQUFILElBQXNCbE0sRUFBRSxDQUFDaU0sVUFBSCxHQUFnQixDQUF0QyxDQURELEdBQzRDak0sRUFBRSxDQUFDc1QsWUFGekMsR0FHSCxDQUhKO0FBSUEsR0EzTDhCOztBQTZML0I7Ozs7O0FBS0FwQixpQkFsTStCLDZCQWtNYjtBQUNqQixRQUFNbFMsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNwSCxNQUFILENBQVVpVixXQUFWLEdBQ043TixFQUFFLENBQUMyTCxhQUFILEdBQ0MzTCxFQUFFLENBQUNtVCxhQURKLEdBQ29CbmxCLElBQUksQ0FBQ2tOLEdBQUwsQ0FBUyxFQUFULEVBQWE4RSxFQUFFLENBQUNtTSxnQkFBaEIsS0FBcUNuTSxFQUFFLENBQUNpTSxVQUFILEdBQWdCLENBQXJELENBRmQsR0FHSCxDQUhKO0FBSUEsR0F6TThCOztBQTJNL0I7Ozs7OztBQU1BMnhDLGtCQWpOK0IsNEJBaU5kL3lELFVBak5jLEVBaU5GO0FBQzVCLFdBQU9BLFVBQVUsQ0FBQ3NpQixPQUFYLENBQW1COWEsY0FBSyxDQUFDckgsZ0JBQXpCLElBQTZDLElBQTdDLEdBQW9ELEdBQTNEO0FBQ0EsR0FuTjhCOztBQXFOL0I7Ozs7OztBQU1BNnlELDJCQTNOK0IscUNBMk5MaHpELFVBM05LLEVBMk5PO0FBQ3JDLFdBQU9BLFVBQVUsQ0FBQ3NpQixPQUFYLENBQW1COWEsY0FBSyxDQUFDckgsZ0JBQXpCLElBQTZDLElBQTdDLEdBQW9ELEtBQTNEO0FBQ0EsR0E3TjhCOztBQStOL0I7Ozs7OztBQU1BcytDLG1CQXJPK0IsNkJBcU9ialYsU0FyT2EsRUFxT0ZnVixLQXJPRSxFQXFPSztBQUFBLFFBQzdCcnBDLEVBQUUsR0FBRyxJQUR3QjtBQUFBLFFBRTdCODlDLFNBQVMsR0FBRzk5QyxFQUFFLENBQUNpMEIsY0FBSCxDQUFrQkksU0FBbEIsQ0FGaUI7QUFJbkNyMEIsTUFBRSxDQUFDc1IsTUFBSCxDQUFVelUsU0FBVixZQUF3QnhLLGNBQUssQ0FBQ3hILFVBQTlCLEdBQ0VtSixNQURGLENBQ1MsVUFBQXFNLEVBQUU7QUFBQSxhQUFJeTlDLFNBQVMsQ0FBQ24yRCxPQUFWLENBQWtCMFksRUFBbEIsS0FBeUIsQ0FBN0I7QUFBQSxLQURYLEVBRUU4TSxPQUZGLENBRVU5YSxjQUFLLENBQUN0SCxpQkFGaEIsRUFFbUNzK0MsS0FGbkMsRUFHRWx2QyxVQUhGLEdBSUUrTixRQUpGLENBSVcsR0FKWCxFQUtFL1IsS0FMRixDQUtRLFNBTFIsRUFLbUIsWUFBVztBQUM1QixhQUFPLENBQUNrekMsS0FBSyxHQUFHcnBDLEVBQUUsQ0FBQzQ5QyxnQkFBTixHQUF5QjU5QyxFQUFFLENBQUM2OUMseUJBQWxDLEVBQ0wzdEQsSUFESyxDQUNBOFAsRUFEQSxFQUNJekQsaUdBQVEsQ0FBQyxJQUFELENBRFosQ0FBUDtBQUVBLEtBUkYsQ0FKbUM7QUFhbkMsR0FsUDhCOztBQW9QL0I7Ozs7QUFJQWt0QyxjQXhQK0IsMEJBd1BoQjtBQUNkLFFBQU16cEMsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDc1IsTUFBSCxDQUFVelUsU0FBVixZQUF3QnhLLGNBQUssQ0FBQ3hILFVBQTlCLEdBQ0VzaUIsT0FERixDQUNVOWEsY0FBSyxDQUFDdEgsaUJBRGhCLE1BRUVvUCxVQUZGLEdBR0UrTixRQUhGLENBR1csR0FIWCxFQUlFL1IsS0FKRixDQUlRLFNBSlIsRUFJbUIsWUFBVztBQUM1QixhQUFPNkosRUFBRSxDQUFDNDlDLGdCQUFILENBQW9CcmhELGlHQUFRLENBQUMsSUFBRCxDQUE1QixDQUFQO0FBQ0EsS0FORixDQUhjO0FBVWQsR0FsUThCOztBQW9RL0I7Ozs7O0FBS0F3aEQsWUF6UStCLHNCQXlRcEIxcEIsU0F6UW9CLEVBeVFUO0FBQUEsUUFDZnIwQixFQUFFLEdBQUcsSUFEVTtBQUFBLFFBRWZwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZHO0FBSWhCQSxVQUFNLENBQUNpVixXQUpTLEtBS3BCalYsTUFBTSxDQUFDaVYsV0FBUCxLQUxvQixFQU1wQjdOLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVW5iLEtBQVYsQ0FBZ0IsWUFBaEIsRUFBOEIsU0FBOUIsQ0FOb0IsRUFRcEIsQ0FBQzZKLEVBQUUsQ0FBQ2k5QyxpQkFBSixJQUF5Qmo5QyxFQUFFLENBQUM4VixZQUFILEVBUkwsR0FVckI5VixFQUFFLENBQUN1MEIscUJBQUgsQ0FBeUJGLFNBQXpCLENBVnFCLEVBWXJCcjBCLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVXpVLFNBQVYsQ0FBb0JtRCxFQUFFLENBQUNnK0MsZUFBSCxDQUFtQjNwQixTQUFuQixDQUFwQixFQUNFbCtCLEtBREYsQ0FDUSxZQURSLEVBQ3NCLFNBRHRCLEVBRUVnRSxVQUZGLEdBR0VoRSxLQUhGLENBR1EsU0FIUixFQUdtQixZQUFXO0FBQzVCLGFBQU82SixFQUFFLENBQUM0OUMsZ0JBQUgsQ0FBb0JyaEQsaUdBQVEsQ0FBQyxJQUFELENBQTVCLENBQVA7QUFDQSxLQUxGLENBWnFCO0FBa0JyQixHQTNSOEI7O0FBNlIvQjs7Ozs7QUFLQTBoRCxZQWxTK0Isc0JBa1NwQjVwQixTQWxTb0IsRUFrU1Q7QUFBQSxRQUNmcjBCLEVBQUUsR0FBRyxJQURVO0FBQUEsUUFFZnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkc7QUFJakJBLFVBQU0sQ0FBQ2lWLFdBQVAsSUFBc0J0ZixPQUFPLENBQUM4bEMsU0FBRCxDQUpaLEtBS3BCejdCLE1BQU0sQ0FBQ2lWLFdBQVAsS0FMb0IsRUFNcEI3TixFQUFFLENBQUNzUixNQUFILENBQVVuYixLQUFWLENBQWdCLFlBQWhCLEVBQThCLFFBQTlCLENBTm9CLEdBU3JCNkosRUFBRSxDQUFDMk4sa0JBQUgsQ0FBc0IwbUIsU0FBdEIsQ0FUcUIsRUFVckJyMEIsRUFBRSxDQUFDc1IsTUFBSCxDQUFVelUsU0FBVixDQUFvQm1ELEVBQUUsQ0FBQ2crQyxlQUFILENBQW1CM3BCLFNBQW5CLENBQXBCLEVBQ0VsK0IsS0FERixDQUNRLFNBRFIsRUFDbUIsR0FEbkIsRUFFRUEsS0FGRixDQUVRLFlBRlIsRUFFc0IsUUFGdEIsQ0FWcUI7QUFhckIsR0EvUzhCOztBQWlUL0I7Ozs7QUFJQStuRCw2QkFyVCtCLHlDQXFURDtBQUM3QixTQUFLbEIsaUJBQUwsR0FBeUIsRUFESTtBQUU3QixHQXZUOEI7O0FBeVQvQjs7Ozs7QUFLQU8sZUE5VCtCLHlCQThUakJZLElBOVRpQixFQThUWDtBQUFBLFFBQ2JuK0MsRUFBRSxHQUFHLElBRFE7QUFBQSxRQUVicEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQztBQUFBLFFBR2IyVixPQUFPLEdBQUd2TyxFQUFFLENBQUMwTSxTQUFILEtBQWlCLE9BSGQ7QUFLbkJ5eEMsUUFBSSxDQUNGbnRELElBREYsQ0FDTyxPQURQLEVBQ2dCLFVBQVNxUCxFQUFULEVBQWE7QUFBQSxVQUNyQjlQLElBQUksR0FBR2dNLGlHQUFRLENBQUMsSUFBRCxDQURNO0FBQUEsVUFFckI2aEQsU0FBUyxHQUFJLENBQUM3dEQsSUFBSSxDQUFDcEcsS0FBTCxFQUFELElBQWlCb0csSUFBSSxDQUFDUyxJQUFMLENBQVUsT0FBVixDQUFsQixJQUF5QyxFQUZoQztBQUkzQixhQUFPb3RELFNBQVMsR0FBR3ArQyxFQUFFLENBQUNpdEMsYUFBSCxDQUFpQjU2QyxjQUFLLENBQUN4SCxVQUF2QixFQUFtQ3dWLEVBQW5DLENBQW5CO0FBQ0EsS0FORixFQU9FbEssS0FQRixDQU9RLFlBUFIsRUFPc0IsVUFBQWtLLEVBQUU7QUFBQSxhQUFLTCxFQUFFLENBQUNvMEIsY0FBSCxDQUFrQi96QixFQUFsQixJQUF3QixTQUF4QixHQUFvQyxRQUF6QztBQUFBLEtBUHhCLEVBUUVsSyxLQVJGLENBUVEsUUFSUixFQVFrQixTQVJsQixFQVNFcVksRUFURixDQVNLLE9BVEwsRUFTYyxVQUFBbk8sRUFBRSxFQUFJO0FBQ2J2USxZQUFNLENBQUM4SSxNQUFNLENBQUM4cEIsbUJBQVIsRUFBNkIxaUIsRUFBN0IsRUFBaUNLLEVBQWpDLENBRE8sS0FFYnJPLHdGQUFPLENBQUNxc0QsTUFGSyxJQUdoQnIrQyxFQUFFLENBQUNpRCxHQUFILENBQU9pekMsSUFBUCxFQUhnQixFQUloQmwyQyxFQUFFLENBQUNpRCxHQUFILENBQU93NUMsSUFBUCxDQUFZcDhDLEVBQVosQ0FKZ0IsS0FNaEJMLEVBQUUsQ0FBQ2lELEdBQUgsQ0FBT3E3QyxNQUFQLENBQWNqK0MsRUFBZCxDQU5nQixFQU9oQixDQUFDa08sT0FBRCxJQUFZdk8sRUFBRSxDQUFDc1UsY0FBSCxDQUFrQmpVLEVBQWxCLENBQVosR0FBb0NMLEVBQUUsQ0FBQ2lELEdBQUgsQ0FBT29tQyxLQUFQLENBQWFocEMsRUFBYixDQUFwQyxHQUF1REwsRUFBRSxDQUFDaUQsR0FBSCxDQUFPdW1DLE1BQVAsRUFQdkMsSUFXbEJqN0IsT0FBTyxJQUFJdk8sRUFBRSxDQUFDNlYsV0FBSCxFQVhPO0FBWWxCLEtBckJGLENBTG1CLEVBNEJkdEgsT0E1QmMsSUE2QmxCNHZDLElBQUksQ0FDRjN2QyxFQURGLENBQ0ssVUFETCxFQUNpQixVQUFTbk8sRUFBVCxFQUFhO0FBQ3ZCdlEsWUFBTSxDQUFDOEksTUFBTSxDQUFDZ3FCLGlCQUFSLEVBQTJCNWlCLEVBQTNCLEVBQStCSyxFQUEvQixDQURpQixLQUUzQjlELGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWU0USxPQUFmLENBQXVCOWEsY0FBSyxDQUFDdEgsaUJBQTdCLEtBRjJCLEVBRzNCaVYsRUFBRSxDQUFDaUQsR0FBSCxDQUFPdW1DLE1BQVAsRUFIMkI7QUFLNUIsS0FORixFQU9FaDdCLEVBUEYsQ0FPSyxXQVBMLEVBT2tCLFVBQVNuTyxFQUFULEVBQWE7QUFDeEJ2USxZQUFNLENBQUM4SSxNQUFNLENBQUMrcEIsa0JBQVIsRUFBNEIzaUIsRUFBNUIsRUFBZ0NLLEVBQWhDLENBRGtCLEtBRTVCOUQsaUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZTRRLE9BQWYsQ0FBdUI5YSxjQUFLLENBQUN0SCxpQkFBN0IsS0FGNEIsRUFJeEIsQ0FBQ2lWLEVBQUUsQ0FBQzRKLFVBQUosSUFBa0I1SixFQUFFLENBQUNzVSxjQUFILENBQWtCalUsRUFBbEIsQ0FKTSxJQUszQkwsRUFBRSxDQUFDaUQsR0FBSCxDQUFPb21DLEtBQVAsQ0FBYWhwQyxFQUFiLENBTDJCO0FBUTdCLEtBZkYsQ0E3QmtCO0FBOENuQixHQTVXOEI7O0FBOFcvQjs7Ozs7O0FBTUErOEMscUJBcFgrQiwrQkFvWFgvb0IsU0FwWFcsRUFvWEEva0MsT0FwWEEsRUFvWFM7QUFBQSxRQVNuQ2l2RCxVQVRtQztBQUFBLFFBVW5DQyxVQVZtQztBQUFBLFFBa0JuQ0MsVUFsQm1DO0FBQUEsUUFDakN6K0MsRUFBRSxHQUFHLElBRDRCO0FBQUEsUUFFakNwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZxQjtBQUFBLFFBS2pDOGxELE1BQU0sR0FBRyxFQUx3QjtBQUFBLFFBTWpDQyxTQUFTLEdBQUcvbEQsTUFBTSxDQUFDbXFCLHNCQUFQLEdBQWdDLENBTlg7QUFBQSxRQU9uQ3RjLFFBQVEsR0FBRyxDQVB3QjtBQUFBLFFBUW5DbTRDLFNBQVMsR0FBRyxDQVJ1QjtBQUFBLFFBV25DQyxXQUFXLEdBQUcsQ0FYcUI7QUFBQSxRQVlqQ0MsT0FBTyxHQUFHLEVBWnVCO0FBQUEsUUFhakNDLE1BQU0sR0FBRyxFQWJ3QjtBQUFBLFFBY2pDQyxPQUFPLEdBQUcsRUFkdUI7QUFBQSxRQWVqQ0MsT0FBTyxHQUFHLENBQUMsQ0FBRCxDQWZ1QjtBQUFBLFFBZ0JqQ0MsS0FBSyxHQUFHLEVBaEJ5QjtBQUFBLFFBaUJuQzNSLElBQUksR0FBRyxDQWpCNEI7QUFBQSxRQW1CakM0UixvQkFBb0IsR0FBR24vQyxFQUFFLENBQUMyTCxhQUFILElBQW9CM0wsRUFBRSxDQUFDNkwsYUFuQmI7QUFBQSxRQXNCakNpeUMsU0FBUyxHQUFHenBCLFNBQVMsQ0FDekJyZ0MsTUFEZ0IsQ0FDVCxVQUFBcU0sRUFBRTtBQUFBLGFBQUksQ0FBQ3hTLFNBQVMsQ0FBQytLLE1BQU0sQ0FBQ3VuQixVQUFQLENBQWtCOWYsRUFBbEIsQ0FBRCxDQUFWLElBQXFDekgsTUFBTSxDQUFDdW5CLFVBQVAsQ0FBa0I5ZixFQUFsQixNQUEwQixJQUFuRTtBQUFBLEtBRE8sQ0F0QnFCO0FBQUEsUUF5QmpDK0csY0FBYyxHQUFHOVgsT0FBTyxDQUFDOFgsY0F6QlE7QUFBQSxRQTJCakNnNEMsVUFBVSxHQUFHLFVBQVMxSCxXQUFULEVBQXNCcjNDLEVBQXRCLEVBQTBCO0FBTTVDLGFBTEtMLEVBQUUsQ0FBQ2c5QyxpQkFBSCxDQUFxQjM4QyxFQUFyQixDQUtMLEtBSkNMLEVBQUUsQ0FBQ2c5QyxpQkFBSCxDQUFxQjM4QyxFQUFyQixJQUNDTCxFQUFFLENBQUNpM0MsV0FBSCxDQUFlUyxXQUFmLEVBQTRCcmxELGNBQUssQ0FBQ3hILFVBQWxDLENBR0YsR0FBT21WLEVBQUUsQ0FBQ2c5QyxpQkFBSCxDQUFxQjM4QyxFQUFyQixDQUFQO0FBQ0EsS0FsQ3NDO0FBQUEsUUFvQ2pDZy9DLGVBQWUsR0FBRyxVQUFTM0gsV0FBVCxFQUFzQnIzQyxFQUF0QixFQUEwQjFDLEtBQTFCLEVBQWlDO0FBQUEsVUFTcERpVixNQVRvRDtBQUFBLFVBRWxEMHNDLE1BQU0sR0FBRzNoRCxLQUFLLEtBQUttZ0QsU0FBUyxDQUFDdHZELE1BQVYsR0FBbUIsQ0FGWTtBQUFBLFVBR2xEK3dELEdBQUcsR0FBR0gsVUFBVSxDQUFDMUgsV0FBRCxFQUFjcjNDLEVBQWQsQ0FIa0M7QUFBQSxVQUlsRG0vQyxTQUFTLEdBQUdELEdBQUcsQ0FBQ2p1RCxLQUFKLEdBQVlxdEQsU0FBWixJQUNoQlcsTUFBTSxJQUFJLENBQUNILG9CQUFYLEdBQWtDLENBQWxDLEdBckNrQixFQW9DRixJQUNzQ3ZtRCxNQUFNLENBQUNrcUIsY0FMUDtBQUFBLFVBTWxEMjhCLFVBQVUsR0FBR0YsR0FBRyxDQUFDaHVELE1BQUosR0F2Q0QsQ0FpQ3NDO0FBQUEsVUFPbERtdUQsVUFBVSxHQUFHUCxvQkFBb0IsR0FBR00sVUFBSCxHQUFnQkQsU0FQQztBQUFBLFVBUWxERyxVQUFVLEdBQUdSLG9CQUFvQixHQUFHbi9DLEVBQUUsQ0FBQ2tTLGVBQUgsRUFBSCxHQUEwQmxTLEVBQUUsQ0FBQ2lTLGNBQUgsRUFSVDtBQUFBLFVBWWxEMnRDLFlBQVksR0FBRyxVQUFTQyxHQUFULEVBQWNDLFdBQWQsRUFBMkI7QUFDMUNBLG1CQUQwQyxLQUU5Q2x0QyxNQUFNLEdBQUcsQ0FBQytzQyxVQUFVLEdBQUdkLFdBQWIsR0FBMkJhLFVBQTVCLElBQTBDLENBRkwsRUFJMUM5c0MsTUFBTSxHQUFHOHJDLE1BSmlDLEtBSzdDOXJDLE1BQU0sR0FBRyxDQUFDK3NDLFVBQVUsR0FBR0QsVUFBZCxJQUE0QixDQUxRLEVBTTdDYixXQUFXLEdBQUcsQ0FOK0IsRUFPN0N0UixJQUFJLEVBUHlDLElBVy9DMlIsS0FBSyxDQUFDVyxHQUFELENBQUwsR0FBYXRTLElBWGtDLEVBWS9DMFIsT0FBTyxDQUFDMVIsSUFBRCxDQUFQLEdBQWdCdnRDLEVBQUUsQ0FBQzZMLGFBQUgsR0FBbUIsRUFBbkIsR0FBd0IrRyxNQVpPLEVBYS9Da3NDLE9BQU8sQ0FBQ2UsR0FBRCxDQUFQLEdBQWVoQixXQWJnQyxFQWMvQ0EsV0FBVyxJQUFJYSxVQWRnQztBQWUvQyxPQTNCdUQ7O0FBb0N4RCxVQW5DYy9oRCxLQUFLLEtBQUssQ0FtQ3hCLEtBTkNraEQsV0FBVyxHQUFHLENBTWYsRUFMQ3RSLElBQUksR0FBRyxDQUtSLEVBSkM5bUMsUUFBUSxHQUFHLENBSVosRUFIQ200QyxTQUFTLEdBQUcsQ0FHYixHQUFJaG1ELE1BQU0sQ0FBQ2lWLFdBQVAsSUFBc0IsQ0FBQzdOLEVBQUUsQ0FBQ28wQixjQUFILENBQWtCL3pCLEVBQWxCLENBQTNCLEVBTUMsT0FMQTArQyxNQUFNLENBQUMxK0MsRUFBRCxDQUFOLEdBQWEsQ0FLYixFQUpBMitDLE9BQU8sQ0FBQzMrQyxFQUFELENBQVAsR0FBYyxDQUlkLEVBSEE2K0MsS0FBSyxDQUFDNytDLEVBQUQsQ0FBTCxHQUFZLENBR1osUUFGQXkrQyxPQUFPLENBQUN6K0MsRUFBRCxDQUFQLEdBQWMsQ0FFZDtBQUdEMCtDLFlBQU0sQ0FBQzErQyxFQUFELENBQU4sR0FBYW0vQyxTQTdDMkMsRUE4Q3hEUixPQUFPLENBQUMzK0MsRUFBRCxDQUFQLEdBQWNvL0MsVUE5QzBDLEdBZ0RwRCxDQUFDaDVDLFFBQUQsSUFBYSs0QyxTQUFTLElBQUkvNEMsUUFoRDBCLE1BaUR2REEsUUFBUSxHQUFHKzRDLFNBakQ0QyxJQW9EcEQsQ0FBQ1osU0FBRCxJQUFjYSxVQUFVLElBQUliLFNBcER3QixNQXFEdkRBLFNBQVMsR0FBR2EsVUFyRDJDO0FBd0R4RCxVQUFNTSxTQUFTLEdBQUdaLG9CQUFvQixHQUFHUCxTQUFILEdBQWVuNEMsUUFBckQ7QUFFSTdOLFlBQU0sQ0FBQ2lxQixjQTFENkMsSUEyRHZEbjBCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZb3dELE1BQVosRUFBb0JsdkQsT0FBcEIsQ0FBNEIsVUFBQWd3RCxHQUFHO0FBQUEsZUFBS2QsTUFBTSxDQUFDYyxHQUFELENBQU4sR0FBY3A1QyxRQUFuQjtBQUFBLE9BQS9CLENBM0R1RCxFQTREdkQvWCxNQUFNLENBQUNDLElBQVAsQ0FBWXF3RCxPQUFaLEVBQXFCbnZELE9BQXJCLENBQTZCLFVBQUFnd0QsR0FBRztBQUFBLGVBQUtiLE9BQU8sQ0FBQ2EsR0FBRCxDQUFQLEdBQWVqQixTQUFwQjtBQUFBLE9BQWhDLENBNUR1RCxFQTZEdkRoc0MsTUFBTSxHQUFHLENBQUMrc0MsVUFBVSxHQUFHSSxTQUFTLEdBQUdqQyxTQUFTLENBQUN0dkQsTUFBcEMsSUFBOEMsQ0E3REEsRUErRG5Eb2tCLE1BQU0sR0FBRzhyQyxNQS9EMEMsSUFnRXRERyxXQUFXLEdBQUcsQ0FoRXdDLEVBaUV0RHRSLElBQUksR0FBRyxDQWpFK0MsRUFrRXREdVEsU0FBUyxDQUFDanVELE9BQVYsQ0FBa0IsVUFBQWd3RCxHQUFHO0FBQUEsZUFBSUQsWUFBWSxDQUFDQyxHQUFELENBQWhCO0FBQUEsT0FBckIsQ0FsRXNELElBb0V0REQsWUFBWSxDQUFDdi9DLEVBQUQsS0FwRTBDLElBdUV2RHUvQyxZQUFZLENBQUN2L0MsRUFBRCxDQXZFMkM7QUF5RXhELEtBN0dzQzs7QUErR25DTCxNQUFFLENBQUM2TCxhQS9HZ0MsS0FnSHRDMGhDLElBQUksR0FBRzMwQyxNQUFNLENBQUM2cEIsaUJBQVAsR0FBMkI3cEIsTUFBTSxDQUFDNnBCLGlCQUFsQyxHQUFzRHE3QixTQUFTLENBQUN0dkQsTUFoSGpDLEVBaUh0Q3dSLEVBQUUsQ0FBQ3k5QyxnQkFBSCxDQUFvQmxRLElBQXBCLENBakhzQyxHQW9IbkN2dEMsRUFBRSxDQUFDMkwsYUFwSGdDLElBcUh0QzR5QyxVQUFVLEdBQUcsVUFBQWwrQyxFQUFFO0FBQUEsYUFBSW9HLFFBQVEsR0FBR3k0QyxLQUFLLENBQUM3K0MsRUFBRCxDQUFwQjtBQUFBLEtBckh1QixFQXNIdENtK0MsVUFBVSxHQUFHLFVBQUFuK0MsRUFBRTtBQUFBLGFBQUk0K0MsT0FBTyxDQUFDQyxLQUFLLENBQUM3K0MsRUFBRCxDQUFOLENBQVAsR0FBcUJ5K0MsT0FBTyxDQUFDeitDLEVBQUQsQ0FBaEM7QUFBQSxLQXRIdUIsSUF1SDVCTCxFQUFFLENBQUM2TCxhQXZIeUIsSUF3SHRDMHlDLFVBQVUsR0FBRyxVQUFBbCtDLEVBQUU7QUFBQSxhQUFJb0csUUFBUSxHQUFHeTRDLEtBQUssQ0FBQzcrQyxFQUFELENBQWhCLEdBQXVCLEVBQTNCO0FBQUEsS0F4SHVCLEVBeUh0Q20rQyxVQUFVLEdBQUcsVUFBQW4rQyxFQUFFO0FBQUEsYUFBSTQrQyxPQUFPLENBQUNDLEtBQUssQ0FBQzcrQyxFQUFELENBQU4sQ0FBUCxHQUFxQnkrQyxPQUFPLENBQUN6K0MsRUFBRCxDQUFoQztBQUFBLEtBekh1QixLQTJIdENrK0MsVUFBVSxHQUFHLFVBQUFsK0MsRUFBRTtBQUFBLGFBQUk0K0MsT0FBTyxDQUFDQyxLQUFLLENBQUM3K0MsRUFBRCxDQUFOLENBQVAsR0FBcUJ5K0MsT0FBTyxDQUFDeitDLEVBQUQsQ0FBaEM7QUFBQSxLQTNIdUIsRUE0SHRDbStDLFVBQVUsR0FBRyxVQUFBbitDLEVBQUU7QUFBQSxhQUFJdStDLFNBQVMsR0FBR00sS0FBSyxDQUFDNytDLEVBQUQsQ0FBckI7QUFBQSxLQTVIdUI7O0FBQUEsUUErSGpDMi9DLGNBQWMsR0FBRyxVQUFDMy9DLEVBQUQsRUFBS3ZQLENBQUw7QUFBQSxhQUFXeXRELFVBQVUsQ0FBQ2wrQyxFQUFELEVBQUt2UCxDQUFMLENBQVYsR0FBb0IsQ0FBcEIsR0FBd0I4SCxNQUFNLENBQUNtcUIsc0JBQTFDO0FBQUEsS0EvSGdCO0FBQUEsUUFnSWpDazlCLGNBQWMsR0FBRyxVQUFDNS9DLEVBQUQsRUFBS3ZQLENBQUw7QUFBQSxhQUFXeXRELFVBQVUsQ0FBQ2wrQyxFQUFELEVBQUt2UCxDQUFMLENBQXJCO0FBQUEsS0FoSWdCO0FBQUEsUUFpSWpDb3ZELGVBQWUsR0FBRyxVQUFDNy9DLEVBQUQsRUFBS3ZQLENBQUw7QUFBQSxhQUFXeXRELFVBQVUsQ0FBQ2wrQyxFQUFELEVBQUt2UCxDQUFMLENBQVYsR0FBb0IsQ0FBL0I7QUFBQSxLQWpJZTtBQUFBLFFBa0lqQ3F2RCxlQUFlLEdBQUcsVUFBQzkvQyxFQUFELEVBQUt2UCxDQUFMO0FBQUEsYUFBV3l0RCxVQUFVLENBQUNsK0MsRUFBRCxFQUFLdlAsQ0FBTCxDQUFWLEdBQW9CLENBQXBCLEdBQXdCOEgsTUFBTSxDQUFDbXFCLHNCQUExQztBQUFBLEtBbEllO0FBQUEsUUFvSWpDcTlCLGNBQWMsR0FBRyxVQUFDLy9DLEVBQUQsRUFBS3ZQLENBQUw7QUFBQSxhQUFXMHRELFVBQVUsQ0FBQ24rQyxFQUFELEVBQUt2UCxDQUFMLENBQVYsR0FBb0IsQ0FBL0I7QUFBQSxLQXBJZ0I7QUFBQSxRQXFJakN1dkQsY0FBYyxHQUFHLFVBQUNoZ0QsRUFBRCxFQUFLdlAsQ0FBTDtBQUFBLGFBQVcwdEQsVUFBVSxDQUFDbitDLEVBQUQsRUFBS3ZQLENBQUwsQ0FBVixHQUFvQixDQUEvQjtBQUFBLEtBcklnQjtBQUFBLFFBc0lqQ3d2RCxjQUFjLEdBQUcsVUFBQ2pnRCxFQUFELEVBQUt2UCxDQUFMO0FBQUEsYUFBVzB0RCxVQUFVLENBQUNuK0MsRUFBRCxFQUFLdlAsQ0FBTCxDQUFWLEdBQW9CLENBQS9CO0FBQUEsS0F0SWdCO0FBQUEsUUF3SWpDeU4sR0FBRyxHQUFHLENBQUMsR0F4STBCO0FBQUEsUUEySWpDcTNDLENBQUMsR0FBRzUxQyxFQUFFLENBQUNzUixNQUFILENBQVV6VSxTQUFWLFlBQXdCeEssY0FBSyxDQUFDeEgsVUFBOUIsR0FDUmtKLElBRFEsQ0FDSCtwRCxTQURHLEVBRVJoaEQsS0FGUSxHQUdSL0wsTUFIUSxDQUdELEdBSEMsQ0EzSTZCOztBQWdKdkNpUCxNQUFFLENBQUN1OUMsYUFBSCxDQUFpQjNILENBQWpCLENBaEp1QyxFQWtKdkNBLENBQUMsQ0FBQzdrRCxNQUFGLENBQVMsTUFBVCxFQUNFNUUsSUFERixDQUNPLFVBQUFrVSxFQUFFO0FBQUEsYUFBS3hTLFNBQVMsQ0FBQytLLE1BQU0sQ0FBQ3VuQixVQUFQLENBQWtCOWYsRUFBbEIsQ0FBRCxDQUFULEdBQW1DekgsTUFBTSxDQUFDdW5CLFVBQVAsQ0FBa0I5ZixFQUFsQixDQUFuQyxHQUEyREEsRUFBaEU7QUFBQSxLQURULEVBRUUvRCxJQUZGLENBRU8sVUFBUytELEVBQVQsRUFBYXZQLENBQWIsRUFBZ0I7QUFDckJ1dUQscUJBQWUsQ0FBQyxJQUFELEVBQU9oL0MsRUFBUCxFQUFXdlAsQ0FBWCxDQURNO0FBRXJCLEtBSkYsRUFLRXFGLEtBTEYsQ0FLUSxnQkFMUixFQUswQixNQUwxQixFQU1FbkYsSUFORixDQU1PLEdBTlAsRUFNWW11RCxvQkFBb0IsR0FBR2EsY0FBSCxHQUFvQnpoRCxHQU5wRCxFQU9Fdk4sSUFQRixDQU9PLEdBUFAsRUFPWW11RCxvQkFBb0IsR0FBRzVnRCxHQUFILEdBQVM2aEQsY0FQekMsQ0FsSnVDLEVBMkp2Q3hLLENBQUMsQ0FBQzdrRCxNQUFGLENBQVMsTUFBVCxFQUNFQyxJQURGLENBQ08sT0FEUCxFQUNnQnFCLGNBQUssQ0FBQ3ZILGVBRHRCLEVBRUVxTCxLQUZGLENBRVEsY0FGUixFQUV3QixHQUZ4QixFQUdFbkYsSUFIRixDQUdPLEdBSFAsRUFHWW11RCxvQkFBb0IsR0FBR2MsY0FBSCxHQUFvQjFoRCxHQUhwRCxFQUlFdk4sSUFKRixDQUlPLEdBSlAsRUFJWW11RCxvQkFBb0IsR0FBRzVnRCxHQUFILEdBQVM4aEQsY0FKekMsQ0EzSnVDO0FBaUt2QyxRQUFNRSxRQUFRLEdBQUd2Z0QsRUFBRSxDQUFDcEgsTUFBSCxDQUFVcXFCLGVBQTNCOztBQUVBLFFBQUlzOUIsUUFBSixFQUFjO0FBQ2IsVUFBTXp5QixHQUFHLEdBQUcsRUFBWjtBQUVBOG5CLE9BQUMsQ0FBQzdrRCxNQUFGLENBQVMsVUFBQTFDLENBQUMsRUFBSTtBQUNiLFlBQU1tbEQsT0FBTyxHQUFHM2tELFFBQVEsQ0FBQytKLE1BQU0sQ0FBQzR0QixhQUFSLENBQVIsR0FDZjV0QixNQUFNLENBQUM0dEIsYUFEUSxHQUNRLENBQUM1dEIsTUFBTSxDQUFDOHRCLFVBQVIsQ0FEeEI7QUFHQW9ILFdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwRyxDQUFaLE1BQW1CLENBQUMsQ0FBcEIsSUFBeUJ5L0IsR0FBRyxDQUFDejRCLElBQUosQ0FBU2hILENBQVQsQ0FKWjtBQU1iLFlBQUk0YixLQUFLLEdBQUd1cEMsT0FBTyxDQUFDMWxCLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwRyxDQUFaLElBQWlCbWxELE9BQU8sQ0FBQ2hsRCxNQUExQixDQUFuQjtBQU1BLGVBSkl5YixLQUFLLEtBQUssV0FJZCxLQUhDQSxLQUFLLEdBQUcsTUFHVCxHQUFPMWlCLFFBQVEsQ0FBQzByRCxlQUFULENBQXlCQyw2RkFBWSxDQUFDeHNDLEdBQXRDLEVBQTJDMUcsRUFBRSxDQUFDZ2pDLGlCQUFILENBQXFCLzRCLEtBQXJCLElBQThCQSxLQUE5QixHQUFzQyxLQUFqRixDQUFQO0FBQ0EsT0FiRCxFQWNFalosSUFkRixDQWNPLE9BZFAsRUFjZ0JxQixjQUFLLENBQUNwSCxlQWR0QixFQWVFa0wsS0FmRixDQWVRLE1BZlIsRUFlZ0IsVUFBQTlILENBQUM7QUFBQSxlQUFJMlIsRUFBRSxDQUFDNkosS0FBSCxDQUFTeGIsQ0FBVCxDQUFKO0FBQUEsT0FmakIsRUFnQkU4SCxLQWhCRixDQWdCUSxnQkFoQlIsRUFnQjBCLE1BaEIxQixFQWlCRW5GLElBakJGLENBaUJPLE1BakJQLEVBaUJlLFVBQUMrQyxJQUFELEVBQU80dUMsR0FBUCxFQUFZN3dDLFNBQVosRUFBMEI7QUFBQSxZQUNqQ3ZCLElBQUksR0FBR3VCLFNBQVMsQ0FBQzZ3QyxHQUFELENBRGlCO0FBQUEsWUFFakNNLFFBQVEsR0FBRzF5QyxJQUFJLENBQUMweUMsUUFBTCxDQUFjejZCLFdBQWQsRUFGc0I7QUFJdkMsZUFBT3k2QixRQUFRLEtBQUssS0FBYixjQUF5QmpqQyxFQUFFLENBQUNxSixVQUE1QixvQkFBZ0R0VixJQUFoRCxJQUF5RGtCLFNBQWhFO0FBQ0EsT0F0QkYsQ0FIYTtBQTBCYixLQTFCRCxNQTJCQzJnRCxDQUFDLENBQUM3a0QsTUFBRixDQUFTLE1BQVQsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JxQixjQUFLLENBQUNuSCxjQUR0QixFQUVFaUwsS0FGRixDQUVRLFFBRlIsRUFFa0I2SixFQUFFLENBQUM2SixLQUZyQixFQUdFMVQsS0FIRixDQUdRLGdCQUhSLEVBRzBCLE1BSDFCLEVBSUVuRixJQUpGLENBSU8sSUFKUCxFQUlhbXVELG9CQUFvQixHQUFHZSxlQUFILEdBQXFCM2hELEdBSnRELEVBS0V2TixJQUxGLENBS08sSUFMUCxFQUthbXVELG9CQUFvQixHQUFHNWdELEdBQUgsR0FBUytoRCxjQUwxQyxFQU1FdHZELElBTkYsQ0FNTyxJQU5QLEVBTWFtdUQsb0JBQW9CLEdBQUdnQixlQUFILEdBQXFCNWhELEdBTnRELEVBT0V2TixJQVBGLENBT08sSUFQUCxFQU9hbXVELG9CQUFvQixHQUFHNWdELEdBQUgsR0FBUytoRCxjQVAxQyxFQVFFdHZELElBUkYsQ0FRTyxjQVJQLEVBUXVCNEgsTUFBTSxDQUFDb3FCLHVCQVI5QixDQTNCRCxDQW5LdUMsQ0F5TXZDOzs7QUFDQXk3QixjQUFVLEdBQUd6K0MsRUFBRSxDQUFDc1IsTUFBSCxDQUFVbGYsTUFBVixZQUFxQkMsY0FBSyxDQUFDekgsZ0JBQTNCLFdBMU0wQixFQTRNbkNvVixFQUFFLENBQUM2TCxhQUFILElBQW9CcEYsUUFBUSxHQUFHLENBQS9CLElBQW9DZzRDLFVBQVUsQ0FBQ3JrRCxJQUFYLE9BQXNCLENBNU12QixLQTZNdENxa0QsVUFBVSxHQUFHeitDLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVWxVLE1BQVYsQ0FBaUIsR0FBakIsYUFBMEIvSyxjQUFLLENBQUN4SCxVQUFoQyxHQUNYbUcsSUFEVyxDQUNOLE9BRE0sRUFDR3FCLGNBQUssQ0FBQ3pILGdCQURULEVBRVhtRyxNQUZXLENBRUosTUFGSSxDQTdNeUI7QUFrTnZDLFFBQU0zRSxLQUFLLEdBQUc0VCxFQUFFLENBQUNzUixNQUFILENBQVV6VSxTQUFWLENBQW9CLE1BQXBCLEVBQ1o5SSxJQURZLENBQ1ArcEQsU0FETyxFQUVaM3hELElBRlksQ0FFUCxVQUFBa1UsRUFBRTtBQUFBLGFBQUt4UyxTQUFTLENBQUMrSyxNQUFNLENBQUN1bkIsVUFBUCxDQUFrQjlmLEVBQWxCLENBQUQsQ0FBVCxHQUFtQ3pILE1BQU0sQ0FBQ3VuQixVQUFQLENBQWtCOWYsRUFBbEIsQ0FBbkMsR0FBMkRBLEVBQWhFO0FBQUEsS0FGSyxFQUVnRTtBQUZoRSxLQUdaL0QsSUFIWSxDQUdQLFVBQVMrRCxFQUFULEVBQWF2UCxDQUFiLEVBQWdCO0FBQ3JCdXVELHFCQUFlLENBQUMsSUFBRCxFQUFPaC9DLEVBQVAsRUFBV3ZQLENBQVgsQ0FETTtBQUVyQixLQUxZLENBQWQ7QUFPQSxLQUFDc1csY0FBYyxHQUFHaGIsS0FBSyxDQUFDK04sVUFBTixFQUFILEdBQXdCL04sS0FBdkMsRUFDRTRFLElBREYsQ0FDTyxHQURQLEVBQ1lndkQsY0FEWixFQUVFaHZELElBRkYsQ0FFTyxHQUZQLEVBRVlvdkQsY0FGWixDQXpOdUM7QUE2TnZDLFFBQU1JLEtBQUssR0FBR3hnRCxFQUFFLENBQUNzUixNQUFILENBQVV6VSxTQUFWLGdCQUE0QnhLLGNBQUssQ0FBQ3ZILGVBQWxDLEdBQ1ppSixJQURZLENBQ1ArcEQsU0FETyxDQUFkOztBQVVBLFFBUEEsQ0FBQzEyQyxjQUFjLEdBQUdvNUMsS0FBSyxDQUFDcm1ELFVBQU4sRUFBSCxHQUF3QnFtRCxLQUF2QyxFQUNFeHZELElBREYsQ0FDTyxPQURQLEVBQ2dCLFVBQUFxUCxFQUFFO0FBQUEsYUFBSTArQyxNQUFNLENBQUMxK0MsRUFBRCxDQUFWO0FBQUEsS0FEbEIsRUFFRXJQLElBRkYsQ0FFTyxRQUZQLEVBRWlCLFVBQUFxUCxFQUFFO0FBQUEsYUFBSTIrQyxPQUFPLENBQUMzK0MsRUFBRCxDQUFYO0FBQUEsS0FGbkIsRUFHRXJQLElBSEYsQ0FHTyxHQUhQLEVBR1lpdkQsY0FIWixFQUlFanZELElBSkYsQ0FJTyxHQUpQLEVBSVlxdkQsY0FKWixDQU9BLEVBQUlFLFFBQUosRUFBYztBQUNiLFVBQU1FLEtBQUssR0FBR3pnRCxFQUFFLENBQUNzUixNQUFILENBQVV6VSxTQUFWLFlBQXdCeEssY0FBSyxDQUFDcEgsZUFBOUIsR0FDWjhJLElBRFksQ0FDUCtwRCxTQURPLENBQWQ7QUFHQSxPQUFDMTJDLGNBQWMsR0FBR3E1QyxLQUFLLENBQUN0bUQsVUFBTixFQUFILEdBQXdCc21ELEtBQXZDLEVBQ0Vua0QsSUFERixDQUNPLFlBQVc7QUFBQSxZQU9aeW9DLE1BUFk7QUFBQSxZQVFaenpDLEtBUlk7QUFBQSxZQVNaQyxNQVRZO0FBQUEsWUFDVjB4QyxRQUFRLEdBQUcsS0FBS0EsUUFBTCxDQUFjejZCLFdBQWQsRUFERDtBQUFBLFlBRVZpcEMsTUFBTSxHQUFHenhDLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXd0QixPQUZUO0FBQUEsWUFHWmgxQixDQUFDLEdBQUcsR0FIUTtBQUFBLFlBSVpDLENBQUMsR0FBRyxHQUpRO0FBQUEsWUFLWis5QyxPQUFPLEdBQUcsQ0FMRTtBQUFBLFlBTVpzUixPQUFPLEdBQUcsR0FORTs7QUFXaEIsWUFBSXpkLFFBQVEsS0FBSyxRQUFqQixFQUEyQjtBQUMxQixjQUFNN29DLElBQUksR0FBR3EzQyxNQUFNLEdBQUcsRUFBdEI7QUFFQXJnRCxXQUFDLEdBQUcsSUFIc0IsRUFJMUJDLENBQUMsR0FBRyxJQUpzQixFQUsxQjB6QyxNQUFNLEdBQUcwTSxNQUFNLEdBQUdyM0MsSUFMUSxFQU0xQmcxQyxPQUFPLEdBQUdxQyxNQUFNLEdBQUcsQ0FOTyxFQU8xQmlQLE9BQU8sR0FBRyxDQUFDdG1ELElBUGU7QUFRMUIsU0FSRCxNQVFPLElBQUk2b0MsUUFBUSxLQUFLLE1BQWpCLEVBQXlCO0FBQy9CLGNBQU03b0MsS0FBSSxHQUFHcTNDLE1BQU0sR0FBRyxHQUF0Qjs7QUFFQW5nRCxlQUFLLEdBQUc4SSxLQUh1QixFQUkvQjdJLE1BQU0sR0FBRzZJLEtBSnNCLEVBSy9Cc21ELE9BQU8sR0FBRyxDQUxxQjtBQU0vQjs7QUFFRG5rRCx5R0FBUSxDQUFDLElBQUQsQ0FBUixDQUNFdkwsSUFERixDQUNPSSxDQURQLEVBQ1UsVUFBQS9DLENBQUM7QUFBQSxpQkFBSTZ4RCxlQUFlLENBQUM3eEQsQ0FBRCxDQUFmLEdBQXFCK2dELE9BQXpCO0FBQUEsU0FEWCxFQUVFcCtDLElBRkYsQ0FFT0ssQ0FGUCxFQUVVLFVBQUFoRCxDQUFDO0FBQUEsaUJBQUlpeUQsY0FBYyxDQUFDanlELENBQUQsQ0FBZCxHQUFvQnF5RCxPQUF4QjtBQUFBLFNBRlgsRUFHRTF2RCxJQUhGLENBR08sR0FIUCxFQUdZK3pDLE1BSFosRUFJRS96QyxJQUpGLENBSU8sT0FKUCxFQUlnQk0sS0FKaEIsRUFLRU4sSUFMRixDQUtPLFFBTFAsRUFLaUJPLE1BTGpCLENBM0JnQjtBQWlDaEIsT0FsQ0YsQ0FKYTtBQXVDYixLQXZDRCxNQXVDTztBQUNOLFVBQU1rdkQsTUFBSyxHQUFHemdELEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVXpVLFNBQVYsZ0JBQTRCeEssY0FBSyxDQUFDbkgsY0FBbEMsR0FDWjZJLElBRFksQ0FDUCtwRCxTQURPLENBQWQ7O0FBR0EsT0FBQzEyQyxjQUFjLEdBQUdxNUMsTUFBSyxDQUFDdG1ELFVBQU4sRUFBSCxHQUF3QnNtRCxNQUF2QyxFQUNFdHFELEtBREYsQ0FDUSxRQURSLEVBQ2tCNkosRUFBRSxDQUFDNkosS0FEckIsRUFFRTdZLElBRkYsQ0FFTyxJQUZQLEVBRWFrdkQsZUFGYixFQUdFbHZELElBSEYsQ0FHTyxJQUhQLEVBR2FzdkQsY0FIYixFQUlFdHZELElBSkYsQ0FJTyxJQUpQLEVBSWFtdkQsZUFKYixFQUtFbnZELElBTEYsQ0FLTyxJQUxQLEVBS2FzdkQsY0FMYixDQUpNO0FBVU47O0FBRUc3QixjQTFSbUMsSUEyUnRDLENBQUNyM0MsY0FBYyxHQUFHcTNDLFVBQVUsQ0FBQ3RrRCxVQUFYLEVBQUgsR0FBNkJza0QsVUFBNUMsRUFDRXp0RCxJQURGLENBQ08sUUFEUCxFQUNpQmdQLEVBQUUsQ0FBQ2tTLGVBQUgsS0FBdUIsRUFEeEMsRUFFRWxoQixJQUZGLENBRU8sT0FGUCxFQUVnQnlWLFFBQVEsSUFBSThtQyxJQUFJLEdBQUcsQ0FBWCxDQUFSLEdBQXdCLEVBRnhDLENBM1JzQyxFQXFTdkN2dEMsRUFBRSxDQUFDMDlDLHFCQUFILENBQXlCajNDLFFBQXpCLENBclN1QyxFQXNTdkN6RyxFQUFFLENBQUMyOUMsc0JBQUgsQ0FBMEJpQixTQUExQixDQXRTdUMsRUF1U3ZDNStDLEVBQUUsQ0FBQ3k5QyxnQkFBSCxDQUFvQmxRLElBQXBCLENBdlN1QztBQXdTdkM7QUE1cEI4QixDQUExQixDOztBQ2JOOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0EsSUFBTW9ULFVBQVUsR0FBRyxZQUF5QjtBQUFBLE1BQ3ZDMzdDLFFBRHVDO0FBQUEsTUFBeEJ6RyxHQUF3Qix1RUFBbEIsTUFBa0I7QUFBQSxNQUFWak4sS0FBVTtBQUFBLE1BRXJDc3ZELEtBQUssR0FBR2p6RCxRQUFRLENBQUMyRCxLQUFELENBRnFCO0FBWTNDLFNBUEMwVCxRQU9ELEdBUkl6RyxHQUFHLENBQUM1VyxPQUFKLENBQVksUUFBWixJQUF3QixDQUFDLENBUTdCLEdBUFlpNUQsS0FBSyxHQUFHdHZELEtBQUssR0FBRyxDQUFYLEdBQWUsUUFPaEMsR0FOV2lOLEdBQUcsQ0FBQzVXLE9BQUosQ0FBWSxPQUFaLElBQXVCLENBQUMsQ0FNbkMsR0FMWWk1RCxLQUFLLEdBQUd0dkQsS0FBSCxHQUFXLEtBSzVCLEdBSFlzdkQsS0FBSyxHQUFHLENBQUgsR0FBTyxPQUd4QixFQUFPNTdDLFFBQVA7QUFDQSxDQWJEOztBQWVBclMsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I7Ozs7QUFJQXBQLFdBTCtCLHVCQUtuQjtBQUNYLFFBQU03UCxFQUFFLEdBQUcsSUFBWDs7QUFFQSxRQUFJQSxFQUFFLENBQUNwSCxNQUFILENBQVV1eUIsVUFBZCxFQUEwQjtBQUN6Qm5yQixRQUFFLENBQUMzVCxLQUFILEdBQVcyVCxFQUFFLENBQUMwRyxHQUFILENBQU8zVixNQUFQLENBQWMsR0FBZCxDQURjO0FBR3pCLFVBQU01RSxJQUFJLEdBQUc2VCxFQUFFLENBQUMzVCxLQUFILENBQ1gwRSxNQURXLENBQ0osTUFESSxFQUVYb0YsS0FGVyxDQUVMLGFBRkssRUFFVXdxRCxVQUFVLENBQUMzZ0QsRUFBRSxDQUFDcEgsTUFBSCxDQUFVeXlCLGNBQVgsQ0FGcEIsRUFHWHI2QixJQUhXLENBR04sT0FITSxFQUdHcUIsY0FBSyxDQUFDaEcsS0FIVCxDQUFiO0FBS0FpRSxrQkFBWSxDQUFDbkUsSUFBRCxFQUFPNlQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdXlCLFVBQWpCLEVBQTZCLENBQUMsRUFBRCxFQUFNLEdBQU4sQ0FBN0IsQ0FSYTtBQVN6QjtBQUNELEdBbEI4Qjs7QUFvQi9COzs7O0FBSUF6VSxhQXhCK0IseUJBd0JqQjtBQUNiLFFBQU0xVyxFQUFFLEdBQUcsSUFBWDs7QUFFQSxRQUFJQSxFQUFFLENBQUMzVCxLQUFQLEVBQWM7QUFDYixVQUFNZ0YsQ0FBQyxHQUFHMk8sRUFBRSxDQUFDNmdELFNBQUgsQ0FBYTN3RCxJQUFiLENBQWtCOFAsRUFBbEIsQ0FBVjtBQUVJLFdBQUtoRyxJQUFMLENBQVVnRyxFQUFFLENBQUMzVCxLQUFILENBQVNrRSxJQUFULEdBQWdCMHdDLE9BQTFCLENBSFMsR0FJWmpoQyxFQUFFLENBQUMzVCxLQUFILENBQVMyRSxJQUFULENBQWMsV0FBZCxzQkFBd0MydkQsVUFBVSxDQUFDM2dELEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXl5QixjQUFYLEVBQTJCcnJCLEVBQUUsQ0FBQ3NULFlBQTlCLENBQWxELGVBQWtHamlCLENBQWxHLE9BSlksR0FNWjJPLEVBQUUsQ0FBQzNULEtBQUgsQ0FBUzJFLElBQVQsQ0FBYyxHQUFkLEVBQW1CZ1AsRUFBRSxDQUFDOGdELFNBQUgsQ0FBYTV3RCxJQUFiLENBQWtCOFAsRUFBbEIsQ0FBbkIsRUFBMENoUCxJQUExQyxDQUErQyxHQUEvQyxFQUFvREssQ0FBcEQsQ0FOWTtBQVFiO0FBQ0QsR0FwQzhCOztBQXNDL0I7Ozs7O0FBS0F5dkQsV0EzQytCLHVCQTJDbkI7QUFBQSxRQUlQMXZELENBSk87QUFBQSxRQUNMNE8sRUFBRSxHQUFHLElBREE7QUFBQSxRQUVMcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGUDtBQUFBLFFBR0xvTSxRQUFRLEdBQUdwTSxNQUFNLENBQUN5eUIsY0FBUCxJQUF5QixNQUgvQjtBQWtCWCxXQVpJLGlCQUFpQnJ4QixJQUFqQixDQUFzQmdMLFFBQXRCLENBWUosSUFYQzVULENBQUMsR0FBRzRPLEVBQUUsQ0FBQ3NULFlBQUgsR0FBa0J0VCxFQUFFLENBQUNpM0MsV0FBSCxDQUFlajNDLEVBQUUsQ0FBQzNULEtBQWxCLEVBQXlCZ0csY0FBSyxDQUFDaEcsS0FBL0IsRUFBc0NpRixLQVc3RCxFQVRLMFQsUUFBUSxDQUFDcmQsT0FBVCxDQUFpQixPQUFqQixLQUE2QixDQVNsQyxHQVJFeUosQ0FBQyxJQUFLd0gsTUFBTSxDQUFDd3lCLGFBQVAsQ0FBcUI5ckIsS0FBckIsSUFBOEIsQ0FRdEMsR0FQWTBGLFFBQVEsQ0FBQ3JkLE9BQVQsQ0FBaUIsUUFBakIsS0FBOEIsQ0FPMUMsS0FORXlKLENBQUMsSUFBSSxDQU1QLEtBSENBLENBQUMsR0FBSXdILE1BQU0sQ0FBQ3d5QixhQUFQLENBQXFCNXJCLElBQXJCLElBQTZCLENBR25DLEVBQU9wTyxDQUFQO0FBQ0EsR0E5RDhCOztBQWdFL0I7Ozs7O0FBS0F5dkQsV0FyRStCLHVCQXFFbkI7QUFDWCxRQUFNN2dELEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBTyxDQUFDQSxFQUFFLENBQUNwSCxNQUFILENBQVV3eUIsYUFBVixDQUF3Qi9yQixHQUF4QixJQUErQixDQUFoQyxJQUNOVyxFQUFFLENBQUNpM0MsV0FBSCxDQUFlajNDLEVBQUUsQ0FBQzNULEtBQWxCLEVBQXlCZ0csY0FBSyxDQUFDaEcsS0FBL0IsRUFBc0NrRixNQUR2QztBQUVBLEdBMUU4Qjs7QUE0RS9COzs7OztBQUtBb3ZDLGlCQWpGK0IsNkJBaUZiO0FBQ2pCLFFBQU0zZ0MsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUM2Z0QsU0FBSCxNQUFrQjdnRCxFQUFFLENBQUNwSCxNQUFILENBQVV3eUIsYUFBVixDQUF3QjdyQixNQUF4QixJQUFrQyxDQUFwRCxDQUFQO0FBQ0E7QUFyRjhCLENBQTFCLEM7O0FDOUJOOzs7O0FBSUE7QUFDQTtBQUVBNU0sTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0IzVixVQUQrQixzQkFDcEI7QUFDVixRQUFNdEosRUFBRSxHQUFHLElBQVgsQ0FEVSxDQUdWOztBQU9BO0FBTkFBLE1BQUUsQ0FBQytPLE1BQUgsYUFBZS9PLEVBQUUsQ0FBQ3FKLFVBQWxCLFVBSlUsRUFNVnJKLEVBQUUsQ0FBQ2lQLGNBQUgsYUFBdUJqUCxFQUFFLENBQUMrTyxNQUExQixXQU5VLEVBT1YvTyxFQUFFLENBQUNtUCxjQUFILGFBQXVCblAsRUFBRSxDQUFDK08sTUFBMUIsV0FQVSxFQVFWL08sRUFBRSxDQUFDcVAsYUFBSCxhQUFzQnJQLEVBQUUsQ0FBQytPLE1BQXpCLFVBUlUsRUFXVi9PLEVBQUUsQ0FBQ2dRLFFBQUgsR0FBY2hRLEVBQUUsQ0FBQytnRCxXQUFILENBQWUvZ0QsRUFBRSxDQUFDK08sTUFBbEIsQ0FYSixFQVlWL08sRUFBRSxDQUFDYyxnQkFBSCxHQUFzQmQsRUFBRSxDQUFDK2dELFdBQUgsQ0FBZS9nRCxFQUFFLENBQUNpUCxjQUFsQixDQVpaLEVBYVZqUCxFQUFFLENBQUNnQixnQkFBSCxHQUFzQmhCLEVBQUUsQ0FBQytnRCxXQUFILENBQWUvZ0QsRUFBRSxDQUFDbVAsY0FBbEIsQ0FiWixFQWNWblAsRUFBRSxDQUFDZzVDLGVBQUgsR0FBcUJoNUMsRUFBRSxDQUFDK2dELFdBQUgsQ0FBZS9nRCxFQUFFLENBQUNxUCxhQUFsQixDQWRYO0FBZVYsR0FoQjhCO0FBa0IvQjB4QyxhQWxCK0IsdUJBa0JuQjFnRCxFQWxCbUIsRUFrQmY7QUFBQSxRQUNUTCxFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZIO0FBSWYsUUFBSyxDQUFDQSxNQUFNLENBQUNvWCxRQUFSLElBQW9CLFNBQVNoVyxJQUFULENBQWNxRyxFQUFkLENBQXJCLElBQ0YsQ0FBQ3pILE1BQU0sQ0FBQ3NxQixlQUFSLElBQTJCLGVBQWVscEIsSUFBZixDQUFvQnFHLEVBQXBCLENBRHpCLElBRUYsQ0FBQ3pILE1BQU0sQ0FBQ2lyQixlQUFSLElBQTJCLGVBQWU3cEIsSUFBZixDQUFvQnFHLEVBQXBCLENBRjdCLEVBR0MsT0FBTyxJQUFQO0FBR0QsUUFBTTJnRCxLQUFLLEdBQUc5NUQsTUFBTSxDQUFDTyxTQUFQLENBQWlCdzVELFVBQWpCLENBQ1p6NEMsV0FEWSxHQUNFN2dCLE9BREYsQ0FDVSxTQURWLEtBQ3dCLENBRHRDO0FBR0EseUJBQWVxNUQsS0FBSyxHQUFHLEVBQUgsR0FBUXo1RCxRQUFRLENBQUMyNUQsR0FBVCxDQUFhdHdELEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBNUIsY0FBMkR5UCxFQUEzRDtBQUNBLEdBaEM4QjtBQWtDL0J5TyxZQWxDK0Isc0JBa0NwQmt5QixNQWxDb0IsRUFrQ1ozZ0MsRUFsQ1ksRUFrQ1I7QUFDdEIsV0FBTzJnQyxNQUFNLENBQUNqd0MsTUFBUCxDQUFjLFVBQWQsRUFDTEMsSUFESyxDQUNBLElBREEsRUFDTXFQLEVBRE4sRUFFTHRQLE1BRkssQ0FFRSxNQUZGLENBQVA7QUFHQSxHQXRDOEI7QUF3Qy9Cb3dELGNBeEMrQix3QkF3Q2xCbGhELGFBeENrQixFQXdDSDtBQUMzQjtBQUNBLFFBQU1ULElBQUksR0FBR3hSLElBQUksQ0FBQ2tOLEdBQUwsQ0FBUyxFQUFULEVBQWEsS0FBSzBYLE1BQUwsQ0FBWXBULElBQXpCLENBQWI7QUFFQSxXQUFPUyxhQUFhLEdBQUcsRUFBRSxJQUFJVCxJQUFOLENBQUgsR0FBaUIsRUFBRUEsSUFBSSxHQUFHLENBQVQsQ0FBckM7QUFDQSxHQTdDOEI7QUErQy9CNGhELGNBL0MrQix3QkErQ2xCbmhELGFBL0NrQixFQStDSDtBQUMzQixXQUFPQSxhQUFhLEdBQUcsQ0FBQyxFQUFKLEdBQVMsQ0FBQyxLQUFLMlMsTUFBTCxDQUFZdlQsR0FBMUM7QUFDQSxHQWpEOEI7QUFtRC9CNGMsZUFuRCtCLDJCQW1EZjtBQUNmLFFBQU1qYyxFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQ21oRCxZQUFILENBQWdCLENBQUNuaEQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdUgsWUFBM0IsQ0FBUDtBQUNBLEdBdkQ4QjtBQXlEL0IrYixlQXpEK0IsMkJBeURmO0FBQ2YsUUFBTWxjLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDb2hELFlBQUgsQ0FBZ0IsQ0FBQ3BoRCxFQUFFLENBQUNwSCxNQUFILENBQVV1SCxZQUEzQixDQUFQO0FBQ0EsR0E3RDhCO0FBK0QvQmtjLGVBL0QrQiwyQkErRGY7QUFDZixRQUFNcmMsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNwSCxNQUFILENBQVVtSSxZQUFWLEdBQ04sQ0FBQyxDQURLLEdBQ0RmLEVBQUUsQ0FBQ21oRCxZQUFILENBQWdCbmhELEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBQTFCLENBRE47QUFFQSxHQXBFOEI7QUFzRS9CbWMsZUF0RStCLDJCQXNFZjtBQUNmLFFBQU10YyxFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQ29oRCxZQUFILENBQWdCcGhELEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBQTFCLENBQVA7QUFDQSxHQTFFOEI7QUE0RS9Ca2hELGtCQTVFK0IsNEJBNEVkcGhELGFBNUVjLEVBNEVDO0FBQUEsUUFDekJELEVBQUUsR0FBRyxJQURvQjtBQUFBLFFBRXpCUixJQUFJLEdBQUd4UixJQUFJLENBQUNrTixHQUFMLENBQVMsRUFBVCxFQUFhOEUsRUFBRSxDQUFDNFMsTUFBSCxDQUFVcFQsSUFBdkIsQ0FGa0I7QUFBQSxRQUd6QkYsS0FBSyxHQUFHdFIsSUFBSSxDQUFDa04sR0FBTCxDQUFTLEVBQVQsRUFBYThFLEVBQUUsQ0FBQzRTLE1BQUgsQ0FBVXRULEtBQXZCLENBSGlCO0FBSy9CO0FBQ0EsV0FBT1csYUFBYSxHQUNuQkQsRUFBRSxDQUFDMU8sS0FBSCxHQUFXLENBQVgsR0FBZWtPLElBQWYsR0FBc0JGLEtBREgsR0FDV1UsRUFBRSxDQUFDNFMsTUFBSCxDQUFVcFQsSUFBVixHQUFpQixFQURoRDtBQUVBLEdBcEY4QjtBQXNGL0I4aEQsbUJBdEYrQiw2QkFzRmJyaEQsYUF0RmEsRUFzRkU7QUFDaEM7QUFDQSxXQUFPLENBQUNBLGFBQWEsR0FBRyxLQUFLMlMsTUFBTCxDQUFZclQsTUFBZixHQUF5QixLQUFLcVQsTUFBTCxDQUFZdlQsR0FBWixHQUFrQixLQUFLOU4sTUFBOUQsSUFBeUUsRUFBaEY7QUFDQSxHQXpGOEI7QUEyRi9CNHFCLG1CQTNGK0IsK0JBMkZYO0FBQ25CLFFBQU1uYyxFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU9BLEVBQUUsQ0FBQ3FoRCxnQkFBSCxDQUFvQixDQUFDcmhELEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXVILFlBQS9CLENBQVA7QUFDQSxHQS9GOEI7QUFpRy9CaWMsb0JBakcrQixnQ0FpR1Y7QUFDcEIsUUFBTXBjLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBT0EsRUFBRSxDQUFDc2hELGlCQUFILENBQXFCLENBQUN0aEQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdUgsWUFBaEMsQ0FBUDtBQUNBLEdBckc4QjtBQXVHL0JvYyxtQkF2RytCLCtCQXVHWDtBQUNuQixRQUFNdmMsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNxaEQsZ0JBQUgsQ0FBb0JyaEQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdUgsWUFBOUIsS0FBK0NILEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVW1JLFlBQVYsR0FBeUIsRUFBekIsR0FBOEIsQ0FBN0UsQ0FBUDtBQUNBLEdBM0c4QjtBQTZHL0J5YixvQkE3RytCLGdDQTZHVjtBQUNwQixRQUFNeGMsRUFBRSxHQUFHLElBQVg7QUFFQSxXQUFPQSxFQUFFLENBQUNzaEQsaUJBQUgsQ0FBcUJ0aEQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVdUgsWUFBL0IsQ0FBUDtBQUNBO0FBakg4QixDQUExQixDOztBQ1BOOzs7O0NBSWlEOztBQUNqRDtBQUNBO0FBQ0E7QUFFQXhOLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9CbFAsWUFEK0Isd0JBQ2xCO0FBQ1osUUFBTS9QLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQ3pVLE1BQUgsR0FBWXlVLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUWxCLE1BQVIsQ0FBZSxHQUFmLEVBQ1ZDLElBRFUsQ0FDTCxXQURLLEVBQ1FnUCxFQUFFLENBQUNnUSxRQURYLEVBRVZoZixJQUZVLENBRUwsT0FGSyxFQUVJcUIsY0FBSyxDQUFDN0csT0FGVixDQUhBO0FBTVosR0FQOEI7QUFTL0IycUIsY0FUK0Isd0JBU2xCak8sUUFUa0IsRUFTUjtBQUFBLFFBQ2hCbEksRUFBRSxHQUFHLElBRFc7QUFBQSxRQUVoQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkk7QUFJdEI7QUFHQTtBQUZBb0gsTUFBRSxDQUFDelUsTUFBSCxDQUFVNEssS0FBVixDQUFnQixZQUFoQixFQUE4QjZKLEVBQUUsQ0FBQ2dTLFVBQUgsS0FBa0IsUUFBbEIsR0FBNkIsU0FBM0QsQ0FMc0IsRUFRdEJoUyxFQUFFLENBQUN1aEQsVUFBSCxHQUFnQnZoRCxFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQzdHLE9BQXpCLEdBQ2RxUixTQURjLFlBQ0F4SyxjQUFLLENBQUM5RyxNQUROLEdBRWR3SSxJQUZjLENBRVQ2RSxNQUFNLENBQUNwTixPQUZFLENBUk0sRUFZdEJ3VSxFQUFFLENBQUN1aEQsVUFBSCxDQUFjamtELElBQWQsR0FDRW5ELFVBREYsR0FFRStOLFFBRkYsQ0FFV0EsUUFGWCxFQUdFL1IsS0FIRixDQUdRLFNBSFIsRUFHbUIsR0FIbkIsRUFJRW9ILE1BSkYsRUFac0IsRUFrQnRCeUMsRUFBRSxDQUFDdWhELFVBQUgsR0FBZ0J2aEQsRUFBRSxDQUFDdWhELFVBQUgsQ0FBY3prRCxLQUFkLEdBQ2QvTCxNQURjLENBQ1AsR0FETyxFQUVkZ00sS0FGYyxDQUVSaUQsRUFBRSxDQUFDdWhELFVBRkssRUFHZHZ3RCxJQUhjLENBR1QsT0FIUyxFQUdBZ1AsRUFBRSxDQUFDd2hELFdBQUgsQ0FBZWhtRCxJQUFmLENBQW9Cd0UsRUFBcEIsQ0FIQSxDQWxCTSxFQXVCdEJBLEVBQUUsQ0FBQ3VoRCxVQUFILENBQ0V4d0QsTUFERixDQUNTLE1BRFQsRUFFRW9GLEtBRkYsQ0FFUSxjQUZSLEVBRXdCLEdBRnhCLENBdkJzQjtBQTBCdEIsR0FuQzhCO0FBcUMvQitqQixjQXJDK0Isd0JBcUNsQjlTLGNBckNrQixFQXFDRjtBQUFBLFFBQ3RCcEgsRUFBRSxHQUFHLElBRGlCO0FBQUEsUUFFeEJ4VSxPQUFPLEdBQUd3VSxFQUFFLENBQUN1aEQsVUFBSCxDQUFjbnZELE1BQWQsQ0FBcUIsTUFBckIsQ0FGYztBQVU1QixXQU5BNUcsT0FBTyxHQUFHLENBQUM0YixjQUFjLEdBQUc1YixPQUFPLENBQUMyTyxVQUFSLEVBQUgsR0FBMEIzTyxPQUF6QyxFQUNSd0YsSUFEUSxDQUNILEdBREcsRUFDRWdQLEVBQUUsQ0FBQ3loRCxPQUFILENBQVdqbUQsSUFBWCxDQUFnQndFLEVBQWhCLENBREYsRUFFUmhQLElBRlEsQ0FFSCxHQUZHLEVBRUVnUCxFQUFFLENBQUMwaEQsT0FBSCxDQUFXbG1ELElBQVgsQ0FBZ0J3RSxFQUFoQixDQUZGLEVBR1JoUCxJQUhRLENBR0gsT0FIRyxFQUdNZ1AsRUFBRSxDQUFDMmhELFdBQUgsQ0FBZW5tRCxJQUFmLENBQW9Cd0UsRUFBcEIsQ0FITixFQUlSaFAsSUFKUSxDQUlILFFBSkcsRUFJT2dQLEVBQUUsQ0FBQzRoRCxZQUFILENBQWdCcG1ELElBQWhCLENBQXFCd0UsRUFBckIsQ0FKUCxDQU1WLEVBQU8sQ0FDTixDQUFDb0gsY0FBYyxHQUFHNWIsT0FBTyxDQUFDMk8sVUFBUixFQUFILEdBQTBCM08sT0FBekMsRUFDRTJLLEtBREYsQ0FDUSxjQURSLEVBQ3dCLFVBQUE5SCxDQUFDO0FBQUEsYUFBS2QsT0FBTyxDQUFDYyxDQUFDLENBQUNrYSxPQUFILENBQVAsR0FBcUJsYSxDQUFDLENBQUNrYSxPQUF2QixHQUFpQyxLQUF0QztBQUFBLEtBRHpCLEVBRUVpRyxFQUZGLENBRUssS0FGTCxFQUVZLFlBQVc7QUFFckJqUyx1R0FBUSxDQUFDLEtBQUsya0MsVUFBTixDQUFSLENBQ0Vya0MsU0FERixDQUNZLGVBRFosRUFFRVUsTUFGRixFQUZxQjtBQUtyQixLQVBGLENBRE0sQ0FBUDtBQVVBLEdBekQ4QjtBQTJEL0Jza0QsYUEzRCtCLHVCQTJEbkI5c0QsSUEzRG1CLEVBMkRiMUcsQ0EzRGEsRUEyRFY7QUFBQSxRQU1oQndLLEtBTmdCO0FBQUEsUUFDZG1ILEVBQUUsR0FBRyxJQURTO0FBQUEsUUFFZHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkU7QUFBQSxRQUdkc0gsU0FBUyxHQUFHdEgsTUFBTSxDQUFDdUgsWUFITDtBQUFBLFFBSWQ0d0IsR0FBRyxHQUFHaDhCLElBQUksS0FBSyxHQUpEO0FBQUEsUUFLaEJ4RixHQUFHLEdBQUcsT0FMVTtBQUFBLFFBT2hCZ1AsR0FBRyxHQUFHLENBUFU7QUF1QnBCLFdBZElsUSxDQUFDLENBQUNyRyxJQUFGLEtBQVcsR0FBWCxJQUFrQnFHLENBQUMsQ0FBQ3JHLElBQUYsS0FBVyxJQWNqQyxJQWJLLENBQUMrb0MsR0FhTixLQVpFeGhDLEdBQUcsR0FBRyxLQVlSLEdBVEssQ0FBQ3doQyxHQUFHLEdBQUc3d0IsU0FBSCxHQUFlLENBQUNBLFNBQXBCLEtBQWtDM1EsR0FBRyxJQUFJbEIsQ0FTOUMsS0FSRXdLLEtBQUssR0FBR21ILEVBQUUsQ0FBQzNSLENBQUMsQ0FBQ3JHLElBQUgsQ0FRWixFQVBFdVcsR0FBRyxHQUFHMUYsS0FBSyxDQUFDeEssQ0FBQyxDQUFDa0IsR0FBRCxDQUFGLENBT2IsS0FMVyxDQUFDd2hDLEdBQUcsR0FBRyxDQUFDN3dCLFNBQUosR0FBZ0JBLFNBQXBCLEtBQWtDM1EsR0FBRyxJQUFJbEIsQ0FLcEQsS0FKQ3dLLEtBQUssR0FBR21ILEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0JuRCxFQUFFLENBQUM1TyxDQUk1QixFQUhDbU4sR0FBRyxHQUFHMUYsS0FBSyxDQUFDbUgsRUFBRSxDQUFDcUQsWUFBSCxLQUFvQnJELEVBQUUsQ0FBQ3NELFNBQUgsQ0FBYWpWLENBQUMsQ0FBQ2tCLEdBQUQsQ0FBZCxDQUFwQixHQUEyQ2xCLENBQUMsQ0FBQ2tCLEdBQUQsQ0FBN0MsQ0FHWixHQUFPZ1AsR0FBUDtBQUNBLEdBbkY4QjtBQXFGL0JrakQsU0FyRitCLG1CQXFGdkJwekQsQ0FyRnVCLEVBcUZwQjtBQUNWLFdBQU8sS0FBS3d6RCxXQUFMLENBQWlCLEdBQWpCLEVBQXNCeHpELENBQXRCLENBQVA7QUFDQSxHQXZGOEI7QUF5Ri9CcXpELFNBekYrQixtQkF5RnZCcnpELENBekZ1QixFQXlGcEI7QUFDVixXQUFPLEtBQUt3ekQsV0FBTCxDQUFpQixHQUFqQixFQUFzQnh6RCxDQUF0QixDQUFQO0FBQ0EsR0EzRjhCO0FBNkYvQnl6RCxlQTdGK0IseUJBNkZqQi9zRCxJQTdGaUIsRUE2RlgxRyxDQTdGVyxFQTZGUjtBQUFBLFFBTWxCd0ssS0FOa0I7QUFBQSxRQUNoQm1ILEVBQUUsR0FBRyxJQURXO0FBQUEsUUFFaEJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZJO0FBQUEsUUFHaEJzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhIO0FBQUEsUUFJaEI0aEQsT0FBTyxHQUFHaHRELElBQUksS0FBSyxPQUpIO0FBQUEsUUFLaEJJLEtBQUssR0FBRzZLLEVBQUUsQ0FBQytoRCxPQUFPLEdBQUcsU0FBSCxHQUFlLFNBQXZCLENBQUYsQ0FBb0MxekQsQ0FBcEMsQ0FMUTtBQUFBLFFBT2xCa0IsR0FBRyxHQUFHLEtBUFk7QUFBQSxRQVFsQjZGLEdBQUcsR0FBRzRLLEVBQUUsQ0FBQ2pMLElBQUQsQ0FSVTtBQXdCdEIsV0FkSTFHLENBQUMsQ0FBQ3JHLElBQUYsS0FBVyxHQUFYLElBQWtCcUcsQ0FBQyxDQUFDckcsSUFBRixLQUFXLElBY2pDLElBYkssQ0FBQys1RCxPQWFOLEtBWkV4eUQsR0FBRyxHQUFHLE9BWVIsR0FUSyxDQUFDd3lELE9BQU8sR0FBRzdoRCxTQUFILEdBQWUsQ0FBQ0EsU0FBeEIsS0FBc0MzUSxHQUFHLElBQUlsQixDQVNsRCxLQVJFd0ssS0FBSyxHQUFHbUgsRUFBRSxDQUFDM1IsQ0FBQyxDQUFDckcsSUFBSCxDQVFaLEVBUEVvTixHQUFHLEdBQUd5RCxLQUFLLENBQUN4SyxDQUFDLENBQUNrQixHQUFELENBQUYsQ0FPYixLQUxXLENBQUN3eUQsT0FBTyxHQUFHLENBQUM3aEQsU0FBSixHQUFnQkEsU0FBeEIsS0FBc0MzUSxHQUFHLElBQUlsQixDQUt4RCxLQUpDd0ssS0FBSyxHQUFHbUgsRUFBRSxDQUFDbUQsU0FBSCxJQUFnQm5ELEVBQUUsQ0FBQzVPLENBSTVCLEVBSENnRSxHQUFHLEdBQUd5RCxLQUFLLENBQUNtSCxFQUFFLENBQUNxRCxZQUFILEtBQW9CckQsRUFBRSxDQUFDc0QsU0FBSCxDQUFhalYsQ0FBQyxDQUFDa0IsR0FBRCxDQUFkLENBQXBCLEdBQTJDbEIsQ0FBQyxDQUFDa0IsR0FBRCxDQUE3QyxDQUdaLEdBQU82RixHQUFHLEdBQUdELEtBQU4sR0FBYyxDQUFkLEdBQWtCQyxHQUFHLEdBQUdELEtBQS9CO0FBQ0EsR0F0SDhCO0FBd0gvQndzRCxhQXhIK0IsdUJBd0huQnR6RCxDQXhIbUIsRUF3SGhCO0FBQ2QsV0FBTyxLQUFLeXpELGFBQUwsQ0FBbUIsT0FBbkIsRUFBNEJ6ekQsQ0FBNUIsQ0FBUDtBQUNBLEdBMUg4QjtBQTRIL0J1ekQsY0E1SCtCLHdCQTRIbEJ2ekQsQ0E1SGtCLEVBNEhmO0FBQ2YsV0FBTyxLQUFLeXpELGFBQUwsQ0FBbUIsUUFBbkIsRUFBNkJ6ekQsQ0FBN0IsQ0FBUDtBQUNBLEdBOUg4QjtBQWdJL0IyekQsYUFoSStCLHVCQWdJbkIzekQsQ0FoSW1CLEVBZ0loQjtBQUNkLFdBQU8sQ0FBQ0EsQ0FBQyxDQUFDckcsSUFBSCxJQUFXcUcsQ0FBQyxDQUFDckcsSUFBRixLQUFXLEdBQTdCO0FBQ0E7QUFsSThCLENBQTFCLEM7Ozs7QUNUTjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUEySyxNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQjs7Ozs7O0FBTUF5Z0IsTUFQK0IsZ0JBTzFCanBDLEtBUDBCLEVBT25CO0FBQUEsUUFDTHVKLEVBQUUsR0FBRyxJQURBO0FBQUEsUUFFTHBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlA7QUFBQSxRQUdMM0csSUFBSSxHQUFHK04sRUFBRSxDQUFDL04sSUFITDs7QUFLWCxRQUFJLENBQUErTixFQUFFLENBQUNnUyxVQUFILE1BQ0ZwWixNQUFNLENBQUNtb0Isc0JBREwsTUFDK0I7QUFDakMsS0FBQW5vQixNQUFNLENBQUNpUyxZQUFQLElBQXdCN0ssRUFBRSxDQUFDeXdCLElBQUgsQ0FBUXd4QixTQUY5QixLQUdGcnBELE1BQU0sQ0FBQ3NvQix1QkFIVCxDQUdpQztBQUhqQztBQUFBLG9EQVFpQmxoQixFQUFFLENBQUN1SixTQVJwQjtBQUFBLFlBUU8yNEMsRUFSUDtBQUFBLFlBUVdDLEVBUlg7QUFBQSw2Q0FTaUIxckQsS0FUakI7QUFBQSxZQVNPMnJELEVBVFA7QUFBQSxZQVNXQyxFQVRYO0FBQUEsWUFXTUMsSUFYTixHQVdhdDBELElBQUksQ0FBQzJELEdBQUwsQ0FBU3V3RCxFQUFULEVBQWFFLEVBQWIsQ0FYYjtBQUFBLFlBWU1HLElBWk4sR0FZYXYwRCxJQUFJLENBQUNrTixHQUFMLENBQVNnbkQsRUFBVCxFQUFhRSxFQUFiLENBWmI7QUFBQSxZQWFNSSxJQWJOLEdBYWE1cEQsTUFBTSxDQUFDb29CLHNCQUFQLEdBQWdDaGhCLEVBQUUsQ0FBQzRTLE1BQUgsQ0FBVXZULEdBQTFDLEdBQWdEclIsSUFBSSxDQUFDMkQsR0FBTCxDQUFTd3dELEVBQVQsRUFBYUUsRUFBYixDQWI3RDtBQUFBLFlBY01JLElBZE4sR0FjYTdwRCxNQUFNLENBQUNvb0Isc0JBQVAsR0FBZ0NoaEIsRUFBRSxDQUFDek8sTUFBbkMsR0FBNEN2RCxJQUFJLENBQUNrTixHQUFMLENBQVNpbkQsRUFBVCxFQUFhRSxFQUFiLENBZHpEOztBQWdCQXB3RCxZQUFJLENBQUNHLE1BQUwsWUFBZ0JDLGNBQUssQ0FBQ25JLFFBQXRCLEdBQ0U4RyxJQURGLENBQ08sR0FEUCxFQUNZc3hELElBRFosRUFFRXR4RCxJQUZGLENBRU8sR0FGUCxFQUVZd3hELElBRlosRUFHRXh4RCxJQUhGLENBR08sT0FIUCxFQUdnQnV4RCxJQUFJLEdBQUdELElBSHZCLEVBSUV0eEQsSUFKRixDQUlPLFFBSlAsRUFJaUJ5eEQsSUFBSSxHQUFHRCxJQUp4QixDQWhCQSxFQXVCQXZ3RCxJQUFJLENBQUM0SyxTQUFMLFlBQW1CeEssY0FBSyxDQUFDekcsTUFBekIsR0FDRWlSLFNBREYsWUFDZ0J4SyxjQUFLLENBQUMxRyxLQUR0QixHQUVFcUksTUFGRixDQUVTLFVBQUEzRixDQUFDO0FBQUEsaUJBQUl1SyxNQUFNLENBQUNxb0IsMkJBQVAsQ0FBbUM1eUIsQ0FBbkMsQ0FBSjtBQUFBLFNBRlYsRUFHRWlPLElBSEYsQ0FHTyxVQUFTak8sQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQUEsY0FJaEJ3dEQsTUFKZ0I7QUFBQSxjQUNkM3lELEtBQUssR0FBRzRRLGlHQUFRLENBQUMsSUFBRCxDQURGO0FBQUEsY0FFZG1tRCxVQUFVLEdBQUcvMkQsS0FBSyxDQUFDd2hCLE9BQU4sQ0FBYzlhLGNBQUssQ0FBQ2hGLFFBQXBCLENBRkM7QUFBQSxjQUdkczFELFVBQVUsR0FBR2gzRCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDL0UsUUFBcEIsQ0FIQztBQUFBLGNBS2hCeTFDLFFBQVEsS0FMUTs7QUFPcEIsY0FBSXAzQyxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDeEksTUFBcEIsQ0FBSixFQUFpQztBQUFBLGdCQUMxQnVILENBQUMsR0FBR3pGLEtBQUssQ0FBQ3FGLElBQU4sQ0FBVyxJQUFYLElBQW1CLENBREc7QUFBQSxnQkFFMUJLLENBQUMsR0FBRzFGLEtBQUssQ0FBQ3FGLElBQU4sQ0FBVyxJQUFYLElBQW1CLENBRkc7QUFJaENzdEQsa0JBQU0sR0FBR3QrQyxFQUFFLENBQUM0aUQsV0FKb0IsRUFLaEM3ZixRQUFRLEdBQUd1ZixJQUFJLEdBQUdseEQsQ0FBUCxJQUFZQSxDQUFDLEdBQUdteEQsSUFBaEIsSUFBd0JDLElBQUksR0FBR254RCxDQUEvQixJQUFvQ0EsQ0FBQyxHQUFHb3hELElBTG5CO0FBTWhDLFdBTkQsTUFNTyxJQUFJOTJELEtBQUssQ0FBQ3doQixPQUFOLENBQWM5YSxjQUFLLENBQUM5SixHQUFwQixDQUFKLEVBQThCO0FBQUEsOEJBQ05pSixVQUFVLENBQUMsSUFBRCxDQURKO0FBQUEsZ0JBQzdCSixFQUQ2QixlQUM3QkEsQ0FENkI7QUFBQSxnQkFDMUJDLENBRDBCLGVBQzFCQSxDQUQwQjtBQUFBLGdCQUN2QkMsS0FEdUIsZUFDdkJBLEtBRHVCO0FBQUEsZ0JBQ2hCQyxNQURnQixlQUNoQkEsTUFEZ0I7O0FBR3BDK3NELGtCQUFNLEdBQUd0K0MsRUFBRSxDQUFDNmlELFVBSHdCLEVBSXBDOWYsUUFBUSxHQUFHLEVBQUV3ZixJQUFJLEdBQUdueEQsRUFBUCxJQUFZQSxFQUFDLEdBQUdFLEtBQUosR0FBWWd4RCxJQUExQixLQUFtQyxFQUFFRyxJQUFJLEdBQUdweEQsQ0FBUCxJQUFZQSxDQUFDLEdBQUdFLE1BQUosR0FBYWl4RCxJQUEzQixDQUpWO0FBS3BDLFdBTE0sTUFNTjtBQUNBOztBQUdHemYsa0JBQVEsR0FBRzRmLFVBdkJLLEtBd0JuQmgzRCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDL0UsUUFBcEIsRUFBOEIsQ0FBQ3ExRCxVQUEvQixDQXhCbUIsRUEwQm5CaDNELEtBQUssQ0FBQ3doQixPQUFOLENBQWM5YSxjQUFLLENBQUNoRixRQUFwQixFQUE4QixDQUFDcTFELFVBQS9CLENBMUJtQixFQTJCbkJwRSxNQUFNLENBQUNwdUQsSUFBUCxDQUFZOFAsRUFBWixFQUFnQixDQUFDMGlELFVBQWpCLEVBQTZCLzJELEtBQTdCLEVBQW9DMEMsQ0FBcEMsRUFBdUN5QyxDQUF2QyxDQTNCbUI7QUE2QnBCLFNBaENGLENBdkJBO0FBQUE7QUF3REEsR0FwRThCOztBQXNFL0I7Ozs7OztBQU1BOHVDLFdBNUUrQixxQkE0RXJCbnBDLEtBNUVxQixFQTRFZDtBQUFBLFFBQ1Z1SixFQUFFLEdBQUcsSUFESztBQUFBLFFBRVZwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZGO0FBSVpvSCxNQUFFLENBQUNnUyxVQUFILE1BQW1CLENBQUNwWixNQUFNLENBQUNtb0Isc0JBSmYsS0FRaEIvZ0IsRUFBRSxDQUFDdUosU0FBSCxHQUFlOVMsS0FSQyxFQVVoQnVKLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUUcsTUFBUixZQUFtQkMsY0FBSyxDQUFDekosS0FBekIsR0FDRW1JLE1BREYsQ0FDUyxNQURULEVBRUVDLElBRkYsQ0FFTyxPQUZQLEVBRWdCcUIsY0FBSyxDQUFDbkksUUFGdEIsRUFHRWlNLEtBSEYsQ0FHUSxTQUhSLEVBR21CLEtBSG5CLENBVmdCLEVBZWhCNkosRUFBRSxDQUFDOGlELGFBQUgsSUFmZ0I7QUFnQmhCLEdBNUY4Qjs7QUE4Ri9COzs7OztBQUtBampCLFNBbkcrQixxQkFtR3JCO0FBQUEsUUFDSDcvQixFQUFFLEdBQUcsSUFERjtBQUFBLFFBRUhwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZUO0FBSUxvSCxNQUFFLENBQUNnUyxVQUFILE1BQW1CLENBQUNwWixNQUFNLENBQUNtb0Isc0JBSnRCLEtBUVQvZ0IsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUNuSSxRQUF6QixHQUNFaVEsVUFERixHQUVFK04sUUFGRixDQUVXLEdBRlgsRUFHRS9SLEtBSEYsQ0FHUSxTQUhSLEVBR21CLEdBSG5CLEVBSUVvSCxNQUpGLEVBUlMsRUFjVHlDLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsWUFBc0J4SyxjQUFLLENBQUMxRyxLQUE1QixHQUNFd2hCLE9BREYsQ0FDVTlhLGNBQUssQ0FBQy9FLFFBRGhCLEtBZFMsRUFpQlQwUyxFQUFFLENBQUM4aUQsYUFBSCxJQWpCUztBQWtCVCxHQXJIOEI7QUF1SC9CQSxlQXZIK0IseUJBdUhqQkMsVUF2SGlCLEVBdUhMO0FBQ3pCLFNBQUt2NUMsUUFBTCxHQUFnQnU1QyxVQURTO0FBRXpCO0FBekg4QixDQUExQixDOzs7OztBQ1ROOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBcHdELE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7Ozs7O0FBT0ErakMsYUFSK0IsdUJBUW5COTJELE1BUm1CLEVBUVhtQyxDQVJXLEVBUVJ5QyxDQVJRLEVBUUw7QUFBQSxRQUNuQmtQLEVBQUUsR0FBRyxJQURjO0FBQUEsUUFFbkJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZPO0FBQUEsUUFHbkJzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhBO0FBQUEsUUFJbkJxWixFQUFFLEdBQUcsQ0FBQ3RaLFNBQVMsR0FBR0YsRUFBRSxDQUFDMFosT0FBTixHQUFnQjFaLEVBQUUsQ0FBQzJaLE9BQTdCLEVBQXNDbmUsSUFBdEMsQ0FBMkN3RSxFQUEzQyxDQUpjO0FBQUEsUUFLbkI0WixFQUFFLEdBQUcsQ0FBQzFaLFNBQVMsR0FBR0YsRUFBRSxDQUFDMlosT0FBTixHQUFnQjNaLEVBQUUsQ0FBQzBaLE9BQTdCLEVBQXNDbGUsSUFBdEMsQ0FBMkN3RSxFQUEzQyxDQUxjO0FBQUEsUUFNbkJwQixDQUFDLEdBQUdvQixFQUFFLENBQUNvakMsWUFBSCxDQUFnQjVuQyxJQUFoQixDQUFxQndFLEVBQXJCLENBTmU7QUFVekI7QUFGQWxRLFVBQU0sQ0FBQzhJLE1BQU0sQ0FBQzJvQixlQUFSLEVBQXlCdmhCLEVBQUUsQ0FBQ2lELEdBQTVCLEVBQWlDNVUsQ0FBakMsRUFBb0NuQyxNQUFNLENBQUNxRSxJQUFQLEVBQXBDLENBUm1CLEVBV3pCeVAsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUMzRyxlQUF6QixTQUEyQ3NVLEVBQUUsQ0FBQ3MyQix1QkFBSCxDQUEyQmpvQyxDQUFDLENBQUNnUyxFQUE3QixDQUEzQyxHQUNFeEQsU0FERixZQUNnQnhLLGNBQUssQ0FBQzVHLGNBRHRCLGNBQ3dDcUYsQ0FEeEMsR0FFRWlELElBRkYsQ0FFTyxDQUFDMUYsQ0FBRCxDQUZQLEVBR0V5TyxLQUhGLEdBSUUvTCxNQUpGLENBSVMsUUFKVCxFQUtFQyxJQUxGLENBS08sT0FMUCxFQUtnQjtBQUFBLGFBQU1nUCxFQUFFLENBQUNpdEMsYUFBSCxDQUFpQjU2QyxjQUFLLENBQUM1RyxjQUF2QixFQUF1Q3FGLENBQXZDLENBQU47QUFBQSxLQUxoQixFQU1FRSxJQU5GLENBTU8sSUFOUCxFQU1hd29CLEVBTmIsRUFPRXhvQixJQVBGLENBT08sSUFQUCxFQU9hNG9CLEVBUGIsRUFRRTVvQixJQVJGLENBUU8sUUFSUCxFQVFpQmdQLEVBQUUsQ0FBQzZKLEtBUnBCLEVBU0U3WSxJQVRGLENBU08sR0FUUCxFQVNZLFVBQUFrdkMsRUFBRTtBQUFBLGFBQUlsZ0MsRUFBRSxDQUFDb2pDLFlBQUgsQ0FBZ0JsRCxFQUFoQixJQUFzQixHQUExQjtBQUFBLEtBVGQsRUFVRS9sQyxVQVZGLEdBV0UrTixRQVhGLENBV1csR0FYWCxFQVlFbFgsSUFaRixDQVlPLEdBWlAsRUFZWTROLENBWlosQ0FYeUI7QUF3QnpCLEdBaEM4Qjs7QUFrQy9COzs7Ozs7O0FBT0Fxa0QsZUF6QytCLHlCQXlDakIvMkQsTUF6Q2lCLEVBeUNUbUMsQ0F6Q1MsRUF5Q055QyxDQXpDTSxFQXlDSDtBQUMzQixRQUFNa1AsRUFBRSxHQUFHLElBQVg7QUFJQTtBQUZBbFEsVUFBTSxDQUFDa1EsRUFBRSxDQUFDcEgsTUFBSCxDQUFVNG9CLGlCQUFYLEVBQThCeGhCLEVBQUUsQ0FBQ2lELEdBQWpDLEVBQXNDNVUsQ0FBdEMsRUFBeUNuQyxNQUFNLENBQUNxRSxJQUFQLEVBQXpDLENBSHFCLEVBTTNCeVAsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUMzRyxlQUF6QixTQUEyQ3NVLEVBQUUsQ0FBQ3MyQix1QkFBSCxDQUEyQmpvQyxDQUFDLENBQUNnUyxFQUE3QixDQUEzQyxHQUNFeEQsU0FERixZQUNnQnhLLGNBQUssQ0FBQzVHLGNBRHRCLGNBQ3dDcUYsQ0FEeEMsR0FFRXFKLFVBRkYsR0FHRStOLFFBSEYsQ0FHVyxHQUhYLEVBSUVsWCxJQUpGLENBSU8sR0FKUCxFQUlZLENBSlosRUFLRXVNLE1BTEYsRUFOMkI7QUFZM0IsR0FyRDhCOztBQXVEL0I7Ozs7Ozs7O0FBUUFxbEQsYUEvRCtCLHVCQStEbkJoa0IsUUEvRG1CLEVBK0RUMXlDLE1BL0RTLEVBK0REbUMsQ0EvREMsRUErREV5QyxDQS9ERixFQStESztBQUNuQyxRQUFNMmlELE1BQU0sYUFBTTdVLFFBQVEsR0FBRyxFQUFILEdBQVEsSUFBdEIsZ0JBQVo7QUFFQSxTQUFLNlUsTUFBTCxFQUFhdm5ELE1BQWIsRUFBcUJtQyxDQUFyQixFQUF3QnlDLENBQXhCLENBSG1DO0FBSW5DLEdBbkU4Qjs7QUFxRS9COzs7Ozs7QUFNQW95RCxZQTNFK0Isc0JBMkVwQmgzRCxNQTNFb0IsRUEyRVptQyxDQTNFWSxFQTJFVDtBQUFBLFFBQ2YyUixFQUFFLEdBQUcsSUFEVTtBQUFBLFFBRWZwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZHO0FBSXJCOUksVUFBTSxDQUFDOEksTUFBTSxDQUFDMm9CLGVBQVIsRUFBeUJ2aEIsRUFBekIsRUFBNkIzUixDQUE3QixFQUFnQ25DLE1BQU0sQ0FBQ3FFLElBQVAsRUFBaEMsQ0FKZSxFQU1qQnFJLE1BQU0sQ0FBQ29uQixvQkFOVSxJQU9wQjl6QixNQUFNLENBQUNpTyxVQUFQLEdBQW9CK04sUUFBcEIsQ0FBNkIsR0FBN0IsRUFDRS9SLEtBREYsQ0FDUSxNQURSLEVBQ2dCO0FBQUEsYUFBTWd0RCxrRkFBSyxDQUFDbmpELEVBQUUsQ0FBQzZKLEtBQUgsQ0FBU3hiLENBQVQsQ0FBRCxDQUFMLENBQW1CKzBELFFBQW5CLENBQTRCLEdBQTVCLENBQU47QUFBQSxLQURoQixDQVBvQjtBQVVyQixHQXJGOEI7O0FBdUYvQjs7Ozs7O0FBTUFDLGNBN0YrQix3QkE2RmxCbjNELE1BN0ZrQixFQTZGVm1DLENBN0ZVLEVBNkZQO0FBQUEsUUFDakIyUixFQUFFLEdBQUcsSUFEWTtBQUFBLFFBRWpCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSztBQUl2QjlJLFVBQU0sQ0FBQzhJLE1BQU0sQ0FBQzRvQixpQkFBUixFQUEyQnhoQixFQUEzQixFQUErQjNSLENBQS9CLEVBQWtDbkMsTUFBTSxDQUFDcUUsSUFBUCxFQUFsQyxDQUppQixFQU1uQnFJLE1BQU0sQ0FBQ29uQixvQkFOWSxJQU90Qjl6QixNQUFNLENBQUNpTyxVQUFQLEdBQW9CK04sUUFBcEIsQ0FBNkIsR0FBN0IsRUFDRS9SLEtBREYsQ0FDUSxNQURSLEVBQ2dCO0FBQUEsYUFBTTZKLEVBQUUsQ0FBQzZKLEtBQUgsQ0FBU3hiLENBQVQsQ0FBTjtBQUFBLEtBRGhCLENBUHNCO0FBVXZCLEdBdkc4Qjs7QUF5Ry9COzs7Ozs7OztBQVFBdzBELFlBakgrQixzQkFpSHBCamtCLFFBakhvQixFQWlIVjF5QyxNQWpIVSxFQWlIRm1DLENBakhFLEVBaUhDeUMsQ0FqSEQsRUFpSEk7QUFDbEMsbUJBQ0k4dEMsUUFBUSxHQUFHLEVBQUgsR0FBUSxJQURwQixpQkFFRTF5QyxNQUZGLEVBRVVtQyxDQUZWLEVBRWF5QyxDQUZiLENBRGtDO0FBSWxDLEdBckg4Qjs7QUF1SC9COzs7Ozs7O0FBT0F3eUQsV0E5SCtCLHFCQThIckJ4Z0IsSUE5SHFCLEVBOEhmejBDLENBOUhlLEVBOEhaO0FBQ2xCLFFBQU0yUixFQUFFLEdBQUcsSUFBWDtBQUVBLFdBQU84aUMsSUFBSSxDQUFDRyxRQUFMLEtBQWtCLE1BQWxCLEdBQ05qakMsRUFBRSxDQUFDNmlELFVBREcsR0FFTDdpRCxFQUFFLENBQUNpZ0MsVUFBSCxDQUFjNXhDLENBQWQsSUFDQyxZQUFNLENBQUUsQ0FEVCxHQUNZO0FBQ1gyUixNQUFFLENBQUM0aUQsV0FKTjtBQU1BLEdBdkk4Qjs7QUF5SS9COzs7Ozs7O0FBT0FwbEIsYUFoSitCLHVCQWdKbkJzRixJQWhKbUIsRUFnSmJ6MEMsQ0FoSmEsRUFnSlZ5QyxDQWhKVSxFQWdKUDtBQUFBLFFBTW5CeXlELFlBTm1CO0FBQUEsUUFDakJ2akQsRUFBRSxHQUFHLElBRFk7QUFBQSxRQUVqQnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRks7QUFBQSxRQUdqQmpOLEtBQUssR0FBRzRRLGlHQUFRLENBQUN1bUMsSUFBRCxDQUhDO0FBQUEsUUFJakI0ZixVQUFVLEdBQUcvMkQsS0FBSyxDQUFDd2hCLE9BQU4sQ0FBYzlhLGNBQUssQ0FBQ2hGLFFBQXBCLENBSkk7QUFBQSxRQUtqQml4RCxNQUFNLEdBQUd0K0MsRUFBRSxDQUFDc2pELFNBQUgsQ0FBYXhnQixJQUFiLEVBQW1CejBDLENBQW5CLEVBQXNCbU4sSUFBdEIsQ0FBMkJ3RSxFQUEzQixDQUxROztBQVF2QixRQUFJcEgsTUFBTSxDQUFDbW9CLHNCQUFQLElBQWlDbm9CLE1BQU0sQ0FBQ3FvQiwyQkFBUCxDQUFtQzV5QixDQUFuQyxDQUFyQyxFQUE0RTtBQUMzRSxVQUFJLENBQUN1SyxNQUFNLENBQUNzb0IsdUJBQVosRUFBcUM7QUFDcEMsWUFBSWtmLFFBQVEsY0FBTy90QyxjQUFLLENBQUN6RyxNQUFiLENBQVo7QUFFSWdOLGNBQU0sQ0FBQ29vQixzQkFIeUIsS0FJbkNvZixRQUFRLElBQUlwZ0MsRUFBRSxDQUFDczJCLHVCQUFILENBQTJCam9DLENBQUMsQ0FBQ2dTLEVBQTdCLENBSnVCLEdBT3BDTCxFQUFFLENBQUMvTixJQUFILENBQVE0SyxTQUFSLENBQWtCdWpDLFFBQWxCLEVBQ0V2akMsU0FERixZQUNnQnhLLGNBQUssQ0FBQzFHLEtBRHRCLEdBRUUyUSxJQUZGLENBRU8sVUFBU2pPLENBQVQsRUFBWXlDLENBQVosRUFBZTtBQUNwQixjQUFNbkYsS0FBSyxHQUFHNFEsaUdBQVEsQ0FBQyxJQUFELENBQXRCO0FBRUk1USxlQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDaEYsUUFBcEIsQ0FIZ0IsS0FJbkJrMkQsWUFBWSxHQUFHNTNELEtBSkksRUFLbkIyeUQsTUFBTSxLQUFRM3lELEtBQUssQ0FBQ3doQixPQUFOLENBQWM5YSxjQUFLLENBQUNoRixRQUFwQixLQUFSLEVBQThDZ0IsQ0FBOUMsRUFBaUR5QyxDQUFqRCxDQUxhO0FBT3BCLFNBVEYsQ0FQb0M7QUFpQnBDOztBQUVJeXlELGtCQUFELElBQWlCQSxZQUFZLENBQUNoekQsSUFBYixPQUF3QjVFLEtBQUssQ0FBQzRFLElBQU4sRUFwQjhCLEtBcUIxRTVFLEtBQUssQ0FBQ3doQixPQUFOLENBQWM5YSxjQUFLLENBQUNoRixRQUFwQixFQUE4QixDQUFDcTFELFVBQS9CLENBckIwRSxFQXNCMUVwRSxNQUFNLENBQUMsQ0FBQ29FLFVBQUYsRUFBYy8yRCxLQUFkLEVBQXFCMEMsQ0FBckIsRUFBd0J5QyxDQUF4QixDQXRCb0U7QUF3QjNFO0FBQ0Q7QUFqTDhCLENBQTFCLEM7O0FDVk47Ozs7QUFJQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRUE2QixNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQjs7OztBQUlBdWtDLFdBTCtCLHVCQUtuQjtBQUFBLFFBQ0x4akQsRUFBRSxHQUFHLElBREE7QUFBQSxRQUVMcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGUDtBQUFBLFFBR0xzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhkO0FBTVhILE1BQUUsQ0FBQ3ZYLEtBQUgsR0FBV3lYLFNBQVMsR0FBR3VqRCxxRkFBUSxFQUFYLEdBQWdCQyxxRkFBUSxFQU5qQzs7QUFRWDtBQVJXLFFBd0JQQyxVQXhCTztBQUFBLFFBeUJQQyxPQXpCTztBQUFBLFFBU0xDLFlBQVksR0FBRyxZQUFNO0FBQzFCN2pELFFBQUUsQ0FBQzhqRCxjQUFILEVBRDBCO0FBRTFCLEtBWFU7QUFBQSxRQVlMQyxZQUFZLEdBQUcsWUFBTTtBQUFBLFVBQ3BCdDdELEtBQUssR0FBR3VYLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsWUFBa0JDLGNBQUssQ0FBQzVKLEtBQXhCLGVBRFk7QUFBQSxVQUVwQnV6QixTQUFTLEdBQUc7QUFBQzFxQixhQUFLLEVBQUUsQ0FBUjtBQUFXQyxjQUFNLEVBQUU7QUFBbkIsT0FGUTtBQVMxQixhQUxJOUksS0FBSyxDQUFDMlIsSUFBTixFQUtKLEtBSkM0aEIsU0FBUyxDQUFDMXFCLEtBQVYsR0FBa0IsQ0FBQzdJLEtBQUssQ0FBQ3VJLElBQU4sQ0FBVyxPQUFYLENBSXBCLEVBSENnckIsU0FBUyxDQUFDenFCLE1BQVYsR0FBbUIsQ0FBQzlJLEtBQUssQ0FBQ3VJLElBQU4sQ0FBVyxRQUFYLENBR3JCLEdBQU9nckIsU0FBUyxDQUFDOWIsU0FBUyxHQUFHLE9BQUgsR0FBYSxRQUF2QixDQUFoQjtBQUNBLEtBdEJVOztBQXlEWDtBQTlCQUYsTUFBRSxDQUFDdlgsS0FBSCxDQUNFK2xCLEVBREYsQ0FDSyxPQURMLEVBQ2MsWUFBTTtBQUNsQnhPLFFBQUUsQ0FBQzBNLFNBQUgsS0FBaUIsT0FBakIsSUFBNEIxTSxFQUFFLENBQUM2VixXQUFILEVBRFYsRUFFbEJndUMsWUFBWSxFQUZNO0FBR2xCLEtBSkYsRUFLRXIxQyxFQUxGLENBS0ssT0FMTCxFQUtjcTFDLFlBTGQsRUFNRXIxQyxFQU5GLENBTUssS0FOTCxFQU1ZLFlBQU07QUFDaEJtMUMsZ0JBQVUsR0FBRzNqRCxFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFMLEVBREc7QUFFaEIsS0FSRixDQTNCVyxFQXFDWC9LLEVBQUUsQ0FBQ3ZYLEtBQUgsQ0FBU3U3RCxZQUFULEdBQXdCLFlBQVc7QUFBQTs7QUFDbENKLGFBQU8sSUFBSTVtQyxZQUFZLENBQUM0bUMsT0FBRCxDQURXLEVBRWxDQSxPQUFPLEdBQUczbUMsVUFBVSxDQUFDLFlBQU07QUFDMUIsWUFBTW5yQixTQUFTLEdBQUcsS0FBSSxDQUFDbXlELFlBQUwsRUFBbEI7O0FBRUFOLGtCQUFVLElBQUlyeEQsNkZBQWdCLENBQUNSLFNBQVMsQ0FBQ3ZCLElBQVYsRUFBRCxDQUE5QixJQUNDLEtBQUksQ0FBQzJ6RCxJQUFMLENBQVVweUQsU0FBVixFQUFxQjZ4RCxVQUFVLENBQUNqekQsR0FBWCxDQUFlc1AsRUFBRSxDQUFDaU8sSUFBSCxDQUFRa2UsUUFBUixFQUFmLENBQXJCLENBSnlCO0FBSzFCLE9BTG1CLEVBS2pCLENBTGlCLENBRmM7QUFRbEMsS0E3Q1UsRUErQ1huc0IsRUFBRSxDQUFDdlgsS0FBSCxDQUFTNHBELE1BQVQsR0FBa0IsWUFBVztBQUM1QixVQUFNOFIsTUFBTSxHQUFHLEtBQUtBLE1BQUwsSUFBZjtBQU1BLGFBSklBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVW53RCxNQUFWLENBQWlCLFVBQUF4RyxDQUFDO0FBQUEsZUFBSW9CLEtBQUssQ0FBQ3BCLENBQUQsQ0FBVDtBQUFBLE9BQWxCLEVBQWdDZ0IsTUFBaEMsS0FBMkMsQ0FJL0MsSUFIQ3dSLEVBQUUsQ0FBQzlOLE9BQUgsSUFBYzhOLEVBQUUsQ0FBQzlOLE9BQUgsQ0FBV0UsTUFBWCxZQUFzQkMsY0FBSyxDQUFDNUosS0FBNUIsR0FBcUN5SCxJQUFyQyxDQUEwQyxJQUExQyxDQUdmLEVBQU8sSUFBUDtBQUNBLEtBdkRVLEVBMERYOFAsRUFBRSxDQUFDdlgsS0FBSCxDQUFTb1EsS0FBVCxHQUFpQixVQUFTQSxLQUFULEVBQWdCO0FBQUEsVUFDMUJ5QixDQUFDLEdBQUcxQixNQUFNLENBQUM4WixvQkFBUCxJQUErQnF4QyxZQUFZLEVBRHJCO0FBQUEsVUFFNUJJLE1BQU0sR0FBR25rRCxFQUFFLENBQUNva0QsU0FBSCxFQUZtQjtBQVVoQztBQUlBO0FBQ0E7QUFYSSxPQUFDRCxNQUFELElBQVd0ckQsS0FBSyxDQUFDSyxLQUpXLEdBSy9CaXJELE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxFQUFTLENBQUN0ckQsS0FBSyxDQUFDSyxLQUFOLEdBQWMsQ0FBZCxDQUFELEVBQW1Cb0IsQ0FBbkIsQ0FBVCxDQUxzQixHQU1yQnhMLE9BQU8sQ0FBQ3ExRCxNQUFELENBTmMsS0FPL0JBLE1BQU0sR0FBR0EsTUFBTSxDQUFDenpELEdBQVAsQ0FBVyxVQUFDbEQsQ0FBRCxFQUFJc0QsQ0FBSjtBQUFBLGVBQVUsQ0FBQ3RELENBQUQsRUFBSXNELENBQUMsR0FBRyxDQUFKLEdBQVF3SixDQUFSLEdBQVl4SixDQUFoQixDQUFWO0FBQUEsT0FBWCxDQVBzQixHQVdoQ29QLFNBQVMsSUFBSWlrRCxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVV2MEIsT0FBVixFQVhtQixFQVloQyxLQUFLdTBCLE1BQUwsQ0FBWUEsTUFBWixDQVpnQyxFQWdCaEMsS0FBSzlSLE1BQUwsRUFoQmdDO0FBaUJoQyxLQTNFVSxFQTZFWHJ5QyxFQUFFLENBQUN2WCxLQUFILENBQVN3N0QsWUFBVCxHQUF3QjtBQUFBLGFBQ3ZCamtELEVBQUUsQ0FBQzlOLE9BQUgsR0FBYThOLEVBQUUsQ0FBQzlOLE9BQUgsQ0FBV0UsTUFBWCxZQUFzQkMsY0FBSyxDQUFDNUosS0FBNUIsRUFBYixHQUFvRDhULGlHQUFRLENBQUMsRUFBRCxDQURyQztBQUFBLEtBN0ViO0FBZ0ZYLEdBckY4Qjs7QUF1Ri9COzs7O0FBSUFtVCxjQTNGK0IsMEJBMkZoQjtBQUFBLFFBQ1IxUCxFQUFFLEdBQUcsSUFERztBQUFBLFFBRVJwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZKO0FBQUEsUUFHUnlyRCxVQUFVLEdBQUd6ckQsTUFBTSxDQUFDNlcsYUFBUCxHQUF1QixTQUF2QixHQUFtQyxRQUh4QztBQUFBLFFBSVJWLE1BQU0sYUFBTS9PLEVBQUUsQ0FBQytPLE1BQVQsY0FKRTtBQUFBLFFBS1JpQixRQUFRLEdBQUdoUSxFQUFFLENBQUMrZ0QsV0FBSCxDQUFlaHlDLE1BQWYsQ0FMSDtBQU9kL08sTUFBRSxDQUFDeWMsaUJBQUgsR0FBdUIxTixNQVBULEVBUWQvTyxFQUFFLENBQUM4TyxVQUFILENBQWM5TyxFQUFFLENBQUM0TyxJQUFqQixFQUF1QkcsTUFBdkIsQ0FSYyxFQVNkL08sRUFBRSxDQUFDd2pELFNBQUgsRUFUYyxFQVdkeGpELEVBQUUsQ0FBQzlOLE9BQUgsR0FBYThOLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBTzNWLE1BQVAsQ0FBYyxHQUFkLEVBQW1CQyxJQUFuQixDQUF3QixXQUF4QixFQUFxQ2dQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsU0FBaEIsQ0FBckMsQ0FYQztBQWFkLFFBQU0vTyxPQUFPLEdBQUc4TixFQUFFLENBQUM5TixPQUFuQjtBQUlBO0FBS0E7QUFLQTtBQUtBO0FBTUE7QUFDQTtBQXhCQUEsV0FBTyxDQUFDaUUsS0FBUixDQUFjLFlBQWQsRUFBNEJrdUQsVUFBNUIsQ0FmYyxFQWtCZG55RCxPQUFPLENBQUNuQixNQUFSLENBQWUsR0FBZixFQUNFQyxJQURGLENBQ08sV0FEUCxFQUNvQmdmLFFBRHBCLEVBRUVoZixJQUZGLENBRU8sT0FGUCxFQUVnQnFCLGNBQUssQ0FBQ3pKLEtBRnRCLENBbEJjLEVBdUJkb1gsRUFBRSxDQUFDNE4sT0FBSCxDQUFXLEtBQVgsS0FBcUIxYixPQUFPLENBQUNFLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3pKLEtBQXpCLEdBQ25CbUksTUFEbUIsQ0FDWixHQURZLEVBRW5CQyxJQUZtQixDQUVkLE9BRmMsRUFFTHFCLGNBQUssQ0FBQy9JLFNBRkQsQ0F2QlAsRUE0QmQ0SSxPQUFPLENBQUNFLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ3pKLEtBQXpCLEdBQ0VtSSxNQURGLENBQ1MsR0FEVCxFQUVFQyxJQUZGLENBRU8sT0FGUCxFQUVnQnFCLGNBQUssQ0FBQzdJLFVBRnRCLENBNUJjLEVBaUNkMEksT0FBTyxDQUFDbkIsTUFBUixDQUFlLEdBQWYsRUFDRUMsSUFERixDQUNPLFdBRFAsRUFDb0JnZixRQURwQixFQUVFaGYsSUFGRixDQUVPLE9BRlAsRUFFZ0JxQixjQUFLLENBQUM1SixLQUZ0QixFQUdFeUgsSUFIRixDQUdPOFAsRUFBRSxDQUFDdlgsS0FIVixDQWpDYyxFQXdDZHVYLEVBQUUsQ0FBQ2EsSUFBSCxDQUFRK0wsSUFBUixHQUFlMWEsT0FBTyxDQUFDbkIsTUFBUixDQUFlLEdBQWYsRUFDYkMsSUFEYSxDQUNSLE9BRFEsRUFDQ3FCLGNBQUssQ0FBQ3BLLEtBRFAsRUFFYitJLElBRmEsQ0FFUixXQUZRLEVBRUtnUCxFQUFFLENBQUNpQixZQUFILENBQWdCLE1BQWhCLENBRkwsRUFHYmpRLElBSGEsQ0FHUixXQUhRLEVBR0s0SCxNQUFNLENBQUN1SCxZQUFQLEdBQXNCLEVBQXRCLEdBQTJCSCxFQUFFLENBQUNjLGdCQUhuQyxFQUliM0ssS0FKYSxDQUlQLFlBSk8sRUFJT3lDLE1BQU0sQ0FBQzJaLG9CQUFQLEdBQThCOHhDLFVBQTlCLEdBQTJDLFFBSmxELENBeENEO0FBNkNkLEdBeEk4Qjs7QUEwSS9COzs7OztBQUtBandDLDBCQS9JK0Isb0NBK0lOdFEsT0EvSU0sRUErSUc7QUFBQSxRQUMzQjlELEVBQUUsR0FBRyxJQURzQjtBQUFBLFFBRTNCOU4sT0FBTyxHQUFHOE4sRUFBRSxDQUFDOU4sT0FGYztBQUFBLFFBRzNCMEcsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFIZTtBQUFBLFFBSTNCc3hDLGFBQWEsR0FBR2xxQyxFQUFFLENBQUNrcUMsYUFBSCxDQUFpQjF1QyxJQUFqQixDQUFzQndFLEVBQXRCLENBSlc7QUFBQSxRQUszQm1xQyxTQUFTLEdBQUducUMsRUFBRSxDQUFDbXFDLFNBQUgsQ0FBYTN1QyxJQUFiLENBQWtCd0UsRUFBbEIsQ0FMZTtBQUFBLFFBTTNCMnNDLGNBQWMsR0FBRzNzQyxFQUFFLENBQUMyc0MsY0FBSCxDQUFrQm54QyxJQUFsQixDQUF1QndFLEVBQXZCLENBTlU7QUFBQSxRQU8zQjRzQyxVQUFVLEdBQUc1c0MsRUFBRSxDQUFDNHNDLFVBQUgsQ0FBY3B4QyxJQUFkLENBQW1Cd0UsRUFBbkIsQ0FQYztBQUFBLFFBUTNCNnNDLFVBQVUsR0FBRzdzQyxFQUFFLENBQUM2c0MsVUFBSCxDQUFjcnhDLElBQWQsQ0FBbUJ3RSxFQUFuQixDQVJjOztBQVVqQyxRQUFJcEgsTUFBTSxDQUFDNlcsYUFBWCxFQUEwQjtBQUN6QjtBQUR5QixVQUVuQjYwQyxnQkFBZ0IsR0FBR3B5RCxPQUFPLENBQUNFLE1BQVIsWUFBbUJDLGNBQUssQ0FBQy9JLFNBQXpCLEdBQ3ZCdVQsU0FEdUIsWUFDVHhLLGNBQUssQ0FBQ2hKLFFBREcsR0FFdkIwSyxJQUZ1QixDQUVsQitQLE9BRmtCLEVBR3ZCOVMsSUFIdUIsQ0FHbEIsT0FIa0IsRUFHVGs1QyxhQUhTLENBRkE7QUFBQSxVQU1uQnFhLGVBQWUsR0FBR0QsZ0JBQWdCLENBQUN4bkQsS0FBakIsR0FDdEIvTCxNQURzQixDQUNmLEdBRGUsRUFFdEJvRixLQUZzQixDQUVoQixTQUZnQixFQUVMLEdBRkssRUFHdEJuRixJQUhzQixDQUdqQixPQUhpQixFQUdSazVDLGFBSFEsRUFJdEJudEMsS0FKc0IsQ0FJaEJ1bkQsZ0JBSmdCLENBTkM7QUFhekJDLHFCQUFlLENBQUN4ekQsTUFBaEIsQ0FBdUIsR0FBdkIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0JtNUMsU0FEaEIsQ0FieUI7QUFnQnpCO0FBaEJ5QixVQWlCbkJxYSxpQkFBaUIsR0FBR3R5RCxPQUFPLENBQUNFLE1BQVIsWUFBbUJDLGNBQUssQ0FBQzdJLFVBQXpCLEdBQ3hCcVQsU0FEd0IsWUFDVnhLLGNBQUssQ0FBQzlJLFNBREksR0FFeEJ3SyxJQUZ3QixDQUVuQitQLE9BRm1CLEVBR3hCOVMsSUFId0IsQ0FHbkIsT0FIbUIsRUFHVjI3QyxjQUhVLENBakJEO0FBQUEsVUFxQm5COFgsZ0JBQWdCLEdBQUdELGlCQUFpQixDQUFDMW5ELEtBQWxCLEdBQTBCL0wsTUFBMUIsQ0FBaUMsR0FBakMsRUFDdkJvRixLQUR1QixDQUNqQixTQURpQixFQUNOLEdBRE0sRUFFdkJuRixJQUZ1QixDQUVsQixPQUZrQixFQUVUMjdDLGNBRlMsRUFHdkI1dkMsS0FIdUIsQ0FHakJ5bkQsaUJBSGlCLENBckJBO0FBMEJ6QjtBQUlBO0FBSUE7QUFQQUMsc0JBQWdCLENBQUMxekQsTUFBakIsQ0FBd0IsR0FBeEIsRUFDRUMsSUFERixDQUNPLE9BRFAsRUFDZ0I0N0MsVUFEaEIsQ0EzQnlCLEVBK0J6QjVzQyxFQUFFLENBQUM0TixPQUFILENBQVcsTUFBWCxLQUFzQjYyQyxnQkFBZ0IsQ0FBQzF6RCxNQUFqQixDQUF3QixHQUF4QixFQUNwQkMsSUFEb0IsQ0FDZixPQURlLEVBQ042N0MsVUFETSxDQS9CRyxFQW1DekIzNkMsT0FBTyxDQUFDMkssU0FBUixZQUFzQnhLLGNBQUssQ0FBQzVKLEtBQTVCLFlBQ0V1SSxJQURGLENBQ080SCxNQUFNLENBQUN1SCxZQUFQLEdBQXNCLE9BQXRCLEdBQWdDLFFBRHZDLEVBQ2lEdkgsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQkgsRUFBRSxDQUFDdVQsTUFBekIsR0FBa0N2VCxFQUFFLENBQUN3VCxPQUR0RixDQW5DeUI7QUFxQ3pCO0FBQ0QsR0EvTDhCOztBQWlNL0I7Ozs7O0FBS0FreEMsc0JBdE0rQixnQ0FzTVZqdkMsZUF0TVUsRUFzTU87QUFDckMsUUFBTXpWLEVBQUUsR0FBRyxJQUFYO0FBRUFBLE1BQUUsQ0FBQzJrRCxVQUFILEdBQWdCM2tELEVBQUUsQ0FBQzlOLE9BQUgsQ0FBVzJLLFNBQVgsWUFBeUJ4SyxjQUFLLENBQUM3SixJQUEvQixHQUF1Q3FVLFNBQXZDLFlBQXFEeEssY0FBSyxDQUFDOUosR0FBM0QsR0FDZHdMLElBRGMsQ0FDVGlNLEVBQUUsQ0FBQ3NxQyxPQUFILENBQVc5dUMsSUFBWCxDQUFnQndFLEVBQWhCLENBRFMsQ0FIcUIsRUFNckNBLEVBQUUsQ0FBQzJrRCxVQUFILENBQ0VybkQsSUFERixHQUVFbkQsVUFGRixHQUdFK04sUUFIRixDQUdXdU4sZUFIWCxFQUlFdGYsS0FKRixDQUlRLFNBSlIsRUFJbUIsR0FKbkIsRUFLRW9ILE1BTEYsRUFOcUMsRUFhckN5QyxFQUFFLENBQUMya0QsVUFBSCxHQUFnQjNrRCxFQUFFLENBQUMya0QsVUFBSCxDQUNkN25ELEtBRGMsR0FFZC9MLE1BRmMsQ0FFUCxNQUZPLEVBR2RDLElBSGMsQ0FHVCxPQUhTLEVBR0FnUCxFQUFFLENBQUN1cUMsUUFBSCxDQUFZL3VDLElBQVosQ0FBaUJ3RSxFQUFqQixDQUhBLEVBSWQ3SixLQUpjLENBSVIsUUFKUSxFQUlFLE1BSkYsRUFLZEEsS0FMYyxDQUtSLE1BTFEsRUFLQTZKLEVBQUUsQ0FBQzZKLEtBTEgsRUFNZDlNLEtBTmMsQ0FNUmlELEVBQUUsQ0FBQzJrRCxVQU5LLEVBT2R4dUQsS0FQYyxDQU9SLFNBUFEsRUFPRzZKLEVBQUUsQ0FBQ3dxQyxjQUFILENBQWtCaHZDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FQSCxDQWJxQjtBQXFCckMsR0EzTjhCOztBQTZOL0I7Ozs7Ozs7QUFPQTRrRCxzQkFwTytCLGdDQW9PVkMsWUFwT1UsRUFvT0l6OUMsY0FwT0osRUFvT29CYyxRQXBPcEIsRUFvTzhCO0FBQzVELFFBQU15OEMsVUFBVSxHQUFHdjlDLGNBQWMsR0FDaEMsS0FBS3U5QyxVQUFMLENBQWdCeHFELFVBQWhCLENBQTJCNUgsU0FBUyxFQUFwQyxFQUF3QzJWLFFBQXhDLENBQWlEQSxRQUFqRCxDQURnQyxHQUVoQyxLQUFLeThDLFVBRk47QUFJQUEsY0FBVSxDQUFDM3pELElBQVgsQ0FBZ0IsR0FBaEIsRUFBcUI2ekQsWUFBckIsRUFDRTF1RCxLQURGLENBQ1EsU0FEUixFQUNtQixHQURuQixDQUw0RDtBQU81RCxHQTNPOEI7O0FBNk8vQjs7Ozs7QUFLQTJ1RCx1QkFsUCtCLGlDQWtQVHJ2QyxlQWxQUyxFQWtQUTtBQUN0QyxRQUFNelYsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDK2tELFdBQUgsR0FBaUIva0QsRUFBRSxDQUFDOU4sT0FBSCxDQUFXMkssU0FBWCxZQUF5QnhLLGNBQUssQ0FBQy9HLEtBQS9CLEdBQ2Z1UixTQURlLFlBQ0R4SyxjQUFLLENBQUNoSCxJQURMLEdBRWYwSSxJQUZlLENBRVZpTSxFQUFFLENBQUNrdEMsUUFBSCxDQUFZMXhDLElBQVosQ0FBaUJ3RSxFQUFqQixDQUZVLENBSHFCLEVBT3RDQSxFQUFFLENBQUMra0QsV0FBSCxDQUNFem5ELElBREYsR0FFRW5ELFVBRkYsR0FHRStOLFFBSEYsQ0FHV3VOLGVBSFgsRUFJRXRmLEtBSkYsQ0FJUSxTQUpSLEVBSW1CLEdBSm5CLEVBS0VvSCxNQUxGLEVBUHNDLEVBY3RDeUMsRUFBRSxDQUFDK2tELFdBQUgsR0FBaUIva0QsRUFBRSxDQUFDK2tELFdBQUgsQ0FDZmpvRCxLQURlLEdBRWYvTCxNQUZlLENBRVIsTUFGUSxFQUdmQyxJQUhlLENBR1YsT0FIVSxFQUdEZ1AsRUFBRSxDQUFDbXRDLFNBQUgsQ0FBYTN4QyxJQUFiLENBQWtCd0UsRUFBbEIsQ0FIQyxFQUlmN0osS0FKZSxDQUlULFFBSlMsRUFJQzZKLEVBQUUsQ0FBQzZKLEtBSkosRUFLZjlNLEtBTGUsQ0FLVGlELEVBQUUsQ0FBQytrRCxXQUxNLEVBTWY1dUQsS0FOZSxDQU1ULFNBTlMsRUFNRTZKLEVBQUUsQ0FBQ3dxQyxjQUFILENBQWtCaHZDLElBQWxCLENBQXVCd0UsRUFBdkIsQ0FORixDQWRxQjtBQXFCdEMsR0F2UThCOztBQXlRL0I7Ozs7Ozs7QUFPQWdsRCx1QkFoUitCLGlDQWdSVEMsYUFoUlMsRUFnUk03OUMsY0FoUk4sRUFnUnNCYyxRQWhSdEIsRUFnUmdDO0FBQzlELFFBQU02OEMsV0FBVyxHQUFHMzlDLGNBQWMsR0FDakMsS0FBSzI5QyxXQUFMLENBQWlCNXFELFVBQWpCLENBQTRCNUgsU0FBUyxFQUFyQyxFQUF5QzJWLFFBQXpDLENBQWtEQSxRQUFsRCxDQURpQyxHQUVqQyxLQUFLNjhDLFdBRk47QUFJQUEsZUFBVyxDQUFDL3pELElBQVosQ0FBaUIsR0FBakIsRUFBc0JpMEQsYUFBdEIsRUFDRTl1RCxLQURGLENBQ1EsU0FEUixFQUNtQixHQURuQixDQUw4RDtBQU85RCxHQXZSOEI7O0FBeVIvQjs7Ozs7QUFLQSt1RCx1QkE5UitCLGlDQThSVHp2QyxlQTlSUyxFQThSUTtBQUN0QyxRQUFNelYsRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDbWxELFdBQUgsR0FBaUJubEQsRUFBRSxDQUFDOU4sT0FBSCxDQUFXMkssU0FBWCxZQUF5QnhLLGNBQUssQ0FBQ3RLLEtBQS9CLEdBQ2Y4VSxTQURlLFlBQ0R4SyxjQUFLLENBQUN2SyxJQURMLEdBRWZpTSxJQUZlLENBRVZpTSxFQUFFLENBQUNrdEMsUUFBSCxDQUFZMXhDLElBQVosQ0FBaUJ3RSxFQUFqQixDQUZVLENBSHFCLEVBT3RDQSxFQUFFLENBQUNtbEQsV0FBSCxDQUNFN25ELElBREYsR0FFRW5ELFVBRkYsR0FHRStOLFFBSEYsQ0FHV3VOLGVBSFgsRUFJRXRmLEtBSkYsQ0FJUSxTQUpSLEVBSW1CLEdBSm5CLEVBS0VvSCxNQUxGLEVBUHNDLEVBY3RDeUMsRUFBRSxDQUFDbWxELFdBQUgsR0FBaUJubEQsRUFBRSxDQUFDbWxELFdBQUgsQ0FDZnJvRCxLQURlLEdBRWYvTCxNQUZlLENBRVIsTUFGUSxFQUdmQyxJQUhlLENBR1YsT0FIVSxFQUdEZ1AsRUFBRSxDQUFDNHdDLFNBQUgsQ0FBYXAxQyxJQUFiLENBQWtCd0UsRUFBbEIsQ0FIQyxFQUlmN0osS0FKZSxDQUlULE1BSlMsRUFJRDZKLEVBQUUsQ0FBQzZKLEtBSkYsRUFLZjFULEtBTGUsQ0FLVCxTQUxTLEVBS0UsWUFBVztBQUU1QixhQURBNkosRUFBRSxDQUFDNndDLGNBQUgsR0FBb0J0MEMsaUdBQVEsQ0FBQyxJQUFELENBQVIsQ0FBZXBHLEtBQWYsQ0FBcUIsU0FBckIsQ0FDcEIsRUFBTyxHQUFQO0FBQ0EsS0FSZSxFQVNmNEcsS0FUZSxDQVNUaUQsRUFBRSxDQUFDbWxELFdBVE0sRUFVZmh2RCxLQVZlLENBVVQsU0FWUyxFQVVFLEdBVkYsQ0FkcUI7QUF5QnRDLEdBdlQ4Qjs7QUF3VC9COzs7Ozs7O0FBT0FpdkQsdUJBL1QrQixpQ0ErVFRDLGFBL1RTLEVBK1RNaitDLGNBL1ROLEVBK1RzQmMsUUEvVHRCLEVBK1RnQztBQUM5RCxRQUFNaTlDLFdBQVcsR0FBRy85QyxjQUFjLEdBQ2pDLEtBQUsrOUMsV0FBTCxDQUFpQmhyRCxVQUFqQixDQUE0QjVILFNBQVMsRUFBckMsRUFBeUMyVixRQUF6QyxDQUFrREEsUUFBbEQsQ0FEaUMsR0FFakMsS0FBS2k5QyxXQUZOO0FBSUFBLGVBQVcsQ0FBQ24wRCxJQUFaLENBQWlCLEdBQWpCLEVBQXNCcTBELGFBQXRCLEVBQ0VsdkQsS0FERixDQUNRLE1BRFIsRUFDZ0IsS0FBSzBULEtBRHJCLEVBRUUxVCxLQUZGLENBRVEsU0FGUixFQUVtQixLQUFLMDZDLGNBRnhCLENBTDhEO0FBUTlELEdBdlU4Qjs7QUF5VS9COzs7Ozs7O0FBT0FqNUIsZ0JBaFYrQiwwQkFnVmhCRixZQWhWZ0IsRUFnVkZ4UCxRQWhWRSxFQWdWUXZjLEtBaFZSLEVBZ1ZlO0FBQUEsUUFDdkNxVSxFQUFFLEdBQUcsSUFEa0M7QUFBQSxRQUV2Q3BILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRjJCO0FBSTdDb0gsTUFBRSxDQUFDOU4sT0FBSCxDQUFXaUUsS0FBWCxDQUFpQixZQUFqQixFQUErQnlDLE1BQU0sQ0FBQzZXLGFBQVAsR0FBdUIsU0FBdkIsR0FBbUMsUUFBbEUsQ0FKNkMsRUFPekM3VyxNQUFNLENBQUM2VyxhQVBrQyxLQVN4Q3pkLHdGQUFPLElBQUlBLHdGQUFPLENBQUMrQyxJQUFSLEtBQWlCLE1BVFksSUFVM0NpTCxFQUFFLENBQUN2WCxLQUFILENBQVM0cEQsTUFBVCxFQVYyQyxFQWN4QzM2QixZQWR3QyxLQWdCM0MsQ0FBQ2hsQixVQUFVLENBQUNzTixFQUFELENBQVgsSUFBbUJBLEVBQUUsQ0FBQ3ZYLEtBQUgsQ0FBUzRwRCxNQUFULEVBaEJ3QixFQWtCM0MzakQsTUFBTSxDQUFDQyxJQUFQLENBQVloRCxLQUFLLENBQUNvSixJQUFsQixFQUF3QmxGLE9BQXhCLENBQWdDLFVBQUFyQyxDQUFDLEVBQUk7QUFBQSxVQUM5QjJFLElBQUksR0FBR1csVUFBVSxDQUFDdEYsQ0FBRCxDQURhO0FBQUEsVUFFOUI4M0QsSUFBSSxHQUFHdGxELEVBQUUsdUJBQWdCN04sSUFBaEIsRUFBRixDQUEwQnhHLEtBQUssQ0FBQ2t0QixPQUFOLENBQWNyckIsQ0FBZCxDQUExQixLQUZ1QjtBQUlwQ3dTLFFBQUUsaUJBQVU3TixJQUFWLGlCQUFGLENBQStCK1YsUUFBL0IsQ0FKb0MsRUFLcENsSSxFQUFFLGlCQUFVN04sSUFBVixpQkFBRixDQUErQm16RCxJQUEvQixFQUFxQ3A5QyxRQUFyQyxFQUErQ0EsUUFBL0MsQ0FMb0M7QUFNcEMsS0FORCxDQWxCMkM7QUEyQjdDLEdBM1c4Qjs7QUE2Vy9COzs7O0FBSUE0N0MsZ0JBalgrQiw0QkFpWGQ7QUFDaEIsUUFBTTlqRCxFQUFFLEdBQUcsSUFBWDtBQUVBQSxNQUFFLENBQUN5USxNQUFILENBQVU7QUFDVHJKLG9CQUFjLElBREw7QUFFVHdULFdBQUssRUFBRTVhLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTJlLFlBRlI7QUFHVEcsa0JBQVksSUFISDtBQUlUL0csdUJBQWlCLElBSlI7QUFLVDQwQyxtQkFBYTtBQUxKLEtBQVYsQ0FIZ0IsRUFXaEJ2bEQsRUFBRSxDQUFDcEgsTUFBSCxDQUFVcXBCLGdCQUFWLENBQTJCL3hCLElBQTNCLENBQWdDOFAsRUFBRSxDQUFDaUQsR0FBbkMsRUFBd0NqRCxFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFMLEVBQXhDLENBWGdCO0FBWWhCLEdBN1g4Qjs7QUErWC9COzs7Ozs7QUFNQStRLGtCQXJZK0IsNEJBcVlkMVUsY0FyWWMsRUFxWUVnQixXQXJZRixFQXFZZTtBQUFBLFFBRXpDakUsUUFGeUM7QUFBQSxRQUN2Q25FLEVBQUUsR0FBRyxJQURrQztBQUl6Q29JLGVBQVcsSUFBSUEsV0FBVyxDQUFDRCxRQUpjLEdBSzVDaEUsUUFBUSxHQUFHaUUsV0FBVyxDQUFDRCxRQUxxQixJQU81Q2hFLFFBQVEsR0FBR25FLEVBQUUsQ0FBQzlOLE9BQUgsQ0FBV0UsTUFBWCxZQUFzQkMsY0FBSyxDQUFDcEssS0FBNUIsRUFQaUMsRUFReENtZixjQVJ3QyxLQVF0QmpELFFBQVEsR0FBR0EsUUFBUSxDQUFDaEssVUFBVCxFQVJXLElBVzdDNkYsRUFBRSxDQUFDOU4sT0FBSCxDQUFXbEIsSUFBWCxDQUFnQixXQUFoQixFQUE2QmdQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsU0FBaEIsQ0FBN0IsQ0FYNkMsRUFZN0NrRCxRQUFRLENBQUNuVCxJQUFULENBQWMsV0FBZCxFQUEyQmdQLEVBQUUsQ0FBQ2lCLFlBQUgsQ0FBZ0IsTUFBaEIsQ0FBM0IsQ0FaNkM7QUFhN0MsR0FsWjhCOztBQW9aL0I7Ozs7O0FBS0FtakQsV0F6WitCLHVCQXlabkI7QUFBQSxRQUNMcGtELEVBQUUsR0FBRyxJQURBO0FBQUEsUUFFUG1rRCxNQUFNLEdBQUdua0QsRUFBRSxDQUFDcEgsTUFBSCxDQUFVOHFCLGFBRlo7QUFZWCxXQVJJeWdDLE1BUUosS0FQSzEyRCxVQUFVLENBQUMwMkQsTUFBRCxDQU9mLEdBTkVBLE1BQU0sR0FBR0EsTUFBTSxDQUFDbmtELEVBQUUsQ0FBQ2dPLFVBQUgsQ0FBY2hPLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXRCLENBQUQsRUFBaUM5RCxFQUFFLENBQUNpTyxJQUFwQyxDQU1qQixHQUxZak8sRUFBRSxDQUFDcUQsWUFBSCxNQUFxQjhnRCxNQUFNLENBQUN4dkQsS0FBUCxDQUFhL0YsS0FBYixDQUtqQyxLQUpFdTFELE1BQU0sR0FBR0EsTUFBTSxDQUFDenpELEdBQVAsQ0FBVyxVQUFBbEQsQ0FBQztBQUFBLGFBQUl3UyxFQUFFLENBQUNpTyxJQUFILENBQVFqTyxFQUFFLENBQUNzRCxTQUFILENBQWE5VixDQUFiLENBQVIsQ0FBSjtBQUFBLEtBQVosQ0FJWCxJQUFPMjJELE1BQVA7QUFDQTtBQXRhOEIsQ0FBMUIsQzs7Ozs7OztBQ2pCTjs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBeHhELE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7O0FBSUFuUyxVQUwrQixzQkFLcEI7QUFDVixRQUFNOU0sRUFBRSxHQUFHLElBQVg7QUFFQUEsTUFBRSxDQUFDbUQsU0FBSCxHQUFlLElBSEwsRUFLVm5ELEVBQUUsQ0FBQ3dsRCxZQUFILEVBTFUsRUFNVnhsRCxFQUFFLENBQUN5bEQsaUJBQUgsRUFOVTtBQU9WLEdBWjhCOztBQWMvQjs7Ozs7QUFLQXp1QyxlQW5CK0IsMkJBbUJKO0FBQUEsUUFBYnhiLElBQWE7QUFBQSxRQUNwQndFLEVBQUUsR0FBRyxJQURlO0FBQUEsUUFFcEJ3d0IsV0FBVyxHQUFHeHdCLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVWlTLFlBRko7QUFJMUI3SyxNQUFFLENBQUMrVyxlQUFILEVBSjBCO0FBTTFCLFFBQU0xc0IsVUFBVSxHQUFHMlYsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUNoSSxVQUF6QixFQUFuQjtBQUVJbW1DLGVBQVcsSUFBSWgxQixJQVJPLEdBU3pCd0UsRUFBRSxDQUFDMGxELG1CQUFILENBQXVCcjdELFVBQXZCLEVBQW1DbW1DLFdBQVcsQ0FBQ3o3QixJQUEvQyxDQVR5QixHQVVmeUcsSUFBSSxPQVZXLEtBV3pCd0UsRUFBRSxDQUFDaUQsR0FBSCxDQUFPMGlELE1BQVAsRUFYeUIsRUFhekJ0N0QsVUFBVSxDQUNSbWtCLEVBREYsQ0FDSyxPQURMLEVBQ2MsSUFEZCxFQUVFQSxFQUZGLENBRUssT0FGTCxFQUVjLElBRmQsQ0FieUI7QUFpQjFCLEdBcEM4Qjs7QUFzQy9COzs7O0FBSUFnM0MsY0ExQytCLDBCQTBDaEI7QUFBQSxRQUNSeGxELEVBQUUsR0FBRyxJQURHO0FBQUEsUUFFUnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRko7QUFBQSxRQUlSNjNCLElBQUksR0FBR20xQixnRkFBTSxHQUFHMTlDLFFBQVQsQ0FBa0IsQ0FBbEIsRUFDWHNHLEVBRFcsQ0FDUixPQURRLEVBQ0N4TyxFQUFFLENBQUM2bEQsV0FBSCxDQUFlcnFELElBQWYsQ0FBb0J3RSxFQUFwQixDQURELEVBRVh3TyxFQUZXLENBRVIsTUFGUSxFQUVBeE8sRUFBRSxDQUFDOGxELE1BQUgsQ0FBVXRxRCxJQUFWLENBQWV3RSxFQUFmLENBRkEsRUFHWHdPLEVBSFcsQ0FHUixLQUhRLEVBR0R4TyxFQUFFLENBQUMrbEQsU0FBSCxDQUFhdnFELElBQWIsQ0FBa0J3RSxFQUFsQixDQUhDLENBSkM7QUFTZDs7QUFnQkE7Ozs7O0FBZkF5d0IsUUFBSSxDQUFDdTFCLGNBQUwsR0FBc0IsWUFBTTtBQUMzQixVQUFNN0IsTUFBTSxHQUFHdnJELE1BQU0sQ0FBQzZtQixXQUFQLElBQXNCLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FBckM7QUFFQSxhQUFPLENBQUMwa0MsTUFBTSxDQUFDLENBQUQsQ0FBUCxFQUFZbjJELElBQUksQ0FBQ2tOLEdBQUwsQ0FBUzhFLEVBQUUsQ0FBQ213QixlQUFILEtBQXVCZzBCLE1BQU0sQ0FBQyxDQUFELENBQXRDLEVBQTJDQSxNQUFNLENBQUMsQ0FBRCxDQUFqRCxDQUFaLENBQVA7QUFDQSxLQWRhLEVBZ0JkMXpCLElBQUksQ0FBQ0MsaUJBQUwsR0FBeUIsWUFBVztBQUFBLFVBQzdCbEIsS0FBSyxHQUFHcGhDLFVBQVUsQ0FBQzRSLEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzJaLFNBQUwsRUFBRCxDQUFWLEdBQStCM2MsVUFBVSxDQUFDNFIsRUFBRSxDQUFDOHdCLGFBQUgsRUFBRCxDQURwQjtBQUFBLFVBRTdCcXpCLE1BQU0sR0FBRyxLQUFLNkIsY0FBTCxFQUZvQjtBQU1uQyxhQUZBLEtBQUs1c0QsV0FBTCxDQUFpQixDQUFDK3FELE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWTMwQixLQUFiLEVBQW9CMjBCLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWTMwQixLQUFoQyxDQUFqQixDQUVBLEVBQU8sSUFBUDtBQUNBLEtBdkJhLEVBOEJkaUIsSUFBSSxDQUFDdzFCLG9CQUFMLEdBQTRCLFVBQUFDLFNBQVMsRUFBSTtBQUV4Q2xtRCxRQUFFLENBQUMzRyxTQUFILElBQWdCMkcsRUFBRSxDQUFDM0csU0FBSCxDQUFhSCxLQUFiLENBQW1COEcsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLOEgsS0FBTCxFQUFuQixDQUZ3QjtBQUl4QztBQUp3QyxVQUtsQ1csUUFBUSxHQUFHcXNELFNBQVMsQ0FDekJ0dEQsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQixVQUF0QixHQUFtQyxVQURWLENBQVQsQ0FFZkgsRUFBRSxDQUFDM0csU0FBSCxJQUFnQjJHLEVBQUUsQ0FBQzVPLENBRkosQ0FMdUI7QUFBQSxVQVNsQ21JLE1BQU0sR0FBR3lHLEVBQUUsQ0FBQzR3QixXQUFILENBQWUvMkIsUUFBUSxDQUFDTixNQUFULEVBQWYsQ0FUeUI7QUFBQSxVQVVsQzRzRCxPQUFPLEdBQUd2dEQsTUFBTSxDQUFDMmUsWUFWaUI7QUFZeEMxZCxjQUFRLENBQUNOLE1BQVQsQ0FBZ0JBLE1BQWhCLEVBQXdCeUcsRUFBRSxDQUFDa08sVUFBM0IsQ0Fad0MsRUFjeENsTyxFQUFFLENBQUNtRCxTQUFILEdBQWVuRCxFQUFFLENBQUM4ckIsa0JBQUgsQ0FBc0JqeUIsUUFBdEIsQ0FkeUIsRUFleENtRyxFQUFFLENBQUN1QyxLQUFILENBQVMxSixLQUFULENBQWVtSCxFQUFFLENBQUNtRCxTQUFsQixDQWZ3QyxFQWlCcENnakQsT0FqQm9DLEtBbUJ2QyxDQUFDbm1ELEVBQUUsQ0FBQzNHLFNBQUosS0FBa0IyRyxFQUFFLENBQUMzRyxTQUFILEdBQWUyRyxFQUFFLENBQUM1TyxDQUFILENBQUswSSxJQUFMLEVBQWpDLENBbkJ1QyxFQW9CdkNrRyxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLENBQVlBLE1BQVosQ0FwQnVDO0FBc0J4QyxLQXBEYSxFQXNEZHlHLEVBQUUsQ0FBQ3l3QixJQUFILEdBQVVBLElBdERJO0FBdURkLEdBakc4Qjs7QUFtRy9COzs7O0FBSUFvMUIsYUF2RytCLHlCQXVHakI7QUFBQSxRQUNQN2xELEVBQUUsR0FBRyxJQURFO0FBQUEsUUFFUGpPLEtBQUssR0FBR0Msd0ZBQU8sQ0FBQ28wRCxXQUZUO0FBSVJyMEQsU0FKUSxLQVFiaU8sRUFBRSxDQUFDeXdCLElBQUgsQ0FBUTQxQixVQUFSLEdBQXFCdDBELEtBUlIsRUFTYmpDLE1BQU0sQ0FBQ2tRLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVSttQixnQkFBWCxFQUE2QjNmLEVBQUUsQ0FBQ2lELEdBQWhDLEVBQXFDbFIsS0FBckMsQ0FUTztBQVViLEdBakg4Qjs7QUFtSC9COzs7O0FBSUErekQsUUF2SCtCLG9CQXVIdEI7QUFBQSxRQUNGOWxELEVBQUUsR0FBRyxJQURIO0FBQUEsUUFFRnBILE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlY7QUFBQSxRQUdGN0csS0FBSyxHQUFHQyx3RkFITjs7QUFLUixRQUNFNEcsTUFBTSxDQUFDaVMsWUFBUixJQUNDOVksS0FBSyxDQUFDcTBELFdBRFAsSUFFQXBtRCxFQUFFLENBQUM2RyxtQkFBSCxDQUF1QjdHLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQS9CLEVBQXdDdFYsTUFBeEMsS0FBbUQsQ0FIcEQ7QUFBQSxVQVFNODNELFdBQVcsR0FBR3YwRCxLQUFLLENBQUNxMEQsV0FBTixDQUFrQnJ4RCxJQUFsQixLQUEyQixXQVIvQztBQUFBLFVBU013eEQsU0FBUyxHQUFHeDBELEtBQUssQ0FBQ3EwRCxXQUFOLENBQWtCSSxVQUFsQixHQUErQixDQVRqRDtBQUFBLFVBVU1OLFNBQVMsR0FBR24wRCxLQUFLLENBQUNtMEQsU0FWeEI7QUFZSSxPQUFDSSxXQUFELElBQWdCQyxTQUFoQixJQUE2QnZtRCxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLEdBQWM1RSxLQUFkLENBQW9CLFVBQUNuSCxDQUFELEVBQUlzRCxDQUFKO0FBQUEsZUFBVXRELENBQUMsS0FBS3dTLEVBQUUsQ0FBQ2tPLFVBQUgsQ0FBY3BkLENBQWQsQ0FBaEI7QUFBQSxPQUFwQixDQVpqQyxJQWFDa1AsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxDQUFZeUcsRUFBRSxDQUFDa08sVUFBZixDQWJELEVBZ0JBbE8sRUFBRSxDQUFDeXdCLElBQUgsQ0FBUXcxQixvQkFBUixDQUE2QkMsU0FBN0IsQ0FoQkEsRUFrQklsbUQsRUFBRSxDQUFDeUMsYUFBSCxNQUFzQnpDLEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzJaLFNBQUwsR0FBaUIsQ0FBakIsTUFBd0IvSyxFQUFFLENBQUNrTyxVQUFILENBQWMsQ0FBZCxDQWxCbEQsSUFtQkNsTyxFQUFFLENBQUM1TyxDQUFILENBQUttSSxNQUFMLENBQVksQ0FBQ3lHLEVBQUUsQ0FBQ2tPLFVBQUgsQ0FBYyxDQUFkLElBQW1CLEtBQXBCLEVBQTJCbE8sRUFBRSxDQUFDNU8sQ0FBSCxDQUFLMlosU0FBTCxHQUFpQixDQUFqQixDQUEzQixDQUFaLENBbkJELEVBc0JBL0ssRUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1RySixzQkFBYyxJQURMO0FBRVR3VCxhQUFLLEVBQUVoaUIsTUFBTSxDQUFDMmUsWUFGTDtBQUdURyxvQkFBWSxJQUhIO0FBSVRtRCxxQkFBYSxJQUpKO0FBS1QwcUMscUJBQWE7QUFMSixPQUFWLENBdEJBLEVBOEJBdmxELEVBQUUsQ0FBQzBKLFdBQUgsR0FBaUI0OEMsV0E5QmpCLEVBK0JBeDJELE1BQU0sQ0FBQzhJLE1BQU0sQ0FBQzhtQixXQUFSLEVBQXFCMWYsRUFBRSxDQUFDaUQsR0FBeEIsRUFBNkJqRCxFQUFFLENBQUNtRCxTQUFILENBQWE1SixNQUFiLEVBQTdCLENBL0JOO0FBQUE7QUFnQ0EsR0E1SjhCOztBQThKL0I7Ozs7QUFJQXdzRCxXQWxLK0IsdUJBa0tuQjtBQUFBLFFBQ0wvbEQsRUFBRSxHQUFHLElBREE7QUFBQSxRQUVMcW1ELFVBQVUsR0FBR3JtRCxFQUFFLENBQUN5d0IsSUFBSCxDQUFRNDFCLFVBRmhCO0FBSVg7QUFDSSxLQUFDQSxVQUFELElBQ0Z0MEQsS0FBSyxJQUFJczBELFVBQVUsQ0FBQ3R2RCxPQUFYLEtBQXVCaEYsS0FBSyxDQUFDZ0YsT0FBdEMsSUFBaURzdkQsVUFBVSxDQUFDcnZELE9BQVgsS0FBdUJqRixLQUFLLENBQUNpRixPQU5yRSxLQVdYZ0osRUFBRSxDQUFDK1csZUFBSCxFQVhXLEVBWVgvVyxFQUFFLENBQUN5bUQsVUFBSCxFQVpXLEVBY1gzMkQsTUFBTSxDQUFDa1EsRUFBRSxDQUFDcEgsTUFBSCxDQUFVZ25CLGNBQVgsRUFBMkI1ZixFQUFFLENBQUNpRCxHQUE5QixFQUFtQ2pELEVBQUUsQ0FBQ0EsRUFBRSxDQUFDbUQsU0FBSCxHQUFlLFdBQWYsR0FBNkIsTUFBOUIsQ0FBRixDQUF3QzVKLE1BQXhDLEVBQW5DLENBZEs7QUFlWCxHQWpMOEI7O0FBbUwvQjs7Ozs7QUFLQXUzQixlQXhMK0IsMkJBd0xmO0FBQ1QsUUFBQTl3QixFQUFFLEdBQUcsSUFBTDtBQUFBLFFBQ0FwSCxNQURBLEdBQ1NvSCxFQUFFLENBQUNwSCxNQURaO0FBQUEsaURBRVdvSCxFQUFFLENBQUNrTyxVQUZkO0FBQUEsUUFFRHZjLEdBRkM7QUFBQSxRQUVJdUosR0FGSjs7QUFZTixXQVJJck4sU0FBUyxDQUFDK0ssTUFBTSxDQUFDa25CLFVBQVIsQ0FRYixLQVBDbnVCLEdBQUcsR0FBR21ELFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FBQ25ELEdBQUQsRUFBTWlILE1BQU0sQ0FBQ2tuQixVQUFiLENBQVIsQ0FPaEIsR0FKSWp5QixTQUFTLENBQUMrSyxNQUFNLENBQUNtbkIsVUFBUixDQUliLEtBSEM3a0IsR0FBRyxHQUFHcEcsU0FBUyxDQUFDLEtBQUQsRUFBUSxDQUFDb0csR0FBRCxFQUFNdEMsTUFBTSxDQUFDbW5CLFVBQWIsQ0FBUixDQUdoQixHQUFPLENBQUNwdUIsR0FBRCxFQUFNdUosR0FBTixDQUFQO0FBQ0EsR0F0TThCOztBQXdNL0I7Ozs7O0FBS0F1ckQsWUE3TStCLHNCQTZNcEJ2dUQsS0E3TW9CLEVBNk1iO0FBQ2pCLFFBQU04SCxFQUFFLEdBQUcsSUFBWDs7QUFFQSxRQUFJQSxFQUFFLENBQUNtRCxTQUFQLEVBQWtCO0FBQUEsVUFDWDB0QixVQUFVLEdBQUc3d0IsRUFBRSxDQUFDbUQsU0FBSCxDQUFhNUosTUFBYixFQURGO0FBQUEsVUFFWHl6QixPQUFPLEdBQUdodEIsRUFBRSxDQUFDaU8sSUFBSCxDQUFRMVUsTUFBUixFQUZDO0FBQUEsVUFHWG10RCxLQUFLLEdBQUcsSUFIRztBQUFBLFVBS1hDLFlBQVksR0FBRyxDQUFDOTFCLFVBQVUsQ0FBQyxDQUFELENBQVYsSUFBaUI3RCxPQUFPLENBQUMsQ0FBRCxDQUF4QixJQUFnQzZELFVBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0I2MUIsS0FBakIsSUFBMkIxNUIsT0FBTyxDQUFDLENBQUQsQ0FBbEUsTUFDbkJBLE9BQU8sQ0FBQyxDQUFELENBQVAsSUFBYzZELFVBQVUsQ0FBQyxDQUFELENBQXhCLElBQStCN0QsT0FBTyxDQUFDLENBQUQsQ0FBUCxJQUFlNkQsVUFBVSxDQUFDLENBQUQsQ0FBVixHQUFnQjYxQixLQUQzQyxDQUxKO0FBQUEsT0FTYnh1RCxLQUFLLElBQUl5dUQsWUFUSSxNQVVoQjNtRCxFQUFFLENBQUN1QyxLQUFILENBQVMxSixLQUFULENBQWVtSCxFQUFFLENBQUNpTyxJQUFsQixDQVZnQixFQVdoQmpPLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS21JLE1BQUwsQ0FBWXlHLEVBQUUsQ0FBQ2lPLElBQUgsQ0FBUWxELFNBQVIsRUFBWixDQVhnQixFQVloQi9LLEVBQUUsQ0FBQ21ELFNBQUgsR0FBZSxJQVpDO0FBY2pCO0FBQ0QsR0EvTjhCOztBQWlPL0I7Ozs7QUFJQXVpRCxxQkFyTytCLCtCQXFPWHI3RCxVQXJPVyxFQXFPQzBLLElBck9ELEVBcU9PO0FBQUEsUUFDL0JpTCxFQUFFLEdBQUcsSUFEMEI7QUFBQSxRQUUvQjRtRCxTQUFTLEdBQUc3eEQsSUFBSSxLQUFLLE1BQVQsR0FBa0JpTCxFQUFFLENBQUM2bUQsYUFBckIsR0FBcUM3bUQsRUFBRSxDQUFDeXdCLElBRnJCO0FBSXJDcG1DLGNBQVUsQ0FDUjZGLElBREYsQ0FDTzAyRCxTQURQLEVBRUVwNEMsRUFGRixDQUVLLGVBRkwsRUFFc0IsSUFGdEIsQ0FKcUM7QUFPckMsR0E1TzhCOztBQThPL0I7Ozs7QUFJQWkzQyxtQkFsUCtCLCtCQWtQWDtBQUFBLFFBQ2J6bEQsRUFBRSxHQUFHLElBRFE7QUFBQSxRQUVicEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQztBQUFBLFFBR2JzSCxTQUFTLEdBQUd0SCxNQUFNLENBQUN1SCxZQUhOO0FBQUEsUUFJZmhMLEtBQUssR0FBRyxDQUpPO0FBQUEsUUFLZkMsR0FBRyxHQUFHLENBTFM7QUFBQSxRQU1makksUUFBUSxHQUFHLElBTkk7QUFBQSxRQVFiMjVELElBQUksR0FBRztBQUNaOStELFVBQUksRUFBRWtZLFNBQVMsR0FBRyxHQUFILEdBQVMsR0FEWjtBQUVabFAsVUFBSSxFQUFFa1AsU0FBUyxHQUFHLFFBQUgsR0FBYyxPQUZqQjtBQUdadkMsV0FBSyxFQUFFdUMsU0FBUyxHQUFHLENBQUgsR0FBTztBQUhYLEtBUk07QUFjbkJGLE1BQUUsQ0FBQzZtRCxhQUFILEdBQW1CbG5CLGdGQUFNLEdBQ3ZCb25CLGFBRGlCLENBQ0gsQ0FERyxFQUVqQnY0QyxFQUZpQixDQUVkLE9BRmMsRUFFTCxZQUFXO0FBQ3ZCeE8sUUFBRSxDQUFDOGlELGFBQUgsSUFEdUIsRUFHbEIzMUQsUUFIa0IsS0FJdEJBLFFBQVEsR0FBRzZTLEVBQUUsQ0FBQy9OLElBQUgsQ0FBUWxCLE1BQVIsQ0FBZSxNQUFmLEVBQ1RDLElBRFMsQ0FDSixXQURJLEVBQ1NnUCxFQUFFLENBQUNnUSxRQURaLEVBRVRoZixJQUZTLENBRUosT0FGSSxFQUVLcUIsY0FBSyxDQUFDbkYsU0FGWCxFQUdUOEQsSUFIUyxDQUdKLE9BSEksRUFHS2tQLFNBQVMsR0FBR0YsRUFBRSxDQUFDMU8sS0FBTixHQUFjLENBSDVCLEVBSVROLElBSlMsQ0FJSixRQUpJLEVBSU1rUCxTQUFTLEdBQUcsQ0FBSCxHQUFPRixFQUFFLENBQUN6TyxNQUp6QixDQUpXLEdBV3ZCNEQsS0FBSyxHQUFHOHBDLGdHQUFPLENBQUMsSUFBRCxDQUFQLENBQWM2bkIsSUFBSSxDQUFDbnBELEtBQW5CLENBWGUsRUFZdkJ2SSxHQUFHLEdBQUdELEtBWmlCLEVBY3ZCaEksUUFBUSxDQUNONkQsSUFERixDQUNPODFELElBQUksQ0FBQzkrRCxJQURaLEVBQ2tCbU4sS0FEbEIsRUFFRW5FLElBRkYsQ0FFTzgxRCxJQUFJLENBQUM5MUQsSUFGWixFQUVrQixDQUZsQixDQWR1QixFQWtCdkJnUCxFQUFFLENBQUM2bEQsV0FBSCxFQWxCdUI7QUFtQnZCLEtBckJpQixFQXNCakJyM0MsRUF0QmlCLENBc0JkLE1BdEJjLEVBc0JOLFlBQVc7QUFDdEJwWixTQUFHLEdBQUc2cEMsZ0dBQU8sQ0FBQyxJQUFELENBQVAsQ0FBYzZuQixJQUFJLENBQUNucEQsS0FBbkIsQ0FEZ0IsRUFHdEJ4USxRQUFRLENBQ042RCxJQURGLENBQ084MUQsSUFBSSxDQUFDOStELElBRFosRUFDa0JnRyxJQUFJLENBQUMyRCxHQUFMLENBQVN3RCxLQUFULEVBQWdCQyxHQUFoQixDQURsQixFQUVFcEUsSUFGRixDQUVPODFELElBQUksQ0FBQzkxRCxJQUZaLEVBRWtCaEQsSUFBSSxDQUFDbXRCLEdBQUwsQ0FBUy9sQixHQUFHLEdBQUdELEtBQWYsQ0FGbEIsQ0FIc0I7QUFNdEIsS0E1QmlCLEVBNkJqQnFaLEVBN0JpQixDQTZCZCxLQTdCYyxFQTZCUCxZQUFZO0FBQUE7QUFBQSxVQUNoQjNWLEtBQUssR0FBR21ILEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0JuRCxFQUFFLENBQUM1TyxDQURYOztBQWtCdEIsVUFmQTRPLEVBQUUsQ0FBQzhpRCxhQUFILElBZUEsRUFiQTMxRCxRQUFRLENBQ042RCxJQURGLENBQ084MUQsSUFBSSxDQUFDOStELElBRFosRUFDa0IsQ0FEbEIsRUFFRWdKLElBRkYsQ0FFTzgxRCxJQUFJLENBQUM5MUQsSUFGWixFQUVrQixDQUZsQixDQWFBLEVBVEltRSxLQUFLLEdBQUdDLEdBU1osWUFSZ0IsQ0FBQ0EsR0FBRCxFQUFNRCxLQUFOLENBUWhCLEVBUkVBLEtBUUYsWUFSU0MsR0FRVCxtQkFMSUQsS0FBSyxHQUFHLENBS1osS0FKQ0MsR0FBRyxJQUFJcEgsSUFBSSxDQUFDbXRCLEdBQUwsQ0FBU2htQixLQUFULENBSVIsRUFIQ0EsS0FBSyxHQUFHLENBR1QsR0FBSUEsS0FBSyxLQUFLQyxHQUFkLEVBQ0M0SyxFQUFFLENBQUNpRCxHQUFILENBQU93dEIsSUFBUCxDQUFZLENBQUN0N0IsS0FBRCxFQUFRQyxHQUFSLEVBQWExRSxHQUFiLENBQWlCLFVBQUFsRCxDQUFDO0FBQUEsZUFBSXFMLEtBQUssQ0FBQzgzQixNQUFOLENBQWFuakMsQ0FBYixDQUFKO0FBQUEsT0FBbEIsQ0FBWixDQURELEVBRUN3UyxFQUFFLENBQUMrbEQsU0FBSCxFQUZELE1BSUMsSUFBSS9sRCxFQUFFLENBQUNneUIsV0FBSCxFQUFKLEVBQ0NoeUIsRUFBRSxDQUFDbWdDLHlCQUFILENBQTZCM2tDLElBQTdCLENBQWtDLElBQWxDLEVBQXdDd0UsRUFBeEMsQ0FERCxNQUVPO0FBQ0EsWUFBQWpPLE1BQUssR0FBR0Msd0ZBQU8sQ0FBQ28wRCxXQUFSLElBQXVCcDBELHdGQUEvQjtBQUFBLG9CQUNTLGFBQWFELE1BQWIsR0FBcUIsQ0FBQ0EsTUFBSyxDQUFDZ0YsT0FBUCxFQUFnQmhGLE1BQUssQ0FBQ2lGLE9BQXRCLENBQXJCLEdBQXNELENBQUNqRixNQUFLLENBQUNYLENBQVAsRUFBVVcsTUFBSyxDQUFDVixDQUFoQixDQUQvRDtBQUFBO0FBQUEsWUFDQ0QsQ0FERDtBQUFBLFlBQ0lDLENBREo7QUFBQSxZQUVBbkYsTUFGQSxHQUVTM0UsUUFBUSxDQUFDcTFDLGdCQUFULENBQTBCeHJDLENBQTFCLEVBQTZCQyxDQUE3QixDQUZUOztBQUlOMk8sVUFBRSxDQUFDZ2dDLHNCQUFILENBQTBCeGtDLElBQTFCLENBQStCdFAsTUFBL0IsRUFBdUNxUSxpR0FBUSxDQUFDclEsTUFBRCxDQUFSLENBQWlCb3dDLEtBQWpCLEVBQXZDLEVBQWlFdDhCLEVBQWpFLENBTE07QUFNTjtBQUVGLEtBN0RpQixDQWRBO0FBNEVuQixHQTlUOEI7QUFnVS9CZ25ELG9CQWhVK0IsZ0NBZ1VWO0FBQUEsUUFDZGhuRCxFQUFFLEdBQUcsSUFEUztBQUFBLFFBRWRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZFO0FBQUEsUUFHZHF1RCxXQUFXLEdBQUdydUQsTUFBTSxDQUFDaW5CLGdCQUhQO0FBS2hCb25DLGVBQVcsSUFBSXJ1RCxNQUFNLENBQUNpUyxZQUFQLENBQW9COVYsSUFBcEIsS0FBNkIsTUFMNUIsS0FNZGlMLEVBQUUsQ0FBQ3l3QixJQUFILENBQVF5MkIsUUFOTSxHQWNsQmxuRCxFQUFFLENBQUN5d0IsSUFBSCxDQUFReTJCLFFBQVIsQ0FBaUIvd0QsS0FBakIsQ0FBdUIsU0FBdkIsRUFBa0MsSUFBbEMsQ0Fka0IsR0FPbEI2SixFQUFFLENBQUN5d0IsSUFBSCxDQUFReTJCLFFBQVIsR0FBbUJsbkQsRUFBRSxDQUFDa0gsV0FBSCxDQUFlblcsTUFBZixDQUFzQixLQUF0QixFQUNqQm9jLE9BRGlCLENBQ1Q5YSxjQUFLLENBQUMzSixNQURHLE1BRWpCcUksTUFGaUIsQ0FFVixNQUZVLEVBR2pCeWQsRUFIaUIsQ0FHZCxPQUhjLEVBR0x4TyxFQUFFLENBQUNpRCxHQUFILENBQU8waUQsTUFBUCxDQUFjbnFELElBQWQsQ0FBbUJ3RSxFQUFuQixDQUhLLEVBSWpCbU4sT0FKaUIsQ0FJVDlhLGNBQUssQ0FBQzFKLGVBSkcsTUFLakJ3RCxJQUxpQixDQUtaODZELFdBQVcsQ0FBQzk2RCxJQUFaLElBQW9CLFlBTFIsQ0FQRDtBQWlCcEI7QUFqVjhCLENBQTFCLEM7O0FDZk47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7SUFTTWc3RCxlQUFlLEdBQUcsVUFBQzNULE9BQUQsRUFBVTNwQyxLQUFWLEVBQWlCeEosRUFBakIsRUFBd0I7QUFDL0MsTUFBTTlQLElBQUksR0FBR2dNLGlHQUFRLENBQUNpM0MsT0FBTyxDQUFDNFQsU0FBUixJQUFELENBQXJCO0FBU0EsU0FQQTcyRCxJQUFJLENBQ0ZTLElBREYsQ0FDTyxJQURQLEVBQ2FxUCxFQURiLEVBRUVqRCxNQUZGLENBRVMsTUFGVCxFQUVpQixjQUZqQixFQUdFcE0sSUFIRixDQUdPLE9BSFAsRUFHZ0JULElBQUksQ0FBQ1MsSUFBTCxDQUFVLE9BQVYsQ0FIaEIsRUFJRUEsSUFKRixDQUlPLFFBSlAsRUFJaUJULElBQUksQ0FBQ1MsSUFBTCxDQUFVLFFBQVYsQ0FKakIsRUFLRW1GLEtBTEYsQ0FLUSxNQUxSLEVBS2dCMFQsS0FMaEIsQ0FPQSxFQUFPO0FBQ054SixNQUFFLEVBQUZBLEVBRE07QUFFTjlQLFFBQUksRUFBRUEsSUFBSSxDQUFDQSxJQUFMO0FBRkEsR0FBUDtBQUlBLEM7SUFJSzgyRCxnQkFBZ0IsR0FBRyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLEVBQWtDLFNBQWxDLEVBQTZDLFNBQTdDLEVBQXdELFNBQXhELEVBQW1FLFNBQW5FLEVBQThFLFNBQTlFLEVBQXlGLFNBQXpGLEVBQW9HLFNBQXBHLEMsRUFGekI7QUFDQTs7O0FBR0ExMEQsTUFBTSxDQUFDK1YsMkJBQWEsQ0FBQ3VXLFNBQWYsRUFBMEI7QUFDL0I7Ozs7OztBQU1BcW9DLGlCQVArQiw2QkFPYjtBQUFBLFFBRVhqeEQsSUFBSSxHQUFHOU8sUUFBUSxDQUFDOE8sSUFGTDtBQUFBLFFBR2JtOUMsT0FBTyxHQUFHbjlDLElBQUksb0JBSEQ7O0FBS2pCLFFBQUksQ0FBQ205QyxPQUFMLEVBQWM7QUFBQSxVQUVQK1QsSUFBSSxHQUFHaGdFLFFBQVEsQ0FBQzJsQixhQUFULENBQXVCLE1BQXZCLENBRkE7QUFJYnE2QyxVQUFJLENBQUNqbEQsU0FBTCxHQUFpQmpRLGNBQUssQ0FBQ3RJLFlBSlYsRUFLYnc5RCxJQUFJLENBQUNweEQsS0FBTCxDQUFXQyxPQUFYLEdBQXFCLE1BTFIsRUFNYkMsSUFBSSxDQUFDQyxXQUFMLENBQWlCaXhELElBQWpCLENBTmE7QUFRYixVQUFNakssT0FBTyxHQUFHcDJELE1BQU0sQ0FBQ3NnRSxnQkFBUCxDQUF3QkQsSUFBeEIsRUFBOEJFLGVBQTlDO0FBRUFGLFVBQUksQ0FBQ3JtQixVQUFMLENBQWdCM3FDLFdBQWhCLENBQTRCZ3hELElBQTVCLENBVmEsRUFZVGpLLE9BQU8sQ0FBQzMxRCxPQUFSLFFBQTZCLENBQUMsQ0FackIsS0FhWjZyRCxPQUFPLEdBQUc4SixPQUFPLENBQ2ZqdEQsT0FEUSxDQUNBLDJCQURBLEVBQzZCLEVBRDdCLEVBRVJPLEtBRlEsTUFHUkYsR0FIUSxDQUdKLFVBQUFsRCxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDa3NELElBQUYsR0FBU3JwRCxPQUFULENBQWlCLFVBQWpCLEVBQTZCLEVBQTdCLENBQUo7QUFBQSxPQUhHLEVBSVIyRCxNQUpRLENBSUQwekQsT0FKQyxDQWJFLEVBbUJacnhELElBQUksb0JBQUosR0FBaUJtOUMsT0FuQkw7QUFxQmI7O0FBRUQsV0FBT0EsT0FBUDtBQUNBLEdBcEM4QjtBQXNDL0IxcEMsZUF0QytCLDJCQXNDZjtBQUFBLFFBQ1Q5SixFQUFFLEdBQUcsSUFESTtBQUFBLFFBRVRwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZIO0FBQUEsUUFHVCt1RCxNQUFNLEdBQUcvdUQsTUFBTSxDQUFDaW9CLFdBSFA7QUFBQSxRQUlUcEQsUUFBUSxHQUFHN2tCLE1BQU0sQ0FBQ2dvQixVQUpUO0FBQUEsUUFLVGtOLEdBQUcsR0FBRyxFQUxHO0FBQUEsUUFPWDBsQixPQUFPLEdBQUcza0QsUUFBUSxDQUFDK0osTUFBTSxDQUFDc3BCLGFBQVIsQ0FBUixHQUFpQ3RwQixNQUFNLENBQUNzcEIsYUFBeEMsR0FDYjBsQywyRkFBYyxDQUFDNW5ELEVBQUUsQ0FBQ3NuRCxlQUFILE1BQXdCRCxnQkFBekIsQ0FBZCxDQUF5RG51RCxLQUF6RCxFQVJjO0FBQUEsUUFVVDJ1RCxvQkFBb0IsR0FBR3JVLE9BVmQ7O0FBWWYsUUFBSS9sRCxVQUFVLENBQUNtTCxNQUFNLENBQUMwVyxXQUFSLENBQWQsRUFBb0M7QUFBQSxVQUM3Qm14QyxLQUFLLEdBQUc3bkQsTUFBTSxDQUFDMFcsV0FBUCxFQURxQjtBQUFBLFVBSTdCdzRDLGlCQUFpQixHQUFHdFUsT0FBTyxDQUFDOWlELEdBQVIsQ0FBWSxVQUFDbUMsQ0FBRCxFQUFJOEssS0FBSixFQUFjO0FBQUEsWUFDN0NrTSxLQUFLLEdBQUdoWCxDQUFDLENBQUN4QyxPQUFGLENBQVUsYUFBVixFQUF5QixFQUF6QixDQURxQztBQUFBLFlBRTdDZ1EsRUFBRSxhQUFNTCxFQUFFLENBQUNxSixVQUFULHNCQUErQlEsS0FBL0IsY0FBd0NsTSxLQUF4QyxDQUYyQztBQUluRCxlQUFPd3BELGVBQWUsQ0FBQzFHLEtBQUssQ0FBQzlpRCxLQUFLLEdBQUc4aUQsS0FBSyxDQUFDanlELE1BQWYsQ0FBTixFQUE4QnFFLENBQTlCLEVBQWlDd04sRUFBakMsQ0FBdEI7QUFDQSxPQUx5QixDQUpTLEVBR25DOztBQVFBbXpDLGFBQU8sR0FBR3NVLGlCQUFpQixDQUFDcDNELEdBQWxCLENBQXNCLFVBQUFtQyxDQUFDO0FBQUEsOEJBQVlBLENBQUMsQ0FBQ3dOLEVBQWQ7QUFBQSxPQUF2QixDQVh5QixFQVluQ0wsRUFBRSxDQUFDdVAsUUFBSCxHQUFjdTRDLGlCQVpxQjtBQWFuQzs7QUFFRCxXQUFPLFVBQVN6NUQsQ0FBVCxFQUFZO0FBQUEsVUFHZHdiLEtBSGM7QUFBQSxVQUNaeEosRUFBRSxHQUFHaFMsQ0FBQyxDQUFDZ1MsRUFBRixJQUFTaFMsQ0FBQyxDQUFDMEYsSUFBRixJQUFVMUYsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFBMUIsSUFBaUNoUyxDQUQxQjtBQUFBLFVBRVowNUQsTUFBTSxHQUFHL25ELEVBQUUsQ0FBQ3c0QyxRQUFILENBQVluNEMsRUFBWixFQUFnQixDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE1BQW5CLENBQWhCLEtBQStDLENBQUNMLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVTJuQixVQUFWLENBQXFCbGdCLEVBQXJCLENBRjdDO0FBeUJsQixhQW5CSTVTLFVBQVUsQ0FBQ2s2RCxNQUFNLENBQUN0bkQsRUFBRCxDQUFQLENBbUJkLEdBbEJDd0osS0FBSyxHQUFHODlDLE1BQU0sQ0FBQ3RuRCxFQUFELENBQU4sQ0FBV2hTLENBQVgsQ0FrQlQsR0FmV3M1RCxNQUFNLENBQUN0bkQsRUFBRCxDQWVqQixHQWRDd0osS0FBSyxHQUFHODlDLE1BQU0sQ0FBQ3RuRCxFQUFELENBY2YsSUFWS3l0QixHQUFHLENBQUNubUMsT0FBSixDQUFZMFksRUFBWixJQUFrQixDQVV2QixJQVRFeXRCLEdBQUcsQ0FBQ3o0QixJQUFKLENBQVNnTCxFQUFULENBU0YsRUFOQ3dKLEtBQUssR0FBR2srQyxNQUFNLEdBQUdGLG9CQUFvQixDQUFDLzVCLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwWSxFQUFaLElBQWtCd25ELG9CQUFvQixDQUFDcjVELE1BQXhDLENBQXZCLEdBQ2JnbEQsT0FBTyxDQUFDMWxCLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwWSxFQUFaLElBQWtCbXpDLE9BQU8sQ0FBQ2hsRCxNQUEzQixDQUtULEVBSENtNUQsTUFBTSxDQUFDdG5ELEVBQUQsQ0FBTixHQUFhd0osS0FHZCxHQUFPcGMsVUFBVSxDQUFDZ3dCLFFBQUQsQ0FBVixHQUNOQSxRQUFRLENBQUM1VCxLQUFELEVBQVF4YixDQUFSLENBREYsR0FDZXdiLEtBRHRCO0FBRUEsS0EzQkQ7QUE0QkEsR0E3RjhCO0FBK0YvQkcsb0JBL0YrQixnQ0ErRlY7QUFBQSxRQUNkaEssRUFBRSxHQUFHLElBRFM7QUFBQSxRQUVkcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGRTtBQUFBLFFBR2QrdUQsTUFBTSxHQUFHL3VELE1BQU0sQ0FBQ3NwQixhQUhGO0FBQUEsUUFJZDRsQixTQUFTLEdBQUdsdkMsTUFBTSxDQUFDdXBCLGVBSkw7QUFBQSxRQU1kNmxDLE9BQU8sR0FBR2xnQixTQUFTLENBQUNsZ0MsSUFBVixLQUFtQixPQU5mO0FBQUEsUUFPZDFNLEdBQUcsR0FBRzRzQyxTQUFTLENBQUM1c0MsR0FBVixJQUFpQixHQVBUO0FBQUEsUUFRZGdILE1BQU0sR0FBRzRsQyxTQUFTLENBQUM1bEMsTUFBVixJQUNkNGxDLFNBQVMsQ0FBQzVsQyxNQUFWLENBQWlCMVQsTUFESCxHQUNZczVDLFNBQVMsQ0FBQzVsQyxNQUR0QixHQUMrQixFQVQxQjtBQVdwQixXQUFPclQsUUFBUSxDQUFDaTVDLFNBQUQsQ0FBUixHQUFzQixVQUFTbjRDLEtBQVQsRUFBZ0I7QUFDNUMsVUFBSWthLEtBQUssR0FBRzg5QyxNQUFNLENBQUNBLE1BQU0sQ0FBQ241RCxNQUFQLEdBQWdCLENBQWpCLENBQWxCOztBQUVBLFdBQUssSUFBV2hCLENBQVgsRUFBYytnQyxHQUFkLEVBQUl6OUIsQ0FBQyxHQUFHLENBQWIsRUFBeUJ5OUIsR0FBRyxHQUFHcnNCLE1BQU0sQ0FBQ3BSLENBQUQsQ0FBckMsRUFBMkNBLENBQUMsRUFBNUMsRUFHQyxJQUZBdEQsQ0FBQyxHQUFHdzZELE9BQU8sR0FBR3I0RCxLQUFILEdBQVlBLEtBQUssR0FBRyxHQUFSLEdBQWN1TCxHQUVyQyxFQUFJMU4sQ0FBQyxHQUFHK2dDLEdBQVIsRUFBYTtBQUNaMWtCLGFBQUssR0FBRzg5QyxNQUFNLENBQUM3MkQsQ0FBRCxDQURGO0FBRVo7QUFDQTs7QUFHRixhQUFPK1ksS0FBUDtBQUNBLEtBYk0sR0FhSCxJQWJKO0FBY0EsR0F4SDhCOztBQTBIL0I7Ozs7Ozs7QUFPQTAxQixjQWpJK0Isd0JBaUlsQkQsTUFqSWtCLEVBaUlWanhDLENBaklVLEVBaUlQO0FBQUEsUUFDakIyUixFQUFFLEdBQUcsSUFEWTtBQUFBLFFBRWpCcEgsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGSztBQUFBLFFBR2pCNlYsTUFBTSxHQUFHN1YsTUFBTSxDQUFDd3BCLFlBSEM7QUFBQSxRQUluQnZZLEtBQUssR0FBR3kxQixNQUFNLEdBQUc3d0IsTUFBSCxHQUFZek8sRUFBRSxDQUFDNkosS0FKVjtBQU1uQjNhLFlBQVEsQ0FBQzJhLEtBQUQsQ0FOVyxHQU90QkEsS0FBSyxHQUFHLFVBQUF4YixDQUFDLEVBQUk7QUFDWixVQUFNZ1MsRUFBRSxHQUFHaFMsQ0FBQyxDQUFDZ1MsRUFBYjtBQUVBLGFBQU9BLEVBQUUsSUFBSW9PLE1BQU4sR0FBZUEsTUFBTSxDQUFDcE8sRUFBRCxDQUFyQixHQUE0QkwsRUFBRSxDQUFDNkosS0FBSCxDQUFTeEosRUFBVCxDQUFuQztBQUNBLEtBWHFCLEdBWVozUyxRQUFRLENBQUNtYyxLQUFELENBWkksS0FhdEJBLEtBQUssR0FBRztBQUFBLGFBQU00RSxNQUFOO0FBQUEsS0FiYyxHQWlCbkJ2ZixRQUFRLENBQUNiLENBQUQsQ0FqQlcsR0FrQnRCMlIsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQ3pLLEdBQTVCLGNBQW1DeUcsQ0FBQyxDQUFDZ1MsRUFBckMsR0FDRWxLLEtBREYsQ0FDUSxNQURSLEVBQ2dCMFQsS0FBSyxDQUFDeGIsQ0FBRCxDQURyQixDQWxCc0IsR0FxQnRCMlIsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQzFHLEtBQTVCLGNBQXFDMEMsQ0FBckMsR0FDRWlPLElBREYsQ0FDTyxVQUFTak8sQ0FBVCxFQUFZO0FBQ2pCLFVBQU1rZ0MsR0FBRyxHQUFHMWtCLEtBQUssQ0FBQ3hiLENBQUQsQ0FBakI7QUFFQSxXQUFLOEgsS0FBTCxDQUFXaTlDLE1BQVgsR0FBb0I3a0IsR0FISCxFQUlqQixLQUFLcDRCLEtBQUwsQ0FBV2c5QyxJQUFYLEdBQWtCNWtCLEdBSkQ7QUFLakIsS0FORixDQXJCc0I7QUE2QnZCO0FBOUo4QixDQUExQixDOztBQ3ZDTjs7OztBQUlBO0FBQ0E7O0FBRUEsSUFBTTA1QixTQUFTLEdBQUcsVUFBQ2pvRCxFQUFELEVBQUtrb0QsU0FBTCxFQUFnQjE2RCxDQUFoQixFQUFzQjtBQUFBLE1BQ2pDb0wsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFEcUI7QUFBQSxNQUVqQzdELElBQUksa0JBQVdtekQsU0FBWCxpQkFGNkI7QUFBQSxNQUdqQ3pvRCxNQUFNLEdBQUc3RyxNQUFNLENBQUM3RCxJQUFELENBQU4sR0FDZDZELE1BQU0sQ0FBQzdELElBQUQsQ0FEUSxHQUNDaUwsRUFBRSxDQUFDNDZDLGtCQUpvQjtBQU12QyxTQUFPbjdDLE1BQU0sQ0FBQ2pTLENBQUQsQ0FBYjtBQUNBLENBUEQ7O0FBU0FtRixNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQnc3QixZQUQrQixzQkFDcEIyQixNQURvQixFQUNaO0FBQUEsUUFDWnA4QyxFQUFFLEdBQUcsSUFETztBQUFBLFFBRWRtb0QsVUFBVSxHQUFHbm9ELEVBQUUsQ0FBQ29vRCxPQUZGO0FBQUEsUUFHZEMsV0FBVyxHQUFHcm9ELEVBQUUsQ0FBQ3NvRCxRQUhIO0FBVWxCLFdBTElsTSxNQUFNLElBQUksQ0FBQ3A4QyxFQUFFLENBQUM0TixPQUFILENBQVcsT0FBWCxDQUtmLEtBSkN1NkMsVUFBVSxHQUFHbm9ELEVBQUUsQ0FBQ2duQyxxQkFJakIsRUFIQ3FoQixXQUFXLEdBQUdyb0QsRUFBRSxDQUFDZ25DLHFCQUdsQixHQUFPLFVBQVN4NUMsQ0FBVCxFQUFZZ2lDLEtBQVosRUFBbUJudkIsRUFBbkIsRUFBdUI7QUFDN0IsVUFBTVosTUFBTSxHQUFHTyxFQUFFLENBQUNoWSxJQUFILENBQVFza0MsS0FBUixDQUFjanNCLEVBQWQsTUFBc0IsSUFBdEIsR0FDZGdvRCxXQURjLEdBQ0FGLFVBRGY7QUFHQSxhQUFPMW9ELE1BQU0sQ0FBQ3ZQLElBQVAsQ0FBWThQLEVBQVosRUFBZ0J4UyxDQUFoQixFQUFtQmdpQyxLQUFuQixDQUFQO0FBQ0EsS0FMRDtBQU1BLEdBakI4QjtBQW1CL0I0NEIsU0FuQitCLG1CQW1CdkI1NkQsQ0FuQnVCLEVBbUJwQjtBQUNWLFdBQU95NkQsU0FBUyxDQUFDLElBQUQsRUFBTyxHQUFQLEVBQVl6NkQsQ0FBWixDQUFoQjtBQUNBLEdBckI4QjtBQXVCL0I4NkQsVUF2QitCLG9CQXVCdEI5NkQsQ0F2QnNCLEVBdUJuQjtBQUNYLFdBQU95NkQsU0FBUyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWF6NkQsQ0FBYixDQUFoQjtBQUNBLEdBekI4QjtBQTJCL0JvdEQsb0JBM0IrQiw4QkEyQlpwdEQsQ0EzQlksRUEyQlQ7QUFDckIsV0FBT0QsT0FBTyxDQUFDQyxDQUFELENBQVAsR0FBYSxDQUFDQSxDQUFkLEdBQWtCLEVBQXpCO0FBQ0EsR0E3QjhCO0FBK0IvQnc1Qyx1QkEvQitCLGlDQStCVHg1QyxDQS9CUyxFQStCTmdpQyxLQS9CTSxFQStCQztBQUMvQixxQkFBVSxDQUFDQSxLQUFLLEdBQUcsR0FBVCxFQUFjOXFCLE9BQWQsQ0FBc0IsQ0FBdEIsQ0FBVjtBQUNBLEdBakM4QjtBQW1DL0JpeEIsaUJBbkMrQiwyQkFtQ2Z4QixRQW5DZSxFQW1DTDtBQUFBLFFBQ25CbjBCLEVBQUUsR0FBRyxJQURjO0FBQUEsUUFFbkIwMUIsVUFBVSxHQUFHMTFCLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXdZLFdBRko7QUFBQSxRQUduQm0zQyxhQUFhLEdBQUcsVUFBQS82RCxDQUFDO0FBQUEsYUFBS0QsT0FBTyxDQUFDQyxDQUFELENBQVAsR0FBYSxDQUFDQSxDQUFkLEdBQWtCLEVBQXZCO0FBQUEsS0FIRTtBQUFBLFFBSXJCaVMsTUFBTSxHQUFHOG9ELGFBSlk7O0FBa0J6QixXQVhJOTZELFVBQVUsQ0FBQ2lvQyxVQUFVLENBQUNqMkIsTUFBWixDQVdkLEdBVkNBLE1BQU0sR0FBR2kyQixVQUFVLENBQUNqMkIsTUFVckIsR0FUV25SLFlBQVksQ0FBQ29uQyxVQUFVLENBQUNqMkIsTUFBWixDQVN2QixLQVJLaTJCLFVBQVUsQ0FBQ2oyQixNQUFYLENBQWtCMDBCLFFBQWxCLENBUUwsR0FQRTEwQixNQUFNLEdBQUdpMkIsVUFBVSxDQUFDajJCLE1BQVgsQ0FBa0IwMEIsUUFBbEIsV0FDUm8wQixhQURRLEdBQ1E3eUIsVUFBVSxDQUFDajJCLE1BQVgsQ0FBa0IwMEIsUUFBbEIsQ0FNbkIsR0FKRTEwQixNQUFNLEdBQUc7QUFBQSxhQUFNLEVBQU47QUFBQSxLQUlYLEdBQU9BLE1BQVA7QUFDQTtBQXREOEIsQ0FBMUIsQzs7QUNoQk47Ozs7QUFJQTtBQUNBO0FBRUE5TSxNQUFNLENBQUMrViwyQkFBYSxDQUFDdVcsU0FBZixFQUEwQjtBQUMvQjs7Ozs7OztBQU9BdVUsVUFSK0Isb0JBUXRCamtDLEdBUnNCLEVBUWpCSSxLQVJpQixFQVFVO0FBQUEsUUFBcEI2NEQsVUFBb0I7QUFDeEMsU0FBSzUvQyxLQUFMLENBQVdyWixHQUFYLElBQWtCaTVELFVBQVUsR0FBRyxLQUFLOTFCLFdBQUwsQ0FBaUIvaUMsS0FBakIsQ0FBSCxHQUE2QkEsS0FEakI7QUFFeEMsR0FWOEI7O0FBWS9COzs7OztBQUtBODRELGFBakIrQix1QkFpQm5CbDVELEdBakJtQixFQWlCZDtBQUFBOztBQUNoQjJELFdBQU8sQ0FBQzNELEdBQUQsQ0FBUCxDQUFhTSxPQUFiLENBQXFCLFVBQUFyQyxDQUFDO0FBQUEsYUFBSSxPQUFPLEtBQUksQ0FBQ29iLEtBQUwsQ0FBV3BiLENBQVgsQ0FBWDtBQUFBLEtBQXRCLENBRGdCO0FBRWhCLEdBbkI4Qjs7QUFxQi9COzs7Ozs7O0FBT0E0bEMsVUE1QitCLG9CQTRCdEI3akMsR0E1QnNCLEVBNEJHO0FBQUEsUUFBcEJpNUQsVUFBb0I7O0FBQ2pDLFFBQUlBLFVBQUosRUFBZ0I7QUFDZixVQUFNMWtELE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxXQUFLLElBQVd6RCxFQUFYLEVBQUl2UCxDQUFDLEdBQUcsQ0FBYixFQUFxQnVQLEVBQUUsR0FBRzlRLEdBQUcsQ0FBQ3VCLENBQUQsQ0FBN0IsRUFBbUNBLENBQUMsRUFBcEMsRUFDS3VQLEVBQUUsSUFBSSxLQUFLdUksS0FEaEIsSUFFRTlFLE9BQU8sQ0FBQ3pPLElBQVIsQ0FBYSxLQUFLcTlCLFdBQUwsQ0FBaUIsS0FBSzlwQixLQUFMLENBQVd2SSxFQUFYLENBQWpCLENBQWIsQ0FGRjs7QUFNQSxhQUFPeUQsT0FBUDtBQUNBOztBQUNBLFdBQU8sS0FBSzhFLEtBQUwsQ0FBV3JaLEdBQVgsS0FBbUIsSUFBMUI7QUFFRCxHQTFDOEI7O0FBNEMvQjs7Ozs7QUFLQXNzQyxZQWpEK0Isc0JBaURwQjZzQixHQWpEb0IsRUFpRGY7QUFDZixRQUFNMW9ELEVBQUUsR0FBRyxJQUFYOztBQUVBLFNBQUssSUFBTTVPLENBQVgsSUFBZ0I0TyxFQUFFLENBQUM0SSxLQUFuQixHQUVLOC9DLEdBQUcsSUFBSSxNQUFNMXVELElBQU4sQ0FBVzVJLENBQVgsQ0FGWixNQUdFNE8sRUFBRSxDQUFDNEksS0FBSCxDQUFTeFgsQ0FBVCxJQUFjLElBSGhCO0FBTUE7QUExRDhCLENBQTFCLEM7O0FDUE47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQXVCLE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9CZ3VCLGVBRCtCLHlCQUNqQmh4QyxNQURpQixFQUNUazRCLFFBRFMsRUFDQztBQUMvQixzQkFBV2w0QixNQUFYLGNBQXFCQSxNQUFNLEdBQUcsS0FBS3E2Qix1QkFBTCxDQUE2Qm5DLFFBQTdCLENBQTlCO0FBQ0EsR0FIOEI7QUFLL0J3aUIsV0FMK0IscUJBS3JCdG9ELENBTHFCLEVBS2xCO0FBQ1osV0FBTyxLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDbEcsSUFBekIsRUFBK0JrQyxDQUFDLENBQUNzUCxLQUFqQyxDQUFQO0FBQ0EsR0FQOEI7QUFTL0I0NEMsWUFUK0Isc0JBU3BCbG9ELENBVG9CLEVBU2pCO0FBQ2IsV0FBTyxLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDakcsS0FBekIsRUFBZ0NpQyxDQUFDLENBQUNnUyxFQUFsQyxDQUFQO0FBQ0EsR0FYOEI7QUFhL0Jzb0QsWUFiK0Isc0JBYXBCdDZELENBYm9CLEVBYWpCO0FBQ2IsV0FBTyxLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDMUcsS0FBekIsRUFBZ0MwQyxDQUFDLENBQUNzUCxLQUFsQyxDQUFQO0FBQ0EsR0FmOEI7QUFpQi9CaXJELGFBakIrQix1QkFpQm5CdjZELENBakJtQixFQWlCaEI7QUFDZCxXQUFPLEtBQUs0K0MsYUFBTCxDQUFtQjU2QyxjQUFLLENBQUN6RyxNQUF6QixFQUFpQ3lDLENBQUMsQ0FBQ2dTLEVBQW5DLENBQVA7QUFDQSxHQW5COEI7QUFxQi9CK0osd0JBckIrQixvQ0FxQk47QUFBQSxRQUNsQnBLLEVBQUUsR0FBRyxJQURhO0FBQUEsUUFFbEI2b0QsT0FBTyxHQUFHN29ELEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVWl1QixZQUFWLElBQTBCLEVBRmxCO0FBQUEsUUFHbEJpSCxHQUFHLEdBQUcsRUFIWTtBQUt4QixXQUFPLFVBQVN6L0IsQ0FBVCxFQUFZO0FBQ2xCLFVBQU1nUyxFQUFFLEdBQUdoUyxDQUFDLENBQUNnUyxFQUFGLElBQVNoUyxDQUFDLENBQUMwRixJQUFGLElBQVUxRixDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUExQixJQUFpQ2hTLENBQTVDO0FBTUEsYUFKSXkvQixHQUFHLENBQUNubUMsT0FBSixDQUFZMFksRUFBWixJQUFrQixDQUl0QixJQUhDeXRCLEdBQUcsQ0FBQ3o0QixJQUFKLENBQVNnTCxFQUFULENBR0QsRUFBT3dvRCxPQUFPLENBQUMvNkIsR0FBRyxDQUFDbm1DLE9BQUosQ0FBWTBZLEVBQVosSUFBa0J3b0QsT0FBTyxDQUFDcjZELE1BQTNCLENBQWQ7QUFDQSxLQVJEO0FBU0EsR0FuQzhCO0FBcUMvQjIrQyxXQXJDK0IscUJBcUNyQjkrQyxDQXJDcUIsRUFxQ2xCO0FBQ1osV0FBTyxLQUFLczZELFVBQUwsQ0FBZ0J0NkQsQ0FBaEIsSUFBcUIsS0FBSzQrQyxhQUFMLENBQW1CNTZDLGNBQUssQ0FBQ2hILElBQXpCLEVBQStCZ0QsQ0FBQyxDQUFDZ1MsRUFBakMsQ0FBNUI7QUFDQSxHQXZDOEI7QUF5Qy9CdXNDLFlBekMrQixzQkF5Q3BCditDLENBekNvQixFQXlDakI7QUFDYixXQUFPLEtBQUt1NkQsV0FBTCxDQUFpQnY2RCxDQUFqQixJQUFzQixLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDL0csS0FBekIsRUFBZ0MrQyxDQUFDLENBQUNnUyxFQUFsQyxDQUE3QjtBQUNBLEdBM0M4QjtBQTZDL0JteEMsYUE3QytCLHVCQTZDbkJuakQsQ0E3Q21CLEVBNkNoQjtBQUNkLFdBQU8sS0FBS3M2RCxVQUFMLENBQWdCdDZELENBQWhCLElBQXFCLEtBQUs0K0MsYUFBTCxDQUFtQjU2QyxjQUFLLENBQUN4SSxNQUF6QixFQUFpQ3dFLENBQUMsQ0FBQ3NQLEtBQW5DLENBQTVCO0FBQ0EsR0EvQzhCO0FBaUQvQm12QyxjQWpEK0Isd0JBaURsQnorQyxDQWpEa0IsRUFpRGY7QUFDZixXQUFPLEtBQUt1NkQsV0FBTCxDQUFpQnY2RCxDQUFqQixJQUFzQixLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDdkksT0FBekIsRUFBa0N1RSxDQUFDLENBQUNnUyxFQUFwQyxDQUE3QjtBQUNBLEdBbkQ4QjtBQXFEL0JrcUMsVUFyRCtCLG9CQXFEdEJsOEMsQ0FyRHNCLEVBcURuQjtBQUNYLFdBQU8sS0FBS3M2RCxVQUFMLENBQWdCdDZELENBQWhCLElBQXFCLEtBQUs0K0MsYUFBTCxDQUFtQjU2QyxjQUFLLENBQUM5SixHQUF6QixFQUE4QjhGLENBQUMsQ0FBQ3NQLEtBQWhDLENBQTVCO0FBQ0EsR0F2RDhCO0FBeUQvQndzQyxXQXpEK0IscUJBeURyQjk3QyxDQXpEcUIsRUF5RGxCO0FBQ1osV0FBTyxLQUFLdTZELFdBQUwsQ0FBaUJ2NkQsQ0FBakIsSUFBc0IsS0FBSzQrQyxhQUFMLENBQW1CNTZDLGNBQUssQ0FBQzdKLElBQXpCLEVBQStCNkYsQ0FBQyxDQUFDZ1MsRUFBakMsQ0FBN0I7QUFDQSxHQTNEOEI7QUE2RC9Cc29DLFVBN0QrQixvQkE2RHRCdDZDLENBN0RzQixFQTZEbkI7QUFDWCxXQUFPLEtBQUtzNkQsVUFBTCxDQUFnQnQ2RCxDQUFDLENBQUMwRixJQUFsQixJQUEwQixLQUFLazVDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDekssR0FBekIsRUFBOEJ5RyxDQUFDLENBQUMwRixJQUFGLENBQU9zTSxFQUFyQyxDQUFqQztBQUNBLEdBL0Q4QjtBQWlFL0I2bkMsV0FqRStCLHFCQWlFckI3NUMsQ0FqRXFCLEVBaUVsQjtBQUNaLFdBQU8sS0FBS3U2RCxXQUFMLENBQWlCdjZELENBQUMsQ0FBQzBGLElBQW5CLElBQTJCLEtBQUtrNUMsYUFBTCxDQUFtQjU2QyxjQUFLLENBQUN4SyxJQUF6QixFQUErQndHLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBQXRDLENBQWxDO0FBQ0EsR0FuRThCO0FBcUUvQnV3QyxXQXJFK0IscUJBcUVyQnZpRCxDQXJFcUIsRUFxRWxCO0FBQ1osV0FBTyxLQUFLczZELFVBQUwsQ0FBZ0J0NkQsQ0FBaEIsSUFBcUIsS0FBSzQrQyxhQUFMLENBQW1CNTZDLGNBQUssQ0FBQ3ZLLElBQXpCLEVBQStCdUcsQ0FBQyxDQUFDZ1MsRUFBakMsQ0FBNUI7QUFDQSxHQXZFOEI7QUF5RS9Cd3NDLFlBekUrQixzQkF5RXBCeCtDLENBekVvQixFQXlFakI7QUFDYixXQUFPLEtBQUt1NkQsV0FBTCxDQUFpQnY2RCxDQUFqQixJQUFzQixLQUFLNCtDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDdEssS0FBekIsRUFBZ0NzRyxDQUFDLENBQUNnUyxFQUFsQyxDQUE3QjtBQUNBLEdBM0U4QjtBQTZFL0JtaEQsYUE3RStCLHVCQTZFbkJuekQsQ0E3RW1CLEVBNkVoQnlDLENBN0VnQixFQTZFYjtBQUNqQixxQkFBVSxLQUFLbThDLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDOUcsTUFBekIsRUFBaUN1RixDQUFqQyxDQUFWLGNBQWlELFdBQVd6QyxDQUFYLEdBQWVBLENBQUMsU0FBaEIsR0FBeUIsRUFBMUU7QUFDQSxHQS9FOEI7QUFpRi9CNnZDLFlBakYrQixzQkFpRnBCN3ZDLENBakZvQixFQWlGakI7QUFDYixXQUFPLEtBQUs0K0MsYUFBTCxDQUFtQjU2QyxjQUFLLENBQUNqSSxTQUF6QixFQUFvQ2lFLENBQUMsQ0FBQ3NQLEtBQXRDLENBQVA7QUFDQSxHQW5GOEI7QUFxRi9CbXJELGFBckYrQix1QkFxRm5Cem9ELEVBckZtQixFQXFGZjtBQUFBLFFBQ1Qwb0QscUJBQXFCLEdBQUcsS0FBS253RCxNQUFMLENBQVl3bkIsWUFBWixDQUF5Qi9mLEVBQXpCLENBRGY7QUFBQSxRQUVYMm9ELGVBQWUsR0FBRyxFQUZQO0FBUWYsV0FKSUQscUJBSUosS0FIQ0MsZUFBZSxjQUFPMzJELGNBQUssQ0FBQ25HLE1BQWIsY0FBdUI2OEQscUJBQXZCLENBR2hCLEdBQU8sS0FBSzliLGFBQUwsQ0FBbUI1NkMsY0FBSyxDQUFDbkcsTUFBekIsRUFBaUNtVSxFQUFqQyxJQUF1QzJvRCxlQUE5QztBQUNBLEdBOUY4QjtBQWdHL0I3Z0IsWUFoRytCLHNCQWdHcEI5NUMsQ0FoR29CLEVBZ0dqQjtBQUNiLFdBQU8sS0FBSzQ2RCxZQUFMLENBQWtCNTZELENBQWxCLElBQXVCLEtBQUs2NkQsY0FBTCxDQUFvQjc2RCxDQUFwQixDQUE5QjtBQUNBLEdBbEc4QjtBQW9HL0I0NkQsY0FwRytCLHdCQW9HbEI1NkQsQ0FwR2tCLEVBb0dmO0FBQ2Ysc0JBQVcsS0FBS29kLGdCQUFMLENBQXNCOWpCLE9BQXRCLENBQThCMEcsQ0FBQyxDQUFDZ1MsRUFBaEMsS0FBdUMsQ0FBdkMsR0FBMkNoTyxjQUFLLENBQUM3SCxPQUFqRCxHQUEyRCxFQUF0RTtBQUNBLEdBdEc4QjtBQXdHL0IwK0QsZ0JBeEcrQiwwQkF3R2hCNzZELENBeEdnQixFQXdHYjtBQUNqQixzQkFBVyxLQUFLcWQsa0JBQUwsQ0FBd0IvakIsT0FBeEIsQ0FBZ0MwRyxDQUFDLENBQUNnUyxFQUFsQyxLQUF5QyxDQUF6QyxHQUE2Q2hPLGNBQUssQ0FBQ3BJLFNBQW5ELEdBQStELEVBQTFFO0FBQ0EsR0ExRzhCO0FBNEcvQnFzRCxnQkE1RytCLDBCQTRHaEJqb0QsQ0E1R2dCLEVBNEdiO0FBQ2pCLFdBQU9nRSxjQUFLLENBQUMxSSxTQUFOLEdBQWtCLEtBQUttL0QsV0FBTCxDQUFpQno2RCxDQUFDLENBQUNnUyxFQUFuQixDQUF6QjtBQUNBLEdBOUc4QjtBQWdIL0Jzc0MsZ0JBaEgrQiwwQkFnSGhCdCtDLENBaEhnQixFQWdIYjtBQUNqQixXQUFPZ0UsY0FBSyxDQUFDOUksU0FBTixHQUFrQixLQUFLdS9ELFdBQUwsQ0FBaUJ6NkQsQ0FBQyxDQUFDZ1MsRUFBbkIsQ0FBekI7QUFDQSxHQWxIOEI7QUFvSC9CNnBDLGVBcEgrQix5QkFvSGpCNzdDLENBcEhpQixFQW9IZDtBQUNoQixXQUFPZ0UsY0FBSyxDQUFDaEosUUFBTixHQUFpQixLQUFLeS9ELFdBQUwsQ0FBaUJ6NkQsQ0FBQyxDQUFDZ1MsRUFBbkIsQ0FBeEI7QUFDQSxHQXRIOEI7QUF3SC9CNG5DLGVBeEgrQix5QkF3SGpCNTVDLENBeEhpQixFQXdIZDtBQUNoQixXQUFPZ0UsY0FBSyxDQUFDeEosUUFBTixHQUFpQixLQUFLaWdFLFdBQUwsQ0FBaUJ6NkQsQ0FBQyxDQUFDMEYsSUFBRixDQUFPc00sRUFBeEIsQ0FBeEI7QUFDQSxHQTFIOEI7QUE0SC9CZzJDLGlCQTVIK0IsMkJBNEhmaG9ELENBNUhlLEVBNEhaO0FBQ2xCLFdBQU9nRSxjQUFLLENBQUM1SSxVQUFOLEdBQW1CLEtBQUtxL0QsV0FBTCxDQUFpQno2RCxDQUFDLENBQUNnUyxFQUFuQixDQUExQjtBQUNBLEdBOUg4QjtBQWdJL0JpMkIseUJBaEkrQixtQ0FnSVBuQyxRQWhJTyxFQWdJRztBQUNqQyxXQUFPQSxRQUFRLElBQUlBLFFBQVEsS0FBSyxDQUF6QixHQUNOLFdBQUlBLFFBQUosRUFBZTlqQyxPQUFmLENBQXVCLDBDQUF2QixFQUFtRSxHQUFuRSxDQURNLEdBQ29FLEVBRDNFO0FBRUEsR0FuSThCO0FBcUkvQjRyQyxnQkFySStCLDBCQXFJaEI1N0IsRUFySWdCLEVBcUlacEUsTUFySVksRUFxSUo7QUFDMUIscUJBQVVBLE1BQU0sSUFBSSxFQUFwQixjQUEwQjVKLGNBQUssQ0FBQ25HLE1BQU4sR0FBZSxLQUFLb3FDLHVCQUFMLENBQTZCajJCLEVBQTdCLENBQXpDO0FBQ0EsR0F2SThCO0FBeUkvQm1uQyxpQkF6SStCLDJCQXlJZjJoQixRQXpJZSxFQXlJTGx0RCxNQXpJSyxFQXlJRztBQUFBLFFBQzNCK0QsRUFBRSxHQUFHLElBRHNCO0FBQUEsUUFFM0I4dEIsR0FBRyxHQUFHcTdCLFFBQVEsSUFBSSxFQUZTO0FBSWpDLFdBQU9yN0IsR0FBRyxDQUFDdC9CLE1BQUosR0FDTnMvQixHQUFHLENBQUNwOUIsR0FBSixDQUFRLFVBQUEyUCxFQUFFO0FBQUEsYUFBSUwsRUFBRSxDQUFDaThCLGNBQUgsQ0FBa0I1N0IsRUFBbEIsRUFBc0JwRSxNQUF0QixDQUFKO0FBQUEsS0FBVixDQURNLEdBQ3lDLElBRGhEO0FBRUEsR0EvSThCO0FBaUovQm10RCxnQkFqSitCLDBCQWlKaEIvb0QsRUFqSmdCLEVBaUpaO0FBQ2xCLHNCQUFXaE8sY0FBSyxDQUFDeEgsVUFBTixHQUFtQixLQUFLeXJDLHVCQUFMLENBQTZCajJCLEVBQTdCLENBQTlCO0FBQ0EsR0FuSjhCO0FBcUovQjI5QyxpQkFySitCLDJCQXFKZmx3QixHQXJKZSxFQXFKVjtBQUNwQixRQUFNOXRCLEVBQUUsR0FBRyxJQUFYO0FBRUEsV0FBTzh0QixHQUFHLElBQUlBLEdBQUcsQ0FBQ3QvQixNQUFYLEdBQ05zL0IsR0FBRyxDQUFDcDlCLEdBQUosQ0FBUSxVQUFBMlAsRUFBRTtBQUFBLGFBQUlMLEVBQUUsQ0FBQ29wRCxjQUFILENBQWtCL29ELEVBQWxCLENBQUo7QUFBQSxLQUFWLENBRE0sR0FDaUMsSUFEeEM7QUFFQTtBQTFKOEIsQ0FBMUIsQzs7QUNSTjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUExTixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQW9xQixPQWxCdUIsaUJBa0JqQmdnQixjQWxCaUIsRUFrQkQ7QUFBQSxRQUNmcnBELEVBQUUsR0FBRyxLQUFLeWUsUUFESztBQUFBLFFBRWY0VixTQUFTLEdBQUdyMEIsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JvMUIsY0FBbEIsQ0FGRztBQUFBLFFBR2ZuekIsVUFBVSxHQUFHbDJCLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBTzdKLFNBQVAsQ0FDbEJtRCxFQUFFLENBQUN3bkMsZUFBSCxDQUFtQm5ULFNBQVMsQ0FBQ3JnQyxNQUFWLENBQWlCZ00sRUFBRSxDQUFDc1UsY0FBcEIsRUFBb0N0VSxFQUFwQyxDQUFuQixDQURrQixDQUhFO0FBT3JCLFNBQUt3cEMsTUFBTCxFQVBxQixFQVFyQixLQUFLOGYsT0FBTCxFQVJxQixFQVVyQnB6QixVQUFVLENBQUMvb0IsT0FBWCxDQUFtQjlhLGNBQUssQ0FBQzdILE9BQXpCLE1BQXdDMmlCLE9BQXhDLENBQWdEOWEsY0FBSyxDQUFDcEksU0FBdEQsS0FWcUIsRUFZckIrVixFQUFFLENBQUNnUyxVQUFILE1BQW1CaFMsRUFBRSxDQUFDb25DLFNBQUgsQ0FBYS9TLFNBQWIsQ0FaRSxFQWFyQnIwQixFQUFFLENBQUNzcEMsaUJBQUgsQ0FBcUJqVixTQUFyQixLQWJxQixFQWVyQnIwQixFQUFFLENBQUN5TCxnQkFBSCxHQUFzQjRvQixTQWZELEVBZ0JyQnIwQixFQUFFLENBQUMwTCxrQkFBSCxHQUF3QjFMLEVBQUUsQ0FBQzBMLGtCQUFILENBQXNCMVgsTUFBdEIsQ0FBNkIsVUFBQXFNLEVBQUU7QUFBQSxhQUFJZzBCLFNBQVMsQ0FBQzFzQyxPQUFWLENBQWtCMFksRUFBbEIsSUFBd0IsQ0FBNUI7QUFBQSxLQUEvQixDQWhCSDtBQWlCckIsR0FuQ3NCOztBQXFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBaXBELFNBdER1QixtQkFzRGZELGNBdERlLEVBc0RDO0FBQUEsUUFDakJycEQsRUFBRSxHQUFHLEtBQUt5ZSxRQURPO0FBQUEsUUFFakI0VixTQUFTLEdBQUdyMEIsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JvMUIsY0FBbEIsQ0FGSztBQUFBLFFBR2pCbnpCLFVBQVUsR0FBR2wyQixFQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLENBQ2xCbUQsRUFBRSxDQUFDd25DLGVBQUgsQ0FBbUJuVCxTQUFTLENBQUNyZ0MsTUFBVixDQUFpQmdNLEVBQUUsQ0FBQ3NVLGNBQXBCLEVBQW9DdFUsRUFBcEMsQ0FBbkIsQ0FEa0IsQ0FISTtBQU92QmsyQixjQUFVLENBQUMvb0IsT0FBWCxDQUFtQjlhLGNBQUssQ0FBQzdILE9BQXpCLE1BQXlDMmlCLE9BQXpDLENBQWlEOWEsY0FBSyxDQUFDcEksU0FBdkQsS0FQdUIsRUFRdkIrVixFQUFFLENBQUNnUyxVQUFILE1BQW1CaFMsRUFBRSxDQUFDMm5DLFdBQUgsQ0FBZXRULFNBQWYsQ0FSSSxFQVN2QnIwQixFQUFFLENBQUNzcEMsaUJBQUgsQ0FBcUJqVixTQUFyQixLQVR1QixFQVd2QnIwQixFQUFFLENBQUN5TCxnQkFBSCxHQUFzQnpMLEVBQUUsQ0FBQ3lMLGdCQUFILENBQW9CelgsTUFBcEIsQ0FBMkIsVUFBQXFNLEVBQUU7QUFBQSxhQUFJZzBCLFNBQVMsQ0FBQzFzQyxPQUFWLENBQWtCMFksRUFBbEIsSUFBd0IsQ0FBNUI7QUFBQSxLQUE3QixDQVhDLEVBWXZCTCxFQUFFLENBQUMwTCxrQkFBSCxHQUF3QjJvQixTQVpEO0FBYXZCLEdBbkVzQjs7QUFxRXZCOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQW1WLFFBdEZ1QixrQkFzRmhCNmYsY0F0RmdCLEVBc0ZBO0FBQUEsUUFDaEJycEQsRUFBRSxHQUFHLEtBQUt5ZSxRQURNO0FBQUEsUUFFaEI0VixTQUFTLEdBQUdyMEIsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JvMUIsY0FBbEIsQ0FGSTtBQUFBLFFBR2hCbnpCLFVBQVUsR0FBR2wyQixFQUFFLENBQUMwRyxHQUFILENBQU83SixTQUFQLENBQWlCbUQsRUFBRSxDQUFDd25DLGVBQUgsQ0FBbUJuVCxTQUFuQixDQUFqQixDQUhHO0FBRzhDO0FBRXBFNkIsY0FBVSxDQUFDL29CLE9BQVgsQ0FBbUI5YSxjQUFLLENBQUM3SCxPQUF6QixNQUF5QzJpQixPQUF6QyxDQUFpRDlhLGNBQUssQ0FBQ3BJLFNBQXZELEtBTHNCLEVBTXRCK1YsRUFBRSxDQUFDZ1MsVUFBSCxNQUFtQmhTLEVBQUUsQ0FBQzJuQyxXQUFILENBQWV0VCxTQUFmLENBTkcsRUFRbEJyMEIsRUFBRSxDQUFDcEgsTUFBSCxDQUFVaVYsV0FSUSxLQVNyQjdOLEVBQUUsQ0FBQys5QyxVQUFILENBQWMxcEIsU0FBUyxDQUFDcmdDLE1BQVYsQ0FBaUJnTSxFQUFFLENBQUNvMEIsY0FBSCxDQUFrQjU0QixJQUFsQixDQUF1QndFLEVBQXZCLENBQWpCLENBQWQsQ0FUcUIsRUFVckJBLEVBQUUsQ0FBQ3NSLE1BQUgsQ0FBVXpVLFNBQVYsQ0FBb0JtRCxFQUFFLENBQUNnK0MsZUFBSCxDQUFtQjNwQixTQUFuQixDQUFwQixFQUNFcmdDLE1BREYsQ0FDUyxZQUFXO0FBQ2xCLGFBQU91SSxpR0FBUSxDQUFDLElBQUQsQ0FBUixDQUFlNFEsT0FBZixDQUF1QjlhLGNBQUssQ0FBQ3RILGlCQUE3QixDQUFQO0FBQ0EsS0FIRixFQUlFb2lCLE9BSkYsQ0FJVTlhLGNBQUssQ0FBQ3RILGlCQUpoQixLQVZxQixHQWlCdEJpVixFQUFFLENBQUN5TCxnQkFBSCxHQUFzQixFQWpCQSxFQWtCdEJ6TCxFQUFFLENBQUMwTCxrQkFBSCxHQUF3QixFQWxCRjtBQW1CdEI7QUF6R3NCLENBQWxCLEM7O0FDVE47Ozs7QUFJQTtBQUNBO0FBRUEvWSxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7O0FBSUFzcUMsV0FMdUIscUJBS2I5TSxJQUxhLEVBS1A0TSxjQUxPLEVBS1MvNUQsT0FMVCxFQUtrQjtBQUFBLFFBQ2xDMFEsRUFBRSxHQUFHLEtBQUt5ZSxRQUR3QjtBQUFBLFFBRWxDNFYsU0FBUyxHQUFHcjBCLEVBQUUsQ0FBQ2kwQixjQUFILENBQWtCbzFCLGNBQWxCLENBRnNCO0FBSXhDcnBELE1BQUUsV0FBSXk4QyxJQUFJLEdBQUcsUUFBSCxHQUFjLEtBQXRCLHFCQUFGLENBQWdEcG9CLFNBQWhELENBSndDO0FBQUEsUUFLbEN2d0IsT0FBTyxHQUFHOUQsRUFBRSxDQUFDMEcsR0FBSCxDQUFPN0osU0FBUCxDQUFpQm1ELEVBQUUsQ0FBQ3duQyxlQUFILENBQW1CblQsU0FBbkIsQ0FBakIsQ0FMd0I7QUFBQSxRQU1sQzlyQixPQUFPLEdBQUdrMEMsSUFBSSxHQUFHLEdBQUgsR0FBUyxHQU5XO0FBUXhDMzRDLFdBQU8sQ0FBQzNKLFVBQVIsR0FDRWhFLEtBREYsQ0FDUSxTQURSLEVBQ21Cb1MsT0FEbkIsRUFDNEIsV0FENUIsRUFFRXJZLElBRkYsQ0FFTzhQLEVBQUUsQ0FBQ2s4QixNQUZWLEVBRWtCLFlBQU07QUFDdEJwNEIsYUFBTyxDQUFDM04sS0FBUixDQUFjLFNBQWQsRUFBeUIsSUFBekIsRUFBK0JBLEtBQS9CLENBQXFDLFNBQXJDLEVBQWdEb1MsT0FBaEQsQ0FEc0I7QUFFdEIsS0FKRixDQVJ3QyxFQWN4Q2paLE9BQU8sQ0FBQ2tyQixVQUFSLElBQXNCeGEsRUFBRSxXQUFJeThDLElBQUksR0FBRyxNQUFILEdBQVksTUFBcEIsWUFBRixDQUFzQ3BvQixTQUF0QyxDQWRrQixFQWdCeENyMEIsRUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1RHLDBCQUFvQixJQURYO0FBRVRELHVCQUFpQixJQUZSO0FBR1Q2SixnQkFBVTtBQUhELEtBQVYsQ0FoQndDO0FBcUJ4QyxHQTFCc0I7O0FBNEJ2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQWlpQyxNQS9DdUIsZ0JBK0NsQjRNLGNBL0NrQixFQStDWTtBQUFBLFFBQWQvNUQsT0FBYyx1RUFBSixFQUFJOztBQUNsQyxTQUFLaTZELFNBQUwsS0FBcUJGLGNBQXJCLEVBQXFDLzVELE9BQXJDLENBRGtDO0FBRWxDLEdBakRzQjs7QUFtRHZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBNG1ELE1BdEV1QixnQkFzRWxCbVQsY0F0RWtCLEVBc0VZO0FBQUEsUUFBZC81RCxPQUFjLHVFQUFKLEVBQUk7O0FBQ2xDLFNBQUtpNkQsU0FBTCxLQUFzQkYsY0FBdEIsRUFBc0MvNUQsT0FBdEMsQ0FEa0M7QUFFbEMsR0F4RXNCOztBQTBFdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFndkQsUUE3RnVCLGtCQTZGaEJqcUIsU0E3RmdCLEVBNkZTO0FBQUE7QUFBQSxRQUFkL2tDLE9BQWMsdUVBQUosRUFBSTtBQUFBLFFBQ3pCMFEsRUFBRSxHQUFHLEtBQUt5ZSxRQURlO0FBQUEsUUFFekIzYSxPQUFPLEdBQUc7QUFBQzI0QyxVQUFJLEVBQUUsRUFBUDtBQUFXdkcsVUFBSSxFQUFFO0FBQWpCLEtBRmU7O0FBSS9CO0FBSUE7QUFDQTtBQUpBbDJDLE1BQUUsQ0FBQ2kwQixjQUFILENBQWtCSSxTQUFsQixFQUNFeGtDLE9BREYsQ0FDVSxVQUFBd1EsRUFBRTtBQUFBLGFBQUl5RCxPQUFPLENBQUM5RCxFQUFFLENBQUNzVSxjQUFILENBQWtCalUsRUFBbEIsSUFBd0IsTUFBeEIsR0FBaUMsTUFBbEMsQ0FBUCxDQUFpRGhMLElBQWpELENBQXNEZ0wsRUFBdEQsQ0FBSjtBQUFBLEtBRFosQ0FMK0IsRUFVL0J5RCxPQUFPLENBQUMyNEMsSUFBUixDQUFhanVELE1BQWIsSUFBdUIsS0FBS2l1RCxJQUFMLENBQVUzNEMsT0FBTyxDQUFDMjRDLElBQWxCLEVBQXdCbnRELE9BQXhCLENBVlEsRUFXL0J3VSxPQUFPLENBQUNveUMsSUFBUixDQUFhMW5ELE1BQWIsSUFBdUJ5dUIsVUFBVSxDQUFDO0FBQUEsYUFBTSxLQUFJLENBQUNpNUIsSUFBTCxDQUFVcHlDLE9BQU8sQ0FBQ295QyxJQUFsQixFQUF3QjVtRCxPQUF4QixDQUFOO0FBQUEsS0FBRCxFQUF5QyxDQUF6QyxDQVhGO0FBWS9CO0FBekdzQixDQUFsQixDOzs7O0FDUE47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0lBTU1rNkQsV0FBVyxHQUFHLFVBQUNqd0QsTUFBRCxFQUFTTCxLQUFULEVBQW1CO0FBQUEsdUNBQ25CQSxLQURtQjtBQUFBLE1BQy9CdkgsR0FEK0I7QUFBQSxNQUMxQnVKLEdBRDBCOztBQUd0QyxTQUFPM0IsTUFBTSxDQUFDNUUsS0FBUCxDQUFhLFVBQUNuSCxDQUFELEVBQUlzRCxDQUFKO0FBQUEsV0FDbkJBLENBQUMsS0FBSyxDQUFOLEdBQVd0RCxDQUFDLElBQUltRSxHQUFoQixHQUF3Qm5FLENBQUMsSUFBSTBOLEdBRFY7QUFBQSxHQUFiLENBQVA7QUFHQSxDO0lBbUJLdTFCLGFBQUksR0FBRyxVQUFTckUsV0FBVCxFQUFzQjtBQUFBLE1BRzlCcTlCLFlBSDhCO0FBQUEsTUFDNUJ6cEQsRUFBRSxHQUFHLEtBQUt5ZSxRQURrQjtBQUFBLE1BRTlCbGxCLE1BQU0sR0FBRzZ5QixXQUZxQjs7QUFLbEMsTUFBSXBzQixFQUFFLENBQUNwSCxNQUFILENBQVVpUyxZQUFWLElBQTBCdFIsTUFBMUIsSUFBb0Npd0QsV0FBVyxDQUFDandELE1BQUQsRUFBU3lHLEVBQUUsQ0FBQzh3QixhQUFILEVBQVQsQ0FBbkQsRUFBaUY7QUFDaEYsUUFBTXp0QixZQUFZLEdBQUdyRCxFQUFFLENBQUNxRCxZQUFILEVBQXJCOztBQU1BLFFBSklBLFlBSUosS0FIQzlKLE1BQU0sR0FBR0EsTUFBTSxDQUFDN0ksR0FBUCxDQUFXLFVBQUFVLENBQUM7QUFBQSxhQUFJNE8sRUFBRSxDQUFDc0QsU0FBSCxDQUFhbFMsQ0FBYixDQUFKO0FBQUEsS0FBWixDQUdWLEdBQUk0TyxFQUFFLENBQUNwSCxNQUFILENBQVU2VyxhQUFkLEVBQTZCO0FBQzVCLFVBQU1ndUIsTUFBTSxHQUFHejlCLEVBQUUsQ0FBQ21ELFNBQUgsSUFBZ0JuRCxFQUFFLENBQUM1TyxDQUFsQztBQUVBNE8sUUFBRSxDQUFDdlgsS0FBSCxDQUFTdzdELFlBQVQsR0FBd0IvekQsSUFBeEIsQ0FBNkI4UCxFQUFFLENBQUN2WCxLQUFILENBQVN5N0QsSUFBdEMsRUFBNEMsQ0FBQ3ptQixNQUFNLENBQUNsa0MsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQUFQLEVBQW9Ca2tDLE1BQU0sQ0FBQ2xrQyxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQTFCLENBQTVDLENBSDRCLEVBSTVCa3dELFlBQVksR0FBR2x3RCxNQUphO0FBSzVCLEtBTEQsTUFNQ3lHLEVBQUUsQ0FBQzVPLENBQUgsQ0FBS21JLE1BQUwsQ0FBWUEsTUFBWixDQU5ELEVBT0N5RyxFQUFFLENBQUNtRCxTQUFILEdBQWVuRCxFQUFFLENBQUM1TyxDQVBuQixFQVFDNE8sRUFBRSxDQUFDdUMsS0FBSCxDQUFTMUosS0FBVCxDQUFlbUgsRUFBRSxDQUFDbUQsU0FBbEIsQ0FSRCxFQVVDc21ELFlBQVksR0FBR3pwRCxFQUFFLENBQUNtRCxTQUFILENBQWE0SCxTQUFiLEVBVmhCOztBQWFBL0ssTUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1RySixvQkFBYyxJQURMO0FBRVR3VCxXQUFLLEVBQUU1YSxFQUFFLENBQUNwSCxNQUFILENBQVUyZSxZQUZSO0FBR1RndUMsbUJBQWE7QUFISixLQUFWLENBcEJnRixFQTBCaEZ2bEQsRUFBRSxDQUFDZ25ELGtCQUFILEVBMUJnRixFQTJCaEZsM0QsTUFBTSxDQUFDa1EsRUFBRSxDQUFDcEgsTUFBSCxDQUFVOG1CLFdBQVgsRUFBd0IrcEMsWUFBeEIsQ0EzQjBFO0FBNEJoRixHQTVCRCxNQTZCQ0EsWUFBWSxHQUFHenBELEVBQUUsQ0FBQ21ELFNBQUgsR0FDZG5ELEVBQUUsQ0FBQ21ELFNBQUgsQ0FBYTVKLE1BQWIsRUFEYyxHQUNVeUcsRUFBRSxDQUFDNU8sQ0FBSCxDQUFLMlosU0FBTCxFQTlCMUI7O0FBaUNBLFNBQU8wK0MsWUFBUDtBQUNBLEM7QUF4REQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwREE5MkQsTUFBTSxDQUFDODlCLGFBQUQsRUFBTztBQUNaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkFpNUIsUUFBTSxFQUFFLGtCQUE0QjtBQUFBLFFBQW5CQyxPQUFtQix1RUFBVCxPQUFTO0FBQUEsUUFDN0IzcEQsRUFBRSxHQUFHLEtBQUt5ZSxRQURtQjtBQUFBLFFBRTdCN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmlCO0FBQUEsUUFHL0JneEQsVUFBVSxHQUFHRCxPQUhrQjtBQUsvQkEsV0FMK0IsS0FNbENDLFVBQVUsR0FBR2w4RCxRQUFRLENBQUNpOEQsT0FBRCxDQUFSLElBQXFCLGlCQUFpQjN2RCxJQUFqQixDQUFzQjJ2RCxPQUF0QixDQUFyQixHQUNaO0FBQUM1MEQsVUFBSSxFQUFFNDBEO0FBQVAsS0FEWSxHQUNNQSxPQVBlLEdBVW5DL3dELE1BQU0sQ0FBQ2lTLFlBQVAsR0FBc0IrK0MsVUFWYSxFQVk5QjVwRCxFQUFFLENBQUN5d0IsSUFaMkIsR0FleEJrNUIsT0FBTyxPQWZpQixJQWdCbEMzcEQsRUFBRSxDQUFDZ1gsYUFBSCxJQWhCa0MsSUFhbENoWCxFQUFFLENBQUM4TSxRQUFILEVBYmtDLEVBY2xDOU0sRUFBRSxDQUFDZ1gsYUFBSCxFQWRrQyxHQW1CbkNoWCxFQUFFLENBQUM2cEQsZUFBSCxFQW5CbUM7QUFvQm5DLEdBdkNXOztBQXlDWjs7Ozs7Ozs7Ozs7QUFXQTN1RCxLQUFHLEVBQUUsYUFBU0EsSUFBVCxFQUFjO0FBQUEsUUFDWjhFLEVBQUUsR0FBRyxLQUFLeWUsUUFERTtBQUFBLFFBRVo3bEIsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQTtBQVFsQixZQUpJc0MsSUFBRyxLQUFLLENBQVIsSUFBYUEsSUFJakIsTUFIQ3RDLE1BQU0sQ0FBQ21uQixVQUFQLEdBQW9CanJCLFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FBQ2tMLEVBQUUsQ0FBQ2tPLFVBQUgsQ0FBYyxDQUFkLENBQUQsRUFBbUJoVCxJQUFuQixDQUFSLENBRzlCLEdBQU90QyxNQUFNLENBQUNtbkIsVUFBZDtBQUNBLEdBN0RXOztBQStEWjs7Ozs7Ozs7Ozs7QUFXQXB1QixLQUFHLEVBQUUsYUFBU0EsSUFBVCxFQUFjO0FBQUEsUUFDWnFPLEVBQUUsR0FBRyxLQUFLeWUsUUFERTtBQUFBLFFBRVo3bEIsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGQTtBQVFsQixZQUpJakgsSUFBRyxLQUFLLENBQVIsSUFBYUEsSUFJakIsTUFIQ2lILE1BQU0sQ0FBQ2tuQixVQUFQLEdBQW9CaHJCLFNBQVMsQ0FBQyxLQUFELEVBQVEsQ0FBQ2tMLEVBQUUsQ0FBQ2tPLFVBQUgsQ0FBYyxDQUFkLENBQUQsRUFBbUJ2YyxJQUFuQixDQUFSLENBRzlCLEdBQU9pSCxNQUFNLENBQUNrbkIsVUFBZDtBQUNBLEdBbkZXOztBQXFGWjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE1bUIsT0FBSyxFQUFFLGVBQVNBLE9BQVQsRUFBZ0I7QUFDdEIsUUFBTXUzQixJQUFJLEdBQUcsS0FBS0EsSUFBbEI7O0FBRUEsUUFBSXZoQyxRQUFRLENBQUNnSyxPQUFELENBQVosRUFBcUI7QUFBQSxVQUNidkgsR0FEYSxHQUNEdUgsT0FEQyxDQUNidkgsR0FEYTtBQUFBLFVBQ1J1SixHQURRLEdBQ0RoQyxPQURDLENBQ1JnQyxHQURRO0FBR3BCck4sZUFBUyxDQUFDOEQsR0FBRCxDQUFULElBQWtCOCtCLElBQUksQ0FBQzkrQixHQUFMLENBQVNBLEdBQVQsQ0FIRSxFQUlwQjlELFNBQVMsQ0FBQ3FOLEdBQUQsQ0FBVCxJQUFrQnUxQixJQUFJLENBQUN2MUIsR0FBTCxDQUFTQSxHQUFULENBSkU7QUFLcEI7O0FBRUQsV0FBTztBQUNOdkosU0FBRyxFQUFFOCtCLElBQUksQ0FBQzkrQixHQUFMLEVBREM7QUFFTnVKLFNBQUcsRUFBRXUxQixJQUFJLENBQUN2MUIsR0FBTDtBQUZDLEtBQVA7QUFJQTtBQXBIVyxDQUFQLEMsRUF1SE52SSxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCd1IsTUFBSSxFQUFKQSxhQUR1Qjs7QUFHdkI7Ozs7Ozs7O0FBUUFrMUIsUUFYdUIsb0JBV2Q7QUFBQSxRQUNGM2xELEVBQUUsR0FBRyxLQUFLeWUsUUFEUjtBQUFBLFFBRUY3bEIsTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFGVjs7QUFJUixRQUFJb0gsRUFBRSxDQUFDbUQsU0FBUCxFQUFrQjtBQUNqQnZLLFlBQU0sQ0FBQzZXLGFBQVAsR0FDQ3pQLEVBQUUsQ0FBQ3ZYLEtBQUgsQ0FBU3c3RCxZQUFULEdBQXdCL3pELElBQXhCLENBQTZCOFAsRUFBRSxDQUFDdlgsS0FBSCxDQUFTeTdELElBQXRDLEVBQTRDLElBQTVDLENBREQsR0FFQ2xrRCxFQUFFLENBQUN5d0IsSUFBSCxDQUFRdzFCLG9CQUFSLENBQTZCNkQsZ0ZBQTdCLENBSGdCLEVBS2pCOXBELEVBQUUsQ0FBQ3ltRCxVQUFILElBTGlCLEVBTWpCem1ELEVBQUUsQ0FBQ3l3QixJQUFILENBQVF5MkIsUUFBUixJQUFvQmxuRCxFQUFFLENBQUN5d0IsSUFBSCxDQUFReTJCLFFBQVIsQ0FBaUIvd0QsS0FBakIsQ0FBdUIsU0FBdkIsRUFBa0MsTUFBbEMsQ0FOSDtBQVFqQjtBQUNBLFVBQU05TCxVQUFVLEdBQUcyVixFQUFFLENBQUMvTixJQUFILENBQVFHLE1BQVIsWUFBbUJDLGNBQUssQ0FBQ2hJLFVBQXpCLEVBQW5CO0FBRUkwL0QsK0ZBQWUsQ0FBQzEvRCxVQUFVLENBQUNrRyxJQUFYLEVBQUQsQ0FBZixLQUF1Q3U1RCxnRkFYMUIsSUFZaEI5cEQsRUFBRSxDQUFDeXdCLElBQUgsQ0FBUXkxQixTQUFSLENBQWtCNzdELFVBQWxCLEVBQThCeS9ELGdGQUE5QixDQVpnQixFQWVqQjlwRCxFQUFFLENBQUN5USxNQUFILENBQVU7QUFDVHJKLHNCQUFjLElBREw7QUFFVHVKLHlCQUFpQixJQUZSO0FBR1RDLDRCQUFvQixJQUhYO0FBSVRnSyxhQUFLLEVBQUVoaUIsTUFBTSxDQUFDMmU7QUFKTCxPQUFWLENBZmlCO0FBcUJqQjtBQUNEO0FBckNzQixDQUFsQixDOztBQ3hNTjs7OztBQUlBO0FBQ0E7QUFFQTVrQixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFEQXdjLE1BdER1QixnQkFzRGxCeHJDLElBdERrQixFQXNEWjtBQUFBLFFBQ0orUCxFQUFFLEdBQUcsS0FBS3llLFFBRE47QUFBQSxRQUVKN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRlI7QUFJVjtBQUdBO0FBR0E7QUFVQTtBQUtBO0FBcEJBM0ksUUFBSSxDQUFDbWQsRUFBTCxJQUFXcE4sRUFBRSxDQUFDOHhCLEtBQUgsQ0FBUzdoQyxJQUFJLENBQUNtZCxFQUFkLENBTEQsRUFRVixXQUFXbmQsSUFBWCxJQUFtQixLQUFLOEQsSUFBTCxDQUFVaTJELEtBQVYsQ0FBZ0IvNUQsSUFBSSxDQUFDKzVELEtBQXJCLENBUlQsRUFXVixhQUFhLzVELElBQWIsSUFBcUJ2QixNQUFNLENBQUNDLElBQVAsQ0FBWXNCLElBQUksQ0FBQzQ0RCxPQUFqQixFQUEwQmg1RCxPQUExQixDQUFrQyxVQUFBd1EsRUFBRSxFQUFJO0FBQzVEekgsWUFBTSxDQUFDd25CLFlBQVAsQ0FBb0IvZixFQUFwQixJQUEwQnBRLElBQUksQ0FBQzQ0RCxPQUFMLENBQWF4b0QsRUFBYixDQURrQztBQUU1RCxLQUZvQixDQVhYLEVBZ0JOLGdCQUFnQnBRLElBQWhCLElBQXdCK1AsRUFBRSxDQUFDeUMsYUFBSCxFQWhCbEIsS0FpQlQ3SixNQUFNLENBQUM2aUIsaUJBQVAsR0FBMkJ4ckIsSUFBSSxDQUFDaVQsVUFqQnZCLEdBcUJWLFVBQVVqVCxJQUFWLElBQWtCdkIsTUFBTSxDQUFDQyxJQUFQLENBQVlzQixJQUFJLENBQUM0USxJQUFqQixFQUF1QmhSLE9BQXZCLENBQStCLFVBQUF3USxFQUFFLEVBQUk7QUFDdER6SCxZQUFNLENBQUN3TCxTQUFQLENBQWlCL0QsRUFBakIsSUFBdUJwUSxJQUFJLENBQUM0USxJQUFMLENBQVVSLEVBQVYsQ0FEK0I7QUFFdEQsS0FGaUIsQ0FyQlIsRUEwQlYsWUFBWXBRLElBQVosSUFBb0J2QixNQUFNLENBQUNDLElBQVAsQ0FBWXNCLElBQUksQ0FBQzAzRCxNQUFqQixFQUF5QjkzRCxPQUF6QixDQUFpQyxVQUFBd1EsRUFBRSxFQUFJO0FBQzFEekgsWUFBTSxDQUFDaW9CLFdBQVAsQ0FBbUJ4Z0IsRUFBbkIsSUFBeUJwUSxJQUFJLENBQUMwM0QsTUFBTCxDQUFZdG5ELEVBQVosQ0FEaUM7QUFFMUQsS0FGbUIsQ0ExQlYsRUErQk4sWUFBWXBRLElBQVosSUFBb0JBLElBQUksQ0FBQzZyQyxNQUFMLE9BL0JkLEdBaUNUOTdCLEVBQUUsQ0FBQzg3QixNQUFILENBQVU5N0IsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0Joa0MsSUFBSSxDQUFDNnJDLE1BQUwsVUFBdUIsSUFBdkIsR0FBOEI3ckMsSUFBSSxDQUFDNnJDLE1BQXJELENBQVYsRUFBd0U7QUFBQSxhQUN2RTk3QixFQUFFLENBQUM0N0IsWUFBSCxDQUFnQjNyQyxJQUFoQixDQUR1RTtBQUFBLEtBQXhFLENBakNTLEdBcUNUK1AsRUFBRSxDQUFDNDdCLFlBQUgsQ0FBZ0IzckMsSUFBaEIsQ0FyQ1M7QUF1Q1YsR0E3RnNCOztBQStGdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBNnJDLFFBdEh1QixrQkFzSGhCbXVCLFNBdEhnQixFQXNITDtBQUFBLFFBQ1hqcUQsRUFBRSxHQUFHLEtBQUt5ZSxRQURDO0FBQUEsUUFFYnh1QixJQUFJLEdBQUdnNkQsU0FBUyxJQUFJLEVBRlA7QUFJYm43RCxXQUFPLENBQUNtQixJQUFELENBSk0sR0FLaEJBLElBQUksR0FBRztBQUFDNjlCLFNBQUcsRUFBRTc5QjtBQUFOLEtBTFMsR0FNTnZDLFFBQVEsQ0FBQ3VDLElBQUQsQ0FORixLQU9oQkEsSUFBSSxHQUFHO0FBQUM2OUIsU0FBRyxFQUFFLENBQUM3OUIsSUFBRDtBQUFOLEtBUFM7QUFVakIsUUFBTTY5QixHQUFHLEdBQUc5dEIsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0Joa0MsSUFBSSxDQUFDNjlCLEdBQXZCLENBQVo7QUFFQTl0QixNQUFFLENBQUM4N0IsTUFBSCxDQUFVaE8sR0FBVixFQUFlLFlBQU07QUFDcEI5dEIsUUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1RHLDRCQUFvQixJQURYO0FBRVRELHlCQUFpQixJQUZSO0FBR1Q2SixrQkFBVTtBQUhELE9BQVYsQ0FEb0IsRUFPcEJ4YSxFQUFFLENBQUN5b0QsV0FBSCxDQUFlMzZCLEdBQWYsQ0FQb0IsRUFRcEI3OUIsSUFBSSxDQUFDMnRCLElBQUwsSUFBYTN0QixJQUFJLENBQUMydEIsSUFBTCxFQVJPO0FBU3BCLEtBVEQsQ0FaaUI7QUFzQmpCO0FBNUlzQixDQUFsQixDOzs7OztBQ1BOOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQWpyQixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaURBM0osTUFsRHVCLGdCQWtEbEJybEIsSUFsRGtCLEVBa0RaO0FBQUEsUUFFTjhELElBRk07QUFBQSxRQUdOd0YsTUFITTtBQUFBLFFBTU45SSxJQU5NO0FBQUEsUUFPTnk1RCxFQVBNO0FBQUEsUUFDSmxxRCxFQUFFLEdBQUcsS0FBS3llLFFBRE47QUFBQSxRQUlOandCLE1BQU0sR0FBRyxDQUpIO0FBQUEsUUFLTjI3RCxJQUFJLEdBQUcsQ0FMRDs7QUFhVixTQUpJbDZELElBQUksQ0FBQ21vQyxJQUFMLElBQWFub0MsSUFBSSxDQUFDcW9DLElBQWxCLElBQTBCcm9DLElBQUksQ0FBQ3VvQyxPQUluQyxNQUhDemtDLElBQUksR0FBR2lNLEVBQUUsQ0FBQ21KLFdBQUgsQ0FBZWxaLElBQWYsQ0FHUixHQUFLOEQsSUFBRCxJQUFVaU0sRUFBRSxDQUFDaVksWUFBSCxFQUFkO0FBQUEsVUFJTW15QyxXQUFXLEdBQUcsRUFKcEI7QUFBQSxVQUtNQyxZQUFZLEdBQUdycUQsRUFBRSxDQUFDbXdCLGVBQUgsRUFMckI7QUFBQSxVQU1NcnNCLE9BQU8sR0FBRzlELEVBQUUsQ0FBQ3FOLG9CQUFILENBQXdCdFosSUFBeEIsS0FOaEI7QUFTQWlNLFFBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0JqVSxPQUFoQixDQUF3QixVQUFBOEYsQ0FBQyxFQUFJO0FBRzVCLGlCQUZJL0YsS0FBSyxLQUVULEVBQVNrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ1QsT0FBTyxDQUFDdFYsTUFBNUIsRUFBb0NzQyxDQUFDLEVBQXJDLEVBQ0MsSUFBSTZFLENBQUMsQ0FBQzBLLEVBQUYsS0FBU3lELE9BQU8sQ0FBQ2hULENBQUQsQ0FBUCxDQUFXdVAsRUFBeEIsRUFBNEI7QUFDM0J6USxlQUFLLEtBRHNCLEVBR3ZCK0YsQ0FBQyxDQUFDdU0sTUFBRixDQUFTdk0sQ0FBQyxDQUFDdU0sTUFBRixDQUFTMVQsTUFBVCxHQUFrQixDQUEzQixDQUh1QixLQUkxQjI3RCxJQUFJLEdBQUd4MEQsQ0FBQyxDQUFDdU0sTUFBRixDQUFTdk0sQ0FBQyxDQUFDdU0sTUFBRixDQUFTMVQsTUFBVCxHQUFrQixDQUEzQixFQUE4Qm1QLEtBQTlCLEdBQXNDLENBSm5CLEdBTzNCblAsTUFBTSxHQUFHc1YsT0FBTyxDQUFDaFQsQ0FBRCxDQUFQLENBQVdvUixNQUFYLENBQWtCMVQsTUFQQTs7QUFTM0IsZUFBSyxJQUFJMC9CLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUcxL0IsTUFBcEIsRUFBNEIwL0IsR0FBQyxFQUE3QixFQUNDcHFCLE9BQU8sQ0FBQ2hULENBQUQsQ0FBUCxDQUFXb1IsTUFBWCxDQUFrQmdzQixHQUFsQixFQUFxQnZ3QixLQUFyQixHQUE2QndzRCxJQUFJLEdBQUdqOEIsR0FEckMsRUFHTWx1QixFQUFFLENBQUNxRCxZQUFILEVBSE4sS0FJRVMsT0FBTyxDQUFDaFQsQ0FBRCxDQUFQLENBQVdvUixNQUFYLENBQWtCZ3NCLEdBQWxCLEVBQXFCOThCLENBQXJCLEdBQXlCKzRELElBQUksR0FBR2o4QixHQUpsQzs7QUFRQXY0QixXQUFDLENBQUN1TSxNQUFGLEdBQVd2TSxDQUFDLENBQUN1TSxNQUFGLENBQVMxTyxNQUFULENBQWdCc1EsT0FBTyxDQUFDaFQsQ0FBRCxDQUFQLENBQVdvUixNQUEzQixDQWpCZ0IsRUFrQjNCNEIsT0FBTyxDQUFDMFosTUFBUixDQUFlMXNCLENBQWYsRUFBa0IsQ0FBbEIsQ0FsQjJCO0FBbUIzQjtBQUNBOztBQUdEbEIsYUFBRCxJQUFVdzZELFdBQVcsQ0FBQy8wRCxJQUFaLENBQWlCTSxDQUFDLENBQUMwSyxFQUFuQixDQTNCa0I7QUE0QjVCLE9BNUJELENBVEEsRUF3Q0FMLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0JqVSxPQUFoQixDQUF3QixVQUFBOEYsQ0FBQyxFQUFJO0FBQzVCLGFBQUssSUFBSTdFLEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUdzNUQsV0FBVyxDQUFDNTdELE1BQWhDLEVBQXdDc0MsRUFBQyxFQUF6QyxFQUNDLElBQUk2RSxDQUFDLENBQUMwSyxFQUFGLEtBQVMrcEQsV0FBVyxDQUFDdDVELEVBQUQsQ0FBeEIsRUFBNkI7QUFDNUJxNUQsY0FBSSxHQUFHeDBELENBQUMsQ0FBQ3VNLE1BQUYsQ0FBU3ZNLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBUzFULE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEJtUCxLQUE5QixHQUFzQyxDQURqQjs7QUFHNUIsZUFBSyxJQUFJdXdCLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUcxL0IsTUFBcEIsRUFBNEIwL0IsR0FBQyxFQUE3QixFQUNDdjRCLENBQUMsQ0FBQ3VNLE1BQUYsQ0FBUzdNLElBQVQsQ0FBYztBQUNiZ0wsY0FBRSxFQUFFMUssQ0FBQyxDQUFDMEssRUFETztBQUViMUMsaUJBQUssRUFBRXdzRCxJQUFJLEdBQUdqOEIsR0FGRDtBQUdiOThCLGFBQUMsRUFBRTRPLEVBQUUsQ0FBQ3FELFlBQUgsS0FBb0JyRCxFQUFFLENBQUM2eEIsZUFBSCxDQUFtQnM0QixJQUFJLEdBQUdqOEIsR0FBMUIsQ0FBcEIsR0FBbURpOEIsSUFBSSxHQUFHajhCLEdBSGhEO0FBSWJ2K0IsaUJBQUssRUFBRTtBQUpNLFdBQWQsQ0FERDtBQVFBO0FBRUYsT0FmRCxDQXhDQSxFQTBESXFRLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0J0VixNQTFEcEIsSUEyRENzVixPQUFPLENBQUNqVSxPQUFSLENBQWdCLFVBQUE4RixDQUFDLEVBQUk7QUFHcEIsaUJBRk0yMEQsT0FBTyxHQUFHLEVBRWhCLEVBQVN4NUQsQ0FBQyxHQUFHa1AsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQixDQUFoQixFQUFtQjVCLE1BQW5CLENBQTBCLENBQTFCLEVBQTZCdkUsS0FBMUMsRUFBaUQ3TSxDQUFDLEdBQUdxNUQsSUFBckQsRUFBMkRyNUQsQ0FBQyxFQUE1RCxFQUNDdzVELE9BQU8sQ0FBQ2oxRCxJQUFSLENBQWE7QUFDWmdMLFlBQUUsRUFBRTFLLENBQUMsQ0FBQzBLLEVBRE07QUFFWjFDLGVBQUssRUFBRTdNLENBRks7QUFHWk0sV0FBQyxFQUFFNE8sRUFBRSxDQUFDcUQsWUFBSCxLQUFvQnJELEVBQUUsQ0FBQzZ4QixlQUFILENBQW1CL2dDLENBQW5CLENBQXBCLEdBQTRDQSxDQUhuQztBQUlabkIsZUFBSyxFQUFFO0FBSkssU0FBYixDQUREOztBQVNBZ0csU0FBQyxDQUFDdU0sTUFBRixDQUFTclMsT0FBVCxDQUFpQixVQUFBckMsQ0FBQyxFQUFJO0FBQ3JCQSxXQUFDLENBQUNtUSxLQUFGLElBQVd3c0QsSUFEVSxFQUdoQm5xRCxFQUFFLENBQUNxRCxZQUFILEVBSGdCLEtBSXBCN1YsQ0FBQyxDQUFDNEQsQ0FBRixJQUFPKzRELElBSmE7QUFNckIsU0FORCxDQVpvQixFQW9CcEJ4MEQsQ0FBQyxDQUFDdU0sTUFBRixHQUFXb29ELE9BQU8sQ0FBQzkyRCxNQUFSLENBQWVtQyxDQUFDLENBQUN1TSxNQUFqQixDQXBCUztBQXFCcEIsT0FyQkQsQ0EzREQsRUFtRkFsQyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLEdBQWtCOUQsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQnRRLE1BQWhCLENBQXVCc1EsT0FBdkIsQ0FuRmxCO0FBbUZtRDtBQUVuRDtBQUNBO0FBdEZBLFVBdUZNeW1ELFVBQVUsR0FBR3ZxRCxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQWdCLENBQWhCLENBdkZuQjtBQUFBLFVBd0ZNMG1ELFNBQVMsR0FBR0QsVUFBVSxDQUFDcm9ELE1BQVgsQ0FBa0IsQ0FBbEIsQ0F4RmxCO0FBMkZJclUsZUFBUyxDQUFDb0MsSUFBSSxDQUFDaTZELEVBQU4sQ0EzRmIsSUE0RkMxN0QsTUFBTSxHQUFHLENBNUZWLEVBNkZDMDdELEVBQUUsR0FBR2xxRCxFQUFFLENBQUNxRCxZQUFILEtBQW9CckQsRUFBRSxDQUFDc0QsU0FBSCxDQUFhclQsSUFBSSxDQUFDaTZELEVBQWxCLENBQXBCLEdBQTRDajZELElBQUksQ0FBQ2k2RCxFQTdGdkQsRUErRkNLLFVBQVUsQ0FBQ3JvRCxNQUFYLENBQWtCclMsT0FBbEIsQ0FBMEIsVUFBQXJDLENBQUMsRUFBSTtBQUM5QkEsU0FBQyxDQUFDNEQsQ0FBRixHQUFNODRELEVBQU4sSUFBWTE3RCxNQUFNLEVBRFk7QUFFOUIsT0FGRCxDQS9GRCxJQWtHV1gsU0FBUyxDQUFDb0MsSUFBSSxDQUFDekIsTUFBTixDQWxHcEIsS0FtR0NBLE1BQU0sR0FBR3lCLElBQUksQ0FBQ3pCLE1BbkdmLEdBdUdLNjdELFlBdkdMLEdBaUhXQSxZQUFZLEtBQUssQ0FBakIsSUFBc0JycUQsRUFBRSxDQUFDcUQsWUFBSCxFQWpIakMsS0FrSEM1UyxJQUFJLEdBQUcsQ0FBQzg1RCxVQUFVLENBQUNyb0QsTUFBWCxDQUFrQnFvRCxVQUFVLENBQUNyb0QsTUFBWCxDQUFrQjFULE1BQWxCLEdBQTJCLENBQTdDLEVBQWdENEMsQ0FBaEQsR0FBb0RvNUQsU0FBUyxDQUFDcDVELENBQS9ELElBQW9FLENBbEg1RSxFQW1IQ21JLE1BQU0sR0FBRyxDQUFDLElBQUk5SyxJQUFKLENBQVMsQ0FBQys3RCxTQUFTLENBQUNwNUQsQ0FBWCxHQUFlWCxJQUF4QixDQUFELEVBQWdDLElBQUloQyxJQUFKLENBQVMsQ0FBQys3RCxTQUFTLENBQUNwNUQsQ0FBWCxHQUFlWCxJQUF4QixDQUFoQyxDQW5IVixLQXlHRUEsSUF6R0YsR0F3R0t1UCxFQUFFLENBQUNxRCxZQUFILEVBeEdMLEdBeUdTa25ELFVBQVUsQ0FBQ3JvRCxNQUFYLENBQWtCMVQsTUFBbEIsR0FBMkIsQ0FBM0IsR0FDTis3RCxVQUFVLENBQUNyb0QsTUFBWCxDQUFrQnFvRCxVQUFVLENBQUNyb0QsTUFBWCxDQUFrQjFULE1BQWxCLEdBQTJCLENBQTdDLEVBQWdENEMsQ0FBaEQsR0FBb0RvNUQsU0FBUyxDQUFDcDVELENBRHhELEdBRU5vNUQsU0FBUyxDQUFDcDVELENBQVYsR0FBYzRPLEVBQUUsQ0FBQ2dPLFVBQUgsQ0FBY2hPLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXRCLEVBQStCLENBQS9CLENBM0dqQixHQTZHUyxDQTdHVCxFQWdIQ3ZLLE1BQU0sR0FBRyxDQUFDaXhELFNBQVMsQ0FBQ3A1RCxDQUFWLEdBQWNYLElBQWYsRUFBcUIrNUQsU0FBUyxDQUFDcDVELENBQS9CLENBaEhWLEdBc0hBbUksTUFBTSxJQUFJeUcsRUFBRSxDQUFDcVgsYUFBSCxDQUFpQixJQUFqQixjQUEwQzlkLE1BQTFDLENBdEhWLEVBeUhBeUcsRUFBRSxDQUFDc1EsYUFBSCxDQUFpQnRRLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQXpCLENBekhBLEVBNEhBOUQsRUFBRSxDQUFDeVEsTUFBSCxDQUFVO0FBQ1Q2RSxZQUFJLEVBQUU7QUFDTDNYLGVBQUssRUFBRTZzRCxTQUFTLENBQUM3c0QsS0FEWjtBQUVMblAsZ0JBQU0sRUFBRUEsTUFGSDtBQUdMMFosa0JBQVEsRUFBRTNhLE9BQU8sQ0FBQzBDLElBQUksQ0FBQ2lZLFFBQU4sQ0FBUCxHQUF5QmpZLElBQUksQ0FBQ2lZLFFBQTlCLEdBQXlDbEksRUFBRSxDQUFDcEgsTUFBSCxDQUFVSSxtQkFIeEQ7QUFJTDRrQixjQUFJLEVBQUUzdEIsSUFBSSxDQUFDMnRCLElBSk47QUFLTHlzQyxzQkFBWSxFQUFFQTtBQUxULFNBREc7QUFRVDd2QyxrQkFBVSxJQVJEO0FBU1RwVCxzQkFBYyxFQUFFaWpELFlBQVksR0FBRyxDQVR0QjtBQVVUSSx1QkFBZSxJQVZOO0FBV1RDLHVCQUFlO0FBWE4sT0FBVixDQTVIQTtBQUFBO0FBeUlBO0FBeE1zQixDQUFsQixDLEVBMk1OLzNELE1BQU0sQ0FBQytWLDJCQUFhLENBQUN1VyxTQUFmLEVBQTBCO0FBQy9COzs7Ozs7O0FBT0FuSCxjQVIrQix3QkFRbEI3bkIsSUFSa0IsRUFRWjtBQUFBLFFBQ1orUCxFQUFFLEdBQUcsSUFETztBQUFBLFFBRVpwSCxNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZBO0FBSWxCLFdBQU8sWUFBVztBQVNiLFVBQUEreEQsVUFBVTtBQUFBLFVBUlI3bUQsT0FRUSxHQVJFN1QsSUFBSSxDQUFDNlQsT0FRUDtBQUFBLFVBUFJ3UixJQU9RLEdBUERybEIsSUFBSSxDQUFDcWxCLElBT0o7QUFBQSw2QkFMeUNybEIsSUFBSSxDQUFDdEUsS0FBTCxDQUFXb0osSUFLcEQ7QUFBQSxVQUxGMDFDLE9BS0Usb0JBTFBsaUQsR0FLTztBQUFBLFVBTGE2a0QsUUFLYixvQkFMTy9oRCxJQUtQO0FBQUEsVUFMNkJ5bEQsUUFLN0Isb0JBTHVCaHBELElBS3ZCO0FBQUEsNEJBSnVCbUksSUFBSSxDQUFDdEUsS0FBTCxDQUFXNFMsR0FJbEM7QUFBQSxVQUpQaWIsRUFJTyxtQkFKUEEsRUFJTztBQUFBLFVBSkhJLEVBSUcsbUJBSkhBLEVBSUc7QUFBQSxVQUpDUCxRQUlELG1CQUpDQSxRQUlEO0FBQUEsVUFKV0UsUUFJWCxtQkFKV0EsUUFJWDtBQUFBLFVBSFJ4QixFQUdRLEdBSEg5bkIsSUFBSSxDQUFDOG5CLEVBR0Y7QUFBQSxVQUZSN1AsUUFFUSxHQUZHalksSUFBSSxDQUFDaVksUUFFUjtBQUFBLFVBQ1YwaUQsTUFEVSxHQUNELENBREM7QUFBQSxVQUVSQyxTQUZRLEdBRUl2MUMsSUFBSSxDQUFDM1gsS0FGVDtBQUFBLFVBR1JtdEQsVUFIUSxHQUdLeDFDLElBQUksQ0FBQzltQixNQUhWO0FBQUEsVUFJVnU4RCxTQUpVLEdBSUUvcUQsRUFBRSxDQUFDbXlCLGVBQUgsQ0FBbUJueUIsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQixDQUFoQixFQUFtQjVCLE1BQXRDLEVBQThDMm9ELFNBQTlDLENBSkY7QUFBQSxVQUtWRyxPQUxVLEdBS0FockQsRUFBRSxDQUFDbXlCLGVBQUgsQ0FBbUJueUIsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQixDQUFoQixFQUFtQjVCLE1BQXRDLEVBQThDMm9ELFNBQVMsR0FBR0MsVUFBMUQsQ0FMQTtBQUFBLFVBTVIvL0MsU0FOUSxHQU1JL0ssRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTCxFQU5KO0FBQUEsVUFPUjB4RCxlQVBRLEdBT1UzMUMsSUFBSSxDQUFDcE4sUUFBTCxJQUFpQkEsUUFQM0I7QUFBQSxVQVFSMFYsSUFSUSxHQVFEdEksSUFBSSxDQUFDc0ksSUFBTCxJQUFhLFlBQVcsQ0FBRSxDQVJ6QjtBQUFBLFVBU1JzdEMsSUFUUSxHQVNEbHJELEVBQUUsQ0FBQ3VZLFlBQUgsRUFUQztBQUFBLFVBV1I5ckIsS0FYUSxHQVdBdVQsRUFBRSxDQUFDdlQsS0FBSCxJQUFZb2dCLG9HQUFXLENBQUMsRUFBRCxDQVh2QjtBQUFBLFVBWVJqZ0IsVUFaUSxHQVlLb1QsRUFBRSxDQUFDcFQsVUFBSCxJQUFpQmlnQixvR0FBVyxDQUFDLEVBQUQsQ0FaakM7QUFBQSxVQWFSMDBDLFVBYlEsR0FhS3ZoRCxFQUFFLENBQUN1aEQsVUFBSCxJQUFpQjEwQyxvR0FBVyxDQUFDLEVBQUQsQ0FiakM7QUFBQSxVQWNSOEUsUUFkUSxHQWNHM1IsRUFBRSxDQUFDMlIsUUFBSCxJQUFlOUUsb0dBQVcsQ0FBQyxFQUFELENBZDdCO0FBQUEsVUFlUjBFLE9BZlEsR0FlRXZSLEVBQUUsQ0FBQ3VSLE9BQUgsSUFBYzFFLG9HQUFXLENBQUMsRUFBRCxDQWYzQjtBQUFBLFVBZ0JSMkUsUUFoQlEsR0FnQkd4UixFQUFFLENBQUN3UixRQUFILElBQWUzRSxvR0FBVyxDQUFDLEVBQUQsQ0FoQjdCO0FBQUEsVUFpQlI0RSxRQWpCUSxHQWlCR3pSLEVBQUUsQ0FBQ3lSLFFBQUgsSUFBZTVFLG9HQUFXLENBQUMsRUFBRCxDQWpCN0I7QUFBQSxVQWtCUjZFLFVBbEJRLEdBa0JLMVIsRUFBRSxDQUFDMFIsVUFBSCxJQUFpQjdFLG9HQUFXLENBQUMsRUFBRCxDQWxCakM7O0FBcUJkN00sUUFBRSxDQUFDeUosT0FBSCxLQTlCaUIsRUFpQ2pCekosRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBUixDQUFnQmpVLE9BQWhCLENBQXdCLFVBQUF4QixDQUFDLEVBQUk7QUFDNUJBLFNBQUMsQ0FBQzZULE1BQUYsQ0FBU3NiLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJzdEMsVUFBbkIsQ0FENEI7QUFFNUIsT0FGRCxDQWpDaUI7QUFxQ2pCO0FBQ0EsVUFBTXZ4RCxNQUFNLEdBQUd5RyxFQUFFLENBQUNxWCxhQUFILENBQWlCdlQsT0FBakIsU0FBZixDQXRDaUIsQ0F3Q2pCOztBQUNJOUQsUUFBRSxDQUFDaTVDLFdBekNVLElBeUNLajVDLEVBQUUsQ0FBQ2k1QyxXQUFILElBekNMLEVBNENaM2pDLElBQUksQ0FBQyswQyxZQTVDTyxHQXdETi8wQyxJQUFJLENBQUMrMEMsWUFBTCxLQUFzQixDQUF0QixJQUEyQixDQUFDVSxTQUFTLElBQUlBLFNBQVMsQ0FBQzM1RCxDQUF4QixPQUFnQzQ1RCxPQUFPLElBQUlBLE9BQU8sQ0FBQzU1RCxDQUFuRCxDQXhEckIsR0F5RGhCdTVELFVBQVUsR0FBRzNxRCxFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFTLENBQUMsQ0FBRCxDQUFkLElBQXFCL0ssRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTSxDQUFDLENBQUQsQ0FBWCxDQXpEbEIsR0EyRFp5RyxFQUFFLENBQUNxRCxZQUFILEVBM0RZLEdBNERmc25ELFVBQVUsR0FBSTNxRCxFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFTLENBQUMsQ0FBRCxDQUFkLElBQXFCL0ssRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTSxDQUFDLENBQUQsQ0FBWCxDQTVEcEIsR0E4RGZveEQsVUFBVSxHQUFJM3FELEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzI1RCxTQUFTLENBQUMzNUQsQ0FBZixJQUFvQjRPLEVBQUUsQ0FBQzVPLENBQUgsQ0FBSzQ1RCxPQUFPLENBQUM1NUQsQ0FBYixDQTlEbkIsR0E2Q1o0TyxFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQWdCLENBQWhCLEVBQW1CNUIsTUFBbkIsQ0FBMEIxVCxNQUExQixLQUFxQyxDQTdDekIsR0FnRFh3UixFQUFFLENBQUNxRCxZQUFILEVBaERXLElBaURkMG5ELFNBQVMsR0FBRy9xRCxFQUFFLENBQUNteUIsZUFBSCxDQUFtQm55QixFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUFSLENBQWdCLENBQWhCLEVBQW1CNUIsTUFBdEMsRUFBOEMsQ0FBOUMsQ0FqREUsRUFrRGQ4b0QsT0FBTyxHQUFHaHJELEVBQUUsQ0FBQ215QixlQUFILENBQW1CbnlCLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0IsQ0FBaEIsRUFBbUI1QixNQUF0QyxFQUE4Q2xDLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUStQLE9BQVIsQ0FBZ0IsQ0FBaEIsRUFBbUI1QixNQUFuQixDQUEwQjFULE1BQTFCLEdBQW1DLENBQWpGLENBbERJLEVBbURkbThELFVBQVUsR0FBRzNxRCxFQUFFLENBQUM1TyxDQUFILENBQUsyNUQsU0FBUyxDQUFDMzVELENBQWYsSUFBb0I0TyxFQUFFLENBQUM1TyxDQUFILENBQUs0NUQsT0FBTyxDQUFDNTVELENBQWIsQ0FuRG5CLElBcURkdTVELFVBQVUsR0FBR3Y4RCxVQUFVLENBQUNtTCxNQUFELENBQVYsR0FBcUIsQ0FyRHBCLEdBOENmb3hELFVBQVUsR0FBRzNxRCxFQUFFLENBQUM1TyxDQUFILENBQUsyWixTQUFTLENBQUMsQ0FBRCxDQUFkLElBQXFCL0ssRUFBRSxDQUFDNU8sQ0FBSCxDQUFLbUksTUFBTSxDQUFDLENBQUQsQ0FBWCxDQTlDbkIsRUFrRWpCcXhELE1BQU0sR0FBSXg4RCxVQUFVLENBQUMyYyxTQUFELENBQVYsR0FBd0IzYyxVQUFVLENBQUNtTCxNQUFELENBbEUzQjtBQW1FakIsVUFBTTJzRCxTQUFTLHVCQUFnQnlFLFVBQWhCLHVCQUF1Q0MsTUFBdkMsUUFBZjtBQUVBNXFELFFBQUUsQ0FBQ3krQixjQUFILEVBckVpQjtBQXVFakIsVUFBTTBzQixFQUFFLEdBQUczeUMsd0dBQVksR0FBRzR5QyxJQUFmLENBQW9CQyw4RUFBcEIsRUFDVG5qRCxRQURTLENBQ0EraUQsZUFEQSxDQUFYO0FBR0FDLFVBQUksQ0FBQ3Z5QyxHQUFMLENBQVMsQ0FDUjNZLEVBQUUsQ0FBQ2EsSUFBSCxDQUFRelAsQ0FBUixDQUNFK0ksVUFERixDQUNhZ3hELEVBRGIsRUFFRWo3RCxJQUZGLENBRU8sVUFBQW1MLENBQUM7QUFBQSxlQUFJMkUsRUFBRSxDQUFDdUMsS0FBSCxDQUFTK29ELGFBQVQsQ0FBdUJILEVBQXZCLEVBQTJCaGtELE1BQTNCLENBQWtDOUwsQ0FBbEMsQ0FBSjtBQUFBLE9BRlIsQ0FEUSxFQUtSa1csT0FBTyxDQUNMcFgsVUFERixDQUNhZ3hELEVBRGIsRUFFRW42RCxJQUZGLENBRU8sV0FGUCxFQUVvQmsxRCxTQUZwQixDQUxRLEVBU1IxMEMsUUFBUSxDQUNOclgsVUFERixDQUNhZ3hELEVBRGIsRUFFRW42RCxJQUZGLENBRU8sV0FGUCxFQUVvQmsxRCxTQUZwQixDQVRRLEVBYVJ6MEMsUUFBUSxDQUNOdFgsVUFERixDQUNhZ3hELEVBRGIsRUFFRW42RCxJQUZGLENBRU8sV0FGUCxFQUVvQmsxRCxTQUZwQixDQWJRLEVBaUJSeDBDLFVBQVUsQ0FDUnZYLFVBREYsQ0FDYWd4RCxFQURiLEVBRUVuNkQsSUFGRixDQUVPLFdBRlAsRUFFb0JrMUQsU0FGcEIsQ0FqQlEsRUFxQlJ2MEMsUUFBUSxDQUNOeFgsVUFERixDQUNhZ3hELEVBRGIsRUFFRW42RCxJQUZGLENBRU8sV0FGUCxFQUVvQmsxRCxTQUZwQixDQXJCUSxFQXlCUjNFLFVBQVUsQ0FDUnZ0RCxNQURGLENBQ1NnTSxFQUFFLENBQUNnaUQsV0FEWixFQUVFN25ELFVBRkYsQ0FFYWd4RCxFQUZiLEVBR0VuNkQsSUFIRixDQUdPLFdBSFAsRUFHb0JrMUQsU0FIcEIsQ0F6QlEsRUE4QlJ6NUQsS0FBSyxDQUNIME4sVUFERixDQUNhZ3hELEVBRGIsRUFFRW42RCxJQUZGLENBRU8sV0FGUCxFQUVvQmsxRCxTQUZwQixDQTlCUSxFQWtDUnQ1RCxVQUFVLENBQ1J1TixVQURGLENBQ2FneEQsRUFEYixFQUVFbjZELElBRkYsQ0FFTyxXQUZQLEVBRW9CazFELFNBRnBCLENBbENRLENBQVQsQ0ExRWlCLEVBaUhqQmlGLEVBQUUsQ0FBQ2o3RCxJQUFILENBQVFnN0QsSUFBUixFQUFjLFlBQU07QUFBQSxZQUNidC9ELE1BQU0sR0FBRyxFQURJO0FBQUEsWUFFYlEsS0FBSyxHQUFHLEVBRks7QUFBQSxZQUdiL0IsVUFBVSxHQUFHLEVBSEE7O0FBS25CO0FBQ0EsWUFBSXlnRSxVQUFKLEVBQWdCO0FBQ2YsZUFBSyxJQUNFbnRELEtBREYsRUFBSTdNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnNkQsVUFBcEIsRUFBZ0NoNkQsQ0FBQyxFQUFqQyxFQUNPNk0sS0FEUCxHQUNla3RELFNBQVMsR0FBRy81RCxDQUQzQixFQUdDbEYsTUFBTSxDQUFDeUosSUFBUCxZQUFnQmhELGNBQUssQ0FBQzFHLEtBQXRCLGNBQStCZ1MsS0FBL0IsRUFIRCxFQUlDdlIsS0FBSyxDQUFDaUosSUFBTixZQUFlaEQsY0FBSyxDQUFDbEcsSUFBckIsY0FBNkJ3UixLQUE3QixFQUpELEVBS0N0VCxVQUFVLENBQUNnTCxJQUFYLFlBQW9CaEQsY0FBSyxDQUFDakksU0FBMUIsY0FBdUN1VCxLQUF2QyxFQUxEOztBQVFBcUMsWUFBRSxDQUFDMEcsR0FBSCxDQUFPN0osU0FBUCxZQUFxQnhLLGNBQUssQ0FBQ3pHLE1BQTNCLEdBQ0VpUixTQURGLENBQ1lqUixNQURaLEVBRUUyUixNQUZGLEVBVGUsRUFhZnlDLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBTzdKLFNBQVAsWUFBcUJ4SyxjQUFLLENBQUNqRyxLQUEzQixHQUNFeVEsU0FERixDQUNZelEsS0FEWixFQUVFbVIsTUFGRixFQWJlLEVBaUJmeUMsRUFBRSxDQUFDMEcsR0FBSCxDQUFPN0osU0FBUCxZQUFxQnhLLGNBQUssQ0FBQ2hJLFVBQTNCLEdBQ0V3UyxTQURGLENBQ1l4UyxVQURaLEVBRUVrVCxNQUZGLEVBakJlLEVBcUJmeUMsRUFBRSxDQUFDMEcsR0FBSCxDQUFPdFUsTUFBUCxZQUFrQkMsY0FBSyxDQUFDNUYsS0FBeEIsR0FDRThRLE1BREYsRUFyQmU7QUF1QmYsU0E3QmtCLENBK0JuQjs7O0FBK0JBLFlBOUJBOVEsS0FBSyxDQUFDMk4sSUFBTixNQUFnQjNOLEtBQUssQ0FDbkJ1RSxJQURjLENBQ1QsV0FEUyxFQUNJLElBREosRUFFZEEsSUFGYyxDQUVUZ1AsRUFBRSxDQUFDbzVDLFNBRk0sQ0E4QmhCLEVBMUJBeHNELFVBQVUsQ0FDUm9FLElBREYsQ0FDTyxXQURQLEVBQ29CLElBRHBCLENBMEJBLEVBdkJBcEUsVUFBVSxDQUFDd0YsTUFBWCxDQUFrQixNQUFsQixFQUNFcEIsSUFERixDQUNPLElBRFAsRUFDYTRILE1BQU0sQ0FBQ3VILFlBQVAsR0FBc0IsQ0FBdEIsR0FBMEI0WCxFQUR2QyxFQUVFL21CLElBRkYsQ0FFTyxJQUZQLEVBRWE0SCxNQUFNLENBQUN1SCxZQUFQLEdBQXNCSCxFQUFFLENBQUMxTyxLQUF6QixHQUFpQ3ltQixFQUY5QyxDQXVCQSxFQW5CQW5yQixVQUFVLENBQUN3RixNQUFYLENBQWtCLE1BQWxCLEVBQ0VwQixJQURGLENBQ08sR0FEUCxFQUNZNEgsTUFBTSxDQUFDdUgsWUFBUCxHQUFzQkgsRUFBRSxDQUFDMU8sS0FBekIsR0FBaUMsQ0FEN0MsRUFFRU4sSUFGRixDQUVPLEdBRlAsRUFFWSttQixFQUZaLENBbUJBLEVBZkF4RyxPQUFPLENBQ0x2Z0IsSUFERixDQUNPLFdBRFAsRUFDb0IsSUFEcEIsRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWXk1QyxPQUZaLENBZUEsRUFYQWo1QixRQUFRLENBQ054Z0IsSUFERixDQUNPLFdBRFAsRUFDb0IsSUFEcEIsRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWW84QyxRQUZaLENBV0EsRUFQQTM3QixRQUFRLENBQ056Z0IsSUFERixDQUNPLFdBRFAsRUFDb0IsSUFEcEIsRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWTgvQyxRQUZaLENBT0EsRUFIQXAvQixVQUFVLENBQ1IxZ0IsSUFERixDQUNPLFdBRFAsRUFDb0IsSUFEcEIsQ0FHQSxFQUFJZ1AsRUFBRSxDQUFDNnhDLGFBQUgsRUFBSixFQUNDbmdDLFVBQVUsQ0FDUjFnQixJQURGLENBQ08sSUFEUCxFQUNhd29CLEVBRGIsRUFFRXhvQixJQUZGLENBRU8sSUFGUCxFQUVhNG9CLEVBRmIsQ0FERCxNQUlPO0FBQUEsY0FDQTJ4QyxLQUFLLEdBQUcsVUFBQWw5RCxDQUFDO0FBQUEsbUJBQUltckIsRUFBRSxDQUFDbnJCLENBQUQsQ0FBRixHQUFRdUssTUFBTSxDQUFDd3RCLE9BQW5CO0FBQUEsV0FEVDtBQUFBLGNBRUFvbEMsS0FBSyxHQUFHLFVBQUFuOUQsQ0FBQztBQUFBLG1CQUFJdXJCLEVBQUUsQ0FBQ3ZyQixDQUFELENBQUYsR0FBUXVLLE1BQU0sQ0FBQ3d0QixPQUFuQjtBQUFBLFdBRlQ7O0FBSU4xVSxvQkFBVSxDQUNSMWdCLElBREYsQ0FDTyxHQURQLEVBQ1l1NkQsS0FEWixFQUVFdjZELElBRkYsQ0FFTyxHQUZQLEVBRVl3NkQsS0FGWixFQUdFeDZELElBSEYsQ0FHTyxJQUhQLEVBR2F3b0IsRUFIYixFQUdpQjtBQUhqQixXQUlFeG9CLElBSkYsQ0FJTyxJQUpQLEVBSWE0b0IsRUFKYixDQUpNO0FBU047QUFFRGpJLGdCQUFRLENBQ04zZ0IsSUFERixDQUNPLFdBRFAsRUFDb0IsSUFEcEIsRUFFRUEsSUFGRixDQUVPLEdBRlAsRUFFWXFvQixRQUZaLEVBR0Vyb0IsSUFIRixDQUdPLEdBSFAsRUFHWXVvQixRQUhaLEVBSUVwakIsS0FKRixDQUlRLGNBSlIsRUFJd0I2SixFQUFFLENBQUNnM0MsY0FBSCxDQUFrQng3QyxJQUFsQixDQUF1QndFLEVBQXZCLENBSnhCLENBN0VtQixFQW1GbkJ1aEQsVUFBVSxDQUNSdndELElBREYsQ0FDTyxXQURQLEVBQ29CLElBRHBCLENBbkZtQixFQXNGbkJ1d0QsVUFBVSxDQUFDbnZELE1BQVgsQ0FBa0IsTUFBbEIsRUFBMEI0QixNQUExQixDQUFpQ2dNLEVBQUUsQ0FBQ2dpRCxXQUFwQyxFQUNFaHhELElBREYsQ0FDTyxHQURQLEVBQ1lnUCxFQUFFLENBQUN5aEQsT0FBSCxDQUFXam1ELElBQVgsQ0FBZ0J3RSxFQUFoQixDQURaLEVBRUVoUCxJQUZGLENBRU8sT0FGUCxFQUVnQmdQLEVBQUUsQ0FBQzJoRCxXQUFILENBQWVubUQsSUFBZixDQUFvQndFLEVBQXBCLENBRmhCLENBdEZtQixFQTBGbkJwSCxNQUFNLENBQUMwVixtQkFBUCxJQUE4QnRPLEVBQUUsQ0FBQytXLGVBQUgsRUExRlgsRUE2Rm5CNkcsSUFBSSxFQTdGZSxFQStGbkI1ZCxFQUFFLENBQUN5SixPQUFILEtBL0ZtQjtBQWdHbkIsT0FoR0QsQ0FqSGlCO0FBa05qQixLQWxORDtBQW1OQTtBQS9OOEIsQ0FBMUIsQzs7QUN2Tk47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOVcsTUFBTSxDQUFDNnJCLFdBQUssQ0FBQ1MsU0FBUCxFQUFrQjtBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTJmLFVBakJ1QixvQkFpQmR6SyxRQWpCYyxFQWlCSjtBQUFBLFFBQ1puMEIsRUFBRSxHQUFHLEtBQUt5ZSxRQURFO0FBQUEsUUFFWmd0QyxTQUFTLEdBQUcsRUFGQTtBQVdsQixXQVBBenJELEVBQUUsQ0FBQy9OLElBQUgsQ0FBUTRLLFNBQVIsWUFBc0J4SyxjQUFLLENBQUN6RyxNQUFOLEdBQWVvVSxFQUFFLENBQUNzMkIsdUJBQUgsQ0FBMkJuQyxRQUEzQixDQUFyQyxHQUNFdDNCLFNBREYsWUFDZ0J4SyxjQUFLLENBQUMxRyxLQUR0QixHQUVFcUksTUFGRixDQUVTLFlBQVc7QUFDbEIsYUFBT3VJLGlHQUFRLENBQUMsSUFBRCxDQUFSLENBQWU0USxPQUFmLENBQXVCOWEsY0FBSyxDQUFDaEYsUUFBN0IsQ0FBUDtBQUNBLEtBSkYsRUFLRWlQLElBTEYsQ0FLTyxVQUFBak8sQ0FBQztBQUFBLGFBQUlvOUQsU0FBUyxDQUFDcDJELElBQVYsQ0FBZWhILENBQWYsQ0FBSjtBQUFBLEtBTFIsQ0FPQSxFQUFPbzlELFNBQVA7QUFDQSxHQTdCc0I7O0FBK0J2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBcjVELFFBdkR1QixrQkF1RGhCMDdCLEdBdkRnQixFQXVEWGpWLE9BdkRXLEVBdURGNnlDLFVBdkRFLEVBdURVO0FBQUEsUUFDMUIxckQsRUFBRSxHQUFHLEtBQUt5ZSxRQURnQjtBQUFBLFFBRTFCN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmM7QUFJM0JBLFVBQU0sQ0FBQ21vQixzQkFKb0IsSUFRaEMvZ0IsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQ3pHLE1BQTVCLEdBQ0VpUixTQURGLFlBQ2dCeEssY0FBSyxDQUFDMUcsS0FEdEIsR0FFRTJRLElBRkYsQ0FFTyxVQUFTak8sQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQUEsVUFDZG5GLEtBQUssR0FBRzRRLGlHQUFRLENBQUMsSUFBRCxDQURGO0FBQUEsVUFFZDhELEVBQUUsR0FBR2hTLENBQUMsQ0FBQzBGLElBQUYsR0FBUzFGLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBQWhCLEdBQXFCaFMsQ0FBQyxDQUFDZ1MsRUFGZDtBQUFBLFVBR2RpK0MsTUFBTSxHQUFHdCtDLEVBQUUsQ0FBQ3NqRCxTQUFILENBQWEsSUFBYixFQUFtQmoxRCxDQUFuQixFQUFzQm1OLElBQXRCLENBQTJCd0UsRUFBM0IsQ0FISztBQUFBLFVBSWQyckQsVUFBVSxHQUFHL3lELE1BQU0sQ0FBQ29vQixzQkFBUCxJQUFpQyxDQUFDOE0sR0FBbEMsSUFBeUNBLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwWSxFQUFaLEtBQW1CLENBSjNEO0FBQUEsVUFLZHVyRCxhQUFhLEdBQUcsQ0FBQy95QyxPQUFELElBQVlBLE9BQU8sQ0FBQ2x4QixPQUFSLENBQWdCbUosQ0FBaEIsS0FBc0IsQ0FMcEM7QUFBQSxVQU1kNHhELFVBQVUsR0FBRy8yRCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDaEYsUUFBcEIsQ0FOQztBQVFwQjtBQUNJMUIsV0FBSyxDQUFDd2hCLE9BQU4sQ0FBYzlhLGNBQUssQ0FBQ2hILElBQXBCLEtBQTZCTSxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDdkssSUFBcEIsQ0FUYixLQWFoQjZqRSxVQUFVLElBQUlDLGFBYkUsR0FjZmh6RCxNQUFNLENBQUNxb0IsMkJBQVAsQ0FBbUM1eUIsQ0FBbkMsS0FBeUMsQ0FBQ3EwRCxVQWQzQixJQWVsQnBFLE1BQU0sS0FBTzN5RCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDaEYsUUFBcEIsS0FBUCxFQUE0Q2dCLENBQTVDLEVBQStDeUMsQ0FBL0MsQ0FmWSxHQWlCVGpELFNBQVMsQ0FBQzY5RCxVQUFELENBQVQsSUFBeUJBLFVBQXpCLElBQXVDaEosVUFqQjlCLElBa0JuQnBFLE1BQU0sS0FBUTN5RCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDaEYsUUFBcEIsS0FBUixFQUE4Q2dCLENBQTlDLEVBQWlEeUMsQ0FBakQsQ0FsQmE7QUFvQnBCLEtBdEJGLENBUmdDO0FBK0JoQyxHQXRGc0I7O0FBd0Z2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkErNkQsVUF6R3VCLG9CQXlHZC85QixHQXpHYyxFQXlHVGpWLE9BekdTLEVBeUdBO0FBQUEsUUFDaEI3WSxFQUFFLEdBQUcsS0FBS3llLFFBRE07QUFBQSxRQUVoQjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZJO0FBSWpCQSxVQUFNLENBQUNtb0Isc0JBSlUsSUFRdEIvZ0IsRUFBRSxDQUFDL04sSUFBSCxDQUFRNEssU0FBUixZQUFzQnhLLGNBQUssQ0FBQ3pHLE1BQTVCLEdBQ0VpUixTQURGLFlBQ2dCeEssY0FBSyxDQUFDMUcsS0FEdEIsR0FFRTJRLElBRkYsQ0FFTyxVQUFTak8sQ0FBVCxFQUFZeUMsQ0FBWixFQUFlO0FBQUEsVUFDZG5GLEtBQUssR0FBRzRRLGlHQUFRLENBQUMsSUFBRCxDQURGO0FBQUEsVUFFZDhELEVBQUUsR0FBR2hTLENBQUMsQ0FBQzBGLElBQUYsR0FBUzFGLENBQUMsQ0FBQzBGLElBQUYsQ0FBT3NNLEVBQWhCLEdBQXFCaFMsQ0FBQyxDQUFDZ1MsRUFGZDtBQUFBLFVBR2RpK0MsTUFBTSxHQUFHdCtDLEVBQUUsQ0FBQ3NqRCxTQUFILENBQWEsSUFBYixFQUFtQmoxRCxDQUFuQixFQUFzQm1OLElBQXRCLENBQTJCd0UsRUFBM0IsQ0FISztBQUFBLFVBSWQyckQsVUFBVSxHQUFHL3lELE1BQU0sQ0FBQ29vQixzQkFBUCxJQUFpQyxDQUFDOE0sR0FBbEMsSUFBeUNBLEdBQUcsQ0FBQ25tQyxPQUFKLENBQVkwWSxFQUFaLEtBQW1CLENBSjNEO0FBQUEsVUFLZHVyRCxhQUFhLEdBQUcsQ0FBQy95QyxPQUFELElBQVlBLE9BQU8sQ0FBQ2x4QixPQUFSLENBQWdCbUosQ0FBaEIsS0FBc0IsQ0FMcEM7QUFBQSxVQU1kNHhELFVBQVUsR0FBRy8yRCxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDaEYsUUFBcEIsQ0FOQztBQVFwQjtBQUNJMUIsV0FBSyxDQUFDd2hCLE9BQU4sQ0FBYzlhLGNBQUssQ0FBQ2hILElBQXBCLEtBQTZCTSxLQUFLLENBQUN3aEIsT0FBTixDQUFjOWEsY0FBSyxDQUFDdkssSUFBcEIsQ0FUYixJQWFoQjZqRSxVQUFVLElBQUlDLGFBQWQsSUFBK0JoekQsTUFBTSxDQUFDcW9CLDJCQUFQLENBQW1DNXlCLENBQW5DLENBQS9CLElBQXdFcTBELFVBYnhELElBY25CcEUsTUFBTSxLQUFRM3lELEtBQUssQ0FBQ3doQixPQUFOLENBQWM5YSxjQUFLLENBQUNoRixRQUFwQixLQUFSLEVBQThDZ0IsQ0FBOUMsRUFBaUR5QyxDQUFqRCxDQWRhO0FBZ0JwQixLQWxCRixDQVJzQjtBQTJCdEI7QUFwSXNCLENBQWxCLEM7O0FDVE47Ozs7QUFJQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0EsU0FBU2c3RCxXQUFULENBQXFCejNCLFNBQXJCLEVBQWdDdC9CLElBQWhDLEVBQXNDZzNELGdCQUF0QyxFQUF3RDtBQUFBLE1BQ2pEL3JELEVBQUUsR0FBRyxJQUQ0QztBQUFBLE1BRWpEMVEsT0FBTyxHQUFHeThELGdCQUFnQixJQUFJO0FBQUNsN0MseUJBQXFCLEVBQUUsQ0FBQzdRLEVBQUUsQ0FBQ2dTLFVBQUg7QUFBekIsR0FGbUI7QUFRcEI7QUFKbkMxaUIsU0FBTyxDQUFDb3JCLDBCQUFSLEtBSnVELEVBS3ZEMWEsRUFBRSxDQUFDNEosVUFBSCxLQUx1RCxFQU92RDVKLEVBQUUsQ0FBQ3c3QixhQUFILENBQWlCbkgsU0FBakIsRUFBNEJ0L0IsSUFBNUIsQ0FQdUQsRUFRdkRpTCxFQUFFLENBQUNzUSxhQUFILENBQWlCdFEsRUFBRSxDQUFDak0sSUFBSCxDQUFRK1AsT0FBekIsQ0FSdUQsRUFTdkQ5RCxFQUFFLENBQUM2cEQsZUFBSCxDQUFtQnY2RCxPQUFuQixDQVR1RDtBQVV2RDs7QUFFRHFELE1BQU0sQ0FBQzZyQixXQUFLLENBQUNTLFNBQVAsRUFBa0I7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBaW5DLFdBbEJ1QixxQkFrQmJueEQsSUFsQmEsRUFrQlBzL0IsU0FsQk8sRUFrQkk7QUFBQSxRQUNwQnIwQixFQUFFLEdBQUcsS0FBS3llLFFBRFU7QUFBQSxRQUVwQm52QixPQUFPLEdBQUcsQ0FBQyxLQUFELEVBQVEsT0FBUixFQUNkM0gsT0FEYyxDQUNOb04sSUFETSxLQUNHLENBREgsR0FDTztBQUFDMmIsbUJBQWE7QUFBZCxLQURQLEdBQytCLElBSHJCO0FBSzFCbzdDLGVBQVcsQ0FBQ3R3RCxJQUFaLENBQWlCd0UsRUFBakIsRUFBcUJxMEIsU0FBckIsRUFBZ0N0L0IsSUFBaEMsRUFBc0N6RixPQUF0QyxDQUwwQjtBQU0xQjtBQXhCc0IsQ0FBbEIsQzs7QUMxQk47Ozs7QUFJQTtBQUNBO0FBRUFxRCxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7Ozs7O0FBYUFnakIsUUFkdUIsa0JBY2hCQSxPQWRnQixFQWNSO0FBQUEsUUFDUmppQyxFQUFFLEdBQUcsS0FBS3llLFFBREY7QUFBQSxRQUVSN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRko7QUFBQSxXQUlWaEwsV0FBVyxDQUFDcTBDLE9BQUQsQ0FKRCxHQUtOcnBDLE1BQU0sQ0FBQ3luQixXQUxELElBUWR6bkIsTUFBTSxDQUFDeW5CLFdBQVAsR0FBcUI0aEIsT0FSUCxFQVNkamlDLEVBQUUsQ0FBQ3lRLE1BQUgsRUFUYyxFQVdQN1gsTUFBTSxDQUFDeW5CLFdBWEE7QUFZZDtBQTFCc0IsQ0FBbEIsQzs7QUNQTjs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFhQSxJQUFNeHpCLE1BQU0sR0FBRyxVQUFTbS9ELEtBQVQsRUFBZ0I7QUFBQSxNQUN4QmhzRCxFQUFFLEdBQUcsS0FBS3llLFFBRGM7QUFBQSxNQUV4QjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZZO0FBQUEsU0FJekJvekQsS0FKeUIsSUFROUJwekQsTUFBTSxDQUFDbWhCLFlBQVAsR0FBc0JpeUMsS0FSUSxFQVM5QmhzRCxFQUFFLENBQUNpc0Qsb0JBQUgsRUFUOEIsRUFXdkJyekQsTUFBTSxDQUFDbWhCLFlBWGdCLElBS3RCbmhCLE1BQU0sQ0FBQ21oQixZQUxlO0FBWTlCLENBWkQ7O0FBY0FwbkIsTUFBTSxDQUFDOUYsTUFBRCxFQUFTO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE4ckIsS0FBRyxFQUFFLGFBQVNxekMsS0FBVCxFQUFnQjtBQUNwQixXQUFPLEtBQUtuL0QsTUFBTCxDQUNOLEtBQUs0eEIsUUFBTCxDQUFjN2xCLE1BQWQsQ0FBcUJtaEIsWUFBckIsQ0FDRXZtQixNQURGLENBQ1N3NEQsS0FBSyxJQUFJLEVBRGxCLENBRE0sQ0FBUDtBQUlBLEdBekJhOztBQTJCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXp1RCxRQUFNLEVBQUUsZ0JBQVNuRyxNQUFULEVBQWlCO0FBQUU7QUFDMUIsU0FBS3FuQixRQUFMLENBQWM2N0IsZUFBZCxDQUE4QmxqRCxNQUE5QixLQUR3QjtBQUV4QjtBQWhEYSxDQUFULEM7O0FBb0ROOzs7Ozs7Ozs7Ozs7O0FBYUEsSUFBTW5LLE1BQU0sR0FBRyxVQUFTKytELEtBQVQsRUFBZ0I7QUFBQSxNQUN4QmhzRCxFQUFFLEdBQUcsS0FBS3llLFFBRGM7QUFBQSxNQUV4QjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZZO0FBQUEsU0FJekJvekQsS0FKeUIsSUFROUJwekQsTUFBTSxDQUFDb2hCLFlBQVAsR0FBc0JneUMsS0FSUSxFQVM5QmhzRCxFQUFFLENBQUNpc0Qsb0JBQUgsRUFUOEIsRUFXdkJyekQsTUFBTSxDQUFDb2hCLFlBWGdCLElBS3RCcGhCLE1BQU0sQ0FBQ29oQixZQUxlO0FBWTlCLENBWkQ7O0FBY0FybkIsTUFBTSxDQUFDMUYsTUFBRCxFQUFTO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEwckIsS0FBRyxFQUFFLGFBQVNxekMsS0FBVCxFQUFnQjtBQUNwQixXQUFPLEtBQUsvK0QsTUFBTCxDQUNOLEtBQUt3eEIsUUFBTCxDQUFjN2xCLE1BQWQsQ0FBcUJvaEIsWUFBckIsQ0FDRXhtQixNQURGLENBQ1N3NEQsS0FBSyxJQUFJLEVBRGxCLENBRE0sQ0FBUDtBQUlBLEdBekJhOztBQTJCZDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXp1RCxRQUFNLEVBQUUsZ0JBQVNuRyxNQUFULEVBQWlCO0FBQUU7QUFDMUIsU0FBS3FuQixRQUFMLENBQWM2N0IsZUFBZCxDQUE4QmxqRCxNQUE5QixLQUR3QjtBQUV4QjtBQWhEYSxDQUFULEMsRUFtRE56RSxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCcHlCLFFBQU0sRUFBTkEsTUFEdUI7QUFFdkJJLFFBQU0sRUFBTkE7QUFGdUIsQ0FBbEIsQzs7QUNwS047Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBTXpCLGtCQUFPLEdBQUcsVUFBU0EsUUFBVCxFQUFrQjtBQUFBLE1BQzNCd1UsRUFBRSxHQUFHLEtBQUt5ZSxRQURpQjtBQUFBLE1BRTNCN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRmU7QUFBQSxTQUk1QnBOLFFBSjRCLElBUWpDb04sTUFBTSxDQUFDcE4sT0FBUCxHQUFpQkEsUUFSZ0IsRUFTakN3VSxFQUFFLENBQUNpc0Qsb0JBQUgsRUFUaUMsRUFXMUJ6Z0UsUUFYMEIsSUFLekJvTixNQUFNLENBQUNwTixPQUxrQjtBQVlqQyxDQVpEOztBQWNBbUgsTUFBTSxDQUFDbkgsa0JBQUQsRUFBVTtBQUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQW10QixLQUFHLEVBQUUsYUFBU250QixPQUFULEVBQWtCO0FBQUEsUUFDaEJ3VSxFQUFFLEdBQUcsS0FBS3llLFFBRE07QUFBQSxRQUVoQjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZJO0FBQUEsV0FJakJwTixPQUppQixJQVF0Qm9OLE1BQU0sQ0FBQ3BOLE9BQVAsR0FBaUJvTixNQUFNLENBQUNwTixPQUFQLENBQWVnSSxNQUFmLENBQXNCaEksT0FBdEIsQ0FSSyxFQVN0QndVLEVBQUUsQ0FBQ2lzRCxvQkFBSCxFQVRzQixFQVdmcnpELE1BQU0sQ0FBQ3BOLE9BWFEsSUFLZG9OLE1BQU0sQ0FBQ3BOLE9BTE87QUFZdEIsR0FqQ2M7O0FBbUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBK1IsUUFBTSxFQUFFLGdCQUFTMnVELFlBQVQsRUFBdUI7QUFBQSxRQUN4QmxzRCxFQUFFLEdBQUcsS0FBS3llLFFBRGM7QUFBQSxRQUV4QjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZZO0FBQUEsUUFJeEJ0SixPQUFPLEdBQUc0OEQsWUFBWSxJQUFJLEVBSkY7QUFBQSxRQUt4QmhrRCxRQUFRLEdBQUc3WSxTQUFTLENBQUNDLE9BQUQsRUFBVSxVQUFWLEVBQXNCc0osTUFBTSxDQUFDSSxtQkFBN0IsQ0FMSTtBQUFBLFFBTXhCNnZELE9BQU8sR0FBR3g1RCxTQUFTLENBQUNDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLENBQUMrQyxjQUFLLENBQUM5RyxNQUFQLENBQXJCLENBTks7QUFBQSxRQU8xQkMsT0FBTyxHQUFHd1UsRUFBRSxDQUFDL04sSUFBSCxDQUFRRyxNQUFSLFlBQW1CQyxjQUFLLENBQUM3RyxPQUF6QixHQUNacVIsU0FEWSxDQUNGZ3NELE9BQU8sQ0FBQ240RCxHQUFSLENBQVksVUFBQXlELENBQUM7QUFBQSx3QkFBUUEsQ0FBUjtBQUFBLEtBQWIsQ0FERSxDQVBnQjtBQXNDOUIsV0E1QkEsQ0FBQytULFFBQVEsR0FBRzFjLE9BQU8sQ0FBQzJPLFVBQVIsR0FBcUIrTixRQUFyQixDQUE4QkEsUUFBOUIsQ0FBSCxHQUE2QzFjLE9BQXRELEVBQ0UySyxLQURGLENBQ1EsU0FEUixFQUNtQixHQURuQixFQUVFb0gsTUFGRixFQTRCQSxFQXhCQS9SLE9BQU8sR0FBR29OLE1BQU0sQ0FBQ3BOLE9Bd0JqQixFQXRCSWtELE1BQU0sQ0FBQ0MsSUFBUCxDQUFZVyxPQUFaLEVBQXFCZCxNQXNCekIsSUFyQkNoRCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ3dJLE1BQVIsQ0FBZSxVQUFBekksTUFBTSxFQUFJO0FBQ2xDLFVBQUlxRSxLQUFLLEtBQVQ7QUFEa0MsY0FHN0JyRSxNQUFNLFNBSHVCLEtBT2xDQSxNQUFNLFNBQU4sQ0FBYXFGLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0JmLE9BQXhCLENBQWdDLFVBQUFzRSxDQUFDLEVBQUk7QUFDaEMwMEQsZUFBTyxDQUFDbGhFLE9BQVIsQ0FBZ0J3TSxDQUFoQixLQUFzQixDQURVLEtBRW5DdkUsS0FBSyxLQUY4QjtBQUlwQyxPQUpELENBUGtDLEVBYTNCLENBQUNBLEtBYjBCO0FBY2xDLEtBZFMsQ0FxQlgsRUFMQ2dKLE1BQU0sQ0FBQ3BOLE9BQVAsR0FBaUJBLE9BS2xCLElBSENvTixNQUFNLENBQUNwTixPQUFQLEdBQWlCLEVBR2xCLEVBQU9BLE9BQVA7QUFDQTtBQTdGYyxDQUFWLEMsRUFnR05tSCxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQUN6ekIsU0FBTyxFQUFQQSxrQkFBT0E7QUFBUixDQUFsQixDOztBQ3BJTjs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFNdUksYUFBSSxHQUFHLFVBQVNzZ0MsU0FBVCxFQUFvQjtBQUNoQyxNQUFNdndCLE9BQU8sR0FBRyxLQUFLMmEsUUFBTCxDQUFjMXFCLElBQWQsQ0FBbUIrUCxPQUFuQztBQUVBLFNBQU9sVyxXQUFXLENBQUN5bUMsU0FBRCxDQUFYLEdBQ052d0IsT0FETSxHQUNJQSxPQUFPLENBQUM5UCxNQUFSLENBQWUsVUFBQTJCLENBQUM7QUFBQSxXQUFJMCtCLFNBQVMsQ0FBQzFzQyxPQUFWLENBQWtCZ08sQ0FBQyxDQUFDMEssRUFBcEIsS0FBMkIsQ0FBL0I7QUFBQSxHQUFoQixDQURYO0FBRUEsQ0FMRDs7QUFPQTFOLE1BQU0sQ0FBQ29CLGFBQUQsRUFBTztBQUNaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkF3akMsT0FBSyxFQUFFLGVBQVNsRCxTQUFULEVBQW9CO0FBQzFCLFdBQU8sS0FBSzVWLFFBQUwsQ0FBYzVYLG1CQUFkLENBQWtDLEtBQUs5UyxJQUFMLENBQVVzZ0MsU0FBVixDQUFsQyxDQUFQO0FBQ0EsR0FyQlc7O0FBdUJaOzs7Ozs7Ozs7Ozs7QUFZQW55QixRQUFNLEVBQUUsVUFBU2l5QixRQUFULEVBQWdDO0FBQUEsUUFBYmc0QixJQUFhO0FBQUEsUUFDbkNqcUQsTUFBTSxHQUFHLElBRDBCOztBQUd2QyxRQUFJaXlCLFFBQUosRUFBYztBQUNiLFVBQU1yd0IsT0FBTyxHQUFHLEtBQUsvUCxJQUFMLENBQVVvZ0MsUUFBVixDQUFoQjtBQUVJcndCLGFBQU8sSUFBSWhWLE9BQU8sQ0FBQ2dWLE9BQUQsQ0FIVCxLQUlaNUIsTUFBTSxHQUFHLEVBSkcsRUFNWjRCLE9BQU8sQ0FBQ2pVLE9BQVIsQ0FBZ0IsVUFBQXJDLENBQUMsRUFBSTtBQUNwQixZQUFNNCtELFNBQVMsR0FBRzUrRCxDQUFDLENBQUMwVSxNQUFGLENBQVN4UixHQUFULENBQWEsVUFBQXJDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDc0IsS0FBTjtBQUFBLFNBQWQsQ0FBbEI7QUFFQXc4RCxZQUFJLEdBQUlqcUQsTUFBTSxHQUFHQSxNQUFNLENBQUMxTyxNQUFQLENBQWM0NEQsU0FBZCxDQUFiLEdBQXlDbHFELE1BQU0sQ0FBQzdNLElBQVAsQ0FBWSsyRCxTQUFaLENBSHpCO0FBSXBCLE9BSkQsQ0FOWTtBQVliOztBQUVELFdBQU9scUQsTUFBUDtBQUNBLEdBckRXOztBQXVEWjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOG5ELE9BQUssRUFBRSxlQUFTQSxNQUFULEVBQWdCO0FBR3RCLFdBRkEsS0FBS3ZyQyxRQUFMLENBQWN5L0IsMkJBQWQsRUFFQSxFQUFPLEtBQUt6L0IsUUFBTCxDQUFjeVksb0JBQWQsQ0FBbUMsT0FBbkMsRUFBNEM4eUIsTUFBNUMsQ0FBUDtBQUNBLEdBN0VXOztBQStFWjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBckMsUUFBTSxFQUFFLGdCQUFTQSxPQUFULEVBQWlCO0FBQ3hCLFdBQU8sS0FBS2xwQyxRQUFMLENBQWN5WSxvQkFBZCxDQUFtQyxRQUFuQyxFQUE2Q3l3QixPQUE3QyxDQUFQO0FBQ0EsR0FuR1c7O0FBcUdaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE5bUQsTUFBSSxFQUFFLGNBQVNBLEtBQVQsRUFBZTtBQUNwQixXQUFPLEtBQUs0ZCxRQUFMLENBQWN5WSxvQkFBZCxDQUFtQyxNQUFuQyxFQUEyQ3IyQixLQUEzQyxDQUFQO0FBQ0EsR0F6SFc7O0FBMkhaOzs7Ozs7Ozs7OztBQVdBbFAsS0FBRyxFQUFFLGVBQVc7QUFDZixXQUFPLEtBQUs4c0IsUUFBTCxDQUFjdk4sYUFBZCxHQUE4QnZmLEdBQXJDO0FBQ0EsR0F4SVc7O0FBMElaOzs7Ozs7Ozs7OztBQVdBdUosS0FBRyxFQUFFLGVBQVc7QUFDZixXQUFPLEtBQUt1akIsUUFBTCxDQUFjdk4sYUFBZCxHQUE4QmhXLEdBQXJDO0FBQ0E7QUF2SlcsQ0FBUCxDLEVBMEpOdkksTUFBTSxDQUFDNnJCLFdBQUssQ0FBQ1MsU0FBUCxFQUFrQjtBQUFDbHJCLE1BQUksRUFBSkEsYUFBSUE7QUFBTCxDQUFsQixDOztBQzFMTjs7OztBQUlBO0FBQ0E7QUFFQXBCLE1BQU0sQ0FBQzZyQixXQUFLLENBQUNTLFNBQVAsRUFBa0I7QUFDdkI7Ozs7Ozs7Ozs7QUFVQW90QyxVQVh1QixvQkFXZHY3RCxDQVhjLEVBV1h1N0QsU0FYVyxFQVdEO0FBQUEsUUFDZnJzRCxFQUFFLEdBQUcsS0FBS3llLFFBREs7QUFBQSxRQUVmN2xCLE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BRkc7QUFTckIsV0FMSXdHLFNBQVMsQ0FBQzVRLE1BQVYsR0FBbUIsQ0FLdkIsS0FKQ29LLE1BQU0sQ0FBQzZpQixpQkFBUCxDQUF5QjNxQixDQUF6QixJQUE4QnU3RCxTQUkvQixFQUhDcnNELEVBQUUsQ0FBQ3lRLE1BQUgsRUFHRCxHQUFPN1gsTUFBTSxDQUFDNmlCLGlCQUFQLENBQXlCM3FCLENBQXpCLENBQVA7QUFDQSxHQXJCc0I7O0FBdUJ2Qjs7Ozs7Ozs7Ozs7QUFXQW9TLFlBbEN1QixzQkFrQ1pBLFdBbENZLEVBa0NBO0FBQUEsUUFDaEJsRCxFQUFFLEdBQUcsS0FBS3llLFFBRE07QUFBQSxRQUVoQjdsQixNQUFNLEdBQUdvSCxFQUFFLENBQUNwSCxNQUZJO0FBQUEsV0FJakJ3RyxTQUFTLENBQUM1USxNQUpPLElBUXRCb0ssTUFBTSxDQUFDNmlCLGlCQUFQLEdBQTJCdlksV0FSTCxFQVN0QmxELEVBQUUsQ0FBQ3lRLE1BQUgsRUFUc0IsRUFXZjdYLE1BQU0sQ0FBQzZpQixpQkFYUSxJQUtkN2lCLE1BQU0sQ0FBQzZpQixpQkFMTztBQVl0QjtBQTlDc0IsQ0FBbEIsQzs7QUNQTjs7OztBQUlBO0FBQ0E7QUFFQTlvQixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7QUFTQXBWLE9BVnVCLGlCQVVqQnhKLEVBVmlCLEVBVWI7QUFDVCxXQUFPLEtBQUtvZSxRQUFMLENBQWM1VSxLQUFkLENBQW9CeEosRUFBcEIsQ0FBUCxDQURTLENBQ3VCO0FBQ2hDO0FBWnNCLENBQWxCLEM7O0FDUE47Ozs7QUFJQTtBQUNBO0FBRUExTixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQ3ZCOzs7Ozs7Ozs7Ozs7OztBQWNBN3RCLEdBZnVCLGFBZXJCQSxFQWZxQixFQWVsQjtBQUFBLFFBQ0U0TyxFQUFFLEdBQUcsS0FBS3llLFFBRFo7QUFBQSxRQUVFaGMsYUFBYSxHQUFHekMsRUFBRSxDQUFDeXlCLFNBQUgsTUFBa0J6eUIsRUFBRSxDQUFDeUMsYUFBSCxFQUZwQztBQWlCSixXQWJJM1QsT0FBTyxDQUFDc0MsRUFBRCxDQWFYLEtBWktxUixhQVlMLEdBWEV6QyxFQUFFLENBQUNpRCxHQUFILENBQU9DLFVBQVAsQ0FBa0I5UixFQUFsQixDQVdGLElBVEU0TyxFQUFFLENBQUNxeUIsYUFBSCxDQUFpQnJ5QixFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUF6QixFQUFrQzFTLEVBQWxDLENBU0YsRUFQRTRPLEVBQUUsQ0FBQ3lRLE1BQUgsQ0FBVTtBQUNURywwQkFBb0IsSUFEWDtBQUVURCx1QkFBaUI7QUFGUixLQUFWLENBT0YsSUFBT2xPLGFBQWEsR0FBR3pDLEVBQUUsQ0FBQ2lELEdBQUgsQ0FBT0MsVUFBUCxFQUFILEdBQXlCbEQsRUFBRSxDQUFDak0sSUFBSCxDQUFRcVosRUFBckQ7QUFDQSxHQWpDc0I7O0FBbUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFBLElBcER1QixjQW9EcEJBLEdBcERvQixFQW9EaEI7QUFDTixRQUFNcE4sRUFBRSxHQUFHLEtBQUt5ZSxRQUFoQjtBQVdBLFdBVEl2dkIsUUFBUSxDQUFDa2UsR0FBRCxDQVNaLEtBUkNwTixFQUFFLENBQUN1eUIsY0FBSCxDQUFrQnZ5QixFQUFFLENBQUNqTSxJQUFILENBQVErUCxPQUExQixFQUFtQ3NKLEdBQW5DLENBUUQsRUFOQ3BOLEVBQUUsQ0FBQ3lRLE1BQUgsQ0FBVTtBQUNURywwQkFBb0IsSUFEWDtBQUVURCx1QkFBaUI7QUFGUixLQUFWLENBTUQsR0FBTzNRLEVBQUUsQ0FBQ2pNLElBQUgsQ0FBUXFaLEVBQWY7QUFDQTtBQWpFc0IsQ0FBbEIsQzs7QUNQTjs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0lBUU1rL0MsU0FBUyxHQUFHLFVBQUN0c0QsRUFBRCxFQUFLakwsSUFBTCxFQUFXcEYsS0FBWCxFQUFxQjtBQUFBLE1BQ2hDaUosTUFBTSxHQUFHb0gsRUFBRSxDQUFDcEgsTUFEb0I7QUFBQSxNQUVoQzNRLEtBQUssb0JBQWE4TSxJQUFiLENBRjJCO0FBQUEsTUFHaEM1TSxLQUFLLG9CQUFhNE0sSUFBYixDQUgyQjtBQUFBLE1BSWhDM00sTUFBTSxxQkFBYzJNLElBQWQsQ0FKMEI7QUFzQnRDLFNBaEJJbEgsU0FBUyxDQUFDOEIsS0FBRCxDQWdCYixLQWZLckIsWUFBWSxDQUFDcUIsS0FBRCxDQWVqQixJQWRFcEMsT0FBTyxDQUFDb0MsS0FBSyxDQUFDeUIsQ0FBUCxDQUFQLEtBQXFCd0gsTUFBTSxDQUFDM1EsS0FBRCxDQUFOLEdBQWdCMEgsS0FBSyxDQUFDeUIsQ0FBM0MsQ0FjRixFQWJFN0QsT0FBTyxDQUFDb0MsS0FBSyxDQUFDMEIsQ0FBUCxDQUFQLEtBQXFCdUgsTUFBTSxDQUFDelEsS0FBRCxDQUFOLEdBQWdCd0gsS0FBSyxDQUFDMEIsQ0FBM0MsQ0FhRixFQVpFOUQsT0FBTyxDQUFDb0MsS0FBSyxDQUFDeWMsRUFBUCxDQUFQLEtBQXNCeFQsTUFBTSxDQUFDeFEsTUFBRCxDQUFOLEdBQWlCdUgsS0FBSyxDQUFDeWMsRUFBN0MsQ0FZRixLQVZFeFQsTUFBTSxDQUFDelEsS0FBRCxDQUFOLEdBQWdCd0gsS0FVbEIsRUFURWlKLE1BQU0sQ0FBQ3hRLE1BQUQsQ0FBTixHQUFpQnVILEtBU25CLEdBTkNxUSxFQUFFLENBQUN5USxNQUFILENBQVU7QUFDVEcsd0JBQW9CLElBRFg7QUFFVEQscUJBQWlCO0FBRlIsR0FBVixDQU1ELEdBQU8xYixTQUFQO0FBQ0EsQztJQVNLSCxrQkFBUyxHQUFHLFVBQUNrTCxFQUFELEVBQUtqTCxJQUFMLEVBQWM7QUFDL0IsTUFBTTZELE1BQU0sR0FBR29ILEVBQUUsQ0FBQ3BILE1BQWxCO0FBRUEsU0FBTztBQUNOeEgsS0FBQyxFQUFFd0gsTUFBTSxrQkFBVzdELElBQVgsRUFESDtBQUVOMUQsS0FBQyxFQUFFdUgsTUFBTSxrQkFBVzdELElBQVgsRUFGSDtBQUdOcVgsTUFBRSxFQUFFeFQsTUFBTSxtQkFBWTdELElBQVo7QUFISixHQUFQO0FBS0EsQztJQU1LL00sYUFBSSxHQUFHMkssTUFBTSxDQUFDLFlBQU0sQ0FBRSxDQUFULEVBQVc7QUFDN0I7Ozs7Ozs7Ozs7Ozs7QUFhQTBVLFFBQU0sRUFBRSxnQkFBU0EsT0FBVCxFQUFpQjtBQUN4QixRQUFNckgsRUFBRSxHQUFHLEtBQUt5ZSxRQUFoQjtBQUVJcmYsYUFBUyxDQUFDNVEsTUFIVSxLQUl2QkUsTUFBTSxDQUFDQyxJQUFQLENBQVkwWSxPQUFaLEVBQW9CeFgsT0FBcEIsQ0FBNEIsVUFBQXkrQixNQUFNLEVBQUk7QUFDckN0dUIsUUFBRSxDQUFDaFksSUFBSCxDQUFRdWtFLFlBQVIsQ0FBcUJqK0IsTUFBckIsRUFBNkJqbkIsT0FBTSxDQUFDaW5CLE1BQUQsQ0FBbkMsQ0FEcUM7QUFFckMsS0FGRCxDQUp1QixFQVF2QnR1QixFQUFFLENBQUNoWSxJQUFILENBQVF3dkIsWUFBUixFQVJ1QjtBQVV4QixHQXhCNEI7O0FBMEI3Qjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTdsQixLQUFHLEVBQUUsYUFBU0EsSUFBVCxFQUFjO0FBQ2xCLFFBQU1xTyxFQUFFLEdBQUcsS0FBS3llLFFBQWhCO0FBRUEsV0FBT3JmLFNBQVMsQ0FBQzVRLE1BQVYsR0FDTjg5RCxTQUFTLENBQUN0c0QsRUFBRCxFQUFLLEtBQUwsRUFBWXJPLElBQVosQ0FESCxHQUVObUQsa0JBQVMsQ0FBQ2tMLEVBQUQsRUFBSyxLQUFMLENBRlY7QUFHQSxHQWhENEI7O0FBa0Q3Qjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTlFLEtBQUcsRUFBRSxhQUFTQSxJQUFULEVBQWM7QUFDbEIsUUFBTThFLEVBQUUsR0FBRyxLQUFLeWUsUUFBaEI7QUFFQSxXQUFPcmYsU0FBUyxDQUFDNVEsTUFBVixHQUNOODlELFNBQVMsQ0FBQ3RzRCxFQUFELEVBQUssS0FBTCxFQUFZOUUsSUFBWixDQURILEdBRU5wRyxrQkFBUyxDQUFDa0wsRUFBRCxFQUFLLEtBQUwsQ0FGVjtBQUdBLEdBeEU0Qjs7QUEwRTdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE5RyxPQUFLLEVBQUUsZUFBU0EsTUFBVCxFQUFnQjtBQUN0QixRQUFNbFIsSUFBSSxHQUFHLEtBQUtBLElBQWxCO0FBRUEsUUFBSW9YLFNBQVMsQ0FBQzVRLE1BQWQsRUFDQ1gsU0FBUyxDQUFDcUwsTUFBSyxDQUFDZ0MsR0FBUCxDQUFULElBQXdCbFQsSUFBSSxDQUFDa1QsR0FBTCxDQUFTaEMsTUFBSyxDQUFDZ0MsR0FBZixDQUR6QixFQUVDck4sU0FBUyxDQUFDcUwsTUFBSyxDQUFDdkgsR0FBUCxDQUFULElBQXdCM0osSUFBSSxDQUFDMkosR0FBTCxDQUFTdUgsTUFBSyxDQUFDdkgsR0FBZixDQUZ6QixNQUlDLE9BQU87QUFDTnVKLFNBQUcsRUFBRWxULElBQUksQ0FBQ2tULEdBQUwsRUFEQztBQUVOdkosU0FBRyxFQUFFM0osSUFBSSxDQUFDMkosR0FBTDtBQUZDLEtBQVA7QUFNRCxXQUFPc0QsU0FBUDtBQUNBO0FBN0c0QixDQUFYLEM7QUFyQm5COzs7Ozs7Ozs7QUFxSUF0QyxNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQUNqM0IsTUFBSSxFQUFKQSxhQUFJQTtBQUFMLENBQWxCLEM7O0FDN0tOOzs7O0FBSUE7QUFDQTtBQUVBOzs7OztBQUlBLElBQU1zcEIsTUFBTSxHQUFHM2UsTUFBTSxDQUFDLFlBQU0sQ0FBRSxDQUFULEVBQVc7QUFDL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE4cEQsTUFBSSxFQUFFLGNBQVNwb0IsU0FBVCxFQUFvQjtBQUN6QixRQUFNcjBCLEVBQUUsR0FBRyxLQUFLeWUsUUFBaEI7QUFFQXplLE1BQUUsQ0FBQys5QyxVQUFILENBQWMvOUMsRUFBRSxDQUFDaTBCLGNBQUgsQ0FBa0JJLFNBQWxCLENBQWQsQ0FIeUIsRUFJekJyMEIsRUFBRSxDQUFDNnBELGVBQUgsQ0FBbUI7QUFBQ3J2QyxnQkFBVTtBQUFYLEtBQW5CLENBSnlCO0FBS3pCLEdBekI4Qjs7QUEyQi9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBMDdCLE1BQUksRUFBRSxjQUFTN2hCLFNBQVQsRUFBb0I7QUFDekIsUUFBTXIwQixFQUFFLEdBQUcsS0FBS3llLFFBQWhCO0FBRUF6ZSxNQUFFLENBQUNpK0MsVUFBSCxDQUFjaitDLEVBQUUsQ0FBQ2kwQixjQUFILENBQWtCSSxTQUFsQixDQUFkLENBSHlCLEVBSXpCcjBCLEVBQUUsQ0FBQzZwRCxlQUFILENBQW1CO0FBQUNydkMsZ0JBQVU7QUFBWCxLQUFuQixDQUp5QjtBQUt6QjtBQW5EOEIsQ0FBWCxDQUFyQjtBQXNEQTduQixNQUFNLENBQUM2ckIsV0FBSyxDQUFDUyxTQUFQLEVBQWtCO0FBQUMzTixRQUFNLEVBQU5BO0FBQUQsQ0FBbEIsQzs7QUNqRU47Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTNlLE1BQU0sQ0FBQzZyQixXQUFLLENBQUNTLFNBQVAsRUFBa0I7QUFDdkI7Ozs7Ozs7Ozs7Ozs7QUFhQXV0QyxRQWR1QixrQkFjaEJweUQsSUFkZ0IsRUFjVjtBQUNaLFFBQU14QixNQUFNLEdBQUcsS0FBSzZsQixRQUFMLENBQWM3bEIsTUFBN0I7QUFFQUEsVUFBTSxDQUFDdW1CLFVBQVAsR0FBb0Iva0IsSUFBSSxHQUFHQSxJQUFJLENBQUM5SSxLQUFSLEdBQWdCLElBSDVCLEVBSVpzSCxNQUFNLENBQUN3bUIsV0FBUCxHQUFxQmhsQixJQUFJLEdBQUdBLElBQUksQ0FBQzdJLE1BQVIsR0FBaUIsSUFKOUIsRUFNWixLQUFLMnJCLEtBQUwsUUFOWTtBQU9aLEdBckJzQjs7QUF1QnZCOzs7Ozs7Ozs7Ozs7O0FBYUFBLE9BcEN1QixpQkFvQ2pCdXZDLElBcENpQixFQW9DWEMsWUFwQ1csRUFvQ0c7QUFDekIsUUFBTTFzRCxFQUFFLEdBQUcsS0FBS3llLFFBQWhCLENBRHlCLENBR3pCOztBQUNJaXVDLGdCQUpxQixHQUt4QjFzRCxFQUFFLENBQUN2WCxLQUFILElBQVl1WCxFQUFFLENBQUN2WCxLQUFILENBQVN1N0QsWUFBVCxFQUxZLEdBUXhCaGtELEVBQUUsQ0FBQ2hZLElBQUgsSUFBV2dZLEVBQUUsQ0FBQ2hZLElBQUgsQ0FBUXdZLFNBQVIsRUFSYSxFQVd6QlIsRUFBRSxDQUFDbUQsU0FBSCxHQUFlLElBWFUsRUFhekJzcEQsSUFBSSxHQUFHenNELEVBQUUsQ0FBQ3lRLE1BQUgsQ0FBVTtBQUNoQkMsbUJBQWEsSUFERztBQUVoQkMsdUJBQWlCLElBRkQ7QUFHaEJDLDBCQUFvQixJQUhKO0FBSWhCNEosZ0JBQVU7QUFKTSxLQUFWLENBQUgsR0FLQ3hhLEVBQUUsQ0FBQzZwRCxlQUFILENBQW1CO0FBQ3ZCcnZDLGdCQUFVLElBRGE7QUFFdkJwVCxvQkFBYyxJQUZTO0FBR3ZCc1QsZ0NBQTBCO0FBSEgsS0FBbkIsQ0FsQm9CO0FBdUJ6QixHQTNEc0I7O0FBNkR2Qjs7Ozs7Ozs7QUFRQWl5QyxTQXJFdUIscUJBcUViO0FBQUE7QUFBQSxRQUNIM3NELEVBQUUsR0FBRyxLQUFLeWUsUUFEUDs7QUF5QlQsV0F0Qkk1dkIsUUFBUSxDQUFDbVIsRUFBRCxDQXNCWixLQXJCQ0EsRUFBRSxDQUFDOEksY0FBSCxDQUFrQixjQUFsQixDQXFCRCxFQXBCQzlJLEVBQUUsQ0FBQzI4QyxNQUFILENBQVVuL0IsTUFBVixDQUFpQnhkLEVBQUUsQ0FBQzI4QyxNQUFILENBQVVoMUQsT0FBVixDQUFrQixJQUFsQixDQUFqQixFQUEwQyxDQUExQyxDQW9CRCxFQWpCQ3FZLEVBQUUsQ0FBQzBHLEdBQUgsQ0FBT3RVLE1BQVAsQ0FBYyxHQUFkLEVBQW1COEgsU0FBbkIsRUFpQkQsRUFoQkNyTSxTQUFTLENBQUNtUyxFQUFFLENBQUMrYyxhQUFKLENBQVQsSUFBK0I3MUIsaUJBQU0sQ0FBQzgxQixZQUFQLENBQW9CaGQsRUFBRSxDQUFDK2MsYUFBdkIsQ0FnQmhDLEVBZEM3MUIsaUJBQU0sQ0FBQzBsRSxtQkFBUCxDQUEyQixRQUEzQixFQUFxQzVzRCxFQUFFLENBQUMyYyxjQUF4QyxDQWNELEVBYkMzYyxFQUFFLENBQUNrSCxXQUFILENBQWVpRyxPQUFmLENBQXVCLElBQXZCLE1BQW9DdGMsSUFBcEMsQ0FBeUMsRUFBekMsQ0FhRCxFQVZDbkMsTUFBTSxDQUFDQyxJQUFQLENBQVksSUFBWixFQUFrQmtCLE9BQWxCLENBQTBCLFVBQUFOLEdBQUcsRUFBSTtBQUNoQ0EsU0FBRyxLQUFLLFVBQVIsSUFBc0JiLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZcVIsRUFBWixFQUFnQm5RLE9BQWhCLENBQXdCLFVBQUF3K0IsQ0FBQyxFQUFJO0FBQ2xEcnVCLFVBQUUsQ0FBQ3F1QixDQUFELENBQUYsR0FBUSxJQUQwQztBQUVsRCxPQUZxQixDQURVLEVBS2hDLEtBQUksQ0FBQzkrQixHQUFELENBQUosR0FBWSxJQUxvQixFQU1oQyxPQUFPLEtBQUksQ0FBQ0EsR0FBRCxDQU5xQjtBQU9oQyxLQVBELENBVUQsR0FBTyxJQUFQO0FBQ0EsR0EvRnNCOztBQWlHdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFxSixRQXBIdUIsa0JBb0hoQnpHLElBcEhnQixFQW9IVnhDLEtBcEhVLEVBb0hIOGdCLE1BcEhHLEVBb0hLO0FBQUEsUUFHdkJ6YixHQUh1QjtBQUFBLFFBQ3JCZ0wsRUFBRSxHQUFHLEtBQUt5ZSxRQURXO0FBQUEsUUFFckJsdkIsR0FBRyxHQUFHNEMsSUFBSSxJQUFJQSxJQUFJLENBQUM5QixPQUFMLENBQWEsS0FBYixFQUFvQixHQUFwQixDQUZPO0FBZ0IzQixXQVhJZCxHQUFHLElBQUl5USxFQUFFLENBQUNwSCxNQVdkLEtBVksvSyxTQUFTLENBQUM4QixLQUFELENBVWQsSUFURXFRLEVBQUUsQ0FBQ3BILE1BQUgsQ0FBVXJKLEdBQVYsSUFBaUJJLEtBU25CLEVBUkVxRixHQUFHLEdBQUdyRixLQVFSLEVBTkU4Z0IsTUFBTSxJQUFJLEtBQUt5TSxLQUFMLEVBTVosSUFKRWxvQixHQUFHLEdBQUdnTCxFQUFFLENBQUNwSCxNQUFILENBQVVySixHQUFWLENBSVIsR0FBT3lGLEdBQVA7QUFDQTtBQXJJc0IsQ0FBbEIsQzs7QUNSTjs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7QUFJQSxJQUFNMUksT0FBTyxHQUFHcUcsTUFBTSxDQUFDLFlBQU0sQ0FBRSxDQUFULEVBQVc7QUFDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREE4cEQsTUFBSSxFQUFFLGdCQUFvQjtBQUFBLFFBRXJCOStDLEtBRnFCO0FBQUEsUUFHckJsSCxLQUhxQjtBQUFBLFFBQVh4RyxJQUFXLHVFQUFKLEVBQUk7QUFBQSxRQUNuQitQLEVBQUUsR0FBRyxLQUFLeWUsUUFEUzs7QUFVekI7QUFDQSxRQUxJeHVCLElBQUksQ0FBQ3dHLEtBS1QsS0FKQ0EsS0FBSyxHQUFHeEcsSUFBSSxDQUFDd0csS0FJZCxHQUFJeEcsSUFBSSxDQUFDOEQsSUFBVCxFQUFlO0FBQ2QsVUFBTTFDLENBQUMsR0FBRzJPLEVBQUUsQ0FBQ3FzQixTQUFILENBQWFwOEIsSUFBSSxDQUFDOEQsSUFBTCxDQUFVc00sRUFBdkIsRUFBMkJwUSxJQUFJLENBQUM4RCxJQUFMLENBQVVwRSxLQUFyQyxDQUFWO0FBRUlxUSxRQUFFLENBQUNneUIsV0FBSCxFQUhVLEdBS2J2N0IsS0FBSyxHQUFHLENBQUN1SixFQUFFLENBQUM1TyxDQUFILENBQUtuQixJQUFJLENBQUM4RCxJQUFMLENBQVUzQyxDQUFmLENBQUQsRUFBb0JDLENBQXBCLENBTEssSUFPVCxDQUFDMk8sRUFBRSxDQUFDcEgsTUFBSCxDQUFVd3hCLGVBUEYsS0FRWjN6QixLQUFLLEdBQUcsQ0FBQyxDQUFELEVBQUlwRixDQUFKLENBUkksR0FXYnNNLEtBQUssR0FBR3BRLE9BQU8sQ0FBQzBDLElBQUksQ0FBQzhELElBQUwsQ0FBVTRKLEtBQVgsQ0FBUCxHQUEyQjFOLElBQUksQ0FBQzhELElBQUwsQ0FBVTRKLEtBQXJDLEdBQTZDcUMsRUFBRSxDQUFDdXhCLFdBQUgsQ0FBZXRoQyxJQUFJLENBQUM4RCxJQUFMLENBQVUzQyxDQUF6QixDQVh4QztBQWFkLEtBYkQsTUFhV3ZELFNBQVMsQ0FBQ29DLElBQUksQ0FBQ21CLENBQU4sQ0FicEIsR0FjQ3VNLEtBQUssR0FBR3FDLEVBQUUsQ0FBQ3V4QixXQUFILENBQWV0aEMsSUFBSSxDQUFDbUIsQ0FBcEIsQ0FkVCxHQWVXdkQsU0FBUyxDQUFDb0MsSUFBSSxDQUFDME4sS0FBTixDQWZwQixLQWdCQ0EsS0FBSyxHQUFHMU4sSUFBSSxDQUFDME4sS0FoQmQsRUFYeUIsQ0E4QnpCOzs7QUFDQSxLQUFDcUMsRUFBRSxDQUFDME0sU0FBSCxLQUFpQixPQUFqQixHQUNBLENBQUMsV0FBRCxFQUFjLFdBQWQsQ0FEQSxHQUM2QixDQUFDLFlBQUQsQ0FEOUIsRUFFRTdjLE9BRkYsQ0FFVSxVQUFBZzlELFNBQVMsRUFBSTtBQUN0QjdzRCxRQUFFLENBQUMzSSxhQUFILENBQWlCdzFELFNBQWpCLEVBQTRCbHZELEtBQTVCLEVBQW1DbEgsS0FBbkMsQ0FEc0I7QUFFdEIsS0FKRCxDQS9CeUI7QUFvQ3pCLEdBdEYrQjs7QUF3RmhDOzs7Ozs7QUFNQXkvQyxNQUFJLEVBQUUsZ0JBQVc7QUFDaEIsUUFBTWwyQyxFQUFFLEdBQUcsS0FBS3llLFFBQWhCO0FBRUF6ZSxNQUFFLENBQUM2VixXQUFILElBSGdCLEVBSWhCN1YsRUFBRSxDQUFDeStCLGNBQUgsRUFKZ0IsRUFLaEJ6K0IsRUFBRSxDQUFDNitCLGVBQUgsRUFMZ0IsRUFNaEI3K0IsRUFBRSxDQUFDby9CLFlBQUgsRUFOZ0I7QUFPaEI7QUFyRytCLENBQVgsQ0FBdEI7QUF3R0F6c0MsTUFBTSxDQUFDNnJCLFdBQUssQ0FBQ1MsU0FBUCxFQUFrQjtBQUFDM3lCLFNBQU8sRUFBUEE7QUFBRCxDQUFsQixDOztBQ25ITjs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztJQU9Nd2dFLGdCQUFnQixHQUFHLFVBQUExOEQsR0FBRztBQUFBLFNBQUkyOEQsSUFBSSxDQUNuQ0Msa0JBQWtCLENBQUM1OEQsR0FBRCxDQUFsQixDQUNFQyxPQURGLENBQ1UsaUJBRFYsRUFDNkIsVUFBQzQ4RCxLQUFELEVBQVFwNkQsQ0FBUjtBQUFBLFdBQWNxNkQsTUFBTSxDQUFDQyxZQUFQLGFBQXlCdDZELENBQXpCLEVBQWQ7QUFBQSxHQUQ3QixDQURtQyxDQUFSO0FBQUEsQztJQVd0QnU2RCxnQkFBZ0IsR0FBRyxVQUFDNzhELElBQUQsRUFBTzZKLElBQVAsRUFBZ0I7QUFBQSxNQUNsQ2l6RCxVQUFVLEdBQUcsSUFBSUMsYUFBSixFQURxQjtBQUFBLE1BRWxDdGEsS0FBSyxHQUFHemlELElBQUksQ0FBQzYyRCxTQUFMLElBRjBCO0FBQUEsTUFHbENtRyxPQUFPLEdBQUdwNkQsV0FBVyxDQUFDRCxPQUFPLENBQUMzTCxRQUFRLENBQUM2TCxXQUFWLENBQVIsQ0FBWCxDQUNkWSxNQURjLENBQ1AsVUFBQTRLLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUMydUQsT0FBTjtBQUFBLEdBRE0sRUFFZDc4RCxHQUZjLENBRVYsVUFBQWtPLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUMydUQsT0FBTjtBQUFBLEdBRlMsQ0FId0I7QUFPeEN2YSxPQUFLLENBQUNMLFlBQU4sQ0FBbUIsT0FBbkIsRUFBNEJPLDZGQUFZLENBQUNzYSxLQUF6QyxDQVB3QztBQUFBLE1BU2xDQyxPQUFPLEdBQUdKLFVBQVUsQ0FBQ0ssaUJBQVgsQ0FBNkIxYSxLQUE3QixDQVR3QjtBQUFBLE1BWWxDNzhDLEtBQUssR0FBRzVPLFFBQVEsQ0FBQzJsQixhQUFULENBQXVCLE9BQXZCLENBWjBCLEVBV3hDOztBQUdBL1csT0FBSyxDQUFDRyxXQUFOLENBQWtCL08sUUFBUSxDQUFDb21FLGNBQVQsQ0FBd0JKLE9BQU8sQ0FBQ3pYLElBQVIsQ0FBYSxJQUFiLENBQXhCLENBQWxCLENBZHdDO0FBQUEsTUFnQmxDOFgsUUFBUSxHQUFHUCxVQUFVLENBQUNLLGlCQUFYLENBQTZCdjNELEtBQTdCLENBaEJ1QjtBQUFBLE1Bb0JsQ21tRCxPQUFPLEdBQUcsdUJBQWVwSiw2RkFBWSxDQUFDeHNDLEdBQTVCLHdCQUEyQ3RNLElBQUksQ0FBQzlJLEtBQWhELHlCQUFrRThJLElBQUksQ0FBQzdJLE1BQXZFLGdGQUVYcThELFFBRlcsdUJBR1hILE9BQU8sQ0FBQ3A5RCxPQUFSLENBQWdCLGVBQWhCLEVBQWlDLElBQWpDLENBSFcsb0NBS2RBLE9BTGMsQ0FLTixPQUxNLEVBS0csS0FMSCxDQXBCd0IsRUFrQnhDO0FBQ0E7O0FBUUEsNkNBQW9DeThELGdCQUFnQixDQUFDeFEsT0FBRCxDQUFwRDtBQUNBLEM7QUFsQ0Q7Ozs7Ozs7O0FBb0NBM3BELE1BQU0sQ0FBQzZyQixXQUFLLENBQUNTLFNBQVAsRUFBa0I7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRHVCLDZCQTJCaEJpWixRQTNCZ0IsRUEyQk56YSxRQTNCTSxFQTJCSTtBQUFBLFFBQ3BCemQsRUFBRSxHQUFHLEtBQUt5ZSxRQURVO0FBQUEsUUFFcEJya0IsSUFBSSxHQUFHO0FBQUM5SSxXQUFLLEVBQUUwTyxFQUFFLENBQUNzVCxZQUFYO0FBQXlCL2hCLFlBQU0sRUFBRXlPLEVBQUUsQ0FBQ21UO0FBQXBDLEtBRmE7QUFBQSxRQUdwQjA2QyxVQUFVLEdBQUdULGdCQUFnQixDQUFDLEtBQUtwZ0QsT0FBTixFQUFlNVMsSUFBZixDQUhUOztBQUsxQixRQUFJM00sVUFBVSxDQUFDZ3dCLFFBQUQsQ0FBZCxFQUEwQjtBQUN6QixVQUFNcXdDLEdBQUcsR0FBRyxJQUFJNzNELEtBQUosRUFBWjtBQUVBNjNELFNBQUcsQ0FBQ0MsWUFBSixHQUFtQixXQUhNLEVBSXpCRCxHQUFHLENBQUNFLE1BQUosR0FBYSxZQUFNO0FBQUEsWUFDWkMsTUFBTSxHQUFHMW1FLFFBQVEsQ0FBQzJsQixhQUFULENBQXVCLFFBQXZCLENBREc7QUFBQSxZQUVacmIsR0FBRyxHQUFHbzhELE1BQU0sQ0FBQ0MsVUFBUCxDQUFrQixJQUFsQixDQUZNO0FBSWxCRCxjQUFNLENBQUMzOEQsS0FBUCxHQUFlOEksSUFBSSxDQUFDOUksS0FKRixFQUtsQjI4RCxNQUFNLENBQUMxOEQsTUFBUCxHQUFnQjZJLElBQUksQ0FBQzdJLE1BTEgsRUFNbEJNLEdBQUcsQ0FBQ3M4RCxTQUFKLENBQWNMLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FOa0IsRUFRbEJyd0MsUUFBUSxDQUFDd3dDLE1BQU0sQ0FBQ0csU0FBUCxDQUFpQmwyQixRQUFqQixDQUFELENBUlU7QUFTbEIsT0Fid0IsRUFlekI0MUIsR0FBRyxDQUFDNTNELEdBQUosR0FBVTIzRCxVQWZlO0FBZ0J6Qjs7QUFFRCxXQUFPQSxVQUFQO0FBQ0E7QUFuRHNCLENBQWxCLEM7Ozs7O0FDeEROO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtJQUVJUSxTQUFRLEdBQUcsRTtJQU1UQyxFQUFFLEdBQUc7QUFDVjs7Ozs7OztBQU9BQyxTQUFPLEVBQUUsT0FSQzs7QUFVVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkFDLFVBcENVLG9CQW9DRDUxRCxNQXBDQyxFQW9DTztBQUFBLFFBQ1Z0SixPQUFPLEdBQUc4RSxRQUFRLENBQUMsRUFBRCxFQUFLaTZELFNBQUwsRUFBZXoxRCxNQUFmLENBRFI7QUFBQSxRQUVWNjFELElBQUksR0FBRyxJQUFJandDLFdBQUosQ0FBVWx2QixPQUFWLENBRkc7QUFPaEIsV0FIQW0vRCxJQUFJLENBQUNod0MsUUFBTCxDQUFjaytCLE1BQWQsR0FBdUIsS0FBSytSLFFBRzVCLEVBRkEsS0FBS0EsUUFBTCxDQUFjcjVELElBQWQsQ0FBbUJvNUQsSUFBbkIsQ0FFQSxFQUFPQSxJQUFQO0FBQ0EsR0E1Q1M7O0FBOENWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBSixVQXBFVSxvQkFvRUQvK0QsT0FwRUMsRUFvRVE7QUFLakIsV0FKSUosUUFBUSxDQUFDSSxPQUFELENBSVosS0FIQysrRCxTQUFRLEdBQUcvK0QsT0FHWixHQUFPKytELFNBQVA7QUFDQSxHQTFFUzs7QUE0RVY7Ozs7Ozs7Ozs7O0FBV0FLLFVBQVEsRUFBRSxFQXZGQTs7QUF5RlY7Ozs7Ozs7O0FBUUFDLFFBQU0sRUFBRSxFQWpHRTs7QUFtR1Y7Ozs7QUFJQS9sRSxPQUFLLEVBQUU7QUFDTm1ILE1BQUUsRUFBRXl1QixXQUFLLENBQUNTLFNBREo7QUFFTlIsWUFBUSxFQUFFO0FBQ1QxdUIsUUFBRSxFQUFFMlksMkJBQWEsQ0FBQ3VXLFNBRFQ7QUFFVGozQixVQUFJLEVBQUU7QUFDTCtILFVBQUUsRUFBRXVRLFNBQUksQ0FBQzJlO0FBREo7QUFGRztBQUZKO0FBdkdHLEM7QUFKWDs7Ozs7QUFzSEE7QUFDZXF2Qyw0RUFBZixFIiwiZmlsZSI6ImJpbGxib2FyZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImQzLXRpbWUtZm9ybWF0XCIsIFwiZDMtc2VsZWN0aW9uXCIsIFwiZDMtdHJhbnNpdGlvblwiLCBcImQzLWF4aXNcIiwgXCJkMy1icnVzaFwiLCBcImQzLXNjYWxlXCIsIFwiZDMtZHN2XCIsIFwiZDMtZHJhZ1wiLCBcImQzLXNoYXBlXCIsIFwiZDMtaW50ZXJwb2xhdGVcIiwgXCJkMy1jb2xvclwiLCBcImQzLXpvb21cIiwgXCJkMy1lYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh3aW5kb3csIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzUwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzUxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzUyX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzUzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU1X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU2X18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxuLyogZXNsaW50IHByZWZlci1kZXN0cnVjdHVyaW5nOiBvZmYgKi9cblxudmFyIHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcblxudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbnZhciBvdmVybGF5ID0gcmVxdWlyZSgnLi9vdmVybGF5Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nLFxuICAgIHNldExvZ0xldmVsID0gX3JlcXVpcmUuc2V0TG9nTGV2ZWw7XG5cbnZhciBzZW5kTWVzc2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMvc2VuZE1lc3NhZ2UnKTtcblxudmFyIHJlbG9hZEFwcCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVsb2FkQXBwJyk7XG5cbnZhciBjcmVhdGVTb2NrZXRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVNvY2tldFVybCcpO1xuXG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIGN1cnJlbnRIYXNoOiAnJ1xufTtcbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBob3RSZWxvYWQ6IHRydWUsXG4gIGxpdmVSZWxvYWQ6IGZhbHNlLFxuICBpbml0aWFsOiB0cnVlLFxuICB1c2VXYXJuaW5nT3ZlcmxheTogZmFsc2UsXG4gIHVzZUVycm9yT3ZlcmxheTogZmFsc2UsXG4gIHVzZVByb2dyZXNzOiBmYWxzZVxufTtcbnZhciBzb2NrZXRVcmwgPSBjcmVhdGVTb2NrZXRVcmwoX19yZXNvdXJjZVF1ZXJ5KTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIG9wdGlvbnMuaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xufVxuXG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBvcHRpb25zLmhvdCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBMaXZlIFJlbG9hZGluZyBlbmFibGVkLicpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTsgLy8gZml4ZXMgIzEwNDIuIG92ZXJsYXkgZG9lc24ndCBjbGVhciBpZiBlcnJvcnMgYXJlIGZpeGVkIGJ1dCB3YXJuaW5ncyByZW1haW4uXG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMuY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcbiAgJ3N0aWxsLW9rJzogZnVuY3Rpb24gc3RpbGxPaygpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gTm90aGluZyBjaGFuZ2VkLicpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcblxuICAgIGlmIChob3RDdHgua2V5cygpLmluZGV4T2YoJy4vbG9nJykgIT09IC0xKSB7XG4gICAgICBob3RDdHgoJy4vbG9nJykuc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH1cblxuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLnVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy51c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdQcm9ncmVzcycsIGRhdGEpO1xuICB9LFxuICBvazogZnVuY3Rpb24gb2soKSB7XG4gICAgc2VuZE1lc3NhZ2UoJ09rJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZyk7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnV2FybmluZ3MnLCBzdHJpcHBlZFdhcm5pbmdzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX3dhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2koZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF9lcnJvcnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIERpc2Nvbm5lY3RlZCEnKTtcbiAgICBzZW5kTWVzc2FnZSgnQ2xvc2UnKTtcbiAgfVxufTtcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TWVzc2FnZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZVxuICBjYW1lbGNhc2VcbiovXG5cbnZhciBDbGllbnQgPSBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXztcbnZhciByZXRyaWVzID0gMDtcbnZhciBjbGllbnQgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBjbGllbnQgPSBudWxsOyAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xuICAgICAgLy8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMpO1xuICAgICAgfSwgcmV0cnlJbk1zKTtcbiAgICB9XG4gIH0pO1xuICBjbGllbnQub25NZXNzYWdlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDsiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XG5cbnZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9CYXNlQ2xpZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZUNsaWVudCkge1xuICBfaW5oZXJpdHMoU29ja0pTQ2xpZW50LCBfQmFzZUNsaWVudCk7XG5cbiAgZnVuY3Rpb24gU29ja0pTQ2xpZW50KHVybCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2NrSlNDbGllbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU29ja0pTQ2xpZW50KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrSlNDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5zb2NrLm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmKGUuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKCcuL1NvY2tKU0NsaWVudCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyIsIi8qIHNvY2tqcy1jbGllbnQgdjEuMy4wIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwOidcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgRXZlbnRTb3VyY2VSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvZXZlbnRzb3VyY2UnKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFFdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xufTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2V2ZW50c291cmNlXCI6MjksXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9odG1sZmlsZVwiOjMwLFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi91dGlscy9yYW5kb21cIjo1MCxcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCIuL3JlY2VpdmVyL2pzb25wXCI6MzEsXCIuL3NlbmRlci9qc29ucFwiOjMzLFwiaW5oZXJpdHNcIjo1N31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo0OSxcIi4uL2lmcmFtZVwiOjIyLFwiaW5oZXJpdHNcIjo1N31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XG59XG5cbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xuICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID9cbiAgICAgIGlmcmFtZVV0aWxzLmNyZWF0ZUh0bWxmaWxlIDogaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lO1xuXG4gIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcbiAgICAgIHNlbGYuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIH1cbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfVxuICAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0b3AnKTtcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgfVxuICB9O1xuICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnY2FsbGJhY2snKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UoJ3Blcm1hbmVudCcpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSHRtbGZpbGVSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ19jbG9zZScsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoYXhvIGluIGdsb2JhbCkge1xuICB0cnkge1xuICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcIi4veGRyLXN0cmVhbWluZ1wiOjQwLFwiaW5oZXJpdHNcIjo1N31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcImluaGVyaXRzXCI6NTd9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuMy4wJztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2NvbW1vblwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cblxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5lZWRzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDbGllbnQ7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG5cbnZhciBFbnRpdGllcyA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGNyZWF0aW5nIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn1cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2UpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI1wiLmNvbmNhdChjb2xvcnMucmVkLCBcIlxcXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+XCIpLmNvbmNhdChhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZSkpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lFcnJvck92ZXJsYXkoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9IC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cblxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgZGVzdHJveUVycm9yT3ZlcmxheSgpO1xufTsgLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cblxuZXhwb3J0cy5zaG93TWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZXMpIHtcbiAgc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2VzWzBdKTtcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxuICBIdG1sNEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNC1lbnRpdGllcy5qcycpLFxuICBIdG1sNUVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpLFxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcbn07XG4iLCJ2YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcblxudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcblxudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88fD58XCJ8J3wmL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XG4iLCJ2YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuXG52YXIgaSA9IDA7XG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG53aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgbnVtSW5kZXhbY10gPSBhO1xuICAgIGkrKztcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw0RW50aXRpZXM7XG4iLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIElORk86XG4gICAgY2FzZSBXQVJOOlxuICAgIGNhc2UgRVJST1I6XG4gICAgY2FzZSBERUJVRzpcbiAgICBjYXNlIFRSQUNFOlxuICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgV0FSTklORzpcbiAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIE5PTkU6XG4gICAgY2FzZSBTSUxFTlQ6XG4gICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cblxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZW5kTXNnOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIGhvdFJlbG9hZCA9IF9yZWYuaG90UmVsb2FkLFxuICAgICAgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICAgIGN1cnJlbnRIYXNoID0gX3JlZjIuY3VycmVudEhhc2g7XG5cbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG5cbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoY3VycmVudEhhc2gpLCAnKicpO1xuICAgIH1cbiAgfSAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkKSB7XG4gICAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2Fib3V0OicpIHtcbiAgICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbG9hZEFwcDsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgc2VsZiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbnZhciBnZXRDdXJyZW50U2NyaXB0U291cmNlID0gcmVxdWlyZSgnLi9nZXRDdXJyZW50U2NyaXB0U291cmNlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNvY2tldFVybChyZXNvdXJjZVF1ZXJ5KSB7XG4gIHZhciB1cmxQYXJ0cztcblxuICBpZiAodHlwZW9mIHJlc291cmNlUXVlcnkgPT09ICdzdHJpbmcnICYmIHJlc291cmNlUXVlcnkgIT09ICcnKSB7XG4gICAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHJlc291cmNlUXVlcnkuc3Vic3RyKDEpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuICAgIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICAgIHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgJycpO1xuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoIXVybFBhcnRzLnBvcnQgfHwgdXJsUGFydHMucG9ydCA9PT0gJzAnKSB7XG4gICAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbiAgfVxuXG4gIHZhciBfdXJsUGFydHMgPSB1cmxQYXJ0cyxcbiAgICAgIGF1dGggPSBfdXJsUGFydHMuYXV0aCxcbiAgICAgIHBhdGggPSBfdXJsUGFydHMucGF0aDtcbiAgdmFyIF91cmxQYXJ0czIgPSB1cmxQYXJ0cyxcbiAgICAgIGhvc3RuYW1lID0gX3VybFBhcnRzMi5ob3N0bmFtZSxcbiAgICAgIHByb3RvY29sID0gX3VybFBhcnRzMi5wcm90b2NvbDsgLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzM4NFxuXG4gIGlmICgoaG9zdG5hbWUgPT09ICcwLjAuMC4wJyB8fCBob3N0bmFtZSA9PT0gJzo6JykgJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAhIX5zZWxmLmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSkge1xuICAgIGhvc3RuYW1lID0gc2VsZi5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgfSAvLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4gIC8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcbiAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5cblxuICBpZiAoaG9zdG5hbWUgJiYgKHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XG4gICAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xuICB9IC8vIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBzb2NrIHVybCBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuXG4gIHZhciBzb2NrSG9zdCA9IGhvc3RuYW1lO1xuICB2YXIgc29ja1BhdGggPSAnL3NvY2tqcy1ub2RlJztcbiAgdmFyIHNvY2tQb3J0ID0gdXJsUGFydHMucG9ydDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuXG4gIGlmIChwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHVuZGVmaW5lZCAmJiBwYXRoICE9PSAnLycpIHtcbiAgICB2YXIgcGFyc2VkUXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZShwYXRoKTsgLy8gYWxsIG9mIHRoZXNlIHNvY2sgdXJsIHBhcmFtcyBhcmUgb3B0aW9uYWxseSBwYXNzZWQgaW4gdGhyb3VnaFxuICAgIC8vIHJlc291cmNlUXVlcnksIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmXG4gICAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cbiAgICBzb2NrSG9zdCA9IHBhcnNlZFF1ZXJ5LnNvY2tIb3N0IHx8IHNvY2tIb3N0O1xuICAgIHNvY2tQYXRoID0gcGFyc2VkUXVlcnkuc29ja1BhdGggfHwgc29ja1BhdGg7XG4gICAgc29ja1BvcnQgPSBwYXJzZWRRdWVyeS5zb2NrUG9ydCB8fCBzb2NrUG9ydDtcbiAgfVxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTb2NrZXRVcmw7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKSB7XG4gIC8vIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0YCBpcyB0aGUgbW9zdCBhY2N1cmF0ZSB3YXkgdG8gZmluZCB0aGUgY3VycmVudCBzY3JpcHQsXG4gIC8vIGJ1dCBpcyBub3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cbiAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhbGwgYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIGluIHRoZSBkb2N1bWVudC5cblxuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2U7IiwidmFyIG1hcCA9IHtcblx0XCIuL2xvZ1wiOiAzMVxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDMwOyIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzlfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MV9fOyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180OF9fOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogV2luZG93IG9iamVjdFxuICogQG1vZHVsZVxuICogQGlnbm9yZVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cbmNvbnN0IHdpbiA9ICgoKSA9PiB7XG5cdGNvbnN0IGRlZiA9IG8gPT4gdHlwZW9mIG8gIT09IFwidW5kZWZpbmVkXCIgJiYgbztcblxuXHRyZXR1cm4gZGVmKHNlbGYpIHx8IGRlZih3aW5kb3cpIHx8IGRlZihnbG9iYWwpIHx8IGRlZihnbG9iYWxUaGlzKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59KSgpO1xuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cblxuY29uc3QgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudFxuY29uc3QgaXNNb2JpbGUgPSAoXG5cdHdpbi5uYXZpZ2F0b3IgJiYgd2luLm5hdmlnYXRvci51c2VyQWdlbnQgJiZcblx0XHR3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaVwiKSA+IC0xXG4pIHx8IGZhbHNlO1xuXG5leHBvcnQge1xuXHR3aW4gYXMgd2luZG93LFxuXHRkb2MgYXMgZG9jdW1lbnQsXG5cdGlzTW9iaWxlXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181MF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTFfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzUyX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181M19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTRfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU1X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181Nl9fOyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2JpbGxib2FyZC5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2JpbGxib2FyZC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9iaWxsYm9hcmQuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyotLSBDaGFydCAtLSovXFxuLmJiIHN2ZyB7XFxuICBmb250OiAxMHB4IEdvdGhhbVBybztcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gIGZpbGw6ICM1RDVDNzE7IH1cXG5cXG4uYmIgcGF0aCwgLmJiIGxpbmUge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzAwMDsgfVxcblxcbi5iYiB0ZXh0LCAuYmIgLmJiLWJ1dHRvbiB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLXRpbGUsXFxuLmJiLXhncmlkLWZvY3VzLFxcbi5iYi15Z3JpZCxcXG4uYmItZXZlbnQtcmVjdCxcXG4uYmItYmFycyBwYXRoIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi5iYi1jaGFydC1hcmMgcGF0aCB7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHRleHQge1xcbiAgZmlsbDogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTNweDsgfVxcblxcbi8qLS0gQXhpcyAtLSovXFxuLmJiLWF4aXMge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLyotLSBHcmlkIC0tKi9cXG4uYmItZ3JpZCBsaW5lIHtcXG4gIHN0cm9rZTogI2FhYTsgfVxcblxcbi5iYi1ncmlkIHRleHQge1xcbiAgZmlsbDogI2FhYTsgfVxcblxcbi5iYi14Z3JpZCwgLmJiLXlncmlkIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDMgMzsgfVxcblxcbi8qLS0gVGV4dCBvbiBDaGFydCAtLSovXFxuLmJiLXRleHQuYmItZW1wdHkge1xcbiAgZmlsbDogIzgwODA4MDtcXG4gIGZvbnQtc2l6ZTogMmVtOyB9XFxuXFxuLyotLSBMaW5lIC0tKi9cXG4uYmItbGluZSB7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gUG9pbnQgLS0qL1xcbi5iYi1jaXJjbGUuX2V4cGFuZGVkXyB7XFxuICBzdHJva2Utd2lkdGg6IDFweDtcXG4gIHN0cm9rZTogd2hpdGU7IH1cXG5cXG4uYmItc2VsZWN0ZWQtY2lyY2xlIHtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4vKi0tIEJhciAtLSovXFxuLmJiLWJhciB7XFxuICBzdHJva2Utd2lkdGg6IDA7IH1cXG4gIC5iYi1iYXIuX2V4cGFuZGVkXyB7XFxuICAgIGZpbGwtb3BhY2l0eTogMC43NTsgfVxcblxcbi8qLS0gRm9jdXMgLS0qL1xcbi5iYi10YXJnZXQuYmItZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAxOyB9XFxuXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItbGluZSwgLmJiLXRhcmdldC5iYi1mb2N1c2VkIHBhdGguYmItc3RlcCB7XFxuICBzdHJva2Utd2lkdGg6IDJweDsgfVxcblxcbi5iYi10YXJnZXQuYmItZGVmb2N1c2VkIHtcXG4gIG9wYWNpdHk6IDAuMyAhaW1wb3J0YW50OyB9XFxuXFxuLyotLSBSZWdpb24gLS0qL1xcbi5iYi1yZWdpb24ge1xcbiAgZmlsbDogc3RlZWxibHVlO1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gWm9vbSByZWdpb24gLS0qL1xcbi5iYi16b29tLWJydXNoIHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIEJydXNoIC0tKi9cXG4uYmItYnJ1c2ggLmV4dGVudCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBTZWxlY3QgLSBEcmFnIC0tKi9cXG4vKi0tIExlZ2VuZCAtLSovXFxuLmJiLWxlZ2VuZC1pdGVtIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLWxlZ2VuZC1pdGVtLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwLjE1OyB9XFxuXFxuLmJiLWxlZ2VuZC1iYWNrZ3JvdW5kIHtcXG4gIG9wYWNpdHk6IDAuNzU7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZTogbGlnaHRncmF5O1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLyotLSBUaXRsZSAtLSovXFxuLmJiLXRpdGxlIHtcXG4gIGZvbnQ6IDE0cHggR290aGFtUHJvOyB9XFxuXFxuLyotLSBUb29sdGlwIC0tKi9cXG4uYmItdG9vbHRpcC1jb250YWluZXIge1xcbiAgei1pbmRleDogMTA7IH1cXG5cXG4uYmItdG9vbHRpcCB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgZW1wdHktY2VsbHM6IHNob3c7XFxuICBvcGFjaXR5OiAwLjk7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICAtbW96LWJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7XFxuICBib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3OyB9XFxuICAuYmItdG9vbHRpcCB0ciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNDQ0M7IH1cXG4gIC5iYi10b29sdGlwIHRoIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBwYWRkaW5nOiAycHggNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBjb2xvcjogI0ZGRjsgfVxcbiAgLmJiLXRvb2x0aXAgdGQge1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIHBhZGRpbmc6IDNweCA2cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZG90dGVkICM5OTk7IH1cXG4gICAgLmJiLXRvb2x0aXAgdGQgPiBzcGFuLCAuYmItdG9vbHRpcCB0ZCA+IHN2ZyB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiAxMHB4O1xcbiAgICAgIGhlaWdodDogMTBweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDZweDsgfVxcbiAgLmJiLXRvb2x0aXAudmFsdWUge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbi8qLS0gQXJlYSAtLSovXFxuLmJiLWFyZWEge1xcbiAgc3Ryb2tlLXdpZHRoOiAwO1xcbiAgb3BhY2l0eTogMC4yOyB9XFxuXFxuLyotLSBBcmMgLS0qL1xcbi5iYi1jaGFydC1hcmNzLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDEuM2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMi43ZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6ICNlMGUwZTA7XFxuICBzdHJva2U6IG5vbmU7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS11bml0IHtcXG4gIGZpbGw6ICMwMDA7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1tYXgge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1pbiB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyAuYmItZ2F1Z2UtdmFsdWUge1xcbiAgZmlsbDogIzAwMDsgfVxcblxcbi8qLS0gUmFkYXIgLS0qL1xcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyBwb2x5Z29uIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgdGV4dCB7XFxuICBmaWxsOiAjODQ4MjgyOyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyBsaW5lIHtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgdGV4dCB7XFxuICBmb250LXNpemU6IDEuMTVlbTtcXG4gIGN1cnNvcjogZGVmYXVsdDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLXNoYXBlcyBwb2x5Z29uIHtcXG4gIGZpbGwtb3BhY2l0eTogLjI7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gQnV0dG9uIC0tKi9cXG4uYmItYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTBweDtcXG4gIHJpZ2h0OiAxMHB4OyB9XFxuICAuYmItYnV0dG9uIC5iYi16b29tLXJlc2V0IHtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuaDIjdGl0bGUge1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgdGV4dC10cmFuc2Zvcm06IFxcXCJ1cHBlcmNhc2VcXFwiOyB9XFxuXCIsIFwiXCJdKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDU1MgY2xhc3MgbmFtZXMgZGVmaW5pdGlvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXHRhcmM6IFwiYmItYXJjXCIsXG5cdGFyY3M6IFwiYmItYXJjc1wiLFxuXHRhcmVhOiBcImJiLWFyZWFcIixcblx0YXJlYXM6IFwiYmItYXJlYXNcIixcblx0YXhpczogXCJiYi1heGlzXCIsXG5cdGF4aXNYOiBcImJiLWF4aXMteFwiLFxuXHRheGlzWExhYmVsOiBcImJiLWF4aXMteC1sYWJlbFwiLFxuXHRheGlzWTogXCJiYi1heGlzLXlcIixcblx0YXhpc1kyOiBcImJiLWF4aXMteTJcIixcblx0YXhpc1kyTGFiZWw6IFwiYmItYXhpcy15Mi1sYWJlbFwiLFxuXHRheGlzWUxhYmVsOiBcImJiLWF4aXMteS1sYWJlbFwiLFxuXHRiYXI6IFwiYmItYmFyXCIsXG5cdGJhcnM6IFwiYmItYmFyc1wiLFxuXHRicnVzaDogXCJiYi1icnVzaFwiLFxuXHRidXR0b246IFwiYmItYnV0dG9uXCIsXG5cdGJ1dHRvblpvb21SZXNldDogXCJiYi16b29tLXJlc2V0XCIsXG5cdGNoYXJ0OiBcImJiLWNoYXJ0XCIsXG5cdGNoYXJ0QXJjOiBcImJiLWNoYXJ0LWFyY1wiLFxuXHRjaGFydEFyY3M6IFwiYmItY2hhcnQtYXJjc1wiLFxuXHRjaGFydEFyY3NCYWNrZ3JvdW5kOiBcImJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZFwiLFxuXHRjaGFydEFyY3NHYXVnZU1heDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1heFwiLFxuXHRjaGFydEFyY3NHYXVnZU1pbjogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1pblwiLFxuXHRjaGFydEFyY3NHYXVnZVVuaXQ6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS11bml0XCIsXG5cdGNoYXJ0QXJjc1RpdGxlOiBcImJiLWNoYXJ0LWFyY3MtdGl0bGVcIixcblx0Y2hhcnRBcmNzR2F1Z2VUaXRsZTogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlXCIsXG5cdGNoYXJ0QmFyOiBcImJiLWNoYXJ0LWJhclwiLFxuXHRjaGFydEJhcnM6IFwiYmItY2hhcnQtYmFyc1wiLFxuXHRjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxuXHRjaGFydExpbmVzOiBcImJiLWNoYXJ0LWxpbmVzXCIsXG5cdGNoYXJ0UmFkYXI6IFwiYmItY2hhcnQtcmFkYXJcIixcblx0Y2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXG5cdGNoYXJ0VGV4dDogXCJiYi1jaGFydC10ZXh0XCIsXG5cdGNoYXJ0VGV4dHM6IFwiYmItY2hhcnQtdGV4dHNcIixcblx0Y2lyY2xlOiBcImJiLWNpcmNsZVwiLFxuXHRjaXJjbGVzOiBcImJiLWNpcmNsZXNcIixcblx0Y29sb3JQYXR0ZXJuOiBcImJiLWNvbG9yLXBhdHRlcm5cIixcblx0Y29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXG5cdGRlZm9jdXNlZDogXCJiYi1kZWZvY3VzZWRcIixcblx0ZHJhZ2FyZWE6IFwiYmItZHJhZ2FyZWFcIixcblx0ZW1wdHk6IFwiYmItZW1wdHlcIixcblx0ZXZlbnRSZWN0OiBcImJiLWV2ZW50LXJlY3RcIixcblx0ZXZlbnRSZWN0czogXCJiYi1ldmVudC1yZWN0c1wiLFxuXHRldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcblx0ZXZlbnRSZWN0c1NpbmdsZTogXCJiYi1ldmVudC1yZWN0cy1zaW5nbGVcIixcblx0Zm9jdXNlZDogXCJiYi1mb2N1c2VkXCIsXG5cdGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcblx0Z3JpZDogXCJiYi1ncmlkXCIsXG5cdGdyaWRMaW5lczogXCJiYi1ncmlkLWxpbmVzXCIsXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcblx0bGVnZW5kSXRlbTogXCJiYi1sZWdlbmQtaXRlbVwiLFxuXHRsZWdlbmRJdGVtRXZlbnQ6IFwiYmItbGVnZW5kLWl0ZW0tZXZlbnRcIixcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxuXHRsZWdlbmRJdGVtSGlkZGVuOiBcImJiLWxlZ2VuZC1pdGVtLWhpZGRlblwiLFxuXHRsZWdlbmRJdGVtUG9pbnQ6IFwiYmItbGVnZW5kLWl0ZW0tcG9pbnRcIixcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxuXHRsZXZlbDogXCJiYi1sZXZlbFwiLFxuXHRsZXZlbHM6IFwiYmItbGV2ZWxzXCIsXG5cdGxpbmU6IFwiYmItbGluZVwiLFxuXHRsaW5lczogXCJiYi1saW5lc1wiLFxuXHRyZWdpb246IFwiYmItcmVnaW9uXCIsXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxuXHRzZWxlY3RlZENpcmNsZTogXCJiYi1zZWxlY3RlZC1jaXJjbGVcIixcblx0c2VsZWN0ZWRDaXJjbGVzOiBcImJiLXNlbGVjdGVkLWNpcmNsZXNcIixcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcblx0c2hhcGVzOiBcImJiLXNoYXBlc1wiLFxuXHRzdGFuZm9yZEVsZW1lbnRzOiBcImJiLXN0YW5mb3JkLWVsZW1lbnRzXCIsXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXG5cdHN0YW5mb3JkTGluZXM6IFwiYmItc3RhbmZvcmQtbGluZXNcIixcblx0c3RhbmZvcmRSZWdpb246IFwiYmItc3RhbmZvcmQtcmVnaW9uXCIsXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXG5cdHRhcmdldDogXCJiYi10YXJnZXRcIixcblx0dGV4dDogXCJiYi10ZXh0XCIsXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXG5cdHRpdGxlOiBcImJiLXRpdGxlXCIsXG5cdHRvb2x0aXA6IFwiYmItdG9vbHRpcFwiLFxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXG5cdHRvb2x0aXBOYW1lOiBcImJiLXRvb2x0aXAtbmFtZVwiLFxuXHR4Z3JpZDogXCJiYi14Z3JpZFwiLFxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXG5cdHhncmlkTGluZTogXCJiYi14Z3JpZC1saW5lXCIsXG5cdHhncmlkTGluZXM6IFwiYmIteGdyaWQtbGluZXNcIixcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxuXHR5Z3JpZDogXCJiYi15Z3JpZFwiLFxuXHR5Z3JpZExpbmU6IFwiYmIteWdyaWQtbGluZVwiLFxuXHR5Z3JpZExpbmVzOiBcImJiLXlncmlkLWxpbmVzXCIsXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcblx0em9vbUJydXNoOiBcImJiLXpvb20tYnJ1c2hcIixcblx0em9vbVJlY3Q6IFwiYmItem9vbS1yZWN0XCIsXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcblx0U0VMRUNURUQ6IFwiX3NlbGVjdGVkX1wiLFxuXHRJTkNMVURFRDogXCJfaW5jbHVkZWRfXCJcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQGlnbm9yZVxuICovXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7YnJ1c2hTZWxlY3Rpb24gYXMgZDNCcnVzaFNlbGVjdGlvbn0gZnJvbSBcImQzLWJydXNoXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5cbmNvbnN0IGlzVmFsdWUgPSB2ID0+IHYgfHwgdiA9PT0gMDtcbmNvbnN0IGlzRnVuY3Rpb24gPSB2ID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9IHYgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc051bWJlciA9IHYgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG5jb25zdCBpc1VuZGVmaW5lZCA9IHYgPT4gdHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBpc0RlZmluZWQgPSB2ID0+IHR5cGVvZiB2ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgaXNCb29sZWFuID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7XG5jb25zdCBjZWlsMTAgPSB2ID0+IE1hdGguY2VpbCh2IC8gMTApICogMTA7XG5jb25zdCBhc0hhbGZQaXhlbCA9IG4gPT4gTWF0aC5jZWlsKG4pICsgMC41O1xuY29uc3QgZGlmZkRvbWFpbiA9IGQgPT4gZFsxXSAtIGRbMF07XG5jb25zdCBpc09iamVjdFR5cGUgPSB2ID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNFbXB0eSA9IG8gPT4gKFxuXHRpc1VuZGVmaW5lZChvKSB8fCBvID09PSBudWxsIHx8XG5cdChpc1N0cmluZyhvKSAmJiBvLmxlbmd0aCA9PT0gMCkgfHxcblx0KGlzT2JqZWN0VHlwZShvKSAmJiAhKG8gaW5zdGFuY2VvZiBEYXRlKSAmJiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDApIHx8XG5cdChpc051bWJlcihvKSAmJiBpc05hTihvKSlcbik7XG5jb25zdCBub3RFbXB0eSA9IG8gPT4gIWlzRW1wdHkobyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgaXMgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpc0FycmF5ID0gYXJyID0+IGFyciAmJiBhcnIuY29uc3RydWN0b3IgPT09IEFycmF5O1xuXG4vKipcbiAqIENoZWNrIGlmIGlzIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpc09iamVjdCA9IG9iaiA9PiBvYmogJiYgIW9iai5ub2RlVHlwZSAmJiBpc09iamVjdFR5cGUob2JqKSAmJiAhaXNBcnJheShvYmopO1xuXG5jb25zdCBnZXRPcHRpb24gPSAob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWUpID0+IChcblx0aXNEZWZpbmVkKG9wdGlvbnNba2V5XSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0VmFsdWVcbik7XG5cbmNvbnN0IGhhc1ZhbHVlID0gKGRpY3QsIHZhbHVlKSA9PiB7XG5cdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdE9iamVjdC5rZXlzKGRpY3QpLmZvckVhY2goa2V5ID0+IChkaWN0W2tleV0gPT09IHZhbHVlKSAmJiAoZm91bmQgPSB0cnVlKSk7XG5cblx0cmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBDYWxsIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAqIEBwYXJhbSB7Kn0gYXJncyBBcmd1bWVudHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWU6IGZuIGlzIGZ1bmN0aW9uLCBmYWxzZTogZm4gaXMgbm90IGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYWxsRm4gPSAoZm4sIC4uLmFyZ3MpID0+IHtcblx0Y29uc3QgaXNGbiA9IGlzRnVuY3Rpb24oZm4pO1xuXG5cdGlzRm4gJiYgZm4uY2FsbCguLi5hcmdzKTtcblx0cmV0dXJuIGlzRm47XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGFnIHNpZ24gdG8gaHRtbCBlbnRpdHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNhbml0aXNlID0gc3RyID0+IChpc1N0cmluZyhzdHIpID8gc3RyLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpIDogc3RyKTtcblxuLyoqXG4gKiBTZXQgdGV4dCB2YWx1ZS4gSWYgdGhlcmUncyBtdWx0aWxpbmUgYWRkIG5vZGVzLlxuICogQHBhcmFtIHtkM1NlbGVjdGlvbn0gbm9kZSBUZXh0IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgdmFsdWUgc3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBkeSBkeSB2YWx1ZSBmb3IgbXVsdGlsaW5lZCB0ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzZXRUZXh0VmFsdWUgPSAobm9kZSwgdGV4dCwgZHkgPSBbLTEsIDFdKSA9PiB7XG5cdGlmICghbm9kZSB8fCAhaXNTdHJpbmcodGV4dCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAodGV4dC5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkge1xuXHRcdG5vZGUudGV4dCh0ZXh0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBkaWZmID0gW25vZGUudGV4dCgpLCB0ZXh0XS5tYXAodiA9PiB2LnJlcGxhY2UoL1tcXHNcXG5dL2csIFwiXCIpKTtcblxuXHRcdGlmIChkaWZmWzBdICE9PSBkaWZmWzFdKSB7XG5cdFx0XHRjb25zdCBtdWx0aWxpbmUgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuXG5cdFx0XHQvLyByZXNldCBwb3NzaWJsZSB0ZXh0XG5cdFx0XHRub2RlLmh0bWwoXCJcIik7XG5cblx0XHRcdG11bHRpbGluZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kKFwidHNwYW5cIilcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIGAke2kgPT09IDAgPyBkeVswXSA6IGR5WzFdfWVtYClcblx0XHRcdFx0XHQudGV4dCh2KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufTtcblxuLy8gc3Vic3RpdHV0aW9uIG9mIFNWR1BhdGhTZWcgQVBJIHBvbHlmaWxsXG5jb25zdCBnZXRSZWN0U2VnTGlzdCA9IHBhdGggPT4ge1xuXHQvKlxuXHQgKiBzZWcxIC0tLS0tLS0tLS0gc2VnMlxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcblx0ICogICB8ICAgICAgICAgICAgICAgfFxuXHQgKiBzZWcwIC0tLS0tLS0tLS0gc2VnM1xuXHQgKiAqL1xuXHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJCb3goKTtcblxuXHRyZXR1cm4gW1xuXHRcdHt4LCB5OiB5ICsgaGVpZ2h0fSwgLy8gc2VnMFxuXHRcdHt4LCB5fSwgLy8gc2VnMVxuXHRcdHt4OiB4ICsgd2lkdGgsIHl9LCAvLyBzZWcyXG5cdFx0e3g6IHggKyB3aWR0aCwgeTogeSArIGhlaWdodH0gLy8gc2VnM1xuXHRdO1xufTtcblxuY29uc3QgZ2V0UGF0aEJveCA9IHBhdGggPT4ge1xuXHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRjb25zdCBpdGVtcyA9IGdldFJlY3RTZWdMaXN0KHBhdGgpO1xuXHRjb25zdCB4ID0gaXRlbXNbMF0ueDtcblx0Y29uc3QgeSA9IE1hdGgubWluKGl0ZW1zWzBdLnksIGl0ZW1zWzFdLnkpO1xuXG5cdHJldHVybiB7XG5cdFx0eCwgeSwgd2lkdGgsIGhlaWdodFxuXHR9O1xufTtcblxuLy8gcmV0dXJuIGJydXNoIHNlbGVjdGlvbiBhcnJheVxuY29uc3QgZ2V0QnJ1c2hTZWxlY3Rpb24gPSBjdHggPT4ge1xuXHRsZXQgc2VsZWN0aW9uID0gbnVsbDtcblx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xuXHRjb25zdCBtYWluID0gY3R4LmNvbnRleHQgfHwgY3R4Lm1haW47XG5cblx0Ly8gY2hlY2sgZnJvbSBldmVudFxuXHRpZiAoZXZlbnQgJiYgZXZlbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJCcnVzaEV2ZW50XCIpIHtcblx0XHRzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb247XG5cdC8vIGNoZWNrIGZyb20gYnJ1c2ggYXJlYSBzZWxlY3Rpb25cblx0fSBlbHNlIGlmIChtYWluICYmIChzZWxlY3Rpb24gPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkubm9kZSgpKSkge1xuXHRcdHNlbGVjdGlvbiA9IGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblx0fVxuXG5cdHJldHVybiBzZWxlY3Rpb247XG59O1xuXG4vLyByZXRydW4gcmFuZG9tIG51bWJlclxuY29uc3QgZ2V0UmFuZG9tID0gKGFzU3RyID0gdHJ1ZSkgPT4gTWF0aC5yYW5kb20oKSArIChhc1N0ciA/IFwiXCIgOiAwKTtcblxuY29uc3QgYnJ1c2hFbXB0eSA9IGN0eCA9PiB7XG5cdGNvbnN0IHNlbGVjdGlvbiA9IGdldEJydXNoU2VsZWN0aW9uKGN0eCk7XG5cblx0aWYgKHNlbGVjdGlvbikge1xuXHRcdC8vIGJydXNoIHNlbGVjdGVkIGFyZWFcblx0XHQvLyB0d28tZGltZW5zaW9uYWw6IFtbeDAsIHkwXSwgW3gxLCB5MV1dXG5cdFx0Ly8gb25lLWRpbWVuc2lvbmFsOiBbeDAsIHgxXSBvciBbeTAsIHkxXVxuXHRcdHJldHVybiBzZWxlY3Rpb25bMF0gPT09IHNlbGVjdGlvblsxXTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZXh0ZW5kID0gKHRhcmdldCA9IHt9LCBzb3VyY2UpID0+IHtcblx0Zm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuXHRcdHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBmaXJzdCBsZXR0ZXIgY2FwaXRhbGl6ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ30gY2FwaXRhbGl6ZWQgc3RyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYXBpdGFsaXplID0gc3RyID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gdlxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdG9BcnJheSA9IHYgPT4gW10uc2xpY2UuY2FsbCh2KTtcblxuLyoqXG4gKiBHZXQgY3NzIHJ1bGVzIGZvciBzcGVjaWZpZWQgc3R5bGVzaGVldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlU2hlZXRzIFRoZSBzdHlsZXNoZWV0cyB0byBnZXQgdGhlIHJ1bGVzIGZyb21cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldENzc1J1bGVzID0gc3R5bGVTaGVldHMgPT4ge1xuXHRsZXQgcnVsZXMgPSBbXTtcblxuXHRzdHlsZVNoZWV0cy5mb3JFYWNoKHNoZWV0ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHNoZWV0LmNzc1J1bGVzICYmIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCkge1xuXHRcdFx0XHRydWxlcyA9IHJ1bGVzLmNvbmNhdCh0b0FycmF5KHNoZWV0LmNzc1J1bGVzKSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcmVhZGluZyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn06ICR7ZS50b1N0cmluZygpfWApO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHJ1bGVzO1xufTtcblxuLyoqXG4gKiBHZXQgdW5pcXVlIHZhbHVlIGZyb20gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSBVbmlxdWUgYXJyYXkgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldFVuaXF1ZSA9IGRhdGEgPT4gZGF0YS5maWx0ZXIoKHYsIGksIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2KSA9PT0gaSk7XG5cbi8qKlxuICogTWVyZ2UgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtZXJnZUFycmF5ID0gYXJyID0+IChhcnIgJiYgYXJyLmxlbmd0aCA/IGFyci5yZWR1Y2UoKHAsIGMpID0+IHAuY29uY2F0KGMpKSA6IFtdKTtcblxuLyoqXG4gKiBNZXJnZSBvYmplY3QgcmV0dXJuaW5nIG5ldyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3ROXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBtZXJnZWQgdGFyZ2V0IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbWVyZ2VPYmogPSAodGFyZ2V0LCAuLi5vYmplY3ROKSA9PiB7XG5cdGlmICghb2JqZWN0Ti5sZW5ndGggfHwgKG9iamVjdE4ubGVuZ3RoID09PSAxICYmICFvYmplY3ROWzBdKSkge1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHRjb25zdCBzb3VyY2UgPSBvYmplY3ROLnNoaWZ0KCk7XG5cblx0aWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuXHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0XHQhdGFyZ2V0W2tleV0gJiYgKHRhcmdldFtrZXldID0ge30pO1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlT2JqKHRhcmdldFtrZXldLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGlzQXJyYXkodmFsdWUpID9cblx0XHRcdFx0XHR2YWx1ZS5jb25jYXQoKSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlT2JqKHRhcmdldCwgLi4ub2JqZWN0Tik7XG59O1xuXG4vKipcbiAqIFNvcnQgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgdmFsdWUgdG8gYmUgc29ydGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQXNjIHRydWU6IGFzYywgZmFsc2U6IGRlc2NcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd8RGF0ZX0gc29ydGVkIGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNvcnRWYWx1ZSA9IChkYXRhLCBpc0FzYyA9IHRydWUpID0+IHtcblx0bGV0IGZuO1xuXG5cdGlmIChkYXRhWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdGZuID0gaXNBc2MgPyAoYSwgYikgPT4gYSAtIGIgOiAoYSwgYikgPT4gYiAtIGE7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGlzQXNjICYmIGRhdGEuZXZlcnkoTnVtYmVyKSkge1xuXHRcdFx0Zm4gPSAoYSwgYikgPT4gYSAtIGI7XG5cdFx0fSBlbHNlIGlmICghaXNBc2MpIHtcblx0XHRcdGZuID0gKGEsIGIpID0+IChhID4gYiAmJiAtMSkgfHwgKGEgPCBiICYmIDEpIHx8IChhID09PSBiICYmIDApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkYXRhLmNvbmNhdCgpLnNvcnQoZm4pO1xufTtcblxuLyoqXG4gKiBHZXQgbWluL21heCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgJ21pbicgb3IgJ21heCdcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQXJyYXkgZGF0YSB2YWx1ZVxuICogQHJldHVuIHtOdW1iZXJ8RGF0ZXx1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRNaW5NYXggPSAodHlwZSwgZGF0YSkgPT4ge1xuXHRsZXQgcmVzID0gZGF0YS5maWx0ZXIodiA9PiBub3RFbXB0eSh2KSk7XG5cblx0aWYgKHJlcy5sZW5ndGgpIHtcblx0XHRpZiAoaXNOdW1iZXIocmVzWzBdKSkge1xuXHRcdFx0cmVzID0gTWF0aFt0eXBlXSguLi5yZXMpO1xuXHRcdH0gZWxzZSBpZiAocmVzWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0cmVzID0gc29ydFZhbHVlKHJlcywgdHlwZSA9PT0gXCJtaW5cIilbMF07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlcyA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEdldCByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IG51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgbnVtYmVyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldFJhbmdlID0gKHN0YXJ0LCBlbmQpID0+IHtcblx0Y29uc3QgcmVzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRyZXMucHVzaChpKTtcblx0fVxuXG5cdHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFNlbmQgc3RhdHNcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNlbmRTdGF0cyA9ICgpID0+IHtcblx0aWYgKG5hdmlnYXRvciAmJiBsb2NhbFN0b3JhZ2UpIHtcblx0XHRjb25zdCBrZXkgPSBcIiRiYi5zdGF0c1wiO1xuXHRcdGNvbnN0IHVybCA9IGBodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0P3Y9MSZ0aWQ9VUEtMTQxOTExNTgyLTEmY2lkPTU1NSZ0PXBhZ2V2aWV3JmRwPSUyRiR7bG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6IFwiXCJ9YDtcblx0XHRjb25zdCB0ID0gK25ldyBEYXRlKCk7XG5cdFx0Y29uc3QgbGFzdCA9ICtsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdGNvbnN0IGV4cGlyZSA9IDEwMDAgKiA2MCAqIDYwICogMjQgKiAxNDtcblxuXHRcdGlmICghbGFzdCB8fCAobGFzdCArIGV4cGlyZSkgPCB0KSB7XG5cdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHQgKyBleHBpcmUpO1xuXG5cdFx0XHRpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24pIHtcblx0XHRcdFx0bmF2aWdhdG9yLnNlbmRCZWFjb24odXJsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGkgPSBuZXcgSW1hZ2UoKTtcblxuXHRcdFx0XHRpLnNyYyA9IHVybDtcblx0XHRcdFx0aS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpKTtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIGVtdWxhdGUgZXZlbnRcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcblx0bW91c2U6ICgoKSA9PiB7XG5cdFx0Y29uc3QgZ2V0UGFyYW1zID0gKCkgPT4gKHtcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxuXHRcdH0pO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblx0XHRcdG5ldyBNb3VzZUV2ZW50KFwidFwiKTtcblxuXHRcdFx0cmV0dXJuIChlbCwgZXZlbnRUeXBlLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zKSk7XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIFBvbHlmaWxscyBET000IE1vdXNlRXZlbnRcblx0XHRcdHJldHVybiAoZWwsIGV2ZW50VHlwZSwgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcblx0XHRcdFx0Y29uc3QgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcblxuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9pbml0TW91c2VFdmVudFxuXHRcdFx0XHRtb3VzZUV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0XHRwYXJhbXMuYnViYmxlcyxcblx0XHRcdFx0XHRwYXJhbXMuY2FuY2VsYWJsZSxcblx0XHRcdFx0XHR3aW5kb3csXG5cdFx0XHRcdFx0MCwgLy8gdGhlIGV2ZW50J3MgbW91c2UgY2xpY2sgY291bnRcblx0XHRcdFx0XHRwYXJhbXMuc2NyZWVuWCwgcGFyYW1zLnNjcmVlblksXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChtb3VzZUV2ZW50KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9KSgpLFxuXHR0b3VjaDogKGVsLCBldmVudFR5cGUsIHBhcmFtcykgPT4ge1xuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0aWRlbnRpZmllcjogRGF0ZS5ub3coKSxcblx0XHRcdHRhcmdldDogZWwsXG5cdFx0XHRyYWRpdXNYOiAyLjUsXG5cdFx0XHRyYWRpdXNZOiAyLjUsXG5cdFx0XHRyb3RhdGlvbkFuZ2xlOiAxMCxcblx0XHRcdGZvcmNlOiAwLjVcblx0XHR9LCBwYXJhbXMpKTtcblxuXHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IFRvdWNoRXZlbnQoZXZlbnRUeXBlLCB7XG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRcdFx0YnViYmxlczogdHJ1ZSxcblx0XHRcdHNoaWZ0S2V5OiB0cnVlLFxuXHRcdFx0dG91Y2hlczogW3RvdWNoT2JqXSxcblx0XHRcdHRhcmdldFRvdWNoZXM6IFtdLFxuXHRcdFx0Y2hhbmdlZFRvdWNoZXM6IFt0b3VjaE9ial1cblx0XHR9KSk7XG5cdH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgICYgcmV0dXJuIGJvdW5kIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHRwbCBUZW1wbGF0ZSBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgdmFsdWUgdG8gYmUgcmVwbGFjZWRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRwbFByb2Nlc3MgPSAodHBsLCBkYXRhKSA9PiB7XG5cdGxldCByZXMgPSB0cGw7XG5cblx0Zm9yIChjb25zdCB4IGluIGRhdGEpIHtcblx0XHRyZXMgPSByZXMucmVwbGFjZShuZXcgUmVnRXhwKGB7PSR7eH19YCwgXCJnXCIpLCBkYXRhW3hdKTtcblx0fVxuXG5cdHJldHVybiByZXM7XG59O1xuXG5leHBvcnQge1xuXHRhc0hhbGZQaXhlbCxcblx0YnJ1c2hFbXB0eSxcblx0Y2FsbEZuLFxuXHRjYXBpdGFsaXplLFxuXHRjZWlsMTAsXG5cdGRpZmZEb21haW4sXG5cdGVtdWxhdGVFdmVudCxcblx0ZXh0ZW5kLFxuXHRnZXRCcnVzaFNlbGVjdGlvbixcblx0Z2V0Q3NzUnVsZXMsXG5cdGdldE1pbk1heCxcblx0Z2V0T3B0aW9uLFxuXHRnZXRQYXRoQm94LFxuXHRnZXRSYW5kb20sXG5cdGdldFJhbmdlLFxuXHRnZXRSZWN0U2VnTGlzdCxcblx0Z2V0VW5pcXVlLFxuXHRoYXNWYWx1ZSxcblx0aXNBcnJheSxcblx0aXNCb29sZWFuLFxuXHRpc0RlZmluZWQsXG5cdGlzRW1wdHksXG5cdGlzRnVuY3Rpb24sXG5cdGlzTnVtYmVyLFxuXHRpc09iamVjdCxcblx0aXNPYmplY3RUeXBlLFxuXHRpc1N0cmluZyxcblx0aXNVbmRlZmluZWQsXG5cdGlzVmFsdWUsXG5cdG1lcmdlQXJyYXksXG5cdG1lcmdlT2JqLFxuXHRub3RFbXB0eSxcblx0c2FuaXRpc2UsXG5cdHNlbmRTdGF0cyxcblx0c2V0VGV4dFZhbHVlLFxuXHRzb3J0VmFsdWUsXG5cdHRvQXJyYXksXG5cdHRwbFByb2Nlc3Ncbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQGlnbm9yZVxuICovXG5pbXBvcnQge3NjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJ9IGZyb20gXCJkMy1zY2FsZVwiO1xuaW1wb3J0IHtpc0RlZmluZWQsIGlzTnVtYmVyLCBpc1N0cmluZ30gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlckhlbHBlciB7XG5cdGNvbnN0cnVjdG9yKGNvbmZpZywgcGFyYW1zKSB7XG5cdFx0Y29uc3Qgc2NhbGUgPSBkM1NjYWxlTGluZWFyKCk7XG5cblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcblx0XHR0aGlzLnNjYWxlID0gc2NhbGU7XG5cblx0XHRpZiAoY29uZmlnLm5vVHJhbnNpdGlvbiB8fCAhcGFyYW1zLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKSB7XG5cdFx0XHRjb25maWcud2l0aG91dFRyYW5zaXRpb24gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIHNldCByYW5nZVxuXHRcdGNvbmZpZy5yYW5nZSA9IHNjYWxlLnJhbmdlRXh0ZW50ID9cblx0XHRcdHNjYWxlLnJhbmdlRXh0ZW50KCkgOlxuXHRcdFx0dGhpcy5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZSBhIGNoYXJhY3RlciBkaW1lbnNpb25cblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IG5vZGVcblx0ICogQHJldHVybiB7e3c6IG51bWJlciwgaDogbnVtYmVyfX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHN0YXRpYyBnZXRTaXplRm9yMUNoYXIobm9kZSkge1xuXHRcdC8vIGRlZmF1bHQgc2l6ZSBmb3Igb25lIGNoYXJhY3RlclxuXHRcdGNvbnN0IHNpemUgPSB7XG5cdFx0XHR3OiA1LjUsXG5cdFx0XHRoOiAxMS41XG5cdFx0fTtcblxuXHRcdCFub2RlLmVtcHR5KCkgJiYgbm9kZS5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQudGV4dChcIjBcIilcblx0XHRcdC5jYWxsKGVsID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbC5ub2RlKCkuZ2V0QkJveCgpO1xuXG5cdFx0XHRcdFx0aWYgKHdpZHRoICYmIGhlaWdodCkge1xuXHRcdFx0XHRcdFx0c2l6ZS53ID0gd2lkdGg7XG5cdFx0XHRcdFx0XHRzaXplLmggPSBoZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWwudGV4dChcIlwiKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5nZXRTaXplRm9yMUNoYXIgPSAoKSA9PiBzaXplO1xuXG5cdFx0cmV0dXJuIHNpemU7XG5cdH1cblxuXHRheGlzWChzZWxlY3Rpb24sIHgpIHtcblx0XHRzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IGB0cmFuc2xhdGUoJHtNYXRoLmNlaWwoeChkKSArIHRoaXMuY29uZmlnLnRpY2tPZmZzZXQpfSwwKWApO1xuXHR9XG5cblx0YXhpc1koc2VsZWN0aW9uLCB5KSB7XG5cdFx0c2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKDAsJHtNYXRoLmNlaWwoeShkKSl9KWApO1xuXHR9XG5cblx0c2NhbGVFeHRlbnQoZG9tYWluKSB7XG5cdFx0Y29uc3Qgc3RhcnQgPSBkb21haW5bMF07XG5cdFx0Y29uc3Qgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG5cblx0XHRyZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG5cdH1cblxuXHRnZW5lcmF0ZVRpY2tzKHNjYWxlKSB7XG5cdFx0Y29uc3QgdGlja3MgPSBbXTtcblxuXHRcdGlmIChzY2FsZS50aWNrcykge1xuXHRcdFx0cmV0dXJuIHNjYWxlLnRpY2tzKFxuXHRcdFx0XHQuLi4odGhpcy5jb25maWcudGlja0FyZ3VtZW50cyB8fCBbXSlcblx0XHRcdCkubWFwKHYgPT4gKFxuXHRcdFx0XHQvLyByb3VuZCB0aGUgdGljayB2YWx1ZSBpZiBpcyBudW1iZXJcblx0XHRcdFx0KGlzU3RyaW5nKHYpICYmIGlzTnVtYmVyKHYpICYmICFpc05hTih2KSAmJlxuXHRcdFx0XHRcdE1hdGgucm91bmQodiAqIDEwKSAvIDEwXG5cdFx0XHRcdCkgfHwgdlxuXHRcdFx0KSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG5cblx0XHRmb3IgKGxldCBpID0gTWF0aC5jZWlsKGRvbWFpblswXSk7IGkgPCBkb21haW5bMV07IGkrKykge1xuXHRcdFx0dGlja3MucHVzaChpKTtcblx0XHR9XG5cblx0XHRpZiAodGlja3MubGVuZ3RoID4gMCAmJiB0aWNrc1swXSA+IDApIHtcblx0XHRcdHRpY2tzLnVuc2hpZnQodGlja3NbMF0gLSAodGlja3NbMV0gLSB0aWNrc1swXSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrcztcblx0fVxuXG5cdGNvcHlTY2FsZSgpIHtcblx0XHRjb25zdCBuZXdTY2FsZSA9IHRoaXMuc2NhbGUuY29weSgpO1xuXG5cdFx0aWYgKCFuZXdTY2FsZS5kb21haW4oKS5sZW5ndGgpIHtcblx0XHRcdG5ld1NjYWxlLmRvbWFpbih0aGlzLnNjYWxlLmRvbWFpbigpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3U2NhbGU7XG5cdH1cblxuXHR0ZXh0Rm9ybWF0dGVkKHYpIHtcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gdGhpcy5jb25maWcudGlja0Zvcm1hdDtcblxuXHRcdC8vIHRvIHJvdW5kIGZsb2F0IG51bWJlcnMgZnJvbSAnYmluYXJ5IGZsb2F0aW5nIHBvaW50J1xuXHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJsZS1wcmVjaXNpb25fZmxvYXRpbmctcG9pbnRfZm9ybWF0XG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDkxMDEvbGF5bWFucy1leHBsYW5hdGlvbi1mb3Itd2h5LWphdmFzY3JpcHQtaGFzLXdlaXJkLWZsb2F0aW5nLW1hdGgtaWVlZS03NTQtc3RhbmRcblx0XHRjb25zdCB2YWx1ZSA9IC9cXGQrXFwuXFxkKzB7NSx9XFxkJC8udGVzdCh2KSA/ICtTdHJpbmcodikucmVwbGFjZSgvMCtcXGQkLywgXCJcIikgOiB2O1xuXHRcdGNvbnN0IGZvcm1hdHRlZCA9IHRpY2tGb3JtYXQgPyB0aWNrRm9ybWF0KHZhbHVlKSA6IHZhbHVlO1xuXG5cdFx0cmV0dXJuIGlzRGVmaW5lZChmb3JtYXR0ZWQpID8gZm9ybWF0dGVkIDogXCJcIjtcblx0fVxuXG5cdHRyYW5zaXRpb25pc2Uoc2VsZWN0aW9uKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRyZXR1cm4gY29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID9cblx0XHRcdHNlbGVjdGlvbi5pbnRlcnJ1cHQoKSA6IHNlbGVjdGlvbi50cmFuc2l0aW9uKGNvbmZpZy50cmFuc2l0aW9uKTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIEBpZ25vcmVcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBIZWxwZXIgZnJvbSBcIi4vQXhpc1JlbmRlcmVySGVscGVyXCI7XG5pbXBvcnQge2lzQXJyYXksIHRvQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlcn0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlciB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG5cdFx0Y29uc3QgY29uZmlnID0ge1xuXHRcdFx0aW5uZXJUaWNrU2l6ZTogNixcblx0XHRcdG91dGVyVGlja1NpemU6IHBhcmFtcy5vdXRlclRpY2sgPyA2IDogMCxcblx0XHRcdG9yaWVudDogXCJib3R0b21cIixcblx0XHRcdHJhbmdlOiBbXSxcblx0XHRcdHRpY2tBcmd1bWVudHM6IG51bGwsXG5cdFx0XHR0aWNrQ2VudGVyZWQ6IG51bGwsXG5cdFx0XHR0aWNrQ3VsbGluZzogdHJ1ZSxcblx0XHRcdHRpY2tGb3JtYXQ6IG51bGwsXG5cdFx0XHR0aWNrTGVuZ3RoOiA5LFxuXHRcdFx0dGlja09mZnNldDogMCxcblx0XHRcdHRpY2tQYWRkaW5nOiAzLFxuXHRcdFx0dGlja1ZhbHVlczogbnVsbCxcblx0XHRcdHRyYW5zaXRpb246IG51bGwsXG5cdFx0XHRub1RyYW5zaXRpb246IHBhcmFtcy5ub1RyYW5zaXRpb25cblx0XHR9O1xuXG5cdFx0Y29uZmlnLnRpY2tMZW5ndGggPSBNYXRoLm1heChjb25maWcuaW5uZXJUaWNrU2l6ZSwgMCkgKyBjb25maWcudGlja1BhZGRpbmc7XG5cblx0XHR0aGlzLmhlbHBlciA9IG5ldyBIZWxwZXIoY29uZmlnLCBwYXJhbXMpO1xuXHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBheGlzIGVsZW1lbnRcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNyZWF0ZShnKSB7XG5cdFx0Y29uc3QgY3R4ID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0XHRjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcblx0XHRjb25zdCBoZWxwZXJJbnN0ID0gdGhpcy5oZWxwZXI7XG5cdFx0Y29uc3Qgc2NhbGUgPSBoZWxwZXJJbnN0LnNjYWxlO1xuXHRcdGNvbnN0IG9yaWVudCA9IGNvbmZpZy5vcmllbnQ7XG5cdFx0Y29uc3Qgc3BsaXRUaWNrVGV4dCA9IHRoaXMuc3BsaXRUaWNrVGV4dC5iaW5kKHRoaXMpO1xuXG5cdFx0Y29uc3QgaXNMZWZ0UmlnaHQgPSAvXihsZWZ0fHJpZ2h0KSQvLnRlc3Qob3JpZW50KTtcblx0XHRjb25zdCBpc1RvcEJvdHRvbSA9IC9eKHRvcHxib3R0b20pJC8udGVzdChvcmllbnQpO1xuXG5cdFx0Ly8gbGluZS90ZXh0IGVudGVyIGFuZCBwYXRoIHVwZGF0ZVxuXHRcdGNvbnN0IHRpY2tUcmFuc2Zvcm0gPSBoZWxwZXJJbnN0W2lzVG9wQm90dG9tID8gXCJheGlzWFwiIDogXCJheGlzWVwiXTtcblx0XHRjb25zdCBheGlzUHggPSB0aWNrVHJhbnNmb3JtID09PSBoZWxwZXJJbnN0LmF4aXNYID8gXCJ5XCIgOiBcInhcIjtcblx0XHRjb25zdCBzaWduID0gL14odG9wfGxlZnQpJC8udGVzdChvcmllbnQpID8gLTEgOiAxO1xuXG5cdFx0Ly8gdGljayB0ZXh0IGhlbHBlcnNcblx0XHRjb25zdCByb3RhdGUgPSBwYXJhbXMudGlja1RleHRSb3RhdGU7XG5cblx0XHR0aGlzLmNvbmZpZy5yYW5nZSA9IHNjYWxlLnJhbmdlRXh0ZW50ID9cblx0XHRcdHNjYWxlLnJhbmdlRXh0ZW50KCkgOlxuXHRcdFx0aGVscGVySW5zdC5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XG5cblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgdGlja0xlbmd0aCwgcmFuZ2V9ID0gY29uZmlnO1xuXG5cdFx0Ly8gLy8gZ2V0IHRoZSBheGlzJyB0aWNrIHBvc2l0aW9uIGNvbmZpZ3VyYXRpb25cblx0XHRjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG5cdFx0Y29uc3QgdGlja1RleHRQb3MgPSBuYW1lICYmIC9eKHh8eXx5MikkLy50ZXN0KG5hbWUpID9cblx0XHRcdHBhcmFtcy5jb25maWdbYGF4aXNfJHtuYW1lfV90aWNrX3RleHRfcG9zaXRpb25gXSA6IHt4OiAwLCB5OiAwfTtcblxuXHRcdC8vIHRpY2sgdmlzaWJsaXR5XG5cdFx0Y29uc3QgcHJlZml4ID0gbmFtZSA9PT0gXCJzdWJYXCIgPyBgc3ViY2hhcnRfYXhpc194YCA6IGBheGlzXyR7bmFtZX1gO1xuXHRcdGNvbnN0IGF4aXNTaG93ID0gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3Nob3dgXTtcblx0XHRjb25zdCB0aWNrU2hvdyA9IHtcblx0XHRcdHRpY2s6IGF4aXNTaG93ID8gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3RpY2tfc2hvd2BdIDogZmFsc2UsXG5cdFx0XHR0ZXh0OiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3RleHRfc2hvd2BdIDogZmFsc2Vcblx0XHR9O1xuXG5cdFx0bGV0ICRnID0gbnVsbDtcblxuXHRcdGcuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdGxldCBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZTtcblx0XHRcdGxldCBzY2FsZTEgPSBoZWxwZXJJbnN0LmNvcHlTY2FsZSgpO1xuXG5cdFx0XHQkZyA9IGc7XG5cdFx0XHR0aGlzLl9fY2hhcnRfXyA9IHNjYWxlMTtcblxuXHRcdFx0Y29uZmlnLnRpY2tPZmZzZXQgPSBwYXJhbXMuaXNDYXRlZ29yeSA/XG5cdFx0XHRcdE1hdGguY2VpbCgoc2NhbGUxKDEpIC0gc2NhbGUxKDApKSAvIDIpIDogMDtcblxuXHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvbiAtIGRhdGEgam9pblxuXHRcdFx0Y29uc3QgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFswXSk7XG5cblx0XHRcdC8vIGVudGVyICsgdXBkYXRlIHNlbGVjdGlvblxuXHRcdFx0cGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKVxuXHRcdFx0XHQubWVyZ2UoaGVscGVySW5zdC50cmFuc2l0aW9uaXNlKHBhdGgpKVxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG91dGVyVGlja1NpemVkID0gY29uZmlnLm91dGVyVGlja1NpemUgKiBzaWduO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGlzVG9wQm90dG9tID9cblx0XHRcdFx0XHRcdGBNJHtyYW5nZVswXX0sJHtvdXRlclRpY2tTaXplZH1WMEgke3JhbmdlWzFdfVYke291dGVyVGlja1NpemVkfWAgOlxuXHRcdFx0XHRcdFx0YE0ke291dGVyVGlja1NpemVkfSwke3JhbmdlWzBdfUgwViR7cmFuZ2VbMV19SCR7b3V0ZXJUaWNrU2l6ZWR9YDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aWNrU2hvdy50aWNrIHx8IHRpY2tTaG93LnRleHQpIHtcblx0XHRcdFx0Ly8gY291bnQgb2YgdGljayBkYXRhIGluIGFycmF5XG5cdFx0XHRcdGNvbnN0IHRpY2tzID0gY29uZmlnLnRpY2tWYWx1ZXMgfHwgaGVscGVySW5zdC5nZW5lcmF0ZVRpY2tzKHNjYWxlMSk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvblxuXHRcdFx0XHRsZXQgdGljayA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIilcblx0XHRcdFx0XHQuZGF0YSh0aWNrcywgc2NhbGUxKTtcblxuXHRcdFx0XHQvLyBlbnRlciBzZWxlY3Rpb25cblx0XHRcdFx0Y29uc3QgdGlja0VudGVyID0gdGlja1xuXHRcdFx0XHRcdC5lbnRlcigpXG5cdFx0XHRcdFx0Lmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIilcblx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblxuXHRcdFx0XHQvLyBNRU1POiBObyBleGl0IHRyYW5zaXRpb24uIFRoZSByZWFzb24gaXMgdGhpcyB0cmFuc2l0aW9uIGFmZmVjdHMgbWF4IHRpY2sgd2lkdGggY2FsY3VsYXRpb24gYmVjYXVzZSBvbGQgdGljayB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB0aWNrcy5cblx0XHRcdFx0Y29uc3QgdGlja0V4aXQgPSB0aWNrLmV4aXQoKS5yZW1vdmUoKTtcblxuXHRcdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cblx0XHRcdFx0dGljayA9IHRpY2tFbnRlci5tZXJnZSh0aWNrKTtcblxuXHRcdFx0XHR0aWNrU2hvdy50aWNrICYmIHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xuXHRcdFx0XHR0aWNrU2hvdy50ZXh0ICYmIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuXG5cdFx0XHRcdGNvbnN0IHNpemVGb3IxQ2hhciA9IEhlbHBlci5nZXRTaXplRm9yMUNoYXIodGljayk7XG5cdFx0XHRcdGNvbnN0IGNvdW50cyA9IFtdO1xuXG5cdFx0XHRcdGxldCB0c3BhbiA9IHRpY2suc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJ0c3BhblwiKVxuXHRcdFx0XHRcdC5kYXRhKChkLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXQgPSBwYXJhbXMudGlja011bHRpbGluZSA/XG5cdFx0XHRcdFx0XHRcdHNwbGl0VGlja1RleHQoZCwgc2NhbGUxLCB0aWNrcywgaXNMZWZ0UmlnaHQsIHNpemVGb3IxQ2hhci53KSA6IChcblx0XHRcdFx0XHRcdFx0XHRpc0FycmF5KGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKSkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0aGVscGVySW5zdC50ZXh0Rm9ybWF0dGVkKGQpLmNvbmNhdCgpIDogW2hlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKV1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Y291bnRzW2luZGV4XSA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHNwbGl0Lm1hcChzcGxpdHRlZCA9PiAoe2luZGV4LCBzcGxpdHRlZH0pKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0c3Bhbi5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0dHNwYW4gPSB0c3BhblxuXHRcdFx0XHRcdC5lbnRlcigpXG5cdFx0XHRcdFx0LmFwcGVuZChcInRzcGFuXCIpXG5cdFx0XHRcdFx0Lm1lcmdlKHRzcGFuKVxuXHRcdFx0XHRcdC50ZXh0KGQgPT4gZC5zcGxpdHRlZCk7XG5cblx0XHRcdFx0Ly8gc2V0IDx0c3Bhbj4ncyBwb3NpdGlvblxuXHRcdFx0XHR0c3BhblxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBpc1RvcEJvdHRvbSA/IDAgOiB0aWNrTGVuZ3RoICogc2lnbilcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsICgoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgZHggPSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAob3JpZW50ID09PSBcImJvdHRvbVwiICYmIHJvdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRkeCA9IDggKiBNYXRoLnNpbihNYXRoLlBJICogKHJvdGF0ZSAvIDE4MCkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZHggKyAodGlja1RleHRQb3MueCB8fCAwKTtcblx0XHRcdFx0XHR9KSgpKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgKGQsIGkpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlZlZhbHVlID0gXCIuNzFlbVwiO1xuXHRcdFx0XHRcdFx0bGV0IGR5ID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9yaWVudCAhPT0gXCJ0b3BcIikge1xuXHRcdFx0XHRcdFx0XHRkeSA9IHNpemVGb3IxQ2hhci5oO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZHkgPSBpc0xlZnRSaWdodCA/IC0oKGNvdW50c1tkLmluZGV4XSAtIDEpICogKHNpemVGb3IxQ2hhci5oIC8gMikgLSAzKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHQodGlja1RleHRQb3MueSA9PT0gMCA/IGRlZlZhbHVlIDogMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGlzTnVtYmVyKGR5KSAmJiB0aWNrVGV4dFBvcy55ID9cblx0XHRcdFx0XHRcdFx0ZHkgKyB0aWNrVGV4dFBvcy55IDogZHkgfHwgZGVmVmFsdWU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKTtcblx0XHRcdFx0Y29uc3QgdGV4dFVwZGF0ZSA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcblxuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKS5hdHRyKGAke2F4aXNQeH0yYCwgaW5uZXJUaWNrU2l6ZSAqIHNpZ24pO1xuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKS5hdHRyKGAke2F4aXNQeH1gLCB0aWNrTGVuZ3RoICogc2lnbik7XG5cblx0XHRcdFx0Y3R4LnNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpO1xuXG5cdFx0XHRcdC8vIEFwcGVuZCA8dGl0bGU+IGZvciB0b29sdGlwIGRpc3BsYXlcblx0XHRcdFx0cGFyYW1zLnRpY2tUaXRsZSAmJiB0ZXh0VXBkYXRlLmFwcGVuZCAmJiB0ZXh0VXBkYXRlLmFwcGVuZChcInRpdGxlXCIpXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLnRleHQocGFyYW1zLnRpY2tUaXRsZVtpbmRleF0pO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChzY2FsZTEuYmFuZHdpZHRoKSB7XG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNjYWxlMTtcblx0XHRcdFx0XHRjb25zdCBkeCA9IHguYmFuZHdpZHRoKCkgLyAyO1xuXG5cdFx0XHRcdFx0c2NhbGUwID0gZCA9PiB4KGQpICsgZHg7XG5cdFx0XHRcdFx0c2NhbGUxID0gc2NhbGUwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNjYWxlMC5iYW5kd2lkdGgpIHtcblx0XHRcdFx0XHRzY2FsZTAgPSBzY2FsZTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIHRpY2tFeGl0LCBzY2FsZTEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIHRpY2tFbnRlciwgc2NhbGUwKTtcblx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIGhlbHBlckluc3QudHJhbnNpdGlvbmlzZSh0aWNrKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLCBzY2FsZTEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5nID0gJGc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRpY2sgeC95IGNvb3JkaW5hdGVcblx0ICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFRpY2tYWSgpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0XHRjb25zdCBwb3MgPSB7eDogMCwgeTogMH07XG5cblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xuXHRcdFx0cG9zLnggPSBjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0O1xuXHRcdFx0cG9zLnkgPSBjb25maWcudGlja0NlbnRlcmVkID8gY29uZmlnLnRpY2tPZmZzZXQgOiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBwb3M7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRpY2sgc2l6ZVxuXHQgKiBAcGFyYW0gZFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUaWNrU2l6ZShkKSB7XG5cdFx0Y29uc3Qgc2NhbGUgPSB0aGlzLmhlbHBlci5zY2FsZTtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0XHRjb25zdCBpbm5lclRpY2tTaXplID0gY29uZmlnLmlubmVyVGlja1NpemU7XG5cdFx0Y29uc3QgcmFuZ2UgPSBjb25maWcucmFuZ2U7XG5cblx0XHRjb25zdCB0aWNrUG9zaXRpb24gPSBzY2FsZShkKSArXG5cdFx0XHQoY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldCk7XG5cblx0XHRyZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGljaydzIGxpbmUgJiB0ZXh0IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBsaW5lVXBkYXRlXG5cdCAqIEBwYXJhbSB0ZXh0VXBkYXRlXG5cdCAqIEBwYXJhbSBzY2FsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSkge1xuXHRcdGNvbnN0IHRpY2tQb3MgPSB0aGlzLmdldFRpY2tYWSgpO1xuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCBvcmllbnQsIHRpY2tMZW5ndGgsIHRpY2tPZmZzZXR9ID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3Qgcm90YXRlID0gdGhpcy5wYXJhbXMudGlja1RleHRSb3RhdGU7XG5cblx0XHRjb25zdCB0ZXh0QW5jaG9yRm9yVGV4dCA9IHIgPT4gKCFyID8gXCJtaWRkbGVcIiA6IChyID4gMCA/IFwic3RhcnRcIiA6IFwiZW5kXCIpKTtcblx0XHRjb25zdCB0ZXh0VHJhbnNmb3JtID0gciA9PiAociA/IGByb3RhdGUoJHtyfSlgIDogbnVsbCk7XG5cdFx0Y29uc3QgeUZvclRleHQgPSByID0+IChyID8gMTEuNSAtIDIuNSAqIChyIC8gMTUpICogKHIgPiAwID8gMSA6IC0xKSA6IHRpY2tMZW5ndGgpO1xuXG5cdFx0c3dpdGNoIChvcmllbnQpIHtcblx0XHRcdGNhc2UgXCJib3R0b21cIjpcblx0XHRcdFx0bGluZVVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgdGlja1Bvcy54KVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgdGlja1Bvcy54KVxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGhpcy5nZXRUaWNrU2l6ZS5iaW5kKHRoaXMpKTtcblxuXHRcdFx0XHR0ZXh0VXBkYXRlXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KHJvdGF0ZSkpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGV4dEFuY2hvckZvclRleHQocm90YXRlKSlcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ0b3BcIjpcblx0XHRcdFx0bGluZVVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgMClcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIC1pbm5lclRpY2tTaXplKTtcblxuXHRcdFx0XHR0ZXh0VXBkYXRlXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIC10aWNrTGVuZ3RoICogMilcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibGVmdFwiOlxuXHRcdFx0XHRsaW5lVXBkYXRlXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAtaW5uZXJUaWNrU2l6ZSlcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHRpY2tQb3MueSlcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHRpY2tQb3MueSk7XG5cblx0XHRcdFx0dGV4dFVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAtdGlja0xlbmd0aClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgdGlja09mZnNldClcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRcdFx0bGluZVVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaW5uZXJUaWNrU2l6ZSlcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIDApO1xuXG5cdFx0XHRcdHRleHRVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgdGlja0xlbmd0aClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgMClcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdoZW4gY2F0ZWdvcnkgYXhpc1xuXHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xuXHRcdGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXHRcdGNvbnN0IHRpY2tUZXh0ID0gdGhpcy5oZWxwZXIudGV4dEZvcm1hdHRlZChkKTtcblx0XHRjb25zdCBzcGxpdHRlZCA9IGlzU3RyaW5nKHRpY2tUZXh0KSAmJiB0aWNrVGV4dC5pbmRleE9mKFwiXFxuXCIpID4gLTEgP1xuXHRcdFx0dGlja1RleHQuc3BsaXQoXCJcXG5cIikgOiBbXTtcblxuXHRcdGlmIChzcGxpdHRlZC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBzcGxpdHRlZDtcblx0XHR9XG5cblx0XHRpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHtcblx0XHRcdHJldHVybiB0aWNrVGV4dDtcblx0XHR9XG5cblx0XHRsZXQgdGlja1dpZHRoID0gcGFyYW1zLnRpY2tXaWR0aDtcblxuXHRcdGlmICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSB7XG5cdFx0XHR0aWNrV2lkdGggPSBpc0xlZnRSaWdodCA/IDk1IDogKFxuXHRcdFx0XHRwYXJhbXMuaXNDYXRlZ29yeSA/XG5cdFx0XHRcdFx0KE1hdGguY2VpbChzY2FsZSh0aWNrc1sxXSkgLSBzY2FsZSh0aWNrc1swXSkpIC0gMTIpIDogMTEwXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNwbGl0KHNwbGl0dGVkLCB0ZXh0KSB7XG5cdFx0XHRsZXQgc3VidGV4dDtcblx0XHRcdGxldCBzcGFjZUluZGV4O1xuXHRcdFx0bGV0IHRleHRXaWR0aDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gXCIgXCIpIHtcblx0XHRcdFx0XHRzcGFjZUluZGV4ID0gaTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN1YnRleHQgPSB0ZXh0LnN1YnN0cigwLCBpICsgMSk7XG5cdFx0XHRcdHRleHRXaWR0aCA9IGNoYXJXaWR0aCAqIHN1YnRleHQubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIGlmIHRleHQgd2lkdGggZ2V0cyBvdmVyIHRpY2sgd2lkdGgsIHNwbGl0IGJ5IHNwYWNlIGluZGV4IG9yIGN1cnJlbnQgaW5kZXhcblx0XHRcdFx0aWYgKHRpY2tXaWR0aCA8IHRleHRXaWR0aCkge1xuXHRcdFx0XHRcdHJldHVybiBzcGxpdChcblx0XHRcdFx0XHRcdHNwbGl0dGVkLmNvbmNhdCh0ZXh0LnN1YnN0cigwLCBzcGFjZUluZGV4IHx8IGkpKSxcblx0XHRcdFx0XHRcdHRleHQuc2xpY2Uoc3BhY2VJbmRleCA/IHNwYWNlSW5kZXggKyAxIDogaSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzcGxpdHRlZC5jb25jYXQodGV4dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwbGl0KHNwbGl0dGVkLCBTdHJpbmcodGlja1RleHQpKTtcblx0fVxuXG5cdHNjYWxlKHgpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlbHBlci5zY2FsZTtcblx0XHR9XG5cblx0XHR0aGlzLmhlbHBlci5zY2FsZSA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdG9yaWVudCh4KSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb25maWcub3JpZW50O1xuXHRcdH1cblxuXHRcdHRoaXMuY29uZmlnLm9yaWVudCA9IHggaW4ge1xuXHRcdFx0dG9wOiAxLFxuXHRcdFx0cmlnaHQ6IDEsXG5cdFx0XHRib3R0b206IDEsXG5cdFx0XHRsZWZ0OiAxXG5cdFx0fSA/IFN0cmluZyh4KSA6IFwiYm90dG9tXCI7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHRpY2tGb3JtYXQoZm9ybWF0KSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja0Zvcm1hdDtcblx0XHR9XG5cblx0XHR0aGlzLmNvbmZpZy50aWNrRm9ybWF0ID0gZm9ybWF0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrQ2VudGVyZWQoaXNDZW50ZXJlZCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tDZW50ZXJlZDtcblx0XHR9XG5cblx0XHRjb25maWcudGlja0NlbnRlcmVkID0gaXNDZW50ZXJlZDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aWNrJ3Mgb2Zmc2V0IHZhbHVlLlxuXHQgKiBUaGUgdmFsdWUgd2lsbCBiZSBzZXQgZm9yICdjYXRlZ29yeScgYXhpcyB0eXBlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aWNrT2Zmc2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aWNrIGludGVydmFsIGNvdW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFRvdGFsIGRhdGEgc2l6ZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHR0aWNrSW50ZXJ2YWwoc2l6ZSkge1xuXHRcdGxldCBpbnRlcnZhbDtcblxuXHRcdGlmICh0aGlzLnBhcmFtcy5pc0NhdGVnb3J5KSB7XG5cdFx0XHRpbnRlcnZhbCA9IHRoaXMuY29uZmlnLnRpY2tPZmZzZXQgKiAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmcuc2VsZWN0KFwicGF0aC5kb21haW5cIilcblx0XHRcdFx0Lm5vZGUoKVxuXHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKSAtIHRoaXMuY29uZmlnLm91dGVyVGlja1NpemUgKiAyO1xuXG5cdFx0XHRpbnRlcnZhbCA9IGxlbmd0aCAvIChzaXplIHx8IHRoaXMuZy5zZWxlY3RBbGwoXCJsaW5lXCIpLnNpemUoKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVydmFsID09PSBJbmZpbml0eSA/IDAgOiBpbnRlcnZhbDtcblx0fVxuXG5cdHRpY2tzKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdGlmICghYXJncy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBjb25maWcudGlja0FyZ3VtZW50cztcblx0XHR9XG5cblx0XHRjb25maWcudGlja0FyZ3VtZW50cyA9IHRvQXJyYXkoYXJncyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHRpY2tDdWxsaW5nKGN1bGxpbmcpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ3VsbGluZztcblx0XHR9XG5cblx0XHRjb25maWcudGlja0N1bGxpbmcgPSBjdWxsaW5nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrVmFsdWVzKHgpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdGlmIChpc0Z1bmN0aW9uKHgpKSB7XG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9ICgpID0+IHgodGhpcy5oZWxwZXIuc2NhbGUuZG9tYWluKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrVmFsdWVzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9IHg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzZXRUcmFuc2l0aW9uKHQpIHtcblx0XHR0aGlzLmNvbmZpZy50cmFuc2l0aW9uID0gdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRheGlzVG9wIGFzIGQzQXhpc1RvcCxcblx0YXhpc0JvdHRvbSBhcyBkM0F4aXNCb3R0b20sXG5cdGF4aXNMZWZ0IGFzIGQzQXhpc0xlZnQsXG5cdGF4aXNSaWdodCBhcyBkM0F4aXNSaWdodFxufSBmcm9tIFwiZDMtYXhpc1wiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNWYWx1ZSwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5pbXBvcnQgQXhpc1JlbmRlcmVyIGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xuXG5jb25zdCBpc0hvcml6b250YWwgPSAoJCQsIGZvckhvcml6b250YWwpID0+IHtcblx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQ7XG59O1xuXG5jb25zdCBnZXRBeGlzQ2xhc3NOYW1lID0gaWQgPT4gYCR7Q0xBU1MuYXhpc30gJHtDTEFTU1tgYXhpcyR7Y2FwaXRhbGl6ZShpZCl9YF19YDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyB7XG5cdGNvbnN0cnVjdG9yKG93bmVyKSB7XG5cdFx0dGhpcy5vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuc2V0T3JpZW50KCk7XG5cdH1cblxuXHRpbml0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCB0YXJnZXQgPSBbXCJ4XCIsIFwieVwiXTtcblxuXHRcdGNvbmZpZy5heGlzX3kyX3Nob3cgJiYgdGFyZ2V0LnB1c2goXCJ5MlwiKTtcblxuXHRcdCQkLmF4ZXNMaXN0ID0ge307XG5cblx0XHR0YXJnZXQuZm9yRWFjaCh2ID0+IHtcblx0XHRcdGNvbnN0IGNsYXNzQXhpcyA9IGdldEF4aXNDbGFzc05hbWUodik7XG5cdFx0XHRjb25zdCBjbGFzc0xhYmVsID0gQ0xBU1NbYGF4aXMke2NhcGl0YWxpemUodil9TGFiZWxgXTtcblxuXHRcdFx0JCQuYXhlc1t2XSA9IG1haW4uYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXhpcylcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGxldCByZXMgPSBudWxsO1xuXG5cdFx0XHRcdFx0aWYgKHYgPT09IFwieFwiKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSAkJC5jbGlwUGF0aEZvclhBeGlzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ5XCIgJiYgY29uZmlnLmF4aXNfeV9pbm5lcikge1xuXHRcdFx0XHRcdFx0cmVzID0gJCQuY2xpcFBhdGhGb3JZQXhpcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUodikpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7dn1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcblxuXHRcdFx0JCQuYXhlc1t2XS5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMYWJlbClcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgW1wicm90YXRlKC05MClcIiwgbnVsbF1bXG5cdFx0XHRcdFx0diA9PT0gXCJ4XCIgPyArIWlzUm90YXRlZCA6ICtpc1JvdGF0ZWRcblx0XHRcdFx0XSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpcy50ZXh0QW5jaG9yRm9yWEF4aXNMYWJlbC5iaW5kKHRoaXMpKTtcblxuXHRcdFx0dGhpcy5nZW5lcmF0ZUF4ZXModik7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGF4aXMgb3JpZW50IGFjY29yZGluZyBvcHRpb24gdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldE9yaWVudCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgeUlubmVyID0gY29uZmlnLmF4aXNfeV9pbm5lcjtcblx0XHRjb25zdCB5MklubmVyID0gY29uZmlnLmF4aXNfeTJfaW5uZXI7XG5cblx0XHQkJC54T3JpZW50ID0gaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiO1xuXHRcdCQkLnlPcmllbnQgPSBpc1JvdGF0ZWQgPyAoeUlubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpIDogKHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblx0XHQkJC55Mk9yaWVudCA9IGlzUm90YXRlZCA/ICh5MklubmVyID8gXCJib3R0b21cIiA6IFwidG9wXCIpIDogKHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XG5cdFx0JCQuc3ViWE9yaWVudCA9IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBheGVzXG5cdCAqIEl0J3MgdXNlZCB3aGVuIGF4aXMnIGF4ZXMgb3B0aW9uIGlzIHNldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2VuZXJhdGVBeGVzKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBheGVzID0gW107XG5cdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRsZXQgZDNBeGlzO1xuXG5cdFx0aWYgKGlkID09PSBcInhcIikge1xuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzTGVmdCA6IGQzQXhpc0JvdHRvbTtcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInlcIikge1xuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzQm90dG9tIDogZDNBeGlzTGVmdDtcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInkyXCIpIHtcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc1RvcCA6IGQzQXhpc1JpZ2h0O1xuXHRcdH1cblxuXHRcdGlmIChheGVzQ29uZmlnLmxlbmd0aCkge1xuXHRcdFx0YXhlc0NvbmZpZy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCB0aWNrID0gdi50aWNrO1xuXG5cdFx0XHRcdGF4ZXMucHVzaChcblx0XHRcdFx0XHRkM0F4aXMoJCRbaWRdKVxuXHRcdFx0XHRcdFx0LnRpY2tzKHRpY2suY291bnQpXG5cdFx0XHRcdFx0XHQudGlja0Zvcm1hdCh0aWNrLmZvcm1hdCB8fCAoeCA9PiB4KSlcblx0XHRcdFx0XHRcdC50aWNrVmFsdWVzKHRpY2sudmFsdWVzKVxuXHRcdFx0XHRcdFx0LnRpY2tTaXplT3V0ZXIodGljay5vdXRlciA9PT0gZmFsc2UgPyAwIDogNilcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkLmF4ZXNMaXN0W2lkXSA9IGF4ZXM7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIGF4ZXMgbm9kZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUF4ZXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdE9iamVjdC5rZXlzKCQkLmF4ZXNMaXN0KS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbnN0IHJhbmdlID0gJCRbaWRdLnJhbmdlKCk7XG5cblx0XHRcdCQkLmF4ZXNMaXN0W2lkXS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGF4aXNSYW5nZSA9IHYuc2NhbGUoKS5yYW5nZSgpO1xuXG5cdFx0XHRcdC8vIGFkanVzdCByYW5nZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzg1OVxuXHRcdFx0XHRpZiAoIXJhbmdlLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBheGlzUmFuZ2VbaV0pKSB7XG5cdFx0XHRcdFx0di5zY2FsZSgpLnJhbmdlKHJhbmdlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGAke2dldEF4aXNDbGFzc05hbWUoaWQpfS0ke2kgKyAxfWA7XG5cdFx0XHRcdGxldCBnID0gJCQubWFpbi5zZWxlY3QoYC4ke2NsYXNzTmFtZS5yZXBsYWNlKC9cXHMvLCBcIi5cIil9YCk7XG5cblx0XHRcdFx0aWYgKGcuZW1wdHkoKSkge1xuXHRcdFx0XHRcdGcgPSAkJC5tYWluLmFwcGVuZChcImdcIilcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxuXHRcdFx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKVxuXHRcdFx0XHRcdFx0LmNhbGwodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JCQueEF4aXMuaGVscGVyLnRyYW5zaXRpb25pc2UoZylcblx0XHRcdFx0XHRcdC5jYWxsKHYuc2NhbGUoJCRbaWRdKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKGlkLCBpICsgMSkpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBjYWxsZWQgZnJvbSA6IHVwZGF0ZVNjYWxlcygpICYgZ2V0TWF4VGlja1dpZHRoKClcblx0Z2V0WEF4aXMobmFtZSwgc2NhbGUsIG91dGVyVGljaywgbm9UcmFuc2l0aW9uLCBub1RpY2tUZXh0Um90YXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc0NhdGVnb3J5ID0gJCQuaXNDYXRlZ29yaXplZCgpO1xuXHRcdGNvbnN0IG9yaWVudCA9ICQkW2Ake25hbWV9T3JpZW50YF07XG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9ICQkLnhBeGlzVGlja0Zvcm1hdDtcblx0XHRjb25zdCB0aWNrVmFsdWVzID0gJCQueEF4aXNUaWNrVmFsdWVzO1xuXG5cdFx0Y29uc3QgYXhpc1BhcmFtcyA9IHtcblx0XHRcdGlzQ2F0ZWdvcnksXG5cdFx0XHRvdXRlclRpY2ssXG5cdFx0XHRub1RyYW5zaXRpb24sXG5cdFx0XHRjb25maWcsXG5cdFx0XHRuYW1lLFxuXHRcdFx0dGlja011bHRpbGluZTogY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSxcblx0XHRcdHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxuXHRcdFx0dGlja1RleHRSb3RhdGU6IG5vVGlja1RleHRSb3RhdGUgPyAwIDogY29uZmlnLmF4aXNfeF90aWNrX3JvdGF0ZSxcblx0XHRcdHRpY2tUaXRsZTogaXNDYXRlZ29yeSAmJiBjb25maWcuYXhpc194X3RpY2tfdG9vbHRpcCAmJiAkJC5hcGkuY2F0ZWdvcmllcygpLFxuXHRcdFx0b3JnWFNjYWxlOiAkJC54XG5cdFx0fTtcblxuXHRcdGNvbnN0IGF4aXMgPSBuZXcgQXhpc1JlbmRlcmVyKGF4aXNQYXJhbXMpXG5cdFx0XHQuc2NhbGUoJCQuem9vbVNjYWxlIHx8IHNjYWxlKVxuXHRcdFx0Lm9yaWVudChvcmllbnQpO1xuXG5cdFx0bGV0IG5ld1RpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzO1xuXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpICYmIHRpY2tWYWx1ZXMgJiYgIWlzRnVuY3Rpb24odGlja1ZhbHVlcykpIHtcblx0XHRcdG5ld1RpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLm1hcCh2ID0+ICQkLnBhcnNlRGF0ZSh2KSk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRpY2tcblx0XHRheGlzLnRpY2tGb3JtYXQodGlja0Zvcm1hdCkudGlja1ZhbHVlcyhuZXdUaWNrVmFsdWVzKTtcblxuXHRcdGlmIChpc0NhdGVnb3J5KSB7XG5cdFx0XHRheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xuXG5cdFx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X3RpY2tfY3VsbGluZykpIHtcblx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25maWcuYXhpc194X3RpY2tfY291bnQgJiYgYXhpcy50aWNrcyhjb25maWcuYXhpc194X3RpY2tfY291bnQpO1xuXG5cdFx0cmV0dXJuIGF4aXM7XG5cdH1cblxuXHQvLyBjYWxsZWQgZnJvbSA6IHVwZGF0ZVNjYWxlcygpICYgZ2V0TWF4VGlja1dpZHRoKClcblx0Z2V0WUF4aXMobmFtZSwgc2NhbGUsIG91dGVyVGljaywgbm9UcmFuc2l0aW9uLCBub1RpY2tUZXh0Um90YXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBvcmllbnQgPSAkJFtgJHtuYW1lfU9yaWVudGBdO1xuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBjb25maWdbYGF4aXNfJHtuYW1lfV90aWNrX2Zvcm1hdGBdO1xuXHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSAkJFtgJHtuYW1lfUF4aXNUaWNrVmFsdWVzYF07XG5cblx0XHRjb25zdCBheGlzUGFyYW1zID0ge1xuXHRcdFx0b3V0ZXJUaWNrLFxuXHRcdFx0bm9UcmFuc2l0aW9uLFxuXHRcdFx0Y29uZmlnLFxuXHRcdFx0bmFtZSxcblx0XHRcdHRpY2tUZXh0Um90YXRlOiBub1RpY2tUZXh0Um90YXRlID8gMCA6IGNvbmZpZy5heGlzX3lfdGlja19yb3RhdGVcblx0XHR9O1xuXG5cdFx0Y29uc3QgYXhpcyA9IG5ldyBBeGlzUmVuZGVyZXIoYXhpc1BhcmFtcylcblx0XHRcdC5zY2FsZShzY2FsZSlcblx0XHRcdC5vcmllbnQob3JpZW50KVxuXHRcdFx0LnRpY2tGb3JtYXQoXG5cdFx0XHRcdHRpY2tGb3JtYXQgfHwgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgKHggPT4gYCR7eH0lYCkpXG5cdFx0XHQpO1xuXG5cdFx0JCQuaXNUaW1lU2VyaWVzWSgpID9cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9ibG9iL21hc3Rlci9DSEFOR0VTLm1kI3RpbWUtaW50ZXJ2YWxzLWQzLXRpbWVcblx0XHRcdGF4aXMudGlja3MoY29uZmlnLmF4aXNfeV90aWNrX3RpbWVfdmFsdWUpIDpcblx0XHRcdGF4aXMudGlja1ZhbHVlcyh0aWNrVmFsdWVzKTtcblxuXHRcdHJldHVybiBheGlzO1xuXHR9XG5cblx0dXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHMsIGF4aXMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGZpdCA9IGNvbmZpZy5heGlzX3hfdGlja19maXQ7XG5cdFx0Y29uc3QgY291bnQgPSBjb25maWcuYXhpc194X3RpY2tfY291bnQ7XG5cdFx0bGV0IHZhbHVlcztcblxuXHRcdGlmIChmaXQgfHwgKGNvdW50ICYmIGZpdCkpIHtcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxuXHRcdFx0XHQkJC5tYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSxcblx0XHRcdFx0Y291bnQsXG5cdFx0XHRcdCQkLmlzVGltZVNlcmllcygpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChheGlzKSB7XG5cdFx0XHRheGlzLnRpY2tWYWx1ZXModmFsdWVzKTtcblx0XHR9IGVsc2UgaWYgKCQkLnhBeGlzKSB7XG5cdFx0XHQkJC54QXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XG5cdFx0XHQkJC5zdWJYQXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fVxuXG5cdGdldElkKGlkKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5vd25lci5jb25maWc7XG5cblx0XHRyZXR1cm4gaWQgaW4gY29uZmlnLmRhdGFfYXhlcyA/IGNvbmZpZy5kYXRhX2F4ZXNbaWRdIDogXCJ5XCI7XG5cdH1cblxuXHRnZXRYQXhpc1RpY2tGb3JtYXQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gY29uZmlnLmF4aXNfeF90aWNrX2Zvcm1hdDtcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKTtcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xuXHRcdGxldCBmb3JtYXQ7XG5cblx0XHRpZiAodGlja0Zvcm1hdCkge1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24odGlja0Zvcm1hdCkpIHtcblx0XHRcdFx0Zm9ybWF0ID0gdGlja0Zvcm1hdDtcblx0XHRcdH0gZWxzZSBpZiAoaXNUaW1lU2VyaWVzKSB7XG5cdFx0XHRcdGZvcm1hdCA9IGRhdGUgPT4gKGRhdGUgPyAkJC5heGlzVGltZUZvcm1hdCh0aWNrRm9ybWF0KShkYXRlKSA6IFwiXCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3JtYXQgPSBpc1RpbWVTZXJpZXMgPyAkJC5kZWZhdWx0QXhpc1RpbWVGb3JtYXQgOiAoXG5cdFx0XHRcdGlzQ2F0ZWdvcml6ZWQgP1xuXHRcdFx0XHRcdCQkLmNhdGVnb3J5TmFtZSA6IHYgPT4gKHYgPCAwID8gdi50b0ZpeGVkKDApIDogdilcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IHYgPT5cblx0XHRcdGZvcm1hdC5hcHBseSgkJCwgaXNDYXRlZ29yaXplZCA/XG5cdFx0XHRcdFt2LCAkJC5jYXRlZ29yeU5hbWUodildIDogW3ZdXG5cdFx0XHQpIDogZm9ybWF0O1xuXHR9XG5cblx0Z2V0VGlja1ZhbHVlcyhpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCB0aWNrVmFsdWVzID0gJCQuY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfdmFsdWVzYF07XG5cdFx0Y29uc3QgYXhpcyA9ICQkW2Ake2lkfUF4aXNgXTtcblxuXHRcdHJldHVybiB0aWNrVmFsdWVzIHx8IChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xuXHR9XG5cblx0Z2V0WEF4aXNUaWNrVmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRpY2tWYWx1ZXMoXCJ4XCIpO1xuXHR9XG5cblx0Z2V0WUF4aXNUaWNrVmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRpY2tWYWx1ZXMoXCJ5XCIpO1xuXHR9XG5cblx0Z2V0WTJBeGlzVGlja1ZhbHVlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUaWNrVmFsdWVzKFwieTJcIik7XG5cdH1cblxuXHRnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMub3duZXIuY29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF07XG5cdH1cblxuXHRnZXRMYWJlbFRleHQoaWQpIHtcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xuXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9wdGlvbikgPyBvcHRpb24gOiAoXG5cdFx0XHRvcHRpb24gPyBvcHRpb24udGV4dCA6IG51bGxcblx0XHQpO1xuXHR9XG5cblx0c2V0TGFiZWxUZXh0KGlkLCB0ZXh0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xuXG5cdFx0aWYgKGlzU3RyaW5nKG9wdGlvbikpIHtcblx0XHRcdGNvbmZpZ1tgYXhpc18ke2lkfV9sYWJlbGBdID0gdGV4dDtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbikge1xuXHRcdFx0b3B0aW9uLnRleHQgPSB0ZXh0O1xuXHRcdH1cblx0fVxuXG5cdGdldExhYmVsUG9zaXRpb24oaWQsIGRlZmF1bHRQb3NpdGlvbikge1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gKGlzT2JqZWN0VHlwZShvcHRpb24pICYmIG9wdGlvbi5wb3NpdGlvbikgP1xuXHRcdFx0b3B0aW9uLnBvc2l0aW9uIDogZGVmYXVsdFBvc2l0aW9uWyshaXNSb3RhdGVkXTtcblxuXHRcdGNvbnN0IGhhcyA9IHYgPT4gISF+cG9zaXRpb24uaW5kZXhPZih2KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpc0lubmVyOiBoYXMoXCJpbm5lclwiKSxcblx0XHRcdGlzT3V0ZXI6IGhhcyhcIm91dGVyXCIpLFxuXHRcdFx0aXNMZWZ0OiBoYXMoXCJsZWZ0XCIpLFxuXHRcdFx0aXNDZW50ZXI6IGhhcyhcImNlbnRlclwiKSxcblx0XHRcdGlzUmlnaHQ6IGhhcyhcInJpZ2h0XCIpLFxuXHRcdFx0aXNUb3A6IGhhcyhcInRvcFwiKSxcblx0XHRcdGlzTWlkZGxlOiBoYXMoXCJtaWRkbGVcIiksXG5cdFx0XHRpc0JvdHRvbTogaGFzKFwiYm90dG9tXCIpXG5cdFx0fTtcblx0fVxuXG5cdGdldFhBeGlzTGFiZWxQb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieFwiLCBbXCJpbm5lci10b3BcIiwgXCJpbm5lci1yaWdodFwiXSk7XG5cdH1cblxuXHRnZXRZQXhpc0xhYmVsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInlcIiwgW1wiaW5uZXItcmlnaHRcIiwgXCJpbm5lci10b3BcIl0pO1xuXHR9XG5cblx0Z2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieTJcIiwgW1wiaW5uZXItcmlnaHRcIiwgXCJpbm5lci10b3BcIl0pO1xuXHR9XG5cblx0Z2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpIHtcblx0XHRyZXR1cm4gdGhpc1tgZ2V0JHtpZC50b1VwcGVyQ2FzZSgpfUF4aXNMYWJlbFBvc2l0aW9uYF0oKTtcblx0fVxuXG5cdHRleHRGb3JYQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExhYmVsVGV4dChcInhcIik7XG5cdH1cblxuXHR0ZXh0Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ5XCIpO1xuXHR9XG5cblx0dGV4dEZvclkyQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExhYmVsVGV4dChcInkyXCIpO1xuXHR9XG5cblx0eEZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0bGV0IHggPSBwb3NpdGlvbi5pc01pZGRsZSA/IC0kJC5oZWlnaHQgLyAyIDogMDtcblxuXHRcdGlmIChpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XG5cdFx0XHR4ID0gcG9zaXRpb24uaXNMZWZ0ID8gMCA6IChcblx0XHRcdFx0cG9zaXRpb24uaXNDZW50ZXIgPyAkJC53aWR0aCAvIDIgOiAkJC53aWR0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzQm90dG9tKSB7XG5cdFx0XHR4ID0gLSQkLmhlaWdodDtcblx0XHR9XG5cblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdGR4Rm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRsZXQgZHggPSBwb3NpdGlvbi5pc0JvdHRvbSA/IFwiMC41ZW1cIiA6IFwiMFwiO1xuXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkpIHtcblx0XHRcdGR4ID0gcG9zaXRpb24uaXNMZWZ0ID8gXCIwLjVlbVwiIDogKFxuXHRcdFx0XHRwb3NpdGlvbi5pc1JpZ2h0ID8gXCItMC41ZW1cIiA6IFwiMFwiXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNUb3ApIHtcblx0XHRcdGR4ID0gXCItMC41ZW1cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gZHg7XG5cdH1cblxuXHR0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRsZXQgYW5jaG9yID0gcG9zaXRpb24uaXNNaWRkbGUgPyBcIm1pZGRsZVwiIDogXCJlbmRcIjtcblxuXHRcdGlmIChpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XG5cdFx0XHRhbmNob3IgPSBwb3NpdGlvbi5pc0xlZnQgPyBcInN0YXJ0XCIgOiAoXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gXCJtaWRkbGVcIiA6IFwiZW5kXCJcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xuXHRcdFx0YW5jaG9yID0gXCJzdGFydFwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBhbmNob3I7XG5cdH1cblxuXHR4Rm9yWEF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcblx0fVxuXG5cdHhGb3JZQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSk7XG5cdH1cblxuXHR4Rm9yWTJBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSk7XG5cdH1cblxuXHRkeEZvclhBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xuXHR9XG5cblx0ZHhGb3JZQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0ZHhGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5keEZvckF4aXNMYWJlbCh0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSk7XG5cdH1cblxuXHRkeUZvclhBeGlzTGFiZWwoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKS5pc0lubmVyO1xuXHRcdGNvbnN0IHhIZWlnaHQgPSBjb25maWcuYXhpc194X2hlaWdodDtcblxuXHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiMS4yZW1cIiA6IC0yNSAtIHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieFwiKTtcblx0XHR9IGVsc2UgaWYgKGlzSW5uZXIpIHtcblx0XHRcdHJldHVybiBcIi0wLjVlbVwiO1xuXHRcdH0gZWxzZSBpZiAoeEhlaWdodCkge1xuXHRcdFx0cmV0dXJuIHhIZWlnaHQgLSAxMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiM2VtXCI7XG5cdFx0fVxuXHR9XG5cblx0ZHlGb3JZQXhpc0xhYmVsKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKS5pc0lubmVyO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCItMC41ZW1cIiA6IFwiM2VtXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCIxLjJlbVwiIDogLTEwIC0gKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAwIDogKHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieVwiKSArIDEwKSk7XG5cdFx0fVxuXHR9XG5cblx0ZHlGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpLmlzSW5uZXI7XG5cblx0XHRpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiBcIi0yLjJlbVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiAxNSArICgkJC5jb25maWcuYXhpc195Ml9pbm5lciA/IDAgOiAodGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ5MlwiKSArIDE1KSk7XG5cdFx0fVxuXHR9XG5cblx0dGV4dEFuY2hvckZvclhBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLCBmYWxzZSk7XG5cdH1cblxuXHR0ZXh0QW5jaG9yRm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0dGV4dEFuY2hvckZvclkyQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0Z2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjdXJyZW50VGlja01heCA9ICQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzW2lkXTtcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xuXG5cdFx0aWYgKHdpdGhvdXRSZWNvbXB1dGUgfHwgIWNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0pIHtcblx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xuXHRcdH1cblxuXHRcdGlmICgkJC5zdmcpIHtcblx0XHRcdGNvbnN0IGlzWUF4aXMgPSAvXnkyPyQvLnRlc3QoaWQpO1xuXHRcdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblx0XHRcdGNvbnN0IGdldEZyb20gPSBpc1lBeGlzID8gXCJnZXRZXCIgOiBcImdldFhcIjtcblxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJFtpZF0uY29weSgpLmRvbWFpbigkJFtgJHtnZXRGcm9tfURvbWFpbmBdKHRhcmdldHNUb1Nob3csIGlkKSk7XG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcblxuXHRcdFx0Ly8gZG8gbm90IGNvbXB1dGUgaWYgZG9tYWluIGlzIHNhbWVcblx0XHRcdGlmIChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBkb21haW5baV0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFRpY2tNYXguZG9tYWluID0gZG9tYWluO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBheGlzID0gdGhpc1tgJHtnZXRGcm9tfUF4aXNgXShpZCwgc2NhbGUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19jb3VudGBdO1xuXG5cdFx0XHQvLyBNYWtlIHRvIGdlbmVyYXRlIHRoZSBmaW5hbCB0aWNrIHRleHQgdG8gYmUgcmVuZGVyZWRcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzkyMFxuXHRcdFx0aWYgKHRpY2tDb3VudCkge1xuXHRcdFx0XHRheGlzLnRpY2tWYWx1ZXMoXG5cdFx0XHRcdFx0dGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXG5cdFx0XHRcdFx0XHRkb21haW4sXG5cdFx0XHRcdFx0XHR0aWNrQ291bnQsXG5cdFx0XHRcdFx0XHRpc1lBeGlzID8gJCQuaXNUaW1lU2VyaWVzWSgpIDogJCQuaXNUaW1lU2VyaWVzKClcblx0XHRcdFx0XHQpKTtcblx0XHRcdH1cblxuXHRcdFx0IWlzWUF4aXMgJiYgdGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdywgYXhpcyk7XG5cblx0XHRcdGNvbnN0IGR1bW15ID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0b3BcIiwgXCIwcHhcIilcblx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBcIjBweFwiKTtcblxuXHRcdFx0YXhpcy5jcmVhdGUoZHVtbXkpO1xuXG5cdFx0XHRkdW1teS5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0ZHVtbXkucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFdpZHRoID4gMCkge1xuXHRcdFx0Y3VycmVudFRpY2tNYXguc2l6ZSA9IG1heFdpZHRoO1xuXHRcdH1cblxuXHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xuXHR9XG5cblx0dXBkYXRlTGFiZWxzKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGxhYmVscyA9IHtcblx0XHRcdFg6ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH0gLiR7Q0xBU1MuYXhpc1hMYWJlbH1gKSxcblx0XHRcdFk6ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX0gLiR7Q0xBU1MuYXhpc1lMYWJlbH1gKSxcblx0XHRcdFkyOiAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfSAuJHtDTEFTUy5heGlzWTJMYWJlbH1gKVxuXHRcdH07XG5cblx0XHRPYmplY3Qua2V5cyhsYWJlbHMpLmZpbHRlcihpZCA9PiAhbGFiZWxzW2lkXS5lbXB0eSgpKVxuXHRcdFx0LmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBsYWJlbHNbdl07XG5cdFx0XHRcdGNvbnN0IGF4aXNMYWJlbCA9IGAke3Z9QXhpc0xhYmVsYDtcblxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gPyBub2RlLnRyYW5zaXRpb24oKSA6IG5vZGUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRoaXNbYHhGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgdGhpc1tgZHhGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgdGhpc1tgZHlGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxuXHRcdFx0XHRcdC50ZXh0KHRoaXNbYHRleHRGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0Z2V0UGFkZGluZyhwYWRkaW5nLCBrZXksIGRlZmF1bHRWYWx1ZSwgZG9tYWluTGVuZ3RoKSB7XG5cdFx0Y29uc3QgcCA9IGlzTnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IHBhZGRpbmdba2V5XTtcblxuXHRcdGlmICghaXNWYWx1ZShwKSkge1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cblx0XHRpZiAocGFkZGluZy51bml0ID09PSBcInJhdGlvXCIpIHtcblx0XHRcdHJldHVybiBwYWRkaW5nW2tleV0gKiBkb21haW5MZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gYXNzdW1lIHBhZGRpbmcgaXMgcGl4ZWxzIGlmIHVuaXQgaXMgbm90IHNwZWNpZmllZFxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCk7XG5cdH1cblxuXHRjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwaXhlbHMsIGRvbWFpbkxlbmd0aCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBsZW5ndGggPSAkJC5jb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiAkJC5oZWlnaHQ7XG5cblx0XHRyZXR1cm4gZG9tYWluTGVuZ3RoICogKHBpeGVscyAvIGxlbmd0aCk7XG5cdH1cblxuXHRnZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCB0aWNrQ291bnQsIGZvclRpbWVTZXJpZXMpIHtcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHZhbHVlcztcblx0XHRsZXQgc3RhcnQ7XG5cdFx0bGV0IGVuZDtcblx0XHRsZXQgY291bnQ7XG5cdFx0bGV0IGludGVydmFsO1xuXHRcdGxldCBpO1xuXHRcdGxldCB0aWNrVmFsdWU7XG5cblx0XHRpZiAodGlja0NvdW50KSB7XG5cdFx0XHRjb25zdCB0YXJnZXRDb3VudCA9IGlzRnVuY3Rpb24odGlja0NvdW50KSA/IHRpY2tDb3VudCgpIDogdGlja0NvdW50O1xuXG5cdFx0XHQvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcblx0XHRcdGlmICh0YXJnZXRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3ZhbHVlc1swXV07XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB7XG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbdmFsdWVzWzBdLCB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdXTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Q291bnQgPiAyKSB7XG5cdFx0XHRcdGNvdW50ID0gdGFyZ2V0Q291bnQgLSAyO1xuXHRcdFx0XHRzdGFydCA9IHZhbHVlc1swXTtcblx0XHRcdFx0ZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0aW50ZXJ2YWwgPSAoZW5kIC0gc3RhcnQpIC8gKGNvdW50ICsgMSk7XG5cblx0XHRcdFx0Ly8gcmUtY29uc3RydWN0IHVuaXF1ZSB2YWx1ZXNcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFtzdGFydF07XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0XHR0aWNrVmFsdWUgPSArc3RhcnQgKyBpbnRlcnZhbCAqIChpICsgMSk7XG5cdFx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGZvclRpbWVTZXJpZXMgPyBuZXcgRGF0ZSh0aWNrVmFsdWUpIDogdGlja1ZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChlbmQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghZm9yVGltZVNlcmllcykge1xuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrVmFsdWVzO1xuXHR9XG5cblx0Z2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBheGVzID0gJCQuYXhlcztcblxuXHRcdGNvbnN0IFtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1YlhdID0gW1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YnhcIl1cblx0XHRcdC5tYXAodiA9PiB7XG5cdFx0XHRcdGxldCBheGlzID0gYXhlc1t2XTtcblxuXHRcdFx0XHRpZiAoYXhpcyAmJiBkdXJhdGlvbikge1xuXHRcdFx0XHRcdGF4aXMgPSBheGlzLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYXhpcztcblx0XHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1Ylh9O1xuXHR9XG5cblx0cmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSBpc0hpZGRlbiA/IFwiMFwiIDogXCIxXCI7XG5cblx0XHRbXCJ4XCIsIFwieVwiLCBcInkyXCIsIFwic3ViWFwiXS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbnN0IGF4aXMgPSAkJFtgJHtpZH1BeGlzYF07XG5cblx0XHRcdGlmIChheGlzKSB7XG5cdFx0XHRcdGlmICghaXNJbml0KSB7XG5cdFx0XHRcdFx0YXhpcy5jb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb247XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkJC5heGVzW2lkLnRvTG93ZXJDYXNlKCldLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5KTtcblx0XHRcdFx0YXhpcy5jcmVhdGUodHJhbnNpdGlvbnNbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMudXBkYXRlQXhlcygpO1xuXHR9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQGlnbm9yZVxuICovXG5pbXBvcnQge1xuXHR0aW1lUGFyc2UgYXMgZDNUaW1lUGFyc2UsXG5cdHRpbWVGb3JtYXQgYXMgZDNUaW1lRm9ybWF0LFxuXHR1dGNQYXJzZSBhcyBkM1V0Y1BhcnNlLFxuXHR1dGNGb3JtYXQgYXMgZDNVdGNGb3JtYXRcbn0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4uL2F4aXMvQXhpc1wiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtpc01vYmlsZX0gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQge25vdEVtcHR5LCBhc0hhbGZQaXhlbCwgZ2V0T3B0aW9uLCBpc1ZhbHVlLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzT2JqZWN0LCBjYWxsRm4sIHNlbmRTdGF0cywgc29ydFZhbHVlfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8qKlxuICogSW50ZXJuYWwgY2hhcnQgY2xhc3MuXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxuICogQGNsYXNzIENoYXJ0SW50ZXJuYWxcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0SW50ZXJuYWwge1xuXHRjb25zdHJ1Y3RvcihhcGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5hcGkgPSBhcGk7XG5cdFx0JCQuY29uZmlnID0gJCQuZ2V0T3B0aW9ucygpO1xuXHRcdCQkLmRhdGEgPSB7fTtcblx0XHQkJC5jYWNoZSA9IHt9O1xuXHRcdCQkLmF4ZXMgPSB7fTtcblx0fVxuXG5cdGJlZm9yZUluaXQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY29uZmlnLnN0YXRzICYmIHNlbmRTdGF0cygpO1xuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XG5cblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkKTtcblx0fVxuXG5cdGFmdGVySW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRhZnRlckluaXRcIik7XG5cblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmFmdGVyaW5pdCwgJCQpO1xuXHR9XG5cblx0aW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5pbml0UGFyYW1zKCk7XG5cblx0XHRjb25zdCBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoJCQuY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xuXG5cdFx0Y29udmVydGVkRGF0YSAmJiAkJC5pbml0V2l0aERhdGEoY29udmVydGVkRGF0YSk7XG5cdH1cblxuXHRpbml0UGFyYW1zKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIGRhdGV0aW1lIHRvIGJlIHVzZWQgZm9yIHVuaXF1ZW5lc3Ncblx0XHQkJC5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcblx0XHQkJC5pbml0Q2xpcCgpO1xuXG5cdFx0JCQuZHJhZ1N0YXJ0ID0gbnVsbDtcblx0XHQkJC5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdCQkLmZsb3dpbmcgPSBmYWxzZTtcblx0XHQkJC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdCQkLm1vdXNlb3ZlciA9IGZhbHNlO1xuXHRcdCQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcblxuXHRcdCQkLmNvbG9yID0gJCQuZ2VuZXJhdGVDb2xvcigpO1xuXHRcdCQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcblx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcblxuXHRcdCQkLmV4dHJhTGluZUNsYXNzZXMgPSAkJC5nZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk7XG5cblx0XHQkJC5kYXRhVGltZUZvcm1hdCA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XG5cdFx0JCQuYXhpc1RpbWVGb3JtYXQgPSBjb25maWcuYXhpc194X2xvY2FsdGltZSA/IGQzVGltZUZvcm1hdCA6IGQzVXRjRm9ybWF0O1xuXG5cdFx0Y29uc3QgaXNEcmFnWm9vbSA9ICQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIjtcblxuXHRcdCQkLmRlZmF1bHRBeGlzVGltZUZvcm1hdCA9IGQgPT4ge1xuXHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gdGhpcy56b29tU2NhbGUgOlxuXHRcdFx0XHR0aGlzLnpvb21TY2FsZSAmJiAkJC54Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHRoaXMuem9vbVNjYWxlLmRvbWFpbigpLnRvU3RyaW5nKCk7XG5cblx0XHRcdGNvbnN0IHNwZWNpZmllciA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XG5cdFx0XHRcdChkLmdldFNlY29uZHMoKSAmJiBcIi46JVNcIikgfHxcblx0XHRcdFx0KGQuZ2V0TWludXRlcygpICYmIFwiJUk6JU1cIikgfHxcblx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XG5cdFx0XHRcdChkLmdldERhdGUoKSAhPT0gMSAmJiBcIiViICVkXCIpIHx8XG5cdFx0XHRcdChpc1pvb21lZCAmJiBkLmdldERhdGUoKSA9PT0gMSAmJiBcIiViXFwnJXlcIikgfHxcblx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xuXG5cdFx0XHRyZXR1cm4gJCQuYXhpc1RpbWVGb3JtYXQoc3BlY2lmaWVyKShkKTtcblx0XHR9O1xuXG5cdFx0JCQuaGlkZGVuVGFyZ2V0SWRzID0gW107XG5cdFx0JCQuaGlkZGVuTGVnZW5kSWRzID0gW107XG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXG5cdFx0JCQuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiO1xuXG5cdFx0JCQuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtcmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZExlZnQgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJib3R0b20tbGVmdFwiO1xuXG5cdFx0JCQubGVnZW5kU3RlcCA9IDA7XG5cdFx0JCQubGVnZW5kSXRlbVdpZHRoID0gMDtcblx0XHQkJC5sZWdlbmRJdGVtSGVpZ2h0ID0gMDtcblxuXHRcdCQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzID0ge1xuXHRcdFx0eDoge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXG5cdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcblx0XHRcdHkyOiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifVxuXHRcdH07XG5cblx0XHQkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCA9IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ19yaWdodCA9IGlzUm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeF9zaG93ID8gMCA6IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ190b3AgPSA1O1xuXG5cdFx0JCQud2l0aG91dEZhZGVJbiA9IHt9O1xuXHRcdCQkLmlucHV0VHlwZSA9ICQkLmNvbnZlcnRJbnB1dFR5cGUoKTtcblxuXHRcdCQkLmF4ZXMuc3VieCA9IGQzU2VsZWN0QWxsKFtdKTsgLy8gbmVlZHMgd2hlbiBleGNsdWRpbmcgc3ViY2hhcnQuanNcblx0fVxuXG5cdGluaXRXaXRoRGF0YShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXG5cdFx0Ly8gJCQuaGFzQXJjVHlwZSgpICYmIFtcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChpZCA9PiAoY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA9IGZhbHNlKSk7XG5cblx0XHQkJC5heGlzID0gbmV3IEF4aXMoJCQpO1xuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcblxuXHRcdGNvbnN0IGJpbmR0byA9IHtcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXG5cdFx0XHRjbGFzc25hbWU6IFwiYmJcIlxuXHRcdH07XG5cblx0XHRpZiAoaXNPYmplY3QoY29uZmlnLmJpbmR0bykpIHtcblx0XHRcdGJpbmR0by5lbGVtZW50ID0gY29uZmlnLmJpbmR0by5lbGVtZW50IHx8IFwiI2NoYXJ0XCI7XG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XG5cdFx0JCQuc2VsZWN0Q2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cblx0XHRcdGNvbmZpZy5iaW5kdG8uZWxlbWVudCA6IGQzU2VsZWN0KGJpbmR0by5lbGVtZW50IHx8IFtdKTtcblxuXHRcdGlmICgkJC5zZWxlY3RDaGFydC5lbXB0eSgpKSB7XG5cdFx0XHQkJC5zZWxlY3RDaGFydCA9IGQzU2VsZWN0KGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpO1xuXHRcdH1cblxuXHRcdCQkLnNlbGVjdENoYXJ0Lmh0bWwoXCJcIikuY2xhc3NlZChiaW5kdG8uY2xhc3NuYW1lLCB0cnVlKTtcblxuXHRcdC8vIEluaXQgZGF0YSBhcyB0YXJnZXRzXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpO1xuXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0YXJnZXRzIHRvIGhpZGUgaWYgbmVlZGVkXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlblRhcmdldElkcyhcblx0XHRcdFx0Y29uZmlnLmRhdGFfaGlkZSA9PT0gdHJ1ZSA/XG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5kYXRhX2hpZGVcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGlmIChjb25maWcubGVnZW5kX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyhcblx0XHRcdFx0Y29uZmlnLmxlZ2VuZF9oaWRlID09PSB0cnVlID9cblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmxlZ2VuZF9oaWRlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gZ2F1Z2UsIGhpZGUgbGVnZW5kIC8vIFRPRE86IGZpeFxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgc2l6ZXMgYW5kIHNjYWxlc1xuXHRcdCQkLnVwZGF0ZVNpemVzKCk7XG5cdFx0JCQudXBkYXRlU2NhbGVzKHRydWUpO1xuXG5cdFx0Ly8gU2V0IGRvbWFpbnMgZm9yIGVhY2ggc2NhbGVcblx0XHRpZiAoJCQueCkge1xuXHRcdFx0JCQueC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xuXHRcdFx0JCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG5cblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXG5cdFx0XHQkJC5vcmdYRG9tYWluID0gJCQueC5kb21haW4oKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueSkge1xuXHRcdFx0JCQueS5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZLmRvbWFpbigkJC55LmRvbWFpbigpKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueTIpIHtcblx0XHRcdCQkLnkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQueTIuZG9tYWluKCkpO1xuXHRcdH1cblxuXHRcdC8vIC0tIEJhc2ljIEVsZW1lbnRzIC0tXG5cdFx0JCQuc3ZnID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpXG5cdFx0XHQuc3R5bGUoXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKVxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLmlucHV0VHlwZSkge1xuXHRcdFx0Y29uc3QgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuXG5cdFx0XHQkJC5zdmdcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2VlbnRlclwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3ZlciwgJCQpKVxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2VsZWF2ZVwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3V0LCAkJCkpO1xuXHRcdH1cblxuXHRcdGNvbmZpZy5zdmdfY2xhc3NuYW1lICYmICQkLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xuXG5cdFx0Ly8gRGVmaW5lIGRlZnNcblx0XHQkJC5kZWZzID0gJCQuc3ZnLmFwcGVuZChcImRlZnNcIik7XG5cblx0XHQkJC5jbGlwQ2hhcnQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZCk7XG5cdFx0JCQuY2xpcFhBeGlzID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWRGb3JYQXhpcyk7XG5cdFx0JCQuY2xpcFlBeGlzID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWRGb3JZQXhpcyk7XG5cdFx0JCQuY2xpcEdyaWQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZEZvckdyaWQpO1xuXG5cdFx0Ly8gc2V0IGNvbG9yIHBhdHRlcm5zXG5cdFx0aWYgKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucykge1xuXHRcdFx0JCQucGF0dGVybnMuZm9yRWFjaChwID0+ICQkLmRlZnMuYXBwZW5kKCgpID0+IHAubm9kZSkpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcblxuXHRcdC8vIERlZmluZSByZWdpb25zXG5cdFx0Y29uc3QgbWFpbiA9ICQkLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XG5cblx0XHQkJC5tYWluID0gbWFpbjtcblxuXHRcdC8vIGluaXRpYWxpemUgc3ViY2hhcnQgd2hlbiBzdWJjaGFydCBzaG93IG9wdGlvbiBpcyBzZXRcblx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5pbml0U3ViY2hhcnQoKTtcblxuXHRcdCQkLmluaXRUb29sdGlwICYmICQkLmluaXRUb29sdGlwKCk7XG5cdFx0JCQuaW5pdExlZ2VuZCAmJiAkJC5pbml0TGVnZW5kKCk7XG5cdFx0JCQuaW5pdFRpdGxlICYmICQkLmluaXRUaXRsZSgpO1xuXG5cdFx0Ly8gLS0gTWFpbiBSZWdpb24gLS1cblxuXHRcdC8vIHRleHQgd2hlbiBlbXB0eVxuXHRcdGlmIChjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0KSB7XG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy50ZXh0fSAke0NMQVNTLmVtcHR5fWApXG5cdFx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgLy8gaG9yaXpvbnRhbCBjZW50ZXJpbmcgb2YgdGV4dCBhdCB4IHBvc2l0aW9uIGluIGFsbCBicm93c2Vycy5cblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cblx0XHR9XG5cblx0XHQvLyBSZWdpb25zXG5cdFx0JCQuaW5pdFJlZ2lvbigpO1xuXG5cdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAnZmFsc2UnXG5cdFx0IWNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcblxuXHRcdC8vIERlZmluZSBnIGZvciBjaGFydCBhcmVhXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydClcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKTtcblxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGluaXRcIik7XG5cblx0XHQvLyBDb3ZlciB3aG9sZSB3aXRoIHJlY3RzIGZvciBldmVudHNcblx0XHQkJC5pbml0RXZlbnRSZWN0KCk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnRcblx0XHQkJC5pbml0Q2hhcnRFbGVtZW50cygpO1xuXG5cdFx0Ly8gR3JpZHNcblx0XHQkJC5pbml0R3JpZCgpO1xuXG5cdFx0Ly8gaWYgem9vbSBwcml2aWxlZ2VkLCBpbnNlcnQgcmVjdCB0byBmb3JlZnJvbnRcblx0XHQvLyBUT0RPOiBpcyB0aGlzIG5lZWRlZD9cblx0XHRtYWluLmluc2VydChcInJlY3RcIiwgY29uZmlnLnpvb21fcHJpdmlsZWdlZCA/IG51bGwgOiBgZy4ke0NMQVNTLnJlZ2lvbnN9YClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbVJlY3QpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XG5cblx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xuXHRcdGNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcblxuXHRcdC8vIFNldCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcblx0XHQkJC51cGRhdGVEaW1lbnNpb24oKTtcblxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xuXHRcdGNvbmZpZy5vbmluaXQuY2FsbCgkJCk7XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlLFxuXHRcdFx0aW5pdGlhbGl6aW5nOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyBkYXRhLm9ubWluL21heCBjYWxsYmFja1xuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4RGF0YSgpO1xuXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKTtcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1heCwgJCQsIG1pbk1heC5tYXgpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgcmVzaXplIGV2ZW50XG5cdFx0JCQuYmluZFJlc2l6ZSgpO1xuXG5cdFx0Ly8gZXhwb3J0IGVsZW1lbnQgb2YgdGhlIGNoYXJ0XG5cdFx0JCQuYXBpLmVsZW1lbnQgPSAkJC5zZWxlY3RDaGFydC5ub2RlKCk7XG5cdH1cblxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRbXCJCYXJcIiwgXCJMaW5lXCIsIFwiQnViYmxlXCIsIFwiQXJjXCIsIFwiR2F1Z2VcIiwgXCJQaWVcIiwgXCJSYWRhclwiXS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0JCRbYGluaXQke3Z9YF0oKTtcblx0XHR9KTtcblxuXHRcdG5vdEVtcHR5KCQkLmNvbmZpZy5kYXRhX2xhYmVscykgJiYgJCQuaW5pdFRleHQoKTtcblx0fVxuXG5cdGdldENoYXJ0RWxlbWVudHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGNoYXJ0OiAkJC5zZWxlY3RDaGFydCxcblx0XHRcdHN2ZzogJCQuc3ZnLFxuXHRcdFx0ZGVmczogJCQuZGVmcyxcblx0XHRcdG1haW46ICQkLm1haW4sXG5cdFx0XHR0b29sdGlwOiAkJC50b29sdGlwLFxuXHRcdFx0bGVnZW5kOiAkJC5sZWdlbmQsXG5cdFx0XHR0aXRsZTogJCQudGl0bGUsXG5cdFx0XHRncmlkOiAkJC5ncmlkLFxuXHRcdFx0YXJjOiAkJC5hcmNzLFxuXHRcdFx0YmFyOiB7XG5cdFx0XHRcdGJhcnM6ICQkLm1haW5CYXJcblx0XHRcdH0sXG5cdFx0XHRsaW5lOiB7XG5cdFx0XHRcdGxpbmVzOiAkJC5tYWluTGluZSxcblx0XHRcdFx0YXJlYXM6ICQkLm1haW5BcmVhLFxuXHRcdFx0XHRjaXJjbGVzOiAkJC5tYWluQ2lyY2xlXG5cdFx0XHR9LFxuXHRcdFx0dGV4dDoge1xuXHRcdFx0XHR0ZXh0czogJCQubWFpblRleHRcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0c21vb3RoTGluZXMoZWwsIHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PT0gXCJncmlkXCIpIHtcblx0XHRcdGVsLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0Y29uc3QgW3gxLCB4MiwgeTEsIHkyXSA9IFtcIngxXCIsIFwieDJcIiwgXCJ5MVwiLCBcInkyXCJdXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IE1hdGguY2VpbChnLmF0dHIodikpKTtcblxuXHRcdFx0XHRnLmF0dHIoe3gxLCB4MiwgeTEsIHkyfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0IElmIGlzIGNhbGxlZCBhdCBpbml0aWFsaXphdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlU2l6ZXMoaXNJbml0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcblxuXHRcdGNvbnN0IGxlZ2VuZCA9IHtcblx0XHRcdHdpZHRoOiAkJC5sZWdlbmQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogJCQubGVnZW5kID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAwXG5cdFx0fTtcblxuXHRcdGNvbnN0IGxlZ2VuZEhlaWdodEZvckJvdHRvbSA9ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IDAgOiBsZWdlbmQuaGVpZ2h0O1xuXHRcdGNvbnN0IHhBeGlzSGVpZ2h0ID0gaXNSb3RhdGVkIHx8IGhhc0FyYyA/IDAgOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XG5cblx0XHRjb25zdCBzdWJjaGFydFhBeGlzSGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ICYmIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3cgP1xuXHRcdFx0eEF4aXNIZWlnaHQgOiAzMDtcblx0XHRjb25zdCBzdWJjaGFydEhlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICFoYXNBcmMgP1xuXHRcdFx0KGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCArIHN1YmNoYXJ0WEF4aXNIZWlnaHQpIDogMDtcblxuXHRcdCFpc0luaXQgJiYgJCQuc2V0Q29udGFpbmVyU2l6ZSgpO1xuXG5cdFx0Ly8gZm9yIG1haW5cblx0XHQkJC5tYXJnaW4gPSBpc1JvdGF0ZWQgPyB7XG5cdFx0XHR0b3A6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLFxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXG5cdFx0XHRib3R0b206ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieVwiKSArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXG5cdFx0XHRsZWZ0OiBzdWJjaGFydEhlaWdodCArIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkpXG5cdFx0fSA6IHtcblx0XHRcdHRvcDogNCArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksIC8vIGZvciB0b3AgdGljayB0ZXh0XG5cdFx0XHRyaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcblx0XHRcdGJvdHRvbTogeEF4aXNIZWlnaHQgKyBzdWJjaGFydEhlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXG5cdFx0XHRsZWZ0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KClcblx0XHR9O1xuXG5cdFx0Ly8gZm9yIHN1YmNoYXJ0XG5cdFx0JCQubWFyZ2luMiA9IGlzUm90YXRlZCA/IHtcblx0XHRcdHRvcDogJCQubWFyZ2luLnRvcCxcblx0XHRcdHJpZ2h0OiBOYU4sXG5cdFx0XHRib3R0b206IDIwICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuXHRcdFx0bGVmdDogJCQucm90YXRlZF9wYWRkaW5nX2xlZnRcblx0XHR9IDoge1xuXHRcdFx0dG9wOiAkJC5jdXJyZW50SGVpZ2h0IC0gc3ViY2hhcnRIZWlnaHQgLSBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuXHRcdFx0bGVmdDogJCQubWFyZ2luLmxlZnRcblx0XHR9O1xuXG5cdFx0Ly8gZm9yIGxlZ2VuZFxuXHRcdCQkLm1hcmdpbjMgPSB7XG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogMFxuXHRcdH07XG5cblx0XHQkJC51cGRhdGVTaXplRm9yTGVnZW5kICYmICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQobGVnZW5kKTtcblxuXHRcdCQkLndpZHRoID0gJCQuY3VycmVudFdpZHRoIC0gJCQubWFyZ2luLmxlZnQgLSAkJC5tYXJnaW4ucmlnaHQ7XG5cdFx0JCQuaGVpZ2h0ID0gJCQuY3VycmVudEhlaWdodCAtICQkLm1hcmdpbi50b3AgLSAkJC5tYXJnaW4uYm90dG9tO1xuXG5cdFx0aWYgKCQkLndpZHRoIDwgMCkge1xuXHRcdFx0JCQud2lkdGggPSAwO1xuXHRcdH1cblxuXHRcdGlmICgkJC5oZWlnaHQgPCAwKSB7XG5cdFx0XHQkJC5oZWlnaHQgPSAwO1xuXHRcdH1cblxuXHRcdCQkLndpZHRoMiA9IGlzUm90YXRlZCA/XG5cdFx0XHQkJC5tYXJnaW4ubGVmdCAtICQkLnJvdGF0ZWRfcGFkZGluZ19sZWZ0IC0gJCQucm90YXRlZF9wYWRkaW5nX3JpZ2h0IDogJCQud2lkdGg7XG5cblx0XHQkJC5oZWlnaHQyID0gaXNSb3RhdGVkID9cblx0XHRcdCQkLmhlaWdodCA6ICQkLmN1cnJlbnRIZWlnaHQgLSAkJC5tYXJnaW4yLnRvcCAtICQkLm1hcmdpbjIuYm90dG9tO1xuXG5cdFx0aWYgKCQkLndpZHRoMiA8IDApIHtcblx0XHRcdCQkLndpZHRoMiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmhlaWdodDIgPCAwKSB7XG5cdFx0XHQkJC5oZWlnaHQyID0gMDtcblx0XHR9XG5cblx0XHQvLyBmb3IgYXJjXG5cdFx0JCQuYXJjV2lkdGggPSAkJC53aWR0aCAtICgkJC5pc0xlZ2VuZFJpZ2h0ID8gbGVnZW5kLndpZHRoICsgMTAgOiAwKTtcblx0XHQkJC5hcmNIZWlnaHQgPSAkJC5oZWlnaHQgLSAoJCQuaXNMZWdlbmRSaWdodCA/IDAgOiAxMCk7XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSkge1xuXHRcdFx0JCQuYXJjSGVpZ2h0ICs9ICQkLmhlaWdodCAtICQkLmdldEdhdWdlTGFiZWxIZWlnaHQoKTtcblx0XHR9XG5cblx0XHQkJC51cGRhdGVSYWRpdXMgJiYgJCQudXBkYXRlUmFkaXVzKCk7XG5cblx0XHRpZiAoJCQuaXNMZWdlbmRSaWdodCAmJiBoYXNBcmMpIHtcblx0XHRcdCQkLm1hcmdpbjMubGVmdCA9ICQkLmFyY1dpZHRoIC8gMiArICQkLnJhZGl1c0V4cGFuZGVkICogMS4xO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGFyZ2V0ZWQgZWxlbWVudCB3aXRoIGdpdmVuIGRhdGFcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHMgRGF0YSBvYmplY3QgZm9ybWF0dGVkIGFzICd0YXJnZXQnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVUYXJnZXRzKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQvLyBUZXh0XG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XG5cblx0XHQvLyBCYXJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpO1xuXG5cdFx0Ly8gTGluZVxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpO1xuXG5cdFx0Ly8gQXJjICYgUmFkYXJcblx0XHQkJC5oYXNBcmNUeXBlKHRhcmdldHMpICYmIChcblx0XHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSA/XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cylcblx0XHQpO1xuXG5cdFx0Ly8gU3ViIENoYXJ0XG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0ICYmXG5cdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQodGFyZ2V0cyk7XG5cblx0XHQvLyBGYWRlLWluIGVhY2ggY2hhcnRcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3BsYXkgdGFyZ2V0ZWQgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNob3dUYXJnZXRzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxuXHRcdFx0LmZpbHRlcihkID0+ICQkLmlzVGFyZ2V0VG9TaG93KGQuaWQpKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKCQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH1cblxuXHRnZXRXaXRoT3B0aW9uKG9wdGlvbnMpIHtcblx0XHRjb25zdCB3aXRoT3B0aW9ucyA9IHtcblx0XHRcdFk6IHRydWUsXG5cdFx0XHRTdWJjaGFydDogdHJ1ZSxcblx0XHRcdFRyYW5zaXRpb246IHRydWUsXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXG5cdFx0XHREaW1lbnNpb246IHRydWUsXG5cdFx0XHRUcmltWERvbWFpbjogdHJ1ZSxcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHRVcGRhdGVYRG9tYWluOiBmYWxzZSxcblx0XHRcdFVwZGF0ZU9yZ1hEb21haW46IGZhbHNlLFxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcblx0XHRcdFVwZGF0ZVhBeGlzOiBcIlVwZGF0ZVhEb21haW5cIixcblx0XHRcdFRyYW5zaXRpb25Gb3JFeGl0OiBcIlRyYW5zaXRpb25cIixcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxuXHRcdH07XG5cblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0bGV0IGRlZlZhbCA9IHdpdGhPcHRpb25zW2tleV07XG5cblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XG5cdFx0XHRcdGRlZlZhbCA9IHdpdGhPcHRpb25zW2RlZlZhbF07XG5cdFx0XHR9XG5cblx0XHRcdHdpdGhPcHRpb25zW2tleV0gPSBnZXRPcHRpb24ob3B0aW9ucywgYHdpdGgke2tleX1gLCBkZWZWYWwpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHdpdGhPcHRpb25zO1xuXHR9XG5cblx0cmVkcmF3KG9wdGlvbnMgPSB7fSwgdHJhbnNpdGlvbnNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xuXHRcdGNvbnN0IGZsb3cgPSBvcHRpb25zLmZsb3c7XG5cdFx0Y29uc3Qgd3RoID0gJCQuZ2V0V2l0aE9wdGlvbihvcHRpb25zKTtcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xuXHRcdGNvbnN0IGR1cmF0aW9uRm9yRXhpdCA9IHd0aC5UcmFuc2l0aW9uRm9yRXhpdCA/IGR1cmF0aW9uIDogMDtcblx0XHRjb25zdCBkdXJhdGlvbkZvckF4aXMgPSB3dGguVHJhbnNpdGlvbkZvckF4aXMgPyBkdXJhdGlvbiA6IDA7XG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpO1xuXG5cdFx0IShpbml0aWFsaXppbmcgJiYgY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSAmJlxuXHRcdFx0JCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcblxuXHRcdCQkLnVwZGF0ZVNpemVzKGluaXRpYWxpemluZyk7XG5cblx0XHQvLyB1cGRhdGUgbGVnZW5kIGFuZCB0cmFuc2Zvcm0gZWFjaCBnXG5cblx0XHRpZiAod3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpIHtcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZCgkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCBvcHRpb25zLCB0cmFuc2l0aW9ucyk7XG5cdFx0fSBlbHNlIGlmICh3dGguRGltZW5zaW9uKSB7XG5cdFx0XHQvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxuXHRcdFx0Ly8gbm8gbmVlZCB0byB1cGRhdGUgYXhpcyBpbiBpdCBiZWNhdXNlIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGluIHJlZHJhdygpXG5cdFx0XHQkJC51cGRhdGVEaW1lbnNpb24odHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGF4aXNcblx0XHQvLyBAVE9ETzogTWFrZSAnaW5pdCcgc3RhdGUgdG8gYmUgYWNjZXNzaWJsZSBldmVyeXdoZXJlIG5vdCBwYXNzaW5nIGFzIGFyZ3VtZW50LlxuXHRcdCQkLnJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaW5pdGlhbGl6aW5nKTtcblxuXHRcdC8vIHVwZGF0ZSBjaXJjbGVZIGJhc2VkIG9uIHVwZGF0ZWQgcGFyYW1ldGVyc1xuXHRcdCQkLnVwZGF0ZUNpcmNsZVkoKTtcblxuXHRcdC8vIHhncmlkIGZvY3VzXG5cdFx0JCQudXBkYXRlWGdyaWRGb2N1cygpO1xuXG5cdFx0Ly8gRGF0YSBlbXB0eSBsYWJlbCBwb3NpdGlvbmluZyBhbmQgdGV4dC5cblx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLndpZHRoIC8gMilcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5oZWlnaHQgLyAyKVxuXHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyBcIm5vbmVcIiA6IG51bGwpO1xuXG5cdFx0Ly8gZ3JpZFxuXHRcdCQkLnVwZGF0ZUdyaWQoZHVyYXRpb24pO1xuXG5cdFx0Ly8gcmVjdCBmb3IgcmVnaW9uc1xuXHRcdCQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XG5cblx0XHQvLyBiYXJzXG5cdFx0JCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcblx0XHQkJC51cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk7XG5cdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xuXHRcdCQkLnVwZGF0ZUNpcmNsZSgpO1xuXG5cdFx0Ly8gdGV4dFxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcblxuXHRcdC8vIHRpdGxlXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcblxuXHRcdC8vIGFyY1xuXHRcdCQkLmFyY3MgJiYgJCQucmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHd0aC5UcmFuc2Zvcm0pO1xuXG5cdFx0Ly8gcmFkYXJcblx0XHQkJC5yYWRhcnMgJiYgJCQucmVkcmF3UmFkYXIoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3Rcblx0XHQkJC5tYWluVGV4dCAmJiBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfWApXG5cdFx0XHQuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSlcblx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGV2ZW50IHJlY3RzIHdpbGwgcmVkcmF3biB3aGVuIGZsb3cgY2FsbGVkXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICFmbG93ICYmIHd0aC5FdmVudFJlY3QpIHtcblx0XHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xuXHRcdH1cblxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRyZWRyYXdcIiwgb3B0aW9ucywgZHVyYXRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZHJhdyBheGlzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzVG9TaG93IHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxuXHQgKiBAcGFyYW0ge09iamVjdH0gd3RoXG5cdCAqIEBwYXJhbSB7T2piZWN0fSB0cmFuc2l0aW9uc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZmxvd1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpc0luaXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGhhc0FyY1R5cGUgPSAkJC5oYXNBcmNUeXBlKCk7XG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhJCQuem9vbVNjYWxlO1xuXHRcdGxldCB0aWNrVmFsdWVzO1xuXHRcdGxldCBpbnRlcnZhbEZvckN1bGxpbmc7XG5cdFx0bGV0IHhEb21haW5Gb3Jab29tO1xuXG5cdFx0aWYgKCFoYXNab29tICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0JCQueC5kb21haW4oWzAsICQkLmF4ZXMueC5zZWxlY3RBbGwoXCIudGlja1wiKS5zaXplKCldKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueCAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xuXHRcdFx0IWhhc1pvb20gJiZcblx0XHRcdFx0JCQudXBkYXRlWERvbWFpbih0YXJnZXRzVG9TaG93LCB3dGguVXBkYXRlWERvbWFpbiwgd3RoLlVwZGF0ZU9yZ1hEb21haW4sIHd0aC5UcmltWERvbWFpbik7XG5cblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xuXHRcdFx0XHR0aWNrVmFsdWVzID0gJCQuYXhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICgkJC54QXhpcykge1xuXHRcdFx0JCQueEF4aXMudGlja1ZhbHVlcyhbXSk7XG5cdFx0XHQkJC5zdWJYQXhpcy50aWNrVmFsdWVzKFtdKTtcblx0XHR9XG5cblx0XHRpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhZmxvdykge1xuXHRcdFx0eERvbWFpbkZvclpvb20gPSAkJC54Lm9yZ0RvbWFpbigpO1xuXHRcdH1cblxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRjb25zdCBheGlzID0gJCRba2V5XTtcblxuXHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcblx0XHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX2NvdW50YF07XG5cblx0XHRcdFx0YXhpcy5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBrZXksIHhEb21haW5Gb3Jab29tKSk7XG5cblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXMuZG9tYWluKCk7XG5cblx0XHRcdFx0XHQkJFtgJHtrZXl9QXhpc2BdLnRpY2tWYWx1ZXMoXG5cdFx0XHRcdFx0XHQkJC5heGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcblx0XHRcdFx0XHRcdFx0ZG9tYWluLFxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXG5cdFx0XHRcdFx0XHRcdCQkLmlzVGltZVNlcmllc1koKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGF4ZXNcblx0XHQkJC5heGlzLnJlZHJhdyh0cmFuc2l0aW9ucywgaGFzQXJjVHlwZSwgaXNJbml0KTtcblxuXHRcdC8vIFVwZGF0ZSBheGlzIGxhYmVsXG5cdFx0JCQuYXhpcy51cGRhdGVMYWJlbHMod3RoLlRyYW5zaXRpb24pO1xuXG5cdFx0Ly8gc2hvdy9oaWRlIGlmIG1hbnVhbCBjdWxsaW5nIG5lZWRlZFxuXHRcdGlmICgod3RoLlVwZGF0ZVhEb21haW4gfHwgd3RoLlVwZGF0ZVhBeGlzKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmIHRpY2tWYWx1ZXMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRpY2tWYWx1ZXMubGVuZ3RoIC8gaSA8IGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nX21heCkge1xuXHRcdFx0XHRcdFx0aW50ZXJ2YWxGb3JDdWxsaW5nID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLmF4aXNYfSAudGljayB0ZXh0YCkuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSB0aWNrVmFsdWVzLmluZGV4T2YoZCk7XG5cblx0XHRcdFx0XHRpbmRleCA+PSAwICYmXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zdHlsZShcImRpc3BsYXlcIiwgaW5kZXggJSBpbnRlcnZhbEZvckN1bGxpbmcgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQuc3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXhpc1h9IC50aWNrIHRleHRgKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgc3ViIGRvbWFpblxuXHRcdGlmICh3dGguWSkge1xuXHRcdFx0JCQuc3ViWSAmJiAkJC5zdWJZLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInkyXCIpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgcmVkcmF3IGxpc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNUb1Nob3cgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmbG93XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkdXJhdGlvblxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0c1RvU2hvdywgZmxvdywgZHVyYXRpb24sIHdpdGhTdWJjaGFydCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcblxuXHRcdC8vIHN1YmNoYXJ0XG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQucmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZmxvd1xuXHRcdGNvbnN0IGZsb3dGbiA9IGZsb3cgJiYgJCQuZ2VuZXJhdGVGbG93KHtcblx0XHRcdHRhcmdldHM6IHRhcmdldHNUb1Nob3csXG5cdFx0XHRmbG93OiBmbG93LFxuXHRcdFx0ZHVyYXRpb246IGZsb3cuZHVyYXRpb24sXG5cdFx0XHRzaGFwZSxcblx0XHRcdHh2OiAkJC54di5iaW5kKCQkKVxuXHRcdH0pO1xuXHRcdGNvbnN0IGlzVHJhbnNpdGlvbiA9IChkdXJhdGlvbiB8fCBmbG93Rm4pICYmICQkLmlzVGFiVmlzaWJsZSgpO1xuXG5cdFx0Ly8gcmVkcmF3IGxpc3Rcblx0XHRjb25zdCByZWRyYXdMaXN0ID0gJCQuZ2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pO1xuXG5cdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gYWZ0ZXIgcmVkcmF3IGVuZHNcblx0XHRjb25zdCBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyAoKSA9PiB7XG5cdFx0XHRmbG93Rm4gJiYgZmxvd0ZuKCk7XG5cdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkKTtcblx0XHR9IDogbnVsbDtcblxuXHRcdGlmIChhZnRlclJlZHJhdykge1xuXHRcdFx0Ly8gT25seSB1c2UgdHJhbnNpdGlvbiB3aGVuIGN1cnJlbnQgdGFiIGlzIHZpc2libGUuXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdC8vIFdhaXQgZm9yIGVuZCBvZiB0cmFuc2l0aW9ucyBmb3IgY2FsbGJhY2tcblx0XHRcdFx0Y29uc3Qgd2FpdEZvckRyYXcgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcblxuXHRcdFx0XHQvLyB0cmFuc2l0aW9uIHNob3VsZCBiZSBkZXJpdmVkIGZyb20gb25lIHRyYW5zaXRpb25cblx0XHRcdFx0ZDNUcmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0cmVkcmF3TGlzdFxuXHRcdFx0XHRcdFx0XHQucmVkdWNlKChhY2MsIHQxKSA9PiBhY2MuY29uY2F0KHQxKSwgW10pXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5jYWxsKHdhaXRGb3JEcmF3LCBhZnRlclJlZHJhdyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZnRlclJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXG5cdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdCQkLndpdGhvdXRGYWRlSW5baWRdID0gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNoYXBlIGRyYXcgZnVuY3Rpb25cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0RHJhd1NoYXBlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGhhc1JhZGFyID0gJCQuaGFzVHlwZShcInJhZGFyXCIpO1xuXHRcdGNvbnN0IHNoYXBlID0ge3R5cGU6IHt9LCBpbmRpY2VzOiB7fX07XG5cblx0XHQvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcblx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSB8fCAkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpKSB7XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpO1xuXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmxpbmUgPSBpbmRpY2VzO1xuXHRcdFx0c2hhcGUudHlwZS5saW5lID0gJCQuZ2VuZXJhdGVEcmF3TGluZSA/ICQkLmdlbmVyYXRlRHJhd0xpbmUoaW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQXJlYVR5cGUpO1xuXG5cdFx0XHRcdHNoYXBlLmluZGljZXMuYXJlYSA9IGluZGljZXM7XG5cdFx0XHRcdHNoYXBlLnR5cGUuYXJlYSA9ICQkLmdlbmVyYXRlRHJhd0FyZWEgPyAkJC5nZW5lcmF0ZURyYXdBcmVhKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0JhclR5cGUpO1xuXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmJhciA9IGluZGljZXM7XG5cdFx0XHRzaGFwZS50eXBlLmJhciA9ICQkLmdlbmVyYXRlRHJhd0JhciA/ICQkLmdlbmVyYXRlRHJhd0JhcihpbmRpY2VzKSA6IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRzaGFwZS5wb3MgPSB7XG5cdFx0XHR4Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgdHJ1ZSksXG5cdFx0XHR5Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgZmFsc2UpLFxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBjaXJjbGUgeC95IGZ1bmN0aW9ucyBkZXBlbmRpbmcgb24gdXBkYXRlZCBwYXJhbXNcblx0XHRcdGN4OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVggOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpKS5iaW5kKCQkKSxcblx0XHRcdGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpKS5iaW5kKCQkKVxuXHRcdH07XG5cblx0XHRyZXR1cm4gc2hhcGU7XG5cdH1cblxuXHRnZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaGFzQXJjVHlwZSA9ICQkLmhhc0FyY1R5cGUoKTtcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xuXHRcdGNvbnN0IGxpc3QgPSBbXTtcblxuXHRcdGlmICghaGFzQXJjVHlwZSkge1xuXHRcdFx0Y29uc3Qge2FyZWEsIGJhciwgbGluZX0gPSBzaGFwZS50eXBlO1xuXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0dyaWQoaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25maWcucmVnaW9ucy5sZW5ndGgpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1JlZ2lvbihpc1RyYW5zaXRpb24pKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0JhcihiYXIsIGlzVHJhbnNpdGlvbikpO1xuXG5cdFx0XHRub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpICYmXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdUZXh0KHhGb3JUZXh0LCB5Rm9yVGV4dCwgZmxvdywgaXNUcmFuc2l0aW9uKSk7XG5cdFx0fVxuXG5cdFx0KCFoYXNBcmNUeXBlIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKSkgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0NpcmNsZShjeCwgY3ksIGlzVHJhbnNpdGlvbiwgZmxvd0ZuKSk7XG5cblx0XHRyZXR1cm4gbGlzdDtcblx0fVxuXG5cdHVwZGF0ZUFuZFJlZHJhdyhvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCB0cmFuc2l0aW9ucztcblxuXHRcdC8vIHNhbWUgd2l0aCByZWRyYXdcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XG5cdFx0b3B0aW9ucy53aXRoVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zZm9ybVwiLCBmYWxzZSk7XG5cdFx0b3B0aW9ucy53aXRoTGVnZW5kID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aExlZ2VuZFwiLCBmYWxzZSk7XG5cblx0XHQvLyBOT1Qgc2FtZSB3aXRoIHJlZHJhd1xuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZVhEb21haW4gPSB0cnVlO1xuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZU9yZ1hEb21haW4gPSB0cnVlO1xuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JFeGl0ID0gZmFsc2U7XG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIG9wdGlvbnMud2l0aFRyYW5zaXRpb24pO1xuXG5cdFx0Ly8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxuXHRcdGlmICghKG9wdGlvbnMud2l0aExlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpKSB7XG5cdFx0XHR0cmFuc2l0aW9ucyA9ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhcblx0XHRcdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvckF4aXMgPyBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiA6IDBcblx0XHRcdCk7XG5cblx0XHRcdC8vIFVwZGF0ZSBzY2FsZXNcblx0XHRcdCQkLnVwZGF0ZVNjYWxlcygpO1xuXHRcdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcblx0XHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xuXHRcdCQkLnJlZHJhdyhvcHRpb25zLCB0cmFuc2l0aW9ucyk7XG5cdH1cblxuXHRyZWRyYXdXaXRob3V0UmVzY2FsZSgpIHtcblx0XHR0aGlzLnJlZHJhdyh7XG5cdFx0XHR3aXRoWTogZmFsc2UsXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRpc1RpbWVTZXJpZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlID09PSBcInRpbWVzZXJpZXNcIjtcblx0fVxuXG5cdGlzQ2F0ZWdvcml6ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlLmluZGV4T2YoXCJjYXRlZ29yeVwiKSA+PSAwIHx8IHRoaXMuaGFzVHlwZShcInJhZGFyXCIpO1xuXHR9XG5cblx0aXNDdXN0b21YKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gISQkLmlzVGltZVNlcmllcygpICYmIChjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSk7XG5cdH1cblxuXHRpc1RpbWVTZXJpZXNZKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3lfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XG5cdH1cblxuXHRnZXRUcmFuc2xhdGUodGFyZ2V0LCBpbmRleCA9IDApIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHBhZGRpbmcgPSAwO1xuXHRcdGxldCB4O1xuXHRcdGxldCB5O1xuXG5cdFx0aWYgKGluZGV4ICYmIC9eKHh8eTI/KSQvLnRlc3QodGFyZ2V0KSkge1xuXHRcdFx0cGFkZGluZyA9ICQkLmdldEF4aXNTaXplKHRhcmdldCkgKiBpbmRleDtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ID09PSBcIm1haW5cIikge1xuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi5sZWZ0KTtcblx0XHRcdHkgPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4udG9wKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJjb250ZXh0XCIpIHtcblx0XHRcdHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4yLmxlZnQpO1xuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbjIudG9wKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJsZWdlbmRcIikge1xuXHRcdFx0eCA9ICQkLm1hcmdpbjMubGVmdDtcblx0XHRcdHkgPSAkJC5tYXJnaW4zLnRvcDtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ4XCIpIHtcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAtcGFkZGluZyA6IDA7XG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodCArIHBhZGRpbmc7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieVwiKSB7XG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IC1wYWRkaW5nO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/ICQkLmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInkyXCIpIHtcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogJCQud2lkdGggKyBwYWRkaW5nO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJzdWJ4XCIpIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcImFyY1wiKSB7XG5cdFx0XHR4ID0gJCQuYXJjV2lkdGggLyAyO1xuXHRcdFx0eSA9ICQkLmFyY0hlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwicmFkYXJcIikge1xuXHRcdFx0Y29uc3QgZGlmZiA9ICgkJC5hcmNXaWR0aCAtICQkLmFyY0hlaWdodCkgLyAyO1xuXG5cdFx0XHR4ID0gTWF0aC5tYXgoZGlmZiwgMCkgKyA0O1xuXHRcdFx0eSA9IGRpZmYgPCAwID8gTWF0aC5hYnMoZGlmZikgOiBhc0hhbGZQaXhlbCgkJC5tYXJnaW4udG9wKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KWA7XG5cdH1cblxuXHRpbml0aWFsT3BhY2l0eShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXG5cdFx0XHR0aGlzLndpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xuXHR9XG5cblx0aW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCAmJlxuXHRcdFx0dGhpcy53aXRob3V0RmFkZUluW2QuaWRdID8gdGhpcy5vcGFjaXR5Rm9yQ2lyY2xlKGQpIDogXCIwXCI7XG5cdH1cblxuXHRvcGFjaXR5Rm9yQ2lyY2xlKGQpIHtcblx0XHRjb25zdCBvcGFjaXR5ID0gdGhpcy5jb25maWcucG9pbnRfc2hvdyA/IFwiMVwiIDogXCIwXCI7XG5cblx0XHRyZXR1cm4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkgP1xuXHRcdFx0KHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8IHRoaXMuaXNTY2F0dGVyVHlwZShkKSA/XG5cdFx0XHRcdFwiMC41XCIgOiBvcGFjaXR5KSA6IFwiMFwiO1xuXHR9XG5cblx0b3BhY2l0eUZvclRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzRGF0YUxhYmVsKCkgPyBcIjFcIiA6IFwiMFwiO1xuXHR9XG5cblx0eHgoZCkge1xuXHRcdGNvbnN0IGZuID0gdGhpcy5jb25maWcuem9vbV9lbmFibGVkICYmIHRoaXMuem9vbVNjYWxlID9cblx0XHRcdHRoaXMuem9vbVNjYWxlIDogdGhpcy54O1xuXG5cdFx0cmV0dXJuIGQgPyBmbihkLngpIDogbnVsbDtcblx0fVxuXG5cdHh2KGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHZhbHVlID0gJCQuZ2V0QmFzZVZhbHVlKGQpO1xuXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHR2YWx1ZSA9ICQkLnBhcnNlRGF0ZSh2YWx1ZSk7XG5cdFx0fSBlbHNlIGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9ICQkLmNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5jZWlsKCQkLngodmFsdWUpKTtcblx0fVxuXG5cdHl2KGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gXCJ5MlwiID8gJCQueTIgOiAkJC55O1xuXG5cdFx0cmV0dXJuIE1hdGguY2VpbCh5U2NhbGUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XG5cdH1cblxuXHRzdWJ4eChkKSB7XG5cdFx0cmV0dXJuIGQgPyB0aGlzLnN1YlgoZC54KSA6IG51bGw7XG5cdH1cblxuXHR0cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgeEF4aXM7XG5cdFx0bGV0IHlBeGlzO1xuXHRcdGxldCB5MkF4aXM7XG5cblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1gpIHtcblx0XHRcdHhBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1g7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhBeGlzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0eEF4aXMgPSB4QXhpcy50cmFuc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZKSB7XG5cdFx0XHR5QXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR5QXhpcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX1gKTtcblxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHlBeGlzID0geUF4aXMudHJhbnNpdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWTIpIHtcblx0XHRcdHkyQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eTJBeGlzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZMn1gKTtcblxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHkyQXhpcyA9IHkyQXhpcy50cmFuc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQubWFpbi50cmFuc2l0aW9uKCkgOiAkJC5tYWluKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XG5cblx0XHR4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInhcIikpO1xuXHRcdHlBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieVwiKSk7XG5cdFx0eTJBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieTJcIikpO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcblx0fVxuXG5cdHRyYW5zZm9ybUFsbCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC50cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk7XG5cblx0XHQkJC5jb25maWcuc3ViY2hhcnRfc2hvdyAmJlxuXHRcdFx0JCQudHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xuXG5cdFx0JCQubGVnZW5kICYmICQkLnRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbik7XG5cdH1cblxuXHR1cGRhdGVTdmdTaXplKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBicnVzaCA9ICQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xuXHRcdGNvbnN0IGJydXNoU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuXHRcdGlmIChicnVzaC5zaXplKCkpIHtcblx0XHRcdGJydXNoU2l6ZS53aWR0aCA9ICticnVzaC5hdHRyKFwid2lkdGhcIik7XG5cdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XG5cdFx0fVxuXG5cdFx0JCQuc3ZnXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmN1cnJlbnRXaWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmN1cnJlbnRIZWlnaHQpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdEFsbChbYCMkeyQkLmNsaXBJZH1gLCBgIyR7JCQuY2xpcElkRm9yR3JpZH1gXSlcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KTtcblxuXHRcdCQkLnN2Zy5zZWxlY3QoYCMkeyQkLmNsaXBJZEZvclhBeGlzfWApXG5cdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WEF4aXNDbGlwWS5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQuZ2V0WEF4aXNDbGlwV2lkdGguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgIyR7JCQuY2xpcElkRm9yWUF4aXN9YClcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5nZXRZQXhpc0NsaXBZLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRZQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XG5cblx0XHQkJC5zdmcuc2VsZWN0KGAjJHskJC5jbGlwSWRGb3JTdWJjaGFydH1gKVxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBicnVzaFNpemUuaGVpZ2h0KTtcblxuXHRcdCQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLnpvb21SZWN0fWApXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KTtcblx0fVxuXG5cdHVwZGF0ZURpbWVuc2lvbih3aXRob3V0QXhpcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICghd2l0aG91dEF4aXMpIHtcblx0XHRcdGlmICgkJC54QXhpcyAmJiAkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRcdCQkLnhBeGlzLmNyZWF0ZSgkJC5heGVzLngpO1xuXHRcdFx0XHQkJC5zdWJYQXhpcy5jcmVhdGUoJCQuYXhlcy5zdWJ4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnlBeGlzICYmICQkLnlBeGlzLmNyZWF0ZSgkJC5heGVzLnkpO1xuXHRcdFx0XHQkJC55MkF4aXMgJiYgJCQueTJBeGlzLmNyZWF0ZSgkJC5heGVzLnkyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBwYXNzICd3aXRob3V0QXhpcycgcGFyYW0gdG8gbm90IGFuaW1hdGUgYXQgdGhlIGluaXQgcmVuZGVyaW5nXG5cdFx0JCQudXBkYXRlU2NhbGVzKHdpdGhvdXRBeGlzKTtcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XG5cdFx0JCQudHJhbnNmb3JtQWxsKGZhbHNlKTtcblx0fVxuXG5cdGJpbmRSZXNpemUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uID0gJCQuZ2VuZXJhdGVSZXNpemUoKTtcblx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoY29uZmlnLm9ucmVzaXplLmJpbmQoJCQpKTtcblxuXHRcdGlmIChjb25maWcucmVzaXplX2F1dG8pIHtcblx0XHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiB7XG5cdFx0XHRcdGlmICgkJC5yZXNpemVUaW1lb3V0KSB7XG5cdFx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcblx0XHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQkLnJlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0JCQuYXBpLmZsdXNoKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fSwgMjAwKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZChjb25maWcub25yZXNpemVkLmJpbmQoJCQpKTtcblxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAkJC5yZXNpemVGdW5jdGlvbik7XG5cdH1cblxuXHRnZW5lcmF0ZVJlc2l6ZSgpIHtcblx0XHRjb25zdCByZXNpemVGdW5jdGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNhbGxSZXNpemVGdW5jdGlvbnMoKSB7XG5cdFx0XHRyZXNpemVGdW5jdGlvbnMuZm9yRWFjaChmID0+IGYoKSk7XG5cdFx0fVxuXG5cdFx0Y2FsbFJlc2l6ZUZ1bmN0aW9ucy5hZGQgPSBmID0+IHJlc2l6ZUZ1bmN0aW9ucy5wdXNoKGYpO1xuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMucmVtb3ZlID0gZiA9PiByZXNpemVGdW5jdGlvbnMuc3BsaWNlKHJlc2l6ZUZ1bmN0aW9ucy5pbmRleE9mKGYpLCAxKTtcblxuXHRcdHJldHVybiBjYWxsUmVzaXplRnVuY3Rpb25zO1xuXHR9XG5cblx0ZW5kYWxsKHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG5cdFx0bGV0IG4gPSAwO1xuXG5cdFx0dHJhbnNpdGlvblxuXHRcdFx0LmVhY2goKCkgPT4gKytuKVxuXHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRcdFx0IS0tbiAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCAuLi5hcmdzKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0Z2VuZXJhdGVXYWl0KCkge1xuXHRcdGxldCB0cmFuc2l0aW9uc1RvV2FpdCA9IFtdO1xuXHRcdGNvbnN0IGYgPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuXHRcdFx0bGV0IHRpbWVyO1xuXG5cdFx0XHRmdW5jdGlvbiBsb29wKCkge1xuXHRcdFx0XHRsZXQgZG9uZSA9IDA7XG5cblx0XHRcdFx0dHJhbnNpdGlvbnNUb1dhaXQuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0XHRpZiAodC5lbXB0eSgpKSB7XG5cdFx0XHRcdFx0XHRkb25lKys7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHQudHJhbnNpdGlvbigpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGRvbmUrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0XHRcdFx0aWYgKGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIDUwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsb29wKCk7XG5cdFx0fTtcblxuXHRcdGYuYWRkID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xuXHRcdFx0aXNBcnJheSh0cmFuc2l0aW9uKSA/XG5cdFx0XHRcdCh0cmFuc2l0aW9uc1RvV2FpdCA9IHRyYW5zaXRpb25zVG9XYWl0LmNvbmNhdCh0cmFuc2l0aW9uKSkgOlxuXHRcdFx0XHR0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHRyYW5zaXRpb24pO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gZjtcblx0fVxuXG5cdHBhcnNlRGF0ZShkYXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBwYXJzZWREYXRlO1xuXG5cdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRwYXJzZWREYXRlID0gZGF0ZTtcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XG5cdFx0XHRwYXJzZWREYXRlID0gJCQuZGF0YVRpbWVGb3JtYXQoJCQuY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihkYXRlKSAmJiAhaXNOYU4oZGF0ZSkpIHtcblx0XHRcdHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJzZWREYXRlIHx8IGlzTmFOKCtwYXJzZWREYXRlKSkge1xuXHRcdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB4ICcke2RhdGV9JyB0byBEYXRlIG9iamVjdGApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZWREYXRlO1xuXHR9XG5cblx0aXNUYWJWaXNpYmxlKCkge1xuXHRcdHJldHVybiAhZG9jdW1lbnQuaGlkZGVuO1xuXHR9XG5cblx0Y29udmVydElucHV0VHlwZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGhhc01vdXNlID0gY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZSAmJiAhaXNNb2JpbGUgPyAoXCJvbm1vdXNlb3ZlclwiIGluIHdpbmRvdykgOiBmYWxzZTtcblx0XHRsZXQgaGFzVG91Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoKSB7XG5cdFx0XHQvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy90b3VjaGV2ZW50cy5qc1xuXHRcdFx0Ly8gT24gSUUxMSB3aXRoIElFOSBlbXVsYXRpb24gbW9kZSwgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgaXMgcmV0dXJuaW5nIHRydWVcblx0XHRcdGhhc1RvdWNoID0gKFwib250b3VjaG1vdmVcIiBpbiB3aW5kb3cpIHx8ICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGhhc01vdXNlICYmIFwibW91c2VcIikgfHwgKGhhc1RvdWNoICYmIFwidG91Y2hcIikgfHwgbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsIHBsdWdpbiBob29rXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxsUGx1Z2luSG9vayhwaGFzZSwgLi4uYXJncykge1xuXHRcdHRoaXMuY29uZmlnLnBsdWdpbnMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdGlmIChwaGFzZSA9PT0gXCIkYmVmb3JlSW5pdFwiKSB7XG5cdFx0XHRcdHYuJCQgPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmFwaS5wbHVnaW5zLnB1c2godik7XG5cdFx0XHR9XG5cblx0XHRcdHZbcGhhc2VdKC4uLmFyZ3MpO1xuXHRcdH0pO1xuXHR9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5cbi8qKlxuICogTWFpbiBjaGFydCBjbGFzcy5cbiAqIC0gTm90ZTogSW5zdGFudGlhdGVkIHZpYSBgYmIuZ2VuZXJhdGUoKWAuXG4gKiBAY2xhc3MgQ2hhcnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XG4gKiAgZGF0YToge1xuICogICAgY29sdW1uczogW1xuICpcdCAgICBbXCJ4XCIsIFwiMjAxNS0xMS0wMlwiLCBcIjIwMTUtMTItMDFcIiwgXCIyMDE2LTAxLTAxXCIsIFwiMjAxNi0wMi0wMVwiLCBcIjIwMTYtMDMtMDFcIl0sXG4gKiBcdCAgICBbXCJjb3VudDFcIiwgMTEsIDgsIDcsIDYsIDUgXSxcbiAqXHQgICAgW1wiY291bnQyXCIsIDksIDMsIDYsIDIsIDggXVxuICogICBdfVxuICogfVxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXG4qL1xuLyoqXG4gKiBBY2Nlc3MgcHJpbWFyeSBub2RlIGVsZW1lbnRzXG4gKiBAbmFtZSBDaGFydCMkXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtPYmplY3R9ICRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmNoYXJ0IFdyYXBwZXIgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuc3ZnIE1haW4gc3ZnIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmRlZnMgRGVmaW5pdGlvbiBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5tYWluIE1haW4gZ3JvdXBpbmcgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudG9vbHRpcCBUb29sdGlwIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxlZ2VuZCBMZWdlbmQgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGl0bGUgVGl0bGUgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuZ3JpZCBHcmlkIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmFyYyBBcmMgZWxlbWVudFxuICogQHByb3BlcnR5IHtPYmplY3R9ICQuYmFyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5iYXIuYmFycyBCYXIgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLmxpbmVcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUubGluZXMgTGluZSBlbGVtZW50c1xuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5hcmVhcyBBcmVhcyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5jaXJjbGVzIERhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC50ZXh0XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50ZXh0LnRleHRzIERhdGEgbGFiZWwgdGV4dCBlbGVtZW50c1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7IC4uLiB9KTtcbiAqXG4gKiBjaGFydC4kLmNoYXJ0OyAvLyB3cmFwcGVyIGVsZW1lbnRcbiAqIGNoYXJ0LiQubGluZS5jaXJjbGVzOyAgLy8gYWxsIGRhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0IHtcblx0Y29uc3RydWN0b3IoY29uZmlnKSB7XG5cdFx0Y29uc3QgJCQgPSBuZXcgQ2hhcnRJbnRlcm5hbCh0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqIFBsdWdpbiBpbnN0YW5jZSBhcnJheVxuXHRcdCAqIEBuYW1lIENoYXJ0I3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuXHRcdCAqICAgICAuLi5cblx0XHQgKiAgICAgcGx1Z2luczogW1xuXHRcdCAqICAgICAgICBuZXcgYmIucGx1Z2luLnN0YW5mb3JkKHsgLi4uIH0pLFxuXHRcdCAqICAgICAgICBuZXcgUGx1Z2luQSgpXG5cdFx0ICogICAgIF1cblx0XHQgKiAgfSk7XG5cdFx0ICpcblx0XHQgKiAgY2hhcnQucGx1Z2luczsgLy8gW1N0YW5mb3JkLCBQbHVnaW5BXSAtIGluc3RhbmNlIGFycmF5XG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5zID0gW107XG5cblx0XHR0aGlzLmludGVybmFsID0gJCQ7XG5cblx0XHQkJC5sb2FkQ29uZmlnKGNvbmZpZyk7XG5cdFx0JCQuYmVmb3JlSW5pdChjb25maWcpO1xuXHRcdCQkLmluaXQoKTtcblxuXHRcdHRoaXMuJCA9ICQkLmdldENoYXJ0RWxlbWVudHMoKTtcblxuXHRcdCQkLmFmdGVySW5pdChjb25maWcpO1xuXG5cdFx0Ly8gYmluZCBcInRoaXNcIiB0byBuZXN0ZWQgQVBJXG5cdFx0KGZ1bmN0aW9uIGJpbmRUaGlzKGZuLCB0YXJnZXQsIGFyZ1RoaXMpIHtcblx0XHRcdE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gZm5ba2V5XS5iaW5kKGFyZ1RoaXMpO1xuXG5cdFx0XHRcdE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCAmJlxuXHRcdFx0XHRcdGJpbmRUaGlzKGZuW2tleV0sIHRhcmdldFtrZXldLCBhcmdUaGlzKTtcblx0XHRcdH0pO1xuXHRcdH0pKENoYXJ0LnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogQ2xhc3MgdG8gc2V0IG9wdGlvbnMgb24gZ2VuZXJhdGluZyBjaGFydC5cbiAqIC0gSXQncyBpbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cbiAqIEBjbGFzcyBPcHRpb25zXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gdG8gdXNlIHRoZXNlIG9wdGlvbnMgb24gZ2VuZXJhdGluZyB0aGUgY2hhcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9ucyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cblx0XHRcdCAqIElmIG90aGVyIGNoYXJ0IGlzIHNldCBhbHJlYWR5LCBpdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG5ldyBvbmUgKG9ubHkgb25lIGNoYXJ0IGNhbiBiZSBzZXQgaW4gb25lIGVsZW1lbnQpLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogSW4gY2FzZSBvZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgb3Igbm90IHNwZWNpZmllZCwgd2lsbCBhZGQgYSBgPGRpdj5gIGVsZW1lbnQgdG8gdGhlIGJvZHkuXG5cdFx0XHQgKiBAbmFtZSBiaW5kdG9cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0bz0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG8uZWxlbWVudD0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtiaW5kdG8uY2xhc3NuYW1lPWJiXSBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIG9mIGJpbmQgZWxlbWVudC48YnI+XG5cdFx0XHQgKiAgICAgKipOT1RFOioqIFdoZW4gY2xhc3MgbmFtZSBpc24ndCBgYmJgLCB0aGVuIHlvdSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBkZWZhdWx0IENTUyB0byBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXG5cdFx0XHQgKiBAZGVmYXVsdCAjY2hhcnRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBiaW5kdG86IFwiI215Q29udGFpbmVyXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBvciBIVE1MRWxlbWVudFxuXHRcdFx0ICogYmluZHRvOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q29udGFpbmVyXCIpXG5cdFx0XHQgKlxuXHRcdFx0ICogLy8gb3IgRDMgc2VsZWN0aW9uIG9iamVjdFxuXHRcdFx0ICogYmluZHRvOiBkMy5zZWxlY3QoXCIjbXlDb250YWluZXJcIilcblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBvciB0byBjaGFuZ2UgZGVmYXVsdCBjbGFzc25hbWVcblx0XHRcdCAqIGJpbmR0bzoge1xuXHRcdFx0ICogICAgZWxlbWVudDogXCIjY2hhcnRcIixcblx0XHRcdCAqICAgIGNsYXNzbmFtZTogXCJiaWxsLWJvYXJkXCIgIC8vIGV4KSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2JpbGwtYm9hcmQnPlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRiaW5kdG86IFwiI2NoYXJ0XCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSBmb3IgY2hhcnQgZWxlbWVudFxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICA+IFdoZW4gaXMgZmFsc2UsIGNoYXJ0IG5vZGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFmdGVyIHRoZSBheGlzIG5vZGUgaW4gRE9NIHRyZWUgaGllcmFyY2h5LlxuXHRcdFx0ICogID4gSXMgdG8gbWFrZSBjaGFydCBlbGVtZW50IHBvc2l0aW9uZWQgb3ZlciBheGlzIGVsZW1lbnQuXG5cdFx0XHQgKiBAbmFtZSBjbGlwUGF0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5jbGlwUGF0aClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXG5cdFx0XHQgKiBjbGlwUGF0aDogZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0Y2xpcFBhdGg6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHN2ZyBlbGVtZW50J3MgY2xhc3MgbmFtZVxuXHRcdFx0ICogQG5hbWUgc3ZnXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3ZnLmNsYXNzbmFtZV0gY2xhc3MgbmFtZSBmb3Igc3ZnIGVsZW1lbnRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBzdmc6IHtcbiAgICAgICAgICAgICAqICAgY2xhc3NuYW1lOiBcInRlc3RfY2xhc3NcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRzdmdfY2xhc3NuYW1lOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgY2hhcnQgZWxlbWVudC5cblx0XHRcdCAqIElmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpdCdzIGFwcGVuZGVkIHRvLlxuXHRcdFx0ICogQG5hbWUgc2l6ZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUud2lkdGhdIHdpZHRoIG9mIHRoZSBjaGFydCBlbGVtZW50XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQ2hhcnRTaXplKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNpemU6IHtcbiAgICAgICAgICAgICAqICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgICAqICAgaGVpZ2h0OiA0ODBcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0c2l6ZV93aWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0c2l6ZV9oZWlnaHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbGxvdyB1c2FnZSBzdGF0cyBjb2xsZWN0aW9uLlxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgLSBUaGUgdXNhZ2Ugc3RhdHMgY29sbGVjdGlvbiBpcyB1c2VkIGZvciByZWZlcmVuY2UgcHVycG9zZSBvbmx5LlxuXHRcdFx0ICogICAtIFRoZSBzdGF0cyBkYXRhIHdpbGwgYmUgc2VudCBpbiBhIHBlcmlvZCBvZiBvbmNlIGluIGV2ZXJ5IDIgd2Vla3MuXG5cdFx0XHQgKiAgIC0gSGVscCB1cyB0byBtYWtlIGEgYmV0dGVyIGNoYXJ0IGxpYnJhcnkhIDopXG5cdFx0XHQgKiBAbmFtZSBzdGF0c1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIHR1cm4gb2ZmIHN0YXRzIHNlbmRpbmdcblx0XHRcdCAqIHN0YXRzOiBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRzdGF0czogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgcGFkZGluZyBvZiB0aGUgY2hhcnQgZWxlbWVudC5cblx0XHRcdCAqIEBuYW1lIHBhZGRpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcucmlnaHRdIHBhZGRpbmcgb24gdGhlIHJpZ2h0IG9mIGNoYXJ0XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcuYm90dG9tXSBwYWRkaW5nIG9uIHRoZSBib3R0b20gb2YgY2hhcnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogcGFkZGluZzoge1xuICAgICAgICAgICAgICogICB0b3A6IDIwLFxuICAgICAgICAgICAgICogICByaWdodDogMjAsXG4gICAgICAgICAgICAgKiAgIGJvdHRvbTogMjAsXG4gICAgICAgICAgICAgKiAgIGxlZnQ6IDIwXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdHBhZGRpbmdfbGVmdDogdW5kZWZpbmVkLFxuXHRcdFx0cGFkZGluZ19yaWdodDogdW5kZWZpbmVkLFxuXHRcdFx0cGFkZGluZ190b3A6IHVuZGVmaW5lZCxcblx0XHRcdHBhZGRpbmdfYm90dG9tOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHJlc2l6ZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSByZXNpemVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVzaXplLmF1dG89dHJ1ZV0gU2V0IGNoYXJ0IHJlc2l6ZSBhdXRvbWF0aWNhbGx5IG9uIHZpZXdwb3J0IGNoYW5nZXMuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHJlc2l6ZToge1xuXHRcdFx0ICogICAgICBhdXRvOiBmYWxzZVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cmVzaXplX2F1dG86IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHpvb20gb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgem9vbVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt6b29tLmVuYWJsZWQ9ZmFsc2VdIEVuYWJsZSB6b29taW5nLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt6b29tLmVuYWJsZWQudHlwZT0nd2hlZWwnXSBTZXQgem9vbSBpbnRlcmFjdGlvbiB0eXBlLlxuXHRcdFx0ICogIC0gKipBdmFpbGFibGUgdHlwZXM6Kipcblx0XHRcdCAqICAgIC0gd2hlZWxcblx0XHRcdCAqICAgIC0gZHJhZ1xuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cblx0XHRcdCAqICBJZiB0cnVlIHNldCwgeSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgem9vbWVkIHJlZ2lvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt6b29tLmV4dGVudD1bMSwgMTBdXSBDaGFuZ2Ugem9vbSBleHRlbnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfERhdGV9IFt6b29tLngubWF4XSBTZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZVxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tc3RhcnQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIHN0YXJ0cy48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHpvb21pbmcuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3pvb20ucmVzZXRCdXR0b249dHJ1ZV0gU2V0IHRvIGRpc3BsYXkgem9vbSByZXNldCBidXR0b24gZm9yICdkcmFnJyB0eXBlIHpvb21cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbem9vbS5yZXNldEJ1dHRvbi50ZXh0PSdSZXNldCBab29tJ10gVGV4dCB2YWx1ZSBmb3Igem9vbSByZXNldCBidXR0b24uXG5cdFx0XHQgKiBAc2VlIFtEZW1vOnpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5ab29tKVxuXHRcdFx0ICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgem9vbToge1xuXHRcdFx0ICogICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICAgKiAgICAgICAgICB0eXBlOiBcImRyYWdcIlxuICAgICAgICAgICAgICogICAgICB9LFxuXHRcdFx0ICogICAgICByZXNjYWxlOiB0cnVlLFxuXHRcdFx0ICogICAgICBleHRlbnQ6IFsxLCAxMDBdICAvLyBlbmFibGUgbW9yZSB6b29taW5nXG5cdFx0XHQgKiAgICAgIHg6IHtcblx0XHRcdCAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXG5cdFx0XHQgKiAgICAgICAgICBtYXg6IDEwICAvLyBzZXQgbWF4IHJhbmdlXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgb256b29tOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgIG9uem9vbWVuZDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2hvdyByZXNldCBidXR0b24gd2hlbiBpcyB6b29tZWQtaW5cblx0XHRcdCAqICAgICAgcmVzZXRCdXR0b246IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBjdXN0b21pemVkIHRleHQgdmFsdWUgZm9yIHJlc2V0IHpvb20gYnV0dG9uXG5cdFx0XHQgKiAgICAgIHJlc2V0QnV0dG9uOiB7XG5cdFx0XHQgKiAgICAgICAgICB0ZXh0OiBcIlVuem9vbVwiXG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHpvb21fZW5hYmxlZDogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV9leHRlbnQ6IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fcHJpdmlsZWdlZDogZmFsc2UsXG5cdFx0XHR6b29tX3Jlc2NhbGU6IGZhbHNlLFxuXHRcdFx0em9vbV9vbnpvb206IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fb256b29tc3RhcnQ6IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fb256b29tZW5kOiB1bmRlZmluZWQsXG5cdFx0XHR6b29tX3Jlc2V0QnV0dG9uOiB0cnVlLFxuXHRcdFx0em9vbV94X21pbjogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV94X21heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEludGVyYWN0aW9uIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmVuYWJsZWQ9dHJ1ZV0gSW5kaWNhdGUgaWYgdGhlIGNoYXJ0IHNob3VsZCBoYXZlIGludGVyYWN0aW9ucy48YnI+XG5cdFx0XHQgKiAgICAgSWYgYGZhbHNlYCBpcyBzZXQsIGFsbCBvZiBpbnRlcmFjdGlvbnMgKHNob3dpbmcvaGlkaW5nIHRvb2x0aXAsIHNlbGVjdGlvbiwgbW91c2UgZXZlbnRzLCBldGMpIHdpbGwgYmUgZGlzYWJsZWQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5icmlnaHRlbj10cnVlXSBNYWtlIGJyaWdodGVyIGZvciB0aGUgc2VsZWN0ZWQgYXJlYSAoZXguICdwaWUnIHR5cGUgZGF0YSBzZWxlY3RlZCBhcmVhKVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2g9dHJ1ZV0gZW5hYmxlIG9yIGRpc2FibGUgIHRvdWNoIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58TnVtYmVyfSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0PWZhbHNlXSBlbmFibGUgb3IgZGlzYWJsZSB0byBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0IG9uIHRvdWNoc3RhcnQgJiB0b3VjaG1vdmUgZXZlbnQuIEl0J3MgdXN1YWxseSB1c2VkIHRvIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nLlxuXHRcdFx0ICogQHNlZSBbRGVtbzogdG91Y2gucHJldmVudERlZmF1bHRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5QcmV2ZW50U2Nyb2xsT25Ub3VjaClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgICogICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICBicmlnaHRlbjogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICBpbnB1dFR5cGU6IHtcbiAgICAgICAgICAgICAqICAgICAgICBtb3VzZTogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICB0b3VjaDogZmFsc2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gb3IgZGVjbGFyZSBwcmV2ZW50RGVmYXVsdCBleHBsaWNpdGx5LlxuICAgICAgICAgICAgICogICAgICAgIC8vIEluIHRoaXMgY2FzZSB0b3VjaCBpbnB1dFR5cGUgaXMgZW5hYmxlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgKiAgICAgICAgdG91Y2g6IHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIC8vIG9yIHRocmVzaG9sZCBwaXhlbCB2YWx1ZSAocGl4ZWwgbW92ZWQgZnJvbSB0b3VjaHN0YXJ0IHRvIHRvdWNobW92ZSlcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IDVcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGludGVyYWN0aW9uX2VuYWJsZWQ6IHRydWUsXG5cdFx0XHRpbnRlcmFjdGlvbl9icmlnaHRlbjogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZTogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIG1vdXNlL3RvdWNoIGVudGVycyB0aGUgY2hhcnQuXG5cdFx0XHQgKiBAbmFtZSBvbm92ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbm92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25vdmVyOiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIG9ub3V0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKXt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogb25vdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25vdXQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB1c2VyIHJlc2l6ZXMgdGhlIHNjcmVlbi5cblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKXt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogb25yZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25yZXNpemU6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyZWVuIHJlc2l6ZSBmaW5pc2hlZC5cblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCl7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIG9ucmVzaXplZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbnJlc2l6ZWQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxuXHRcdFx0ICogQG5hbWUgb25iZWZvcmVpbml0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKXt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogb25iZWZvcmVpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgLi4uXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdG9uYmVmb3JlaW5pdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWQuXG5cdFx0XHQgKiBAbmFtZSBvbmluaXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbmluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25pbml0OiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxuXHRcdFx0ICogQG5hbWUgb25hZnRlcmluaXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbmFmdGVyaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbmFmdGVyaW5pdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxuXHRcdFx0ICogQG5hbWUgb25yZW5kZXJlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25yZW5kZXJlZDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cblx0XHRcdCAqIC0gKipOT1RFOioqIElmIGAwIGBvciBgbnVsbGAgc2V0LCB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZC4gU28sIHRoaXMgbWFrZXMgaW5pdGlhbCByZW5kZXJpbmcgZmFzdGVyIGVzcGVjaWFsbHkgaW4gY2FzZSB5b3UgaGF2ZSBhIGxvdCBvZiBkYXRhLlxuXHRcdFx0ICogQG5hbWUgdHJhbnNpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RyYW5zaXRpb24uZHVyYXRpb249MzUwXSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB0cmFuc2l0aW9uOiB7XG5cdFx0XHQgKiAgICBkdXJhdGlvbjogNTAwXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdHRyYW5zaXRpb25fZHVyYXRpb246IDM1MCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZ5IHRoZSBrZXkgb2YgeCB2YWx1ZXMgaW4gdGhlIGRhdGEuPGJyPjxicj5cblx0XHRcdCAqIFdlIGNhbiBzaG93IHRoZSBkYXRhIHdpdGggbm9uLWluZGV4IHggdmFsdWVzIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHRoZSB0eXBlIG9mIHggYXhpcyBpcyB0aW1lc2VyaWVzLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgb24gY2F0ZWdvcnkgYXhpcywgdGhlIHZhbHVlcyBvZiB0aGUgZGF0YSBvbiB0aGUga2V5IHdpbGwgYmUgdXNlZCBmb3IgY2F0ZWdvcnkgbmFtZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHg6IFwiZGF0ZVwiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZnkgdGhlIGtleXMgb2YgdGhlIHggdmFsdWVzIGZvciBlYWNoIGRhdGEuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeHNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHhzOiB7XG4gICAgICAgICAgICAgKiAgICAgIGRhdGExOiBcIngxXCIsXG4gICAgICAgICAgICAgKiAgICAgIGRhdGEyOiBcIngyXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3hzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBmb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIHN0cmluZyBzcGVjaWZlZCBhcyB4LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHhGb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgJVktJW0tJWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICB4OiBcInhcIixcblx0XHRcdCAqICAgIGNvbHVtbnM6IFtcblx0XHRcdCAqICAgICAgICBbXCJ4XCIsIFwiMDEwMTIwMTlcIiwgXCIwMjAxMjAxOVwiLCBcIjAzMDEyMDE5XCJdLFxuXHRcdFx0ICogICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1cblx0XHRcdCAqICAgIF0sXG5cdFx0XHQgKiAgICAvLyBGb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIGFzIGRhdGV0aW1lIGZvciBnaXZlbiAneCcgc3RyaW5nIHZhbHVlXG5cdFx0XHQgKiAgICB4Rm9ybWF0OiBcIiVtJWQlWVwiXG5cdFx0XHQgKiB9LFxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICAgeDoge1xuXHRcdFx0ICogICAgICAgIHR5cGU6IFwidGltZXNlcmllc1wiXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV94Rm9ybWF0OiBcIiVZLSVtLSVkXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxvY2FsdGltZSBmb3JtYXQgdG8gcGFyc2UgeCBheGlzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHhMb2NhbHRpbWVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHhMb2NhbHRpbWU6IGZhbHNlXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeExvY2FsdGltZTogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTb3J0IG9uIHggYXhpcy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKR4U29ydFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgeFNvcnQ6IGZhbHNlXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeFNvcnQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ29udmVydHMgZGF0YSBpZCB2YWx1ZVxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgKiAgICAgICAvLyB3aGVuIGlkIGlzICdkYXRhMScsIGNvbnZlcnRzIHRvIGJlICdkYXRhMidcbiAgICAgICAgICAgICAqICAgICAgIC8vICdkYXRhMicgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBpbml0aWFsIGRhdGEgdmFsdWVcbiAgICAgICAgICAgICAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gXCJkYXRhMlwiO1xuICAgICAgICAgICAgICogICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAqICAgICAgIH1cbiAgICAgICAgICAgICAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9pZENvbnZlcnRlcjogaWQgPT4gaWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGN1c3RvbSBkYXRhIG5hbWUuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbmFtZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFOYW1lKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgbmFtZXM6IHtcbiAgICAgICAgICAgICAqICAgICBkYXRhMTogXCJEYXRhIE5hbWUgMVwiLFxuICAgICAgICAgICAgICogICAgIGRhdGEyOiBcIkRhdGEgTmFtZSAyXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX25hbWVzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY3VzdG9tIGRhdGEgY2xhc3MuPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY2xhc3Nlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICogICAgIGRhdGExOiBcImFkZGl0aW9uYWwtZGF0YTEtY2xhc3NcIixcbiAgICAgICAgICAgICAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2NsYXNzZXM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBncm91cHMgZm9yIHRoZSBkYXRhIGZvciBzdGFja2luZy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRncm91cHNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgZ3JvdXBzOiBbXG4gICAgICAgICAgICAgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcbiAgICAgICAgICAgICAqICAgICBbXCJkYXRhM1wiXVxuICAgICAgICAgICAgICogICBdXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfZ3JvdXBzOiBbXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgeSBheGlzIHRoZSBkYXRhIHJlbGF0ZWQgdG8uIHkgYW5kIHkyIGNhbiBiZSB1c2VkLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGF4ZXM6IHtcblx0XHRcdCAqICAgICBkYXRhMTogXCJ5XCIsXG5cdFx0XHQgKiAgICAgZGF0YTI6IFwieTJcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfYXhlczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHR5cGUgYXQgb25jZS48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgdHlwZSB3aWxsIGJlIGFwcGxpZWQgdG8gZXZlcnkgZGF0YS4gVGhpcyBzZXR0aW5nIGNhbiBiZSBvdmVyd3JpdHRlbiBieSBkYXRhLnR5cGVzLjxicj48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqIC0gYXJlYVxuXHRcdFx0ICogLSBhcmVhLWxpbmUtcmFuZ2Vcblx0XHRcdCAqIC0gYXJlYS1zcGxpbmVcblx0XHRcdCAqIC0gYXJlYS1zcGxpbmUtcmFuZ2Vcblx0XHRcdCAqIC0gYXJlYS1zdGVwXG5cdFx0XHQgKiAtIGJhclxuXHRcdFx0ICogLSBidWJibGVcblx0XHRcdCAqIC0gZG9udXRcblx0XHRcdCAqIC0gZ2F1Z2Vcblx0XHRcdCAqIC0gbGluZVxuXHRcdFx0ICogLSBwaWVcblx0XHRcdCAqIC0gcmFkYXJcblx0XHRcdCAqIC0gc2NhdHRlclxuXHRcdFx0ICogLSBzcGxpbmVcblx0XHRcdCAqIC0gc3RlcFxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgbGluZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHR5cGU6IFwiYmFyXCJcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV90eXBlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHR5cGUgZm9yIGVhY2ggZGF0YS48YnI+XG5cdFx0XHQgKiBUaGlzIHNldHRpbmcgb3ZlcndyaXRlcyBkYXRhLnR5cGUgc2V0dGluZy5cblx0XHRcdCAqIC0gKipOT1RFOioqIGByYWRhcmAgdHlwZSBjYW4ndCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHR5cGVzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHR5cGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICB0eXBlczoge1xuXHRcdFx0ICogICAgIGRhdGExOiBcImJhclwiLFxuXHRcdFx0ICogICAgIGRhdGEyOiBcInNwbGluZVwiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV90eXBlczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxhYmVscyBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbGFiZWxzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzLmNlbnRlcmVkPWZhbHNlXSBDZW50ZXJpemUgbGFiZWxzIG9uIGBiYXJgIHNoYXBlLiAoKipOT1RFOioqIHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGF0YS5sYWJlbHMuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZ1bmN0aW9uIGZvciBkYXRhIGxhYmVscy48YnI+XG5cdFx0XHQgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cblx0XHRcdCAqICAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxuXHRcdFx0ICogIC0gYGlkYCBpcyB0aGUgaWQgb2YgdGhlIGRhdGEgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxuXHRcdFx0ICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG5cdFx0XHQgKiAgLSBgamAgaXMgdGhlIHN1YiBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uPGJyPjxicj5cblx0XHRcdCAqIEZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgZGVmaW5lZCBmb3IgZWFjaCBkYXRhIGJ5IHNwZWNpZnlpbmcgYXMgYW4gb2JqZWN0IGFuZCBEMyBmb3JtYXR0ZXIgZnVuY3Rpb24gY2FuIGJlIHNldCAoZXguIGQzLmZvcm1hdCgnJCcpKVxuIFx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdH0gW2RhdGEubGFiZWxzLmNvbG9yc10gU2V0IGxhYmVsIHRleHQgY29sb3JzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkYXRhLmxhYmVscy5wb3NpdGlvbi54PTBdIHggY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOVW1iZXJ9IFtkYXRhLmxhYmVscy5wb3NpdGlvbi55PTBdIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogbGFiZWwgY29sb3JzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxDb2xvcnMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBmb3JtYXRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbEZvcm1hdClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGxhYmVsIHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxQb3NpdGlvbilcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGxhYmVsczogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIG9yIHNldCBzcGVjaWZpYyBvcHRpb25zXG5cdFx0XHQgKiAgIGxhYmVsczoge1xuXHRcdFx0ICogICAgIGZvcm1hdDogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIGl0J3MgcG9zc2libGUgdG8gc2V0IGZvciBlYWNoIGRhdGFcblx0XHRcdCAqICAgICBmb3JtYXQ6IHtcblx0XHRcdCAqICAgICAgICAgZGF0YTE6IGZ1bmN0aW9uKHYsIGlkLCBpLCBqKSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICAgICAuLi5cblx0XHRcdCAqICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAvLyBhbGlnbiB0ZXh0IHRvIGNlbnRlciBvZiB0aGUgJ2Jhcicgc2hhcGUgKHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXG5cdFx0XHQgKiAgICAgY2VudGVyZWQ6IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIGFwcGx5IGZvciBhbGwgbGFiZWwgdGV4dHNcblx0XHRcdCAqICAgICBjb2xvcnM6IFwicmVkXCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIG9yIHNldCBkaWZmZXJlbnQgY29sb3JzIHBlciBkYXRhc2V0XG5cdFx0XHQgKiAgICAgLy8gZm9yIG5vdCBzcGVjaWZpZWQgZGF0YXNldCwgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IGNvbG9yIHZhbHVlXG5cdFx0XHQgKiAgICAgY29sb3JzOiB7XG5cdFx0XHQgKiAgICAgICAgZGF0YTE6IFwieWVsbG93XCIsXG5cdFx0XHQgKiAgICAgICAgZGF0YTM6IFwiZ3JlZW5cIlxuXHRcdFx0ICogICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb25cblx0XHRcdCAqICAgICBwb3NpdGlvbjoge1xuXHRcdFx0ICogICAgICAgIHg6IC0xMCxcblx0XHRcdCAqICAgICAgICB5OiAxMFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2xhYmVsczoge30sXG5cdFx0XHRkYXRhX2xhYmVsc19jb2xvcnM6IHVuZGVmaW5lZCxcblx0XHRcdGRhdGFfbGFiZWxzX3Bvc2l0aW9uOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgVGhpcyBvcHRpb24gY2hhbmdlcyB0aGUgb3JkZXIgb2Ygc3RhY2tpbmcgZGF0YSBhbmQgcGllY2VzIG9mIHBpZS9kb251dC5cblx0XHRcdCAqICAtIElmIGBudWxsYCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgdGhlIG9yZGVyIHRoZSBkYXRhIGxvYWRlZC5cblx0XHRcdCAqICAtIElmIGZ1bmN0aW9uIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIGFzIFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKTxicj48YnI+XG5cdFx0XHQgKlxuXHRcdFx0ICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIG9yZGVyXG5cdFx0XHQgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIG9yZGVyXG5cdFx0XHQgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGxvYWQgb3JkZXJcblx0XHRcdCAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvblxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9yZGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuXHRcdFx0ICogQGRlZmF1bHQgZGVzY1xuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU9yZGVyKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgLy8gaW4gZGVzY2VuZGluZyBvcmRlciAoZGVmYXVsdClcblx0XHRcdCAqICAgb3JkZXI6IFwiZGVzY1wiXG5cdFx0XHQgKlxuXHRcdFx0ICogICAvLyBpbiBhc2NlbmRpbmcgb3JkZXJcblx0XHRcdCAqICAgb3JkZXI6IFwiYXNjXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIGtlZXBzIGRhdGEgaW5wdXQgb3JkZXJcblx0XHRcdCAqICAgb3JkZXI6IG51bGxcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxuXHRcdFx0ICogICBvcmRlcjogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0ICogICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XG5cdFx0XHQgKiAgICAgICB7XG5cdFx0XHQgKiAgICAgICAgICBpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXG5cdFx0XHQgKiAgICAgICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9LFxuXHRcdFx0ICogICAgICAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgICAgICAgXVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb3JkZXI6IFwiZGVzY1wiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIERlZmluZSByZWdpb25zIGZvciBlYWNoIGRhdGEuPGJyPlxuXHRcdFx0ICogVGhlIHZhbHVlcyBtdXN0IGJlIGFuIGFycmF5IGZvciBlYWNoIGRhdGEgYW5kIGl0IHNob3VsZCBpbmNsdWRlIGFuIG9iamVjdCB0aGF0IGhhcyBgc3RhcnRgLCBgZW5kYCBhbmQgYHN0eWxlYC5cblx0XHRcdCAqIC0gVGhlIG9iamVjdCB0eXBlIHNob3VsZCBiZSBhczpcblx0XHRcdCAqICAgLSBzdGFydCB7TnVtYmVyfTogU3RhcnQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBzdGFydCB3aWxsIGJlIHRoZSBmaXJzdCBkYXRhIHBvaW50LlxuXHRcdFx0ICogICAtIFtlbmRdIHtOdW1iZXJ9OiBFbmQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBlbmQgd2lsbCBiZSB0aGUgbGFzdCBkYXRhIHBvaW50LlxuXHRcdFx0ICogICAtIFtzdHlsZS5kYXNoYXJyYXk9XCIyIDJcIl0ge09iamVjdH06IFRoZSBmaXJzdCBudW1iZXIgc3BlY2lmaWVzIGEgZGlzdGFuY2UgZm9yIHRoZSBmaWxsZWQgYXJlYSwgYW5kIHRoZSBzZWNvbmQgYSBkaXN0YW5jZSBmb3IgdGhlIHVuZmlsbGVkIGFyZWEuXG5cdFx0XHQgKiAtICoqTk9URToqKiBDdXJyZW50bHkgdGhpcyBvcHRpb24gc3VwcG9ydHMgb25seSBsaW5lIGNoYXJ0IGFuZCBkYXNoZWQgc3R5bGUuIElmIHRoaXMgb3B0aW9uIHNwZWNpZmllZCwgdGhlIGxpbmUgd2lsbCBiZSBkYXNoZWQgb25seSBpbiB0aGUgcmVnaW9ucy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRyZWdpb25zXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICByZWdpb25zOiB7XG5cdFx0XHQgKiAgICAgZGF0YTE6IFt7XG5cdFx0XHQgKiAgICAgICAgIHN0YXJ0OiAxLFxuXHRcdFx0ICogICAgICAgICBlbmQ6IDIsXG5cdFx0XHQgKiAgICAgICAgIHN0eWxlOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICBkYXNoYXJyYXk6IFwiNSAyXCJcblx0XHRcdCAqICAgICAgICAgfVxuXHRcdFx0ICogICAgIH0sIHtcblx0XHRcdCAqICAgICAgICAgc3RhcnQ6IDNcblx0XHRcdCAqICAgICB9XSxcblx0XHRcdCAqICAgICAuLi5cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3JlZ2lvbnM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjb2xvciBjb252ZXJ0ZXIgZnVuY3Rpb24uPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHNob3VsZCBhIGZ1bmN0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIGNvbG9yIChlLmcuICcjZmYwMDAwJykgYW5kIGQgdGhhdCBoYXMgZGF0YSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleCwgZXRjLiBBbmQgaXQgbXVzdCByZXR1cm4gYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGNvbG9yIChlLmcuICcjMDBmZjAwJykuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY29sb3Jcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFDb2xvcilcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGNvbG9yOiBmdW5jdGlvbihjb2xvciwgZCkgeyAuLi4gfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2NvbG9yOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNvbG9yIGZvciBlYWNoIGRhdGEuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY29sb3JzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICBjb2xvcnM6IHtcblx0XHRcdCAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXG5cdFx0XHQgKiAgICAgZGF0YTI6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gXCIjMDAwXCI7XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICAgIC4uLlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfY29sb3JzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaWRlIGVhY2ggZGF0YSB3aGVuIHRoZSBjaGFydCBhcHBlYXJzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIHNwZWNpZmllZCwgYWxsIG9mIGRhdGEgd2lsbCBiZSBoaWRkZW4uIElmIG11bHRpcGxlIGlkcyBzcGVjaWZpZWQgYXMgYW4gYXJyYXksIHRob3NlIHdpbGwgYmUgaGlkZGVuLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGhpZGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbnxBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAvLyBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlblxuXHRcdFx0ICogICBoaWRlOiB0cnVlXG5cdFx0XHQgKlxuXHRcdFx0ICogICAvLyBzcGVjaWZpZWQgZGF0YSB3aWxsIGJlIGhpZGRlblxuXHRcdFx0ICogICBoaWRlOiBbXCJkYXRhMVwiLCAuLi5dXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfaGlkZTogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRmlsdGVyIHZhbHVlcyB0byBiZSBzaG93blxuXHRcdFx0ICogVGhlIGRhdGEgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIHJldHVybmVkIGJ5IGAuZGF0YSgpYC5cblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkZmlsdGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAvLyBmaWx0ZXIgZm9yIGlkIHZhbHVlXG5cdFx0XHQgKiAgIGZpbHRlcjogZnVuY3Rpb24odikge1xuXHRcdFx0ICogICAgICAvLyB2OiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcblx0XHRcdCAqICAgICAgLy8gICAgICB7eDogMCwgdmFsdWU6IDEzMCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDB9LCAuLi5dXG5cdFx0XHQgKiAgICAgIC8vICAgIH0sIC4uLl1cblx0XHRcdCAqICAgICAgcmV0dXJuIHYuaWQgIT09IFwiZGF0YTFcIjtcblx0XHRcdCAqICAgfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2ZpbHRlcjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgc3RhY2tpbmcgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgLSBGb3Igc3RhY2tpbmcsICdbZGF0YS5ncm91cHNdKCMuZGF0YSUyNUUyJTI1ODAlMjVBNGdyb3VwcyknIG9wdGlvbiBzaG91bGQgYmUgc2V0XG5cdFx0XHQgKiAgIC0geSBBeGlzIHdpbGwgYmUgc2V0IGluIHBlcmNlbnRhZ2UgdmFsdWUgKDAgfiAxMDAlKVxuXHRcdFx0ICogICAtIE11c3QgaGF2ZSBwb3N0aXZlIHZhbHVlc1xuXHRcdFx0ICogQG5hbWUgZGF0YeKApHN0YWNr4oCkbm9ybWFsaXplXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVN0YWNrTm9ybWFsaXplZClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0ICAgICAqICAgc3RhY2s6IHtcblx0XHQgICAgICogICAgICBub3JtYWxpemU6IHRydWVcblx0XHQgICAgICogICB9XG5cdFx0ICAgICAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zdGFja19ub3JtYWxpemU6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZGF0YSBzZWxlY3Rpb24gZW5hYmxlZDxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgdHJ1ZSwgd2UgY2FuIHNlbGVjdCB0aGUgZGF0YSBwb2ludHMgYW5kIGdldC9zZXQgaXRzIHN0YXRlIG9mIHNlbGVjdGlvbiBieSBBUEkgKGUuZy4gc2VsZWN0LCB1bnNlbGVjdCwgc2VsZWN0ZWQpLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGVuYWJsZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU2VsZWN0aW9uKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHNlbGVjdGlvbjoge1xuXHRcdFx0ICogICAgICAgZW5hYmxlZDogdHJ1ZVxuXHRcdFx0ICogICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3NlbGVjdGlvbl9lbmFibGVkOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpcGxlIGRhdGEgcG9pbnRzIHRoYXQgaGF2ZSBzYW1lIHggdmFsdWUgd2lsbCBiZSBzZWxlY3RlZCBieSBvbmUgc2VsZWN0aW9uLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGdyb3VwZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBncm91cGVkOiB0cnVlXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBlYWNoIGRhdGEgcG9pbnQgdG8gZGV0ZXJtaW5lIGlmIGl0J3Mgc2VsZWN0YWJsZSBvciBub3QuPGJyPjxicj5cblx0XHRcdCAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgZCBhcyBhbiBhcmd1bWVudCBhbmQgaXQgaGFzIHNvbWUgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXguIFRoaXMgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBib29sZWFuLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGlzc2VsZWN0YWJsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHNlbGVjdGlvbjoge1xuXHRcdFx0ICogICAgICAgaXNzZWxlY3RhYmxlOiBmdW5jdGlvbihkKSB7IC4uLiB9XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbXVsdGlwbGUgZGF0YSBwb2ludHMgc2VsZWN0aW9uIGVuYWJsZWQuPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aWxlIGRhdGEgcG9pbnRzIGNhbiBoYXZlIHRoZSBzZWxlY3RlZCBzdGF0ZSBhdCB0aGUgc2FtZSB0aW1lLiBJZiBmYWxzZSBzZXQsIG9ubHkgb25lIGRhdGEgcG9pbnQgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgdW5zZWxlY3RlZCB3aGVuIHRoZSBuZXcgZGF0YSBwb2ludCBpcyBzZWxlY3RlZC5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRtdWx0aXBsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHNlbGVjdGlvbjoge1xuXHRcdFx0ICogICAgICAgbXVsdGlwbGU6IGZhbHNlXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX211bHRpcGxlOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSB0byBzZWxlY3QgZGF0YSBwb2ludHMgYnkgZHJhZ2dpbmcuXG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgZGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkIGJ5IGRyYWdnaW5nLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIHNjcm9sbGluZyBvbiB0aGUgY2hhcnQgd2lsbCBiZSBkaXNhYmxlZCBiZWNhdXNlIGRyYWdnaW5nIGV2ZW50IHdpbGwgaGFuZGxlIHRoZSBldmVudC5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRkcmFnZ2FibGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBkcmFnZ2FibGU6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGU6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBlYWNoIGRhdGEgcG9pbnQgY2xpY2tlZCBhbmQgd2lsbCByZWNlaXZlIGQgYW5kIGVsZW1lbnQgYXMgdGhlIGFyZ3VtZW50cy4gZCBpcyB0aGUgZGF0YSBjbGlja2VkIGFuZCBlbGVtZW50IGlzIHRoZSBlbGVtZW50IGNsaWNrZWQuIEluIHRoaXMgY2FsbGJhY2ssIHRoaXMgd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9uY2xpY2tcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHsgLi4uIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbmNsaWNrOiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3ZlciBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBtb3VzZSBjdXJzb3Igb3IgdmlhIHRvdWNoIG1vdmVzIG9udG8gZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgZCBhcyB0aGUgYXJndW1lbnQuIGQgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG9udG8uIEluIHRoaXMgY2FsbGJhY2ssIHRoaXMgd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9ub3ZlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgb25vdmVyOiBmdW5jdGlvbihkKSB7IC4uLiB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25vdmVyOiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3V0IGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIG1vdXNlIGN1cnNvciBvciB2aWEgdG91Y2ggbW92ZXMgb3V0IGVhY2ggZGF0YSBwb2ludCBhbmQgd2lsbCByZWNlaXZlIGQgYXMgdGhlIGFyZ3VtZW50LiBkIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvdXQuIEluIHRoaXMgY2FsbGJhY2ssIHRoaXMgd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9ub3V0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbm91dDogZnVuY3Rpb24oZCkgeyAuLi4gfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29ub3V0OiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSBzZWxlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25zZWxlY3RlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgb25zZWxlY3RlZDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xuXHRcdFx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XG5cdFx0XHQgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XG5cdFx0XHQgKiAgICAgICAgLi4uXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25zZWxlY3RlZDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgdW4tc2VsZWN0aW9uLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG5cdFx0XHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cblx0XHRcdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cblx0XHRcdCAqICAgICAgICAuLi5cblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbnVuc2VsZWN0ZWQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtaW5pbXVtIGRhdGFcblx0XHRcdCAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxuXHRcdFx0ICogQG5hbWUgZGF0YeKApG9ubWluXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Pbk1pbk1heENhbGxiYWNrKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBvbm1pbjogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0ICogICAgLy8gZGF0YSAtIGV4KSBbe3g6IDMsIHZhbHVlOiA0MDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAzfSwgLi4uIF1cblx0XHQgICAgICogICAgLi4uXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29ubWluOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1heGltdW0gZGF0YVxuXHRcdFx0ICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25tYXhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIG9ubWF4OiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxuXHRcdCAgICAgKiAgICAuLi5cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25tYXg6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMb2FkIGEgQ1NWIG9yIEpTT04gZmlsZSBmcm9tIGEgVVJMLiBOT1RFIHRoYXQgdGhpcyB3aWxsIG5vdCB3b3JrIGlmIGxvYWRpbmcgdmlhIHRoZSBcImZpbGU6Ly9cIiBwcm90b2NvbCBhcyB0aGUgbW9zdCBicm93c2VycyB3aWxsIGJsb2NrIFhNTEhUVFBSZXF1ZXN0cy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKR1cmxcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Mb2FkRGF0YSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCJcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV91cmw6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBYSFIgaGVhZGVyIHZhbHVlXG5cdFx0XHQgKiAtICoqTk9URToqKiBTaG91bGQgYmUgdXNlZCB3aXRoIGBkYXRhLnVybGAgb3B0aW9uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkaGVhZGVyc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NldFJlcXVlc3RIZWFkZXJcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCIsXG5cdFx0XHQgKiAgICAgaGVhZGVyczoge1xuXHRcdFx0ICogICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC94bWxcIixcblx0XHRcdCAqICAgICAgICAuLi5cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfaGVhZGVyczogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFBhcnNlIGEgSlNPTiBvYmplY3QgZm9yIGRhdGEuIFNlZSBhbHNvIGRhdGEua2V5cy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRqc29uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbZGF0YeKApGtleXNdKCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5KU09ORGF0YSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAganNvbjogW1xuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cblx0XHRcdCAqICAgICBdLFxuXHRcdFx0ICogICAgIGtleXM6IHtcblx0XHRcdCAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xuXHRcdFx0ICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2pzb246IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGF0YSBuYW1lcywgdGhlIGZvbGxvd2luZyBjb250YWluaW5nIHJlbGF0ZWQgZGF0YSBpbiB0aGF0IG9yZGVyLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHJvd3Ncblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLlJvd09yaWVudGVkRGF0YSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHJvd3M6IFtcblx0XHRcdCAqICAgICBbXCJBXCIsIFwiQlwiLCBcIkNcIl0sXG5cdFx0XHQgKiAgICAgWzkwLCAxMjAsIDMwMF0sXG5cdFx0XHQgKiAgICAgWzQwLCAxNjAsIDI0MF0sXG5cdFx0XHQgKiAgICAgWzUwLCAyMDAsIDI5MF0sXG5cdFx0XHQgKiAgICAgWzEyMCwgMTYwLCAyMzBdLFxuXHRcdFx0ICogICAgIFs4MCwgMTMwLCAzMDBdLFxuXHRcdFx0ICogICAgIFs5MCwgMjIwLCAzMjBdXG5cdFx0XHQgKiAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBmb3IgJ3JhbmdlJyB0eXBlcygnYXJlYS1saW5lLXJhbmdlJyBvciAnYXJlYS1zcGxpbmUtcmFuZ2UnKSwgZGF0YSBzaG91bGQgY29udGFpbjpcblx0XHRcdCAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcblx0XHRcdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHJvd3M6IFtcblx0XHRcdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcblx0XHRcdCAqICAgICAgW1xuXHRcdFx0ICogICAgICAgIC8vIG9yIHtoaWdoOjE1MCwgbWlkOiAxNDAsIGxvdzogMTEwfSwgMTIwXG5cdFx0XHQgKiAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAxMjBcblx0XHRcdCAqICAgICAgXSxcblx0XHRcdCAqICAgICAgW1sxNTUsIDEzMCwgMTE1XSwgNTVdLFxuXHRcdFx0ICogICAgICBbWzE2MCwgMTM1LCAxMjBdLCA2MF1cblx0XHRcdCAqICAgXSxcblx0XHRcdCAqICAgdHlwZXM6IHtcblx0XHRcdCAqICAgICAgIGRhdGExOiBcImFyZWEtbGluZS1yYW5nZVwiLFxuXHRcdFx0ICogICAgICAgZGF0YTI6IFwibGluZVwiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9yb3dzOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTG9hZCBkYXRhIGZyb20gYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5LCB3aXRoIGVhY2ggZWxlbWVudCBjb250YWluaW5nIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgYSBkYXR1bSBuYW1lIGFuZCBhc3NvY2lhdGVkIGRhdGEgdmFsdWVzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGNvbHVtbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNvbHVtbk9yaWVudGVkRGF0YSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGNvbHVtbnM6IFtcblx0XHRcdCAqICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwLCA1MCwgNDAsIDYwLCA1MF0sXG5cdFx0XHQgKiAgICAgIFtcImRhdGEyXCIsIDIwMCwgMTMwLCA5MCwgMjQwLCAxMzAsIDIyMF0sXG5cdFx0XHQgKiAgICAgIFtcImRhdGEzXCIsIDMwMCwgMjAwLCAxNjAsIDQwMCwgMjUwLCAyNTBdXG5cdFx0XHQgKiAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBmb3IgJ3JhbmdlJyB0eXBlcygnYXJlYS1saW5lLXJhbmdlJyBvciAnYXJlYS1zcGxpbmUtcmFuZ2UnKSwgZGF0YSBzaG91bGQgY29udGFpbjpcblx0XHRcdCAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcblx0XHRcdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGNvbHVtbnM6IFtcblx0XHRcdCAqICAgICAgW1wiZGF0YTFcIixcblx0XHRcdCAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXSwgIC8vIG9yIHtoaWdoOjE1MCwgbWlkOiAxNDAsIGxvdzogMTEwfVxuXHRcdFx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLFxuXHRcdFx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdXG5cdFx0XHQgKiAgICAgIF1cblx0XHRcdCAqICAgXSxcblx0XHRcdCAqICAgdHlwZTogXCJhcmVhLWxpbmUtcmFuZ2VcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2NvbHVtbnM6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBVc2VkIGlmIGxvYWRpbmcgSlNPTiB2aWEgZGF0YS51cmwuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbWltZVR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX21pbWVUeXBlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0IGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuXG5cdFx0XHQgKiAtICoqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRrZXlzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBqc29uOiBbXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxuXHRcdFx0ICogICAgIF0sXG5cdFx0XHQgKiAgICAga2V5czoge1xuXHRcdFx0ICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXG5cdFx0XHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfa2V5czogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxuXHRcdFx0ICogLSBleC4gVG9nZ2xpbmcgYWxsIHZpc2libGUgZGF0YSB0byBub3QgYmUgc2hvd24sIHVubG9hZGluZyBhbGwgY3VycmVudCBkYXRhLCBldGMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkZW1wdHnigKRsYWJlbOKApHRleHRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgZW1wdHk6IHtcblx0XHRcdCAqICAgICBsYWJlbDoge1xuXHRcdFx0ICogICAgICAgdGV4dDogXCJObyBEYXRhXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBzdWJjaGFydCBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBzdWJjaGFydFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5zaG93PWZhbHNlXSBTaG93IHN1YiBjaGFydCBvbiB0aGUgYm90dG9tIG9mIHRoZSBjaGFydC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2sudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdWJjaGFydC5zaXplLmhlaWdodF0gQ2hhbmdlIHRoZSBoZWlnaHQgb2YgdGhlIHN1YmNoYXJ0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3N1YmNoYXJ0Lm9uYnJ1c2hdIFNldCBjYWxsYmFjayBmb3IgYnJ1c2ggZXZlbnQuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgY3VycmVudCB6b29tZWQgeCBkb21haW4uXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uU3ViQ2hhcnQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHN1YmNoYXJ0OiB7XG5cdFx0XHQgKiBcdFx0YXhpczoge1xuXHRcdFx0ICogXHRcdFx0eDoge1xuXHRcdFx0ICogXHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0ICogXHRcdFx0XHR0aWNrOiB7XG5cdFx0XHQgKiBcdFx0XHRcdFx0c2hvdzogdHJ1ZSxcblx0XHRcdCAqIFx0XHRcdFx0XHR0ZXh0OiB7XG5cdFx0XHQgKiBcdFx0XHRcdFx0XHRzaG93OiBmYWxzZVxuXHRcdFx0ICogXHRcdFx0XHRcdH1cblx0XHRcdCAqIFx0XHRcdFx0fVxuXHRcdFx0ICogXHRcdFx0fVxuXHRcdFx0ICogXHRcdH0sXG5cdFx0XHQgKiAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIHNpemU6IHtcblx0XHRcdCAqICAgICAgICAgIGhlaWdodDogMjBcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgb25icnVzaDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRzdWJjaGFydF9zaG93OiBmYWxzZSxcblx0XHRcdHN1YmNoYXJ0X3NpemVfaGVpZ2h0OiA2MCxcblx0XHRcdHN1YmNoYXJ0X2F4aXNfeF9zaG93OiB0cnVlLFxuXHRcdFx0c3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcblx0XHRcdHN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdzogdHJ1ZSxcblx0XHRcdHN1YmNoYXJ0X29uYnJ1c2g6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjb2xvciBvZiB0aGUgZGF0YSB2YWx1ZXNcblx0XHRcdCAqIEBuYW1lIGNvbG9yXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gW2NvbG9yLm9ub3Zlcl0gU2V0IHRoZSBjb2xvciB2YWx1ZSBmb3IgZWFjaCBkYXRhIHBvaW50IHdoZW4gbW91c2UvdG91Y2ggb25vdmVyIGV2ZW50IG9jY3Vycy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci5wYXR0ZXJuXSBjdXN0b20gY29sb3IgcGF0dGVyblxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbG9yLnRpbGVzXSBpZiBkZWZpbmVkLCBhbGxvd3MgdXNlIHN2ZydzIHBhdHRlcm5zIHRvIGZpbGwgZGF0YSBhcmVhLiBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFtTVkdQYXR0ZXJuRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR1BhdHRlcm5FbGVtZW50KS5cblx0XHRcdCAqICAtICoqTk9URToqKiBUaGUgcGF0dGVybiBlbGVtZW50J3MgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLSRDT0xPUi1WQUxVRWAuPGJyPlxuXHRcdFx0ICogICAgZXguIFdoZW4gY29sb3IgcGF0dGVybiB2YWx1ZSBpcyBgWydyZWQnLCAnI2ZmZiddYCBhbmQgZGVmaW5lZCAyIHBhdHRlcm5zLHRoZW4gaWRzIGZvciBwYXR0ZXJuIGVsZW1lbnRzIGFyZTo8YnI+XG5cdFx0XHQgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLXJlZGBcblx0XHRcdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tZmZmYFxuXHRcdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IFtjb2xvci50aHJlc2hvbGRdIGNvbG9yIHRocmVzaG9sZCBmb3IgZ2F1Z2UgYW5kIHRvb2x0aXAgY29sb3Jcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29sb3IudGhyZXNob2xkLnVuaXRdIElmIHNldCB0byBgdmFsdWVgLCB0aGUgdGhyZXNob2xkIHdpbGwgYmUgYmFzZWQgb24gdGhlIGRhdGEgdmFsdWUuIE90aGVyd2lzZSBpdCdsbCBiZSBiYXNlZCBvbiBlcXVhdGlvbiBvZiB0aGUgYHRocmVzaG9sZC5tYXhgIG9wdGlvbiB2YWx1ZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci50aHJlc2hvbGQudmFsdWVzXSBUaHJlc2hvbGQgdmFsdWVzIGZvciBlYWNoIHN0ZXBzXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IudGhyZXNob2xkLm1heD0xMDBdIFRoZSBiYXNlIHZhbHVlIHRvIGRldGVybWluZSB0aHJlc2hvbGQgc3RlcCB2YWx1ZSBjb25kaXRpb24uIFdoZW4gdGhlIGdpdmVuIHZhbHVlIGlzIDE1IGFuZCBtYXggMTAsIHRoZW4gdGhlIHZhbHVlIGZvciB0aHJlc2hvbGQgaXMgYDE1KjEwMC8xMGAuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGNvbG9yOiB7XG5cdFx0XHQgKiAgICAgIHBhdHRlcm46IFtcIiMxZjc3YjRcIiwgXCIjYWVjN2U4XCIsIC4uLl0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBTZXQgY29sb3JzJyBwYXR0ZXJuc1xuXHRcdFx0ICogICAgICAvLyBpdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFNWR1BhdHRlcm5FbGVtZW50XG5cdFx0XHQgKiAgICAgIHRpbGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgICAgdmFyIHBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdHRlcm5cIik7XG5cdFx0XHQgKiAgICAgICAgIHZhciBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuXHRcdFx0ICogICAgICAgICB2YXIgY2lyY2xlMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjMyXCIpO1xuXHRcdFx0ICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjMyXCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgZy5zdHlsZS5maWxsID0gXCIjMDAwXCI7XG5cdFx0XHQgKiAgICAgICAgIGcuc3R5bGUub3BhY2l0eSA9IFwiMC4yXCI7XG4gICAgICAgICAgICAgKlxuXHRcdFx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN4XCIsIFwiM1wiKTtcblx0XHRcdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBcIjNcIik7XG5cdFx0XHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiclwiLCBcIjNcIik7XG4gICAgICAgICAgICAgKlxuXHRcdFx0ICogICAgICAgICBnLmFwcGVuZENoaWxkKGNpcmNsZTEpO1xuXHRcdFx0ICogICAgICAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGcpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuXTtcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGZvciB0aHJlc2hvbGQgdXNhZ2UsIHBhdHRlcm4gdmFsdWVzIHNob3VsZCBiZSBzZXQgZm9yIGVhY2ggc3RlcHNcblx0XHRcdCAqICAgICAgcGF0dGVybjogW1wiZ3JleVwiLCBcImdyZWVuXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxuXHRcdFx0ICogICAgICB0aHJlc2hvbGQ6IHtcblx0XHRcdCAqICAgICAgICAgIHVuaXQ6IFwidmFsdWVcIixcblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzAsIDQwLCA1MF0sICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyAyMCwgJ2dyZWVuJyB3aWxsIGJlIHNldCBhbmQgdGhlIHZhbHVlIGlzIDQwLCAnb3JhbmdlJyB3aWxsIGJlIHNldC5cblx0XHRcdCAqICAgICAgICAgIG1heDogMzAgIC8vIHRoZSBlcXVhdGlvbiBmb3IgbWF4IGlzOiB2YWx1ZSoxMDAvMzBcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNldCBhbGwgZGF0YSB0byAncmVkJ1xuXHRcdFx0ICogICAgICBvbm92ZXI6IFwicmVkXCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgZGlmZmVyZW50IGNvbG9yIGZvciBkYXRhXG5cdFx0XHQgKiAgICAgIG9ub3Zlcjoge1xuXHRcdFx0ICogICAgICAgICAgZGF0YTE6IFwicmVkXCIsXG5cdFx0XHQgKiAgICAgICAgICBkYXRhMjogXCJ5ZWxsb3dcIlxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gd2lsbCBwYXNzIGRhdGEgb2JqZWN0IHRvIHRoZSBjYWxsYmFja1xuXHRcdFx0ICogICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBkLmlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJncmVlblwiO1xuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRjb2xvcl9wYXR0ZXJuOiBbXSxcblx0XHRcdGNvbG9yX3RpbGVzOiB1bmRlZmluZWQsXG5cdFx0XHRjb2xvcl90aHJlc2hvbGQ6IHt9LFxuXHRcdFx0Y29sb3Jfb25vdmVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTGVnZW5kIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGxlZ2VuZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGVnZW5kLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLmhpZGU9ZmFsc2VdIEhpZGUgbGVnZW5kXG5cdFx0XHQgKiAgSWYgdHJ1ZSBnaXZlbiwgYWxsIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi4gSWYgc3RyaW5nIG9yIGFycmF5IGdpdmVuLCBvbmx5IHRoZSBsZWdlbmQgdGhhdCBoYXMgdGhlIGlkIHdpbGwgYmUgaGlkZGVuLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR9IFtsZWdlbmQuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIGxlZ2VuZCBpdGVtcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfEZ1bmN0aW9ufSBbbGVnZW5kLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IGl0ZW0ncyB0ZW1wbGF0ZS48YnI+XG5cdFx0XHQgKiAgLSBJZiBzZXQgYHN0cmluZ2AgdmFsdWUsIHdpdGhpbiB0ZW1wbGF0ZSB0aGUgJ2NvbG9yJyBhbmQgJ3RpdGxlJyBjYW4gYmUgcmVwbGFjZWQgdXNpbmcgdGVtcGxhdGUtbGlrZSBzeW50YXggc3RyaW5nOlxuXHRcdFx0ICogICAgLSB7PUNPTE9SfTogZGF0YSBjb2xvciB2YWx1ZVxuXHRcdFx0ICogICAgLSB7PVRJVExFfTogZGF0YSB0aXRsZSB2YWx1ZVxuXHRcdFx0ICogIC0gSWYgc2V0IGBmdW5jdGlvbmAgdmFsdWUsIHdpbGwgcGFzcyBmb2xsb3dpbmcgYXJndW1lbnRzIHRvIHRoZSBnaXZlbiBmdW5jdGlvbjpcblx0XHRcdCAqICAgLSB0aXRsZSB7U3RyaW5nfTogZGF0YSdzIGlkIHZhbHVlXG5cdFx0XHQgKiAgIC0gY29sb3Ige1N0cmluZ306IGNvbG9yIHN0cmluZ1xuXHRcdFx0ICogICAtIGRhdGEge0FycmF5fTogZGF0YSBhcnJheVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtsZWdlbmQucG9zaXRpb249Ym90dG9tXSBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIGxlZ2VuZC48YnI+XG5cdFx0XHQgKiAgQXZhaWxhYmxlIHZhbHVlcyBhcmU6IGBib3R0b21gLCBgcmlnaHRgIGFuZCBgaW5zZXRgIGFyZSBzdXBwb3J0ZWQuXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW2xlZ2VuZC5pbnNldD17YW5jaG9yOiAndG9wLWxlZnQnLHg6IDEwLHk6IDAsc3RlcDogdW5kZWZpbmVkfV0gQ2hhbmdlIGluc2V0IGxlZ2VuZCBhdHRyaWJ1dGVzLjxicj5cblx0XHRcdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5cyBgYW5jaG9yYCwgYHhgLCBgeWAgYW5kIGBzdGVwYC5cblx0XHRcdCAqICAtICoqYW5jaG9yKiogZGVjaWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZDpcblx0XHRcdCAqICAgLSB0b3AtbGVmdFxuXHRcdFx0ICogICAtIHRvcC1yaWdodFxuXHRcdFx0ICogICAtIGJvdHRvbS1sZWZ0XG5cdFx0XHQgKiAgIC0gYm90dG9tLXJpZ2h0XG5cdFx0XHQgKiAgLSAqKngqKiBhbmQgKip5Kio6XG5cdFx0XHQgKiAgIC0gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGJhc2VkIG9uIHRoZSBhbmNob3IuXG5cdFx0XHQgKiAgLSAqKnN0ZXAqKjpcblx0XHRcdCAqICAgLSBkZWZpbmVzIHRoZSBtYXggc3RlcCB0aGUgbGVnZW5kIGhhcyAoZS5nLiBJZiAyIHNldCBhbmQgbGVnZW5kIGhhcyAzIGxlZ2VuZCBpdGVtLCB0aGUgbGVnZW5kIDIgY29sdW1ucykuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuZXF1YWxseT1mYWxzZV0gU2V0IHRvIGFsbCBpdGVtcyBoYXZlIHNhbWUgd2lkdGggc2l6ZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5wYWRkaW5nPTBdIFNldCBwYWRkaW5nIHZhbHVlXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25jbGljaz11bmRlZmluZWRdIFNldCBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm92ZXI9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm91dD11bmRlZmluZWRdIFNldCBtb3VzZS90b3VjaCBvdXQgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUud2lkdGg9MTBdIFNldCB3aWR0aCBvZiBpdGVtIHRpbGUgZWxlbWVudFxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLmhlaWdodD0xMF0gU2V0IGhlaWdodCBvZiBpdGVtIHRpbGUgZWxlbWVudFxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnVzZVBvaW50PWZhbHNlXSBXaGV0aGVyIHRvIHVzZSBjdXN0b20gcG9pbnRzIGluIGxlZ2VuZC5cblx0XHRcdCAqIEBzZWUgW0RlbW86IHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFBvc2l0aW9uKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogY29udGVudHMudGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kVGVtcGxhdGUxKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogdXNlUG9pbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQudXNlUG9pbnQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGxlZ2VuZDoge1xuXHRcdFx0ICogICAgICBzaG93OiB0cnVlLFxuXHRcdFx0ICogICAgICBoaWRlOiB0cnVlLFxuXHRcdFx0ICogICAgICAvL29yIGhpZGU6IFwiZGF0YTFcIlxuICAgICAgICAgICAgICogICAgICAvL29yIGhpZGU6IFtcImRhdGExXCIsIFwiZGF0YTJcIl1cblx0XHRcdCAqICAgICAgY29udGVudHM6IHtcblx0XHRcdCAqICAgICAgICAgIGJpbmR0bzogXCIjbGVnZW5kXCIsICAgLy8gPHVsIGlkPSdsZWdlbmQnPjwvdWw+XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gd2lsbCBiZSBhczogPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiMxZjc3YjQnPmRhdGExPC9saT5cblx0XHRcdCAqICAgICAgICAgIHRlbXBsYXRlOiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfSc+ez1USVRMRX08L2xpPlwiXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gb3IgdXNpbmcgZnVuY3Rpb25cblx0XHRcdCAqICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihpZCwgY29sb3IsIGRhdGEpIHtcblx0XHRcdCAqICAgICAgICAgICAgICAgLy8gaWYgeW91IHdhbnQgb21pdCBzb21lIGxlZ2VuZCwgcmV0dXJuIGZhbHN5IHZhbHVlXG5cdFx0XHQgKiAgICAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gXCJkYXRhMVwiKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOlwiKyBjb2xvciArXCI+XCIrIHRpdGxlICtcIjwvbGk+XCI7XG5cdFx0XHQgKiAgICAgICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcbiAgICAgICAgICAgICAqICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsICAvLyBib3R0b20sIHJpZ2h0LCBpbnNldFxuXHRcdFx0ICogICAgICBpbnNldDoge1xuXHRcdFx0ICogICAgICAgICAgYW5jaG9yOiBcInRvcC1yaWdodFwiICAvLyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0XG5cdFx0XHQgKiAgICAgICAgICB4OiAyMCxcblx0XHRcdCAqICAgICAgICAgIHk6IDEwLFxuXHRcdFx0ICogICAgICAgICAgc3RlcDogMlxuXHRcdFx0ICogICAgICB9LFxuICAgICAgICAgICAgICogICAgICBlcXVhbGx5OiBmYWxzZSxcbiAgICAgICAgICAgICAqICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgICAgICAgKiAgICAgIGl0ZW06IHtcblx0XHRcdCAqICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICAgICAgb25vdmVyOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgICAgIG9ub3V0OiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyBzZXQgdGlsZSdzIHNpemVcblx0XHRcdCAqICAgICAgICAgIHRpbGU6IHtcblx0XHRcdCAqICAgICAgICAgICAgICB3aWR0aDogMjAsXG5cdFx0XHQgKiAgICAgICAgICAgICAgaGVpZ2h0OiAxNVxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICB1c2VQb2ludDogdHJ1ZVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0bGVnZW5kX3Nob3c6IHRydWUsXG5cdFx0XHRsZWdlbmRfaGlkZTogZmFsc2UsXG5cdFx0XHRsZWdlbmRfY29udGVudHNfYmluZHRvOiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfY29udGVudHNfdGVtcGxhdGU6IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9wb3NpdGlvbjogXCJib3R0b21cIixcblx0XHRcdGxlZ2VuZF9pbnNldF9hbmNob3I6IFwidG9wLWxlZnRcIixcblx0XHRcdGxlZ2VuZF9pbnNldF94OiAxMCxcblx0XHRcdGxlZ2VuZF9pbnNldF95OiAxMCxcblx0XHRcdGxlZ2VuZF9pbnNldF9zdGVwOiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfaXRlbV9vbmNsaWNrOiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfaXRlbV9vbm92ZXI6IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9pdGVtX29ub3V0OiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfZXF1YWxseTogZmFsc2UsXG5cdFx0XHRsZWdlbmRfcGFkZGluZzogMCxcblx0XHRcdGxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg6IDEwLFxuXHRcdFx0bGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQ6IDEwLFxuXHRcdFx0bGVnZW5kX3VzZVBvaW50OiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTd2l0Y2ggeCBhbmQgeSBheGlzIHBvc2l0aW9uLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHJvdGF0ZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICByb3RhdGVkOiB0cnVlXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfcm90YXRlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHggYXhpcyBlbGVtZW50XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGNsaXBQYXRoXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXSgpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxuXHRcdFx0ICogY2xpcFBhdGg6IGZhbHNlXG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9jbGlwUGF0aDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeCBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdHlwZSBvZiB4IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogLSB0aW1lc2VyaWVzXG5cdFx0XHQgKiAtIGNhdGVnb3J5XG5cdFx0XHQgKiAtIGluZGV4ZWRcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdHlwZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCBpbmRleGVkXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBpbmRleGVkXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxuXHRcdFx0ICogQHNlZSBbRGVtbzogdGltZXNlcmllc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlRpbWVzZXJpZXNDaGFydClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGNhdGVnb3J5XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5DYXRlZ29yeURhdGEpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdHlwZTogXCJpbmRleGVkXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGhvdyB0byB0cmVhdCB0aGUgdGltZXpvbmUgb2YgeCB2YWx1ZXMuPGJyPlxuXHRcdFx0ICogSWYgdHJ1ZSwgdHJlYXQgeCB2YWx1ZSBhcyBsb2NhbHRpbWUuIElmIGZhbHNlLCBjb252ZXJ0IHRvIFVUQyBpbnRlcm5hbGx5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRsb2NhbHRpbWVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBsb2NhbHRpbWU6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2xvY2FsdGltZTogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cblx0XHRcdCAqIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGNhdGVnb3J5IG5hbWVzIGluIHN0cmluZy4gSWYgY2F0ZWdvcnkgbmFtZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBkYXRlIGJ5IGRhdGEueCBvcHRpb24sIHRoaXMgaXMgbm90IHJlcXVpcmVkLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRjYXRlZ29yaWVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgW11cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBjYXRlZ29yaWVzOiBbXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5dXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2NhdGVnb3JpZXM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIGNlbnRlcml6ZSB0aWNrcyBvbiBjYXRlZ29yeSBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY2VudGVyZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY2VudGVyZWQ6IHRydWVcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfY2VudGVyZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgZnVuY3Rpb24gdG8gZm9ybWF0IHRpY2sgdmFsdWUuIEZvcm1hdCBzdHJpbmcgaXMgYWxzbyBhdmFpbGFibGUgZm9yIHRpbWVzZXJpZXMgZGF0YS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZvcm1hdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcywgYSAnZGF0ZXRpbWUnIG9iamVjdCBpcyBnaXZlbiBhcyBwYXJhbWV0ZXJcblx0XHRcdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgIHJldHVybiB4LmdldEZ1bGxZZWFyKCk7XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgLy8gZm9yIGNhdGVnb3J5LCBpbmRleChOdW1iZXIpIGFuZCBjYXRlZ29yeU5hbWUoU3RyaW5nKSBhcmUgZ2l2ZW4gYXMgcGFyYW1ldGVyXG5cdFx0XHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKGluZGV4LCBjYXRlZ29yeU5hbWUpIHtcblx0XHRcdCAqICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlOYW1lLnN1YnN0cigwLCAxMCk7XG5cdFx0XHQgKiAgICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcyBmb3JtYXQgc3BlY2lmaWVyXG5cdFx0XHQgKiAgICAgICAgZm9ybWF0OiBcIiVZLSVtLSVkICVIOiVNOiVTXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfZm9ybWF0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0dGluZyBmb3IgY3VsbGluZyB0aWNrcy48YnI+PGJyPlxuXHRcdFx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XG5cdFx0XHQgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy54LnRpY2suY3VsbGluZy5tYXguXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjdWxsaW5nXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdFxuXHRcdFx0ICogLSB0cnVlIGZvciBpbmRleGVkIGF4aXMgYW5kIHRpbWVzZXJpZXMgYXhpc1xuXHRcdFx0ICogLSBmYWxzZSBmb3IgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2N1bGxpbmc6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY3VsbGluZ+KApG1heFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCAxMFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGN1bGxpbmc6IHtcblx0XHRcdCAqICAgICAgICAgICBtYXg6IDVcblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfY3VsbGluZ19tYXg6IDEwLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBudW1iZXIgb2YgeCBheGlzIHRpY2tzIHRvIHNob3cuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGhpZGVzIHRpY2sgbGluZXMgdG9nZXRoZXIgd2l0aCB0aWNrIHRleHQuIElmIHRoaXMgb3B0aW9uIGlzIHVzZWQgb24gdGltZXNlcmllcyBheGlzLCB0aGUgdGlja3MgcG9zaXRpb24gd2lsbCBiZSBkZXRlcm1pbmVkIHByZWNpc2VseSBhbmQgbm90IG5pY2VseSBwb3NpdGlvbmVkIChlLmcuIGl0IHdpbGwgaGF2ZSByb3VnaCBzZWNvbmQgdmFsdWUpLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY291bnRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY291bnQ6IDVcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSB4IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRwb3NpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICB4OiAxMCxcblx0XHRcdCAqICAgICAgICAgICB5OiAxMFxuXHRcdFx0ICogICAgICAgICB9XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaXQgeCBheGlzIHRpY2tzLlxuXHRcdFx0ICogLSAqKnRydWUqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIG5pY2VseSB0byBoYXZlIHNhbWUgaW50ZXJ2YWxzLlxuXHRcdFx0ICogLSAqKmZhbHNlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBhY2NvcmRpbmcgdG8geCB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRmaXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja0ZpdHRpbmcpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBmb3IgdGltZXNlcmllcyB6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tUaW1lc2VyaWVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGZpdDogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfZml0OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgeCB2YWx1ZXMgb2YgdGlja3MgbWFudWFsbHkuPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMuIFRoaXMgb3B0aW9uIHdvcmtzIHdpdGggdGltZXNlcmllcyBkYXRhIGFuZCB0aGUgeCB2YWx1ZXMgd2lsbCBiZSBwYXJzZWQgYWNjb2RpbmcgdG8gdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGFuZCBkYXRhLnhGb3JtYXQgb3B0aW9uLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdmFsdWVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHZhbHVlczogWzEsIDIsIDQsIDgsIDE2LCAzMiwgLi4uXVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja192YWx1ZXM6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUm90YXRlIHggYXhpcyB0aWNrIHRleHQuPGJyPlxuXHRcdFx0ICogSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkcm90YXRlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IDBcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlJvdGF0ZVhBeGlzVGlja1RleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgcm90YXRlOiA2MFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19yb3RhdGU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyB4IGF4aXMgb3V0ZXIgdGljay5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG91dGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgb3V0ZXI6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX291dGVyOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aWNrIHRleHQgdG8gYmUgbXVsdGlsaW5lXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsgYW5kICdheGlzLngudGljay53aWR0aCcgb3B0aW9uIGlzIGlnbm9yZWQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRtdWx0aWxpbmVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja011bHRpbGluZSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBtdWx0aWxpbmU6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gZXhhbXBsZSBvZiBsaW5lIGJyZWFrIHdpdGggJ1xcbidcblx0XHRcdCAqIC8vIEluIHRoaXMgY2FzZSwgJ2F4aXMueC50aWNrLndpZHRoJyBpcyBpZ25vcmVkXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICB4OiBcInhcIixcblx0XHRcdCAqICAgIGNvbHVtbnM6IFtcblx0XHRcdCAqICAgICAgICBbXCJ4XCIsIFwibG9uZ1xcbnRleHRcIiwgXCJBbm90aGVyXFxuTG9uZ1xcblRleHRcIl0sXG5cdFx0XHQgKiAgICAgICAgLi4uXG5cdFx0XHQgKiAgICBdLFxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19tdWx0aWxpbmU6IHRydWUsXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGljayB3aWR0aFxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR3aWR0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgd2lkdGg6IDUwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3dpZHRoOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0byBkaXNwbGF5IHN5c3RlbSB0b29sdGlwKHZpYSAndGl0bGUnIGF0dHJpYnV0ZSkgZm9yIHRpY2sgdGV4dFxuXHRcdFx0ICogLSAqKk5PVEU6KiogT25seSBhdmFpbGFibGUgZm9yIGNhdGVnb3J5IGF4aXMgdHlwZSAoYGF4aXMueC50eXBlPSdjYXRlZ29yeSdgKVxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdG9vbHRpcFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0b29sdGlwOiB0cnVlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3Rvb2x0aXA6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtYXggdmFsdWUgb2YgeCBheGlzIHJhbmdlLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRtYXhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgbWF4OiAxMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfbWF4OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IG1pbiB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApG1pblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBtaW46IC0xMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfbWluOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBhZGRpbmcgZm9yIHggYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgcmFuZ2Ugb2YgeCBheGlzIHdpbGwgaW5jcmVhc2UvZGVjcmVhc2UgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZXMuXG5cdFx0XHQgKiBJZiBubyBwYWRkaW5nIGlzIG5lZWRlZCBpbiB0aGUgcmFnZSBvZiB4IGF4aXMsIDAgc2hvdWxkIGJlIHNldC5cblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgIFRoZSBwYWRkaW5nIHZhbHVlcyBhcmVuJ3QgYmFzZWQgb24gcGl4ZWxzLiBJdCBkaWZmZXJzIGFjY29yZGluZyBheGlzIHR5cGVzPGJyPlxuXHRcdFx0ICogICAtICoqY2F0ZWdvcnk6KiogVGhlIHVuaXQgb2YgdGljayB2YWx1ZVxuXHRcdFx0ICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDFgLCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcblx0XHRcdCAqICAgLSAqKnRpbWVzZXJpZXM6KiogTnVtZXJpYyB0aW1lIHZhbHVlXG5cdFx0XHQgKiAgICAgZXguIHRoZSBnaXZlbiB2YWx1ZSBgMTAwMCo2MCo2MCoyNGAsIHdoaWNoIGlzIG51bWVyaWMgdGltZSBlcXVpdmFsZW50IG9mIGEgZGF5LCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkcGFkZGluZ1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHBhZGRpbmc6IHtcblx0XHRcdCAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICdjYXRlZ29yeSdcblx0XHRcdCAqICAgICAgIGxlZnQ6IDEsICAvLyBzZXQgbGVmdCBwYWRkaW5nIHdpZHRoIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSB0aWNrJ3Mgd2lkdGhcblx0XHRcdCAqICAgICAgIHJpZ2h0OiAwLjUgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiB0aWNrJ3Mgd2lkdGhcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyB3aGVuIGF4aXMgdHlwZSBpcyAndGltZXNlcmllcydcblx0XHRcdCAqICAgICAgIGxlZnQ6IDEwMDAqNjAqNjAqMjQsICAvLyBzZXQgbGVmdCBwYWRkaW5nIHdpZHRoIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXG5cdFx0XHQgKiAgICAgICByaWdodDogMTAwMCo2MCo2MCoxMiAgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3BhZGRpbmc6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBoZWlnaHQgb2YgeCBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBUaGUgaGVpZ2h0IG9mIHggYXhpcyBjYW4gYmUgc2V0IG1hbnVhbGx5IGJ5IHRoaXMgb3B0aW9uLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlIGZvciB4IGF4aXMsIHBsZWFzZSB1c2UgdGhpcyBvcHRpb24gZm9yIHRoYXQuIFRoZSB1bml0IGlzIHBpeGVsLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRoZWlnaHRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgaGVpZ2h0OiAyMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9oZWlnaHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZGVmYXVsdCBleHRlbnQgZm9yIHN1YmNoYXJ0IGFuZCB6b29tLiBUaGlzIGNhbiBiZSBhbiBhcnJheSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGV4dGVudFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIC8vIGV4dGVudCByYW5nZSBhcyBhIHBpeGVsIHZhbHVlXG5cdFx0XHQgKiAgICAgZXh0ZW50OiBbMCwgMjAwXSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gd2hlbiBheGlzIGlzICd0aW1lc2VyaWVzJywgcGFyc2FibGUgZGF0ZXRpbWUgc3RyaW5nXG5cdFx0XHQgKiAgICAgZXh0ZW50OiBbXCIyMDE5LTAzLTAxXCIsIFwiMjAxOS0wMy0wNVwiXSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gcmV0dXJuIGV4dGVudCB2YWx1ZVxuXHRcdFx0ICogICAgIGV4dGVudDogZnVuY3Rpb24oZG9tYWluLCBzY2FsZSkge1xuXHRcdFx0ICogICAgXHQgdmFyIGV4dGVudCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24odikge1xuXHRcdFx0ICogICAgIFx0ICAgIHJldHVybiBzY2FsZSh2KTtcblx0XHRcdCAqICAgICBcdCB9KTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgIFx0IC8vIGl0IHNob3VsZCByZXR1cm4gYSBmb3JtYXQgb2YgYXJyYXlcblx0XHRcdCAqICAgXHQgLy8gZXgpIFswLCA1ODRdXG5cdFx0XHQgKiAgICAgXHQgcmV0dXJuIGV4dGVudDtcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2V4dGVudDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBsYWJlbCBvbiB4IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqICBZb3UgY2FuIHNldCB4IGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIHN0cmluZyBhbmQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgYW5kIHdlIGNhbiBjaGFuZ2UgdGhlIHBvaXNpdG9uIGJ5IHBhc3Npbmcgb2JqZWN0IHRoYXQgaGFzIHBvc2l0aW9uIGtleS4gQXZhaWxhYmxlIHBvc2l0aW9uIGRpZmZlcnMgYWNjb3JkaW5nIHRvIHRoZSBheGlzIGRpcmVjdGlvbiAodmVydGljYWwgb3IgaG9yaXpvbnRhbCkuIElmIHN0cmluZyBzZXQsIHRoZSBwb3NpdGlvbiB3aWxsIGJlIHRoZSBkZWZhdWx0LlxuXHRcdFx0ICogIC0gKipJZiBpdCdzIGhvcml6b250YWwgYXhpczoqKlxuXHRcdFx0ICogICAgLSBpbm5lci1yaWdodCBbZGVmYXVsdF1cblx0XHRcdCAqICAgIC0gaW5uZXItY2VudGVyXG5cdFx0XHQgKiAgICAtIGlubmVyLWxlZnRcblx0XHRcdCAqICAgIC0gb3V0ZXItcmlnaHRcblx0XHRcdCAqICAgIC0gb3V0ZXItY2VudGVyXG5cdFx0XHQgKiAgICAtIG91dGVyLWxlZnRcblx0XHRcdCAqICAtICoqSWYgaXQncyB2ZXJ0aWNhbCBheGlzOioqXG5cdFx0XHQgKiAgICAtIGlubmVyLXRvcCBbZGVmYXVsdF1cblx0XHRcdCAqICAgIC0gaW5uZXItbWlkZGxlXG5cdFx0XHQgKiAgICAtIGlubmVyLWJvdHRvbVxuXHRcdFx0ICogICAgLSBvdXRlci10b3Bcblx0XHRcdCAqICAgIC0gb3V0ZXItbWlkZGxlXG5cdFx0XHQgKiAgICAtIG91dGVyLWJvdHRvbVxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRsYWJlbFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IFwiWW91ciBYIEF4aXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKlxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWCBBeGlzXCIsXG5cdFx0XHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItY2VudGVyXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2xhYmVsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB4IEF4aXMuXG5cdFx0XHQgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB4IEF4aXMgdmFsdWVcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG5cdFx0XHQgKlxuXHRcdFx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdFx0XHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdFx0XHQgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XG5cdFx0XHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcblx0XHRcdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuXHRcdFx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogeDoge1xuXHRcdFx0ICogICAgYXhlczogW1xuXHRcdFx0ICogICAgICB7XG5cdFx0XHQgKiAgICAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xuXHRcdFx0ICogICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgIGNvdW50OiAyLFxuXHRcdFx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIC4uLlxuXHRcdFx0ICogICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfYXhlczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHkgYXhpcyBlbGVtZW50XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGNsaXBQYXRoXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxuXHRcdFx0ICogY2xpcFBhdGg6IGZhbHNlXG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9jbGlwUGF0aDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeSBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdHlwZSBvZiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogICAtIHRpbWVzZXJpZXNcblx0XHRcdCAqICAgLSBjYXRlZ29yeVxuXHRcdFx0ICogICAtIGluZGV4ZWRcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdHlwZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90eXBlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IG1heCB2YWx1ZSBvZiB5IGF4aXMuXG5cdFx0XHQgKiAtICoqTk9URToqKiBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRtYXhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgbWF4OiAxMDAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X21heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtaW4gdmFsdWUgb2YgeSBheGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkbWluXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIG1pbjogMTAwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9taW46IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGludmVydGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIGludmVydGVkOiB0cnVlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2ludmVydGVkOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkY2VudGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIGNlbnRlcjogMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9jZW50ZXI6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IHkgYXhpcyBpbnNpZGUgb2YgdGhlIGNoYXJ0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRpbm5lclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBpbm5lcjogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9pbm5lcjogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxhYmVsIG9uIHkgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogWW91IGNhbiBzZXQgeSBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy54LmxhYmVsLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRsYWJlbFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBsYWJlbDogXCJZb3VyIFkgQXhpc1wiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBsYWJlbDoge1xuXHRcdFx0ICogICAgICAgIHRleHQ6IFwiWW91ciBZIEF4aXNcIixcblx0XHRcdCAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1taWRkbGVcIlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfbGFiZWw6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgZDMuZm9ybWF0IG9iamVjdCBhcyB3ZWxsIGFzIGEgZnVuY3Rpb24geW91IGRlZmluZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGZvcm1hdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgIHJldHVybiB4LmdldEZ1bGxZZWFyKCk7XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX2Zvcm1hdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRvdXRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIG91dGVyOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19vdXRlcjogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgeSBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdmFsdWVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHZhbHVlczogWzEwMCwgMTAwMCwgMTAwMDBdXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX3ZhbHVlczogbnVsbCxcblx0XHRcdGF4aXNfeV90aWNrX3JvdGF0ZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cblx0XHRcdCAqIC0gKipOT1RFOioqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBjYWxjdWxhdGVkIHByZWNpc2VseSwgc28gdGhlIHZhbHVlcyBvbiB0aGUgdGlja3Mgd2lsbCBub3QgYmUgcm91bmRlZCBuaWNlbHkuIEluIHRoZSBjYXNlLCBheGlzLnkudGljay5mb3JtYXQgb3IgYXhpcy55LnRpY2sudmFsdWVzIHdpbGwgYmUgaGVscGZ1bC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGNvdW50XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNvdW50OiA1XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX2NvdW50OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIGxpbmUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0KiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgdGV4dC5cblx0XHRcdCogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcblx0XHRcdCogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHRcdCogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCogQGV4YW1wbGVcblx0XHRcdCogYXhpczoge1xuXHRcdFx0KiAgIHk6IHtcblx0XHRcdCogICAgIHRpY2s6IHtcblx0XHRcdCogICAgICAgdGV4dDoge1xuXHRcdFx0KiAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCogICAgICAgfVxuXHRcdFx0KiAgICAgfVxuXHRcdFx0KiAgIH1cblx0XHRcdCogfVxuXHRcdFx0Ki9cblx0XHRcdGF4aXNfeV90aWNrX3RleHRfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIHkgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICBwb3NpdGlvbjoge1xuXHRcdFx0ICogICAgICAgICAgIHg6IDEwLFxuXHRcdFx0ICogICAgICAgICAgIHk6IDEwXG5cdFx0XHQgKiAgICAgICAgIH1cblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcy48YnI+PGJyPlxuXHRcdFx0ICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3RpbWUudmFsdWVdIEQzJ3MgdGltZSBpbnRlcnZhbCBmdW5jdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUjaW50ZXJ2YWxzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRpbWU6IHtcblx0XHRcdCAqICAgICAgICAgIC8vIHRpY2tzIGF0IDE1LW1pbnV0ZSBpbnRlcnZhbHNcblx0XHRcdCAqICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjdGltZV90aWNrc1xuXHRcdFx0ICogICAgICAgICAgdmFsdWU6IGQzLnRpbWVNaW51dGUuZXZlcnkoMTUpXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdC8vIEBUT0RPOiBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0XG5cdFx0XHRheGlzX3lfdGlja190aW1lX3ZhbHVlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBhZGRpbmcgZm9yIHkgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogWW91IGNhbiBzZXQgcGFkZGluZyBmb3IgeSBheGlzIHRvIGNyZWF0ZSBtb3JlIHNwYWNlIG9uIHRoZSBlZGdlIG9mIHRoZSBheGlzLlxuXHRcdFx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxuXHRcdFx0ICpcblx0XHRcdCAqIC0gKipOT1RFOioqIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRwYWRkaW5nXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgcGFkZGluZzoge1xuXHRcdFx0ICogICAgICAgdG9wOiAwLFxuXHRcdFx0ICogICAgICAgYm90dG9tOiAwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9wYWRkaW5nOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeSBheGlzIHdoZW4gdGhlcmUgaXMgbm8gZGF0YSBvbiBpbml0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRkZWZhdWx0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2RlZmF1bHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5IEF4aXMuXG5cdFx0XHQgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB5IEF4aXMgdmFsdWVcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG5cdFx0XHQgKlxuXHRcdFx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdFx0XHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdFx0XHQgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XG5cdFx0XHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcblx0XHRcdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuXHRcdFx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogeToge1xuXHRcdFx0ICogICAgYXhlczogW1xuXHRcdFx0ICogICAgICB7XG5cdFx0XHQgKiAgICAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xuXHRcdFx0ICogICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgIGNvdW50OiAyLFxuXHRcdFx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIC4uLlxuXHRcdFx0ICogICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfYXhlczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBzaG93OiB0cnVlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9zaG93OiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWF4IHZhbHVlIG9mIHkyIGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRtYXhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIG1heDogMTAwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfbWF4OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IG1pbiB2YWx1ZSBvZiB5MiBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkbWluXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBtaW46IC0xMDAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9taW46IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5MiBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIGludmVydGVkOiB0cnVlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9pbnZlcnRlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5MiBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkY2VudGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBjZW50ZXI6IDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX2NlbnRlcjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgeTIgYXhpcyBpbnNpZGUgb2YgdGhlIGNoYXJ0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkaW5uZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIGlubmVyOiB0cnVlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9pbm5lcjogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxhYmVsIG9uIHkyIGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFlvdSBjYW4gc2V0IHkyIGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLngubGFiZWwuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRsYWJlbFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IFwiWW91ciBZMiBBeGlzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBsYWJlbDoge1xuXHRcdFx0ICogICAgICAgIHRleHQ6IFwiWW91ciBZMiBBeGlzXCIsXG5cdFx0XHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9sYWJlbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGZvcm1hdHRlciBmb3IgeTIgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkuZm9ybWF0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGZvcm1hdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBmb3JtYXQ6IGQzLmZvcm1hdChcIiQsXCIpXG5cdFx0XHQgKiAgICAgICAvL29yIGZvcm1hdDogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCIkXCIgKyBkOyB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyBvdXRlciB0aWNrLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApG91dGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIG91dGVyOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfb3V0ZXI6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHkyIGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdmFsdWVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfdmFsdWVzOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgbnVtYmVyIG9mIHkyIGF4aXMgdGlja3MuXG5cdFx0XHQgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjb3VudFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY291bnQ6IDVcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX2NvdW50OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayBsaW5lLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja19zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgdGV4dC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKR0ZXh04oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja190ZXh0X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSB5MiBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICB4OiAxMCxcblx0XHRcdCAqICAgICAgICAgICB5OiAxMFxuXHRcdFx0ICogICAgICAgICB9XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja190ZXh0X3Bvc2l0aW9uOiB7eDogMCwgeTogMH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cblx0XHRcdCAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkcGFkZGluZ1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBwYWRkaW5nOiB7XG5cdFx0XHQgKiAgICAgICB0b3A6IDEwMCxcblx0XHRcdCAqICAgICAgIGJvdHRvbTogMTAwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfcGFkZGluZzoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeTIgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB5MiBheGlzIHdoZW4gdGhlcmUgaXMgbm8gZGF0YSBvbiBpbml0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkZGVmYXVsdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBkZWZhdWx0OiBbMCwgMTAwMF1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX2RlZmF1bHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5MiBBeGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geTIgQXhpcyB2YWx1ZVxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcblx0XHRcdCAqXG5cdFx0XHQgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0XHRcdCAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcblx0XHRcdCAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcblx0XHRcdCAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxuXHRcdFx0ICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XG5cdFx0XHQgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogeTI6IHtcblx0XHRcdCAqICAgIGF4ZXM6IFtcblx0XHRcdCAqICAgICAge1xuXHRcdFx0ICogICAgICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICBjb3VudDogMixcblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICAuLi5cblx0XHRcdCAqICAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9heGVzOiBbXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgcmVsYXRlZCBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBncmlkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Zyb250PWZhbHNlXSBTZXQgJ2dyaWQgJiBmb2N1cyBsaW5lcycgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGdyaWQgbGluZXMgYW5kIGNoYXJ0IGVsZW1lbnRzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbeC5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxuXHRcdFx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLiB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLiBGb3IgcG9zaXRpb24sIHN0YXJ0LCBtaWRkbGUgYW5kIGVuZCAoZGVmYXVsdCkgYXJlIGF2YWlsYWJsZS5cblx0XHRcdCAqICBJZiB4IGF4aXMgaXMgY2F0ZWdvcnkgYXhpcywgdmFsdWUgY2FuIGJlIGNhdGVnb3J5IG5hbWUuIElmIHggYXhpcyBpcyB0aW1lc2VyaWVzIGF4aXMsIHZhbHVlIGNhbiBiZSBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt5LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtBcnJheX0gW3kubGluZXM9W11dIFNob3cgYWRkaXRpb25hbCBncmlkIGxpbmVzIGFsb25nIHkgYXhpcy48YnI+XG5cdFx0XHQgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIHZhbHVlLCB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3kudGlja3M9MTBdIE51bWJlciBvZiB5IGdyaWRzIHRvIGJlIHNob3duLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZm9jdXMuc2hvdz10cnVlXSBTaG93IGdyaWRzIHdoZW4gZm9jdXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lcy5mcm9udD10cnVlXSBTZXQgZ3JpZCBsaW5lcyB0byBiZSBwb3NpdGlvbmVkIG92ZXIgY2hhcnQgZWxlbWVudHMuXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLkdyaWRMaW5lcylcblx0XHRcdCAqIEBzZWUgW0RlbW86IFggR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxYR3JpZExpbmVzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogWSBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFlHcmlkTGluZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZ3JpZDoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICBsaW5lczogW1xuXHRcdFx0ICogICAgICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIG9uIDJcIn0sXG5cdFx0XHQgKiAgICAgICB7dmFsdWU6IDUsIHRleHQ6IFwiTGFiZWwgb24gNVwiLCBjbGFzczogXCJsYWJlbC01XCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiA2LCB0ZXh0OiBcIkxhYmVsIG9uIDZcIiwgcG9zaXRpb246IFwic3RhcnRcIn1cblx0XHRcdCAqICAgICBdXG5cdFx0XHQgKiAgIH0sXG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBzaG93OiB0cnVlLFxuXHRcdFx0ICogICAgIGxpbmVzOiBbXG5cdFx0XHQgKiAgICAgICB7dmFsdWU6IDEwMCwgdGV4dDogXCJMYWJlbCBvbiAxMDBcIn0sXG5cdFx0XHQgKiAgICAgICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCBvbiAyMDBcIiwgY2xhc3M6IFwibGFiZWwtMjAwXCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiAzMDAsIHRleHQ6IFwiTGFiZWwgb24gMzAwXCIsIHBvc2l0aW9uOiAnbWlkZGxlJ31cblx0XHRcdCAqICAgICBdLFxuXHRcdFx0ICogICAgIHRpY2tzOiA1XG5cdFx0XHQgKiAgIH0sXG5cdFx0XHQgKiAgIGZyb250OiB0cnVlLFxuXHRcdFx0ICogICBmb2N1czoge1xuXHRcdFx0ICogICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICB9LFxuXHRcdFx0ICogICBsaW5lczoge1xuXHRcdFx0ICogICAgICBmcm9udDogZmFsc2Vcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRncmlkX3hfc2hvdzogZmFsc2UsXG5cdFx0XHRncmlkX3hfdHlwZTogXCJ0aWNrXCIsXG5cdFx0XHRncmlkX3hfbGluZXM6IFtdLFxuXHRcdFx0Z3JpZF95X3Nob3c6IGZhbHNlLFxuXHRcdFx0Z3JpZF95X2xpbmVzOiBbXSxcblx0XHRcdGdyaWRfeV90aWNrczogMTAsXG5cdFx0XHRncmlkX2ZvY3VzX3Nob3c6IHRydWUsXG5cdFx0XHRncmlkX2Zyb250OiBmYWxzZSxcblx0XHRcdGdyaWRfbGluZXNfZnJvbnQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBvaW50IG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIHBvaW50XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BvaW50LnNob3c9dHJ1ZV0gV2hldGhlciB0byBzaG93IGVhY2ggcG9pbnQgaW4gbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbcG9pbnQucj0yLjVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50LlxuXHRcdFx0ICogIC0gKipOT1RFOioqIERpc2FibGVkIGZvciAnYnViYmxlJyB0eXBlXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwb2ludC5mb2N1cy5leHBhbmQuZW5hYmxlZD10cnVlXSBXaGV0aGVyIHRvIGV4cGFuZCBlYWNoIHBvaW50IG9uIGZvY3VzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb2ludC5mb2N1cy5leHBhbmQucj1wb2ludC5yKjEuNzVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIGZvY3VzLlxuXHRcdFx0ICogIC0gKipOT1RFOioqIEZvciAnYnViYmxlJyB0eXBlLCB0aGUgZGVmYXVsdCBpcyBgYnViYmxlU2l6ZSoxLjE1YFxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb2ludC5zZW5zaXRpdml0eT0xMF0gVGhlIHNlbnN0aXZpdHkgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwb2ludC5zZWxlY3Qucj1wb2ludC5yKjRdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIHNlbGVjdGVkLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtwb2ludC50eXBlPVwiY2lyY2xlXCJdIFRoZSB0eXBlIG9mIHBvaW50IHRvIGJlIGRyYXduXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogIC0gSWYgY2hhcnQgaGFzICdidWJibGUnIHR5cGUsIG9ubHkgY2lyY2xlIGNhbiBiZSB1c2VkLlxuXHRcdFx0ICogIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXG5cdFx0XHQgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogIC0gY2lyY2xlXG5cdFx0XHQgKiAgLSByZWN0YW5nbGVcblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtwb2ludC5wYXR0ZXJuPVtdXSBUaGUgdHlwZSBvZiBwb2ludCBvciBzdmcgc2hhcGUgYXMgc3RyaW5nLCB0byBiZSBkcmF3biBmb3IgZWFjaCBsaW5lXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuXHRcdFx0ICogIC0gSWYgY2hhcnQgaGFzICdidWJibGUnIHR5cGUsIG9ubHkgY2lyY2xlIGNhbiBiZSB1c2VkLlxuXHRcdFx0ICogIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXG5cdFx0XHQgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogIC0gY2lyY2xlXG5cdFx0XHQgKiAgLSByZWN0YW5nbGVcblx0XHRcdCAqICAtIHN2ZyBzaGFwZSB0YWcgaW50ZXJwcmV0ZWQgYXMgc3RyaW5nPGJyPlxuXHRcdFx0ICogICAgKGV4LiBgPHBvbHlnb24gcG9pbnRzPScyLjUgMCAwIDUgNSA1Jz48L3BvbHlnb24+YClcblx0XHRcdCAqIEBzZWUgW0RlbW86IHBvaW50IHR5cGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNQb2ludC5SZWN0YW5nbGVQb2ludHMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHBvaW50OiB7XG5cdFx0XHQgKiAgICAgIHNob3c6IGZhbHNlLFxuXHRcdFx0ICogICAgICByOiA1LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3IgY3VzdG9taXplIHRoZSByYWRpdXNcblx0XHRcdCAqICAgICAgcjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gcjtcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIGZvY3VzOiB7XG5cdFx0XHQgKiAgICAgICAgICBleHBhbmQ6IHtcblx0XHRcdCAqICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHRcdFx0ICogICAgICAgICAgICAgIHI6IDFcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgc2VsZWN0OiB7XG5cdFx0XHQgKiAgICAgICAgICByOiAzXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBoYXZpbmcgbG93ZXIgdmFsdWUsIG1lYW5zIGhvdyBjbG9zZXIgdG8gYmUgZm9yIGludGVyYWN0aW9uXG5cdFx0XHQgKiAgICAgIHNlbnNpdGl2aXR5OiAzLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gdmFsaWQgdmFsdWVzIGFyZSBcImNpcmNsZVwiIG9yIFwicmVjdGFuZ2xlXCJcblx0XHRcdCAqICAgICAgdHlwZTogXCJyZWN0YW5nbGVcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIGluZGljYXRlIGFzIHBhdHRlcm5cbiBcdFx0XHQgKiAgICAgIHBhdHRlcm46IFtcbiBcdFx0XHQgKiAgICAgICAgXCJjaXJjbGVcIixcbiBcdFx0XHQgKiAgICAgICAgXCJyZWN0YW5nbGVcIixcbiBcdFx0XHQgKiAgICAgICAgXCI8cG9seWdvbiBwb2ludHM9JzAgNiA0IDAgLTQgMCc+PC9wb2x5Z29uPlwiXG4gXHRcdFx0ICogICAgIF0sXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRwb2ludF9zaG93OiB0cnVlLFxuXHRcdFx0cG9pbnRfcjogMi41LFxuXHRcdFx0cG9pbnRfc2Vuc2l0aXZpdHk6IDEwLFxuXHRcdFx0cG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQ6IHRydWUsXG5cdFx0XHRwb2ludF9mb2N1c19leHBhbmRfcjogdW5kZWZpbmVkLFxuXHRcdFx0cG9pbnRfcGF0dGVybjogW10sXG5cdFx0XHRwb2ludF9zZWxlY3RfcjogdW5kZWZpbmVkLFxuXHRcdFx0cG9pbnRfdHlwZTogXCJjaXJjbGVcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbGluZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBsaW5lXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuY29ubmVjdE51bGw9ZmFsc2VdIFNldCBpZiBudWxsIGRhdGEgcG9pbnQgd2lsbCBiZSBjb25uZWN0ZWQgb3Igbm90Ljxicj5cblx0XHRcdCAqICBJZiB0cnVlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBiZSBjb25uZWN0ZWQgd2l0aG91dCBhbnkgZGF0YSBwb2ludC4gSWYgZmFsc2Ugc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIG5vdCBiZSBjb25uZWN0ZWQgYW5kIGdldCBlbXB0eS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9ICAgW2xpbmUuY2xhc3Nlcz11bmRlZmluZWRdIElmIHNldCwgdXNlZCB0byBzZXQgYSBjc3MgY2xhc3Mgb24gZWFjaCBsaW5lLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZS5zdGVwLnR5cGU9c3RlcF0gQ2hhbmdlIHN0ZXAgdHlwZSBmb3Igc3RlcCBjaGFydC48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSB2YWx1ZXM6Kipcblx0XHRcdCAqIC0gc3RlcFxuXHRcdFx0ICogLSBzdGVwLWJlZm9yZVxuXHRcdFx0ICogLSBzdGVwLWFmdGVyXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58QXJyYXl9IFtsaW5lLnBvaW50PXRydWVdIFNldCB0byBmYWxzZSB0byBub3QgZHJhdyBwb2ludHMgb24gbGluZWNoYXJ0cy4gT3IgcGFzcyBhbiBhcnJheSBvZiBsaW5lIGlkcyB0byBkcmF3IHBvaW50cyBmb3IuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGxpbmU6IHtcblx0XHRcdCAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXG5cdFx0XHQgKiAgICAgIGNsYXNzZXM6IFtcblx0XHRcdCAqICAgICAgICAgIFwibGluZS1jbGFzczFcIixcblx0XHRcdCAqICAgICAgICAgIFwibGluZS1jbGFzczJcIlxuXHRcdFx0ICogICAgICBdLFxuXHRcdFx0ICogICAgICBzdGVwOiB7XG5cdFx0XHQgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcblx0XHRcdCAqICAgICAgcG9pbnQ6IGZhbHNlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcblx0XHRcdCAqICAgICAgcG9pbnQ6IFtcblx0XHRcdCAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXG5cdFx0XHQgKiAgICAgIF1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGxpbmVfY29ubmVjdE51bGw6IGZhbHNlLFxuXHRcdFx0bGluZV9zdGVwX3R5cGU6IFwic3RlcFwiLFxuXHRcdFx0bGluZV9jbGFzc2VzOiB1bmRlZmluZWQsXG5cdFx0XHRsaW5lX3BvaW50OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBiYXIgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgYmFyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnBhZGRpbmc9MF0gVGhlIHBhZGRpbmcgcGl4ZWwgdmFsdWUgYmV0d2VlbiBlYWNoIGJhci5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnJhZGl1c10gU2V0IHRoZSByYWRpdXMgb2YgYmFyIGVkZ2UgaW4gcGl4ZWwuXG5cdFx0XHQgKiAtICoqTk9URToqKiBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnJhZGl1cy5yYXRpb10gU2V0IHRoZSByYWRpdXMgcmF0aW8gb2YgYmFyIGVkZ2UgaW4gcmVsYXRpdmUgdGhlIGJhcidzIHdpZHRoLlxuIFx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLnNlbnNpdGl2aXR5PTJdIFRoZSBzZW5zdGl2aXR5IG9mZnNldCB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aF0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5yYXRpbz0wLjZdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0IGJ5IHJhdGlvLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGgubWF4XSBUaGUgbWF4aW11bSB3aWR0aCB2YWx1ZSBmb3IgcmF0aW8uXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZV0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgZm9yIGluZGljYXRlZCBkYXRhc2V0IG9ubHkuXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogICAtIFdvcmtzIG9ubHkgZm9yIG5vbi1zdGFja2VkIGJhclxuXHRcdFx0ICogICAtIEJhcnMgYXJlIGNlbnRlcmVkIGFjY29kaW5nIGl0cyB0b3RhbCB3aWR0aCB2YWx1ZVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWUucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbYmFyLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYmFyIGNoYXJ0LlxuXHRcdFx0ICogQHNlZSBbRGVtbzogYmFyIHBhZGRpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyUGFkZGluZylcblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciByYWRpdXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyUmFkaXVzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogYmFyIHdpZHRoXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogYmFyIHdpZHRoIHZhcmlhbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyV2lkdGhWYXJpYW50KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBiYXI6IHtcblx0XHRcdCAqICAgICAgcGFkZGluZzogMSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHRoZSAncmFkaXVzJyBvcHRpb24gY2FuIGJlIHVzZWQgb25seSBmb3Igbm9uLXN0YWNraW5nIGJhcnNcblx0XHRcdCAqICAgICAgcmFkaXVzOiAxMCxcblx0XHRcdCAqICAgICAgLy8gb3Jcblx0XHRcdCAqICAgICAgcmFkaXVzOiB7XG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogMC41XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHdpbGwgbm90IGhhdmUgb2Zmc2V0IGJldHdlZW4gZWFjaCBiYXIgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG5cdFx0XHQgKiAgICAgIHNlbnNpdGl2aXR5OiAwLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgd2lkdGg6IDEwLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Jcblx0XHRcdCAqICAgICAgd2lkdGg6IHtcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiAwLjIsXG5cdFx0XHQgKiAgICAgICAgICBtYXg6IDIwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBzcGVjaWZ5IHdpZHRoIHBlciBkYXRhc2V0XG5cdFx0XHQgKiAgICAgIHdpZHRoOiB7XG5cdFx0XHQgKiAgICAgICAgICBkYXRhMTogMjAsXG5cdFx0XHQgKiAgICAgICAgICBkYXRhMjoge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJhdGlvOiAwLjIsXG5cdFx0XHQgKiAgICAgICAgICAgICAgbWF4OiAyMFxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0YmFyX3BhZGRpbmc6IDAsXG5cdFx0XHRiYXJfcmFkaXVzOiB1bmRlZmluZWQsXG5cdFx0XHRiYXJfcmFkaXVzX3JhdGlvOiB1bmRlZmluZWQsXG5cdFx0XHRiYXJfc2Vuc2l0aXZpdHk6IDIsXG5cdFx0XHRiYXJfd2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdGJhcl93aWR0aF9yYXRpbzogMC42LFxuXHRcdFx0YmFyX3dpZHRoX21heDogdW5kZWZpbmVkLFxuXHRcdFx0YmFyX3plcm9iYXNlZDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYnViYmxlIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGJ1YmJsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW2J1YmJsZS5tYXhSPTM1XSBTZXQgdGhlIG1heCBidWJibGUgcmFkaXVzIHZhbHVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGJ1YmJsZToge1xuXHRcdFx0ICogICAgICAvLyBleCkgSWYgMTAwIGlzIHRoZSBoaWdoZXN0IHZhbHVlIGFtb25nIGRhdGEgYm91bmQsIHRoZSByZXByZXNlbnRhdGlvbiBidWJibGUgb2YgMTAwIHdpbGwgaGF2ZSByYWRpdXMgb2YgNTAuXG5cdFx0XHQgKiAgICAgIC8vIEFuZCB0aGUgbGVzc2VyIHdpbGwgaGF2ZSByYWRpdXMgcmVsYXRpdmVseSBmcm9tIHRoYSBtYXggdmFsdWUuXG5cdFx0XHQgKiAgICAgIG1heFI6IDUwLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Igc2V0IHJhZGl1cyBjYWxsYmFja1xuXHRcdFx0ICogICAgICBtYXhSOiBmdW5jdGlvbihkKSB7XG5cdFx0XHQgKiAgICAgICAgICAvLyBleC4gb2YgZCBwYXJhbSAtIHt4OiBGcmkgT2N0IDA2IDIwMTcgMDA6MDA6MDAgR01UKzA5MDAsIHZhbHVlOiA4MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDV9XG5cdFx0XHQgKiAgICAgICAgICAuLi5cblx0XHRcdCAqICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSAqIDIpO1xuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRidWJibGVfbWF4UjogMzUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFyZWEgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgYXJlYVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYXJlYSBjaGFydC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FyZWEuYWJvdmU9ZmFsc2VdIFNldCBiYWNrZ3JvdW5kIGFyZWEgYWJvdmUgdGhlIGRhdGEgY2hhcnQgbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxPYmplY3R9IFthcmVhLmxpbmVhckdyYWRpZW50PWZhbHNlXSBTZXQgdGhlIGxpbmVhciBncmFkaWVudCBvbiBhcmVhLjxicj48YnI+XG5cdFx0XHQgKiBPciBjdXN0b21pemUgYnkgZ2l2aW5nIGJlbG93IG9iamVjdCB2YWx1ZTpcblx0XHRcdCAqICAtIHgge0FycmF5fTogYHgxYCwgYHgyYCB2YWx1ZVxuXHRcdFx0ICogIC0geSB7QXJyYXl9OiBgeTFgLCBgeTJgIHZhbHVlXG5cdFx0XHQgKiAgLSBzdG9wcyB7QXJyYXl9OiBFYWNoIGl0ZW0gc2hvdWxkIGJlIGhhdmluZyBgW29mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XWAgdmFsdWVzLlxuXHRcdFx0ICogQHNlZSBbTUROJ3MgJmx0O2xpbmVhckdyYWRpZW50Pl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvbGluZWFyR3JhZGllbnQpLCBbJmx0O3N0b3A+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdG9wKVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGFib3ZlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5BYm92ZSlcblx0XHRcdCAqIEBzZWUgW0RlbW86IGxpbmVhckdyYWRpZW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5MaW5lYXJHcmFkaWVudClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgYXJlYToge1xuXHRcdFx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlLFxuXHRcdFx0ICogICAgICBhYm92ZTogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHdpbGwgZ2VuZXJhdGUgZm9sbHdpbmcgbGluZWFyR3JhZGllbnQ6XG5cdFx0XHQgKiAgICAgIC8vIDxsaW5lYXJHcmFkaWVudCB4MT1cIjBcIiB4Mj1cIjBcIiB5MT1cIjBcIiB5Mj1cIjFcIj5cblx0XHRcdCAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjFcIj48L3N0b3A+XG5cdFx0XHQgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIwXCI+PC9zdG9wPlxuXHRcdFx0ICogICAgICAvLyA8L2xpbmVhckdyYWRpZW50PlxuXHRcdFx0ICogICAgICBsaW5lYXJHcmFkaWVudDogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIE9yIGN1c3RvbWl6ZWQgZ3JhZGllbnRcblx0XHRcdCAqICAgICAgbGluZWFyR3JhZGllbnQ6IHtcblx0XHRcdCAqICAgICAgXHR4OiBbMCwgMF0sICAvLyB4MSwgeDIgYXR0cmlidXRlc1xuXHRcdFx0ICogICAgICBcdHk6IFswLCAwXSwgIC8vIHkxLCB5MiBhdHRyaWJ1dGVzXG5cdFx0XHQgKiAgICAgIFx0c3RvcHM6IFtcblx0XHRcdCAqICAgICAgXHRcdC8vIG9mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XG5cdFx0XHQgKiAgICAgIFx0XHRbMCwgXCIjN2NiNWVjXCIsIDFdLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgXHRcdC8vIHNldHRpbmcgJ251bGwnIGZvciBzdG9wLWNvbG9yLCB3aWxsIHNldCBpdHMgb3JpZ2luYWwgZGF0YSBjb2xvclxuXHRcdFx0ICogICAgICBcdFx0WzAuNSwgbnVsbCwgMF0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBcdFx0Ly8gc2V0dGluZyAnZnVuY3Rpb24nIGZvciBzdG9wLWNvbG9yLCB3aWxsIHBhc3MgZGF0YSBpZCBhcyBhcmd1bWVudC5cblx0XHRcdCAqICAgICAgXHRcdC8vIEl0IHNob3VsZCByZXR1cm4gY29sb3Igc3RyaW5nIG9yIG51bGwgdmFsdWVcblx0XHRcdCAqICAgICAgXHRcdFsxLCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImJsdWVcIjsgfSwgMF0sXG5cdFx0XHQgKiAgICAgIFx0XVxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRhcmVhX3plcm9iYXNlZDogdHJ1ZSxcblx0XHRcdGFyZWFfYWJvdmU6IGZhbHNlLFxuXHRcdFx0YXJlYV9saW5lYXJHcmFkaWVudDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBpZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBwaWVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcGllLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggcGllIHBpZWNlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3BpZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmxhYmVsLnRocmVzaG9sZD0wLjA1XSBTZXQgdGhyZXNob2xkIHRvIHNob3cvaGlkZSBsYWJlbHMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BpZS5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbcGllLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgcGllIHBpZWNlcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxPYmplY3R9IFtwaWUuaW5uZXJSYWRpdXM9MF0gU2V0cyB0aGUgaW5uZXIgcmFkaXVzIG9mIHBpZSBhcmMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRkaW5nPTBdIFNldHMgdGhlIGdhcCBiZXR3ZWVuIHBpZSBhcmNzLlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBwaWU6IHtcblx0XHRcdCAqICAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxuXHRcdFx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcblx0XHRcdCAqICAgICAgICAgICAgICAuLi5cblx0XHRcdCAqICAgICAgICAgICAgICByZXR1cm4gcmF0aW87XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuNVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cblx0XHRcdCAqICAgICAgZXhwYW5kOiBmYWxzZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cblx0XHRcdCAqICAgICAgZXhwYW5kOiB7XG5cdFx0XHQgKiAgICAgICAgICBkdXJhdGlvbjogNTAwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBpbm5lclJhZGl1czogMCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgaW5uZXJSYWRpdXMgZm9yIGVhY2ggZGF0YVxuXHRcdFx0ICogICAgICBpbm5lclJhZGl1czoge1xuXHRcdFx0ICogICAgICBcdGRhdGExOiAxMCxcblx0XHRcdCAqICAgICAgXHRkYXRhMjogMFxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBwYWRBbmdsZTogMC4xLFxuXHRcdFx0ICogICAgICBwYWRkaW5nOiAwXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRwaWVfbGFiZWxfc2hvdzogdHJ1ZSxcblx0XHRcdHBpZV9sYWJlbF9mb3JtYXQ6IHVuZGVmaW5lZCxcblx0XHRcdHBpZV9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXG5cdFx0XHRwaWVfbGFiZWxfcmF0aW86IHVuZGVmaW5lZCxcblx0XHRcdHBpZV9leHBhbmQ6IHt9LFxuXHRcdFx0cGllX2V4cGFuZF9kdXJhdGlvbjogNTAsXG5cdFx0XHRwaWVfaW5uZXJSYWRpdXM6IDAsXG5cdFx0XHRwaWVfcGFkQW5nbGU6IDAsXG5cdFx0XHRwaWVfcGFkZGluZzogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgcGx1Z2luc1xuXHRcdFx0ICogQG5hbWUgcGx1Z2luc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgcGx1Z2luczogW1xuXHRcdFx0ICogICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcblx0XHRcdCAqICAgIG5ldyBQbHVnaW5BKCksXG5cdFx0XHQgKiAgICAuLi5cblx0XHRcdCAqIF1cblx0XHRcdCAqL1xuXHRcdFx0cGx1Z2luczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGdhdWdlIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGdhdWdlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmZ1bGxDaXJjbGU9ZmFsc2VdIFNob3cgZnVsbCBjaXJjbGUgYXMgZG9udXQuIFdoZW4gc2V0IHRvICd0cnVlJywgdGhlIG1heCBsYWJlbCB3aWxsIG5vdCBiZSBzaG93ZWQgZHVlIHRvIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBzYW1lIGxvY2F0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2F1Z2UubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZ2F1Z2UuIExhYmVsIHRleHQgY2FuIGJlIG11bHRpbGluZWQgd2l0aCBgXFxuYCBjaGFyYWN0ZXIuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZXh0ZW50c10gU2V0IGN1c3RvbWl6ZWQgbWluL21heCBsYWJlbCB0ZXh0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2F1Z2UuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBnYXVnZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgdGhlIGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5taW49MF0gU2V0IG1pbiB2YWx1ZSBvZiB0aGUgZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLm1heD0xMDBdIFNldCBtYXggdmFsdWUgb2YgdGhlIGdhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5zdGFydGluZ0FuZ2xlPS0xICogTWF0aC5QSSAvIDJdXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBnYXVnZSBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS51bml0c10gU2V0IHVuaXRzIG9mIHRoZSBnYXVnZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uud2lkdGhdIFNldCB3aWR0aCBvZiBnYXVnZSBjaGFydC5cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgZ2F1Z2U6IHtcblx0XHRcdCAqICAgICAgZnVsbENpcmNsZTogZmFsc2UsXG5cdFx0XHQgKiAgICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxuXHRcdFx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICBleHRlbnRzOiBmdW5jdGlvbih2YWx1ZSwgaXNNYXgpIHtcblx0XHQgXHQgKiAgICAgICAgICAgICAgcmV0dXJuIChpc01heCA/IFwiTWF4OlwiIDogXCJNaW46XCIpICsgdmFsdWU7XG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBzZXQgZHVyYXRpb25cblx0XHRcdCAqICAgICAgZXhwYW5kOiB7XG5cdFx0XHQgKiAgICAgICAgICBkdXJhdGlvbjogMjBcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgbWluOiAtMTAwLFxuXHRcdFx0ICogICAgICBtYXg6IDIwMCxcblx0XHRcdCAqICAgICAgdGl0bGU6IFwiVGl0bGUgVGV4dFwiLFxuXHRcdFx0ICogICAgICB1bml0czogXCIlXCIsXG5cdFx0XHQgKiAgICAgIHdpZHRoOiAxMFxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0Z2F1Z2VfZnVsbENpcmNsZTogZmFsc2UsXG5cdFx0XHRnYXVnZV9sYWJlbF9zaG93OiB0cnVlLFxuXHRcdFx0Z2F1Z2VfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG5cdFx0XHRnYXVnZV9taW46IDAsXG5cdFx0XHRnYXVnZV9tYXg6IDEwMCxcblx0XHRcdGdhdWdlX3N0YXJ0aW5nQW5nbGU6IC0xICogTWF0aC5QSSAvIDIsXG5cdFx0XHRnYXVnZV9sYWJlbF9leHRlbnRzOiB1bmRlZmluZWQsXG5cdFx0XHRnYXVnZV90aXRsZTogXCJcIixcblx0XHRcdGdhdWdlX3VuaXRzOiB1bmRlZmluZWQsXG5cdFx0XHRnYXVnZV93aWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2VfZXhwYW5kOiB7fSxcblx0XHRcdGdhdWdlX2V4cGFuZF9kdXJhdGlvbjogNTAsXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZG9udXQgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgZG9udXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkb251dC5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtkb251dC5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkb251dC5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGRvbnV0IHBpZWNlcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQud2lkdGhdIFNldCB3aWR0aCBvZiBkb251dCBjaGFydC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZG9udXQudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGRvbnV0IGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LnBhZEFuZ2xlPTBdIFNldCBwYWRkaW5nIGJldHdlZW4gZGF0YS5cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgZG9udXQ6IHtcblx0XHRcdCAqICAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxuXHRcdFx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcblx0XHRcdCAqICAgICAgICAgIFx0Li4uXG5cdFx0XHQgKiAgICAgICAgICBcdHJldHVybiByYXRpbztcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICAvLyBvciBzZXQgcmF0aW8gbnVtYmVyXG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogMC41XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXG5cdFx0XHQgKiAgICAgIHdpZHRoOiAxMCxcblx0XHRcdCAqICAgICAgcGFkQW5nbGU6IDAuMixcblx0XHRcdCAqICAgICAgdGl0bGU6IFwiRG9udXQgVGl0bGVcIlxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gdGl0bGUgd2l0aCBsaW5lIGJyZWFrXG5cdFx0XHQgKiAgICAgIHRpdGxlOiBcIlRpdGxlMVxcblRpdGxlMlwiXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRkb251dF9sYWJlbF9zaG93OiB0cnVlLFxuXHRcdFx0ZG9udXRfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG5cdFx0XHRkb251dF9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXG5cdFx0XHRkb251dF9sYWJlbF9yYXRpbzogdW5kZWZpbmVkLFxuXHRcdFx0ZG9udXRfd2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdGRvbnV0X3RpdGxlOiBcIlwiLFxuXHRcdFx0ZG9udXRfZXhwYW5kOiB7fSxcblx0XHRcdGRvbnV0X2V4cGFuZF9kdXJhdGlvbjogNTAsXG5cdFx0XHRkb251dF9wYWRBbmdsZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgc3BsaW5lIG9wdGlvbnNcblx0XHRcdCAqIC0gKipBdmFpbGFibGUgaW50ZXJwb2xhdGlvbiB0eXBlIHZhbHVlczoqKlxuXHRcdFx0ICogIC0gYmFzaXMgKGQzLmN1cnZlQmFzaXMpXG5cdFx0XHQgKiAgLSBiYXNpcy1jbG9zZWQgKGQzLmN1cnZlQmFzaXNDbG9zZWQpXG5cdFx0XHQgKiAgLSBiYXNpcy1vcGVuIChkMy5jdXJ2ZUJhc2lzT3Blbilcblx0XHRcdCAqICAtIGJ1bmRsZSAoZDMuY3VydmVCdW5kbGUpXG5cdFx0XHQgKiAgLSBjYXJkaW5hbCAoZDMuY3VydmVDYXJkaW5hbClcblx0XHRcdCAqICAtIGNhcmRpbmFsLWNsb3NlZCAoZDMuY3VydmVDYXJkaW5hbENsb3NlZClcblx0XHRcdCAqICAtIGNhcmRpbmFsLW9wZW4gKGQzLmN1cnZlQ2FyZGluYWxPcGVuKVxuXHRcdFx0ICogIC0gY2F0bXVsbC1yb20gKGQzLmN1cnZlQ2F0bXVsbFJvbSlcblx0XHRcdCAqICAtIGNhdG11bGwtcm9tLWNsb3NlZCAoZDMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkKVxuXHRcdFx0ICogIC0gY2F0bXVsbC1yb20tb3BlbiAoZDMuY3VydmVDYXRtdWxsUm9tT3Blbilcblx0XHRcdCAqICAtIG1vbm90b25lLXggKGQzLmN1cnZlTW9ub3RvbmVYKVxuXHRcdFx0ICogIC0gbW9ub3RvbmUteSAoZDMuY3VydmVNb25vdG9uZVkpXG5cdFx0XHQgKiAgLSBuYXR1cmFsIChkMy5jdXJ2ZU5hdHVyYWwpXG5cdFx0XHQgKiAgLSBsaW5lYXItY2xvc2VkIChkMy5jdXJ2ZUxpbmVhckNsb3NlZClcblx0XHRcdCAqICAtIGxpbmVhciAoZDMuY3VydmVMaW5lYXIpXG5cdFx0XHQgKiAgLSBzdGVwIChkMy5jdXJ2ZVN0ZXApXG5cdFx0XHQgKiAgLSBzdGVwLWFmdGVyIChkMy5jdXJ2ZVN0ZXBBZnRlcilcblx0XHRcdCAqICAtIHN0ZXAtYmVmb3JlIChkMy5jdXJ2ZVN0ZXBCZWZvcmUpXG5cdFx0XHQgKiBAbmFtZSBzcGxpbmVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtzcGxpbmUuaW50ZXJwb2xhdGlvbi50eXBlPVwiY2FyZGluYWxcIl1cblx0XHRcdCAqIEBzZWUgW0ludGVycG9sYXRpb24gKGQzIHY0KV0oaHR0cDovL2JsLm9ja3Mub3JnL2VtbWFzYXVuZGVycy9jMjVhMTQ3OTcwZGVmMmIwMmQ4YzdjMjcxOWRjNzUwMilcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgc3BsaW5lOiB7XG5cdFx0XHQgKiAgICAgIGludGVycG9sYXRpb246IHtcblx0XHRcdCAqICAgICAgICAgIHR5cGU6IFwiY2FyZGluYWxcIlxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlOiBcImNhcmRpbmFsXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHJhZGFyIG9wdGlvbnNcblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhay5cblx0XHRcdCAqIEBuYW1lIHJhZGFyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIuYXhpcy5tYXg9dW5kZWZpbmVkXSBUaGUgbWF4IHZhbHVlIG9mIGF4aXMuIElmIG5vdCBnaXZlbiwgaXQnbGwgdGFrZSB0aGUgbWF4IHZhbHVlIGZyb20gdGhlIGdpdmVuIGRhdGEuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5heGlzLmxpbmUuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgYXhpcyBsaW5lLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgdGV4dC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmRpcmVjdGlvbi5jbG9ja3dpc2U9ZmFsc2VdIFNldCB0aGUgZGlyZWN0aW9uIHRvIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5sZXZlbC5kZXB0aD0zXSBTZXQgdGhlIGxldmVsIGRlcHRoLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGV2ZWwuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcmFkYXIubGV2ZWwudGV4dC5mb3JtYXQ9KHgpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpXSBTZXQgZm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgbGV2ZWwgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5sZXZlbC50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsIHRleHQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLnNpemUucmF0aW89MC44N10gU2V0IHNpemUgcmF0aW8uXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuUmFkYXJDaGFydClcblx0XHRcdCAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiByYWRhciBsZXZlbF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyTGV2ZWwpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiByYWRhciBzaXplXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJTaXplKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogcmFkYXIgYXhpcyBtdWx0aWxpbmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXNNdWx0aWxpbmUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHJhZGFyOiB7XG5cdFx0XHQgKiAgICAgIGF4aXM6IHtcblx0XHRcdCAqICAgICAgICAgIG1heDogNTAsXG5cdFx0XHQgKiAgICAgICAgICBsaW5lOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgZGlyZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgbGV2ZWw6IHtcblx0XHRcdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xuXHRcdFx0ICogICAgICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBzaXplOiB7XG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogMC43XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHJhZGFyX2F4aXNfbWF4OiB1bmRlZmluZWQsXG5cdFx0XHRyYWRhcl9heGlzX2xpbmVfc2hvdzogdHJ1ZSxcblx0XHRcdHJhZGFyX2F4aXNfdGV4dF9zaG93OiB0cnVlLFxuXHRcdFx0cmFkYXJfbGV2ZWxfZGVwdGg6IDMsXG5cdFx0XHRyYWRhcl9sZXZlbF9zaG93OiB0cnVlLFxuXHRcdFx0cmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQ6IHggPT4gKHggJSAxID09PSAwID8geCA6IHgudG9GaXhlZCgyKSksXG5cdFx0XHRyYWRhcl9sZXZlbF90ZXh0X3Nob3c6IHRydWUsXG5cdFx0XHRyYWRhcl9zaXplX3JhdGlvOiAwLjg3LFxuXHRcdFx0cmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyByZWN0YW5nbGVzIGluc2lkZSB0aGUgY2hhcnQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyBheGlzLCBzdGFydCwgZW5kIGFuZCBjbGFzcy4gVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxuXHRcdFx0ICogYXhpcyBtdXN0IGJlIHgsIHkgb3IgeTIuIHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHRoZSB2YWx1ZSB3aGVyZSByZWdpb25zIHN0YXJ0IGFuZCBlbmQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuIElmIHRpbWVzZXJpZXMgeCBheGlzLCBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIgY2FuIGJlIHVzZWQuIElmIGNsYXNzIGlzIHNldCwgdGhlIHJlZ2lvbiBlbGVtZW50IHdpbGwgaGF2ZSBpdCBhcyBjbGFzcy5cblx0XHRcdCAqIEBuYW1lIHJlZ2lvbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICByZWdpb25zOiBbXG5cdFx0XHQgKiAgICB7XG5cdFx0XHQgKiAgICAgIGF4aXM6IFwieFwiLFxuXHRcdFx0ICogICAgICBzdGFydDogMSxcblx0XHRcdCAqICAgICAgZW5kOiA0LFxuXHRcdFx0ICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqICBdXG5cdFx0XHQgKi9cblx0XHRcdHJlZ2lvbnM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRvb2x0aXAgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgdG9vbHRpcFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHRvb2x0aXAuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmRvTm90SGlkZT1mYWxzZV0gTWFrZSB0b29sdGlwIGtlZXAgc2hvd2luZyBub3QgaGlkaW5nIG9uIGludGVyYWN0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXG5cdFx0XHQgKiAgIC0gKipOT1RFOioqIFRoZSBvdmVybGFwcGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgZGlzcGxheWVkIGFzIGdyb3VwZWQgZXZlbiBpZiBzZXQgZmFsc2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmxpbmtlZD1mYWxzZV0gU2V0IGlmIHRvb2x0aXBzIG9uIGFsbCB2aXNpYmxlIGNoYXJ0cyB3aXRoIGxpa2UgeCBwb2ludHMgYXJlIHNob3duIHRvZ2V0aGVyIHdoZW4gb25lIGlzIHNob3duLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnRpdGxlXSBTZXQgZm9ybWF0IGZvciB0aGUgdGl0bGUgb2YgdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudmFsdWVdIFNldCBmb3JtYXQgZm9yIHRoZSB2YWx1ZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXG5cdFx0XHQgKiAgSWYgdW5kZWZpbmVkIHJldHVybmVkLCB0aGUgcm93IG9mIHRoYXQgdmFsdWUgd2lsbCBiZSBza2lwcGVkLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAucG9zaXRpb25dIFNldCBjdXN0b20gcG9zaXRpb24gZm9yIHRoZSB0b29sdGlwLjxicj5cblx0XHRcdCAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufE9iamVjdH0gW3Rvb2x0aXAuY29udGVudHNdIFNldCBjdXN0b20gSFRNTCBmb3IgdGhlIHRvb2x0aXAuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBkYXRhLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCBhbmQgY29sb3Igb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gSWYgdG9vbHRpcC5ncm91cGVkIGlzIHRydWUsIGRhdGEgaW5jbHVkZXMgbXVsdGlwbGUgZGF0YSBwb2ludHMuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3Rvb2x0aXAuY29udGVudHMudGVtcGxhdGU9dW5kZWZpbmVkXSBTZXQgdG9vbHRpcCdzIHRlbXBsYXRlLlxuXHRcdFx0ICogIC0gKipOT1RFOioqIFdoZW4gaXMgc3BlY2lmaWVkLCB3aWxsIG5vdCBiZSB1cGRhdGluZyB0b29sdGlwJ3MgcG9zaXRpb24uXG5cdFx0XHQgKiAgLSBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcblx0XHRcdCAqICAgIC0ge3sgLi4uIH19OiB0aGUgZG91Ymx5IGN1cmx5IGJyYWNrZXRzIGluZGljYXRlIGxvb3AgYmxvY2sgZm9yIGRhdGEgcm93c1xuXHRcdFx0ICogICAgLSB7PUNMQVNTX1RPT0xUSVB9OiBkZWZhdWx0IHRvb2x0aXAgY2xhc3MgbmFtZSBgYmItdG9vbHRpcGAuXG5cdFx0XHQgKiAgICAtIHs9Q0xBU1NfVE9PTFRJUF9OQU1FfTogZGVmYXVsdCB0b29sdGlwIGRhdGEgY2xhc3MgbmFtZSAoZXguIGBiYi10b29sdGlwLW5hbWUtZGF0YTFgKVxuXHRcdFx0ICogICAgLSB7PVRJVExFfTogdGl0bGUgdmFsdWVcblx0XHRcdCAqICAgIC0gez1DT0xPUn06IGRhdGEgY29sb3Jcblx0XHRcdCAqICAgIC0gez1WQUxVRX06IGRhdGEgdmFsdWVcblx0XHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdG9vbHRpcC5jb250ZW50cy50ZXh0PXVuZGVmaW5lZF0gU2V0IGFkZGl0aW9uYWwgdGV4dCBjb250ZW50IHdpdGhpbiBkYXRhIGxvb3AsIHVzaW5nIHRlbXBsYXRlIHN5bnRheC5cblx0XHRcdCAqICAtICoqTk9URToqKiBJdCBzaG91bGQgY29udGFpbiBgeyBrZXk6IEFycmF5LCAuLi4gfWAgdmFsdWVcblx0XHRcdCAqICAgIC0gJ2tleScgbmFtZSBpcyB1c2VkIGFzIHN1YnN0aXR1dGlvbiB3aXRoaW4gdGVtcGxhdGUgYXMgJ3s9S0VZfSdcblx0XHRcdCAqICAgIC0gVGhlIHZhbHVlIGFycmF5IGxlbmd0aCBzaG91bGQgbWF0Y2ggd2l0aCB0aGUgZGF0YSBsZW5ndGhcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAuaW5pdC5zaG93PWZhbHNlXSBTaG93IHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0b29sdGlwLmluaXQueD0wXSBTZXQgeCBBeGlzIGluZGV4IHRvIGJlIHNob3duIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdG9vbHRpcC5pbml0LnBvc2l0aW9uPXt0b3A6IFwiMHB4XCIsbGVmdDogXCI1MHB4XCJ9XSBTZXQgdGhlIHBvc2l0aW9uIG9mIHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93XSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgc2hvd24uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5vbmhpZGVdIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGJlZm9yZSB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5vbnNob3duXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBzaG93blxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRkZW5dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9IFt0b29sdGlwLm9yZGVyPW51bGxdIFNldCB0b29sdGlwIGRhdGEgZGlzcGxheSBvcmRlci48YnI+PGJyPlxuXHRcdFx0ICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcblx0XHRcdCAqICAtIGBhc2NgOiBJbiBhc2NlbmRpbmcgZGF0YSB2YWx1ZSBvcmRlclxuXHRcdFx0ICogIC0gYG51bGxgOiBJdCBrZWVwcyB0aGUgZGF0YSBkaXNwbGF5IG9yZGVyPGJyPlxuXHRcdFx0ICogICAgICoqTk9URToqKiBXaGVuIGBkYXRhLmdyb3Vwc2AgaXMgc2V0LCB0aGUgb3JkZXIgd2lsbCBmb2xsb3cgYXMgdGhlIHN0YWNrZWQgZ3JhcGggb3JkZXIuPGJyPlxuXHRcdFx0ICogICAgICBJZiB3YW50IHRvIG9yZGVyIGFzIGRhdGEgYm91bmQsIHNldCBhbnkgdmFsdWUgcmF0aGVyIHRoYW4gYXNjLCBkZXNjIG9yIG51bGwuIChleC4gZW1wdHkgc3RyaW5nIFwiXCIpXG5cdFx0XHQgKiAgLSBgZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IC4uLiB9YDogW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBIaWRlIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkhpZGVUb29sdGlwKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBHcm91cGluZ10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcEdyb3VwaW5nKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBGb3JtYXRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBGb3JtYXQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBMaW5rZWQgVG9vbHRpcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuTGlua2VkVG9vbHRpcHMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBUb29sdGlwIFRlbXBsYXRlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwVGVtcGxhdGUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHRvb2x0aXA6IHtcblx0XHRcdCAqICAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICAgZG9Ob3RIaWRlOiB0cnVlLFxuXHRcdFx0ICogICAgICBncm91cGVkOiBmYWxzZSxcblx0XHRcdCAqICAgICAgZm9ybWF0OiB7XG5cdFx0XHQgKiAgICAgICAgICB0aXRsZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gXCJEYXRhIFwiICsgeDsgfSxcblx0XHRcdCAqICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uKG5hbWUsIHJhdGlvLCBpZCwgaW5kZXgpIHsgcmV0dXJuIG5hbWU7IH0sXG5cdFx0XHQgKiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCwgaW5kZXgpIHsgcmV0dXJuIHJhdGlvOyB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH1cbiAgXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcbiAgXHRcdFx0ICogICAgICBjb250ZW50czogZnVuY3Rpb24oZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XG4gIFx0XHRcdCAqICAgICAgICAgIHJldHVybiAuLi4gLy8gZm9ybWF0dGVkIGh0bWwgYXMgeW91IHdhbnRcbiAgICBcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgIC8vIHNwZWNpZnkgdG9vbHRpcCBjb250ZW50cyB1c2luZyB0ZW1wbGF0ZVxuXHRcdFx0ICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XG5cdFx0XHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+PC9saT5cblx0XHRcdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPjwvbGk+XG5cdFx0XHQgKiAgICAgICAvLyA8L3VsPlxuXHRcdFx0ICogICAgICAgY29udGVudHM6IHtcblx0XHRcdCAqICAgICAgXHRiaW5kdG86IFwiI3Rvb2x0aXBcIixcblx0XHRcdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXG5cdFx0XHQgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj48YnI+JyArXG5cdFx0XHQgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPjwvbGk+JyArXG5cdFx0XHQgKiAgICAgIFx0XHQnfX08L3VsPidcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgIC8vIHdpdGggYWRkaXRpb25hbCB0ZXh0IHZhbHVlXG5cdFx0XHQgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcblx0XHRcdCAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cblx0XHRcdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj5jb21tZW50MTxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPnRleHQxPC9saT5cblx0XHRcdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPmNvbW1lbnQyPHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+dGV4dDI8L2xpPlxuXHRcdFx0ICogICAgICAgLy8gPC91bD5cblx0XHRcdCAqICAgICAgIGNvbnRlbnRzOiB7XG5cdFx0XHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXG5cdFx0XHQgKiAgICAgIFx0dGV4dDoge1xuXHRcdFx0ICogICAgICBcdFx0Ly8gYSkgJ2tleScgbmFtZSBpcyB1c2VkIGFzIHN1YnN0aXR1dGlvbiB3aXRoaW4gdGVtcGxhdGUgYXMgJ3s9S0VZfSdcblx0XHRcdCAqICAgICAgXHRcdC8vIGIpIHRoZSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXG5cdFx0XHQgKiAgICAgIFx0XHRWQVIxOiBbXCJ0ZXh0MVwiLCBcInRleHQyXCJdLFxuXHRcdFx0ICogICAgICBcdFx0VkFSMjogW1wiY29tbWVudDFcIiwgXCJjb21tZW50MlwiXSxcblx0XHRcdCAqICAgICAgXHR9LFxuXHRcdFx0ICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcblx0XHRcdCAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPns9VkFSMn08YnI+JyArXG5cdFx0XHQgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPns9VkFSMX08L2xpPicgK1xuXHRcdFx0ICogICAgICBcdFx0J319PC91bD4nXG5cdFx0XHQgKiAgICAgIH1cbiAgICBcdFx0ICpcbiAgICBcdFx0ICogICAgICAvLyBzb3J0IHRvb2x0aXAgZGF0YSB2YWx1ZSBkaXNwbGF5IGluIGFzY2VuZGluZyBvcmRlclxuICAgIFx0XHQgKiAgICAgIG9yZGVyOiBcImFzY1wiLFxuICAgIFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzcGVjaWZ5aW5nIHNvcnQgZnVuY3Rpb25cblx0XHRcdCAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdCAqICAgICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XG5cdFx0XHQgKiAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifVxuXHRcdFx0ICogICAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cblx0XHRcdCAqICAgICAgaW5pdDoge1xuXHRcdFx0ICogICAgICAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICAgICAgIHg6IDIsXG5cdFx0XHQgKiAgICAgICAgICBwb3NpdGlvbjoge1xuXHRcdFx0ICogICAgICAgICAgICAgIHRvcDogXCIxNTBweFwiLFxuXHRcdFx0ICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBzaG93blxuXHRcdFx0ICogICAgICBvbnNob3c6IGZ1bmN0aW9uKCkgeyAuLi59LFxuXHRcdFx0ICogICAgICAvLyBmaXJlcyBwcmlvciB0b29sdGlwIGlzIGhpZGRlblxuXHRcdFx0ICogICAgICBvbmhpZGU6IGZ1bmN0aW9uKCkgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBzaG93blxuXHRcdFx0ICogICAgICBvbnNob3duOiBmdW5jdGlvbigpIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgaGlkZGVuXG5cdFx0XHQgKiAgICAgIG9uaGlkZGVuOiBmdW5jdGlvbigpIHsgLi4uIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBMaW5rIGFueSB0b29sdGlwcyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBhcmUgb24gdGhlIHNjcmVlbiB3aGVyZSBzYW1lIHggY29vcmRpbmF0ZXMgYXJlIGF2YWlsYWJsZVxuXHRcdFx0ICogICAgICAvLyBVc2VmdWwgZm9yIHRpbWVzZXJpZXMgY29ycmVsYXRpb25cblx0XHRcdCAqICAgICAgbGlua2VkOiB0cnVlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gU3BlY2lmeSBuYW1lIHRvIGludGVyYWN0IHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBvbmx5LlxuXHRcdFx0ICogICAgICBsaW5rZWQ6IHtcblx0XHRcdCAqICAgICAgICAgIG5hbWU6IFwic29tZS1ncm91cFwiXG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHRvb2x0aXBfc2hvdzogdHJ1ZSxcblx0XHRcdHRvb2x0aXBfZG9Ob3RIaWRlOiBmYWxzZSxcblx0XHRcdHRvb2x0aXBfZ3JvdXBlZDogdHJ1ZSxcblx0XHRcdHRvb2x0aXBfZm9ybWF0X3RpdGxlOiB1bmRlZmluZWQsXG5cdFx0XHR0b29sdGlwX2Zvcm1hdF9uYW1lOiB1bmRlZmluZWQsXG5cdFx0XHR0b29sdGlwX2Zvcm1hdF92YWx1ZTogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9wb3NpdGlvbjogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9jb250ZW50czoge30sXG5cdFx0XHR0b29sdGlwX2luaXRfc2hvdzogZmFsc2UsXG5cdFx0XHR0b29sdGlwX2luaXRfeDogMCxcblx0XHRcdHRvb2x0aXBfaW5pdF9wb3NpdGlvbjoge1xuXHRcdFx0XHR0b3A6IFwiMHB4XCIsXG5cdFx0XHRcdGxlZnQ6IFwiNTBweFwiXG5cdFx0XHR9LFxuXHRcdFx0dG9vbHRpcF9saW5rZWQ6IGZhbHNlLFxuXHRcdFx0dG9vbHRpcF9saW5rZWRfbmFtZTogXCJcIixcblx0XHRcdHRvb2x0aXBfb25zaG93OiAoKSA9PiB7fSxcblx0XHRcdHRvb2x0aXBfb25oaWRlOiAoKSA9PiB7fSxcblx0XHRcdHRvb2x0aXBfb25zaG93bjogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29uaGlkZGVuOiAoKSA9PiB7fSxcblx0XHRcdHRvb2x0aXBfb3JkZXI6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRpdGxlIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIHRpdGxlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdGl0bGUudGV4dF0gVGl0bGUgdGV4dC4gSWYgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFsbG93aW5nIG11bHRpbGluZSB0aXRsZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy50b3A9MF0gVG9wIHBhZGRpbmcgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcucmlnaHQ9MF0gUmlnaHQgcGFkZGluZyB2YWx1ZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy5ib3R0b209MF0gQm90dG9tIHBhZGRpbmcgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcubGVmdD0wXSBMZWZ0IHBhZGRpbmcgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnBvc2l0aW9uPWNlbnRlcl0gQXZhaWxhYmxlIHZhbHVlcyBhcmU6ICdjZW50ZXInLCAncmlnaHQnIGFuZCAnbGVmdCcuXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVGl0bGUuTXVsdGlsaW5lZFRpdGxlKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICB0aXRsZToge1xuXHRcdFx0ICogICAgICB0ZXh0OiBcIlRpdGxlIFRleHRcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIE11bHRpbGluZSB0aXRsZSB0ZXh0XG5cdFx0XHQgKiAgICAgIHRleHQ6IFwiTWFpbiB0aXRsZSB0ZXh0XFxuU3ViIHRpdGxlIHRleHRcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIHBhZGRpbmc6IHtcblx0XHRcdCAqICAgICAgICAgIHRvcDogMTAsXG5cdFx0XHQgKiAgICAgICAgICByaWdodDogMTAsXG5cdFx0XHQgKiAgICAgICAgICBib3R0b206IDEwLFxuXHRcdFx0ICogICAgICAgICAgbGVmdDogMTBcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgcG9zaXRpb246IFwiY2VudGVyXCJcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHRpdGxlX3RleHQ6IHVuZGVmaW5lZCxcblx0XHRcdHRpdGxlX3BhZGRpbmc6IHtcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHR9LFxuXHRcdFx0dGl0bGVfcG9zaXRpb246IFwiY2VudGVyXCJcblx0XHR9O1xuXHR9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgT3B0aW9ucyBmcm9tIFwiLi9PcHRpb25zXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7aXNEZWZpbmVkLCBpc09iamVjdFR5cGUsIGV4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZXRPcHRpb25zKCkge1xuXHRcdHJldHVybiBuZXcgT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBMb2FkIGNvbmZpZ3VyYXRpb24gb3B0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVXNlcidzIGdlbmVyYXRpb24gY29uZmlnIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRsb2FkQ29uZmlnKGNvbmZpZykge1xuXHRcdGNvbnN0IHRoaXNDb25maWcgPSB0aGlzLmNvbmZpZztcblx0XHRsZXQgdGFyZ2V0O1xuXHRcdGxldCBrZXlzO1xuXHRcdGxldCByZWFkO1xuXG5cdFx0Y29uc3QgZmluZCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGtleSA9IGtleXMuc2hpZnQoKTtcblxuXHRcdFx0aWYgKGtleSAmJiB0YXJnZXQgJiYgaXNPYmplY3RUeXBlKHRhcmdldCkgJiYga2V5IGluIHRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQgPSB0YXJnZXRba2V5XTtcblx0XHRcdFx0cmV0dXJuIGZpbmQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIWtleSkge1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH07XG5cblx0XHRPYmplY3Qua2V5cyh0aGlzQ29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHR0YXJnZXQgPSBjb25maWc7XG5cdFx0XHRrZXlzID0ga2V5LnNwbGl0KFwiX1wiKTtcblx0XHRcdHJlYWQgPSBmaW5kKCk7XG5cblx0XHRcdGlmIChpc0RlZmluZWQocmVhZCkpIHtcblx0XHRcdFx0dGhpc0NvbmZpZ1trZXldID0gcmVhZDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzY2FsZVRpbWUgYXMgZDNTY2FsZVRpbWUsXG5cdHNjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJcbn0gZnJvbSBcImQzLXNjYWxlXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0U2NhbGUobWluLCBtYXgsIGZvclRpbWVzZXJpZXMpIHtcblx0XHRyZXR1cm4gKGZvclRpbWVzZXJpZXMgP1xuXHRcdFx0ZDNTY2FsZVRpbWUoKSA6IGQzU2NhbGVMaW5lYXIoKVxuXHRcdCkucmFuZ2UoW21pbiwgbWF4XSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB4IEF4aXMgc2NhbGUgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkb21haW5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0IFRoZSBvZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFgobWluLCBtYXgsIGRvbWFpbiwgb2Zmc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLmdldFNjYWxlKG1pbiwgbWF4LCAkJC5pc1RpbWVTZXJpZXMoKSk7XG5cblx0XHRyZXR1cm4gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKFxuXHRcdFx0ZG9tYWluID8gc2NhbGUuZG9tYWluKGRvbWFpbikgOiBzY2FsZSxcblx0XHRcdG9mZnNldFxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB5IEF4aXMgc2NhbGUgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkb21haW5cblx0ICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRZKG1pbiwgbWF4LCBkb21haW4pIHtcblx0XHRjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUobWluLCBtYXgsIHRoaXMuaXNUaW1lU2VyaWVzWSgpKTtcblxuXHRcdGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKTtcblxuXHRcdHJldHVybiBzY2FsZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGN1c3RvbWl6ZWQgc2NhbGVcblx0ICogQHBhcmFtIHtkMy5zY2FsZUxpbmVhcnxkMy5zY2FsZVRpbWV9IHNjYWxlVmFsdWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0VmFsdWUgT2Zmc2V0IGdldHRlciB0byBiZSBzdW1cblx0ICogQHJldHVybiB7fSBzY2FsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q3VzdG9taXplZFNjYWxlKHNjYWxlVmFsdWUsIG9mZnNldFZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IG9mZnNldCA9IG9mZnNldFZhbHVlIHx8ICgoKSA9PiAkJC54QXhpcy50aWNrT2Zmc2V0KCkpO1xuXHRcdGNvbnN0IHNjYWxlID0gZnVuY3Rpb24oZCwgcmF3KSB7XG5cdFx0XHRjb25zdCB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xuXG5cdFx0XHRyZXR1cm4gcmF3ID8gdiA6IE1hdGguY2VpbCh2KTtcblx0XHR9O1xuXG5cdFx0Ly8gY29weSBvcmlnaW5hbCBzY2FsZSBtZXRob2RzXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc2NhbGVWYWx1ZSkge1xuXHRcdFx0c2NhbGVba2V5XSA9IHNjYWxlVmFsdWVba2V5XTtcblx0XHR9XG5cblx0XHRzY2FsZS5vcmdEb21haW4gPSAoKSA9PiBzY2FsZVZhbHVlLmRvbWFpbigpO1xuXHRcdHNjYWxlLm9yZ1NjYWxlID0gKCkgPT4gc2NhbGVWYWx1ZTtcblxuXHRcdC8vIGRlZmluZSBjdXN0b20gZG9tYWluKCkgZm9yIGNhdGVnb3JpemVkIGF4aXNcblx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cdFx0XHRzY2FsZS5kb21haW4gPSBmdW5jdGlvbihkb21haW5WYWx1ZSkge1xuXHRcdFx0XHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XG5cblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tYWluID0gdGhpcy5vcmdEb21haW4oKTtcblxuXHRcdFx0XHRcdHJldHVybiBbZG9tYWluWzBdLCBkb21haW5bMV0gKyAxXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjYWxlVmFsdWUuZG9tYWluKGRvbWFpbik7XG5cblx0XHRcdFx0cmV0dXJuIHNjYWxlO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2NhbGU7XG5cdH0sXG5cblx0Z2V0WVNjYWxlKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/IHRoaXMueTIgOiB0aGlzLnk7XG5cdH0sXG5cblx0Z2V0U3ViWVNjYWxlKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/IHRoaXMuc3ViWTIgOiB0aGlzLnN1Ylk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzY2FsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCAtIHBhcmFtIGlzIGdpdmVuIGF0IHRoZSBpbml0IHJlbmRlcmluZ1xuXHQgKi9cblx0dXBkYXRlU2NhbGVzKGlzSW5pdCwgdXBkYXRlWERvbWFpbiA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHQvLyB1cGRhdGUgZWRnZXNcblx0XHQkJC54TWluID0gaXNSb3RhdGVkID8gMSA6IDA7XG5cdFx0JCQueE1heCA9IGlzUm90YXRlZCA/ICQkLmhlaWdodCA6ICQkLndpZHRoO1xuXHRcdCQkLnlNaW4gPSBpc1JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0O1xuXHRcdCQkLnlNYXggPSBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IDE7XG5cdFx0JCQuc3ViWE1pbiA9ICQkLnhNaW47XG5cdFx0JCQuc3ViWE1heCA9ICQkLnhNYXg7XG5cdFx0JCQuc3ViWU1pbiA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyO1xuXHRcdCQkLnN1YllNYXggPSBpc1JvdGF0ZWQgPyAkJC53aWR0aDIgOiAxO1xuXG5cdFx0Ly8gdXBkYXRlIHNjYWxlc1xuXHRcdC8vIHggQXhpc1xuXHRcdGNvbnN0IHhEb21haW4gPSB1cGRhdGVYRG9tYWluICYmICQkLnggJiYgJCQueC5vcmdEb21haW4oKTtcblx0XHRjb25zdCB4U3ViRG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiAkJC5vcmdYRG9tYWluO1xuXG5cdFx0JCQueCA9ICQkLmdldFgoJCQueE1pbiwgJCQueE1heCwgeERvbWFpbiwgKCkgPT4gJCQueEF4aXMudGlja09mZnNldCgpKTtcblx0XHQkJC5zdWJYID0gJCQuZ2V0WCgkJC54TWluLCAkJC54TWF4LCB4U3ViRG9tYWluLCBkID0+IChkICUgMSA/IDAgOiAkJC5zdWJYQXhpcy50aWNrT2Zmc2V0KCkpKTtcblxuXHRcdCQkLnhBeGlzVGlja0Zvcm1hdCA9ICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCk7XG5cdFx0JCQueEF4aXNUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRYQXhpc1RpY2tWYWx1ZXMoKTtcblxuXHRcdCQkLnhBeGlzID0gJCQuYXhpc1xuXHRcdFx0LmdldFhBeGlzKFwieFwiLCAkJC54LCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XG5cblx0XHQkJC5zdWJYQXhpcyA9ICQkLmF4aXNcblx0XHRcdC5nZXRYQXhpcyhcInN1YlhcIiwgJCQuc3ViWCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xuXG5cdFx0Ly8geSBBeGlzXG5cdFx0JCQueSA9ICQkLmdldFkoJCQueU1pbiwgJCQueU1heCwgJCQueSA/ICQkLnkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xuXHRcdCQkLnN1YlkgPSAkJC5nZXRZKCQkLnN1YllNaW4sICQkLnN1YllNYXgsICQkLnN1YlkgPyAkJC5zdWJZLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcblxuXHRcdCQkLnlBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0WUF4aXNUaWNrVmFsdWVzKCk7XG5cblx0XHQkJC55QXhpcyA9ICQkLmF4aXNcblx0XHRcdC5nZXRZQXhpcyhcInlcIiwgJCQueSwgY29uZmlnLmF4aXNfeV90aWNrX291dGVyLCBpc0luaXQpO1xuXG5cdFx0Ly8geTIgQXhpc1xuXHRcdGlmIChjb25maWcuYXhpc195Ml9zaG93KSB7XG5cdFx0XHQkJC55MiA9ICQkLmdldFkoJCQueU1pbiwgJCQueU1heCwgJCQueTIgPyAkJC55Mi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xuXHRcdFx0JCQuc3ViWTIgPSAkJC5nZXRZKCQkLnN1YllNaW4sICQkLnN1YllNYXgsXG5cdFx0XHRcdCQkLnN1YlkyID8gJCQuc3ViWTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcblxuXHRcdFx0JCQueTJBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0WTJBeGlzVGlja1ZhbHVlcygpO1xuXG5cdFx0XHQkJC55MkF4aXMgPSAkJC5heGlzXG5cdFx0XHRcdC5nZXRZQXhpcyhcInkyXCIsICQkLnkyLCBjb25maWcuYXhpc195Ml90aWNrX291dGVyLCBpc0luaXQpO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBmb3IgYXJjXG5cdFx0JCQudXBkYXRlQXJjICYmICQkLnVwZGF0ZUFyYygpO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgYnJ1c2hFbXB0eSwgZ2V0QnJ1c2hTZWxlY3Rpb24sIGdldE1pbk1heCwgaXNEZWZpbmVkLCBub3RFbXB0eSwgaXNWYWx1ZSwgaXNPYmplY3QsIGlzTnVtYmVyLCBkaWZmRG9tYWluLCBzb3J0VmFsdWV9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNNaW4gPSB0eXBlID09PSBcIm1pblwiO1xuXG5cdFx0Y29uc3QgZGF0YUdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwcztcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKTtcblx0XHRjb25zdCB5cyA9ICQkLmdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKTtcblxuXHRcdGlmIChkYXRhR3JvdXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGhhc1ZhbHVlID0gJCRbYGhhcyR7aXNNaW4gPyBcIk5lZ2F0aXZlXCIgOiBcIlBvc2l0aXZlXCJ9VmFsdWVJblRhcmdldHNgXSh0YXJnZXRzKTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGlkc0luR3JvdXA7IChpZHNJbkdyb3VwID0gZGF0YUdyb3Vwc1tqXSk7IGorKykge1xuXHRcdFx0XHQvLyBEZXRlcm1pbmUgYmFzZUlkXG5cdFx0XHRcdGlkc0luR3JvdXAgPSBpZHNJbkdyb3VwLmZpbHRlcih2ID0+IGlkcy5pbmRleE9mKHYpID49IDApO1xuXG5cdFx0XHRcdGlmIChpZHNJbkdyb3VwLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgYmFzZUlkID0gaWRzSW5Hcm91cFswXTtcblx0XHRcdFx0Y29uc3QgYmFzZUF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKTtcblxuXHRcdFx0XHQvLyBJbml0aWFsaXplIGJhc2UgdmFsdWUuIFNldCB0byAwIGlmIG5vdCBtYXRjaCB3aXRoIHRoZSBjb25kaXRpb25cblx0XHRcdFx0aWYgKGhhc1ZhbHVlICYmIHlzW2Jhc2VJZF0pIHtcblx0XHRcdFx0XHR5c1tiYXNlSWRdID0geXNbYmFzZUlkXS5tYXAodiA9PiAoXG5cdFx0XHRcdFx0XHQoaXNNaW4gPyB2IDwgMCA6IHYgPiAwKSA/IHYgOiAwXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBrID0gMSwgaWQ7IChpZCA9IGlkc0luR3JvdXBba10pOyBrKyspIHtcblx0XHRcdFx0XHRpZiAoIXlzW2lkXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgYXhpc0lkID0gJCQuYXhpcy5nZXRJZChpZCk7XG5cblx0XHRcdFx0XHR5c1tpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsID0gK3Y7XG5cdFx0XHRcdFx0XHRjb25zdCBtZWV0Q29uZGl0aW9uID0gaXNNaW4gPyB2YWwgPiAwIDogdmFsIDwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKGF4aXNJZCA9PT0gYmFzZUF4aXNJZCAmJiAhKGhhc1ZhbHVlICYmIG1lZXRDb25kaXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdHlzW2Jhc2VJZF1baV0gKz0gdmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdldE1pbk1heCh0eXBlLCBPYmplY3Qua2V5cyh5cykubWFwKGtleSA9PiBnZXRNaW5NYXgodHlwZSwgeXNba2V5XSkpKTtcblx0fSxcblxuXHRnZXRZRG9tYWluTWluKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuXHR9LFxuXG5cdGdldFlEb21haW5NYXgodGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XG5cdH0sXG5cblx0Z2V0WURvbWFpbih0YXJnZXRzLCBheGlzSWQsIHhEb21haW4pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHtcblx0XHRcdHJldHVybiBbMCwgMTAwXTtcblx0XHR9XG5cblx0XHRjb25zdCB0YXJnZXRzQnlBeGlzSWQgPSB0YXJnZXRzLmZpbHRlcih0ID0+ICQkLmF4aXMuZ2V0SWQodC5pZCkgPT09IGF4aXNJZCk7XG5cdFx0Y29uc3QgeVRhcmdldHMgPSB4RG9tYWluID8gJCQuZmlsdGVyQnlYRG9tYWluKHRhcmdldHNCeUF4aXNJZCwgeERvbWFpbikgOiB0YXJnZXRzQnlBeGlzSWQ7XG5cdFx0Y29uc3QgeU1pbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fbWluYF07XG5cdFx0Y29uc3QgeU1heCA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fbWF4YF07XG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcblx0XHRsZXQgeURvbWFpbk1heCA9ICQkLmdldFlEb21haW5NYXgoeVRhcmdldHMpO1xuXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9jZW50ZXJgXTtcblx0XHRsZXQgaXNaZXJvQmFzZWQgPSAoJCQuaGFzVHlwZShcImJhclwiLCB5VGFyZ2V0cykgJiYgY29uZmlnLmJhcl96ZXJvYmFzZWQpIHx8ICgkJC5oYXNUeXBlKFwiYXJlYVwiLCB5VGFyZ2V0cykgJiYgY29uZmlnLmFyZWFfemVyb2Jhc2VkKTtcblx0XHRjb25zdCBpc0ludmVydGVkID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9pbnZlcnRlZGBdO1xuXHRcdGNvbnN0IHNob3dIb3Jpem9udGFsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBzaG93VmVydGljYWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiAhY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIE1FTU86IGF2b2lkIGludmVydGluZyBkb21haW4gdW5leHBlY3RlZGx5XG5cdFx0eURvbWFpbk1pbiA9IGlzVmFsdWUoeU1pbikgPyB5TWluIDpcblx0XHRcdChpc1ZhbHVlKHlNYXgpID8gKHlEb21haW5NaW4gPCB5TWF4ID8geURvbWFpbk1pbiA6IHlNYXggLSAxMCkgOiB5RG9tYWluTWluKTtcblx0XHR5RG9tYWluTWF4ID0gaXNWYWx1ZSh5TWF4KSA/IHlNYXggOlxuXHRcdFx0KGlzVmFsdWUoeU1pbikgPyAoeU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwKSA6IHlEb21haW5NYXgpO1xuXG5cdFx0aWYgKHlUYXJnZXRzLmxlbmd0aCA9PT0gMCkgeyAvLyB1c2UgY3VycmVudCBkb21haW4gaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXG5cdFx0XHRyZXR1cm4gJCRbYXhpc0lkXS5kb21haW4oKTtcblx0XHR9XG5cblx0XHRpZiAoaXNOYU4oeURvbWFpbk1pbikpIHsgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcblx0XHRcdHlEb21haW5NaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChpc05hTih5RG9tYWluTWF4KSkgeyAvLyBzZXQgbWF4aW11bSB0byBoYXZlIHNhbWUgdmFsdWUgYXMgeURvbWFpbk1pblxuXHRcdFx0eURvbWFpbk1heCA9IHlEb21haW5NaW47XG5cdFx0fVxuXG5cdFx0aWYgKHlEb21haW5NaW4gPT09IHlEb21haW5NYXgpIHtcblx0XHRcdHlEb21haW5NaW4gPCAwID8geURvbWFpbk1heCA9IDAgOiB5RG9tYWluTWluID0gMDtcblx0XHR9XG5cblx0XHRjb25zdCBpc0FsbFBvc2l0aXZlID0geURvbWFpbk1pbiA+PSAwICYmIHlEb21haW5NYXggPj0gMDtcblx0XHRjb25zdCBpc0FsbE5lZ2F0aXZlID0geURvbWFpbk1pbiA8PSAwICYmIHlEb21haW5NYXggPD0gMDtcblxuXHRcdC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXG5cdFx0aWYgKChpc1ZhbHVlKHlNaW4pICYmIGlzQWxsUG9zaXRpdmUpIHx8IChpc1ZhbHVlKHlNYXgpICYmIGlzQWxsTmVnYXRpdmUpKSB7XG5cdFx0XHRpc1plcm9CYXNlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAoeURvbWFpbk1pbiA9IDApO1xuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAoeURvbWFpbk1heCA9IDApO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKTtcblx0XHRjb25zdCBwYWRkaW5nID0ge3RvcDogZG9tYWluTGVuZ3RoICogMC4xLCBib3R0b206IGRvbWFpbkxlbmd0aCAqIDAuMX07XG5cblx0XHRpZiAoaXNEZWZpbmVkKGNlbnRlcikpIHtcblx0XHRcdGNvbnN0IHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xuXG5cdFx0XHR5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcblx0XHRcdHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xuXHRcdH1cblxuXHRcdC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXG5cdFx0aWYgKHNob3dIb3Jpem9udGFsRGF0YUxhYmVsKSB7XG5cdFx0XHRjb25zdCBkaWZmID0gZGlmZkRvbWFpbigkJC55LnJhbmdlKCkpO1xuXHRcdFx0Y29uc3QgcmF0aW8gPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJ3aWR0aFwiKVxuXHRcdFx0XHQubWFwKHYgPT4gdiAvIGRpZmYpO1xuXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRwYWRkaW5nW3ZdICs9IGRvbWFpbkxlbmd0aCAqIChyYXRpb1tpXSAvICgxIC0gcmF0aW9bMF0gLSByYXRpb1sxXSkpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcblx0XHRcdGNvbnN0IGxlbmd0aHMgPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJoZWlnaHRcIik7XG5cblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdHBhZGRpbmdbdl0gKz0gJCQuYXhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhsZW5ndGhzW2ldLCBkb21haW5MZW5ndGgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKC9eeTI/JC8udGVzdChheGlzSWQpKSB7XG5cdFx0XHRjb25zdCBwID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9wYWRkaW5nYF07XG5cblx0XHRcdGlmIChub3RFbXB0eShwKSkge1xuXHRcdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRwYWRkaW5nW3ZdID0gJCQuYXhpcy5nZXRQYWRkaW5nKHAsIHYsIHBhZGRpbmdbdl0sIGRvbWFpbkxlbmd0aCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAocGFkZGluZy5ib3R0b20gPSB5RG9tYWluTWluKTtcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHBhZGRpbmcudG9wID0gLXlEb21haW5NYXgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbiA9IFt5RG9tYWluTWluIC0gcGFkZGluZy5ib3R0b20sIHlEb21haW5NYXggKyBwYWRkaW5nLnRvcF07XG5cblx0XHRyZXR1cm4gaXNJbnZlcnRlZCA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XG5cdH0sXG5cblx0Z2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHZhbHVlID0gJCQuY29uZmlnW2BheGlzX3hfJHt0eXBlfWBdO1xuXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgP1xuXHRcdFx0KCQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKHZhbHVlKSA6IHZhbHVlKSA6XG5cdFx0XHRnZXRNaW5NYXgodHlwZSwgdGFyZ2V0cy5tYXAodCA9PiBnZXRNaW5NYXgodHlwZSwgdC52YWx1ZXMubWFwKHYgPT4gdi54KSkpKTtcblx0fSxcblxuXHRnZXRYRG9tYWluTWluKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuXHR9LFxuXG5cdGdldFhEb21haW5NYXgodGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XG5cdH0sXG5cblx0Z2V0WERvbWFpblBhZGRpbmcoZG9tYWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuXHRcdGNvbnN0IHhQYWRkaW5nID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xuXHRcdGxldCBtYXhEYXRhQ291bnQ7XG5cdFx0bGV0IHBhZGRpbmc7XG5cblx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cdFx0XHRwYWRkaW5nID0gMDtcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcblx0XHRcdG1heERhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYWRkaW5nID0gZGlmZiAqIDAuMDE7XG5cdFx0fVxuXG5cdFx0bGV0IGxlZnQgPSBwYWRkaW5nO1xuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XG5cblx0XHRpZiAoaXNPYmplY3QoeFBhZGRpbmcpICYmIG5vdEVtcHR5KHhQYWRkaW5nKSkge1xuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcblx0XHRcdHJpZ2h0ID0gaXNWYWx1ZSh4UGFkZGluZy5yaWdodCkgPyB4UGFkZGluZy5yaWdodCA6IHBhZGRpbmc7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihjb25maWcuYXhpc194X3BhZGRpbmcpKSB7XG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XG5cdFx0XHRyaWdodCA9IHhQYWRkaW5nO1xuXHRcdH1cblxuXHRcdHJldHVybiB7bGVmdCwgcmlnaHR9O1xuXHR9LFxuXG5cdGdldFhEb21haW4odGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB4RG9tYWluID0gWyQkLmdldFhEb21haW5NaW4odGFyZ2V0cyksICQkLmdldFhEb21haW5NYXgodGFyZ2V0cyldO1xuXHRcdGxldCBmaXJzdFggPSB4RG9tYWluWzBdO1xuXHRcdGxldCBsYXN0WCA9IHhEb21haW5bMV07XG5cdFx0Y29uc3QgcGFkZGluZyA9ICQkLmdldFhEb21haW5QYWRkaW5nKHhEb21haW4pO1xuXHRcdGxldCBtaW4gPSAwO1xuXHRcdGxldCBtYXggPSAwO1xuXG5cdFx0Ly8gc2hvdyBjZW50ZXIgb2YgeCBkb21haW4gaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lXG5cdFx0aWYgKChmaXJzdFggLSBsYXN0WCkgPT09IDAgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdGZpcnN0WCA9IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgKiAwLjUpO1xuXHRcdFx0XHRsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdFggPSBmaXJzdFggPT09IDAgPyAxIDogKGZpcnN0WCAqIDAuNSk7XG5cdFx0XHRcdGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IChsYXN0WCAqIDEuNSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZpcnN0WCB8fCBmaXJzdFggPT09IDApIHtcblx0XHRcdG1pbiA9ICQkLmlzVGltZVNlcmllcygpID8gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAtIHBhZGRpbmcubGVmdCkgOiBmaXJzdFggLSBwYWRkaW5nLmxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKGxhc3RYIHx8IGxhc3RYID09PSAwKSB7XG5cdFx0XHRtYXggPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSArIHBhZGRpbmcucmlnaHQpIDogbGFzdFggKyBwYWRkaW5nLnJpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBbbWluLCBtYXhdO1xuXHR9LFxuXG5cdHVwZGF0ZVhEb21haW4odGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XG5cblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcblx0XHRcdCQkLnguZG9tYWluKGRvbWFpbiB8fCBzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpO1xuXHRcdFx0JCQub3JnWERvbWFpbiA9ICQkLnguZG9tYWluKCk7XG5cblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcblxuXHRcdFx0JCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZSgkJC5zdWJYKTtcblx0XHR9XG5cblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcblx0XHRcdGNvbnN0IGRvbWFpblZhbHVlID0gZG9tYWluIHx8ICghJCQuYnJ1c2ggfHwgYnJ1c2hFbXB0eSgkJCkpID9cblx0XHRcdFx0JCQub3JnWERvbWFpbiA6IGdldEJydXNoU2VsZWN0aW9uKCQkKS5tYXAoJCQuc3ViWC5pbnZlcnQpO1xuXG5cdFx0XHQkJC54LmRvbWFpbihkb21haW5WYWx1ZSk7XG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpbSBkb21haW4gd2hlbiB0b28gYmlnIGJ5IHpvb20gbW91c2Vtb3ZlIGV2ZW50XG5cdFx0d2l0aFRyaW0gJiYgJCQueC5kb21haW4oJCQudHJpbVhEb21haW4oJCQueC5vcmdEb21haW4oKSkpO1xuXG5cdFx0cmV0dXJuICQkLnguZG9tYWluKCk7XG5cdH0sXG5cblx0dHJpbVhEb21haW4oZG9tYWluKSB7XG5cdFx0Y29uc3Qgem9vbURvbWFpbiA9IHRoaXMuZ2V0Wm9vbURvbWFpbigpO1xuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xuXG5cdFx0aWYgKGRvbWFpblswXSA8PSBtaW4pIHtcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcblx0XHRcdGRvbWFpblswXSA9IG1pbjtcblx0XHR9XG5cblx0XHRpZiAobWF4IDw9IGRvbWFpblsxXSkge1xuXHRcdFx0ZG9tYWluWzBdID0gK2RvbWFpblswXSAtIChkb21haW5bMV0gLSBtYXgpO1xuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xuXHRcdH1cblxuXHRcdHJldHVybiBkb21haW47XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtcblx0ZXh0ZW5kLFxuXHRnZXRVbmlxdWUsXG5cdGhhc1ZhbHVlLFxuXHRpc0FycmF5LFxuXHRpc0Jvb2xlYW4sXG5cdGlzRGVmaW5lZCxcblx0aXNGdW5jdGlvbixcblx0aXNOdW1iZXIsXG5cdGlzT2JqZWN0LFxuXHRpc09iamVjdFR5cGUsXG5cdGlzU3RyaW5nLFxuXHRpc1VuZGVmaW5lZCxcblx0aXNWYWx1ZSxcblx0bm90RW1wdHksXG5cdG1lcmdlQXJyYXksXG5cdHNvcnRWYWx1ZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGlzWChrZXkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcblx0XHRjb25zdCBleGlzdFZhbHVlID0gbm90RW1wdHkoY29uZmlnLmRhdGFfeHMpICYmIGhhc1ZhbHVlKGNvbmZpZy5kYXRhX3hzLCBrZXkpO1xuXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcblx0fSxcblxuXHRpc05vdFgoa2V5KSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzWChrZXkpO1xuXHR9LFxuXG5cdGlzU3RhY2tOb3JtYWxpemVkKCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xuXHR9LFxuXG5cdGlzR3JvdXBlZChpZCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xuXHRcdFx0Lm1hcCh2ID0+IHYuaW5kZXhPZihpZCkgPj0gMClbMF07XG5cdH0sXG5cblx0Z2V0WEtleShpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gY29uZmlnLmRhdGFfeCA/XG5cdFx0XHRjb25maWcuZGF0YV94IDogKG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSA/IGNvbmZpZy5kYXRhX3hzW2lkXSA6IG51bGwpO1xuXHR9LFxuXG5cdGdldFhWYWx1ZXNPZlhLZXkoa2V5LCB0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlkcyA9IHRhcmdldHMgJiYgbm90RW1wdHkodGFyZ2V0cykgPyAkJC5tYXBUb0lkcyh0YXJnZXRzKSA6IFtdO1xuXHRcdGxldCB4VmFsdWVzO1xuXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0aWYgKCQkLmdldFhLZXkoaWQpID09PSBrZXkpIHtcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHhWYWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBpbmRleCBudW1iZXIgYmFzZWQgb24gZ2l2ZW4geCBBeGlzIHZhbHVlXG5cdCAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8U3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlZFggeCBBeGlzIGxpc3QgdG8gYmUgYmFzZWQgb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBpbmRleCBudW1iZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEluZGV4QnlYKHgsIGJhc2VkWCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBiYXNlZFggP1xuXHRcdFx0YmFzZWRYLmluZGV4T2YoaXNTdHJpbmcoeCkgPyB4IDogK3gpIDpcblx0XHRcdCgkJC5maWx0ZXJCeVgoJCQuZGF0YS50YXJnZXRzLCB4KVswXSB8fCB7aW5kZXg6IG51bGx9KS5pbmRleDtcblx0fSxcblxuXHRnZXRYVmFsdWUoaWQsIGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gaWQgaW4gJCQuZGF0YS54cyAmJlxuXHRcdFx0JCQuZGF0YS54c1tpZF0gJiZcblx0XHRcdGlzVmFsdWUoJCQuZGF0YS54c1tpZF1baV0pID8gJCQuZGF0YS54c1tpZF1baV0gOiBpO1xuXHR9LFxuXG5cdGdldE90aGVyVGFyZ2V0WHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlkc0ZvclggPSBPYmplY3Qua2V5cygkJC5kYXRhLnhzKTtcblxuXHRcdHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xuXHR9LFxuXG5cdGdldE90aGVyVGFyZ2V0WChpbmRleCkge1xuXHRcdGNvbnN0IHhzID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XG5cblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xuXHR9LFxuXG5cdGFkZFhzKHhzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0T2JqZWN0LmtleXMoeHMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0JCQuY29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc011bHRpcGxlWCh4cykge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh4cykubWFwKGlkID0+IHhzW2lkXSkubGVuZ3RoID4gMTtcblx0fSxcblxuXHRpc011bHRpcGxlWCgpIHtcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcblx0XHRcdCF0aGlzLmNvbmZpZy5kYXRhX3hTb3J0IHx8XG5cdFx0XHR0aGlzLmhhc1R5cGUoXCJidWJibGVcIikgfHxcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XG5cdH0sXG5cblx0YWRkTmFtZShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBuYW1lO1xuXG5cdFx0aWYgKGRhdGEpIHtcblx0XHRcdG5hbWUgPSAkJC5jb25maWcuZGF0YV9uYW1lc1tkYXRhLmlkXTtcblx0XHRcdGRhdGEubmFtZSA9IG5hbWUgIT09IHVuZGVmaW5lZCA/IG5hbWUgOiBkYXRhLmlkO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXG5cdFx0XHQubWFwKHQgPT4gJCQuYWRkTmFtZSgkJC5nZXRWYWx1ZU9uSW5kZXgodC52YWx1ZXMsIGluZGV4KSkpO1xuXHR9LFxuXG5cdGdldFZhbHVlT25JbmRleCh2YWx1ZXMsIGluZGV4KSB7XG5cdFx0Y29uc3QgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcih2ID0+IHYuaW5kZXggPT09IGluZGV4KTtcblxuXHRcdHJldHVybiB2YWx1ZU9uSW5kZXgubGVuZ3RoID8gdmFsdWVPbkluZGV4WzBdIDogbnVsbDtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRYKHRhcmdldHMsIHgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdHYueCA9ICQkLmdlbmVyYXRlVGFyZ2V0WCh4W2ldLCB0LmlkLCBpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdID0geDtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRYcyh0YXJnZXRzLCB4cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpbmRleCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgeCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSA/IGluZGV4IDogKHJhd1ggfHwgaW5kZXgpO1xuXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHR4ID0gcmF3WCA/ICQkLnBhcnNlRGF0ZShyYXdYKSA6ICQkLnBhcnNlRGF0ZSgkJC5nZXRYVmFsdWUoaWQsIGluZGV4KSk7XG5cdFx0fSBlbHNlIGlmICgkJC5pc0N1c3RvbVgoKSAmJiAhJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH0sXG5cblx0Y2xvbmVUYXJnZXQodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiB0YXJnZXQuaWQsXG5cdFx0XHRpZF9vcmc6IHRhcmdldC5pZF9vcmcsXG5cdFx0XHR2YWx1ZXM6IHRhcmdldC52YWx1ZXMubWFwKGQgPT4gKHt4OiBkLngsIHZhbHVlOiBkLnZhbHVlLCBpZDogZC5pZH0pKVxuXHRcdH07XG5cdH0sXG5cblx0dXBkYXRlWHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XG5cblx0XHRpZiAodGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdCQkLnhzID0gW107XG5cblx0XHRcdHRhcmdldHNbMF0udmFsdWVzLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdCQkLnhzW3YuaW5kZXhdID0gdi54O1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFByZXZYKGkpIHtcblx0XHRjb25zdCB4ID0gdGhpcy54c1tpIC0gMV07XG5cblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFgoaSkge1xuXHRcdGNvbnN0IHggPSB0aGlzLnhzW2kgKyAxXTtcblxuXHRcdHJldHVybiBpc0RlZmluZWQoeCkgPyB4IDogbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGJhc2UgdmFsdWUgaXNBcmVhUmFuZ2VUeXBlXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEJhc2VWYWx1ZShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCB2YWx1ZSA9IGRhdGEudmFsdWU7XG5cblx0XHQvLyBJbiBjYXNlIG9mIGFyZWEtcmFuZ2UsIGRhdGEgaXMgZ2l2ZW4gYXM6IFtsb3csIG1pZCwgaGlnaF0gb3Ige2xvdywgbWlkLCBoaWdofVxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcblx0XHRpZiAodmFsdWUgJiYgJCQuaXNBcmVhUmFuZ2VUeXBlKGRhdGEpKSB7XG5cdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgbWluL21heCB2YWx1ZSBmcm9tIHRoZSBkYXRhXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcblx0ICogQHJldHVybiB7e21pbjoge051bWJlcn0sIG1heDoge051bWJlcn19fVxuXHQgKi9cblx0Z2V0TWluTWF4VmFsdWUoZGF0YSkge1xuXHRcdGNvbnN0IGdldEJhc2VWYWx1ZSA9IHRoaXMuZ2V0QmFzZVZhbHVlLmJpbmQodGhpcyk7XG5cdFx0bGV0IG1pbjtcblx0XHRsZXQgbWF4O1xuXG5cdFx0KGRhdGEgfHwgdGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxuXHRcdFx0LmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2Lm1hcChnZXRCYXNlVmFsdWUpLmZpbHRlcihpc051bWJlcik7XG5cblx0XHRcdFx0bWluID0gTWF0aC5taW4oaSA/IG1pbiA6IEluZmluaXR5LCAuLi52YWx1ZSk7XG5cdFx0XHRcdG1heCA9IE1hdGgubWF4KGkgPyBtYXggOiAtSW5maW5pdHksIC4uLnZhbHVlKTtcblx0XHRcdH0pO1xuXG5cdFx0cmV0dXJuIHttaW4sIG1heH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbWluL21heCBkYXRhXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm4ge3ttaW46IEFycmF5LCBtYXg6IEFycmF5fX1cblx0ICovXG5cdGdldE1pbk1heERhdGEoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkbWluTWF4RGF0YVwiO1xuXHRcdGxldCBtaW5NYXhEYXRhID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0aWYgKCFtaW5NYXhEYXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKTtcblx0XHRcdGNvbnN0IG1pbk1heCA9ICQkLmdldE1pbk1heFZhbHVlKGRhdGEpO1xuXG5cdFx0XHRsZXQgbWluID0gW107XG5cdFx0XHRsZXQgbWF4ID0gW107XG5cblx0XHRcdGRhdGEuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3QgbWluRGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1pbik7XG5cdFx0XHRcdGNvbnN0IG1heERhdGEgPSAkJC5nZXRGaWx0ZXJlZERhdGFCeVZhbHVlKHYsIG1pbk1heC5tYXgpO1xuXG5cdFx0XHRcdGlmIChtaW5EYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRcdG1pbiA9IG1pbi5jb25jYXQobWluRGF0YSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWF4RGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0XHRtYXggPSBtYXguY29uY2F0KG1heERhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBjYWNoZWQgZGF0YVxuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIG1pbk1heERhdGEgPSB7bWluLCBtYXh9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWluTWF4RGF0YTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHN1bSBvZiBkYXRhIHBlciBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGdldFRvdGFsUGVySW5kZXgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkdG90YWxQZXJJbmRleFwiO1xuXHRcdGxldCBzdW0gPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XG5cdFx0XHRzdW0gPSBbXTtcblxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcblx0XHRcdFx0cm93LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFzdW1baV0pIHtcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXG5cdCAqIEByZXR1cm4ge051bWJlcn1cbiBcdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUb3RhbERhdGFTdW0oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkdG90YWxEYXRhU3VtXCI7XG5cdFx0bGV0IHRvdGFsRGF0YVN1bSA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICghdG90YWxEYXRhU3VtKSB7XG5cdFx0XHRjb25zdCB0b3RhbCA9IG1lcmdlQXJyYXkoJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcblx0XHRcdFx0Lm1hcCh2ID0+IHYudmFsdWUpXG5cdFx0XHRcdC5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcblxuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIHRvdGFsRGF0YVN1bSA9IHRvdGFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdG90YWxEYXRhU3VtO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgZmlsdGVyZWQgZGF0YSBieSB2YWx1ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7QXJyYXl9IGZpbHRlcmVkIGFycmF5IGRhdGFcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEZpbHRlcmVkRGF0YUJ5VmFsdWUoZGF0YSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gZGF0YS5maWx0ZXIodCA9PiB0aGlzLmdldEJhc2VWYWx1ZSh0KSA9PT0gdmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcblx0ICogQHJldHVybiB7TnVtYmVyfSBtYXggZGF0YSBsZW5ndGhcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldE1heERhdGFDb3VudCgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoLi4udGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubGVuZ3RoKSk7XG5cdH0sXG5cblx0Z2V0TWF4RGF0YUNvdW50VGFyZ2V0KHRhcmdldHMpIHtcblx0XHRjb25zdCBsZW5ndGggPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRsZXQgbWF4ID0gMDtcblx0XHRsZXQgbWF4VGFyZ2V0O1xuXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0aWYgKHQudmFsdWVzLmxlbmd0aCA+IG1heCkge1xuXHRcdFx0XHRcdG1heFRhcmdldCA9IHQ7XG5cdFx0XHRcdFx0bWF4ID0gdC52YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF4VGFyZ2V0ID0gbGVuZ3RoID8gdGFyZ2V0c1swXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heFRhcmdldDtcblx0fSxcblxuXHRtYXBUb0lkcyh0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKGQgPT4gZC5pZCk7XG5cdH0sXG5cblx0bWFwVG9UYXJnZXRJZHMoaWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGlkcyA/IChpc0FycmF5KGlkcykgPyBpZHMuY29uY2F0KCkgOiBbaWRzXSkgOiAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xuXHR9LFxuXG5cdGhhc1RhcmdldCh0YXJnZXRzLCBpZCkge1xuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgdmFsOyAodmFsID0gaWRzW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNUYXJnZXRUb1Nob3codGFyZ2V0SWQpIHtcblx0XHRyZXR1cm4gdGhpcy5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xuXHR9LFxuXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGlkZGVuTGVnZW5kSWRzLmluZGV4T2YodGFyZ2V0SWQpIDwgMDtcblx0fSxcblxuXHRmaWx0ZXJUYXJnZXRzVG9TaG93KHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gKHRhcmdldHMgfHwgJCQuZGF0YS50YXJnZXRzKS5maWx0ZXIodCA9PiAkJC5pc1RhcmdldFRvU2hvdyh0LmlkKSk7XG5cdH0sXG5cblx0bWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgeHMgPSBbXTtcblxuXHRcdGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoKSB7XG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcblx0XHRcdFx0bWVyZ2VBcnJheSh0YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLm1hcCh2ID0+ICt2LngpKSlcblx0XHRcdCk7XG5cblx0XHRcdHhzID0gJCQuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xuXHR9LFxuXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcblx0XHR0aGlzLmhpZGRlblRhcmdldElkcyA9IHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmNvbmNhdCh0YXJnZXRJZHMpO1xuXHR9LFxuXG5cdHJlbW92ZUhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcblx0XHR0aGlzLmhpZGRlblRhcmdldElkcyA9IHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcblx0fSxcblxuXHRhZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcblx0fSxcblxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzQXNJZEtleWVkKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgeXMgPSB7fTtcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXG5cdFx0XHQubWFwKHYgPT4gKGlzU3RyaW5nKHYpID8gdiA6ICt2KSkgOiBudWxsO1xuXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IFtdO1xuXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XG5cblx0XHRcdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgXCJoaWdoXCIgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRkYXRhLnB1c2goLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpc011bHRpcGxlWCkge1xuXHRcdFx0XHRcdFx0ZGF0YVskJC5nZXRJbmRleEJ5WCh2LngsIHhzKV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR5c1t0LmlkXSA9IGRhdGE7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4geXM7XG5cdH0sXG5cblx0Y2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCBjaGVja2VyKSB7XG5cdFx0Y29uc3QgaWRzID0gT2JqZWN0LmtleXModGFyZ2V0cyk7XG5cdFx0bGV0IHZhbHVlcztcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXMgPSB0YXJnZXRzW2lkc1tpXV0udmFsdWVzO1xuXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoY2hlY2tlcih2YWx1ZXNbal0udmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aGFzTXVsdGlUYXJnZXRzKCkge1xuXHRcdHJldHVybiB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPiAxO1xuXHR9LFxuXG5cdGhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2IDwgMCk7XG5cdH0sXG5cblx0aGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPiAwKTtcblx0fSxcblxuXHRfY2hlY2tPcmRlcih0eXBlKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcuZGF0YV9vcmRlcjtcblxuXHRcdHJldHVybiBpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcblx0fSxcblxuXHRpc09yZGVyRGVzYygpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImRlc2NcIik7XG5cdH0sXG5cblx0aXNPcmRlckFzYygpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImFzY1wiKTtcblx0fSxcblxuXHQvKipcblx0ICogU29ydCB0YXJnZXRzIGRhdGFcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1ZhbHVlXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFsuLi50YXJnZXRzVmFsdWVdO1xuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xuXHRcdGNvbnN0IG9yZGVyRGVzYyA9ICQkLmlzT3JkZXJEZXNjKCk7XG5cblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XG5cdFx0XHR0YXJnZXRzLnNvcnQoKHQxLCB0MikgPT4ge1xuXHRcdFx0XHRjb25zdCByZWR1Y2VyID0gKHAsIGMpID0+IHAgKyBNYXRoLmFicyhjLnZhbHVlKTtcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xuXHRcdFx0XHRjb25zdCB0MlN1bSA9IHQyLnZhbHVlcy5yZWR1Y2UocmVkdWNlciwgMCk7XG5cblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY29uZmlnLmRhdGFfb3JkZXIpKSB7XG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIpO1xuXHRcdH0gLy8gVE9ETzogYWNjZXB0IG5hbWUgYXJyYXkgZm9yIG9yZGVyXG5cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fSxcblxuXHRmaWx0ZXJCeVgodGFyZ2V0cywgeCkge1xuXHRcdHJldHVybiBtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKS5maWx0ZXIodiA9PiB2LnggLSB4ID09PSAwKTtcblx0fSxcblxuXHRmaWx0ZXJSZW1vdmVOdWxsKGRhdGEpIHtcblx0XHRyZXR1cm4gZGF0YS5maWx0ZXIoZCA9PiBpc1ZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKGQpKSk7XG5cdH0sXG5cblx0ZmlsdGVyQnlYRG9tYWluKHRhcmdldHMsIHhEb21haW4pIHtcblx0XHRyZXR1cm4gdGFyZ2V0cy5tYXAodCA9PiAoe1xuXHRcdFx0aWQ6IHQuaWQsXG5cdFx0XHRpZF9vcmc6IHQuaWRfb3JnLFxuXHRcdFx0dmFsdWVzOiB0LnZhbHVlcy5maWx0ZXIodiA9PiB4RG9tYWluWzBdIDw9IHYueCAmJiB2LnggPD0geERvbWFpblsxXSlcblx0XHR9KSk7XG5cdH0sXG5cblx0aGFzRGF0YUxhYmVsKCkge1xuXHRcdGNvbnN0IGRhdGFMYWJlbHMgPSB0aGlzLmNvbmZpZy5kYXRhX2xhYmVscztcblxuXHRcdHJldHVybiAoaXNCb29sZWFuKGRhdGFMYWJlbHMpICYmIGRhdGFMYWJlbHMpIHx8XG5cdFx0XHQoaXNPYmplY3RUeXBlKGRhdGFMYWJlbHMpICYmIG5vdEVtcHR5KGRhdGFMYWJlbHMpKTtcblx0fSxcblxuXHRnZXREYXRhTGFiZWxMZW5ndGgobWluLCBtYXgsIGtleSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBsZW5ndGhzID0gWzAsIDBdO1xuXHRcdGNvbnN0IHBhZGRpbmdDb2VmID0gMS4zO1xuXG5cdFx0JCQuc2VsZWN0Q2hhcnQuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi5kdW1teVwiKVxuXHRcdFx0LmRhdGEoW21pbiwgbWF4XSlcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LnRleHQoZCA9PiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZCkpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiBwYWRkaW5nQ29lZjtcblx0XHRcdH0pXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRyZXR1cm4gbGVuZ3Rocztcblx0fSxcblxuXHRpc05vbmVBcmMoZCkge1xuXHRcdHJldHVybiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5pZCk7XG5cdH0sXG5cblx0aXNBcmMoZCkge1xuXHRcdHJldHVybiBcImRhdGFcIiBpbiBkICYmIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmRhdGEuaWQpO1xuXHR9LFxuXG5cdGZpbmRTYW1lWE9mVmFsdWVzKHZhbHVlcywgaW5kZXgpIHtcblx0XHRjb25zdCB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54O1xuXHRcdGNvbnN0IHNhbWVzID0gW107XG5cdFx0bGV0IGk7XG5cblx0XHRmb3IgKGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSBpbmRleDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNhbWVzO1xuXHR9LFxuXG5cdGZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0cywgcG9zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4gJCQuZmluZENsb3Nlc3QodGFyZ2V0LnZhbHVlcywgcG9zKSk7IC8vIG1hcCB0byBhcnJheSBvZiBjbG9zZXN0IHBvaW50cyBvZiBlYWNoIHRhcmdldFxuXG5cdFx0Ly8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxuXHRcdHJldHVybiAkJC5maW5kQ2xvc2VzdChjYW5kaWRhdGVzLCBwb3MpO1xuXHR9LFxuXG5cdGZpbmRDbG9zZXN0KHZhbHVlcywgcG9zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBtaW5EaXN0ID0gJCQuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5O1xuXHRcdGxldCBjbG9zZXN0O1xuXG5cdFx0Ly8gZmluZCBtb3VzZW92ZXJpbmcgYmFyXG5cdFx0dmFsdWVzXG5cdFx0XHQuZmlsdGVyKHYgPT4gdiAmJiAkJC5pc0JhclR5cGUodi5pZCkpXG5cdFx0XHQuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYmFyc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHYuaWQpfSAuJHtDTEFTUy5iYXJ9LSR7di5pbmRleH1gKS5ub2RlKCk7XG5cblx0XHRcdFx0aWYgKCFjbG9zZXN0ICYmICQkLmlzV2l0aGluQmFyKHNoYXBlKSkge1xuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdC8vIGZpbmQgY2xvc2VzdCBwb2ludCBmcm9tIG5vbi1iYXJcblx0XHR2YWx1ZXNcblx0XHRcdC5maWx0ZXIodiA9PiB2ICYmICEkJC5pc0JhclR5cGUodi5pZCkpXG5cdFx0XHQuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3QgZCA9ICQkLmRpc3QodiwgcG9zKTtcblxuXHRcdFx0XHRpZiAoZCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZDtcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4gY2xvc2VzdDtcblx0fSxcblxuXHRkaXN0KGRhdGEsIHBvcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Y29uc3QgeEluZGV4ID0gaXNSb3RhdGVkID8gMSA6IDA7XG5cdFx0Y29uc3QgeUluZGV4ID0gaXNSb3RhdGVkID8gMCA6IDE7XG5cdFx0Y29uc3QgeSA9ICQkLmNpcmNsZVkoZGF0YSwgZGF0YS5pbmRleCk7XG5cdFx0Y29uc3QgeCA9ICgkJC56b29tU2NhbGUgfHwgJCQueCkoZGF0YS54KTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIHBvc1t4SW5kZXhdLCAyKSArIE1hdGgucG93KHkgLSBwb3NbeUluZGV4XSwgMikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGRhdGEgZm9yIHN0ZXAgdHlwZVxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgT2JqZWN0IGRhdGEgdmFsdWVzXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBzdGVwVHlwZSA9IGNvbmZpZy5saW5lX3N0ZXBfdHlwZTtcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xuXG5cdFx0Y29uc3QgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XG5cblx0XHRpZiAoIWlzUm90YXRlZCAmJiAhaXNDYXRlZ29yaXplZCkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9XG5cblx0XHQvLyBpbnNlcnQgJiBhcHBlbmQgY2xvbmluZyBmaXJzdC9sYXN0IHZhbHVlIHRvIGJlIGZ1bGx5IHJlbmRlcmVkIGNvdmVyaW5nIG9uIGVhY2ggZ2FwIHNpZGVzXG5cdFx0Y29uc3QgaWQgPSBjb252ZXJ0ZWRbMF0uaWQ7XG5cblx0XHQvLyBpbnNlcnRcblx0XHRsZXQgeCA9IGNvbnZlcnRlZFswXS54IC0gMTtcblx0XHRsZXQgdmFsdWUgPSBjb252ZXJ0ZWRbMF0udmFsdWU7XG5cblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC51bnNoaWZ0KHt4LCB2YWx1ZSwgaWR9KTtcblxuXHRcdHN0ZXBUeXBlID09PSBcInN0ZXAtYWZ0ZXJcIiAmJlxuXHRcdFx0Y29udmVydGVkLnVuc2hpZnQoe3g6IHggLSAxLCB2YWx1ZSwgaWR9KTtcblxuXHRcdC8vIGFwcGVuZFxuXHRcdHggPSBjb252ZXJ0ZWQubGVuZ3RoO1xuXHRcdHZhbHVlID0gY29udmVydGVkW3ggLSAxXS52YWx1ZTtcblxuXHRcdGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnB1c2goe3gsIHZhbHVlLCBpZH0pO1xuXG5cdFx0c3RlcFR5cGUgPT09IFwic3RlcC1iZWZvcmVcIiAmJlxuXHRcdFx0Y29udmVydGVkLnB1c2goe3g6IHggKyAxLCB2YWx1ZSwgaWR9KTtcblxuXHRcdHJldHVybiBjb252ZXJ0ZWQ7XG5cdH0sXG5cblx0Y29udmVydFZhbHVlc1RvUmFuZ2UodmFsdWVzKSB7XG5cdFx0Y29uc3QgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XG5cdFx0Y29uc3QgcmFuZ2VzID0gW107XG5cblx0XHRjb252ZXJ0ZWQuZm9yRWFjaChyYW5nZSA9PiB7XG5cdFx0XHRjb25zdCB7eCwgaWR9ID0gcmFuZ2U7XG5cblx0XHRcdHJhbmdlcy5wdXNoKHtcblx0XHRcdFx0eCxcblx0XHRcdFx0aWQsXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVswXVxuXHRcdFx0fSk7XG5cblx0XHRcdHJhbmdlcy5wdXNoKHtcblx0XHRcdFx0eCxcblx0XHRcdFx0aWQsXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVsyXVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcmFuZ2VzO1xuXHR9LFxuXG5cdHVwZGF0ZURhdGFBdHRyaWJ1dGVzKG5hbWUsIGF0dHJzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjdXJyZW50ID0gY29uZmlnW2BkYXRhXyR7bmFtZX1gXTtcblxuXHRcdGlmIChpc1VuZGVmaW5lZChhdHRycykpIHtcblx0XHRcdHJldHVybiBjdXJyZW50O1xuXHRcdH1cblxuXHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGN1cnJlbnRbaWRdID0gYXR0cnNbaWRdO1xuXHRcdH0pO1xuXG5cdFx0JCQucmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XG5cblx0XHRyZXR1cm4gY3VycmVudDtcblx0fSxcblxuXHRnZXRBcmVhUmFuZ2VEYXRhKGQsIHR5cGUpIHtcblx0XHRjb25zdCB2YWx1ZSA9IGQudmFsdWU7XG5cblx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gW1wiaGlnaFwiLCBcIm1pZFwiLCBcImxvd1wiXS5pbmRleE9mKHR5cGUpO1xuXG5cdFx0XHRyZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHZhbHVlW2luZGV4XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVbdHlwZV07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYXRpbyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBSYXRpbyBmb3IgZ2l2ZW4gdHlwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIHZhbHVlIG9iamVjdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFzUGVyY2VudCBDb252ZXJ0IHRoZSByZXR1cm4gYXMgcGVyY2VudCBvciBub3Rcblx0ICogQHJldHVybiB7TnVtYmVyfSBSYXRpbyB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UmF0aW8odHlwZSwgZCwgYXNQZXJjZW50KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBhcGkgPSAkJC5hcGk7XG5cdFx0bGV0IHJhdGlvID0gMDtcblxuXHRcdGlmIChkICYmIGFwaS5kYXRhLnNob3duLmNhbGwoYXBpKS5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGRhdGFWYWx1ZXMgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpO1xuXG5cdFx0XHRyYXRpbyA9IGQucmF0aW8gfHwgZC52YWx1ZTtcblxuXHRcdFx0aWYgKHR5cGUgPT09IFwiYXJjXCIpIHtcblx0XHRcdFx0Ly8gaWYgaGFzIHBhZEFuZ2xlIHNldCwgY2FsY3VsYXRlIHJhdGUgYmFzZWQgb24gdmFsdWVcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcblx0XHRcdFx0XHRsZXQgdG90YWwgPSAkJC5nZXRUb3RhbERhdGFTdW0oKTtcblxuXHRcdFx0XHRcdGlmICgkJC5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0b3RhbCAtPSBkYXRhVmFsdWVzKCQkLmhpZGRlblRhcmdldElkcykucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmF0aW8gPSBkLnZhbHVlIC8gdG90YWw7XG5cblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJhdGlvID0gKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gKFxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcblx0XHRcdFx0bGV0IHRvdGFsID0gdGhpcy5nZXRUb3RhbFBlckluZGV4KCk7XG5cblx0XHRcdFx0aWYgKCQkLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRsZXQgaGlkZGVuU3VtID0gZGF0YVZhbHVlcygkJC5oaWRkZW5UYXJnZXRJZHMsIGZhbHNlKTtcblxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRoaWRkZW5TdW0gPSBoaWRkZW5TdW1cblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MubWFwKCh2LCBpKSA9PiAoaXNOdW1iZXIodikgPyB2IDogMCkgKyBjdXJyW2ldKSk7XG5cblx0XHRcdFx0XHRcdHRvdGFsID0gdG90YWwubWFwKCh2LCBpKSA9PiB2IC0gaGlkZGVuU3VtW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkLnJhdGlvID0gaXNOdW1iZXIoZC52YWx1ZSkgJiYgdG90YWwgJiYgdG90YWxbZC5pbmRleF0gPiAwID9cblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xuXG5cdFx0XHRcdHJhdGlvID0gZC5yYXRpbztcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XG5cdFx0XHRcdHJhdGlvID0gKHBhcnNlRmxvYXQoTWF0aC5tYXgoZC52YWx1ZSwgMCkpIC8gJCQubWF4VmFsdWUpICogY29uZmlnLnJhZGFyX3NpemVfcmF0aW87XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0Y3N2UGFyc2UgYXMgZDNDc3ZQYXJzZSxcblx0dHN2UGFyc2UgYXMgZDNUc3ZQYXJzZSxcblx0Y3N2UGFyc2VSb3dzIGFzIGQzQ3N2UGFyc2VSb3dzLFxuXHR0c3ZQYXJzZVJvd3MgYXMgZDNUc3ZQYXJzZVJvd3MsXG59IGZyb20gXCJkMy1kc3ZcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtpc1VuZGVmaW5lZCwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNWYWx1ZSwgbm90RW1wdHksIGV4dGVuZCwgaXNBcnJheSwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQ29udmVydCBkYXRhIGFjY29yZGluZyBpdHMgdHlwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBkYXRhIG9iamVjdFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZvciB1cmwoWEhSKSB0eXBlIGxvYWRpbmdcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y29udmVydERhdGEoYXJncywgY2FsbGJhY2spIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGRhdGE7XG5cblx0XHRpZiAoYXJncy5iaW5kdG8pIHtcblx0XHRcdGRhdGEgPSB7fTtcblxuXHRcdFx0W1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl1cblx0XHRcdFx0LmZvckVhY2godiA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qga2V5ID0gYGRhdGFfJHt2fWA7XG5cblx0XHRcdFx0XHRpZiAoa2V5IGluIGFyZ3MpIHtcblx0XHRcdFx0XHRcdGRhdGFbdl0gPSBhcmdzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGRhdGEudXJsICYmIGNhbGxiYWNrKSB7XG5cdFx0XHQkJC5jb252ZXJ0VXJsVG9EYXRhKGRhdGEudXJsLCBkYXRhLm1pbWVUeXBlLCBkYXRhLmhlYWRlcnMsIGRhdGEua2V5cywgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5qc29uKSB7XG5cdFx0XHRkYXRhID0gJCQuY29udmVydEpzb25Ub0RhdGEoZGF0YS5qc29uLCBkYXRhLmtleXMpO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5yb3dzKSB7XG5cdFx0XHRkYXRhID0gJCQuY29udmVydFJvd3NUb0RhdGEoZGF0YS5yb3dzKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY29sdW1ucykge1xuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnRDb2x1bW5zVG9EYXRhKGRhdGEuY29sdW1ucyk7XG5cdFx0fSBlbHNlIGlmIChhcmdzLmJpbmR0bykge1xuXHRcdFx0dGhyb3cgRXJyb3IoXCJ1cmwgb3IganNvbiBvciByb3dzIG9yIGNvbHVtbnMgaXMgcmVxdWlyZWQuXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdGNvbnZlcnRVcmxUb0RhdGEodXJsLCBtaW1lVHlwZSA9IFwiY3N2XCIsIGhlYWRlcnMsIGtleXMsIGRvbmUpIHtcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdGlmIChoZWFkZXJzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcS5vcGVuKFwiR0VUXCIsIHVybCk7XG5cdFx0cmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSByZXEucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0cmVzcG9uc2UgJiYgZG9uZS5jYWxsKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzW2Bjb252ZXJ0JHtjYXBpdGFsaXplKG1pbWVUeXBlKX1Ub0RhdGFgXShcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcblx0XHRcdFx0XHRcdFx0a2V5c1xuXHRcdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke3VybH06IFNvbWV0aGluZyB3ZW50IHdyb25nIGxvYWRpbmchYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVxLnNlbmQoKTtcblx0fSxcblxuXHRfY29udmVydENzdlRzdlRvRGF0YShwYXJzZXIsIHhzdikge1xuXHRcdGNvbnN0IHJvd3MgPSBwYXJzZXIucm93cyh4c3YpO1xuXHRcdGxldCBkO1xuXG5cdFx0aWYgKHJvd3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRkID0gW3t9XTtcblxuXHRcdFx0cm93c1swXS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZDtcblx0fSxcblxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xuXHRcdHJldHVybiB0aGlzLl9jb252ZXJ0Q3N2VHN2VG9EYXRhKHtcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxuXHRcdFx0cGFyc2U6IGQzQ3N2UGFyc2Vcblx0XHR9LCB4c3YpO1xuXHR9LFxuXG5cdGNvbnZlcnRUc3ZUb0RhdGEodHN2KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnZlcnRDc3ZUc3ZUb0RhdGEoe1xuXHRcdFx0cm93czogZDNUc3ZQYXJzZVJvd3MsXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxuXHRcdH0sIHRzdik7XG5cdH0sXG5cblx0Y29udmVydEpzb25Ub0RhdGEoanNvbiwga2V5c1BhcmFtKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgbmV3Um93cyA9IFtdO1xuXHRcdGxldCB0YXJnZXRLZXlzO1xuXHRcdGxldCBkYXRhO1xuXG5cdFx0aWYgKGlzQXJyYXkoanNvbikpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcblxuXHRcdFx0aWYgKGtleXMueCkge1xuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcblx0XHRcdFx0Y29uZmlnLmRhdGFfeCA9IGtleXMueDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XG5cblx0XHRcdGpzb24uZm9yRWFjaChvID0+IHtcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcblx0XHRcdFx0XHQvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIGJlY2F1c2UgdW5kZWZpbmVkIGRhdGEgd2lsbCBiZSByZW1vdmVkIGluIGNvbnZlcnREYXRhVG9UYXJnZXRzKClcblx0XHRcdFx0XHRsZXQgdiA9IHRoaXMuZmluZFZhbHVlSW5Kc29uKG8sIGtleSk7XG5cblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcblx0XHRcdFx0XHRcdHYgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRuZXdSb3dzLnB1c2gobmV3Um93KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Um93c1RvRGF0YShuZXdSb3dzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRjb25zdCB0bXAgPSBqc29uW2tleV0uY29uY2F0KCk7XG5cblx0XHRcdFx0dG1wLnVuc2hpZnQoa2V5KTtcblx0XHRcdFx0bmV3Um93cy5wdXNoKHRtcCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydENvbHVtbnNUb0RhdGEobmV3Um93cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0ZmluZFZhbHVlSW5Kc29uKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIG9iamVjdFtwYXRoXTtcblx0XHR9XG5cblx0XHRjb25zdCBjb252ZXJ0ZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgXCIuJDFcIik7IC8vIGNvbnZlcnQgaW5kZXhlcyB0byBwcm9wZXJ0aWVzIChyZXBsYWNlIFtdIHdpdGggLilcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBjb252ZXJ0ZWRQYXRoLnJlcGxhY2UoL15cXC4vLCBcIlwiKS5zcGxpdChcIi5cIik7IC8vIHN0cmlwIGEgbGVhZGluZyBkb3Rcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xuXG5cdFx0cGF0aEFycmF5LnNvbWUoayA9PiAhKFxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cblx0XHRcdFx0dGFyZ2V0W2tdIDogdW5kZWZpbmVkXG5cdFx0KSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdGNvbnZlcnRSb3dzVG9EYXRhKHJvd3MpIHtcblx0XHRjb25zdCBrZXlzID0gcm93c1swXTtcblx0XHRjb25zdCBuZXdSb3dzID0gW107XG5cblx0XHRmb3IgKGxldCBpID0gMSwgbGVuMSA9IHJvd3MubGVuZ3RoOyBpIDwgbGVuMTsgaSsrKSB7XG5cdFx0XHRjb25zdCBuZXdSb3cgPSB7fTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGxlbjIgPSByb3dzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQocm93c1tpXVtqXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gcm93c1tpXVtqXTtcblx0XHRcdH1cblxuXHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XG5cdH0sXG5cblx0Y29udmVydENvbHVtbnNUb0RhdGEoY29sdW1ucykge1xuXHRcdGNvbnN0IG5ld1Jvd3MgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwLCBsZW4xID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHtcblx0XHRcdGNvbnN0IGtleSA9IGNvbHVtbnNbaV1bMF07XG5cblx0XHRcdGZvciAobGV0IGogPSAxLCBsZW4yID0gY29sdW1uc1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKG5ld1Jvd3NbaiAtIDFdKSkge1xuXHRcdFx0XHRcdG5ld1Jvd3NbaiAtIDFdID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoY29sdW1uc1tpXVtqXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3Um93c1tqIC0gMV1ba2V5XSA9IGNvbHVtbnNbaV1bal07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XG5cdH0sXG5cblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSB8fCB7fSk7XG5cdFx0Y29uc3QgaWRzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzTm90WCwgJCQpIDogW107XG5cdFx0Y29uc3QgeHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNYLCAkJCkgOiBbXTtcblx0XHRsZXQgeHNEYXRhO1xuXG5cdFx0Ly8gc2F2ZSB4IGZvciB1cGRhdGUgZGF0YSBieSBsb2FkIHdoZW4gY3VzdG9tIHggYW5kIGJiLnggQVBJXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0Y29uc3QgeEtleSA9IHRoaXMuZ2V0WEtleShpZCk7XG5cblx0XHRcdGlmICh0aGlzLmlzQ3VzdG9tWCgpIHx8IHRoaXMuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxuXHRcdFx0XHRpZiAoeHMuaW5kZXhPZih4S2V5KSA+PSAwKSB7XG5cdFx0XHRcdFx0eHNEYXRhID0gKChhcHBlbmRYcyAmJiAkJC5kYXRhLnhzW2lkXSkgfHwgW10pXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxuXHRcdFx0XHRcdFx0XHRkYXRhLm1hcChkID0+IGRbeEtleV0pXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihpc1ZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbmZpZy5kYXRhX3gpIHtcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxuXHRcdFx0XHRcdHhzRGF0YSA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSkge1xuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcblx0XHRcdFx0XHR4c0RhdGEgPSAkJC5nZXRYVmFsdWVzT2ZYS2V5KHhLZXksICQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eHNEYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IGkpO1xuXHRcdFx0fVxuXG5cdFx0XHR4c0RhdGEgJiYgKHRoaXMuZGF0YS54c1tpZF0gPSB4c0RhdGEpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY2hlY2sgeCBpcyBkZWZpbmVkXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0aWYgKCF4c0RhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB4IGlzIG5vdCBkZWZpbmVkIGZvciBpZCA9IFwiJHtpZH1cIi5gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGNvbnZlcnQgdG8gdGFyZ2V0XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IGlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgY29udmVydGVkSWQgPSBjb25maWcuZGF0YV9pZENvbnZlcnRlcihpZCk7XG5cdFx0XHRjb25zdCB4S2V5ID0gJCQuZ2V0WEtleShpZCk7XG5cdFx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDdXN0b21YKCkgJiYgJCQuaXNDYXRlZ29yaXplZCgpO1xuXHRcdFx0Y29uc3QgaGFzQ2F0ZWdvcnkgPSBpc0NhdGVnb3JpemVkICYmIGRhdGEubWFwKHYgPT4gdi54KVxuXHRcdFx0XHQuZXZlcnkodiA9PiBjb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZih2KSA+IC0xKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQ6IGNvbnZlcnRlZElkLFxuXHRcdFx0XHRpZF9vcmc6IGlkLFxuXHRcdFx0XHR2YWx1ZXM6IGRhdGEubWFwKChkLCBpKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcmF3WCA9IGRbeEtleV07XG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XG5cdFx0XHRcdFx0bGV0IHg7XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgP1xuXHRcdFx0XHRcdFx0K2RbaWRdIDogKGlzQXJyYXkodmFsdWUpIHx8IChpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuaGlnaCkgPyB2YWx1ZSA6IG51bGwpO1xuXG5cdFx0XHRcdFx0Ly8gdXNlIHggYXMgY2F0ZWdvcmllcyBpZiBjdXN0b20geCBhbmQgY2F0ZWdvcml6ZWRcblx0XHRcdFx0XHRpZiAoaXNDYXRlZ29yaXplZCAmJiBpbmRleCA9PT0gMCAmJiAhaXNVbmRlZmluZWQocmF3WCkpIHtcblx0XHRcdFx0XHRcdGlmICghaGFzQ2F0ZWdvcnkgJiYgaW5kZXggPT09IDAgJiYgaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBbXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHJhd1gpO1xuXG5cdFx0XHRcdFx0XHRpZiAoeCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5wdXNoKHJhd1gpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBtYXJrIGFzIHggPSB1bmRlZmluZWQgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZCBmaWx0ZXIgdG8gcmVtb3ZlIGFmdGVyIG1hcHBlZFxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChkW2lkXSkgfHwgJCQuZGF0YS54c1tpZF0ubGVuZ3RoIDw9IGkpIHtcblx0XHRcdFx0XHRcdHggPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHt4LCB2YWx1ZSwgaWQ6IGNvbnZlcnRlZElkfTtcblx0XHRcdFx0fSkuZmlsdGVyKHYgPT4gaXNEZWZpbmVkKHYueCkpXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0Ly8gZmluaXNoIHRhcmdldHNcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHQvLyBzb3J0IHZhbHVlcyBieSBpdHMgeFxuXHRcdFx0aWYgKGNvbmZpZy5kYXRhX3hTb3J0KSB7XG5cdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuc29ydCgodjEsIHYyKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgeDEgPSB2MS54IHx8IHYxLnggPT09IDAgPyB2MS54IDogSW5maW5pdHk7XG5cdFx0XHRcdFx0Y29uc3QgeDIgPSB2Mi54IHx8IHYyLnggPT09IDAgPyB2Mi54IDogSW5maW5pdHk7XG5cblx0XHRcdFx0XHRyZXR1cm4geDEgLSB4Mjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGV4aW5nIGVhY2ggdmFsdWVcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+ICh2LmluZGV4ID0gaSkpO1xuXG5cdFx0XHQvLyB0aGlzIG5lZWRzIHRvIGJlIHNvcnRlZCBiZWNhdXNlIGl0cyBpbmRleCBhbmQgdmFsdWUuaW5kZXggaXMgaWRlbnRpY2FsXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdLnNvcnQoKHYxLCB2MikgPT4gdjEgLSB2Mik7XG5cdFx0fSk7XG5cblx0XHQvLyBjYWNoZSBpbmZvcm1hdGlvbiBhYm91dCB2YWx1ZXNcblx0XHQkJC5oYXNOZWdhdGl2ZVZhbHVlID0gJCQuaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcblx0XHQkJC5oYXNQb3NpdGl2ZVZhbHVlID0gJCQuaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcblxuXHRcdC8vIHNldCB0YXJnZXQgdHlwZXNcblx0XHRpZiAoY29uZmlnLmRhdGFfdHlwZSkge1xuXHRcdFx0JCQuc2V0VGFyZ2V0VHlwZSgkJC5tYXBUb0lkcyh0YXJnZXRzKVxuXHRcdFx0XHQuZmlsdGVyKGlkID0+ICEoaWQgaW4gY29uZmlnLmRhdGFfdHlwZXMpKSwgY29uZmlnLmRhdGFfdHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gY2FjaGUgYXMgb3JpZ2luYWwgaWQga2V5ZWRcblx0XHR0YXJnZXRzLmZvckVhY2goZCA9PiAkJC5hZGRDYWNoZShkLmlkX29yZywgZCwgdHJ1ZSkpO1xuXG5cdFx0cmV0dXJuIHRhcmdldHM7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRsb2FkKHJhd1RhcmdldHMsIGFyZ3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHRhcmdldHMgPSByYXdUYXJnZXRzO1xuXG5cdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdC8vIGZpbHRlciBsb2FkaW5nIHRhcmdldHMgaWYgbmVlZGVkXG5cdFx0XHRpZiAoYXJncy5maWx0ZXIpIHtcblx0XHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKGFyZ3MuZmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IHR5cGUgaWYgYXJncy50eXBlcyB8fCBhcmdzLnR5cGUgc3BlY2lmaWVkXG5cdFx0XHRpZiAoYXJncy50eXBlIHx8IGFyZ3MudHlwZXMpIHtcblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSAoYXJncy50eXBlcyAmJiBhcmdzLnR5cGVzW3QuaWRdKSB8fCBhcmdzLnR5cGU7XG5cblx0XHRcdFx0XHQkJC5zZXRUYXJnZXRUeXBlKHQuaWQsIHR5cGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlL0FkZCBkYXRhXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGQuaWQgPT09IHRhcmdldHNbaV0uaWQpIHtcblx0XHRcdFx0XHRcdGQudmFsdWVzID0gdGFyZ2V0c1tpXS52YWx1ZXM7XG5cdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7IC8vIGFkZCByZW1haW5lZFxuXHRcdH1cblxuXHRcdC8vIFNldCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcblx0XHR9KTtcblxuXHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUoKTtcblx0fSxcblxuXHRsb2FkRnJvbUFyZ3MoYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdC8vIHByZXZlbnQgbG9hZCB3aGVuIGNoYXJ0IGlzIGFscmVhZHkgZGVzdHJveWVkXG5cdFx0aWYgKCEkJC5jb25maWcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXG5cdFx0JCQucmVzZXRDYWNoZSgpO1xuXG5cdFx0Y29uc3QgZGF0YSA9IGFyZ3MuZGF0YSB8fCAkJC5jb252ZXJ0RGF0YShhcmdzLCBkID0+ICQkLmxvYWQoJCQuY29udmVydERhdGFUb1RhcmdldHMoZCksIGFyZ3MpKTtcblxuXHRcdCQkLmxvYWQoZGF0YSA/ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpIDogbnVsbCwgYXJncyk7XG5cdH0sXG5cblx0dW5sb2FkKHJhd1RhcmdldElkcywgY3VzdG9tRG9uZUNiKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBkb25lID0gY3VzdG9tRG9uZUNiO1xuXHRcdGxldCB0YXJnZXRJZHMgPSByYXdUYXJnZXRJZHM7XG5cblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXG5cdFx0JCQucmVzZXRDYWNoZSgpO1xuXG5cdFx0aWYgKCFkb25lKSB7XG5cdFx0XHRkb25lID0gKCkgPT4ge307XG5cdFx0fVxuXG5cdFx0Ly8gZmlsdGVyIGV4aXN0aW5nIHRhcmdldFxuXHRcdHRhcmdldElkcyA9IHRhcmdldElkcy5maWx0ZXIoaWQgPT4gJCQuaGFzVGFyZ2V0KCQkLmRhdGEudGFyZ2V0cywgaWQpKTtcblxuXHRcdC8vIElmIG5vIHRhcmdldCwgY2FsbCBkb25lIGFuZCByZXR1cm5cblx0XHRpZiAoIXRhcmdldElkcyB8fCB0YXJnZXRJZHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRkb25lKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpXG5cdFx0XHQuY2FsbCgkJC5lbmRhbGwsIGRvbmUpO1xuXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0Ly8gUmVzZXQgZmFkZWluIGZvciBmdXR1cmUgbG9hZFxuXHRcdFx0JCQud2l0aG91dEZhZGVJbltpZF0gPSBmYWxzZTtcblx0XHRcdC8vIFJlbW92ZSB0YXJnZXQncyBlbGVtZW50c1xuXHRcdFx0aWYgKCQkLmxlZ2VuZCkge1xuXHRcdFx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldFxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0ID0+IHQuaWQgIT09IGlkKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQ2F0ZWdvcnkgTmFtZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICogQHJldHVybnMge1N0cmluZ30gZ2F0ZWdvcnkgTmFtZVxuXHQgKi9cblx0Y2F0ZWdvcnlOYW1lKGkpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdHJldHVybiBpIDwgY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA/IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA6IGk7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdG1vdXNlIGFzIGQzTW91c2UsXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0ZXZlbnQgYXMgZDNFdmVudFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2VtdWxhdGVFdmVudCwgZXh0ZW5kLCBpc0Jvb2xlYW4sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxuXHQgKiBBZGQgYSBjb250YWluZXIgZm9yIHRoZSB6b25lIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0RXZlbnRSZWN0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0cylcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhd3MgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlZHJhd0V2ZW50UmVjdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcblx0XHRsZXQgZXZlbnRSZWN0VXBkYXRlO1xuXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIHpvb21FbmFibGVkICYmIHpvb21FbmFibGVkLnR5cGUgIT09IFwiZHJhZ1wiID8gKFxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJucy1yZXNpemVcIiA6IFwiZXctcmVzaXplXCJcblx0XHRcdCkgOiBudWxsKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c011bHRpcGxlLCBpc011bHRpcGxlWClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XG5cblx0XHQvLyBjbGVhciBvbGQgcmVjdHNcblx0XHRldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnJlbW92ZSgpO1xuXG5cdFx0Ly8gb3BlbiBhcyBwdWJsaWMgY29uc3RpYWJsZVxuXHRcdCQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XG5cblx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmV2ZW50UmVjdC5kYXRhKFswXSk7XG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdC8vIGVudGVyOiBvbmx5IG9uZSByZWN0IHdpbGwgYmUgYWRkZWRcblx0XHRcdC8vIGV4aXQ6IG5vdCBuZWVkZWQgYmVjYXVzZSBhbHdheXMgb25seSBvbmUgcmVjdCBleGlzdHNcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTZXQgZGF0YSBhbmQgdXBkYXRlICQkLmV2ZW50UmVjdFxuXHRcdFx0Y29uc3QgbWF4RGF0YUNvdW50VGFyZ2V0ID0gJCQuZ2V0TWF4RGF0YUNvdW50VGFyZ2V0KCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0obWF4RGF0YUNvdW50VGFyZ2V0ID8gbWF4RGF0YUNvdW50VGFyZ2V0LnZhbHVlcyA6IFtdKTtcblx0XHRcdCQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5ldmVudFJlY3QuZGF0YShkID0+IGQpO1xuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRldmVudFJlY3RVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xuXG5cdFx0aWYgKCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICEkJC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHQkJC5iaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCk7XG5cdFx0fVxuXHR9LFxuXG5cdGJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IGdldEV2ZW50UmVjdCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0cmV0dXJuIGQzU2VsZWN0KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xuXHRcdH07XG5cblx0XHRjb25zdCBnZXRJbmRleCA9IGV2ZW50UmVjdCA9PiB7XG5cdFx0XHRsZXQgaW5kZXggPSBldmVudFJlY3QgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKSAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xuXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdGluZGV4ID0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xuXHRcdFx0aWYgKGlzTXVsdGlwbGVYKSB7XG5cdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZXZlbnRSZWN0KTtcblxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcblxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDpcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHQvLyBhY2NvcmRpbmcgJ2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaC5wcmV2ZW50RGVmYXVsdCcgb3B0aW9uXG5cdFx0Y29uc3QgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0O1xuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xuXHRcdGNvbnN0IHByZXZlbnRUaHJlc2hvbGQgPSAoIWlzTmFOKHByZXZlbnREZWZhdWx0KSAmJiBwcmV2ZW50RGVmYXVsdCkgfHwgbnVsbDtcblx0XHRsZXQgc3RhcnRQeDtcblxuXHRcdGNvbnN0IHByZXZlbnRFdmVudCA9IGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0Y29uc3QgY3VycmVudFhZID0gdG91Y2hbYGNsaWVudCR7Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwiWVwiIDogXCJYXCJ9YF07XG5cblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZXZlbnRUeXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZlbnRUaHJlc2hvbGQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRzdGFydFB4ID0gY3VycmVudFhZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQgfHwgc3RhcnRQeCA9PT0gdHJ1ZSB8fCAoXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHQvLyBvbmNlIHByZXZlbnRlZCwga2VlcCBwcmV2ZW50ZWQgZHVyaW5nIHdob2xlICd0b3VjaG1vdmUnIGNvbnRleHRcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXG5cdFx0JCQuc3ZnXG5cdFx0XHQub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdCB0b3VjaG1vdmUuZXZlbnRSZWN0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmV2ZW50RXZlbnQoZDNFdmVudCk7XG5cdFx0XHRcdFx0c2VsZWN0UmVjdCh0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQub24oXCJ0b3VjaGVuZC5ldmVudFJlY3RcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCAkJC5jYW5jZWxDbGljaykge1xuXHRcdFx0XHRcdFx0JCQuY2FuY2VsQ2xpY2sgJiYgKCQkLmNhbmNlbENsaWNrID0gZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGxvY2F0aW9uIGFuZCBzaXplIG9mIHRoZSBldmVudFJlY3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKi9cblx0dXBkYXRlRXZlbnRSZWN0KGV2ZW50UmVjdFVwZGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgeFNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cdFx0Y29uc3QgZXZlbnRSZWN0RGF0YSA9IGV2ZW50UmVjdFVwZGF0ZSB8fCAkJC5ldmVudFJlY3QuZGF0YSgpOy8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCB4O1xuXHRcdGxldCB5O1xuXHRcdGxldCB3O1xuXHRcdGxldCBoO1xuXG5cdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdC8vIFRPRE86IHJvdGF0ZWQgbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdHggPSAwO1xuXHRcdFx0eSA9IDA7XG5cdFx0XHR3ID0gJCQud2lkdGg7XG5cdFx0XHRoID0gJCQuaGVpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcmVjdFc7XG5cdFx0XHRsZXQgcmVjdFg7XG5cblx0XHRcdGlmICgkJC5pc0NhdGVnb3JpemVkKCkpIHtcblx0XHRcdFx0cmVjdFcgPSAkJC5nZXRFdmVudFJlY3RXaWR0aCgpO1xuXHRcdFx0XHRyZWN0WCA9IGQgPT4geFNjYWxlKGQueCkgLSAocmVjdFcgLyAyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBpbmRleCBmb3IgeCB0aGF0IGlzIHVzZWQgYnkgcHJldlggYW5kIG5leHRYXG5cdFx0XHRcdCQkLnVwZGF0ZVhzKCk7XG5cblx0XHRcdFx0Y29uc3QgZ2V0UHJldk5leHRYID0gZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcblx0XHRcdFx0XHRcdG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmVjdFcgPSBkID0+IHtcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IG1ha2UgdGhlIGV2ZW50UmVjdCBmdWxsIHdpZHRoIChvciBoZWlnaHQpXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHgubmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0eC5uZXh0ID0geFNjYWxlLmRvbWFpbigpWzFdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCgwLCAoeFNjYWxlKHgubmV4dCkgLSB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZWN0WCA9IGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XG5cdFx0XHRcdFx0Y29uc3QgdGhpc1ggPSAkJC5kYXRhLnhzW2QuaWRdW2QuaW5kZXhdO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IHBvc2l0aW9uIHRoZSBldmVudFJlY3QgYXQgMFxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuICh4U2NhbGUodGhpc1gpICsgeFNjYWxlKHgucHJldikpIC8gMjtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiByZWN0WDtcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyByZWN0WCA6IDA7XG5cdFx0XHR3ID0gaXNSb3RhdGVkID8gJCQud2lkdGggOiByZWN0Vztcblx0XHRcdGggPSBpc1JvdGF0ZWQgPyByZWN0VyA6ICQkLmhlaWdodDtcblx0XHR9XG5cblx0XHRldmVudFJlY3REYXRhLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIHgpXG5cdFx0XHQuYXR0cihcInlcIiwgeSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdylcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xuXHR9LFxuXG5cdHNlbGVjdFJlY3RGb3JTaW5nbGUoY29udGV4dCwgZXZlbnRSZWN0LCBpbmRleCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25FbmFibGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ7XG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25Hcm91cGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ7XG5cdFx0Y29uc3QgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XG5cdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gJCQuZ2V0QWxsVmFsdWVzT25JbmRleChpbmRleCk7XG5cblx0XHRpZiAoaXNUb29sdGlwR3JvdXBlZCkge1xuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KTtcblx0XHRcdCQkLnNob3dYR3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XG5cblx0XHRcdGlmICghaXNTZWxlY3Rpb25FbmFibGVkIHx8IGlzU2VsZWN0aW9uR3JvdXBlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCkge1xuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XG5cdFx0XHRcdFx0JCQuaGlkZVhHcmlkRm9jdXMoKTtcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xuXG5cdFx0XHRcdFx0IWlzU2VsZWN0aW9uR3JvdXBlZCAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhbGwoc2VsZWN0ZWQgPT4ge1xuXHRcdFx0XHRjb25zdCBkID0gc2VsZWN0ZWQuZGF0YSgpO1xuXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQgJiYgKGlzU2VsZWN0aW9uR3JvdXBlZCB8fCBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKSkge1xuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChkLCBjb250ZXh0KTtcblx0XHRcdFx0XHQkJC5zaG93WEdyaWRGb2N1cyhkKTtcblxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdFx0XHRcdHNlbGVjdGVkLmVhY2goZCA9PiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCwgZC5pZCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleCwgaWQsIHJlc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCAmJlxuXHRcdFx0JCQuZXhwYW5kQ2lyY2xlcyhpbmRleCwgaWQsIHJlc2V0KTtcblxuXHRcdCQkLmV4cGFuZEJhcnMoaW5kZXgsIGlkLCByZXNldCk7XG5cdH0sXG5cblx0c2VsZWN0UmVjdEZvck11bHRpcGxlWHMoY29udGV4dCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdC8vIGRvIG5vdGhpbmcgd2hlbiBkcmFnZ2luZ1xuXHRcdGlmICgkJC5kcmFnZ2luZyB8fCAkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKGNvbnRleHQpO1xuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcblxuXHRcdGlmICgkJC5tb3VzZW92ZXIgJiYgKCFjbG9zZXN0IHx8IGNsb3Nlc3QuaWQgIT09ICQkLm1vdXNlb3Zlci5pZCkpIHtcblx0XHRcdGNvbmZpZy5kYXRhX29ub3V0LmNhbGwoJCQuYXBpLCAkJC5tb3VzZW92ZXIpO1xuXHRcdFx0JCQubW91c2VvdmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICghY2xvc2VzdCkge1xuXHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2FtZVhEYXRhID0gKFxuXHRcdFx0JCQuaXNCdWJibGVUeXBlKGNsb3Nlc3QpIHx8ICQkLmlzU2NhdHRlclR5cGUoY2xvc2VzdCkgfHwgIWNvbmZpZy50b29sdGlwX2dyb3VwZWRcblx0XHQpID8gW2Nsb3Nlc3RdIDogJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XG5cblx0XHQvLyBzaG93IHRvb2x0aXAgd2hlbiBjdXJzb3IgaXMgY2xvc2UgdG8gc29tZSBwb2ludFxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZCA9PiAkJC5hZGROYW1lKGQpKTtcblxuXHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XG5cblx0XHQvLyBleHBhbmQgcG9pbnRzXG5cdFx0JCQuZXhwYW5kQ2lyY2xlc0JhcnMoY2xvc2VzdC5pbmRleCwgY2xvc2VzdC5pZCwgdHJ1ZSk7XG5cblx0XHQvLyBTaG93IHhncmlkIGZvY3VzIGxpbmVcblx0XHQkJC5zaG93WEdyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xuXG5cdFx0Ly8gU2hvdyBjdXJzb3IgYXMgcG9pbnRlciBpZiBwb2ludCBpcyBjbG9zZSB0byBtb3VzZSBwb3NpdGlvblxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcblx0XHRcdCQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XG5cblx0XHRcdGlmICghJCQubW91c2VvdmVyKSB7XG5cdFx0XHRcdGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCk7XG5cdFx0XHRcdCQkLm1vdXNlb3ZlciA9IGNsb3Nlc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbnNlbGVjdCBFdmVudFJlY3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1bnNlbGVjdFJlY3QoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xuXHRcdCQkLmhpZGVYR3JpZEZvY3VzKCk7XG5cdFx0JCQuaGlkZVRvb2x0aXAoKTtcblx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKGZhbHNlKTtcblx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcblx0XHQkJC51bmV4cGFuZEJhcnMoKTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBvcHRpb25zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0T3Zlck91dChpc092ZXIsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XG5cblx0XHQvLyBDYWxsIGV2ZW50IGhhbmRsZXJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XG5cblx0XHRcdGNvbmZpZy5jb2xvcl9vbm92ZXIgJiYgJCQuc2V0T3ZlckNvbG9yKGlzT3ZlciwgZCwgaXNBcmMpO1xuXG5cdFx0XHRpZiAoaXNBcmMpIHtcblx0XHRcdFx0Y2FsbGJhY2soZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc092ZXIgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoZCwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApLmVhY2goY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2FsbCBkYXRhLm9ub3Zlci9vdXQgY2FsbGJhY2sgZm9yIHRvdWNoIGV2ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxsT3Zlck91dEZvclRvdWNoKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FsbGVlID0gJCQuY2FsbE92ZXJPdXRGb3JUb3VjaDtcblx0XHRjb25zdCBsYXN0ID0gY2FsbGVlLmxhc3Q7XG5cblx0XHRpZiAoaXNPYmplY3QoZCkgJiYgbGFzdCA/IGQuaWQgIT09IGxhc3QuaWQgOiAoZCAhPT0gbGFzdCkpIHtcblx0XHRcdChsYXN0IHx8IGlzTnVtYmVyKGxhc3QpKSAmJiAkJC5zZXRPdmVyT3V0KGZhbHNlLCBsYXN0KTtcblx0XHRcdChkIHx8IGlzTnVtYmVyKGQpKSAmJiAkJC5zZXRPdmVyT3V0KHRydWUsIGQpO1xuXG5cdFx0XHRjYWxsZWUubGFzdCA9IGQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZHJhZ2dhYmxlIHNlbGVjdGlvbiBmdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldERyYWdnYWJsZVNlbGVjdGlvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUgJiYgJCQuZHJhZyA/XG5cdFx0XHRkM0RyYWcoKVxuXHRcdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkgeyAkJC5kcmFnKGQzTW91c2UodGhpcykpOyB9KVxuXHRcdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHsgJCQuZHJhZ3N0YXJ0KGQzTW91c2UodGhpcykpOyB9KVxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4geyAkJC5kcmFnZW5kKCk7IH0pIDogKCkgPT4ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBldmVudFJlY3QgZm9yIGVhY2ggZGF0YSBvbiB0aGUgeC1heGlzLlxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKi9cblx0Z2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWChldmVudFJlY3RFbnRlcikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gXCJwb2ludGVyXCIgOiBudWxsKVxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGhpcykoZCwgJCQpO1xuXHRcdFx0fSlcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcblxuXHRcdGlmICgkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xuXHRcdFx0cmVjdFxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXG5cdFx0XHRcdFx0aWYgKCQkLmRyYWdnaW5nIHx8ICQkLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dCh0cnVlLCBkLmluZGV4KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgaW5kZXggPSBkLmluZGV4O1xuXHRcdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH0tJHtpbmRleH1gKTtcblxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmXG5cdFx0XHRcdFx0XHQkJC5jb25maWcubGluZV9zdGVwX3R5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXG5cdFx0XHRcdFx0XHRkM01vdXNlKHRoaXMpWzBdIDwgJCQueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aW5kZXggLT0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCA9PT0gLTEgP1xuXHRcdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOiAkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHRoaXMsIGV2ZW50UmVjdCwgaW5kZXgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcblx0XHRcdFx0XHRpZiAoISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBkLmluZGV4KTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0Y2xpY2tIYW5kbGVyRm9yU2luZ2xlWChkLCBjdHgpIHtcblx0XHRjb25zdCAkJCA9IGN0eDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCAkJC5jYW5jZWxDbGljaykge1xuXHRcdFx0JCQuY2FuY2VsQ2xpY2sgJiYgKCQkLmNhbmNlbENsaWNrID0gZmFsc2UpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xuXG5cdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkMikge1xuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkMikpIHtcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBkMiwgaW5kZXgpO1xuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGQyLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBldmVudFJlY3QsXG5cdCAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqL1xuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgcmVjdCA9IGV2ZW50UmVjdEVudGVyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIDApXG5cdFx0XHQuYXR0cihcInlcIiwgMClcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5oZWlnaHQpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdClcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xuXHRcdFx0fSlcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcblxuXHRcdGlmICgkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xuXHRcdFx0cmVjdFxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXIgbW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKHRoaXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gY2hhcnQgaXMgZGVzdHJveWVkXG5cdFx0XHRcdFx0aWYgKCEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdGNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMoY3R4KSB7XG5cdFx0Y29uc3QgJCQgPSBjdHg7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZSh0aGlzKTtcblx0XHRjb25zdCBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XG5cblx0XHRpZiAoIWNsb3Nlc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCl9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7Y2xvc2VzdC5pbmRleH1gKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBjbG9zZXN0KSkge1xuXHRcdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgY2xvc2VzdCwgY2xvc2VzdC5pbmRleCk7XG5cdFx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmNhbGwoJCQuYXBpLCBjbG9zZXN0LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBtb3VzZSBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZXZlbnQgdHlwZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgZXZlbnRSZWN0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZSB2YWx1ZVxuXHQgKi9cblx0ZGlzcGF0Y2hFdmVudCh0eXBlLCBpbmRleCwgbW91c2UpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcblx0XHRjb25zdCBldmVudFJlY3QgPSAkJC5tYWluLnNlbGVjdChzZWxlY3Rvcikubm9kZSgpO1xuXHRcdGNvbnN0IHt3aWR0aCwgbGVmdCwgdG9wfSA9IGV2ZW50UmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoaXNNdWx0aXBsZVggPyAwIDogKHdpZHRoIC8gMikpO1xuXHRcdGNvbnN0IHkgPSB0b3AgKyAobW91c2UgPyBtb3VzZVsxXSA6IDApO1xuXHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdHNjcmVlblg6IHgsXG5cdFx0XHRzY3JlZW5ZOiB5LFxuXHRcdFx0Y2xpZW50WDogeCxcblx0XHRcdGNsaWVudFk6IHlcblx0XHR9O1xuXG5cdFx0ZW11bGF0ZUV2ZW50Wy9eKG1vdXNlfGNsaWNrKS8udGVzdCh0eXBlKSA/IFwibW91c2VcIiA6IFwidG91Y2hcIl0oZXZlbnRSZWN0LCB0eXBlLCBwYXJhbXMpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7aXNWYWx1ZSwgY2VpbDEwLCBleHRlbmQsIGNhcGl0YWxpemV9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldENvbnRhaW5lclNpemUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY3VycmVudFdpZHRoID0gJCQuZ2V0Q3VycmVudFdpZHRoKCk7XG5cdFx0JCQuY3VycmVudEhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcblx0fSxcblxuXHRnZXRDdXJyZW50V2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5zaXplX3dpZHRoIHx8ICQkLmdldFBhcmVudFdpZHRoKCk7XG5cdH0sXG5cblx0Z2V0Q3VycmVudEhlaWdodCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XG5cblx0XHRyZXR1cm4gaCA+IDAgPyBoIDogMzIwIC8gKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBBeGlzIHNpemUgYWNjb3JkaW5nIGl0cyBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZCB2YWx1ZSAtIHgsIHkgb3IgeTJcblx0ICogQHJldHVybiB7bnVtYmVyfSBzaXplIEF4aXMgc2l6ZSB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0QXhpc1NpemUoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRyZXR1cm4gKGlzUm90YXRlZCAmJiBpZCA9PT0gXCJ4XCIpIHx8ICghaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpKSA/XG5cdFx0XHQkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChpZCwgdHJ1ZSkgOlxuXHRcdFx0JCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nVG9wKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoO1xuXG5cdFx0bGV0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3RvcCkgP1xuXHRcdFx0Y29uZmlnLnBhZGRpbmdfdG9wIDogMDtcblxuXHRcdGlmICgkJC50aXRsZSAmJiAkJC50aXRsZS5ub2RlKCkpIHtcblx0XHRcdHBhZGRpbmcgKz0gJCQuZ2V0VGl0bGVQYWRkaW5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4ZXNMZW4gJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICogYXhlc0xlbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFkZGluZztcblx0fSxcblxuXHRnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XG5cdFx0Y29uc3QgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfYm90dG9tKSA/XG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xuXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXG5cdFx0KTtcblx0fSxcblxuXHRnZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBheGlzSWQgPSBpc1JvdGF0ZWQgPyBcInhcIiA6IFwieVwiO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoYXhpc0lkLCB3aXRob3V0UmVjb21wdXRlKTtcblx0XHRsZXQgcGFkZGluZztcblxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2xlZnQpKSB7XG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfbGVmdDtcblx0XHR9IGVsc2UgaWYgKGlzUm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyA9ICFjb25maWcuYXhpc194X3Nob3cgP1xuXHRcdFx0XHQxIDogTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKTtcblx0XHR9IGVsc2UgaWYgKCFjb25maWcuYXhpc195X3Nob3cgfHwgY29uZmlnLmF4aXNfeV9pbm5lcikgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxuXHRcdFx0cGFkZGluZyA9ICQkLmF4aXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDMwIDogMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkZWZhdWx0UGFkZGluZyA9IDEwO1xuXHRcdGNvbnN0IGxlZ2VuZFdpZHRoT25SaWdodCA9ICQkLmlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpICsgMjAgOiAwO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcblx0XHRjb25zdCBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpO1xuXHRcdGxldCBwYWRkaW5nO1xuXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfcmlnaHQpKSB7XG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfcmlnaHQgKyAxOyAvLyAxIGlzIG5lZWRlZCBub3QgdG8gaGlkZSB0aWNrIGxpbmVcblx0XHR9IGVsc2UgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZyArIGxlZ2VuZFdpZHRoT25SaWdodDtcblx0XHR9IGVsc2UgaWYgKCFjb25maWcuYXhpc195Ml9zaG93IHx8IGNvbmZpZy5heGlzX3kyX2lubmVyKSB7IC8vICYmICFjb25maWcuYXhpc19yb3RhdGVkXG5cdFx0XHRwYWRkaW5nID0gMiArIGxlZ2VuZFdpZHRoT25SaWdodCArXG5cdFx0XHRcdCgkJC5heGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKS5pc091dGVyID8gMjAgOiAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhcmVudCByZWN0IGVsZW1lbnQncyBzaXplXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgcHJvcGVydHkvYXR0cmlidXRlIG5hbWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFBhcmVudFJlY3RWYWx1ZShrZXkpIHtcblx0XHRjb25zdCBvZmZzZXROYW1lID0gYG9mZnNldCR7Y2FwaXRhbGl6ZShrZXkpfWA7XG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuc2VsZWN0Q2hhcnQubm9kZSgpO1xuXHRcdGxldCB2O1xuXG5cdFx0d2hpbGUgKCF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHYgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClba2V5XTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKG9mZnNldE5hbWUgaW4gcGFyZW50KSB7XG5cdFx0XHRcdFx0Ly8gSW4gSUUgaW4gY2VydGFpbiBjYXNlcyBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdFx0XHQvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxuXHRcdFx0XHRcdHYgPSBwYXJlbnRbb2Zmc2V0TmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKGtleSA9PT0gXCJ3aWR0aFwiKSB7XG5cdFx0XHQvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHVzZSBib2R5J3Mgb2Zmc2V0V2lkdGggaW5zdGVhZC5cblx0XHRcdGNvbnN0IGJvZHlXaWR0aCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG5cblx0XHRcdHYgPiBib2R5V2lkdGggJiYgKHYgPSBib2R5V2lkdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2O1xuXHR9LFxuXG5cdGdldFBhcmVudFdpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBhcmVudFJlY3RWYWx1ZShcIndpZHRoXCIpO1xuXHR9LFxuXG5cdGdldFBhcmVudEhlaWdodCgpIHtcblx0XHRjb25zdCBoID0gdGhpcy5zZWxlY3RDaGFydC5zdHlsZShcImhlaWdodFwiKTtcblxuXHRcdHJldHVybiBoLmluZGV4T2YoXCJweFwiKSA+IDAgPyBwYXJzZUludChoLCAxMCkgOiAwO1xuXHR9LFxuXG5cdGdldFN2Z0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaGFzTGVmdEF4aXNSZWN0ID0gY29uZmlnLmF4aXNfcm90YXRlZCB8fCAoIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIpO1xuXHRcdGNvbnN0IGxlZnRBeGlzQ2xhc3MgPSBjb25maWcuYXhpc19yb3RhdGVkID8gQ0xBU1MuYXhpc1ggOiBDTEFTUy5heGlzWTtcblx0XHRjb25zdCBsZWZ0QXhpcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtsZWZ0QXhpc0NsYXNzfWApLm5vZGUoKTtcblx0XHRjb25zdCBzdmdSZWN0ID0gbGVmdEF4aXMgJiYgaGFzTGVmdEF4aXNSZWN0ID8gbGVmdEF4aXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7cmlnaHQ6IDB9O1xuXHRcdGNvbnN0IGNoYXJ0UmVjdCA9ICQkLnNlbGVjdENoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XG5cdFx0Y29uc3Qgc3ZnTGVmdCA9IHN2Z1JlY3QucmlnaHQgLSBjaGFydFJlY3QubGVmdCAtXG5cdFx0XHQoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XG5cblx0XHRyZXR1cm4gc3ZnTGVmdCA+IDAgPyBzdmdMZWZ0IDogMDtcblx0fSxcblxuXHRnZXRBeGlzV2lkdGhCeUF4aXNJZChpZCwgd2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBwb3NpdGlvbiA9ICQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpO1xuXG5cdFx0cmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArXG5cdFx0XHQocG9zaXRpb24uaXNJbm5lciA/IDIwIDogNDApO1xuXHR9LFxuXG5cdGdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCBoID0gMzA7XG5cblx0XHRpZiAoaWQgPT09IFwieFwiICYmICFjb25maWcuYXhpc194X3Nob3cpIHtcblx0XHRcdHJldHVybiA4O1xuXHRcdH1cblxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgY29uZmlnLmF4aXNfeF9oZWlnaHQpIHtcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2hlaWdodDtcblx0XHR9XG5cblx0XHRpZiAoaWQgPT09IFwieVwiICYmICFjb25maWcuYXhpc195X3Nob3cpIHtcblx0XHRcdHJldHVybiBjb25maWcubGVnZW5kX3Nob3cgJiZcblx0XHRcdFx0ISQkLmlzTGVnZW5kUmlnaHQgJiZcblx0XHRcdFx0ISQkLmlzTGVnZW5kSW5zZXQgPyAxMCA6IDE7XG5cdFx0fVxuXG5cdFx0aWYgKGlkID09PSBcInkyXCIgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHtcblx0XHRcdHJldHVybiAkJC5yb3RhdGVkX3BhZGRpbmdfdG9wO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSB4L3kgYXhpcyBoZWlnaHQgd2hlbiB0aWNrIHJvdGF0ZWRcblx0XHRpZiAoKGlkID09PSBcInhcIiAmJiAhaXNSb3RhdGVkICYmIGNvbmZpZy5heGlzX3hfdGlja19yb3RhdGUpIHx8XG5cdFx0XHQoaWQgPT09IFwieVwiICYmIGlzUm90YXRlZCAmJiBjb25maWcuYXhpc195X3RpY2tfcm90YXRlKSkge1xuXHRcdFx0aCA9IDMwICtcblx0XHRcdFx0JCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQpICpcblx0XHRcdFx0TWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3JvdGF0ZWBdKSAvIDE4MCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGggK1xuXHRcdFx0KCQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpLmlzSW5uZXIgPyAwIDogMTApICtcblx0XHRcdChpZCA9PT0gXCJ5MlwiICYmICFpc1JvdGF0ZWQgPyAtMTAgOiAwKTtcblx0fSxcblxuXHRnZXRFdmVudFJlY3RXaWR0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy54QXhpcy50aWNrSW50ZXJ2YWwoKSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0Y3VydmVTdGVwQmVmb3JlIGFzIGQzQ3VydmVTdGVwQmVmb3JlLFxuXHRjdXJ2ZVN0ZXBBZnRlciBhcyBkM0N1cnZlU3RlcEFmdGVyLFxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcblx0Y3VydmVCYXNpc09wZW4gYXMgZDNDdXJ2ZUJhc2lzT3Blbixcblx0Y3VydmVCYXNpcyBhcyBkM0N1cnZlQmFzaXMsXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXG5cdGN1cnZlQ2FyZGluYWxDbG9zZWQgYXMgZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxuXHRjdXJ2ZUNhcmRpbmFsT3BlbiBhcyBkM0N1cnZlQ2FyZGluYWxPcGVuLFxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcblx0Y3VydmVDYXRtdWxsUm9tQ2xvc2VkIGFzIGQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxuXHRjdXJ2ZUNhdG11bGxSb21PcGVuIGFzIGQzQ3VydmVDYXRtdWxsUm9tT3Blbixcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxuXHRjdXJ2ZUxpbmVhckNsb3NlZCBhcyBkM0N1cnZlTGluZWFyQ2xvc2VkLFxuXHRjdXJ2ZUxpbmVhciBhcyBkM0N1cnZlTGluZWFyLFxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxuXHRjdXJ2ZU1vbm90b25lWSBhcyBkM0N1cnZlTW9ub3RvbmVZLFxuXHRjdXJ2ZU5hdHVyYWwgYXMgZDNDdXJ2ZU5hdHVyYWwsXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxufSBmcm9tIFwiZDMtc2hhcGVcIjtcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0U2hhcGVJbmRpY2VzKHR5cGVGaWx0ZXIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcblx0XHRsZXQgaSA9IDA7XG5cblx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0c1xuXHRcdFx0LmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpXG5cdFx0XHQuZm9yRWFjaChkID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGdyb3VwczsgKGdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwc1tqXSk7IGorKykge1xuXHRcdFx0XHRcdGlmIChncm91cHMuaW5kZXhPZihkLmlkKSA8IDApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSAwLCByb3c7IChyb3cgPSBncm91cHNba10pOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmIChyb3cgaW4gaW5kaWNlcykge1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzW2QuaWRdID0gaW5kaWNlc1tyb3ddO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoaW5kaWNlc1tkLmlkXSkpIHtcblx0XHRcdFx0XHRpbmRpY2VzW2QuaWRdID0gaSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGluZGljZXMuX19tYXhfXyA9IGkgLSAxO1xuXG5cdFx0cmV0dXJuIGluZGljZXM7XG5cdH0sXG5cblx0Z2V0U2hhcGVYKG9mZnNldCwgdGFyZ2V0c051bSwgaW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLnN1YlggOiAoJCQuem9vbVNjYWxlIHx8ICQkLngpO1xuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSAkJC5jb25maWcuYmFyX3BhZGRpbmc7XG5cdFx0Y29uc3Qgc3VtID0gKHAsIGMpID0+IHAgKyBjO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcblxuXHRcdHJldHVybiBkID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmRpY2VzID8gaW5kaWNlc1tkLmlkXSA6IDA7XG5cdFx0XHRsZXQgeCA9IDA7XG5cblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XG5cdFx0XHRcdGNvbnN0IHhQb3MgPSBzY2FsZShkLngpO1xuXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXG5cdFx0XHRcdFx0XHRvZmZzZXQudG90YWwuc2xpY2UoMCwgaW5kZXggKyAxKS5yZWR1Y2Uoc3VtKSAtXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHhQb3MgLSAoaXNOdW1iZXIob2Zmc2V0KSA/IG9mZnNldCA6IG9mZnNldC53aWR0aCkgKiAodGFyZ2V0c051bSAvIDIgLSBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0c051bSA9PT0gMikge1xuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRTaGFwZVkoaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xuXG5cdFx0cmV0dXJuIGQgPT4gKGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpKShcblx0XHRcdGlzU3RhY2tOb3JtYWxpemVkID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCBkLCB0cnVlKSA6IGQudmFsdWVcblx0XHQpO1xuXHR9LFxuXG5cdGdldFNoYXBlT2Zmc2V0KHR5cGVGaWx0ZXIsIGluZGljZXMsIGlzU3ViKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkpO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9IHRhcmdldHMubWFwKHQgPT4gdC5pZCk7XG5cblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xuXHRcdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZShkLmlkKSA6ICQkLmdldFlTY2FsZShkLmlkKTtcblx0XHRcdGNvbnN0IHkwID0gc2NhbGUoMCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0geTA7XG5cdFx0XHRsZXQgaSA9IGlkeDtcblxuXHRcdFx0dGFyZ2V0c1xuXHRcdFx0XHQuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0XHRjb25zdCByb3dWYWx1ZXMgPSAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuY29udmVydFZhbHVlc1RvU3RlcCh0LnZhbHVlcykgOiB0LnZhbHVlcztcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSByb3dWYWx1ZXMubWFwKHYgPT4gKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIHYsIHRydWUpIDogdi52YWx1ZSkpO1xuXG5cdFx0XHRcdFx0aWYgKHQuaWQgPT09IGQuaWQgfHwgaW5kaWNlc1t0LmlkXSAhPT0gaW5kaWNlc1tkLmlkXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0YXJnZXRJZHMuaW5kZXhPZih0LmlkKSA8IHRhcmdldElkcy5pbmRleE9mKGQuaWQpKSB7XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgeCB2YWx1ZXMgbGluZSB1cFxuXHRcdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJvd1ZhbHVlc1tpXSkgfHwgK3Jvd1ZhbHVlc1tpXS54ICE9PSArZC54KSB7IC8vIFwiK1wiIGZvciB0aW1lc2VyaWVzXG5cdFx0XHRcdFx0XHRcdC8vIGlmIG5vdCwgdHJ5IHRvIGZpbmQgdGhlIHZhbHVlIHRoYXQgZG9lcyBsaW5lIHVwXG5cdFx0XHRcdFx0XHRcdGkgPSAtMTtcblxuXHRcdFx0XHRcdFx0XHRyb3dWYWx1ZXMuZm9yRWFjaCgodiwgaikgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHgxID0gdi54LmNvbnN0cnVjdG9yID09PSBEYXRlID8gK3YueCA6IHYueDtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB4MiA9IGQueC5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/ICtkLnggOiBkLng7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoeDEgPT09IHgyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpID0gajtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoaSBpbiByb3dWYWx1ZXMgJiYgcm93VmFsdWVzW2ldLnZhbHVlICogZC52YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBzY2FsZSh2YWx1ZXNbaV0pIC0geTA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9O1xuXHR9LFxuXG5cdGlzV2l0aGluU2hhcGUodGhhdCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoYXQpO1xuXHRcdGxldCBpc1dpdGhpbjtcblxuXHRcdGlmICghJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpIHtcblx0XHRcdGlzV2l0aGluID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xuXHRcdFx0aXNXaXRoaW4gPSAkJC5pc1N0ZXBUeXBlKGQpID9cblx0XHRcdFx0JCQuaXNXaXRoaW5TdGVwKHRoYXQsICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKSkgOlxuXHRcdFx0XHQkJC5pc1dpdGhpbkNpcmNsZSh0aGF0LCAkJC5pc0J1YmJsZVR5cGUoZCkgPyAkJC5wb2ludFNlbGVjdFIoZCkgKiAxLjUgOiAwKTtcblx0XHR9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XG5cdFx0XHRpc1dpdGhpbiA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSA/ICQkLmlzV2l0aGluQmFyKHRoYXQpIDogdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXNXaXRoaW47XG5cdH0sXG5cblx0Z2V0SW50ZXJwb2xhdGUoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuZ2V0SW50ZXJwb2xhdGVUeXBlKGQpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdFwiYmFzaXNcIjogZDNDdXJ2ZUJhc2lzLFxuXHRcdFx0XCJiYXNpcy1jbG9zZWRcIjogZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxuXHRcdFx0XCJiYXNpcy1vcGVuXCI6IGQzQ3VydmVCYXNpc09wZW4sXG5cdFx0XHRcImJ1bmRsZVwiOiBkM0N1cnZlQnVuZGxlLFxuXHRcdFx0XCJjYXJkaW5hbFwiOiBkM0N1cnZlQ2FyZGluYWwsXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiOiBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIjogZDNDdXJ2ZUNhcmRpbmFsT3Blbixcblx0XHRcdFwiY2F0bXVsbC1yb21cIjogZDNDdXJ2ZUNhdG11bGxSb20sXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiOiBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiOiBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXG5cdFx0XHRcIm1vbm90b25lLXhcIjogZDNDdXJ2ZU1vbm90b25lWCxcblx0XHRcdFwibW9ub3RvbmUteVwiOiBkM0N1cnZlTW9ub3RvbmVZLFxuXHRcdFx0XCJuYXR1cmFsXCI6IGQzQ3VydmVOYXR1cmFsLFxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCI6IGQzQ3VydmVMaW5lYXJDbG9zZWQsXG5cdFx0XHRcImxpbmVhclwiOiBkM0N1cnZlTGluZWFyLFxuXHRcdFx0XCJzdGVwXCI6IGQzQ3VydmVTdGVwLFxuXHRcdFx0XCJzdGVwLWFmdGVyXCI6IGQzQ3VydmVTdGVwQWZ0ZXIsXG5cdFx0XHRcInN0ZXAtYmVmb3JlXCI6IGQzQ3VydmVTdGVwQmVmb3JlXG5cdFx0fVtpbnRlcnBvbGF0aW9uXTtcblx0fSxcblxuXHRnZXRJbnRlcnBvbGF0ZVR5cGUoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0eXBlID0gJCQuY29uZmlnLnNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGU7XG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmlzSW50ZXJwb2xhdGlvblR5cGUodHlwZSkgPyB0eXBlIDogXCJjYXJkaW5hbFwiO1xuXG5cdFx0cmV0dXJuICQkLmlzU3BsaW5lVHlwZShkKSA/XG5cdFx0XHRpbnRlcnBvbGF0aW9uIDogKFxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cblx0XHRcdFx0XHQkJC5jb25maWcubGluZV9zdGVwX3R5cGUgOiBcImxpbmVhclwiXG5cdFx0XHQpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0ZXZlbnQgYXMgZDNFdmVudFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1xuXHRhcmMgYXMgZDNBcmMsXG5cdHBpZSBhcyBkM1BpZVxufSBmcm9tIFwiZDMtc2hhcGVcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgZDNJbnRlcnBvbGF0ZX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UGllKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcblxuXHRcdGNvbnN0IHBhZEFuZ2xlID0gJCQuaGFzVHlwZShcInBpZVwiKSAmJiBwYWRkaW5nID9cblx0XHRcdHBhZGRpbmcgKiAwLjAxIDogY29uZmlnW2Ake2NvbmZpZy5kYXRhX3R5cGV9X3BhZEFuZ2xlYF0gP1xuXHRcdFx0XHRjb25maWdbYCR7Y29uZmlnLmRhdGFfdHlwZX1fcGFkQW5nbGVgXSA6IDA7XG5cblx0XHQkJC5waWUgPSBkM1BpZSgpXG5cdFx0XHQucGFkQW5nbGUocGFkQW5nbGUpXG5cdFx0XHQuc29ydFZhbHVlcyhcblx0XHRcdFx0JCQuaXNPcmRlckFzYygpIHx8ICQkLmlzT3JkZXJEZXNjKCkgP1xuXHRcdFx0XHRcdChhLCBiKSA9PiAoJCQuaXNPcmRlckFzYygpID8gYSAtIGIgOiBiIC0gYSkgOiBudWxsXG5cdFx0XHQpXG5cdFx0XHQudmFsdWUoZCA9PiBkLnZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSk7XG5cdH0sXG5cblx0dXBkYXRlUmFkaXVzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnBpZV9pbm5lclJhZGl1cztcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nO1xuXHRcdGNvbnN0IHcgPSBjb25maWcuZ2F1Z2Vfd2lkdGggfHwgY29uZmlnLmRvbnV0X3dpZHRoO1xuXG5cdFx0JCQucmFkaXVzRXhwYW5kZWQgPSBNYXRoLm1pbigkJC5hcmNXaWR0aCwgJCQuYXJjSGVpZ2h0KSAvIDI7XG5cdFx0JCQucmFkaXVzID0gJCQucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xuXHRcdCQkLmlubmVyUmFkaXVzUmF0aW8gPSB3ID8gKCQkLnJhZGl1cyAtIHcpIC8gJCQucmFkaXVzIDogMC42O1xuXG5cdFx0Y29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgfHwgKFxuXHRcdFx0cGFkZGluZyA/IHBhZGRpbmcgKiAoJCQuaW5uZXJSYWRpdXNSYXRpbyArIDAuMSkgOiAwXG5cdFx0KTtcblxuXHRcdC8vIE5PVEU6IGlubmVyUmFkaXVzIGNhbiBiZSBhbiBvYmplY3QgYnkgdXNlciBzZXR0aW5nLCBvbmx5IGZvciAncGllJyB0eXBlXG5cdFx0JCQuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cblx0XHRcdCQkLnJhZGl1cyAqICQkLmlubmVyUmFkaXVzUmF0aW8gOiBpbm5lclJhZGl1cztcblx0fSxcblxuXHRnZXRJbm5lclJhZGl1cyhkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCByYWRpdXMgPSAkJC5pbm5lclJhZGl1cztcblxuXHRcdGlmICghaXNOdW1iZXIocmFkaXVzKSAmJiBkKSB7XG5cdFx0XHRyYWRpdXMgPSByYWRpdXNbZC5kYXRhLmlkXSB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiByYWRpdXM7XG5cdH0sXG5cblx0dXBkYXRlQXJjKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpO1xuXHRcdCQkLnN2Z0FyY0V4cGFuZGVkID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoKTtcblx0XHQkJC5zdmdBcmNFeHBhbmRlZFN1YiA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKDAuOTgpO1xuXHR9LFxuXG5cdHVwZGF0ZUFuZ2xlKGRWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IHBpZSA9ICQkLnBpZTtcblx0XHRsZXQgZCA9IGRWYWx1ZTtcblx0XHRsZXQgZm91bmQgPSBmYWxzZTtcblxuXHRcdGlmICghY29uZmlnKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkpIHtcblx0XHRcdGNvbnN0IHRvdGFsU3VtID0gJCQuZ2V0VG90YWxEYXRhU3VtKCk7XG5cblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gdG90YWxTdW0sIG1ha2UgdG90YWxTdW0gdG8gbWF4IHZhbHVlXG5cdFx0XHRpZiAodG90YWxTdW0gPiBjb25maWcuZ2F1Z2VfbWF4KSB7XG5cdFx0XHRcdGNvbmZpZy5nYXVnZV9tYXggPSB0b3RhbFN1bTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gTWF0aC5QSSAqIChjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDIgOiAxKTtcblx0XHRcdGNvbnN0IGdTdGFydCA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXHRcdFx0Y29uc3QgZ0VuZCA9IHJhZGl1cyAqICh0b3RhbFN1bSAvIChjb25maWcuZ2F1Z2VfbWF4IC0gY29uZmlnLmdhdWdlX21pbikpO1xuXG5cdFx0XHRwaWUgPSAkJC5waWVcblx0XHRcdFx0LnN0YXJ0QW5nbGUoZ1N0YXJ0KVxuXHRcdFx0XHQuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XG5cdFx0fVxuXG5cdFx0cGllKCQkLmZpbHRlclRhcmdldHNUb1Nob3coKSkuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGlmICghZm91bmQgJiYgdC5kYXRhLmlkID09PSBkLmRhdGEuaWQpIHtcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRkID0gdDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChpc05hTihkLnN0YXJ0QW5nbGUpKSB7XG5cdFx0XHRkLnN0YXJ0QW5nbGUgPSAwO1xuXHRcdH1cblxuXHRcdGlmIChpc05hTihkLmVuZEFuZ2xlKSkge1xuXHRcdFx0ZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm91bmQgPyBkIDogbnVsbDtcblx0fSxcblxuXHRnZXRTdmdBcmMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlyID0gJCQuZ2V0SW5uZXJSYWRpdXMoKTtcblx0XHRsZXQgYXJjID0gZDNBcmMoKVxuXHRcdFx0Lm91dGVyUmFkaXVzKCQkLnJhZGl1cylcblx0XHRcdC5pbm5lclJhZGl1cyhpc051bWJlcihpcikgPyBpciA6IDApO1xuXG5cdFx0Y29uc3QgbmV3QXJjID0gKGQsIHdpdGhvdXRVcGRhdGUpID0+IHtcblx0XHRcdGxldCBwYXRoID0gXCJNIDAgMFwiO1xuXG5cdFx0XHRpZiAoZC52YWx1ZSB8fCBkLmRhdGEpIHtcblx0XHRcdFx0aWYgKCFpc051bWJlcihpcikpIHtcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXG5cdFx0XHRcdGlmICh3aXRob3V0VXBkYXRlKSB7XG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcblx0XHRcdFx0fSBlbHNlIGlmICh1cGRhdGVkKSB7XG5cdFx0XHRcdFx0cGF0aCA9IGFyYyh1cGRhdGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9O1xuXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cblx0XHRuZXdBcmMuY2VudHJvaWQgPSBhcmMuY2VudHJvaWQ7XG5cblx0XHRyZXR1cm4gbmV3QXJjO1xuXHR9LFxuXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYXJjID0gZDNBcmMoKVxuXHRcdFx0Lm91dGVyUmFkaXVzKCQkLnJhZGl1c0V4cGFuZGVkICogKHJhdGUgfHwgMSkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblxuXHRcdFx0cmV0dXJuIHVwZGF0ZWQgPyBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpKHVwZGF0ZWQpIDogXCJNIDAgMFwiO1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJjKGQsIHdpdGhvdXRVcGRhdGUsIGZvcmNlKSB7XG5cdFx0cmV0dXJuIGZvcmNlIHx8IHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyB0aGlzLnN2Z0FyYyhkLCB3aXRob3V0VXBkYXRlKSA6IFwiTSAwIDBcIjtcblx0fSxcblxuXHR0cmFuc2Zvcm1Gb3JBcmNMYWJlbChkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0bGV0IHRyYW5zbGF0ZSA9IFwiXCI7XG5cblx0XHRpZiAodXBkYXRlZCAmJiAoISQkLmhhc1R5cGUoXCJnYXVnZVwiKSB8fCAkJC5oYXNNdWx0aVRhcmdldHMoKSkpIHtcblx0XHRcdGNvbnN0IGMgPSB0aGlzLnN2Z0FyYy5jZW50cm9pZCh1cGRhdGVkKTtcblx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xuXHRcdFx0Y29uc3QgeSA9IGlzTmFOKGNbMV0pID8gMCA6IGNbMV07XG5cdFx0XHRjb25zdCBoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG5cdFx0XHRsZXQgcmF0aW8gPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbykgfHxcblx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XG5cblx0XHRcdGlmIChyYXRpbykge1xuXHRcdFx0XHRyYXRpbyA9IGlzRnVuY3Rpb24ocmF0aW8pID8gcmF0aW8oZCwgJCQucmFkaXVzLCBoKSA6IHJhdGlvO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmF0aW8gPSAkJC5yYWRpdXMgJiZcblx0XHRcdFx0XHQoaCA/ICgzNiAvICQkLnJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvICQkLnJhZGl1cyA6IDAuOCkgKiAkJC5yYWRpdXMgLyBoIDogMCk7XG5cdFx0XHR9XG5cblx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cmFuc2xhdGU7XG5cdH0sXG5cblx0Y29udmVydFRvQXJjRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkTmFtZSh7XG5cdFx0XHRpZDogZC5kYXRhLmlkLFxuXHRcdFx0dmFsdWU6IGQudmFsdWUsXG5cdFx0XHRyYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcblx0XHRcdGluZGV4OiBkLmluZGV4LFxuXHRcdH0pO1xuXHR9LFxuXG5cdHRleHRGb3JBcmNMYWJlbChzZWxlY3Rpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuc2hvdWxkU2hvd0FyY0xhYmVsKCkpIHtcblx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdXBkYXRlZCA/IHVwZGF0ZWQudmFsdWUgOiBudWxsO1xuXHRcdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldFJhdGlvKFwiYXJjXCIsIHVwZGF0ZWQpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YS5pZDtcblx0XHRcdFx0Y29uc3QgaXNVbmRlclRocmVzaG9sZCA9ICEoXG5cdFx0XHRcdFx0ISQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhJCQubWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbylcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoaXNVbmRlclRocmVzaG9sZCkge1xuXHRcdFx0XHRcdGNvbnN0IHRleHQgPSAoXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxuXHRcdFx0XHRcdCkodmFsdWUsIHJhdGlvLCBpZCkudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRcdHNldFRleHRWYWx1ZShub2RlLCB0ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRleHRGb3JHYXVnZU1pbk1heCh2YWx1ZSwgaXNNYXgpIHtcblx0XHRjb25zdCBmb3JtYXQgPSB0aGlzLmdldEdhdWdlTGFiZWxFeHRlbnRzKCk7XG5cblx0XHRyZXR1cm4gZm9ybWF0ID8gZm9ybWF0KHZhbHVlLCBpc01heCkgOiB2YWx1ZTtcblx0fSxcblxuXHRleHBhbmRBcmModGFyZ2V0SWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Ly8gTUVNTzogYXZvaWQgdG8gY2FuY2VsIHRyYW5zaXRpb25cblx0XHRpZiAoJCQudHJhbnNpdGluZykge1xuXHRcdFx0Y29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRcdGlmICghJCQudHJhbnNpdGluZykge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXG5cdFx0XHRcdFx0JCQubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbUZvY3VzZWR9YCkuc2l6ZSgpID4gMCAmJlxuXHRcdFx0XHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDEwKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyhuZXdUYXJnZXRJZHMsIGAuJHtDTEFTUy5jaGFydEFyY31gKSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0aWYgKCEkJC5zaG91bGRFeHBhbmQoZC5kYXRhLmlkKSB8fCBkLnZhbHVlID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZXhwYW5kRHVyYXRpb24gPSAkJC5leHBhbmREdXJhdGlvbihkLmRhdGEuaWQpO1xuXG5cdFx0XHRcdGQzU2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcInBhdGhcIilcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uKVxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmNFeHBhbmRlZClcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uICogMilcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWRTdWIpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0dW5leHBhbmRBcmModGFyZ2V0SWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCQkLnRyYW5zaXRpbmcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXG5cdFx0XHQuc2VsZWN0QWxsKFwicGF0aFwiKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGQgPT4gJCQuZXhwYW5kRHVyYXRpb24oZC5kYXRhLmlkKSlcblx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmMpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdEFsbChgJHtDTEFTUy5hcmN9YClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXHR9LFxuXG5cdGV4cGFuZER1cmF0aW9uKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRsZXQgdHlwZTtcblxuXHRcdGlmICgkJC5pc0RvbnV0VHlwZShpZCkpIHtcblx0XHRcdHR5cGUgPSBcImRvbnV0XCI7XG5cdFx0fSBlbHNlIGlmICgkJC5pc0dhdWdlVHlwZShpZCkpIHtcblx0XHRcdHR5cGUgPSBcImdhdWdlXCI7XG5cdFx0fSBlbHNlIGlmICgkJC5pc1BpZVR5cGUoaWQpKSB7XG5cdFx0XHR0eXBlID0gXCJwaWVcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZSA/IGNvbmZpZ1tgJHt0eXBlfV9leHBhbmRfZHVyYXRpb25gXSA6IDUwO1xuXHR9LFxuXG5cdHNob3VsZEV4cGFuZChpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gKCQkLmlzRG9udXRUeXBlKGlkKSAmJiBjb25maWcuZG9udXRfZXhwYW5kKSB8fFxuXHRcdFx0KCQkLmlzR2F1Z2VUeXBlKGlkKSAmJiBjb25maWcuZ2F1Z2VfZXhwYW5kKSB8fFxuXHRcdFx0KCQkLmlzUGllVHlwZShpZCkgJiYgY29uZmlnLnBpZV9leHBhbmQpO1xuXHR9LFxuXG5cdHNob3VsZFNob3dBcmNMYWJlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIFtcInBpZVwiLCBcImRvbnV0XCIsIFwiZ2F1Z2VcIl1cblx0XHRcdC5zb21lKHYgPT4gJCQuaGFzVHlwZSh2KSAmJiBjb25maWdbYCR7dn1fbGFiZWxfc2hvd2BdKTtcblx0fSxcblxuXHRtZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0aHJlc2hvbGQgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgPyBjb25maWcuZG9udXRfbGFiZWxfdGhyZXNob2xkIDogY29uZmlnLnBpZV9sYWJlbF90aHJlc2hvbGQ7XG5cblx0XHRyZXR1cm4gcmF0aW8gPj0gdGhyZXNob2xkO1xuXHR9LFxuXG5cdGdldEFyY0xhYmVsRm9ybWF0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IGZvcm1hdCA9IGNvbmZpZy5waWVfbGFiZWxfZm9ybWF0O1xuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xuXHRcdFx0Zm9ybWF0ID0gY29uZmlnLmdhdWdlX2xhYmVsX2Zvcm1hdDtcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJkb251dFwiKSkge1xuXHRcdFx0Zm9ybWF0ID0gY29uZmlnLmRvbnV0X2xhYmVsX2Zvcm1hdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm9ybWF0O1xuXHR9LFxuXG5cdGdldEdhdWdlTGFiZWxFeHRlbnRzKCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5nYXVnZV9sYWJlbF9leHRlbnRzO1xuXHR9LFxuXG5cdGdldEFyY1RpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0eXBlID0gKCQkLmhhc1R5cGUoXCJkb251dFwiKSAmJiBcImRvbnV0XCIpIHx8ICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgXCJnYXVnZVwiKTtcblxuXHRcdHJldHVybiB0eXBlID8gJCQuY29uZmlnW2Ake3R5cGV9X3RpdGxlYF0gOiBcIlwiO1xuXHR9LFxuXG5cdHVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcblx0XHRjb25zdCBjbGFzc0NoYXJ0QXJjID0gJCQuY2xhc3NDaGFydEFyYy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0FyY3MgPSAkJC5jbGFzc0FyY3MuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgbWFpblBpZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3N9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXG5cdFx0XHQuZGF0YSgkJC5waWUodGFyZ2V0cykpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydEFyYyhkKSArIGNsYXNzRm9jdXMoZC5kYXRhKSk7XG5cblx0XHRjb25zdCBtYWluUGllRW50ZXIgPSBtYWluUGllVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QXJjKTtcblxuXHRcdG1haW5QaWVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJjcylcblx0XHRcdC5tZXJnZShtYWluUGllVXBkYXRlKTtcblxuXHRcdG1haW5QaWVFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQuYXR0cihcImR5XCIsIGhhc0dhdWdlICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXHRcdC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uLCBidXQgbm90IGJhZCB0byB1cGRhdGUgY29sb3IgaW4gcmVkcmF3XG5cdFx0Ly8gbWFpblBpZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XG5cdH0sXG5cblx0aW5pdEFyYygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5hcmNzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3MpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpO1xuXG5cdFx0JCQuc2V0QXJjVGl0bGUoKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGFyYyB0aXRsZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRBcmNUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdGl0bGUgPSAkJC5nZXRBcmNUaXRsZSgpO1xuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuXG5cdFx0aWYgKHRpdGxlKSB7XG5cdFx0XHRjb25zdCB0ZXh0ID0gJCQuYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1NbaGFzR2F1Z2UgPyBcImNoYXJ0QXJjc0dhdWdlVGl0bGVcIiA6IFwiY2hhcnRBcmNzVGl0bGVcIl0pXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuXG5cdFx0XHRpZiAoaGFzR2F1Z2UpIHtcblx0XHRcdFx0dGV4dFxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItMC4zZW1cIilcblx0XHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgXCIyN3B4XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRUZXh0VmFsdWUodGV4dCwgdGl0bGUsIGhhc0dhdWdlID8gdW5kZWZpbmVkIDogWy0xLjMsIDEuM10pO1xuXHRcdH1cblx0fSxcblxuXHRyZWRyYXdBcmMoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCwgd2l0aFRyYW5zZm9ybSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgaGFzSW50ZXJhY3Rpb24gPSBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZDtcblxuXHRcdGxldCBtYWluQXJjID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY3N9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY31gKVxuXHRcdFx0LmRhdGEoJCQuYXJjRGF0YS5iaW5kKCQkKSk7XG5cblx0XHRtYWluQXJjLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0bWFpbkFyYyA9IG1haW5BcmMuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQuZGF0YSkpXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiBoYXNJbnRlcmFjdGlvbiAmJiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRpZiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xuXHRcdFx0XHRcdGQuc3RhcnRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXHRcdFx0XHRcdGQuZW5kQW5nbGUgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBkO1xuXHRcdFx0fSlcblx0XHRcdC5tZXJnZShtYWluQXJjKTtcblxuXHRcdG1haW5BcmNcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gKCEkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDApXCIgOiBcIlwiKSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRyZXR1cm4gZCA9PT0gdGhpcy5fY3VycmVudCA/IFwiMFwiIDogXCIxXCI7XG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goKCkgPT4ge1xuXHRcdFx0XHQkJC50cmFuc2l0aW5nID0gdHJ1ZTtcblx0XHRcdH0pXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblxuXHRcdFx0XHRpZiAoIXVwZGF0ZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4gXCJNIDAgMFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGUgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudC5lbmRBbmdsZSA9IHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCB1cGRhdGVkKTtcblxuXHRcdFx0XHR0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZWQgPSBpbnRlcnBvbGF0ZSh0KTtcblxuXHRcdFx0XHRcdGludGVycG9sYXRlZC5kYXRhID0gZC5kYXRhOyAvLyBkYXRhLmlkIHdpbGwgYmUgdXBkYXRlZCBieSBpbnRlcnBvcmF0b3Jcblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGludGVycG9sYXRlZCwgdHJ1ZSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMSlcIiA6IFwiXCIpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gKCQkLmxldmVsQ29sb3IgP1xuXHRcdFx0XHQkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhLmlkKSlcblx0XHRcdClcblx0XHRcdC8vIFdoZXJlIGdhdWdlIHJlYWRpbmcgY29sb3Igd291bGQgcmVjZWl2ZSBjdXN0b21pemF0aW9uLlxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgKCkgPT4ge1xuXHRcdFx0XHQkJC50cmFuc2l0aW5nID0gZmFsc2U7XG5cdFx0XHR9KTtcblxuXHRcdC8vIGJpbmQgYXJjIGV2ZW50c1xuXHRcdGhhc0ludGVyYWN0aW9uICYmICQkLmJpbmRBcmNFdmVudChtYWluQXJjKTtcblxuXHRcdCQkLnJlZHJhd0FyY1RleHQoZHVyYXRpb24pO1xuXHR9LFxuXG5cdGJpbmRBcmNFdmVudChhcmMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuXHRcdGNvbnN0IGlzTW91c2UgPSAkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcblxuXHRcdGZ1bmN0aW9uIHNlbGVjdEFyYyhfdGhpcywgYXJjRGF0YSwgaWQpIHtcblx0XHRcdC8vIHRyYW5zaXRpb25zXG5cdFx0XHQkJC5leHBhbmRBcmMoaWQpO1xuXHRcdFx0JCQuYXBpLmZvY3VzKGlkKTtcblx0XHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKGlkLCB0cnVlKTtcblx0XHRcdCQkLnNob3dUb29sdGlwKFthcmNEYXRhXSwgX3RoaXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuc2VsZWN0QXJjKGFyY0RhdGEpIHtcblx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHQkJC51bmV4cGFuZEFyYyhpZCk7XG5cdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XG5cdFx0XHQkJC5yZXZlcnRMZWdlbmQoKTtcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0YXJjXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRcdFx0bGV0IGFyY0RhdGE7XG5cblx0XHRcdFx0aWYgKHVwZGF0ZWQpIHtcblx0XHRcdFx0XHRhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcblxuXHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlICYmICQkLnRvZ2dsZVNoYXBlKHRoaXMsIGFyY0RhdGEsIGkpO1xuXHRcdFx0XHRcdCQkLmNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGFyY0RhdGEsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdC8vIG1vdXNlIGV2ZW50c1xuXHRcdGlmIChpc01vdXNlKSB7XG5cdFx0XHRhcmNcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRpZiAoJCQudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcblx0XHRcdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dCh0cnVlLCBhcmNEYXRhKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XG5cdFx0XHRcdFx0aWYgKCQkLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XG5cblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpO1xuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGFyY0RhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCB0aGlzKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gdG91Y2ggZXZlbnRzXG5cdFx0aWYgKGlzVG91Y2ggJiYgJCQuaGFzQXJjVHlwZSgpICYmICEkJC5yYWRhcnMpIHtcblx0XHRcdGNvbnN0IGdldEV2ZW50QXJjID0gKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XG5cblx0XHRcdFx0cmV0dXJuIGV2ZW50QXJjO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoJCQudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBldmVudEFyYyA9IGdldEV2ZW50QXJjKCk7XG5cdFx0XHRcdGNvbnN0IGRhdHVtID0gZXZlbnRBcmMuZGF0dW0oKTtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IChkYXR1bSAmJiBkYXR1bS5kYXRhICYmIGRhdHVtLmRhdGEuaWQpID8gJCQudXBkYXRlQW5nbGUoZGF0dW0pIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaChhcmNEYXRhKTtcblxuXHRcdFx0XHRpc1VuZGVmaW5lZChpZCkgP1xuXHRcdFx0XHRcdHVuc2VsZWN0QXJjKCkgOiBzZWxlY3RBcmModGhpcywgYXJjRGF0YSwgaWQpO1xuXHRcdFx0fTtcblxuXHRcdFx0JCQuc3ZnXG5cdFx0XHRcdC5vbihcInRvdWNoc3RhcnRcIiwgaGFuZGxlcilcblx0XHRcdFx0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZXIpO1xuXHRcdH1cblx0fSxcblxuXHRyZWRyYXdBcmNUZXh0KGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcblxuXHRcdGNvbnN0IHRleHQgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcblx0XHRcdC5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpID8gQ0xBU1MuZ2F1Z2VWYWx1ZSA6IG51bGwpKVxuXHRcdFx0LmNhbGwoJCQudGV4dEZvckFyY0xhYmVsLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgZCA9PiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiAhJCQuaGFzTXVsdGlUYXJnZXRzKCkgPyBgJHtNYXRoLnJvdW5kKCQkLnJhZGl1cyAvIDUpfXB4YCA6IFwiXCIpKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+ICgkJC5pc1RhcmdldFRvU2hvdyhkLmRhdGEuaWQpICYmICQkLmlzQXJjVHlwZShkLmRhdGEpID8gXCIxXCIgOiBcIjBcIikpO1xuXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc1RpdGxlfWApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCBoYXNHYXVnZSA/IFwiMVwiIDogXCIwXCIpO1xuXG5cdFx0aWYgKGhhc0dhdWdlKSB7XG5cdFx0XHRjb25zdCBpc0Z1bGxDaXJjbGUgPSBjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcblx0XHRcdGNvbnN0IGVuZEFuZ2xlID0gKGlzRnVsbENpcmNsZSA/IC00IDogLTEpICogY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XG5cblx0XHRcdGlzRnVsbENpcmNsZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBgJHtNYXRoLnJvdW5kKCQkLnJhZGl1cyAvIDE0KX1gKTtcblxuXHRcdFx0JCQuYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmR9YClcblx0XHRcdFx0LmF0dHIoXCJkXCIsICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBkID0ge1xuXHRcdFx0XHRcdFx0ZGF0YTogW3t2YWx1ZTogY29uZmlnLmdhdWdlX21heH1dLFxuXHRcdFx0XHRcdFx0c3RhcnRBbmdsZTogY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGUsXG5cdFx0XHRcdFx0XHRlbmRBbmdsZTogZW5kQW5nbGVcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdCQkLmFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZVVuaXR9YClcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi43NWVtXCIpXG5cdFx0XHRcdC50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gY29uZmlnLmdhdWdlX3VuaXRzIDogXCJcIik7XG5cblx0XHRcdGlmIChjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdykge1xuXHRcdFx0XHQkJC5hcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW59YClcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIGAkey0xICogKCQkLmlubmVyUmFkaXVzICsgKCgkJC5yYWRpdXMgLSAkJC5pbm5lclJhZGl1cykgLyAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAxIDogMikpKX1weGApXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIjEuMmVtXCIpXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9taW4sIGZhbHNlKSk7XG5cblx0XHRcdFx0Ly8gc2hvdyBtYXggdGV4dCB3aGVuIGlzbid0IGZ1bGxDaXJjbGVcblx0XHRcdFx0IWlzRnVsbENpcmNsZSAmJiAkJC5hcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXh9YClcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIGAkeyQkLmlubmVyUmFkaXVzICsgKCgkJC5yYWRpdXMgLSAkJC5pbm5lclJhZGl1cykgLyAyKX1weGApXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIjEuMmVtXCIpXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9tYXgsIHRydWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5pdEdhdWdlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXJjcyA9ICQkLmFyY3M7XG5cdFx0Y29uc3QgYXBwZW5kVGV4dCA9IGNsYXNzTmFtZSA9PiB7XG5cdFx0XHRhcmNzLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblx0XHR9O1xuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xuXHRcdFx0YXJjcy5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZCk7XG5cblx0XHRcdGNvbmZpZy5nYXVnZV91bml0cyAmJiBhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdCk7XG5cblx0XHRcdGlmIChjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdykge1xuXHRcdFx0XHRhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlTWluKTtcblx0XHRcdFx0IWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRHYXVnZUxhYmVsSGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gMjAgOiAwO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7bW91c2UgYXMgZDNNb3VzZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgZ2V0UmFuZG9tLCBnZXRSZWN0U2VnTGlzdCwgaXNOdW1iZXIsIGlzT2JqZWN0VHlwZSwgaXNWYWx1ZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0QmFyKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgbWFpbkJhclVwZGF0ZSA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRCYXIoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcblx0XHRjb25zdCBtYWluQmFyRW50ZXIgPSBtYWluQmFyVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuXHRcdC8vIEJhcnMgZm9yIGVhY2ggZGF0YVxuXHRcdG1haW5CYXJFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycylcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XG5cdH0sXG5cblx0dXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBiYXJEYXRhID0gJCQuYmFyRGF0YS5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0JhciA9ICQkLmNsYXNzQmFyLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGluaXRpYWxPcGFjaXR5ID0gJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCk7XG5cblx0XHQkJC5tYWluQmFyID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9YClcblx0XHRcdC5kYXRhKGJhckRhdGEpO1xuXG5cdFx0JCQubWFpbkJhci5leGl0KCkudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW5CYXIgPSAkJC5tYWluQmFyLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0Jhcilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXG5cdFx0XHQubWVyZ2UoJCQubWFpbkJhcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgaW5pdGlhbE9wYWNpdHkpO1xuXHR9LFxuXG5cdHJlZHJhd0JhcihkcmF3QmFyLCB3aXRoVHJhbnNpdGlvbikge1xuXHRcdHJldHVybiBbXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aGlzLm1haW5CYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiB0aGlzLm1haW5CYXIpXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QmFyKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXG5cdFx0XTtcblx0fSxcblxuXHRnZXRCYXJXKGF4aXMsIGJhclRhcmdldHNOdW0pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRpY2tJbnRlcnZhbCA9IGF4aXMudGlja0ludGVydmFsKCQkLmdldE1heERhdGFDb3VudCgpKTtcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xuXHRcdGxldCByZXN1bHQ7XG5cblx0XHRjb25zdCBnZXRXaWR0aCA9IGlkID0+IHtcblx0XHRcdGNvbnN0IHdpZHRoID0gaWQgPyBjb25maWcuYmFyX3dpZHRoW2lkXSA6IGNvbmZpZy5iYXJfd2lkdGg7XG5cdFx0XHRjb25zdCByYXRpbyA9IGlkID8gd2lkdGgucmF0aW8gOiBjb25maWcuYmFyX3dpZHRoX3JhdGlvO1xuXHRcdFx0Y29uc3QgbWF4ID0gaWQgPyB3aWR0aC5tYXggOiBjb25maWcuYmFyX3dpZHRoX21heDtcblx0XHRcdGNvbnN0IHcgPSBpc051bWJlcih3aWR0aCkgP1xuXHRcdFx0XHR3aWR0aCA6IGJhclRhcmdldHNOdW0gPyAodGlja0ludGVydmFsICogcmF0aW8pIC8gYmFyVGFyZ2V0c051bSA6IDA7XG5cblx0XHRcdHJldHVybiBtYXggJiYgdyA+IG1heCA/IG1heCA6IHc7XG5cdFx0fTtcblxuXHRcdHJlc3VsdCA9IGdldFdpZHRoKCk7XG5cblx0XHRpZiAoIWlzR3JvdXBlZCAmJiBpc09iamVjdFR5cGUoY29uZmlnLmJhcl93aWR0aCkpIHtcblx0XHRcdHJlc3VsdCA9IHt3aWR0aDogcmVzdWx0LCB0b3RhbDogW119O1xuXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0aWYgKGNvbmZpZy5iYXJfd2lkdGhbdi5pZF0pIHtcblx0XHRcdFx0XHRyZXN1bHRbdi5pZF0gPSBnZXRXaWR0aCh2LmlkKTtcblx0XHRcdFx0XHRyZXN1bHQudG90YWwucHVzaChyZXN1bHRbdi5pZF0gfHwgcmVzdWx0LndpZHRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRnZXRCYXJzKGksIGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHN1ZmZpeCA9IChpc1ZhbHVlKGkpID8gYC0ke2l9YCA6IGBgKTtcblxuXHRcdHJldHVybiAoaWQgPyAkJC5tYWluXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApIDogJCQubWFpbilcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn0ke3N1ZmZpeH1gKTtcblx0fSxcblxuXHRleHBhbmRCYXJzKGksIGlkLCByZXNldCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJlc2V0ICYmICQkLnVuZXhwYW5kQmFycygpO1xuXHRcdCQkLmdldEJhcnMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xuXHR9LFxuXG5cdHVuZXhwYW5kQmFycyhpKSB7XG5cdFx0dGhpcy5nZXRCYXJzKGkpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcblx0fSxcblxuXHRnZW5lcmF0ZURyYXdCYXIoYmFySW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKTtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XG5cdFx0Y29uc3QgYmFyUmFkaXVzID0gY29uZmlnLmJhcl9yYWRpdXM7XG5cdFx0Y29uc3QgYmFyUmFkaXVzUmF0aW8gPSBjb25maWcuYmFyX3JhZGl1c19yYXRpbztcblxuXHRcdC8vIGdldCB0aGUgYmFyIHJhZGl1c1xuXHRcdGNvbnN0IGdldFJhZGl1cyA9IGlzTnVtYmVyKGJhclJhZGl1cykgJiYgYmFyUmFkaXVzID4gMCA/XG5cdFx0XHQoKSA9PiBiYXJSYWRpdXMgOiAoXG5cdFx0XHRcdGlzTnVtYmVyKGJhclJhZGl1c1JhdGlvKSA/IHcgPT4gdyAqIGJhclJhZGl1c1JhdGlvIDogbnVsbFxuXHRcdFx0KTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBnZXRQb2ludHMoZCwgaSk7XG5cblx0XHRcdC8vIHN3aXRjaCBwb2ludHMgaWYgYXhpcyBpcyByb3RhdGVkLCBub3QgYXBwbGljYWJsZSBmb3Igc3ViIGNoYXJ0XG5cdFx0XHRjb25zdCBpbmRleFggPSAraXNSb3RhdGVkO1xuXHRcdFx0Y29uc3QgaW5kZXhZID0gKyFpbmRleFg7XG5cblx0XHRcdGNvbnN0IGlzTmVnYXRpdmUgPSBkLnZhbHVlIDwgMDtcblx0XHRcdGNvbnN0IHBhdGhSYWRpdXMgPSBbXCJcIiwgXCJcIl07XG5cdFx0XHRsZXQgcmFkaXVzID0gMDtcblxuXHRcdFx0aWYgKGdldFJhZGl1cyAmJiAhaXNHcm91cGVkKSB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaXNSb3RhdGVkID8gaW5kZXhZIDogaW5kZXhYO1xuXHRcdFx0XHRjb25zdCBiYXJXID0gcG9pbnRzWzJdW2luZGV4XSAtIHBvaW50c1swXVtpbmRleF07XG5cblx0XHRcdFx0cmFkaXVzID0gZ2V0UmFkaXVzKGJhclcpO1xuXG5cdFx0XHRcdGNvbnN0IGFyYyA9IGBhJHtyYWRpdXN9LCR7cmFkaXVzfSAke2lzTmVnYXRpdmUgPyBgMSAwIDBgIDogYDAgMCAxYH0gYDtcblxuXHRcdFx0XHRwYXRoUmFkaXVzWyshaXNSb3RhdGVkXSA9IGAke2FyY30ke3JhZGl1c30sJHtyYWRpdXN9YDtcblx0XHRcdFx0cGF0aFJhZGl1c1sraXNSb3RhdGVkXSA9IGAke2FyY30ke1stcmFkaXVzLCByYWRpdXNdW2lzUm90YXRlZCA/IFwic29ydFwiIDogXCJyZXZlcnNlXCJdKCl9YDtcblxuXHRcdFx0XHRpc05lZ2F0aXZlICYmIHBhdGhSYWRpdXMucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXRoIHN0cmluZyBkYXRhIHNob3VsZG4ndCBiZSBjb250YWluaW5nIG5ldyBsaW5lIGNoYXJzXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy81MzBcblx0XHRcdGNvbnN0IHBhdGggPSBpc1JvdGF0ZWQgP1xuXHRcdFx0XHRgSCR7cG9pbnRzWzFdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1swXX1WJHtwb2ludHNbMl1baW5kZXhZXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfUgke3BvaW50c1szXVtpbmRleFhdfWAgOlxuXHRcdFx0XHRgViR7cG9pbnRzWzFdW2luZGV4WV0gKyAoaXNOZWdhdGl2ZSA/IC1yYWRpdXMgOiByYWRpdXMpfSAke3BhdGhSYWRpdXNbMF19SCR7cG9pbnRzWzJdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1WJHtwb2ludHNbM11baW5kZXhZXX1gO1xuXG5cdFx0XHRyZXR1cm4gYE0ke3BvaW50c1swXVtpbmRleFhdfSwke3BvaW50c1swXVtpbmRleFldfSR7cGF0aH16YDtcblx0XHR9O1xuXHR9LFxuXG5cdGdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGF4aXMgPSBpc1N1YiA/ICQkLnN1YlhBeGlzIDogJCQueEF4aXM7XG5cdFx0Y29uc3QgYmFyVGFyZ2V0c051bSA9IGJhckluZGljZXMuX19tYXhfXyArIDE7XG5cdFx0Y29uc3QgYmFyVyA9ICQkLmdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSk7XG5cdFx0Y29uc3QgYmFyWCA9ICQkLmdldFNoYXBlWChiYXJXLCBiYXJUYXJnZXRzTnVtLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcblx0XHRjb25zdCBiYXJZID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpO1xuXHRcdGNvbnN0IGJhck9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQmFyVHlwZSwgYmFySW5kaWNlcywgISFpc1N1Yik7XG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG5cblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKDApO1xuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYmFyT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYmFyIGNoYXJ0XG5cdFx0XHRjb25zdCB3aWR0aCA9IGlzTnVtYmVyKGJhclcpID8gYmFyVyA6IGJhcldbZC5pZF0gfHwgYmFyVy53aWR0aDtcblx0XHRcdGNvbnN0IHBvc1ggPSBiYXJYKGQpO1xuXHRcdFx0bGV0IHBvc1kgPSBiYXJZKGQpO1xuXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcblx0XHRcdGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkICYmIChcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcblx0XHRcdCkpIHtcblx0XHRcdFx0cG9zWSA9IHkwO1xuXHRcdFx0fVxuXG5cdFx0XHRwb3NZIC09ICh5MCAtIG9mZnNldCk7XG5cblx0XHRcdC8vIDQgcG9pbnRzIHRoYXQgbWFrZSBhIGJhclxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXG5cdFx0XHRcdFtwb3NYLCBwb3NZXSxcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgcG9zWV0sXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIG9mZnNldF1cblx0XHRcdF07XG5cdFx0fTtcblx0fSxcblxuXHRpc1dpdGhpbkJhcih0aGF0KSB7XG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoYXQpO1xuXHRcdGNvbnN0IGxpc3QgPSBnZXRSZWN0U2VnTGlzdCh0aGF0KTtcblx0XHRjb25zdCBbc2VnMCwgc2VnMV0gPSBsaXN0O1xuXHRcdGNvbnN0IHggPSBNYXRoLm1pbihzZWcwLngsIHNlZzEueCk7XG5cdFx0Y29uc3QgeSA9IE1hdGgubWluKHNlZzAueSwgc2VnMS55KTtcblx0XHRjb25zdCBvZmZzZXQgPSB0aGlzLmNvbmZpZy5iYXJfc2Vuc2l0aXZpdHk7XG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhhdC5nZXRCQm94KCk7XG5cdFx0Y29uc3Qgc3ggPSB4IC0gb2Zmc2V0O1xuXHRcdGNvbnN0IGV4ID0geCArIHdpZHRoICsgb2Zmc2V0O1xuXHRcdGNvbnN0IHN5ID0geSArIGhlaWdodCArIG9mZnNldDtcblx0XHRjb25zdCBleSA9IHkgLSBvZmZzZXQ7XG5cblx0XHRyZXR1cm4gc3ggPCBtb3VzZVswXSAmJlxuXHRcdFx0bW91c2VbMF0gPCBleCAmJlxuXHRcdFx0ZXkgPCBtb3VzZVsxXSAmJlxuXHRcdFx0bW91c2VbMV0gPCBzeTtcblx0fVxufSk7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmQsIGdldE1pbk1heCwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdEJ1YmJsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJidWJibGVcIikpIHtcblx0XHRcdGNvbmZpZy5wb2ludF9zaG93ID0gdHJ1ZTtcblx0XHRcdGNvbmZpZy5wb2ludF90eXBlID0gXCJjaXJjbGVcIjtcblx0XHRcdGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSA9IDI1O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHVzZXIgYWdlbnQncyBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgcGF0aCBpbiB1c2VyIHVuaXRzXG5cdCAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdHZW9tZXRyeUVsZW1lbnQvZ2V0VG90YWxMZW5ndGhcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0QmFzZUxlbmd0aCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiRiYXNlTGVuZ3RoXCI7XG5cdFx0bGV0IGJhc2VMZW5ndGggPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRpZiAoIWJhc2VMZW5ndGgpIHtcblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCBiYXNlTGVuZ3RoID0gZ2V0TWluTWF4KFwibWluXCIsIFtcblx0XHRcdFx0JCQuYXhlcy54LnNlbGVjdChcInBhdGhcIikubm9kZSgpXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCksXG5cdFx0XHRcdCQkLmF4ZXMueS5zZWxlY3QoXCJwYXRoXCIpLm5vZGUoKVxuXHRcdFx0XHRcdC5nZXRUb3RhbExlbmd0aCgpXG5cdFx0XHRdKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJhc2VMZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcmFkaXVzIHZhbHVlIGZvciBidWJibGUgY2lyY2xlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRnZXRCdWJibGVSKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IG1heFIgPSAkJC5jb25maWcuYnViYmxlX21heFI7XG5cblx0XHRpZiAoaXNGdW5jdGlvbihtYXhSKSkge1xuXHRcdFx0bWF4UiA9IG1heFIoZCk7XG5cdFx0fSBlbHNlIGlmICghaXNOdW1iZXIobWF4UikpIHtcblx0XHRcdG1heFIgPSAoJCQuZ2V0QmFzZUxlbmd0aCgpIC8gKCQkLmdldE1heERhdGFDb3VudCgpICogMikpICsgMTI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsICQkLmdldE1pbk1heERhdGEoKS5tYXgubWFwKGQgPT4gKGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlKSkpO1xuXHRcdGNvbnN0IG1heEFyZWEgPSBtYXhSICogbWF4UiAqIE1hdGguUEk7XG5cdFx0Y29uc3QgYXJlYSA9IGQudmFsdWUgKiAobWF4QXJlYSAvIG1heCk7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGFyZWEgLyBNYXRoLlBJKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRhcmVhIGFzIGQzQXJlYSxcblx0bGluZSBhcyBkM0xpbmVcbn0gZnJvbSBcImQzLXNoYXBlXCI7XG5pbXBvcnQge1xuXHRtb3VzZSBhcyBkM01vdXNlLFxuXHRzZWxlY3QgYXMgZDNTZWxlY3Rcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgZ2V0UmFuZG9tLCBpc0FycmF5LCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBpc1ZhbHVlfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRMaW5lKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xuXHR9LFxuXG5cdHVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NMaW5lcyA9ICQkLmNsYXNzTGluZXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NDaXJjbGVzID0gJCQuY2xhc3NDaXJjbGVzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xuXG5cdFx0Y29uc3QgbWFpbkxpbmVVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRMaW5lKGQpICsgY2xhc3NGb2N1cyhkKSk7XG5cblx0XHRjb25zdCBtYWluTGluZUVudGVyID0gbWFpbkxpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuXHRcdC8vIExpbmVzIGZvciBlYWNoIGRhdGFcblx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XG5cblx0XHQvLyBBcmVhc1xuXHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcblxuXHRcdGlmIChjb25maWcucG9pbnRfc2hvdykge1xuXHRcdFx0Ly8gQ2lyY2xlcyBmb3IgZWFjaCBkYXRhIHBvaW50IG9uIGxpbmVzXG5cdFx0XHRjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2VsZWN0ZWRDaXJjbGVzLCBkLmlkKSk7XG5cblx0XHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2lyY2xlcylcblx0XHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgZGF0ZSBmb3Igc2VsZWN0ZWQgY2lyY2xlc1xuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0LmlkKX1gKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGAke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xuXHRcdFx0XHRcdGQudmFsdWUgPSB0LnZhbHVlc1tkLmluZGV4XS52YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBNRU1POiBjYW4gbm90IGtlZXAgc2FtZSBjb2xvci4uLlxuXHRcdC8vIG1haW5MaW5lVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcblx0fSxcblxuXHR1cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLm1haW5MaW5lID0gJCQubWFpblxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmV9YClcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcblxuXHRcdCQkLm1haW5MaW5lLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpbkxpbmUgPSAkJC5tYWluTGluZS5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAkeyQkLmNsYXNzTGluZS5iaW5kKCQkKShkKX0gJHskJC5leHRyYUxpbmVDbGFzc2VzKGQpIHx8IFwiXCJ9YClcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5tZXJnZSgkJC5tYWluTGluZSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgZCA9PiAoJCQuaXNTdGVwVHlwZShkKSA/IFwiY3Jpc3BFZGdlc1wiIDogXCJcIikpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcblx0fSxcblxuXHRyZWRyYXdMaW5lKGRyYXdMaW5lLCB3aXRoVHJhbnNpdGlvbikge1xuXHRcdHJldHVybiBbXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aGlzLm1haW5MaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogdGhpcy5tYWluTGluZSlcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lKVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgdGhpcy5jb2xvcilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnZlIGludGVycG9sYXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGQgRGF0YSBvYmplY3Rcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRDdXJ2ZShkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlzUm90YXRlZFN0ZXBUeXBlID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZCAmJiAkJC5pc1N0ZXBUeXBlKGQpO1xuXG5cdFx0Ly8gd2hlbiBpcyBzdGVwICYgcm90YXRlZCwgc2hvdWxkIGJlIGNvbXB1dGVkIGluIGRpZmZlcmVudCB3YXlcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NzFcblx0XHRyZXR1cm4gaXNSb3RhdGVkU3RlcFR5cGUgPyBjb250ZXh0ID0+IHtcblx0XHRcdGNvbnN0IHN0ZXAgPSAkJC5nZXRJbnRlcnBvbGF0ZShkKShjb250ZXh0KTtcblxuXHRcdFx0Ly8ga2VlcCB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0XHRzdGVwLm9yZ1BvaW50ID0gc3RlcC5wb2ludDtcblxuXHRcdFx0Ly8gdG8gZ2V0IHJvdGF0ZWQgcGF0aCBkYXRhXG5cdFx0XHRzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDEgJiYgKHRoaXMuX3BvaW50ID0gMik7XG5cblx0XHRcdFx0Y29uc3QgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xuXG5cdFx0XHRcdHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkxKTtcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8oeCwgeTEpO1xuXG5cdFx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdH07XG5cblx0XHRcdHN0ZXAucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0XHRcdHRoaXMuX3BvaW50ID09PSAwID8gdGhpcy5vcmdQb2ludCh4LCB5KSA6IHRoaXMucG9pbnRSb3RhdGVkKHgsIHkpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIHN0ZXA7XG5cdFx0fSA6ICQkLmdldEludGVycG9sYXRlKGQpO1xuXHR9LFxuXG5cdGdlbmVyYXRlRHJhd0xpbmUobGluZUluZGljZXMsIGlzU3ViKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1Yik7XG5cdFx0Y29uc3QgeVNjYWxlR2V0dGVyID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG5cblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xuXHRcdGNvbnN0IHlWYWx1ZSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cblx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0QmFzZVZhbHVlKGQpKVxuXHRcdCk7XG5cblx0XHRsZXQgbGluZSA9IGQzTGluZSgpO1xuXG5cdFx0bGluZSA9IGlzUm90YXRlZCA/XG5cdFx0XHRsaW5lLngoeVZhbHVlKS55KHhWYWx1ZSkgOiBsaW5lLngoeFZhbHVlKS55KHlWYWx1ZSk7XG5cblx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xuXHRcdFx0bGluZSA9IGxpbmUuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgeCA9IGlzU3ViID8gJCQuc3ViWCA6ICQkLng7XG5cblx0XHRyZXR1cm4gZCA9PiB7XG5cdFx0XHRjb25zdCB5ID0geVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpO1xuXHRcdFx0bGV0IHZhbHVlcyA9IGxpbmVDb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXM7XG5cdFx0XHRsZXQgeDAgPSAwO1xuXHRcdFx0bGV0IHkwID0gMDtcblx0XHRcdGxldCBwYXRoO1xuXG5cdFx0XHRpZiAoJCQuaXNMaW5lVHlwZShkKSkge1xuXHRcdFx0XHRjb25zdCByZWdpb25zID0gY29uZmlnLmRhdGFfcmVnaW9uc1tkLmlkXTtcblxuXHRcdFx0XHRpZiAocmVnaW9ucykge1xuXHRcdFx0XHRcdHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCByZWdpb25zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBhdGggPSBsaW5lLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0eDAgPSB4KHZhbHVlc1swXS54KTtcblx0XHRcdFx0XHR5MCA9IHkodmFsdWVzWzBdLnZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcblx0XHR9O1xuXHR9LFxuXG5cdGdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWJWYWx1ZSkgeyAvLyBwYXJ0aWFsIGR1cGxpY2F0aW9uIG9mIGdlbmVyYXRlR2V0QmFyUG9pbnRzXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBsaW5lVGFyZ2V0c051bSA9IGxpbmVJbmRpY2VzLl9fbWF4X18gKyAxO1xuXHRcdGNvbnN0IGlzU3ViID0gISFpc1N1YlZhbHVlO1xuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgbGluZVRhcmdldHNOdW0sIGxpbmVJbmRpY2VzLCBpc1N1Yik7XG5cdFx0Y29uc3QgeSA9ICQkLmdldFNoYXBlWShpc1N1Yik7XG5cdFx0Y29uc3QgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1Yik7XG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG5cblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKDApO1xuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gbGluZU9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGFyZWEgY2hhcnRcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xuXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcblx0XHRcdCkpIHtcblx0XHRcdFx0cG9zWSA9IHkwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGxpbmUgcG9zaXRpb25cblx0XHRcdGNvbnN0IHBvaW50ID0gW3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50LCAvLyBmcm9tIGhlcmUgYW5kIGJlbG93LCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50XG5cdFx0XHRdO1xuXHRcdH07XG5cdH0sXG5cblx0bGluZVdpdGhSZWdpb25zKGQsIHgsIHksIF9yZWdpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xuXHRcdGNvbnN0IHhPZmZzZXQgPSAkJC5pc0NhdGVnb3JpemVkKCkgPyAwLjUgOiAwO1xuXHRcdGNvbnN0IHJlZ2lvbnMgPSBbXTtcblx0XHRjb25zdCBkYXNoYXJyYXkgPSBcIjIgMlwiOyAvLyBkZWZhdWx0IHZhbHVlXG5cblx0XHRsZXQgeHA7XG5cdFx0bGV0IHlwO1xuXHRcdGxldCBkaWZmO1xuXHRcdGxldCBkaWZmeDI7XG5cblx0XHQvLyBjaGVjayB3ZWF0aGVyIGRhdGEgaXMgd2l0aGluIHJlZ2lvblxuXHRcdGNvbnN0IGlzV2l0aGluUmVnaW9ucyA9ICh3aXRoaW5YLCB3aXRoaW5SZWdpb25zKSA9PiB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gd2l0aGluUmVnaW9uc1tpXSk7IGkrKykge1xuXHRcdFx0XHRpZiAocmVnLnN0YXJ0IDwgd2l0aGluWCAmJiB3aXRoaW5YIDw9IHJlZy5lbmQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVnLnN0eWxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gQ2hlY2sgc3RhcnQvZW5kIG9mIHJlZ2lvbnNcblx0XHRpZiAoaXNEZWZpbmVkKF9yZWdpb25zKSkge1xuXHRcdFx0Y29uc3QgZ2V0VmFsdWUgPSAodiwgZGVmKSA9PiAoXG5cdFx0XHRcdGlzVW5kZWZpbmVkKHYpID8gZGVmIDogKGlzVGltZVNlcmllcyA/ICQkLnBhcnNlRGF0ZSh2KSA6IHYpXG5cdFx0XHQpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gX3JlZ2lvbnNbaV0pOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBnZXRWYWx1ZShyZWcuc3RhcnQsIGRbMF0ueCk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KTtcblx0XHRcdFx0Y29uc3Qgc3R5bGUgPSByZWcuc3R5bGUgfHwge2Rhc2hhcnJheX07XG5cblx0XHRcdFx0cmVnaW9uc1tpXSA9IHtzdGFydCwgZW5kLCBzdHlsZX07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHNjYWxlc1xuXHRcdGNvbnN0IHhWYWx1ZSA9IGlzUm90YXRlZCA/IGR0ID0+IHkoZHQudmFsdWUpIDogZHQgPT4geChkdC54KTtcblx0XHRjb25zdCB5VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB4KGR0LngpIDogZHQgPT4geShkdC52YWx1ZSk7XG5cblx0XHQvLyBEZWZpbmUgc3ZnIGdlbmVyYXRvciBmdW5jdGlvbiBmb3IgcmVnaW9uXG5cdFx0Y29uc3QgZ2VuZXJhdGVNID0gcG9pbnRzID0+IGBNJHtwb2ludHNbMF1bMF19LCR7cG9pbnRzWzBdWzFdfUwke3BvaW50c1sxXVswXX0sJHtwb2ludHNbMV1bMV19YDtcblxuXHRcdGNvbnN0IHNXaXRoUmVnaW9uID0gaXNUaW1lU2VyaWVzID8gKGQwLCBkMSwgaywgdGltZXNlcmllc0RpZmYpID0+IHtcblx0XHRcdGNvbnN0IHgwID0gZDAueC5nZXRUaW1lKCk7XG5cdFx0XHRjb25zdCB4RGlmZiA9IGQxLnggLSBkMC54O1xuXHRcdFx0Y29uc3QgeHYwID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIGspO1xuXHRcdFx0Y29uc3QgeHYxID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIChrICsgdGltZXNlcmllc0RpZmYpKTtcblxuXHRcdFx0Y29uc3QgcG9pbnRzID0gaXNSb3RhdGVkID9cblx0XHRcdFx0W1t5KHlwKGspKSwgeCh4djApXSwgW3koeXAoayArIGRpZmYpKSwgeCh4djEpXV0gOlxuXHRcdFx0XHRbW3goeHYwKSwgeSh5cChrKSldLCBbeCh4djEpLCB5KHlwKGsgKyBkaWZmKSldXTtcblxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xuXHRcdH0gOiAoZDAsIGQxLCBrLCBvdGhlckRpZmYpID0+IHtcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XG5cdFx0XHRcdFtbeSh5cChrKSwgdHJ1ZSksIHgoeHAoaykpXSwgW3koeXAoayArIG90aGVyRGlmZiksIHRydWUpLCB4KHhwKGsgKyBvdGhlckRpZmYpKV1dIDpcblx0XHRcdFx0W1t4KHhwKGspLCB0cnVlKSwgeSh5cChrKSldLCBbeCh4cChrICsgb3RoZXJEaWZmKSwgdHJ1ZSksIHkoeXAoayArIG90aGVyRGlmZikpXV07XG5cblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcblx0XHR9O1xuXG5cdFx0Ly8gR2VuZXJhdGVcblx0XHRsZXQgcGF0aCA9IFwiTVwiO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGRhdGE7IChkYXRhID0gZFtpXSk7IGkrKykge1xuXHRcdFx0Y29uc3QgcHJldkRhdGEgPSBkW2kgLSAxXTtcblx0XHRcdGxldCBzdHlsZSA9IGlzV2l0aGluUmVnaW9ucyhkYXRhLngsIHJlZ2lvbnMpO1xuXG5cdFx0XHQvLyBEcmF3IGFzIG5vcm1hbFxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSkge1xuXHRcdFx0XHRwYXRoICs9IGAke2kgPyBcIkxcIiA6IFwiXCJ9JHt4VmFsdWUoZGF0YSl9LCR7eVZhbHVlKGRhdGEpfWA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUuZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHN0eWxlID0gZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERyYXcgd2l0aCByZWdpb24gLy8gVE9ETzogRml4IGZvciBob3Jpem90YWwgY2hhcnRzXG5cdFx0XHRcdHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyk7XG5cdFx0XHRcdHlwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEudmFsdWUsIGRhdGEudmFsdWUpO1xuXG5cdFx0XHRcdGNvbnN0IGR4ID0geChkYXRhLngpIC0geChwcmV2RGF0YS54KTtcblx0XHRcdFx0Y29uc3QgZHkgPSB5KGRhdGEudmFsdWUpIC0geShwcmV2RGF0YS52YWx1ZSk7XG5cdFx0XHRcdGNvbnN0IGRkID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG5cblx0XHRcdFx0ZGlmZiA9IHN0eWxlWzBdIC8gZGQ7XG5cdFx0XHRcdGRpZmZ4MiA9IGRpZmYgKiBzdHlsZVsxXTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gZGlmZjsgaiA8PSAxOyBqICs9IGRpZmZ4Mikge1xuXHRcdFx0XHRcdHBhdGggKz0gc1dpdGhSZWdpb24ocHJldkRhdGEsIGRhdGEsIGosIGRpZmYpO1xuXG5cdFx0XHRcdFx0Ly8gdG8gbWFrZSBzdXJlIGNvcnJlY3QgbGluZSBkcmF3aW5nXG5cdFx0XHRcdFx0aWYgKGogKyBkaWZmeDIgPj0gMSkge1xuXHRcdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgMSwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cblx0dXBkYXRlQXJlYUdyYWRpZW50KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xuXHRcdFx0Y29uc3QgaWQgPSBgJHskJC5kYXRldGltZUlkfS1hcmVhR3JhZGllbnQkeyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWA7XG5cblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpICYmICQkLmRlZnMuc2VsZWN0KGAjJHtpZH1gKS5lbXB0eSgpKSB7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gJCQuY29sb3IoZCk7XG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHR4ID0gWzAsIDBdLFxuXHRcdFx0XHRcdHkgPSBbMCwgMV0sXG5cdFx0XHRcdFx0c3RvcHMgPSBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV1cblx0XHRcdFx0fSA9ICQkLmNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50O1xuXG5cdFx0XHRcdGNvbnN0IGxpbmVhckdyYWRpZW50ID0gJCQuZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiaWRcIiwgYCR7aWR9YClcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIHhbMF0pXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4WzFdKVxuXHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgeVswXSlcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHlbMV0pO1xuXG5cdFx0XHRcdHN0b3BzLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RvcENvbG9yID0gaXNGdW5jdGlvbih2WzFdKSA/IHZbMV0oZC5pZCkgOiB2WzFdO1xuXG5cdFx0XHRcdFx0bGluZWFyR3JhZGllbnQuYXBwZW5kKFwic3RvcFwiKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJvZmZzZXRcIiwgdlswXSlcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdG9wQ29sb3IgfHwgY29sb3IpXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3Atb3BhY2l0eVwiLCB2WzJdKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0dXBkYXRlQXJlYUNvbG9yKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgP1xuXHRcdFx0YHVybCgjJHskJC5kYXRldGltZUlkfS1hcmVhR3JhZGllbnQkeyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfSlgIDpcblx0XHRcdCQkLmNvbG9yKGQpO1xuXHR9LFxuXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgJiYgJCQudXBkYXRlQXJlYUdyYWRpZW50KCk7XG5cblx0XHQkJC5tYWluQXJlYSA9ICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYX1gKVxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuXG5cdFx0JCQubWFpbkFyZWEuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluQXJlYSA9ICQkLm1haW5BcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZUFyZWFDb2xvci5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQkLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xuXHRcdFx0XHRyZXR1cm4gXCIwXCI7XG5cdFx0XHR9KVxuXHRcdFx0Lm1lcmdlKCQkLm1haW5BcmVhKTtcblxuXHRcdCQkLm1haW5BcmVhXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLm9yZ0FyZWFPcGFjaXR5KTtcblx0fSxcblxuXHRyZWRyYXdBcmVhKGRyYXdBcmVhLCB3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBbXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyAkJC5tYWluQXJlYS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6ICQkLm1haW5BcmVhKVxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlQXJlYUNvbG9yLmJpbmQoJCQpKVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGQgPT4gKCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/ICQkLm9yZ0FyZWFPcGFjaXR5IC8gMS43NSA6ICQkLm9yZ0FyZWFPcGFjaXR5KSlcblx0XHRdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhcmVhIHBhdGggZGF0YVxuXHQgKiBAcGFyYW0gYXJlYUluZGljZXNcblx0ICogQHBhcmFtIGlzU3ViXG5cdCAqIEByZXR1cm4ge2Z1bmN0aW9uKCo9KTogKCp8c3RyaW5nKX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlRHJhd0FyZWEoYXJlYUluZGljZXMsIGlzU3ViKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XG5cdFx0Y29uc3QgeVNjYWxlR2V0dGVyID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG5cblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xuXHRcdGNvbnN0IHZhbHVlMCA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cblx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XG5cdFx0XHRcdFx0JCQuZ2V0QXJlYVJhbmdlRGF0YShkLCBcImhpZ2hcIikgOiAwXG5cdFx0XHQpKTtcblx0XHRjb25zdCB2YWx1ZTEgPSAoZCwgaSkgPT4gKCQkLmlzR3JvdXBlZChkLmlkKSA/XG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMV1bMV0gOlxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKFxuXHRcdFx0XHQkJC5pc0FyZWFSYW5nZVR5cGUoZCkgP1xuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJsb3dcIikgOiBkLnZhbHVlXG5cdFx0XHQpKTtcblxuXHRcdHJldHVybiBkID0+IHtcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xuXHRcdFx0bGV0IHgwID0gMDtcblx0XHRcdGxldCB5MCA9IDA7XG5cdFx0XHRsZXQgcGF0aDtcblxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkpIHtcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcblxuXHRcdFx0XHRhcmVhID0gaXNSb3RhdGVkID9cblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxuXHRcdFx0XHRcdFx0LngwKHZhbHVlMClcblx0XHRcdFx0XHRcdC54MSh2YWx1ZTEpIDpcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxuXHRcdFx0XHRcdFx0LnkwKGNvbmZpZy5hcmVhX2Fib3ZlID8gMCA6IHZhbHVlMClcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xuXG5cdFx0XHRcdGlmICghbGluZUNvbm5lY3ROdWxsKSB7XG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuXHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhdGggPSBhcmVhLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHgwID0gJCQueCh2YWx1ZXNbMF0ueCk7XG5cdFx0XHRcdFx0eTAgPSAkJC5nZXRZU2NhbGUoZC5pZCkodmFsdWVzWzBdLnZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcblx0XHR9O1xuXHR9LFxuXG5cdGdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpIHtcblx0XHQvLyBwYXJ0aWFsIGR1cGxpY2F0aW9uIG9mIGdlbmVyYXRlR2V0QmFyUG9pbnRzXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBhcmVhVGFyZ2V0c051bSA9IGFyZWFJbmRpY2VzLl9fbWF4X18gKyAxO1xuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgYXJlYVRhcmdldHNOdW0sIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcblx0XHRjb25zdCB5ID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpO1xuXHRcdGNvbnN0IGFyZWFPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0FyZWFUeXBlLCBhcmVhSW5kaWNlcywgISFpc1N1Yik7XG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XG5cdFx0XHRjb25zdCBvZmZzZXQgPSBhcmVhT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxuXHRcdFx0Y29uc3QgcG9zWCA9IHgoZCk7XG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XG5cblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxuXHRcdFx0KSkge1xuXHRcdFx0XHRwb3NZID0geTA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgYXJlYSBwb3NpdGlvblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcblx0XHRcdF07XG5cdFx0fTtcblx0fSxcblxuXHR1cGRhdGVDaXJjbGUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCEkJC5jb25maWcucG9pbnRfc2hvdykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLm1haW5DaXJjbGUgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZX1gKVxuXHRcdFx0LmRhdGEoZCA9PiAhJCQuaXNCYXJUeXBlKGQpICYmICghJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5zaG91bGREcmF3UG9pbnRzRm9yTGluZShkKSkgJiZcblx0XHRcdFx0JCQubGFiZWxpc2hEYXRhKGQpKTtcblxuXHRcdCQkLm1haW5DaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpbkNpcmNsZSA9ICQkLm1haW5DaXJjbGUuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZCgkJC5wb2ludChcImNyZWF0ZVwiLCB0aGlzLCAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKSwgJCQucG9pbnRSLmJpbmQoJCQpLCAkJC5jb2xvcikpXG5cdFx0XHQubWVyZ2UoJCQubWFpbkNpcmNsZSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCkpO1xuXHR9LFxuXG5cdHJlZHJhd0NpcmNsZShjeCwgY3ksIHdpdGhUcmFuc2l0aW9uLCBmbG93KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHNlbGVjdGVkQ2lyY2xlcyA9ICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKTtcblxuXHRcdGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRjb25zdCBtYWluQ2lyY2xlcyA9IFtdO1xuXG5cdFx0JCQubWFpbkNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQub3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKSwgJCQuY29sb3IsIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpLmJpbmQodGhpcyk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihkKTtcblxuXHRcdFx0bWFpbkNpcmNsZXMucHVzaChyZXN1bHQpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgcG9zQXR0ciA9ICQkLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRtYWluQ2lyY2xlcyxcblx0XHRcdHNlbGVjdGVkQ2lyY2xlc1xuXHRcdFx0XHQuYXR0cihgJHtwb3NBdHRyfXhgLCBjeClcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn15YCwgY3kpXG5cdFx0XTtcblx0fSxcblxuXHRjaXJjbGVYKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaGFzVmFsdWUgPSBpc1ZhbHVlKGQueCk7XG5cblx0XHRyZXR1cm4gJCQuY29uZmlnLnpvb21fZW5hYmxlZCAmJiAkJC56b29tU2NhbGUgP1xuXHRcdFx0KGhhc1ZhbHVlID8gJCQuem9vbVNjYWxlKGQueCkgOiBudWxsKSA6XG5cdFx0XHQoaGFzVmFsdWUgPyAkJC54KGQueCkgOiBudWxsKTtcblx0fSxcblxuXHR1cGRhdGVDaXJjbGVZKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNpcmNsZVkgPSAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgaWQgPSBkLmlkO1xuXG5cdFx0XHRyZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/XG5cdFx0XHRcdCQkLmdlbmVyYXRlR2V0TGluZVBvaW50cygkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNMaW5lVHlwZSkpKGQsIGkpWzBdWzFdIDpcblx0XHRcdFx0JCQuZ2V0WVNjYWxlKGlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpO1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0Q2lyY2xlcyhpLCBpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzdWZmaXggPSAoaXNWYWx1ZShpKSA/IGAtJHtpfWAgOiBgYCk7XG5cblx0XHRyZXR1cm4gKGlkID8gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC5tYWluKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfSR7c3VmZml4fWApO1xuXHR9LFxuXG5cdGV4cGFuZENpcmNsZXMoaSwgaWQsIHJlc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcblxuXHRcdHJlc2V0ICYmICQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXG5cdFx0Y29uc3QgY2lyY2xlcyA9ICQkLmdldENpcmNsZXMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xuXHRcdGNvbnN0IHNjYWxlID0gcihjaXJjbGVzKSAvICQkLmNvbmZpZy5wb2ludF9yO1xuXHRcdGNvbnN0IHJhdGlvID0gMSAtIHNjYWxlO1xuXG5cdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xuXHRcdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdHJhbnNmb3JtIG11c3QgYmUgYXBwbGllZCB0byBlYWNoIG5vZGUgaW5kaXZpZHVhbGx5XG5cdFx0XHRjaXJjbGVzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gZDNTZWxlY3QodGhpcyk7XG5cblx0XHRcdFx0aWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xuXHRcdFx0XHRcdHBvaW50LmF0dHIoXCJyXCIsIHIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdGNvbnN0IHggPSByYXRpbyAqICgrcG9pbnQuYXR0cihcInhcIikgKyB3aWR0aCAvIDIpO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSByYXRpbyAqICgrcG9pbnQuYXR0cihcInlcIikgKyBoZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRcdHBvaW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3h9ICR7eX0pIHNjYWxlKCR7c2NhbGV9KWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0dW5leHBhbmRDaXJjbGVzKGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgciA9ICQkLnBvaW50Ui5iaW5kKCQkKTtcblxuXHRcdGNvbnN0IGNpcmNsZXMgPSAkJC5nZXRDaXJjbGVzKGkpXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcblxuXHRcdGNpcmNsZXMuYXR0cihcInJcIiwgcik7XG5cblx0XHQhJCQuaXNDaXJjbGVQb2ludCgpICYmXG5cdFx0XHRjaXJjbGVzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHNjYWxlKCR7cihjaXJjbGVzKSAvICQkLmNvbmZpZy5wb2ludF9yfSlgKTtcblx0fSxcblxuXHRwb2ludFIoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcG9pbnRSID0gY29uZmlnLnBvaW50X3I7XG5cdFx0bGV0IHIgPSBwb2ludFI7XG5cblx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuXHRcdFx0ciA9IDA7XG5cdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVR5cGUoZCkpIHtcblx0XHRcdHIgPSAkJC5nZXRCdWJibGVSKGQpO1xuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwb2ludFIpKSB7XG5cdFx0XHRyID0gcG9pbnRSKGQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9LFxuXG5cdHBvaW50RXhwYW5kZWRSKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHNjYWxlID0gJCQuaXNCdWJibGVUeXBlKGQpID8gMS4xNSA6IDEuNzU7XG5cblx0XHRyZXR1cm4gY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkID9cblx0XHRcdChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IgfHwgJCQucG9pbnRSKGQpICogc2NhbGUpIDogJCQucG9pbnRSKGQpO1xuXHR9LFxuXG5cdHBvaW50U2VsZWN0UihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHNlbGVjdFIgPSAkJC5jb25maWcucG9pbnRfc2VsZWN0X3I7XG5cblx0XHRyZXR1cm4gaXNGdW5jdGlvbihzZWxlY3RSKSA/XG5cdFx0XHRzZWxlY3RSKGQpIDogKHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNCk7XG5cdH0sXG5cblx0aXNXaXRoaW5DaXJjbGUobm9kZSwgcikge1xuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZShub2RlKTtcblx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3Qobm9kZSk7XG5cdFx0Y29uc3QgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KCkgPyBcImNcIiA6IFwiXCI7XG5cblx0XHRsZXQgY3ggPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH14YCk7XG5cdFx0bGV0IGN5ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eWApO1xuXG5cdFx0Ly8gaWYgbm9kZSBkb24ndCBoYXZlIGN4L3kgb3IgeC95IGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdGlmICghKGN4IHx8IGN5KSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG5cdFx0XHRjb25zdCB7eCwgeX0gPSBub2RlLmdldEJCb3ggPyBub2RlLmdldEJCb3goKSA6IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGN4ID0geDtcblx0XHRcdGN5ID0geTtcblx0XHR9XG5cblx0XHRjb25zdCBpcyA9IE1hdGguc3FydChcblx0XHRcdE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMilcblx0XHQpIDwgKHIgfHwgdGhpcy5jb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpO1xuXG5cdFx0cmV0dXJuIGlzO1xuXHR9LFxuXG5cdGlzV2l0aGluU3RlcCh0aGF0LCB5KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHkgLSBkM01vdXNlKHRoYXQpWzFdKSA8IDMwO1xuXHR9LFxuXG5cdHNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpIHtcblx0XHRjb25zdCBsaW5lUG9pbnQgPSB0aGlzLmNvbmZpZy5saW5lX3BvaW50O1xuXG5cdFx0cmV0dXJuIGxpbmVQb2ludCA9PT0gdHJ1ZSB8fFxuXHRcdFx0KGlzQXJyYXkobGluZVBvaW50KSAmJiBsaW5lUG9pbnQuaW5kZXhPZihkLmlkKSAhPT0gLTEpO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlcyxcblx0c2VsZWN0IGFzIGQzU2VsZWN0XG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtnZXRSYW5kb20sIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZSwgdG9BcnJheSwgZXh0ZW5kLCBub3RFbXB0eX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRoYXNWYWxpZFBvaW50VHlwZSh0eXBlKSB7XG5cdFx0cmV0dXJuIC9eKGNpcmNsZXxyZWN0KGFuZ2xlKT98cG9seWdvbnxlbGxpcHNlfHVzZSkkL2kudGVzdCh0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGUpO1xuXHR9LFxuXG5cdGhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyh0eXBlKSB7XG5cdFx0Y29uc3QgcG9pbnRUeXBlID0gdHlwZSB8fCB0aGlzLmNvbmZpZy5wb2ludF90eXBlO1xuXG5cdFx0cmV0dXJuIGlzT2JqZWN0VHlwZShwb2ludFR5cGUpICYmXG5cdFx0XHRpc0Z1bmN0aW9uKHBvaW50VHlwZS5jcmVhdGUpICYmIGlzRnVuY3Rpb24ocG9pbnRUeXBlLnVwZGF0ZSk7XG5cdH0sXG5cblx0aW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XG5cdFx0XHRjb25zdCBhdHRyaWJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XG5cdFx0XHRcdG5hbWUgPSBuYW1lLm5hbWU7XG5cdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgZnJvbS5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XG5cdFx0Y29uc3Qgbm9kZSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0Y29uc3QgY2xvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZDNOYW1lc3BhY2VzLnN2Zywgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuXHRcdGNsb25lLmlkID0gaWQ7XG5cdFx0Y2xvbmUuc3R5bGUuZmlsbCA9IFwiaW5oZXJpdFwiO1xuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xuXG5cdFx0Y29weUF0dHIobm9kZSwgY2xvbmUpO1xuXG5cdFx0aWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRjb25zdCBwYXJlbnQgPSBkM1NlbGVjdChjbG9uZSk7XG5cblx0XHRcdGlmIChcImlubmVySFRNTFwiIGluIGNsb25lKSB7XG5cdFx0XHRcdHBhcmVudC5odG1sKG5vZGUuaW5uZXJIVE1MKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvcHlBdHRyKHYsIHBhcmVudC5hcHBlbmQodi50YWdOYW1lKS5ub2RlKCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkJC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XG5cdH0sXG5cblx0cG9pbnRGcm9tRGVmcyhpZCkge1xuXHRcdHJldHVybiB0aGlzLmRlZnMuc2VsZWN0KGAjJHtpZH1gKTtcblx0fSxcblxuXHRnZW5lcmF0ZVBvaW50KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaWRzID0gW107XG5cdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/IGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGNvbnN0IGlkID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRsZXQgcG9pbnQ7XG5cblx0XHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcblxuXHRcdFx0XHRpZiAoJCQuaGFzVmFsaWRQb2ludFR5cGUocG9pbnQpKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSAkJFtwb2ludF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoISQkLmhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyhwb2ludCkpIHtcblx0XHRcdFx0XHRjb25zdCBwb2ludElkID0gYCR7JCQuZGF0ZXRpbWVJZH0tcG9pbnQtJHtpZH1gO1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50RnJvbURlZnMgPSAkJC5wb2ludEZyb21EZWZzKHBvaW50SWQpO1xuXG5cdFx0XHRcdFx0aWYgKHBvaW50RnJvbURlZnMuc2l6ZSgpIDwgMSkge1xuXHRcdFx0XHRcdFx0JCQuaW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgcG9pbnRJZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVcIikge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS5jcmVhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCBwb2ludElkLCAuLi5hcmdzKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ1cGRhdGVcIikge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS51cGRhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcG9pbnRbbWV0aG9kXS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIC4uLmFyZ3MpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9LFxuXG5cdGdldFRyYW5zaXRpb25OYW1lKCkge1xuXHRcdHJldHVybiBnZXRSYW5kb20oKTtcblx0fSxcblxuXHRjdXN0b206IHtcblx0XHRjcmVhdGUoZWxlbWVudCwgaWQsIGNzc0NsYXNzRm4sIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInVzZVwiKVxuXHRcdFx0XHQuYXR0cihcInhsaW5rOmhyZWZcIiwgYCMke2lkfWApXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY3NzQ2xhc3NGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbilcblx0XHRcdFx0Lm5vZGUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XG5cblx0XHRcdGNvbnN0IHhQb3NGbjIgPSBkID0+IHhQb3NGbihkKSAtIHdpZHRoIC8gMjtcblx0XHRcdGNvbnN0IHlQb3NGbjIgPSBkID0+IHlQb3NGbihkKSAtIGhlaWdodCAvIDI7XG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuXG5cdFx0XHRcdGlmIChmbG93KSB7XG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBlbGVtZW50XG5cdFx0XHRcdFx0XHQuYXR0cihcInhcIiwgeFBvc0ZuMik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IGVsZW1lbnRcblx0XHRcdFx0XHQudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSlcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeFBvc0ZuMilcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeVBvc0ZuMilcblx0XHRcdFx0XHQudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XG5cblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IGVsZW1lbnRcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeFBvc0ZuMilcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeVBvc0ZuMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gJ2NpcmNsZScgZGF0YSBwb2ludFxuXHRjaXJjbGU6IHtcblx0XHRjcmVhdGUoZWxlbWVudCwgY3NzQ2xhc3NGbiwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwiY2lyY2xlXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY3NzQ2xhc3NGbilcblx0XHRcdFx0LmF0dHIoXCJyXCIsIHNpemVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbilcblx0XHRcdFx0Lm5vZGUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG5cdFx0XHQvLyB3aGVuICcubG9hZCgpJyBjYWxsZWQsIGJ1YmJsZSBzaXplIHNob3VsZCBiZSB1cGRhdGVkXG5cdFx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzXG5cdFx0XHRcdFx0LmF0dHIoXCJyXCIsICQkLnBvaW50Ui5iaW5kKCQkKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9ICQkLmdldFRyYW5zaXRpb25OYW1lKCk7XG5cblx0XHRcdFx0aWYgKGZsb3cpIHtcblx0XHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzXG5cdFx0XHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IGVsZW1lbnQuYXR0cihcImN4XCIpID9cblx0XHRcdFx0XHRtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCB4UG9zRm4pXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcblx0XHRcdFx0XHRcdC50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKSA6XG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMuYXR0cihcImN4XCIsIHhQb3NGbilcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgeVBvc0ZuKTtcblxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXNcblx0XHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbilcblx0XHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gJ3JlY3RhbmdsZScgZGF0YSBwb2ludFxuXHRyZWN0YW5nbGU6IHtcblx0XHRjcmVhdGUoZWxlbWVudCwgY3NzQ2xhc3NGbiwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuXHRcdFx0Y29uc3QgcmVjdFNpemVGbiA9IGQgPT4gc2l6ZUZuKGQpICogMi4wO1xuXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY3NzQ2xhc3NGbilcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCByZWN0U2l6ZUZuKVxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCByZWN0U2l6ZUZuKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxuXHRcdFx0XHQubm9kZSgpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGUoZWxlbWVudCwgeFBvc0ZuLCB5UG9zRm4sIG9wYWNpdHlTdHlsZUZuLCBmaWxsU3R5bGVGbixcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcblx0XHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRcdGNvbnN0IHIgPSAkJC5jb25maWcucG9pbnRfcjtcblx0XHRcdGNvbnN0IHJlY3RYUG9zRm4gPSBkID0+IHhQb3NGbihkKSAtIHI7XG5cdFx0XHRjb25zdCByZWN0WVBvc0ZuID0gZCA9PiB5UG9zRm4oZCkgLSByO1xuXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuXG5cdFx0XHRcdGlmIChmbG93KSB7XG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlc1xuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlc1xuXHRcdFx0XHRcdC50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCByZWN0WVBvc0ZuKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcblxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXNcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgcmVjdFhQb3NGbilcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRldmVudCBhcyBkM0V2ZW50XG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmQsIGdldE1pbk1heCwgZ2V0UmFuZ2UsIGlzRGVmaW5lZCwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBzZXRUZXh0VmFsdWUsIHRvQXJyYXl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbG9ja3dpc2UgSWYgdGhlIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIENvb3JkaW5hdGUgdHlwZSAneCcgb3IgJ3knXG4gKiBAcGFyYW0ge051bWJlcn0gZWRnZSBOdW1iZXIgb2YgZWRnZVxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBUaGUgaW5kZXhlZCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGlzQ2xvY2t3aXNlLCB0eXBlLCBlZGdlLCBwb3MsIHJhbmdlLCByYXRpbykge1xuXHRjb25zdCBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zO1xuXHRjb25zdCByID0gMiAqIE1hdGguUEk7XG5cdGNvbnN0IGZ1bmMgPSB0eXBlID09PSBcInhcIiA/IE1hdGguc2luIDogTWF0aC5jb3M7XG5cblx0cmV0dXJuIHJhbmdlICogKDEgLSByYXRpbyAqIGZ1bmMoaW5kZXggKiByIC8gZWRnZSkpO1xufVxuXG4vLyBjYWNoZSBrZXlcbmNvbnN0IGNhY2hlS2V5ID0gXCIkcmFkYXJQb2ludHNcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRSYWRhcigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJyYWRhclwiKSkge1xuXHRcdFx0JCQucmFkYXJzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFJhZGFycyk7XG5cblx0XHRcdC8vIGxldmVsXG5cdFx0XHQkJC5yYWRhcnMubGV2ZWxzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZXZlbHMpO1xuXG5cdFx0XHQvLyBheGlzXG5cdFx0XHQkJC5yYWRhcnMuYXhlcyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpcyk7XG5cblx0XHRcdC8vIHNoYXBlc1xuXHRcdFx0JCQucmFkYXJzLnNoYXBlcyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muc2hhcGVzKTtcblxuXHRcdFx0JCQubWF4VmFsdWUgPSBjb25maWcucmFkYXJfYXhpc19tYXggfHwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heFswXS52YWx1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkYXJTaXplKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA8IDQgPyAtMjAgOiAxMDtcblx0XHRjb25zdCBzaXplID0gKE1hdGgubWluKCQkLmFyY1dpZHRoLCAkJC5hcmNIZWlnaHQpIC0gcGFkZGluZykgLyAyO1xuXG5cdFx0cmV0dXJuIFtzaXplLCBzaXplXTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpKSB7XG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBnZXRSYW5nZSgwLCBnZXRNaW5NYXgoXCJtYXhcIiwgdGFyZ2V0cy5tYXAodiA9PiB2LnZhbHVlcy5sZW5ndGgpKSk7XG5cdFx0fVxuXG5cdFx0JCQuZ2VuZXJhdGVSYWRhclBvaW50cygpO1xuXHR9LFxuXG5cdGdldFJhZGFyUG9zaXRpb24odHlwZSwgaW5kZXgsIHJhbmdlLCByYXRpbykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XG5cdFx0Y29uc3QgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XG5cdFx0Y29uc3QgaXNDbG9ja3dpc2UgPSBjb25maWcucmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTtcblxuXHRcdGNvbnN0IHBvcyA9IHRvQXJyYXkodHlwZSkubWFwKHYgPT4gZ2V0UG9zaXRpb24oXG5cdFx0XHRpc0Nsb2Nrd2lzZSxcblx0XHRcdHYsXG5cdFx0XHRlZGdlLFxuXHRcdFx0aW5kZXgsXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UpID8gcmFuZ2UgOiAodHlwZSA9PT0gXCJ4XCIgPyB3aWR0aCA6IGhlaWdodCksXG5cdFx0XHRpc051bWJlcihyYXRpbykgPyByYXRpbyA6IGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvXG5cdFx0KSk7XG5cblx0XHRyZXR1cm4gcG9zLmxlbmd0aCA9PT0gMSA/IHBvc1swXSA6IHBvcztcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJhdGUgZGF0YSBwb2ludHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlUmFkYXJQb2ludHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XG5cblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcblx0XHRjb25zdCBwb2ludHMgPSAkJC5nZXRDYWNoZShjYWNoZUtleSkgfHwge307XG5cdFx0Y29uc3Qgc2l6ZSA9IHBvaW50cy5fc2l6ZTtcblxuXHRcdC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9ubHkgd2hlbiB0aGUgcHJldmlvdXMgZGltZW5zaW9uIGhhcyBiZWVuIGNoYW5nZWRcblx0XHRpZiAoIXNpemUgfHwgKHNpemUud2lkdGggIT09IHdpZHRoICYmIHNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpKSB7XG5cdFx0XHR0YXJnZXRzLmZvckVhY2goZCA9PiB7XG5cdFx0XHRcdHBvaW50c1tkLmlkXSA9IGQudmFsdWVzLm1hcCgodiwgaSkgPT4gKFxuXHRcdFx0XHRcdCQkLmdldFJhZGFyUG9zaXRpb24oW1wieFwiLCBcInlcIl0sIGksIHVuZGVmaW5lZCwgJCQuZ2V0UmF0aW8oXCJyYWRhclwiLCB2KSlcblx0XHRcdFx0KSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG9pbnRzLl9zaXplID0ge3dpZHRoLCBoZWlnaHR9O1xuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIHBvaW50cyk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlZHJhd1JhZGFyKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gJCQuZ2V0VHJhbnNsYXRlKFwicmFkYXJcIik7XG5cblx0XHQvLyBBZGp1c3QgcmFkYXIsIGNpcmNsZXMgYW5kIHRleHRzJyBwb3NpdGlvblxuXHRcdGlmICh0cmFuc2xhdGUpIHtcblx0XHRcdCQkLnJhZGFycy5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XG5cdFx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XG5cblx0XHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcblx0XHRcdCQkLnVwZGF0ZVJhZGFyTGV2ZWwoKTtcblx0XHRcdCQkLnVwZGF0ZVJhZGFyQXhlcygpO1xuXHRcdFx0JCQudXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2VuZXJhdGVHZXRSYWRhclBvaW50cygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1tkLmlkXVtpXTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnRcblx0XHRcdF07XG5cdFx0fTtcblx0fSxcblxuXHR1cGRhdGVSYWRhckxldmVsKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XG5cdFx0Y29uc3QgZGVwdGggPSBjb25maWcucmFkYXJfbGV2ZWxfZGVwdGg7XG5cdFx0Y29uc3QgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XG5cdFx0Y29uc3Qgc2hvd1RleHQgPSBjb25maWcucmFkYXJfbGV2ZWxfdGV4dF9zaG93O1xuXG5cdFx0Y29uc3QgcmFkYXJMZXZlbHMgPSAkJC5yYWRhcnMubGV2ZWxzO1xuXHRcdGNvbnN0IGxldmVsRGF0YSA9IGdldFJhbmdlKDAsIGRlcHRoKTtcblxuXHRcdGNvbnN0IHJhZGl1cyA9IGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvICogTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cdFx0Y29uc3QgbGV2ZWxSYXRpbyA9IGxldmVsRGF0YS5tYXAobCA9PiByYWRpdXMgKiAoKGwgKyAxKSAvIGRlcHRoKSk7XG5cdFx0Y29uc3QgbGV2ZWxUZXh0Rm9ybWF0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfZm9ybWF0O1xuXG5cdFx0Ly8gR2VuZXJhdGUgcG9pbnRzXG5cdFx0Y29uc3QgcG9pbnRzID0gbGV2ZWxEYXRhLm1hcCh2ID0+IHtcblx0XHRcdGNvbnN0IHJhbmdlID0gbGV2ZWxSYXRpb1t2XTtcblx0XHRcdGNvbnN0IHBvcyA9IGdldFJhbmdlKDAsIGVkZ2UpLm1hcChpID0+IChcblx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgcmFuZ2UsIDEpKS5qb2luKFwiLFwiKVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHBvcy5qb2luKFwiIFwiKTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IGxldmVsID0gcmFkYXJMZXZlbHNcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxldmVsfWApXG5cdFx0XHQuZGF0YShsZXZlbERhdGEpO1xuXG5cdFx0bGV2ZWwuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0Y29uc3QgbGV2ZWxFbnRlciA9IGxldmVsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MubGV2ZWx9ICR7Q0xBU1MubGV2ZWx9LSR7aX1gKTtcblxuXHRcdGxldmVsRW50ZXIuYXBwZW5kKFwicG9seWdvblwiKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcucmFkYXJfbGV2ZWxfc2hvdyA/IG51bGwgOiBcImhpZGRlblwiKTtcblxuXHRcdGlmIChzaG93VGV4dCkge1xuXHRcdFx0aWYgKHJhZGFyTGV2ZWxzLnNlbGVjdChcInRleHRcIikuZW1wdHkoKSkge1xuXHRcdFx0XHRyYWRhckxldmVsc1xuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0uN2VtXCIpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcblx0XHRcdFx0XHQudGV4dCgoKSA9PiBsZXZlbFRleHRGb3JtYXQoMCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXZlbEVudGVyLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG5cdFx0XHRcdC50ZXh0KGQgPT4gbGV2ZWxUZXh0Rm9ybWF0KFxuXHRcdFx0XHRcdCQkLm1heFZhbHVlIC8gbGV2ZWxEYXRhLmxlbmd0aCAqIChkICsgMSlcblx0XHRcdFx0KSk7XG5cdFx0fVxuXG5cdFx0bGV2ZWxFbnRlclxuXHRcdFx0Lm1lcmdlKGxldmVsKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7d2lkdGggLSBsZXZlbFJhdGlvW2RdfSwgJHtoZWlnaHQgLSBsZXZlbFJhdGlvW2RdfSlgKVxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcblx0XHRcdC5hdHRyKFwicG9pbnRzXCIsIGQgPT4gcG9pbnRzW2RdKTtcblxuXHRcdC8vIHVwZGF0ZSBsZXZlbCB0ZXh0IHBvc2l0aW9uXG5cdFx0aWYgKHNob3dUZXh0KSB7XG5cdFx0XHRyYWRhckxldmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBkID0+IChpc1VuZGVmaW5lZChkKSA/IHdpZHRoIDogcG9pbnRzW2RdLnNwbGl0KFwiLFwiKVswXSkpXG5cdFx0XHRcdC5hdHRyKFwieVwiLCBkID0+IChpc1VuZGVmaW5lZChkKSA/IGhlaWdodCA6IDApKTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlUmFkYXJBeGVzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XG5cdFx0Y29uc3QgY2F0ZWdvcmllcyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcblxuXHRcdGxldCBheGlzID0gJCQucmFkYXJzLmF4ZXMuc2VsZWN0QWxsKFwiZ1wiKVxuXHRcdFx0LmRhdGEoY2F0ZWdvcmllcyk7XG5cblx0XHRheGlzLmV4aXQoKS5yZW1vdmUoKTtcblxuXHRcdGNvbnN0IGF4aXNFbnRlciA9IGF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5heGlzfS0ke2l9YCk7XG5cblx0XHRjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcImxpbmVcIik7XG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuXG5cdFx0YXhpcyA9IGF4aXNFbnRlci5tZXJnZShheGlzKTtcblxuXHRcdC8vIGF4aXMgbGluZVxuXHRcdGlmIChjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cpIHtcblx0XHRcdGF4aXMuc2VsZWN0KFwibGluZVwiKVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIHdpZHRoKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGhlaWdodClcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAoZCwgaSkgPT4gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgaSkpXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ5XCIsIGkpKTtcblx0XHR9XG5cblx0XHQvLyBheGlzIHRleHRcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93KSB7XG5cdFx0XHRheGlzLnNlbGVjdChcInRleHRcIilcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi41ZW1cIilcblx0XHRcdFx0LmNhbGwoc2VsZWN0aW9uID0+IHtcblx0XHRcdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0XHRzZXRUZXh0VmFsdWUoZDNTZWxlY3QodGhpcyksIGQsIFstMS4yLCAxLjJdKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRhdHVtKChkLCBpKSA9PiAoe2luZGV4OiBpfSkpXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7JCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgaSwgdW5kZWZpbmVkLCAxKX0gJHskJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpLCB1bmRlZmluZWQsIDEpfSlgKTtcblx0XHR9XG5cblx0XHQkJC5iaW5kRXZlbnQoKTtcblx0fSxcblxuXHRiaW5kRXZlbnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCkge1xuXHRcdFx0Y29uc3QgaXNNb3VzZSA9ICQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xuXHRcdFx0Y29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XG5cdFx0XHRcdGxldCB0YXJnZXQgPSBkM0V2ZW50LnRhcmdldDtcblxuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIG11bHRpbGluZWQgYXhpcyB0ZXh0XG5cdFx0XHRcdGlmICgvdHNwYW4vaS50ZXN0KHRhcmdldC50YWdOYW1lKSkge1xuXHRcdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZCA9IGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKTtcblxuXHRcdFx0XHRyZXR1cm4gZCAmJiBPYmplY3Qua2V5cyhkKS5sZW5ndGggPT09IDEgPyBkLmluZGV4IDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHRcdGNvbnN0IGhpZGUgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcblx0XHRcdFx0Y29uc3Qgbm9JbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcblxuXHRcdFx0XHRpZiAoaXNNb3VzZSB8fCBub0luZGV4KSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlVG9vbHRpcCgpO1xuXHRcdFx0XHRcdHRoaXMudW5leHBhbmRDaXJjbGVzKCk7XG5cblx0XHRcdFx0XHRpZiAoaXNNb3VzZSkge1xuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgaW5kZXgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9JbmRleCkge1xuXHRcdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0JCQucmFkYXJzLnNlbGVjdChgLiR7Q0xBU1MuYXhpc31gKVxuXHRcdFx0XHQub24oaXNNb3VzZSA/IFwibW91c2VvdmVyIFwiIDogXCJ0b3VjaHN0YXJ0XCIsICgpID0+IHtcblx0XHRcdFx0XHRpZiAoJCQudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XG5cblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKCQkLnN2Zy5ub2RlKCksIG51bGwsIGluZGV4KTtcblx0XHRcdFx0XHRpc01vdXNlID8gJCQuc2V0T3Zlck91dCh0cnVlLCBpbmRleCkgOiAkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgaXNNb3VzZSA/IGhpZGUgOiBudWxsKTtcblxuXHRcdFx0aWYgKCFpc01vdXNlKSB7XG5cdFx0XHRcdCQkLnN2Zy5vbihcInRvdWNoc3RhcnRcIiwgaGlkZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGNvbnN0IGFyZWFzID0gJCQucmFkYXJzLnNoYXBlc1xuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcblx0XHRcdC5kYXRhKHRhcmdldHMpO1xuXG5cdFx0Y29uc3QgYXJlYXNFbnRlciA9IGFyZWFzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0NoYXJ0UmFkYXIuYmluZCgkJCkpO1xuXG5cdFx0YXJlYXMuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdGFyZWFzRW50ZXJcblx0XHRcdC5hcHBlbmQoXCJwb2x5Z29uXCIpXG5cdFx0XHQubWVyZ2UoYXJlYXMpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZCkpXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiAkJC5jb2xvcihkKSlcblx0XHRcdC5hdHRyKFwicG9pbnRzXCIsIGQgPT4gcG9pbnRzW2QuaWRdLmpvaW4oXCIgXCIpKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGRhdGEgcG9pbnQgeCBjb29yZGluYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJhZGFyQ2lyY2xlWChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FjaGUoY2FjaGVLZXkpW2QuaWRdW2QuaW5kZXhdWzBdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgZGF0YSBwb2ludCB5IGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3Rcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmFkYXJDaXJjbGVZKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYWNoZShjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMV07XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGxcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtjYXBpdGFsaXplLCBleHRlbmQsIGdldFJhbmRvbSwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0VGV4dCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFRleHRzKTtcblxuXHRcdCQkLm1haW5UZXh0ID0gZDNTZWxlY3RBbGwoW10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgY2hhcnRUZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkJC5kYXRhLnRhcmdldHNcblx0ICovXG5cdHVwZGF0ZVRhcmdldHNGb3JUZXh0KHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2xhc3NDaGFydFRleHQgPSAkJC5jbGFzc0NoYXJ0VGV4dC5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc1RleHRzID0gJCQuY2xhc3NUZXh0cy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcblx0XHRjb25zdCBtYWluVGV4dFVwZGF0ZSA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydFRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRUZXh0fWApXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRUZXh0KGQpICsgY2xhc3NGb2N1cyhkKSk7XG5cblx0XHRjb25zdCBtYWluVGV4dEVudGVyID0gbWFpblRleHRVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRUZXh0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuXHRcdG1haW5UZXh0RW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc1RleHRzKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRleHRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NUZXh0ID0gJCQuY2xhc3NUZXh0LmJpbmQoJCQpO1xuXG5cdFx0JCQubWFpblRleHQgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dHN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy50ZXh0fWApXG5cdFx0XHQuZGF0YShkID0+ICh0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCkpKTtcblxuXHRcdCQkLm1haW5UZXh0LmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW5UZXh0ID0gJCQubWFpblRleHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcblx0XHRcdC5tZXJnZSgkJC5tYWluVGV4dClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0KVxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBkID0+IChjb25maWcuYXhpc19yb3RhdGVkID8gKGQudmFsdWUgPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIikgOiBcIm1pZGRsZVwiKSlcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnRleHQoKGQsIGksIGopID0+ICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkLnZhbHVlLCBkLmlkLCBpLCBqKSk7XG5cdH0sXG5cblx0dXBkYXRlVGV4dENvbG9yKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbGFiZWxDb2xvcnMgPSAkJC5jb25maWcuZGF0YV9sYWJlbHNfY29sb3JzO1xuXHRcdGxldCBjb2xvcjtcblxuXHRcdGlmIChpc1N0cmluZyhsYWJlbENvbG9ycykpIHtcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnM7XG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChsYWJlbENvbG9ycykpIHtcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnNbZC5pZF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbG9yIHx8ICQkLmNvbG9yKGQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgY2hhcnRUZXh0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHggUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHhcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geSBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvckZsb3dcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvbiB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlZHJhd1RleHQoeCwgeSwgZm9yRmxvdywgd2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdCA9IGdldFJhbmRvbSgpO1xuXHRcdGNvbnN0IG9wYWNpdHlGb3JUZXh0ID0gZm9yRmxvdyA/IDAgOiAkJC5vcGFjaXR5Rm9yVGV4dC5iaW5kKCQkKTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHR0aGlzLm1haW5UZXh0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IHRleHQgPSBkM1NlbGVjdCh0aGlzKTtcblxuXHRcdFx0XHQvLyBkbyBub3QgYXBwbHkgdHJhbnNpdGlvbiBmb3IgbmV3bHkgYWRkZWQgdGV4dCBlbGVtZW50c1xuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gJiYgdGV4dC5hdHRyKFwieFwiKSA/IHRleHQudHJhbnNpdGlvbih0KSA6IHRleHQpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHkpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHlGb3JUZXh0KTtcblx0XHRcdH0pXG5cdFx0XTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHZhbHVlIG9mIHRoZSBlbGVtZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcblx0ICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHQgKi9cblx0Z2V0VGV4dFJlY3QoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBiYXNlID0gKGVsZW1lbnQubm9kZSA/IGVsZW1lbnQubm9kZSgpIDogZWxlbWVudCk7XG5cblx0XHRpZiAoIS90ZXh0L2kudGVzdChiYXNlLnRhZ05hbWUpKSB7XG5cdFx0XHRiYXNlID0gYmFzZS5xdWVyeVNlbGVjdG9yKFwidGV4dFwiKTtcblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0ID0gYmFzZS50ZXh0Q29udGVudDtcblx0XHRjb25zdCBjYWNoZUtleSA9IGAkJHt0ZXh0LnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9YDtcblx0XHRsZXQgcmVjdCA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICghcmVjdCkge1xuXHRcdFx0JCQuc3ZnLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxuXHRcdFx0XHQuc3R5bGUoXCJmb250XCIsIGQzU2VsZWN0KGJhc2UpLnN0eWxlKFwiZm9udFwiKSlcblx0XHRcdFx0LmNsYXNzZWQoY2xhc3NOYW1lLCB0cnVlKVxuXHRcdFx0XHQudGV4dCh0ZXh0KVxuXHRcdFx0XHQuY2FsbCh2ID0+IHtcblx0XHRcdFx0XHRyZWN0ID0gdi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIHJlY3QpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB4IG9yIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5kaWNlcyBJbmRpY2VzIHZhbHVlc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclggd2hldGhlciBvciBub3QgdG8geFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBjb29yZGluYXRlc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2VuZXJhdGVYWUZvclRleHQoaW5kaWNlcywgZm9yWCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0eXBlcyA9IE9iamVjdC5rZXlzKGluZGljZXMpO1xuXHRcdGNvbnN0IHBvaW50cyA9IHt9O1xuXHRcdGNvbnN0IGdldHRlciA9IGZvclggPyAkJC5nZXRYRm9yVGV4dCA6ICQkLmdldFlGb3JUZXh0O1xuXG5cdFx0JCQuaGFzVHlwZShcInJhZGFyXCIpICYmIHR5cGVzLnB1c2goXCJyYWRhclwiKTtcblxuXHRcdHR5cGVzLmZvckVhY2godiA9PiB7XG5cdFx0XHRwb2ludHNbdl0gPSAkJFtgZ2VuZXJhdGVHZXQke2NhcGl0YWxpemUodil9UG9pbnRzYF0oaW5kaWNlc1t2XSwgZmFsc2UpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdGNvbnN0IHR5cGUgPSAoJCQuaXNBcmVhVHlwZShkKSAmJiBcImFyZWFcIikgfHxcblx0XHRcdFx0KCQkLmlzQmFyVHlwZShkKSAmJiBcImJhclwiKSB8fFxuXHRcdFx0XHQoJCQuaXNSYWRhclR5cGUoZCkgJiYgXCJyYWRhclwiKSB8fCBcImxpbmVcIjtcblxuXHRcdFx0cmV0dXJuIGdldHRlci5jYWxsKCQkLCBwb2ludHNbdHlwZV0oZCwgaSksIGQsIHRoaXMpO1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjZW50ZXJpemVkIHRleHQgcG9zaXRpb24gZm9yIGJhciB0eXBlIGRhdGEubGFiZWwudGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGV4dEVsZW1lbnQgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRcblx0ICogQHJldHVybnMge051bWJlcn0gUG9zaXRpb24gdmFsdWVcblx0ICovXG5cdGdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2xhYmVscy5jZW50ZXJlZCAmJiAkJC5pc0JhclR5cGUoZCkpIHtcblx0XHRcdGNvbnN0IHJlY3QgPSB0ZXh0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdGNvbnN0IGlzUG9zaXRpdmUgPSBkLnZhbHVlID49IDA7XG5cblx0XHRcdGlmIChpc1JvdGF0ZWQpIHtcblx0XHRcdFx0Y29uc3QgdyA9IChcblx0XHRcdFx0XHRpc1Bvc2l0aXZlID9cblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXSA6XG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV1cblx0XHRcdFx0KSAvIDIgKyAocmVjdC53aWR0aCAvIDIpO1xuXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gLXcgLSAzIDogdyArIDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBoID0gKFxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xuXHRcdFx0XHRcdFx0cG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdIDpcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXVxuXHRcdFx0XHQpIC8gMiArIChyZWN0LmhlaWdodCAvIDIpO1xuXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gaCA6IC1oIC0gMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGNvb3JkaW5hdGVcblx0ICovXG5cdGdldFhGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHhQb3M7XG5cdFx0bGV0IHBhZGRpbmc7XG5cblx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHRwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XG5cdFx0XHR4UG9zID0gcG9pbnRzWzJdWzFdICsgcGFkZGluZyAqIChkLnZhbHVlIDwgMCA/IC0xIDogMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhQb3MgPSAkJC5oYXNUeXBlKFwiYmFyXCIpID8gKHBvaW50c1syXVswXSArIHBvaW50c1swXVswXSkgLyAyIDogcG9pbnRzWzBdWzBdO1xuXHRcdH1cblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRpZiAoeFBvcyA+ICQkLndpZHRoKSB7XG5cdFx0XHRcdHhQb3MgPSAkJC53aWR0aCAtIHRleHRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdFx0fSBlbHNlIGlmICh4UG9zIDwgMCkge1xuXHRcdFx0XHR4UG9zID0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHR4UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4geFBvcyArIChjb25maWcuZGF0YV9sYWJlbHNfcG9zaXRpb24ueCB8fCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGNvb3JkaW5hdGVcblx0ICovXG5cdGdldFlGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgciA9IGNvbmZpZy5wb2ludF9yO1xuXHRcdGNvbnN0IHJlY3QgPSB0ZXh0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRsZXQgYmFzZVkgPSAzO1xuXHRcdGxldCB5UG9zO1xuXG5cdFx0aWYgKGlzUm90YXRlZCkge1xuXHRcdFx0eVBvcyA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbMl1bMF0gKyByZWN0LmhlaWdodCAqIDAuNikgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR5UG9zID0gcG9pbnRzWzJdWzFdO1xuXG5cdFx0XHRpZiAoaXNOdW1iZXIocikgJiYgciA+IDUgJiYgKCQkLmlzTGluZVR5cGUoZCkgfHwgJCQuaXNTY2F0dGVyVHlwZShkKSkpIHtcblx0XHRcdFx0YmFzZVkgKz0gY29uZmlnLnBvaW50X3IgLyAyLjM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkLnZhbHVlIDwgMCB8fCAoZC52YWx1ZSA9PT0gMCAmJiAhJCQuaGFzUG9zaXRpdmVWYWx1ZSkpIHtcblx0XHRcdFx0eVBvcyArPSByZWN0LmhlaWdodDtcblxuXHRcdFx0XHRpZiAoJCQuaXNCYXJUeXBlKGQpKSB7XG5cdFx0XHRcdFx0eVBvcyAtPSBiYXNlWTtcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaXNCYXJUeXBlKGQpKSB7XG5cdFx0XHRcdFx0eVBvcyArPSBiYXNlWTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGRpZmYgPSAtYmFzZVkgKiAyO1xuXG5cdFx0XHRcdGlmICgkJC5pc0JhclR5cGUoZCkpIHtcblx0XHRcdFx0XHRkaWZmID0gLWJhc2VZO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xuXHRcdFx0XHRcdGRpZmYgPSBiYXNlWTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlQb3MgKz0gZGlmZjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsICYmICFpc1JvdGF0ZWQpIHtcblx0XHRcdGNvbnN0IGJveEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoeVBvcyA8IGJveEhlaWdodCkge1xuXHRcdFx0XHR5UG9zID0gYm94SGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmICh5UG9zID4gdGhpcy5oZWlnaHQpIHtcblx0XHRcdFx0eVBvcyA9IHRoaXMuaGVpZ2h0IC0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWlzUm90YXRlZCkge1xuXHRcdFx0eVBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHlQb3MgKyAoY29uZmlnLmRhdGFfbGFiZWxzX3Bvc2l0aW9uLnkgfHwgMCk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8vIGRlZmluZWQgY2hhcnQgdHlwZXMgYXMgY2F0ZWdvcnlcbmNvbnN0IFRZUEVTID0ge1xuXHRBcmVhOiBbXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcImFyZWEtc3RlcFwiXSxcblx0QXJlYVJhbmdlOiBbXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiXSxcblx0QXJjOiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCIsIFwicmFkYXJcIl0sXG5cdExpbmU6IFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXG5cdFN0ZXA6IFtcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXG5cdFNwbGluZTogW1wic3BsaW5lXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiXVxufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdHNldFRhcmdldFR5cGUodGFyZ2V0SWRzLCB0eXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHQkJC53aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZXNbaWRdID0gdHlwZTtcblx0XHR9KTtcblxuXHRcdGlmICghdGFyZ2V0SWRzKSB7XG5cdFx0XHRjb25maWcuZGF0YV90eXBlID0gdHlwZTtcblx0XHR9XG5cdH0sXG5cblx0aGFzVHlwZSh0eXBlLCB0YXJnZXRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZXMgPSAkJC5jb25maWcuZGF0YV90eXBlcztcblx0XHRjb25zdCB0YXJnZXRzID0gdGFyZ2V0c1ZhbHVlIHx8ICQkLmRhdGEudGFyZ2V0cztcblx0XHRsZXQgaGFzID0gZmFsc2U7XG5cblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XG5cdFx0XHRcdGNvbnN0IHQgPSB0eXBlc1t0YXJnZXQuaWRdO1xuXG5cdFx0XHRcdGlmICgodCAmJiB0LmluZGV4T2YodHlwZSkgPj0gMCkgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xuXHRcdFx0XHRcdGhhcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoT2JqZWN0LmtleXModHlwZXMpLmxlbmd0aCkge1xuXHRcdFx0T2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhhcyA9ICQkLmNvbmZpZy5kYXRhX3R5cGUgPT09IHR5cGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhcztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcblx0ICogQHBhcm1hIHtTdHJpbmd9IHR5cGUgVHlwZSBrZXlcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFzVHlwZU9mKHR5cGUsIHRhcmdldHMsIGV4Y2x1ZGUgPSBbXSkge1xuXHRcdHJldHVybiAhVFlQRVNbdHlwZV1cblx0XHRcdC5maWx0ZXIodiA9PiBleGNsdWRlLmluZGV4T2YodikgPT09IC0xKVxuXHRcdFx0LmV2ZXJ5KHYgPT4gIXRoaXMuaGFzVHlwZSh2LCB0YXJnZXRzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGNoYXJ0IHR5cGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGlzVHlwZU9mKGQsIHR5cGUpIHtcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XG5cdFx0Y29uc3QgZGF0YVR5cGUgPSB0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcblxuXHRcdHJldHVybiBpc0FycmF5KHR5cGUpID9cblx0XHRcdHR5cGUuaW5kZXhPZihkYXRhVHlwZSkgPj0gMCA6IGRhdGFUeXBlID09PSB0eXBlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBjb250YWlucyBhcmMgdHlwZXMgY2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFzQXJjVHlwZSh0YXJnZXRzLCBleGNsdWRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZU9mKFwiQXJjXCIsIHRhcmdldHMsIGV4Y2x1ZGUpO1xuXHR9LFxuXG5cdGlzTGluZVR5cGUoZCkge1xuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcblxuXHRcdHJldHVybiAhdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0gfHxcblx0XHRcdHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVTLkxpbmUpO1xuXHR9LFxuXG5cdGlzU3RlcFR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlN0ZXApO1xuXHR9LFxuXG5cdGlzU3BsaW5lVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuU3BsaW5lKTtcblx0fSxcblxuXHRpc0FyZWFUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5BcmVhKTtcblx0fSxcblxuXHRpc0FyZWFSYW5nZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLkFyZWFSYW5nZSk7XG5cdH0sXG5cblx0aXNCYXJUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJhclwiKTtcblx0fSxcblxuXHRpc0J1YmJsZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYnViYmxlXCIpO1xuXHR9LFxuXG5cdGlzU2NhdHRlclR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcblx0fSxcblxuXHRpc1BpZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicGllXCIpO1xuXHR9LFxuXG5cdGlzR2F1Z2VUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImdhdWdlXCIpO1xuXHR9LFxuXG5cdGlzRG9udXRUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xuXHR9LFxuXG5cdGlzUmFkYXJUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInJhZGFyXCIpO1xuXHR9LFxuXG5cdGlzQXJjVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNQaWVUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzR2F1Z2VUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzUmFkYXJUeXBlKGQpO1xuXHR9LFxuXG5cdC8vIGRldGVybWluZSBpZiBpcyAnY2lyY2xlJyBkYXRhIHBvaW50XG5cdGlzQ2lyY2xlUG9pbnQoKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcGF0dGVybiA9IGNvbmZpZy5wb2ludF9wYXR0ZXJuO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXG5cdFx0XHQoIXBhdHRlcm4gfHwgKGlzQXJyYXkocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDApKTtcblx0fSxcblxuXHRsaW5lRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xuXHR9LFxuXG5cdGFyY0RhdGEoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gW2RdIDogW107XG5cdH0sXG5cblx0YmFyRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGRhdGEgYWRhcHQgZm9yIGRhdGEgbGFiZWwgc2hvd2luZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGxhYmVsaXNoRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcblx0XHRcdHRoaXMuaXNTY2F0dGVyVHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc0J1YmJsZVR5cGUoZCkgfHxcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuXHR9LFxuXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgfHwgdGhpcy5pc0xpbmVUeXBlKGQpIHx8IHRoaXMuaXNCdWJibGVUeXBlKGQpID9cblx0XHRcdGQudmFsdWVzIDogW107XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlI2N1cnZlc1xuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGUpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0XCJiYXNpc1wiLFxuXHRcdFx0XCJiYXNpcy1jbG9zZWRcIixcblx0XHRcdFwiYmFzaXMtb3BlblwiLFxuXHRcdFx0XCJidW5kbGVcIixcblx0XHRcdFwiY2FyZGluYWxcIixcblx0XHRcdFwiY2FyZGluYWwtY2xvc2VkXCIsXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcblx0XHRcdFwiY2F0bXVsbC1yb21cIixcblx0XHRcdFwiY2F0bXVsbC1yb20tY2xvc2VkXCIsXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcblx0XHRcdFwibGluZWFyXCIsXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIixcblx0XHRcdFwibW9ub3RvbmUteFwiLFxuXHRcdFx0XCJtb25vdG9uZS15XCIsXG5cdFx0XHRcIm5hdHVyYWxcIlxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0FycmF5LCBpc1ZhbHVlfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8vIEdyaWQgcG9zaXRpb24gYW5kIHRleHQgYW5jaG9yIGhlbHBlcnNcbmNvbnN0IGdldEdyaWRUZXh0QW5jaG9yID0gZCA9PiBpc1ZhbHVlKGQucG9zaXRpb24pIHx8IFwiZW5kXCI7XG5jb25zdCBnZXRHcmlkVGV4dER4ID0gZCA9PiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gNCA6IChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiID8gMCA6IC00KSk7XG5jb25zdCBnZXRHcmlkVGV4dFggPSAoaXNYLCB3aWR0aCwgaGVpZ2h0KSA9PiBkID0+IHtcblx0bGV0IHggPSBpc1ggPyAwIDogd2lkdGg7XG5cblx0aWYgKGQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuXHRcdHggPSBpc1ggPyAtaGVpZ2h0IDogMDtcblx0fSBlbHNlIGlmIChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiKSB7XG5cdFx0eCA9IChpc1ggPyAtaGVpZ2h0IDogd2lkdGgpIC8gMjtcblx0fVxuXG5cdHJldHVybiB4O1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRHcmlkKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnhncmlkID0gZDNTZWxlY3RBbGwoW10pO1xuXG5cdFx0JCQuaW5pdEdyaWRMaW5lcygpO1xuXHRcdCQkLmluaXRYWUZvY3VzR3JpZCgpO1xuXHR9LFxuXG5cdGluaXRHcmlkTGluZXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xuXHRcdFx0JCQuZ3JpZExpbmVzID0gJCQubWFpbi5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5jaGFydH0ke2NvbmZpZy5ncmlkX2xpbmVzX2Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWApXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoRm9yR3JpZClcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy5ncmlkfSAke0NMQVNTLmdyaWRMaW5lc31gKTtcblxuXHRcdFx0JCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkTGluZXMpO1xuXHRcdFx0JCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkTGluZXMpO1xuXG5cdFx0XHQkJC54Z3JpZExpbmVzID0gZDNTZWxlY3RBbGwoW10pO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHhncmlkRGF0YSA9ICQkLmdlbmVyYXRlR3JpZERhdGEoY29uZmlnLmdyaWRfeF90eXBlLCAkJC54KTtcblx0XHRjb25zdCB0aWNrT2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gJCQueEF4aXMudGlja09mZnNldCgpIDogMDtcblx0XHRjb25zdCBwb3MgPSBkID0+ICgoJCQuem9vbVNjYWxlIHx8ICQkLngpKGQpICsgdGlja09mZnNldCkgKiAoaXNSb3RhdGVkID8gLTEgOiAxKTtcblxuXHRcdCQkLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcblx0XHRcdFwieDFcIjogMCxcblx0XHRcdFwieDJcIjogJCQud2lkdGgsXG5cdFx0XHRcInkxXCI6IHBvcyxcblx0XHRcdFwieTJcIjogcG9zLFxuXHRcdH0gOiB7XG5cdFx0XHRcIngxXCI6IHBvcyxcblx0XHRcdFwieDJcIjogcG9zLFxuXHRcdFx0XCJ5MVwiOiAwLFxuXHRcdFx0XCJ5MlwiOiAkJC5oZWlnaHQsXG5cdFx0fTtcblxuXHRcdCQkLnhncmlkID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWR9YClcblx0XHRcdC5kYXRhKHhncmlkRGF0YSk7XG5cblx0XHQkJC54Z3JpZC5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHQkJC54Z3JpZCA9ICQkLnhncmlkLmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKVxuXHRcdFx0Lm1lcmdlKCQkLnhncmlkKTtcblxuXHRcdGlmICghd2l0aG91dFVwZGF0ZSkge1xuXHRcdFx0JCQueGdyaWQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgZ3JpZCA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdE9iamVjdC5rZXlzKCQkLnhncmlkQXR0cikuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRcdFx0Z3JpZC5hdHRyKGlkLCAkJC54Z3JpZEF0dHJbaWRdKVxuXHRcdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAoKSA9PiAoXG5cdFx0XHRcdFx0XHRcdGdyaWQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIpID09PSAoaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogMCkgP1xuXHRcdFx0XHRcdFx0XHRcdFwiMFwiIDogXCIxXCJcblx0XHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVZR3JpZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgZ3JpZFZhbHVlcyA9ICQkLnlBeGlzLnRpY2tWYWx1ZXMoKSB8fCAkJC55LnRpY2tzKGNvbmZpZy5ncmlkX3lfdGlja3MpO1xuXHRcdGNvbnN0IHBvcyA9IGQgPT4gTWF0aC5jZWlsKCQkLnkoZCkpO1xuXG5cdFx0JCQueWdyaWQgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy55Z3JpZH1gKVxuXHRcdFx0LmRhdGEoZ3JpZFZhbHVlcyk7XG5cblx0XHQkJC55Z3JpZC5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHQkJC55Z3JpZCA9ICQkLnlncmlkXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWQpXG5cdFx0XHQubWVyZ2UoJCQueWdyaWQpO1xuXG5cdFx0JCQueWdyaWQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IHBvcyA6IDApXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHBvcyA6ICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiBwb3MpO1xuXG5cdFx0JCQuc21vb3RoTGluZXMoJCQueWdyaWQsIFwiZ3JpZFwiKTtcblx0fSxcblxuXHR1cGRhdGVHcmlkKGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0ISQkLmdyaWRMaW5lcyAmJiAkJC5pbml0R3JpZExpbmVzKCk7XG5cblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXG5cdFx0JCQuZ3JpZC5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcblxuXHRcdCQkLm1haW4uc2VsZWN0KGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c31gKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblxuXHRcdCQkLnVwZGF0ZVhHcmlkTGluZXMoZHVyYXRpb24pO1xuXHRcdCQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJiAkJC51cGRhdGVYR3JpZCgpO1xuXG5cdFx0JCQueGdyaWRMaW5lcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZExpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy54Z3JpZExpbmV9YClcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xuXG5cdFx0Ly8gZXhpdFxuXHRcdCQkLnhncmlkTGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGVudGVyXG5cdFx0Y29uc3QgeGdyaWRMaW5lID0gJCQueGdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG5cblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJcIiA6IFwicm90YXRlKC05MClcIilcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcblxuXHRcdCQkLnhncmlkTGluZXMgPSB4Z3JpZExpbmUubWVyZ2UoJCQueGdyaWRMaW5lcyk7XG5cblx0XHQkJC54Z3JpZExpbmVzXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcblx0XHRcdC5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIFkgR3JpZCBsaW5lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiYgJCQudXBkYXRlWUdyaWQoKTtcblxuXHRcdCQkLnlncmlkTGluZXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRMaW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWRMaW5lfWApXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKTtcblxuXHRcdC8vIGV4aXRcblx0XHQkJC55Z3JpZExpbmVzLmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGVudGVyXG5cdFx0Y29uc3QgeWdyaWRMaW5lID0gJCQueWdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG5cblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJyb3RhdGUoLTkwKVwiIDogXCJcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xuXG5cdFx0JCQueWdyaWRMaW5lcyA9IHlncmlkTGluZS5tZXJnZSgkJC55Z3JpZExpbmVzKTtcblxuXHRcdC8vIHVwZGF0ZVxuXHRcdGNvbnN0IHl2ID0gJCQueXYuYmluZCgkJCk7XG5cblx0XHQkJC55Z3JpZExpbmVzXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueWdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcblx0XHRcdC5zZWxlY3QoXCJsaW5lXCIpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IHl2IDogMClcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gMCA6IHl2KVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiB5dilcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXG5cdFx0JCQueWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LmF0dHIoXCJkeVwiLCAtNSlcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCAkJC53aWR0aCwgJCQuaGVpZ2h0KSlcblx0XHRcdC5hdHRyKFwieVwiLCB5dilcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH0sXG5cblx0cmVkcmF3R3JpZCh3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHh2ID0gJCQueHYuYmluZCgkJCk7XG5cblx0XHRsZXQgbGluZXMgPSAkJC54Z3JpZExpbmVzLnNlbGVjdChcImxpbmVcIik7XG5cdFx0bGV0IHRleHRzID0gJCQueGdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpO1xuXG5cdFx0bGluZXMgPSAod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcylcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IHh2KVxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyB4diA6IDApXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHh2IDogJCQuaGVpZ2h0KTtcblxuXHRcdHRleHRzID0gKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKCFpc1JvdGF0ZWQsICQkLndpZHRoLCAkJC5oZWlnaHQpKVxuXHRcdFx0LmF0dHIoXCJ5XCIsIHh2KVxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLFxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRdO1xuXHR9LFxuXG5cdGluaXRYWUZvY3VzR3JpZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzRnJvbnQgPSBjb25maWcuZ3JpZF9mcm9udDtcblx0XHRjb25zdCBjbGFzc05hbWUgPSBgLiR7Q0xBU1NbaXNGcm9udCAmJiAkJC5ncmlkTGluZXMgPyBcImdyaWRMaW5lc1wiIDogXCJjaGFydFwiXX0ke2lzRnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YDtcblxuXHRcdCQkLmdyaWQgPSAkJC5tYWluLmluc2VydChcImdcIiwgY2xhc3NOYW1lKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGhGb3JHcmlkKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ncmlkKTtcblxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJlxuXHRcdFx0JCQuZ3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZHMpO1xuXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmXG5cdFx0XHQkJC5ncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkcyk7XG5cblx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfc2hvdykge1xuXHRcdFx0JCQuZ3JpZC5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cylcblx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZEZvY3VzKTtcblx0XHR9XG5cdH0sXG5cblx0c2hvd1hHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xuXHRcdGNvbnN0IGZvY3VzRWwgPSAkJC5tYWluLnNlbGVjdEFsbChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YCk7XG5cdFx0Y29uc3QgeHggPSAkJC54eC5iaW5kKCQkKTtcblxuXHRcdGlmICghY29uZmlnLnRvb2x0aXBfc2hvdykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xuXHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvY3VzRWxcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXG5cdFx0XHQuZGF0YShbZGF0YVRvU2hvd1swXV0pXG5cdFx0XHQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIsIHh4KVxuXHRcdFx0LmF0dHIoaXNSb3RhdGVkID8gXCJ5MlwiIDogXCJ4MlwiLCB4eCk7XG5cblx0XHQkJC5zbW9vdGhMaW5lcyhmb2N1c0VsLCBcImdyaWRcIik7XG5cdH0sXG5cblx0aGlkZVhHcmlkRm9jdXMoKSB7XG5cdFx0dGhpcy5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YCkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuXHR9LFxuXG5cdHVwZGF0ZVhncmlkRm9jdXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YClcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IC0xMClcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiAtMTApXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IC0xMCA6IDApXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IC0xMCA6ICQkLmhlaWdodCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVHcmlkRGF0YSh0eXBlLCBzY2FsZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0aWNrTnVtID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApXG5cdFx0XHQuc2VsZWN0QWxsKFwiLnRpY2tcIilcblx0XHRcdC5zaXplKCk7XG5cdFx0bGV0IGdyaWREYXRhID0gW107XG5cblx0XHRpZiAodHlwZSA9PT0gXCJ5ZWFyXCIpIHtcblx0XHRcdGNvbnN0IHhEb21haW4gPSAkJC5nZXRYRG9tYWluKCk7XG5cdFx0XHRjb25zdCBmaXJzdFllYXIgPSB4RG9tYWluWzBdLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRjb25zdCBsYXN0WWVhciA9IHhEb21haW5bMV0uZ2V0RnVsbFllYXIoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGZpcnN0WWVhcjsgaSA8PSBsYXN0WWVhcjsgaSsrKSB7XG5cdFx0XHRcdGdyaWREYXRhLnB1c2gobmV3IERhdGUoYCR7aX0tMDEtMDEgMDA6MDA6MDBgKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdyaWREYXRhID0gc2NhbGUudGlja3MoMTApO1xuXG5cdFx0XHRpZiAoZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSkgeyAvLyB1c2Ugb25seSBpbnRcblx0XHRcdFx0Z3JpZERhdGEgPSBncmlkRGF0YS5maWx0ZXIoZCA9PiBTdHJpbmcoZCkuaW5kZXhPZihcIi5cIikgPCAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JpZERhdGE7XG5cdH0sXG5cblx0Z2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcykge1xuXHRcdHJldHVybiBwYXJhbXMgPyBsaW5lID0+IHtcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHQoaXNBcnJheShwYXJhbXMpID8gcGFyYW1zLmNvbmNhdCgpIDogW3BhcmFtc10pLmZvckVhY2gocGFyYW0gPT4ge1xuXHRcdFx0XHRpZiAoKChcInZhbHVlXCIgaW4gcGFyYW0gJiYgbGluZS52YWx1ZSA9PT0gcGFyYW0udmFsdWUpIHx8IChcImNsYXNzXCIgaW4gcGFyYW0gJiYgbGluZS5jbGFzcyA9PT0gcGFyYW0uY2xhc3MpKSkge1xuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBmb3VuZDtcblx0XHR9IDogKCkgPT4gdHJ1ZTtcblx0fSxcblxuXHRyZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmb3JYKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0b1JlbW92ZSA9ICQkLmdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpO1xuXHRcdGNvbnN0IHRvU2hvdyA9IGxpbmUgPT4gIXRvUmVtb3ZlKGxpbmUpO1xuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lcyA6IENMQVNTLnlncmlkTGluZXM7XG5cdFx0Y29uc3QgY2xhc3NMaW5lID0gZm9yWCA/IENMQVNTLnhncmlkTGluZSA6IENMQVNTLnlncmlkTGluZTtcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtjbGFzc0xpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtjbGFzc0xpbmV9YClcblx0XHRcdC5maWx0ZXIodG9SZW1vdmUpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0Y29uc3QgZ3JpZExpbmVzID0gYGdyaWRfJHtmb3JYID8gXCJ4XCIgOiBcInlcIn1fbGluZXNgO1xuXG5cdFx0Y29uZmlnW2dyaWRMaW5lc10gPSBjb25maWdbZ3JpZExpbmVzXS5maWx0ZXIodG9TaG93KTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRtb3VzZSBhcyBkM01vdXNlXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc2FuaXRpc2UsIHRwbFByb2Nlc3MsIGlzVW5kZWZpbmVkfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRUb29sdGlwKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYmluZHRvID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZHRvO1xuXG5cdFx0JCQudG9vbHRpcCA9IGQzU2VsZWN0KGJpbmR0byk7XG5cblx0XHRpZiAoJCQudG9vbHRpcC5lbXB0eSgpKSB7XG5cdFx0XHQkJC50b29sdGlwID0gJCQuc2VsZWN0Q2hhcnRcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxuXHRcdFx0XHQuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudG9vbHRpcENvbnRhaW5lcilcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cdFx0fVxuXG5cdFx0Ly8gU2hvdyB0b29sdGlwIGlmIG5lZWRlZFxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiBpc1N0cmluZyhjb25maWcudG9vbHRpcF9pbml0X3gpKSB7XG5cdFx0XHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHNbMF07XG5cdFx0XHRcdGxldCBpO1xuXHRcdFx0XHRsZXQgdmFsO1xuXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9ICQkLnBhcnNlRGF0ZShjb25maWcudG9vbHRpcF9pbml0X3gpO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7ICh2YWwgPSB0YXJnZXRzLnZhbHVlc1tpXSk7IGkrKykge1xuXHRcdFx0XHRcdGlmICgodmFsLnggLSBjb25maWcudG9vbHRpcF9pbml0X3gpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSBpO1xuXHRcdFx0fVxuXG5cdFx0XHQkJC50b29sdGlwLmh0bWwoJCQuZ2V0VG9vbHRpcEhUTUwoXG5cdFx0XHRcdCQkLmRhdGEudGFyZ2V0cy5tYXAoZCA9PiAkJC5hZGROYW1lKGQudmFsdWVzW2NvbmZpZy50b29sdGlwX2luaXRfeF0pKSxcblx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcblx0XHRcdFx0JCQuZ2V0WUZvcm1hdCgkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKSksXG5cdFx0XHRcdCQkLmNvbG9yXG5cdFx0XHQpKTtcblxuXHRcdFx0aWYgKCFiaW5kdG8pIHtcblx0XHRcdFx0JCQudG9vbHRpcC5zdHlsZShcInRvcFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLnRvcClcblx0XHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24ubGVmdClcblx0XHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBzdHJpbmdcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRm9ybWF0dGVkIEhUTUwgc3RyaW5nXG5cdCAqL1xuXHRnZXRUb29sdGlwSFRNTCguLi5hcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XG5cdFx0XHRjb25maWcudG9vbHRpcF9jb250ZW50cy5jYWxsKCQkLCAuLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b29sdGlwIGNvbnRlbnQoSFRNTCBzdHJpbmcpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIGRhdGFcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRWYWx1ZUZvcm1hdCBEZWZhdWx0IGZvcm1hdCBmb3IgZWFjaCBkYXRhIHZhbHVlIGluIHRoZSB0b29sdGlwLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2xvciBDb2xvciBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBodG1sXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRpdGxlRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X3RpdGxlIHx8IGRlZmF1bHRUaXRsZUZvcm1hdDtcblx0XHRjb25zdCBuYW1lRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X25hbWUgfHwgKG5hbWUgPT4gbmFtZSk7XG5cdFx0Y29uc3QgdmFsdWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfdmFsdWUgfHwgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyAoKHYsIHJhdGlvKSA9PiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JWApIDogZGVmYXVsdFZhbHVlRm9ybWF0KTtcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xuXHRcdGNvbnN0IGdldFJvd1ZhbHVlID0gcm93ID0+ICQkLmdldEJhc2VWYWx1ZShyb3cpO1xuXHRcdGNvbnN0IGdldEJnQ29sb3IgPSAkJC5sZXZlbENvbG9yID8gcm93ID0+ICQkLmxldmVsQ29sb3Iocm93LnZhbHVlKSA6IHJvdyA9PiBjb2xvcihyb3cpO1xuXHRcdGNvbnN0IGNvbnRlbnRzID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XG5cdFx0Y29uc3QgdHBsU3RyID0gY29udGVudHMudGVtcGxhdGU7XG5cblx0XHRpZiAob3JkZXIgPT09IG51bGwgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCkge1xuXHRcdFx0Ly8gZm9yIHN0YWNrZWQgZGF0YSwgb3JkZXIgc2hvdWxkIGFsaWduZWQgd2l0aCB0aGUgdmlzdWFsbHkgZGlzcGxheWVkIGRhdGFcblx0XHRcdGNvbnN0IGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpXG5cdFx0XHRcdC5tYXAoaTIgPT4gaTIuaWQpXG5cdFx0XHRcdC5yZXZlcnNlKCk7XG5cblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRsZXQgdjEgPSBhID8gYS52YWx1ZSA6IG51bGw7XG5cdFx0XHRcdGxldCB2MiA9IGIgPyBiLnZhbHVlIDogbnVsbDtcblxuXHRcdFx0XHRpZiAodjEgPiAwICYmIHYyID4gMCkge1xuXHRcdFx0XHRcdHYxID0gYS5pZCA/IGlkcy5pbmRleE9mKGEuaWQpIDogbnVsbDtcblx0XHRcdFx0XHR2MiA9IGIuaWQgPyBpZHMuaW5kZXhPZihiLmlkKSA6IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdjEgLSB2Mjtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoL14oYXNjfGRlc2MpJC8udGVzdChvcmRlcikpIHtcblx0XHRcdGNvbnN0IGlzQXNjZW5kaW5nID0gb3JkZXIgPT09IFwiYXNjXCI7XG5cblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRjb25zdCB2MSA9IGEgPyBnZXRSb3dWYWx1ZShhKSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IHYyID0gYiA/IGdldFJvd1ZhbHVlKGIpIDogbnVsbDtcblxuXHRcdFx0XHRyZXR1cm4gaXNBc2NlbmRpbmcgPyB2MSAtIHYyIDogdjIgLSB2MTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcmRlcikpIHtcblx0XHRcdGQuc29ydChvcmRlcik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHBsID0gJCQuZ2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpO1xuXHRcdGxldCB0ZXh0O1xuXHRcdGxldCByb3c7XG5cdFx0bGV0IHBhcmFtO1xuXHRcdGxldCB2YWx1ZTtcblx0XHRsZXQgaTtcblxuXHRcdGZvciAoaSA9IDA7IChyb3cgPSBkW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAoIShnZXRSb3dWYWx1ZShyb3cpIHx8IGdldFJvd1ZhbHVlKHJvdykgPT09IDApKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQodGV4dCkpIHtcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSBzYW5pdGlzZSh0aXRsZUZvcm1hdCA/IHRpdGxlRm9ybWF0KHJvdy54KSA6IHJvdy54KTtcblxuXHRcdFx0XHR0ZXh0ID0gdHBsUHJvY2Vzcyh0cGxbMF0sIHtcblx0XHRcdFx0XHRDTEFTU19UT09MVElQOiBDTEFTUy50b29sdGlwLFxuXHRcdFx0XHRcdFRJVExFOiBpc1ZhbHVlKHRpdGxlKSA/IChcblx0XHRcdFx0XHRcdHRwbFN0ciA/IHRpdGxlIDogYDx0cj48dGggY29sc3Bhbj1cIjJcIj4ke3RpdGxlfTwvdGg+PC90cj5gXG5cdFx0XHRcdFx0KSA6IFwiXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHBhcmFtID0gW3Jvdy5yYXRpbywgcm93LmlkLCByb3cuaW5kZXgsIGRdO1xuXHRcdFx0dmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdChnZXRSb3dWYWx1ZShyb3cpLCAuLi5wYXJhbSkpO1xuXG5cdFx0XHRpZiAoJCQuaXNBcmVhUmFuZ2VUeXBlKHJvdykpIHtcblx0XHRcdFx0Y29uc3QgW2hpZ2gsIGxvd10gPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcCh2ID0+IHNhbml0aXNlKFxuXHRcdFx0XHRcdHZhbHVlRm9ybWF0KCQkLmdldEFyZWFSYW5nZURhdGEocm93LCB2KSwgLi4ucGFyYW0pXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdHZhbHVlID0gYDxiPk1pZDo8L2I+ICR7dmFsdWV9IDxiPkhpZ2g6PC9iPiAke2hpZ2h9IDxiPkxvdzo8L2I+ICR7bG93fWA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXG5cdFx0XHRcdGlmIChyb3cubmFtZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbmFtZSA9IHNhbml0aXNlKG5hbWVGb3JtYXQocm93Lm5hbWUsIC4uLnBhcmFtKSk7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gZ2V0QmdDb2xvcihyb3cpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUF9OQU1FOiBDTEFTUy50b29sdGlwTmFtZSArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHJvdy5pZCksXG5cdFx0XHRcdFx0Q09MT1I6ICh0cGxTdHIgfHwgISQkLnBhdHRlcm5zKSA/IGNvbG9yIDogYDxzdmc+PHJlY3Qgc3R5bGU9XCJmaWxsOiR7Y29sb3J9XCIgd2lkdGg9XCIxMFwiIGhlaWdodD1cIjEwXCI+PC9yZWN0Pjwvc3ZnPmAsXG5cdFx0XHRcdFx0TkFNRTogbmFtZSxcblx0XHRcdFx0XHRWQUxVRTogdmFsdWVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAodHBsU3RyICYmIGlzT2JqZWN0KGNvbnRlbnRzLnRleHQpKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoY29udGVudHMudGV4dCkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRcdFx0Y29udGVudFZhbHVlW2tleV0gPSBjb250ZW50cy50ZXh0W2tleV1baV07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0ICs9IHRwbFByb2Nlc3ModHBsWzFdLCBjb250ZW50VmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBgJHt0ZXh0fTwvdGFibGU+YDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBjb250ZW50IHRlbXBsYXRlIHN0cmluZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHBsU3RyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGVtcGxhdGUgc3RyaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cikge1xuXHRcdHJldHVybiAodHBsU3RyIHx8IGA8dGFibGUgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVB9XCI+PHRib2R5PlxuXHRcdFx0XHR7PVRJVExFfVxuXHRcdFx0XHR7ezx0ciBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPlxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cIm5hbWVcIj4ke3RoaXMucGF0dGVybnMgPyBgez1DT0xPUn1gIDogYDxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfVwiPjwvc3Bhbj5gfXs9TkFNRX08L3RkPlxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cInZhbHVlXCI+ez1WQUxVRX08L3RkPlxuXHRcdFx0XHQ8L3RyPn19XG5cdFx0XHQ8L3Rib2R5PjwvdGFibGU+YClcblx0XHRcdC5yZXBsYWNlKC8oXFxyP1xcbnxcXHQpL2csIFwiXCIpXG5cdFx0XHQuc3BsaXQoL3t7KC4qKX19Lyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVG9TaG93IGRhdGFcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRXaWR0aCBXaWR0aCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRIZWlnaHQgSGVpZ2h0IHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IHRvcCwgbGVmdCB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dG9vbHRpcFBvc2l0aW9uKGRhdGFUb1Nob3csIHRXaWR0aCwgdEhlaWdodCwgZWxlbWVudCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IFtsZWZ0LCB0b3BdID0gZDNNb3VzZShlbGVtZW50KTtcblxuXHRcdGNvbnN0IHN2Z0xlZnQgPSAkJC5nZXRTdmdMZWZ0KHRydWUpO1xuXHRcdGxldCBjaGFydFJpZ2h0ID0gc3ZnTGVmdCArICQkLmN1cnJlbnRXaWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKTtcblxuXHRcdHRvcCArPSAyMDtcblxuXHRcdC8vIERldGVybWluZSB0b29sdGlwIHBvc2l0aW9uXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSkge1xuXHRcdFx0Y29uc3QgcmF3ID0gJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgfHwgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xuXG5cdFx0XHRpZiAoIXJhdykge1xuXHRcdFx0XHR0b3AgKz0gJCQuaGVpZ2h0IC8gMjtcblx0XHRcdFx0bGVmdCArPSAoJCQud2lkdGggLSAoJCQuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwKSkgLyAyO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkYXRhU2NhbGUgPSAkJC54KGRhdGFUb1Nob3dbMF0ueCk7XG5cblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRcdHRvcCA9IGRhdGFTY2FsZSArIDIwO1xuXHRcdFx0XHRsZWZ0ICs9IHN2Z0xlZnQgKyAxMDA7XG5cdFx0XHRcdGNoYXJ0UmlnaHQgLT0gc3ZnTGVmdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvcCAtPSA1O1xuXHRcdFx0XHRsZWZ0ID0gc3ZnTGVmdCArICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh0cnVlKSArIDIwICsgKCQkLnpvb21TY2FsZSA/IGxlZnQgOiBkYXRhU2NhbGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRXaWR0aDtcblxuXHRcdGlmIChyaWdodCA+IGNoYXJ0UmlnaHQpIHtcblx0XHRcdC8vIDIwIGlzIG5lZWRlZCBmb3IgRmlyZWZveCB0byBrZWVwIHRvb2x0aXAgd2lkdGhcblx0XHRcdGxlZnQgLT0gcmlnaHQgLSBjaGFydFJpZ2h0ICsgMjA7XG5cdFx0fVxuXG5cdFx0aWYgKHRvcCArIHRIZWlnaHQgPiAkJC5jdXJyZW50SGVpZ2h0KSB7XG5cdFx0XHR0b3AgLT0gdEhlaWdodCArIDMwO1xuXHRcdH1cblxuXHRcdGlmICh0b3AgPCAwKSB7XG5cdFx0XHR0b3AgPSAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7dG9wLCBsZWZ0fTtcblx0fSxcblxuXHQvKipcblx0ICogU2hvdyB0aGUgdG9vbHRpcFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWREYXRhXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcblx0ICovXG5cdHNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgZWxlbWVudCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYmluZHRvID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZHRvO1xuXHRcdGNvbnN0IGZvckFyYyA9ICQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pO1xuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xuXHRcdGNvbnN0IHBvc2l0aW9uRnVuY3Rpb24gPSBjb25maWcudG9vbHRpcF9wb3NpdGlvbiB8fCAkJC50b29sdGlwUG9zaXRpb247XG5cblx0XHRpZiAoZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBkYXR1bSA9ICQkLnRvb2x0aXAuZGF0dW0oKTtcblx0XHRjb25zdCBkYXRhU3RyID0gSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWREYXRhKTtcblx0XHRsZXQgd2lkdGggPSAoZGF0dW0gJiYgZGF0dW0ud2lkdGgpIHx8IDA7XG5cdFx0bGV0IGhlaWdodCA9IChkYXR1bSAmJiBkYXR1bS5oZWlnaHQpIHx8IDA7XG5cblx0XHRpZiAoIWRhdHVtIHx8IGRhdHVtLmN1cnJlbnQgIT09IGRhdGFTdHIpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gc2VsZWN0ZWREYXRhLmNvbmNhdCgpLnNvcnQoKVswXS5pbmRleDtcblxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uc2hvdywgJCQpO1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBjb250ZW50XG5cdFx0XHQkJC50b29sdGlwXG5cdFx0XHRcdC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxuXHRcdFx0XHRcdHNlbGVjdGVkRGF0YSxcblx0XHRcdFx0XHQkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLFxuXHRcdFx0XHRcdCQkLmdldFlGb3JtYXQoZm9yQXJjKSxcblx0XHRcdFx0XHQkJC5jb2xvclxuXHRcdFx0XHQpKVxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgbnVsbCkgLy8gZm9yIElFOVxuXHRcdFx0XHQuZGF0dW0oe1xuXHRcdFx0XHRcdGluZGV4LFxuXHRcdFx0XHRcdGN1cnJlbnQ6IGRhdGFTdHIsXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoID0gJCQudG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldFdpZHRoXCIpLFxuXHRcdFx0XHRcdGhlaWdodDogaGVpZ2h0ID0gJCQudG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldEhlaWdodFwiKVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uc2hvd24sICQkKTtcblx0XHRcdCQkLl9oYW5kbGVMaW5rZWRDaGFydHModHJ1ZSwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdGlmICghYmluZHRvKSB7XG5cdFx0XHQvLyBHZXQgdG9vbHRpcCBkaW1lbnNpb25zXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uRnVuY3Rpb24uY2FsbCh0aGlzLCBkYXRhVG9TaG93LCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KTtcblxuXHRcdFx0Ly8gU2V0IHRvb2x0aXAgcG9zaXRpb25cblx0XHRcdCQkLnRvb2x0aXBcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsIGAke3Bvc2l0aW9uLnRvcH1weGApXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgYCR7cG9zaXRpb24ubGVmdH1weGApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHRvIGhpZGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhpZGVUb29sdGlwKGZvcmNlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghY29uZmlnLnRvb2x0aXBfZG9Ob3RIaWRlIHx8IGZvcmNlKSB7XG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRlLCAkJCk7XG5cblx0XHRcdC8vIGhpZGUgdG9vbHRpcFxuXHRcdFx0dGhpcy50b29sdGlwXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikgLy8gZm9yIElFOVxuXHRcdFx0XHQuZGF0dW0obnVsbCk7XG5cblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGRlbiwgJCQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIGRpc3BsYXkgZm9yIGxpbmtlZCBjaGFydCBpbnN0YW5jZXNcblx0ICogQHBhcmFtIHtCb29sZWFufSBzaG93IHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCB4IEF4aXMgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVMaW5rZWRDaGFydHMoc2hvdywgaW5kZXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuY29uZmlnLnRvb2x0aXBfbGlua2VkKSB7XG5cdFx0XHRjb25zdCBsaW5rZWROYW1lID0gJCQuY29uZmlnLnRvb2x0aXBfbGlua2VkX25hbWU7XG5cblx0XHRcdCgkJC5hcGkuaW50ZXJuYWwuY2hhcnRzIHx8IFtdKS5mb3JFYWNoKGMgPT4ge1xuXHRcdFx0XHRpZiAoYyAhPT0gJCQuYXBpKSB7XG5cdFx0XHRcdFx0Y29uc3QgY29uZmlnID0gYy5pbnRlcm5hbC5jb25maWc7XG5cdFx0XHRcdFx0Y29uc3QgaXNMaW5rZWQgPSBjb25maWcudG9vbHRpcF9saW5rZWQ7XG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xuXHRcdFx0XHRcdGNvbnN0IGlzSW5Eb20gPSBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGMuZWxlbWVudCk7XG5cblx0XHRcdFx0XHRpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gYy5pbnRlcm5hbC50b29sdGlwLmRhdGEoKVswXTtcblx0XHRcdFx0XHRcdGNvbnN0IGlzTm90U2FtZUluZGV4ID0gaW5kZXggIT09IChkYXRhICYmIGRhdGEuaW5kZXgpO1xuXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHRocm93aW5nIGVycm9yIGZvciBub24tcGFpcmVkIGxpbmtlZCBpbmRleGVzXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2hvdyAmJiBpc05vdFNhbWVJbmRleCkge1xuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5zaG93KHtpbmRleH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzaG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0Yy50b29sdGlwLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdGV2ZW50IGFzIGQzRXZlbnQsXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBjYWxsRm4sIGlzRGVmaW5lZCwgZ2V0T3B0aW9uLCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBub3RFbXB0eSwgdHBsUHJvY2Vzc30gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGxlZ2VuZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRMZWdlbmQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XG5cdFx0JCQubGVnZW5kSGFzUmVuZGVyZWQgPSBmYWxzZTtcblx0XHQkJC5sZWdlbmQgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKTtcblxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcblx0XHRcdCQkLmxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XG5cblx0XHRcdC8vIE1FTU86IGNhbGwgaGVyZSB0byB1cGRhdGUgbGVnZW5kIGJveCBhbmQgdHJhbnNsYXRlIGZvciBhbGxcblx0XHRcdC8vIE1FTU86IHRyYW5zbGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYnkgdGhpcywgc28gdHJhbnNmb3JtIG5vdCBuZWVkZWQgaW4gdXBkYXRlTGVnZW5kKClcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkJC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuXHRcdFx0JCQuaGlkZGVuTGVnZW5kSWRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBsZWdlbmQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aFRyYW5zZm9ybSA6IFdoZXRoZXIgdG8gdXNlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogV2hldGhlciB0cmFuc2l0aW9uIGlzIHVzZWQgd2hlbiB1c2luZyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb24gOiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbnMgUmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmQodGFyZ2V0SWRzLCBvcHRpb25zLCB0cmFuc2l0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgb3B0aW9ueiA9IG9wdGlvbnMgfHwge1xuXHRcdFx0d2l0aFRyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2Vcblx0XHR9O1xuXG5cdFx0b3B0aW9uei53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybVwiLCB0cnVlKTtcblxuXHRcdGlmIChjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0byAmJiBjb25maWcubGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlKSB7XG5cdFx0XHQkJC51cGRhdGVMZWdlbmRUZW1wbGF0ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkJC51cGRhdGVMZWdlbmRFbGVtZW50KFxuXHRcdFx0XHR0YXJnZXRJZHMgfHwgJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSxcblx0XHRcdFx0b3B0aW9ueixcblx0XHRcdFx0dHJhbnNpdGlvbnNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gdG9nZ2xlIGxlZ2VuZCBzdGF0ZVxuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4sIGlkID0+ICEkJC5pc1RhcmdldFRvU2hvdyhpZCkpO1xuXG5cdFx0Ly8gVXBkYXRlIHNpemUgYW5kIHNjYWxlXG5cdFx0JCQudXBkYXRlU2NhbGVzKGZhbHNlLCAhJCQuem9vbVNjYWxlKTtcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XG5cblx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcblx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xuXG5cdFx0JCQubGVnZW5kSGFzUmVuZGVyZWQgPSB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIHVzaW5nIHRlbXBsYXRlIG9wdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGVnZW5kVGVtcGxhdGUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB3cmFwcGVyID0gZDNTZWxlY3QoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8pO1xuXHRcdGNvbnN0IHRlbXBsYXRlID0gY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTtcblxuXHRcdGlmICghd3JhcHBlci5lbXB0eSgpKSB7XG5cdFx0XHRjb25zdCB0YXJnZXRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcblx0XHRcdGNvbnN0IGlkcyA9IFtdO1xuXHRcdFx0bGV0IGh0bWwgPSBcIlwiO1xuXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/XG5cdFx0XHRcdFx0dGVtcGxhdGUuY2FsbCgkJCwgdiwgJCQuY29sb3IodiksICQkLmFwaS5kYXRhKHYpWzBdLnZhbHVlcykgOlxuXHRcdFx0XHRcdHRwbFByb2Nlc3ModGVtcGxhdGUsIHtcblx0XHRcdFx0XHRcdENPTE9SOiAkJC5jb2xvcih2KSxcblx0XHRcdFx0XHRcdFRJVExFOiB2XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdFx0XHRpZHMucHVzaCh2KTtcblx0XHRcdFx0XHRodG1sICs9IGNvbnRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBsZWdlbmRJdGVtID0gd3JhcHBlci5odG1sKGh0bWwpXG5cdFx0XHRcdC5zZWxlY3RBbGwoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXM7IH0pXG5cdFx0XHRcdC5kYXRhKGlkcyk7XG5cblx0XHRcdCQkLnNldExlZ2VuZEl0ZW0obGVnZW5kSXRlbSk7XG5cblx0XHRcdCQkLmxlZ2VuZCA9IHdyYXBwZXI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIGxlZ2VuZC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmVqY3R9IHNpemUgU1xuXHQgKi9cblx0dXBkYXRlU2l6ZUZvckxlZ2VuZChzaXplKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuXG5cdFx0Y29uc3QgaW5zZXRMZWdlbmRQb3NpdGlvbiA9IHtcblx0XHRcdHRvcDogJCQuaXNMZWdlbmRUb3AgP1xuXHRcdFx0XHQkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpICsgY29uZmlnLmxlZ2VuZF9pbnNldF95ICsgNS41IDpcblx0XHRcdFx0JCQuY3VycmVudEhlaWdodCAtIGhlaWdodCAtICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkgLSBjb25maWcubGVnZW5kX2luc2V0X3ksXG5cdFx0XHRsZWZ0OiAkJC5pc0xlZ2VuZExlZnQgP1xuXHRcdFx0XHQkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNSA6XG5cdFx0XHRcdCQkLmN1cnJlbnRXaWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XG5cdFx0fTtcblxuXHRcdCQkLm1hcmdpbjMgPSB7XG5cdFx0XHR0b3A6ICQkLmlzTGVnZW5kUmlnaHQgP1xuXHRcdFx0XHQwIDogJCQuaXNMZWdlbmRJbnNldCA/IGluc2V0TGVnZW5kUG9zaXRpb24udG9wIDogJCQuY3VycmVudEhlaWdodCAtIGhlaWdodCxcblx0XHRcdHJpZ2h0OiBOYU4sXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAkJC5pc0xlZ2VuZFJpZ2h0ID9cblx0XHRcdFx0JCQuY3VycmVudFdpZHRoIC0gd2lkdGggOiAkJC5pc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi5sZWZ0IDogMFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybSBMZWdlbmRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxuXHQgKi9cblx0dHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQubGVnZW5kLnRyYW5zaXRpb24oKSA6ICQkLmxlZ2VuZClcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGVnZW5kIHN0ZXBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCkge1xuXHRcdHRoaXMubGVnZW5kU3RlcCA9IHN0ZXA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSB3aWR0aFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCh3KSB7XG5cdFx0dGhpcy5sZWdlbmRJdGVtV2lkdGggPSB3O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gaGVpZ2h0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQoaCkge1xuXHRcdHRoaXMubGVnZW5kSXRlbUhlaWdodCA9IGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoXG5cdCAqL1xuXHRnZXRMZWdlbmRXaWR0aCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuY29uZmlnLmxlZ2VuZF9zaG93ID8gKFxuXHRcdFx0JCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID9cblx0XHRcdFx0JCQubGVnZW5kSXRlbVdpZHRoICogKCQkLmxlZ2VuZFN0ZXAgKyAxKSA6ICQkLmN1cnJlbnRXaWR0aFxuXHRcdCkgOiAwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kXG5cdCAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMZWdlbmRIZWlnaHQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcblx0XHRcdCQkLmlzTGVnZW5kUmlnaHQgP1xuXHRcdFx0XHQkJC5jdXJyZW50SGVpZ2h0IDogTWF0aC5tYXgoMjAsICQkLmxlZ2VuZEl0ZW1IZWlnaHQpICogKCQkLmxlZ2VuZFN0ZXAgKyAxKVxuXHRcdCkgOiAwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuU2VsZWN0XG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IG9wYWNpdHlcblx0ICovXG5cdG9wYWNpdHlGb3JMZWdlbmQobGVnZW5kSXRlbSkge1xuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIxXCI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGVnZW5kIHRoYXQgaXMgdW5mb2N1c2VkXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmRJdGVtLCBkMy5TZWxlY3Rcblx0ICogQHJldHVybnMge051bWJlcn0gb3BhY2l0eVxuXHQgKi9cblx0b3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZChsZWdlbmRJdGVtKSB7XG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGVzIHRoZSBmb2N1cyBvZiB0aGUgbGVnZW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gZm9jdXMuXG5cdCAqL1xuXHR0b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZvY3VzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldElkeiA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG5cblx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHQuZmlsdGVyKGlkID0+IHRhcmdldElkei5pbmRleE9mKGlkKSA+PSAwKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZvY3VzKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKDEwMClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAoZm9jdXMgPyAkJC5vcGFjaXR5Rm9yTGVnZW5kIDogJCQub3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZClcblx0XHRcdFx0XHQuY2FsbCgkJCwgZDNTZWxlY3QodGhpcykpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldmVydCB0aGUgbGVnZW5kIHRvIGl0cyBkZWZhdWx0IHN0YXRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXZlcnRMZWdlbmQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKDEwMClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKGQzU2VsZWN0KHRoaXMpKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93cyB0aGUgbGVnZW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XG5cdCAqL1xuXHRzaG93TGVnZW5kKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIWNvbmZpZy5sZWdlbmRfc2hvdykge1xuXHRcdFx0Y29uZmlnLmxlZ2VuZF9zaG93ID0gdHJ1ZTtcblx0XHRcdCQkLmxlZ2VuZC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuXG5cdFx0XHQhJCQubGVnZW5kSGFzUmVuZGVyZWQgJiYgJCQudXBkYXRlTGVnZW5kKCk7XG5cdFx0fVxuXHRcdCQkLnJlbW92ZUhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xuXG5cdFx0JCQubGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgbGVnZW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XG5cdCAqL1xuXHRoaWRlTGVnZW5kKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93ICYmIGlzRW1wdHkodGFyZ2V0SWRzKSkge1xuXHRcdFx0Y29uZmlnLmxlZ2VuZF9zaG93ID0gZmFsc2U7XG5cdFx0XHQkJC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuXHRcdH1cblxuXHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2xlYXIgdGhlIExlZ2VuZEl0ZW1UZXh0Qm94IGNhY2hlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2xlYXJMZWdlbmRJdGVtVGV4dEJveENhY2hlKCkge1xuXHRcdHRoaXMubGVnZW5kSXRlbVRleHRCb3ggPSB7fTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGxlZ2VuZCBpdGVtIHN0eWxlICYgYmluZCBldmVudHNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGl0ZW1cblx0ICovXG5cdHNldExlZ2VuZEl0ZW0oaXRlbSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuXG5cdFx0aXRlbVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IGl0ZW1DbGFzcyA9ICghbm9kZS5lbXB0eSgpICYmIG5vZGUuYXR0cihcImNsYXNzXCIpKSB8fCBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBpdGVtQ2xhc3MgKyAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLmxlZ2VuZEl0ZW0sIGlkKTtcblx0XHRcdH0pXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgaWQgPT4ge1xuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgJCQsIGlkKSkge1xuXHRcdFx0XHRcdGlmIChkM0V2ZW50LmFsdEtleSkge1xuXHRcdFx0XHRcdFx0JCQuYXBpLmhpZGUoKTtcblx0XHRcdFx0XHRcdCQkLmFwaS5zaG93KGlkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JCQuYXBpLnRvZ2dsZShpZCk7XG5cdFx0XHRcdFx0XHQhaXNUb3VjaCAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkgPyAkJC5hcGkuZm9jdXMoaWQpIDogJCQuYXBpLnJldmVydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlzVG91Y2ggJiYgJCQuaGlkZVRvb2x0aXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKCFpc1RvdWNoKSB7XG5cdFx0XHRpdGVtXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3V0LCAkJCwgaWQpKSB7XG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdmVyLCAkJCwgaWQpKSB7XG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCB0cnVlKTtcblxuXHRcdFx0XHRcdFx0aWYgKCEkJC50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xuXHRcdFx0XHRcdFx0XHQkJC5hcGkuZm9jdXMoaWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aFRyYW5zZm9ybSA6IFdoZXRoZXIgdG8gdXNlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogV2hldGhlciB0cmFuc2l0aW9uIGlzIHVzZWQgd2hlbiB1c2luZyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb24gOiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxuIFx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZEVsZW1lbnQodGFyZ2V0SWRzLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcblx0XHRjb25zdCBwYWRkaW5nUmlnaHQgPSAxMDtcblx0XHRjb25zdCBwb3NNaW4gPSAxMDtcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XG5cdFx0bGV0IG1heFdpZHRoID0gMDtcblx0XHRsZXQgbWF4SGVpZ2h0ID0gMDtcblx0XHRsZXQgeEZvckxlZ2VuZDtcblx0XHRsZXQgeUZvckxlZ2VuZDtcblx0XHRsZXQgdG90YWxMZW5ndGggPSAwO1xuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcblx0XHRjb25zdCB3aWR0aHMgPSB7fTtcblx0XHRjb25zdCBoZWlnaHRzID0ge307XG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcblx0XHRjb25zdCBzdGVwcyA9IHt9O1xuXHRcdGxldCBzdGVwID0gMDtcblx0XHRsZXQgYmFja2dyb3VuZDtcblx0XHRjb25zdCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA9ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldDtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXG5cdFx0Y29uc3QgdGFyZ2V0SWR6ID0gdGFyZ2V0SWRzXG5cdFx0XHQuZmlsdGVyKGlkID0+ICFpc0RlZmluZWQoY29uZmlnLmRhdGFfbmFtZXNbaWRdKSB8fCBjb25maWcuZGF0YV9uYW1lc1tpZF0gIT09IG51bGwpO1xuXG5cdFx0Y29uc3Qgd2l0aFRyYW5zaXRpb24gPSBvcHRpb25zLndpdGhUcmFuc2l0aW9uO1xuXG5cdFx0Y29uc3QgZ2V0VGV4dEJveCA9IGZ1bmN0aW9uKHRleHRFbGVtZW50LCBpZCkge1xuXHRcdFx0aWYgKCEkJC5sZWdlbmRJdGVtVGV4dEJveFtpZF0pIHtcblx0XHRcdFx0JCQubGVnZW5kSXRlbVRleHRCb3hbaWRdID1cblx0XHRcdFx0XHQkJC5nZXRUZXh0UmVjdCh0ZXh0RWxlbWVudCwgQ0xBU1MubGVnZW5kSXRlbSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAkJC5sZWdlbmRJdGVtVGV4dEJveFtpZF07XG5cdFx0fTtcblxuXHRcdGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHRleHRFbGVtZW50LCBpZCwgaW5kZXgpIHtcblx0XHRcdGNvbnN0IHJlc2V0ID0gaW5kZXggPT09IDA7XG5cdFx0XHRjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDE7XG5cdFx0XHRjb25zdCBib3ggPSBnZXRUZXh0Qm94KHRleHRFbGVtZW50LCBpZCk7XG5cdFx0XHRjb25zdCBpdGVtV2lkdGggPSBib3gud2lkdGggKyB0aWxlV2lkdGggK1xuXHRcdFx0XHQoaXNMYXN0ICYmICFpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IDAgOiBwYWRkaW5nUmlnaHQpICsgY29uZmlnLmxlZ2VuZF9wYWRkaW5nO1xuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xuXHRcdFx0Y29uc3QgaXRlbUxlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gaXRlbUhlaWdodCA6IGl0ZW1XaWR0aDtcblx0XHRcdGNvbnN0IGFyZWFMZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/ICQkLmdldExlZ2VuZEhlaWdodCgpIDogJCQuZ2V0TGVnZW5kV2lkdGgoKTtcblx0XHRcdGxldCBtYXJnaW47XG5cblx0XHRcdC8vIE1FTU86IGNhcmUgYWJvdXQgY29uZGlmaW9uIG9mIHN0ZXAsIHRvdGFsTGVuZ3RoXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwKSB7XG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcblx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIHRvdGFsTGVuZ3RoIC0gaXRlbUxlbmd0aCkgLyAyO1xuXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xuXHRcdFx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XG5cdFx0XHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cdFx0XHRcdFx0XHRzdGVwKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RlcHNbaWQyXSA9IHN0ZXA7XG5cdFx0XHRcdG1hcmdpbnNbc3RlcF0gPSAkJC5pc0xlZ2VuZEluc2V0ID8gMTAgOiBtYXJnaW47XG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xuXHRcdFx0XHR0b3RhbExlbmd0aCArPSBpdGVtTGVuZ3RoO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHJlc2V0KSB7XG5cdFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcblx0XHRcdFx0c3RlcCA9IDA7XG5cdFx0XHRcdG1heFdpZHRoID0gMDtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdyAmJiAhJCQuaXNMZWdlbmRUb1Nob3coaWQpKSB7XG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xuXHRcdFx0XHRoZWlnaHRzW2lkXSA9IDA7XG5cdFx0XHRcdHN0ZXBzW2lkXSA9IDA7XG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHdpZHRoc1tpZF0gPSBpdGVtV2lkdGg7XG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XG5cblx0XHRcdGlmICghbWF4V2lkdGggfHwgaXRlbVdpZHRoID49IG1heFdpZHRoKSB7XG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgPSBpdGVtSGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXhMZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IG1heEhlaWdodCA6IG1heFdpZHRoO1xuXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XG5cdFx0XHRcdE9iamVjdC5rZXlzKHdpZHRocykuZm9yRWFjaChpZDIgPT4gKHdpZHRoc1tpZDJdID0gbWF4V2lkdGgpKTtcblx0XHRcdFx0T2JqZWN0LmtleXMoaGVpZ2h0cykuZm9yRWFjaChpZDIgPT4gKGhlaWdodHNbaWQyXSA9IG1heEhlaWdodCkpO1xuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcblxuXHRcdFx0XHRpZiAobWFyZ2luIDwgcG9zTWluKSB7XG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXHRcdFx0XHRcdHN0ZXAgPSAwO1xuXHRcdFx0XHRcdHRhcmdldElkei5mb3JFYWNoKGlkMiA9PiB1cGRhdGVWYWx1ZXMoaWQyKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXBkYXRlVmFsdWVzKGlkLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXBkYXRlVmFsdWVzKGlkKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKCQkLmlzTGVnZW5kSW5zZXQpIHtcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xuXHRcdFx0JCQudXBkYXRlTGVnZW5kU3RlcChzdGVwKTtcblx0XHR9XG5cblx0XHRpZiAoJCQuaXNMZWdlbmRSaWdodCkge1xuXHRcdFx0eEZvckxlZ2VuZCA9IGlkID0+IG1heFdpZHRoICogc3RlcHNbaWRdO1xuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNMZWdlbmRJbnNldCkge1xuXHRcdFx0eEZvckxlZ2VuZCA9IGlkID0+IG1heFdpZHRoICogc3RlcHNbaWRdICsgMTA7XG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XG5cdFx0fVxuXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGkpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xuXHRcdGNvbnN0IHhGb3JMZWdlbmRSZWN0ID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKTtcblx0XHRjb25zdCB4MUZvckxlZ2VuZFRpbGUgPSAoaWQsIGkpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMjtcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGkpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xuXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRleHQgPSAoaWQsIGkpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgOTtcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaSkgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xuXHRcdGNvbnN0IHlGb3JMZWdlbmRUaWxlID0gKGlkLCBpKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDQ7XG5cblx0XHRjb25zdCBwb3MgPSAtMjAwO1xuXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGxlZ2VuZCBhcmVhXG5cdFx0Y29uc3QgbCA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHRcdC5kYXRhKHRhcmdldElkeilcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcblxuXHRcdCQkLnNldExlZ2VuZEl0ZW0obCk7XG5cblx0XHRsLmFwcGVuZChcInRleHRcIilcblx0XHRcdC50ZXh0KGlkID0+IChpc0RlZmluZWQoY29uZmlnLmRhdGFfbmFtZXNbaWRdKSA/IGNvbmZpZy5kYXRhX25hbWVzW2lkXSA6IGlkKSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XG5cdFx0XHRcdHVwZGF0ZVBvc2l0aW9ucyh0aGlzLCBpZCwgaSk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG5cdFx0XHQuYXR0cihcInhcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4Rm9yTGVnZW5kVGV4dCA6IHBvcylcblx0XHRcdC5hdHRyKFwieVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUZXh0KTtcblxuXHRcdGwuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtRXZlbnQpXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuYXR0cihcInhcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4Rm9yTGVnZW5kUmVjdCA6IHBvcylcblx0XHRcdC5hdHRyKFwieVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRSZWN0KTtcblxuXHRcdGNvbnN0IHVzZVBvaW50ID0gJCQuY29uZmlnLmxlZ2VuZF91c2VQb2ludDtcblxuXHRcdGlmICh1c2VQb2ludCkge1xuXHRcdFx0Y29uc3QgaWRzID0gW107XG5cblx0XHRcdGwuYXBwZW5kKGQgPT4ge1xuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cblx0XHRcdFx0XHRjb25maWcucG9pbnRfcGF0dGVybiA6IFtjb25maWcucG9pbnRfdHlwZV07XG5cblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xuXG5cdFx0XHRcdGxldCBwb2ludCA9IHBhdHRlcm5baWRzLmluZGV4T2YoZCkgJSBwYXR0ZXJuLmxlbmd0aF07XG5cblx0XHRcdFx0aWYgKHBvaW50ID09PSBcInJlY3RhbmdsZVwiKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBcInJlY3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZDNOYW1lc3BhY2VzLnN2ZywgJCQuaGFzVmFsaWRQb2ludFR5cGUocG9pbnQpID8gcG9pbnQgOiBcInVzZVwiKTtcblx0XHRcdH0pXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVBvaW50KVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZCkpXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuXHRcdFx0XHQuYXR0cihcImhyZWZcIiwgKGRhdGEsIGlkeCwgc2VsZWN0aW9uKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgbm9kZSA9IHNlbGVjdGlvbltpZHhdO1xuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lID09PSBcInVzZVwiID8gYCMkeyQkLmRhdGV0aW1lSWR9LXBvaW50LSR7ZGF0YX1gIDogdW5kZWZpbmVkO1xuXHRcdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHgyRm9yTGVnZW5kVGlsZSA6IHBvcylcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxuXHRcdFx0XHQuYXR0cihcInN0cm9rZS13aWR0aFwiLCBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQpO1xuXHRcdH1cblxuXHRcdC8vIFNldCBiYWNrZ3JvdW5kIGZvciBpbnNldCBsZWdlbmRcblx0XHRiYWNrZ3JvdW5kID0gJCQubGVnZW5kLnNlbGVjdChgLiR7Q0xBU1MubGVnZW5kQmFja2dyb3VuZH0gcmVjdGApO1xuXG5cdFx0aWYgKCQkLmlzTGVnZW5kSW5zZXQgJiYgbWF4V2lkdGggPiAwICYmIGJhY2tncm91bmQuc2l6ZSgpID09PSAwKSB7XG5cdFx0XHRiYWNrZ3JvdW5kID0gJCQubGVnZW5kLmluc2VydChcImdcIiwgYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxuXHRcdFx0XHQuYXBwZW5kKFwicmVjdFwiKTtcblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0cyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG5cdFx0XHQuZGF0YSh0YXJnZXRJZHopXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpZCwgaSkge1xuXHRcdFx0XHR1cGRhdGVQb3NpdGlvbnModGhpcywgaWQsIGkpO1xuXHRcdFx0fSk7XG5cblx0XHQod2l0aFRyYW5zaXRpb24gPyB0ZXh0cy50cmFuc2l0aW9uKCkgOiB0ZXh0cylcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcblx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yTGVnZW5kVGV4dCk7XG5cblx0XHRjb25zdCByZWN0cyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcblx0XHRcdC5kYXRhKHRhcmdldElkeik7XG5cblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgaWQgPT4gd2lkdGhzW2lkXSlcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGlkID0+IGhlaWdodHNbaWRdKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRSZWN0KTtcblxuXG5cdFx0aWYgKHVzZVBvaW50KSB7XG5cdFx0XHRjb25zdCB0aWxlcyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW1Qb2ludH1gKVxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xuXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRSID0gJCQuY29uZmlnLnBvaW50X3I7XG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcblx0XHRcdFx0XHRsZXQgeSA9IFwieVwiO1xuXHRcdFx0XHRcdGxldCB4T2Zmc2V0ID0gMjtcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcblx0XHRcdFx0XHRsZXQgcmFkaXVzO1xuXHRcdFx0XHRcdGxldCB3aWR0aDtcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xuXG5cdFx0XHRcdFx0aWYgKG5vZGVOYW1lID09PSBcImNpcmNsZVwiKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xuXG5cdFx0XHRcdFx0XHR4ID0gXCJjeFwiO1xuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcblx0XHRcdFx0XHRcdHJhZGl1cyA9IHBvaW50UiArIHNpemU7XG5cdFx0XHRcdFx0XHR4T2Zmc2V0ID0gcG9pbnRSICogMjtcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcInJlY3RcIikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHBvaW50UiAqIDIuNTtcblxuXHRcdFx0XHRcdFx0d2lkdGggPSBzaXplO1xuXHRcdFx0XHRcdFx0aGVpZ2h0ID0gc2l6ZTtcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXG5cdFx0XHRcdFx0XHQuYXR0cih4LCBkID0+IHgxRm9yTGVnZW5kVGlsZShkKSArIHhPZmZzZXQpXG5cdFx0XHRcdFx0XHQuYXR0cih5LCBkID0+IHlGb3JMZWdlbmRUaWxlKGQpIC0geU9mZnNldClcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHRpbGVzID0gJCQubGVnZW5kLnNlbGVjdEFsbChgbGluZS4ke0NMQVNTLmxlZ2VuZEl0ZW1UaWxlfWApXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XG5cblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRpbGVzLnRyYW5zaXRpb24oKSA6IHRpbGVzKVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgeDFGb3JMZWdlbmRUaWxlKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIHlGb3JMZWdlbmRUaWxlKVxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5Rm9yTGVnZW5kVGlsZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGJhY2tncm91bmQpIHtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGJhY2tncm91bmQudHJhbnNpdGlvbigpIDogYmFja2dyb3VuZClcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBtYXhXaWR0aCAqIChzdGVwICsgMSkgKyAxMCk7XG5cdFx0fVxuXG5cdFx0Ly8gdG9nZ2xlIGxlZ2VuZCBzdGF0ZVxuXHRcdC8vICQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHQvLyBcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4sIGlkID0+ICEkJC5pc1RhcmdldFRvU2hvdyhpZCkpO1xuXG5cdFx0Ly8gVXBkYXRlIGFsbCB0byByZWZsZWN0IGNoYW5nZSBvZiBsZWdlbmRcblx0XHQkJC51cGRhdGVMZWdlbmRJdGVtV2lkdGgobWF4V2lkdGgpO1xuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcblx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc051bWJlciwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5cbi8qKlxuICogR2V0IHRoZSB0ZXh0IHBvc2l0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zIHJpZ2h0LCBsZWZ0IG9yIGNlbnRlclxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIGNoYXJ0IHdpZHRoXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfSB0ZXh0LWFuY2hvciB2YWx1ZSBvciBwb3NpdGlvbiBpbiBwaXhlbFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0VGV4dFBvcyA9IChwb3MgPSBcImxlZnRcIiwgd2lkdGgpID0+IHtcblx0bGV0IHBvc2l0aW9uO1xuXHRjb25zdCBpc051bSA9IGlzTnVtYmVyKHdpZHRoKTtcblxuXHRpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgPiAtMSkge1xuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCAvIDIgOiBcIm1pZGRsZVwiO1xuXHR9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikgPiAtMSkge1xuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCA6IFwiZW5kXCI7XG5cdH0gZWxzZSB7XG5cdFx0cG9zaXRpb24gPSBpc051bSA/IDAgOiBcInN0YXJ0XCI7XG5cdH1cblxuXHRyZXR1cm4gcG9zaXRpb247XG59O1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0aXRsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFRpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICgkJC5jb25maWcudGl0bGVfdGV4dCkge1xuXHRcdFx0JCQudGl0bGUgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKTtcblxuXHRcdFx0Y29uc3QgdGV4dCA9ICQkLnRpdGxlXG5cdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIGdldFRleHRQb3MoJCQuY29uZmlnLnRpdGxlX3Bvc2l0aW9uKSlcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy50aXRsZSk7XG5cblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCAkJC5jb25maWcudGl0bGVfdGV4dCwgWzAuMywgMS41XSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlZHJhd1RpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICgkJC50aXRsZSkge1xuXHRcdFx0Y29uc3QgeSA9ICQkLnlGb3JUaXRsZS5jYWxsKCQkKTtcblxuXHRcdFx0aWYgKC9nL2kudGVzdCgkJC50aXRsZS5ub2RlKCkudGFnTmFtZSkpIHtcblx0XHRcdFx0JCQudGl0bGUuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Z2V0VGV4dFBvcygkJC5jb25maWcudGl0bGVfcG9zaXRpb24sICQkLmN1cnJlbnRXaWR0aCl9LCAke3l9KWApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQudGl0bGUuYXR0cihcInhcIiwgJCQueEZvclRpdGxlLmNhbGwoJCQpKS5hdHRyKFwieVwiLCB5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHggYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGF0dHJpYnV0ZSB2YWx1ZVxuXHQgKi9cblx0eEZvclRpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBjb25maWcudGl0bGVfcG9zaXRpb24gfHwgXCJsZWZ0XCI7XG5cdFx0bGV0IHg7XG5cblx0XHRpZiAoLyhyaWdodHxjZW50ZXIpLy50ZXN0KHBvc2l0aW9uKSkge1xuXHRcdFx0eCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLmdldFRleHRSZWN0KCQkLnRpdGxlLCBDTEFTUy50aXRsZSkud2lkdGg7XG5cblx0XHRcdGlmIChwb3NpdGlvbi5pbmRleE9mKFwicmlnaHRcIikgPj0gMCkge1xuXHRcdFx0XHR4IC09IChjb25maWcudGl0bGVfcGFkZGluZy5yaWdodCB8fCAwKTtcblx0XHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaW5kZXhPZihcImNlbnRlclwiKSA+PSAwKSB7XG5cdFx0XHRcdHggLz0gMjtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBsZWZ0XG5cdFx0XHR4ID0gKGNvbmZpZy50aXRsZV9wYWRkaW5nLmxlZnQgfHwgMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHkgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGF0dHJpYnV0ZSB2YWx1ZVxuXHQgKi9cblx0eUZvclRpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAoJCQuY29uZmlnLnRpdGxlX3BhZGRpbmcudG9wIHx8IDApICtcblx0XHRcdCQkLmdldFRleHRSZWN0KCQkLnRpdGxlLCBDTEFTUy50aXRsZSkuaGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGl0bGUgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBwYWRkaW5nIHZhbHVlXG5cdCAqL1xuXHRnZXRUaXRsZVBhZGRpbmcoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLnlGb3JUaXRsZSgpICsgKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLmJvdHRvbSB8fCAwKTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRDbGlwKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdC8vIE1FTU86IGNsaXBJZCBuZWVkcyB0byBiZSB1bmlxdWUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgZXhpc3Rcblx0XHQkJC5jbGlwSWQgPSBgJHskJC5kYXRldGltZUlkfS1jbGlwYDtcblxuXHRcdCQkLmNsaXBJZEZvclhBeGlzID0gYCR7JCQuY2xpcElkfS14YXhpc2A7XG5cdFx0JCQuY2xpcElkRm9yWUF4aXMgPSBgJHskJC5jbGlwSWR9LXlheGlzYDtcblx0XHQkJC5jbGlwSWRGb3JHcmlkID0gYCR7JCQuY2xpcElkfS1ncmlkYDtcblxuXHRcdC8vIERlZmluZSAnY2xpcC1wYXRoJyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0JCQuY2xpcFBhdGggPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWQpO1xuXHRcdCQkLmNsaXBQYXRoRm9yWEF4aXMgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JYQXhpcyk7XG5cdFx0JCQuY2xpcFBhdGhGb3JZQXhpcyA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvcllBeGlzKTtcblx0XHQkJC5jbGlwUGF0aEZvckdyaWQgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JHcmlkKTtcblx0fSxcblxuXHRnZXRDbGlwUGF0aChpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoKCFjb25maWcuY2xpcFBhdGggJiYgLy1jbGlwJC8udGVzdChpZCkpIHx8XG5cdFx0XHQoIWNvbmZpZy5heGlzX3hfY2xpcFBhdGggJiYgLy1jbGlwLXhheGlzJC8udGVzdChpZCkpIHx8XG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBpc0lFOSA9IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxuXHRcdFx0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1zaWUgOS5cIikgPj0gMDtcblxuXHRcdHJldHVybiBgdXJsKCR7KGlzSUU5ID8gXCJcIiA6IGRvY3VtZW50LlVSTC5zcGxpdChcIiNcIilbMF0pfSMke2lkfSlgO1xuXHR9LFxuXG5cdGFwcGVuZENsaXAocGFyZW50LCBpZCkge1xuXHRcdHJldHVybiBwYXJlbnQuYXBwZW5kKFwiY2xpcFBhdGhcIilcblx0XHRcdC5hdHRyKFwiaWRcIiwgaWQpXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKTtcblx0fSxcblxuXHRnZXRBeGlzQ2xpcFgoZm9ySG9yaXpvbnRhbCkge1xuXHRcdC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcblx0XHRjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMzAsIHRoaXMubWFyZ2luLmxlZnQpO1xuXG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgPyAtKDEgKyBsZWZ0KSA6IC0obGVmdCAtIDEpO1xuXHR9LFxuXG5cdGdldEF4aXNDbGlwWShmb3JIb3Jpem9udGFsKSB7XG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgPyAtMjAgOiAtdGhpcy5tYXJnaW4udG9wO1xuXHR9LFxuXG5cdGdldFhBeGlzQ2xpcFgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwWCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwWSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBZKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fSxcblxuXHRnZXRZQXhpc0NsaXBYKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5jb25maWcuYXhpc195X2lubmVyID9cblx0XHRcdC0xIDogJCQuZ2V0QXhpc0NsaXBYKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldFlBeGlzQ2xpcFkoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwWSgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fSxcblxuXHRnZXRBeGlzQ2xpcFdpZHRoKGZvckhvcml6b250YWwpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbGVmdCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ubGVmdCk7XG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgJCQubWFyZ2luLnJpZ2h0KTtcblxuXHRcdC8vIHdpZHRoICsgYXhpcyBsaW5lIHdpZHRoICsgcGFkZGluZyBmb3IgbGVmdC9yaWdodFxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cblx0XHRcdCQkLndpZHRoICsgMiArIGxlZnQgKyByaWdodCA6ICQkLm1hcmdpbi5sZWZ0ICsgMjA7XG5cdH0sXG5cblx0Z2V0QXhpc0NsaXBIZWlnaHQoZm9ySG9yaXpvbnRhbCkge1xuXHRcdC8vIGxlc3MgdGhhbiAyMCBpcyBub3QgZW5vdWdoIHRvIHNob3cgdGhlIGF4aXMgbGFiZWwgJ291dGVyJyB3aXRob3V0IGxlZ2VuZFxuXHRcdHJldHVybiAoZm9ySG9yaXpvbnRhbCA/IHRoaXMubWFyZ2luLmJvdHRvbSA6ICh0aGlzLm1hcmdpbi50b3AgKyB0aGlzLmhlaWdodCkpICsgMjA7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwV2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldFhBeGlzQ2xpcEhlaWdodCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldFlBeGlzQ2xpcFdpZHRoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xuXHR9LFxuXG5cdGdldFlBeGlzQ2xpcEhlaWdodCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjsgLy8gc2VsZWN0aW9uXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2lzVmFsdWUsIGV4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aW5pdFJlZ2lvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5yZWdpb24gPSAkJC5tYWluLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5yZWdpb25zKTtcblx0fSxcblxuXHR1cGRhdGVSZWdpb24oZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxuXHRcdCQkLnJlZ2lvbi5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcblxuXHRcdC8vIHNlbGVjdCA8Zz4gZWxlbWVudFxuXHRcdCQkLm1haW5SZWdpb24gPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MucmVnaW9uc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MucmVnaW9ufWApXG5cdFx0XHQuZGF0YShjb25maWcucmVnaW9ucyk7XG5cblx0XHQkJC5tYWluUmVnaW9uLmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW5SZWdpb24gPSAkJC5tYWluUmVnaW9uLmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQubWVyZ2UoJCQubWFpblJlZ2lvbilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpO1xuXG5cdFx0JCQubWFpblJlZ2lvblxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XG5cdH0sXG5cblx0cmVkcmF3UmVnaW9uKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCByZWdpb25zID0gJCQubWFpblJlZ2lvbi5zZWxlY3QoXCJyZWN0XCIpO1xuXG5cdFx0cmVnaW9ucyA9ICh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucylcblx0XHRcdC5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQucmVnaW9uSGVpZ2h0LmJpbmQoJCQpKTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKSA6IHJlZ2lvbnMpXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBkID0+IChpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiBcIjAuMVwiKSlcblx0XHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSByZWN0IGFmdGVyIHRyYW5zaXRpb25cblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzLnBhcmVudE5vZGUpXG5cdFx0XHRcdFx0XHQuc2VsZWN0QWxsKFwicmVjdDpub3QoW3hdKVwiKVxuXHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0XHR9KVxuXHRcdF07XG5cdH0sXG5cblx0Z2V0UmVnaW9uWFkodHlwZSwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBpc1ggPSB0eXBlID09PSBcInhcIjtcblx0XHRsZXQga2V5ID0gXCJzdGFydFwiO1xuXHRcdGxldCBzY2FsZTtcblx0XHRsZXQgcG9zID0gMDtcblxuXHRcdGlmIChkLmF4aXMgPT09IFwieVwiIHx8IGQuYXhpcyA9PT0gXCJ5MlwiKSB7XG5cdFx0XHRpZiAoIWlzWCkge1xuXHRcdFx0XHRrZXkgPSBcImVuZFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XG5cdFx0XHRcdHNjYWxlID0gJCRbZC5heGlzXTtcblx0XHRcdFx0cG9zID0gc2NhbGUoZFtrZXldKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKChpc1ggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xuXHRcdFx0c2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblx0XHRcdHBvcyA9IHNjYWxlKCQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGRba2V5XSkgOiBkW2tleV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBwb3M7XG5cdH0sXG5cblx0cmVnaW9uWChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ4XCIsIGQpO1xuXHR9LFxuXG5cdHJlZ2lvblkoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieVwiLCBkKTtcblx0fSxcblxuXHRnZXRSZWdpb25TaXplKHR5cGUsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgaXNXaWR0aCA9IHR5cGUgPT09IFwid2lkdGhcIjtcblx0XHRjb25zdCBzdGFydCA9ICQkW2lzV2lkdGggPyBcInJlZ2lvblhcIiA6IFwicmVnaW9uWVwiXShkKTtcblx0XHRsZXQgc2NhbGU7XG5cdFx0bGV0IGtleSA9IFwiZW5kXCI7XG5cdFx0bGV0IGVuZCA9ICQkW3R5cGVdO1xuXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcblx0XHRcdGlmICghaXNXaWR0aCkge1xuXHRcdFx0XHRrZXkgPSBcInN0YXJ0XCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoaXNXaWR0aCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XG5cdFx0XHRcdHNjYWxlID0gJCRbZC5heGlzXTtcblx0XHRcdFx0ZW5kID0gc2NhbGUoZFtrZXldKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKChpc1dpZHRoID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcblx0XHRcdHNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cdFx0XHRlbmQgPSBzY2FsZSgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkW2tleV0pIDogZFtrZXldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XG5cdH0sXG5cblx0cmVnaW9uV2lkdGgoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblNpemUoXCJ3aWR0aFwiLCBkKTtcblx0fSxcblxuXHRyZWdpb25IZWlnaHQoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblNpemUoXCJoZWlnaHRcIiwgZCk7XG5cdH0sXG5cblx0aXNSZWdpb25PblgoZCkge1xuXHRcdHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRQYXRoQm94fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZy5cblx0ICogRGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgT2JqZWN0XG5cdCAqL1xuXHRkcmFnKG1vdXNlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHxcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXG5cdFx0XHQoY29uZmlnLnpvb21fZW5hYmxlZCAmJiAhJCQuem9vbS5hbHREb21haW4pIHx8IC8vIHNraXAgaWYgem9vbWFibGUgYmVjYXVzZSBvZiBjb25mbGljdCBkcmFnIGJlaGF2aW9yXG5cdFx0XHQhY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlIC8vIHNraXAgd2hlbiBzaW5nbGUgc2VsZWN0aW9uIGJlY2F1c2UgZHJhZyBpcyB1c2VkIGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBbc3gsIHN5XSA9ICQkLmRyYWdTdGFydDtcblx0XHRjb25zdCBbbXgsIG15XSA9IG1vdXNlO1xuXG5cdFx0Y29uc3QgbWluWCA9IE1hdGgubWluKHN4LCBteCk7XG5cdFx0Y29uc3QgbWF4WCA9IE1hdGgubWF4KHN4LCBteCk7XG5cdFx0Y29uc3QgbWluWSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gJCQubWFyZ2luLnRvcCA6IE1hdGgubWluKHN5LCBteSk7XG5cdFx0Y29uc3QgbWF4WSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gJCQuaGVpZ2h0IDogTWF0aC5tYXgoc3ksIG15KTtcblxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIG1pblgpXG5cdFx0XHQuYXR0cihcInlcIiwgbWluWSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4WCAtIG1pblgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBtYXhZIC0gbWluWSk7XG5cblx0XHQvLyBUT0RPOiBiaW5hcnkgc2VhcmNoIHdoZW4gbXVsdGlwbGUgeHNcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmZpbHRlcihkID0+IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcblx0XHRcdFx0Y29uc3QgaXNJbmNsdWRlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQpO1xuXHRcdFx0XHRsZXQgdG9nZ2xlO1xuXHRcdFx0XHRsZXQgaXNXaXRoaW4gPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5jaXJjbGUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNoYXBlLmF0dHIoXCJjeFwiKSAqIDE7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IHNoYXBlLmF0dHIoXCJjeVwiKSAqIDE7XG5cblx0XHRcdFx0XHR0b2dnbGUgPSAkJC50b2dnbGVQb2ludDtcblx0XHRcdFx0XHRpc1dpdGhpbiA9IG1pblggPCB4ICYmIHggPCBtYXhYICYmIG1pblkgPCB5ICYmIHkgPCBtYXhZO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSkge1xuXHRcdFx0XHRcdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IGdldFBhdGhCb3godGhpcyk7XG5cblx0XHRcdFx0XHR0b2dnbGUgPSAkJC50b2dnbGVQYXRoO1xuXHRcdFx0XHRcdGlzV2l0aGluID0gIShtYXhYIDwgeCB8fCB4ICsgd2lkdGggPCBtaW5YKSAmJiAhKG1heFkgPCB5IHx8IHkgKyBoZWlnaHQgPCBtaW5ZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBsaW5lL2FyZWEgc2VsZWN0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzV2l0aGluIF4gaXNJbmNsdWRlZCkge1xuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsICFpc0luY2x1ZGVkKTtcblx0XHRcdFx0XHQvLyBUT0RPOiBpbmNsdWRlZC91bmluY2x1ZGVkIGNhbGxiYWNrIGhlcmVcblx0XHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCAhaXNTZWxlY3RlZCk7XG5cdFx0XHRcdFx0dG9nZ2xlLmNhbGwoJCQsICFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBzdGFydHMuXG5cdCAqIEFkZHMgYW5kIFNob3dzIHRoZSBkcmFnIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSBPYmplY3Rcblx0ICovXG5cdGRyYWdzdGFydChtb3VzZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLmRyYWdTdGFydCA9IG1vdXNlO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5kcmFnYXJlYSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwLjFcIik7XG5cblx0XHQkJC5zZXREcmFnU3RhdHVzKHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBmaW5pc2hlcy5cblx0ICogUmVtb3ZlcyB0aGUgZHJhZyBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZHJhZ2VuZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHsgLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKDEwMClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcblx0XHRcdC5jbGFzc2VkKENMQVNTLklOQ0xVREVELCBmYWxzZSk7XG5cblx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcblx0fSxcblxuXHRzZXREcmFnU3RhdHVzKGlzRHJhZ2dpbmcpIHtcblx0XHR0aGlzLmRyYWdnaW5nID0gaXNEcmFnZ2luZztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtyZ2IgYXMgZDNSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmQsIGNhbGxGbn0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIFNlbGVjdCBhIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHRzZWxlY3RQb2ludCh0YXJnZXQsIGQsIGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgY3ggPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGN5ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKS5iaW5kKCQkKTtcblx0XHRjb25zdCByID0gJCQucG9pbnRTZWxlY3RSLmJpbmQoJCQpO1xuXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG5cblx0XHQvLyBhZGQgc2VsZWN0ZWQtY2lyY2xlIG9uIGxvdyBsYXllciBnXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX0tJHtpfWApXG5cdFx0XHQuZGF0YShbZF0pXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImNpcmNsZVwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoKSA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlLCBpKSlcblx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXG5cdFx0XHQuYXR0cihcImN5XCIsIGN5KVxuXHRcdFx0LmF0dHIoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHQuYXR0cihcInJcIiwgZDIgPT4gJCQucG9pbnRTZWxlY3RSKGQyKSAqIDEuNClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuYXR0cihcInJcIiwgcik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVuZWxlY3QgYSBwb2ludFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKi9cblx0dW5zZWxlY3RQb2ludCh0YXJnZXQsIGQsIGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRjYWxsRm4oJCQuY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xuXG5cdFx0Ly8gcmVtb3ZlIHNlbGVjdGVkLWNpcmNsZSBmcm9tIGxvdyBsYXllciBnXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX0tJHtpfWApXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxuXHRcdFx0LmF0dHIoXCJyXCIsIDApXG5cdFx0XHQucmVtb3ZlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBwb2ludHNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHR0b2dnbGVQb2ludChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpKSB7XG5cdFx0Y29uc3QgbWV0aG9kID0gYCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBvaW50YDtcblxuXHRcdHRoaXNbbWV0aG9kXSh0YXJnZXQsIGQsIGkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZWxlY3QgYSBwYXRoXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcGF0aFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cblx0c2VsZWN0UGF0aCh0YXJnZXQsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLCBkLCB0YXJnZXQubm9kZSgpKTtcblxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcblx0XHRcdHRhcmdldC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+IGQzUmdiKCQkLmNvbG9yKGQpKS5icmlnaHRlcigwLjc1KSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbmVsZWN0IGEgcGF0aFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBhdGhcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICovXG5cdHVuc2VsZWN0UGF0aCh0YXJnZXQsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gJCQuY29sb3IoZCkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIGxpbmVzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKi9cblx0dG9nZ2xlUGF0aChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpKSB7XG5cdFx0dGhpc1tcblx0XHRcdGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQYXRoYFxuXHRcdF0odGFyZ2V0LCBkLCBpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdG9nZ2xlIG1ldGhvZCBvZiB0aGUgdGFyZ2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSB0b2dnbGUgbWV0aG9kXG5cdCAqL1xuXHRnZXRUb2dnbGUodGhhdCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiB0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIiA/XG5cdFx0XHQkJC50b2dnbGVQYXRoIDogKFxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cblx0XHRcdFx0XHQoKSA9PiB7fSA6IC8vIGNpcmNsZSBpcyBoaWRkZW4gaW4gc3RlcCBjaGFydCwgc28gdHJlYXQgYXMgd2l0aGluIHRoZSBjbGljayBhcmVhXG5cdFx0XHRcdFx0JCQudG9nZ2xlUG9pbnRcblx0XHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBzaGFwZXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBzaGFwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICovXG5cdHRvZ2dsZVNoYXBlKHRoYXQsIGQsIGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XG5cdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGF0LCBkKS5iaW5kKCQkKTtcblx0XHRsZXQgdG9nZ2xlZFNoYXBlO1xuXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpIHtcblx0XHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XG5cdFx0XHRcdGxldCBzZWxlY3RvciA9IGAuJHtDTEFTUy5zaGFwZXN9YDtcblxuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQpIHtcblx0XHRcdFx0XHRzZWxlY3RvciArPSAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKHNlbGVjdG9yKVxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpKSB7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZWRTaGFwZSA9IHNoYXBlO1xuXHRcdFx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdG9nZ2xlZFNoYXBlIHx8IHRvZ2dsZWRTaGFwZS5ub2RlKCkgIT09IHNoYXBlLm5vZGUoKSkge1xuXHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCAhaXNTZWxlY3RlZCk7XG5cdFx0XHRcdHRvZ2dsZSghaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRldmVudCBhcyBkM0V2ZW50XG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7XG5cdGJydXNoWCBhcyBkM0JydXNoWCxcblx0YnJ1c2hZIGFzIGQzQnJ1c2hZLFxuXHRicnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9uXG59IGZyb20gXCJkMy1icnVzaFwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgYnJ1c2hFbXB0eSwgY2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgZ2V0UmFuZG9tfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRCcnVzaCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHQvLyBzZXQgdGhlIGJydXNoXG5cdFx0JCQuYnJ1c2ggPSBpc1JvdGF0ZWQgPyBkM0JydXNoWSgpIDogZDNCcnVzaFgoKTtcblxuXHRcdC8vIHNldCBcImJydXNoXCIgZXZlbnRcblx0XHRjb25zdCBicnVzaEhhbmRsZXIgPSAoKSA9PiB7XG5cdFx0XHQkJC5yZWRyYXdGb3JCcnVzaCgpO1xuXHRcdH07XG5cdFx0Y29uc3QgZ2V0QnJ1c2hTaXplID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgYnJ1c2ggPSAkJC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH0gLm92ZXJsYXlgKTtcblx0XHRcdGNvbnN0IGJydXNoU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuXHRcdFx0aWYgKGJydXNoLnNpemUoKSkge1xuXHRcdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBicnVzaFNpemVbaXNSb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XG5cdFx0fTtcblxuXHRcdGxldCBsYXN0RG9tYWluO1xuXHRcdGxldCB0aW1lb3V0O1xuXG5cdFx0JCQuYnJ1c2hcblx0XHRcdC5vbihcInN0YXJ0XCIsICgpID0+IHtcblx0XHRcdFx0JCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcblx0XHRcdFx0YnJ1c2hIYW5kbGVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwiYnJ1c2hcIiwgYnJ1c2hIYW5kbGVyKVxuXHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHtcblx0XHRcdFx0bGFzdERvbWFpbiA9ICQkLngub3JnRG9tYWluKCk7XG5cdFx0XHR9KTtcblxuXHRcdCQkLmJydXNoLnVwZGF0ZVJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0bGFzdERvbWFpbiAmJiBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbi5ub2RlKCkpICYmXG5cdFx0XHRcdFx0dGhpcy5tb3ZlKHNlbGVjdGlvbiwgbGFzdERvbWFpbi5tYXAoJCQuc3ViWC5vcmdTY2FsZSgpKSk7XG5cdFx0XHR9LCAwKTtcblx0XHR9O1xuXG5cdFx0JCQuYnJ1c2gudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLmV4dGVudCgpKCk7XG5cblx0XHRcdGlmIChleHRlbnRbMV0uZmlsdGVyKHYgPT4gaXNOYU4odikpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHQkJC5jb250ZXh0ICYmICQkLmNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5jYWxsKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gc2V0IHRoZSBicnVzaCBleHRlbnRcblx0XHQkJC5icnVzaC5zY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0XHRjb25zdCBoID0gY29uZmlnLnN1YmNoYXJ0X3NpemVfaGVpZ2h0IHx8IGdldEJydXNoU2l6ZSgpO1xuXHRcdFx0bGV0IGV4dGVudCA9ICQkLmdldEV4dGVudCgpO1xuXG5cdFx0XHRpZiAoIWV4dGVudCAmJiBzY2FsZS5yYW5nZSkge1xuXHRcdFx0XHRleHRlbnQgPSBbWzAsIDBdLCBbc2NhbGUucmFuZ2UoKVsxXSwgaF1dO1xuXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KGV4dGVudCkpIHtcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50Lm1hcCgodiwgaSkgPT4gW3YsIGkgPiAwID8gaCA6IGldKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gW1t4MCwgeTBdLCBbeDEsIHkxXV0sIHdoZXJlIFt4MCwgeTBdIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgYW5kIFt4MSwgeTFdIGlzIHRoZSBib3R0b20tcmlnaHQgY29ybmVyXG5cdFx0XHRpc1JvdGF0ZWQgJiYgZXh0ZW50WzFdLnJldmVyc2UoKTtcblx0XHRcdHRoaXMuZXh0ZW50KGV4dGVudCk7XG5cblx0XHRcdC8vIHdoZW4gZXh0ZW50IHVwZGF0ZXMsIGJydXNoIHNlbGVjdGlvbiBhbHNvIGJlIHJlLWFwcGxpZWRcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9pc3N1ZXMvMjkxOFxuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXG5cdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uID0gKCkgPT4gKFxuXHRcdFx0JCQuY29udGV4dCA/ICQkLmNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKSA6IGQzU2VsZWN0KFtdKVxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHN1YmNoYXJ0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFN1YmNoYXJ0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdmlzaWJpbGl0eSA9IGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xuXHRcdGNvbnN0IGNsaXBJZCA9IGAkeyQkLmNsaXBJZH0tc3ViY2hhcnRgO1xuXHRcdGNvbnN0IGNsaXBQYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcElkKTtcblxuXHRcdCQkLmNsaXBJZEZvclN1YmNoYXJ0ID0gY2xpcElkO1xuXHRcdCQkLmFwcGVuZENsaXAoJCQuZGVmcywgY2xpcElkKTtcblx0XHQkJC5pbml0QnJ1c2goKTtcblxuXHRcdCQkLmNvbnRleHQgPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImNvbnRleHRcIikpO1xuXG5cdFx0Y29uc3QgY29udGV4dCA9ICQkLmNvbnRleHQ7XG5cblx0XHRjb250ZXh0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCB2aXNpYmlsaXR5KTtcblxuXHRcdC8vIERlZmluZSBnIGZvciBjaGFydCBhcmVhXG5cdFx0Y29udGV4dC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpO1xuXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGJhciBjaGFydCBhcmVhXG5cdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgbGluZSBjaGFydCBhcmVhXG5cdFx0Y29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcblxuXHRcdC8vIEFkZCBleHRlbnQgcmVjdCBmb3IgQnJ1c2hcblx0XHRjb250ZXh0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5icnVzaClcblx0XHRcdC5jYWxsKCQkLmJydXNoKTtcblxuXHRcdC8vIEFUVEVOVElPTjogVGhpcyBtdXN0IGJlIGNhbGxlZCBBRlRFUiBjaGFydCBhZGRlZFxuXHRcdC8vIEFkZCBBeGlzXG5cdFx0JCQuYXhlcy5zdWJ4ID0gY29udGV4dC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXNYKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3VieFwiKSlcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIlwiIDogJCQuY2xpcFBhdGhGb3JYQXhpcylcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ID8gdmlzaWJpbGl0eSA6IFwiaGlkZGVuXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgc3ViIGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkJC5kYXRhLnRhcmdldHNcblx0ICovXG5cdHVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbnRleHQgPSAkJC5jb250ZXh0O1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0FyZWFzID0gJCQuY2xhc3NBcmVhcy5iaW5kKCQkKTtcblxuXHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xuXHRcdFx0Ly8gLS0gQmFyIC0tLy9cblx0XHRcdGNvbnN0IGNvbnRleHRCYXJVcGRhdGUgPSBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXG5cdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcik7XG5cdFx0XHRjb25zdCBjb250ZXh0QmFyRW50ZXIgPSBjb250ZXh0QmFyVXBkYXRlLmVudGVyKClcblx0XHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxuXHRcdFx0XHQubWVyZ2UoY29udGV4dEJhclVwZGF0ZSk7XG5cblx0XHRcdC8vIEJhcnMgZm9yIGVhY2ggZGF0YVxuXHRcdFx0Y29udGV4dEJhckVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcnMpO1xuXG5cdFx0XHQvLyAtLSBMaW5lIC0tLy9cblx0XHRcdGNvbnN0IGNvbnRleHRMaW5lVXBkYXRlID0gY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0TGluZXN9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpO1xuXHRcdFx0Y29uc3QgY29udGV4dExpbmVFbnRlciA9IGNvbnRleHRMaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKVxuXHRcdFx0XHQubWVyZ2UoY29udGV4dExpbmVVcGRhdGUpO1xuXG5cdFx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXG5cdFx0XHRjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcblxuXHRcdFx0Ly8gQXJlYVxuXHRcdFx0JCQuaGFzVHlwZShcImFyZWFcIikgJiYgY29udGV4dExpbmVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmVhcyk7XG5cblx0XHRcdC8vIC0tIEJydXNoIC0tLy9cblx0XHRcdGNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5icnVzaH0gcmVjdGApXG5cdFx0XHRcdC5hdHRyKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGgyIDogJCQuaGVpZ2h0Mik7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGJhciBvZiB0aGUgc3ViIGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkdXJhdGlvbkZvckV4aXRcblx0ICovXG5cdHVwZGF0ZUJhckZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNvbnRleHRCYXIgPSAkJC5jb250ZXh0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxuXHRcdFx0LmRhdGEoJCQuYmFyRGF0YS5iaW5kKCQkKSk7XG5cblx0XHQkJC5jb250ZXh0QmFyXG5cdFx0XHQuZXhpdCgpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLmNvbnRleHRCYXIgPSAkJC5jb250ZXh0QmFyXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NCYXIuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgXCJub25lXCIpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxuXHRcdFx0Lm1lcmdlKCQkLmNvbnRleHRCYXIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBiYXIgb2YgdGhlIHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGJhclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXdCYXJGb3JTdWJjaGFydChkcmF3QmFyT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGNvbnRleHRCYXIgPSB3aXRoVHJhbnNpdGlvbiA/XG5cdFx0XHR0aGlzLmNvbnRleHRCYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDpcblx0XHRcdHRoaXMuY29udGV4dEJhcjtcblxuXHRcdGNvbnRleHRCYXIuYXR0cihcImRcIiwgZHJhd0Jhck9uU3ViKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGluZSBvZiB0aGUgc3ViIGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHR1cGRhdGVMaW5lRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY29udGV4dExpbmUgPSAkJC5jb250ZXh0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmV9YClcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcblxuXHRcdCQkLmNvbnRleHRMaW5lXG5cdFx0XHQuZXhpdCgpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLmNvbnRleHRMaW5lID0gJCQuY29udGV4dExpbmVcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHQubWVyZ2UoJCQuY29udGV4dExpbmUpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBsaW5lIG9mIHRoZSBzdWJjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBsaW5lXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHJhbnNpdGlvbiBkdXJhdGlvblxuXHQgKi9cblx0cmVkcmF3TGluZUZvclN1YmNoYXJ0KGRyYXdMaW5lT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGNvbnRleHRMaW5lID0gd2l0aFRyYW5zaXRpb24gP1xuXHRcdFx0dGhpcy5jb250ZXh0TGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxuXHRcdFx0dGhpcy5jb250ZXh0TGluZTtcblxuXHRcdGNvbnRleHRMaW5lLmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBhcmVhIG9mIHRoZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHVwZGF0ZUFyZWFGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYX1gKVxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuXG5cdFx0JCQuY29udGV4dEFyZWFcblx0XHRcdC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQuY29udGV4dEFyZWEgPSAkJC5jb250ZXh0QXJlYVxuXHRcdFx0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkJC5vcmdBcmVhT3BhY2l0eSA9IGQzU2VsZWN0KHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiKTtcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xuXHRcdFx0fSlcblx0XHRcdC5tZXJnZSgkJC5jb250ZXh0QXJlYSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xuXHR9LFxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBhcmVhIG9mIHRoZSBzdWJjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBsaW5lXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHJhbnNpdGlvbiBkdXJhdGlvblxuXHQgKi9cblx0cmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGNvbnRleHRBcmVhID0gd2l0aFRyYW5zaXRpb24gP1xuXHRcdFx0dGhpcy5jb250ZXh0QXJlYS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxuXHRcdFx0dGhpcy5jb250ZXh0QXJlYTtcblxuXHRcdGNvbnRleHRBcmVhLmF0dHIoXCJkXCIsIGRyYXdBcmVhT25TdWIpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMub3JnQXJlYU9wYWNpdHkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgc3ViY2hhcnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIGR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZSBTaGFwZSdzIGluZm9cblx0ICovXG5cdHJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLmNvbnRleHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcblxuXHRcdC8vIHN1YmNoYXJ0XG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XG5cdFx0XHQvLyByZWZsZWN0IG1haW4gY2hhcnQgdG8gZXh0ZW50IG9uIHN1YmNoYXJ0IGlmIHpvb21lZFxuXHRcdFx0aWYgKGQzRXZlbnQgJiYgZDNFdmVudC50eXBlID09PSBcInpvb21cIikge1xuXHRcdFx0XHQkJC5icnVzaC51cGRhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHN1YmNoYXJ0IGVsZW1lbnRzIGlmIG5lZWRlZFxuXHRcdFx0aWYgKHdpdGhTdWJjaGFydCkge1xuXHRcdFx0XHQvLyBleHRlbnQgcmVjdFxuXHRcdFx0XHQhYnJ1c2hFbXB0eSgkJCkgJiYgJCQuYnJ1c2gudXBkYXRlKCk7XG5cblx0XHRcdFx0T2JqZWN0LmtleXMoc2hhcGUudHlwZSkuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gY2FwaXRhbGl6ZSh2KTtcblx0XHRcdFx0XHRjb25zdCBkcmF3ID0gJCRbYGdlbmVyYXRlRHJhdyR7bmFtZX1gXShzaGFwZS5pbmRpY2VzW3ZdLCB0cnVlKTtcblxuXHRcdFx0XHRcdCQkW2B1cGRhdGUke25hbWV9Rm9yU3ViY2hhcnRgXShkdXJhdGlvbik7XG5cdFx0XHRcdFx0JCRbYHJlZHJhdyR7bmFtZX1Gb3JTdWJjaGFydGBdKGRyYXcsIGR1cmF0aW9uLCBkdXJhdGlvbik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBicnVzaC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlZHJhd0ZvckJydXNoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XHR3aXRoWTogJCQuY29uZmlnLnpvb21fcmVzY2FsZSxcblx0XHRcdHdpdGhTdWJjaGFydDogZmFsc2UsXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXG5cdFx0fSk7XG5cblx0XHQkJC5jb25maWcuc3ViY2hhcnRfb25icnVzaC5jYWxsKCQkLmFwaSwgJCQueC5vcmdEb21haW4oKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybSBjb250ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5kaWNhdGVzIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9ucyBtZXRob2Qgb2YgQXhpcy5cblx0ICovXG5cdHRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBzdWJYQXhpcztcblxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzU3ViWCkge1xuXHRcdFx0c3ViWEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzU3ViWDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ViWEF4aXMgPSAkJC5jb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YCk7XG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHsgc3ViWEF4aXMgPSBzdWJYQXhpcy50cmFuc2l0aW9uKCk7IH1cblx0XHR9XG5cblx0XHQkJC5jb250ZXh0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XG5cdFx0c3ViWEF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJzdWJ4XCIpKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGV4dGVudCB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IGRlZmF1bHQgZXh0ZW50XG5cdCAqL1xuXHRnZXRFeHRlbnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBleHRlbnQgPSAkJC5jb25maWcuYXhpc194X2V4dGVudDtcblxuXHRcdGlmIChleHRlbnQpIHtcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGV4dGVudCkpIHtcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50KCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSwgJCQuc3ViWCk7XG5cdFx0XHR9IGVsc2UgaWYgKCQkLmlzVGltZVNlcmllcygpICYmIGV4dGVudC5ldmVyeShpc05hTikpIHtcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50Lm1hcCh2ID0+ICQkLnN1YlgoJCQucGFyc2VEYXRlKHYpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV4dGVudDtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRtb3VzZSBhcyBkM01vdXNlLFxuXHRldmVudCBhcyBkM0V2ZW50LFxuXHRzZWxlY3QgYXMgZDNTZWxlY3Rcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7em9vbSBhcyBkM1pvb219IGZyb20gXCJkMy16b29tXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBjYWxsRm4sIGRpZmZEb21haW4sIGdldE1pbk1heCwgaXNEZWZpbmVkfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHpvb20uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0Wm9vbSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC56b29tU2NhbGUgPSBudWxsO1xuXG5cdFx0JCQuZ2VuZXJhdGVab29tKCk7XG5cdFx0JCQuaW5pdFpvb21CZWhhdmlvdXIoKTtcblx0fSxcblxuXHQvKipcblx0ICogQmluZCB6b29tIGV2ZW50XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYmluZCBXZWF0aGVyIGJpbmQgb3IgdW5ib3VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZFpvb21FdmVudChiaW5kID0gdHJ1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9ICQkLmNvbmZpZy56b29tX2VuYWJsZWQ7XG5cblx0XHQkJC5yZWRyYXdFdmVudFJlY3QoKTtcblxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcblxuXHRcdGlmICh6b29tRW5hYmxlZCAmJiBiaW5kKSB7XG5cdFx0XHQkJC5iaW5kWm9vbU9uRXZlbnRSZWN0KGV2ZW50UmVjdHMsIHpvb21FbmFibGVkLnR5cGUpO1xuXHRcdH0gZWxzZSBpZiAoYmluZCA9PT0gZmFsc2UpIHtcblx0XHRcdCQkLmFwaS51bnpvb20oKTtcblxuXHRcdFx0ZXZlbnRSZWN0c1xuXHRcdFx0XHQub24oXCIuem9vbVwiLCBudWxsKVxuXHRcdFx0XHQub24oXCIuZHJhZ1wiLCBudWxsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHpvb21cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlWm9vbSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uc3Qgem9vbSA9IGQzWm9vbSgpLmR1cmF0aW9uKDApXG5cdFx0XHQub24oXCJzdGFydFwiLCAkJC5vblpvb21TdGFydC5iaW5kKCQkKSlcblx0XHRcdC5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKVxuXHRcdFx0Lm9uKFwiZW5kXCIsICQkLm9uWm9vbUVuZC5iaW5kKCQkKSk7XG5cblx0XHQvLyBnZXQgem9vbSBleHRlbnRcblx0XHR6b29tLm9yZ1NjYWxlRXh0ZW50ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZXh0ZW50ID0gY29uZmlnLnpvb21fZXh0ZW50IHx8IFsxLCAxMF07XG5cblx0XHRcdHJldHVybiBbZXh0ZW50WzBdLCBNYXRoLm1heCgkJC5nZXRNYXhEYXRhQ291bnQoKSAvIGV4dGVudFsxXSwgZXh0ZW50WzFdKV07XG5cdFx0fTtcblxuXHRcdHpvb20udXBkYXRlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHJhdGlvID0gZGlmZkRvbWFpbigkJC54Lm9yZ0RvbWFpbigpKSAvIGRpZmZEb21haW4oJCQuZ2V0Wm9vbURvbWFpbigpKTtcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcblxuXHRcdFx0dGhpcy5zY2FsZUV4dGVudChbZXh0ZW50WzBdICogcmF0aW8sIGV4dGVudFsxXSAqIHJhdGlvXSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgc2NhbGUgYWNjb3JkaW5nIHpvb20gdHJhbnNmb3JtIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0em9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSA9IHRyYW5zZm9ybSA9PiB7XG5cdFx0XHQvLyBpbiBjYXNlIG9mIHJlc2l6ZSwgdXBkYXRlIHJhbmdlIG9mIG9yZ1hTY2FsZVxuXHRcdFx0JCQub3JnWFNjYWxlICYmICQkLm9yZ1hTY2FsZS5yYW5nZSgkJC54LnJhbmdlKCkpO1xuXG5cdFx0XHQvLyByZXNjYWxlIGZyb20gdGhlIG9yaWdpbmFsIHNjYWxlXG5cdFx0XHRjb25zdCBuZXdTY2FsZSA9IHRyYW5zZm9ybVtcblx0XHRcdFx0Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwicmVzY2FsZVlcIiA6IFwicmVzY2FsZVhcIlxuXHRcdFx0XSgkJC5vcmdYU2NhbGUgfHwgJCQueCk7XG5cblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnRyaW1YRG9tYWluKG5ld1NjYWxlLmRvbWFpbigpKTtcblx0XHRcdGNvbnN0IHJlc2NhbGUgPSBjb25maWcuem9vbV9yZXNjYWxlO1xuXG5cdFx0XHRuZXdTY2FsZS5kb21haW4oZG9tYWluLCAkJC5vcmdYRG9tYWluKTtcblxuXHRcdFx0JCQuem9vbVNjYWxlID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKTtcblx0XHRcdCQkLnhBeGlzLnNjYWxlKCQkLnpvb21TY2FsZSk7XG5cblx0XHRcdGlmIChyZXNjYWxlKSB7XG5cdFx0XHRcdC8vIGNvcHkgY3VycmVudCBpbml0aWFsIHggc2NhbGUgaW4gY2FzZSBvZiByZXNjYWxlIG9wdGlvbiBpcyB1c2VkXG5cdFx0XHRcdCEkJC5vcmdYU2NhbGUgJiYgKCQkLm9yZ1hTY2FsZSA9ICQkLnguY29weSgpKTtcblx0XHRcdFx0JCQueC5kb21haW4oZG9tYWluKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0JCQuem9vbSA9IHpvb207XG5cdH0sXG5cblx0LyoqXG5cdCAqICdzdGFydCcgZXZlbnQgbGlzdGVuZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uWm9vbVN0YXJ0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQ7XG5cblx0XHRpZiAoIWV2ZW50KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQuem9vbS5zdGFydEV2ZW50ID0gZXZlbnQ7XG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy56b29tX29uem9vbXN0YXJ0LCAkJC5hcGksIGV2ZW50KTtcblx0fSxcblxuXHQvKipcblx0ICogJ3pvb20nIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvblpvb20oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XG5cblx0XHRpZiAoXG5cdFx0XHQhY29uZmlnLnpvb21fZW5hYmxlZCB8fFxuXHRcdFx0IWV2ZW50LnNvdXJjZUV2ZW50IHx8XG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID09PSAwXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNNb3VzZW1vdmUgPSBldmVudC5zb3VyY2VFdmVudC50eXBlID09PSBcIm1vdXNlbW92ZVwiO1xuXHRcdGNvbnN0IGlzWm9vbU91dCA9IGV2ZW50LnNvdXJjZUV2ZW50LndoZWVsRGVsdGEgPCAwO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcblxuXHRcdGlmICghaXNNb3VzZW1vdmUgJiYgaXNab29tT3V0ICYmICQkLnguZG9tYWluKCkuZXZlcnkoKHYsIGkpID0+IHYgIT09ICQkLm9yZ1hEb21haW5baV0pKSB7XG5cdFx0XHQkJC54LmRvbWFpbigkJC5vcmdYRG9tYWluKTtcblx0XHR9XG5cblx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKHRyYW5zZm9ybSk7XG5cblx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpICYmICQkLngub3JnRG9tYWluKClbMF0gPT09ICQkLm9yZ1hEb21haW5bMF0pIHtcblx0XHRcdCQkLnguZG9tYWluKFskJC5vcmdYRG9tYWluWzBdIC0gMWUtMTAsICQkLngub3JnRG9tYWluKClbMV1dKTtcblx0XHR9XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXG5cdFx0XHR3aXRoRGltZW5zaW9uOiBmYWxzZVxuXHRcdH0pO1xuXG5cdFx0JCQuY2FuY2VsQ2xpY2sgPSBpc01vdXNlbW92ZTtcblx0XHRjYWxsRm4oY29uZmlnLnpvb21fb256b29tLCAkJC5hcGksICQkLnpvb21TY2FsZS5kb21haW4oKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqICdlbmQnIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvblpvb21FbmQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHN0YXJ0RXZlbnQgPSAkJC56b29tLnN0YXJ0RXZlbnQ7XG5cblx0XHQvLyBpZiBjbGljaywgZG8gbm90aGluZy4gb3RoZXJ3aXNlLCBjbGljayBpbnRlcmFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuXHRcdGlmICghc3RhcnRFdmVudCB8fFxuXHRcdFx0KGV2ZW50ICYmIHN0YXJ0RXZlbnQuY2xpZW50WCA9PT0gZXZlbnQuY2xpZW50WCAmJiBzdGFydEV2ZW50LmNsaWVudFkgPT09IGV2ZW50LmNsaWVudFkpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XG5cdFx0JCQudXBkYXRlWm9vbSgpO1xuXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy56b29tX29uem9vbWVuZCwgJCQuYXBpLCAkJFskJC56b29tU2NhbGUgPyBcInpvb21TY2FsZVwiIDogXCJzdWJYXCJdLmRvbWFpbigpKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHpvb20gZG9tYWluXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gem9vbSBkb21haW5cbiBcdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRab29tRG9tYWluKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IFttaW4sIG1heF0gPSAkJC5vcmdYRG9tYWluO1xuXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21pbikpIHtcblx0XHRcdG1pbiA9IGdldE1pbk1heChcIm1pblwiLCBbbWluLCBjb25maWcuem9vbV94X21pbl0pO1xuXHRcdH1cblxuXHRcdGlmIChpc0RlZmluZWQoY29uZmlnLnpvb21feF9tYXgpKSB7XG5cdFx0XHRtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW21heCwgY29uZmlnLnpvb21feF9tYXhdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHpvb21cblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSB1bnpvb21cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZVpvb20oZm9yY2UpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuem9vbVNjYWxlKSB7XG5cdFx0XHRjb25zdCB6b29tRG9tYWluID0gJCQuem9vbVNjYWxlLmRvbWFpbigpO1xuXHRcdFx0Y29uc3QgeERvbWFpbiA9ICQkLnN1YlguZG9tYWluKCk7XG5cdFx0XHRjb25zdCBkZWx0YSA9IDAuMDE1OyAvLyBhcmJpdHJhcnkgdmFsdWVcblxuXHRcdFx0Y29uc3QgaXNmdWxseVNob3duID0gKHpvb21Eb21haW5bMF0gPD0geERvbWFpblswXSB8fCAoem9vbURvbWFpblswXSAtIGRlbHRhKSA8PSB4RG9tYWluWzBdKSAmJlxuXHRcdFx0XHQoeERvbWFpblsxXSA8PSB6b29tRG9tYWluWzFdIHx8IHhEb21haW5bMV0gPD0gKHpvb21Eb21haW5bMV0gLSBkZWx0YSkpO1xuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGUgem9vbWVkIGNoYXJ0IGlzIGZ1bGx5IHNob3duLCB0aGVuIHJlc2V0IHNjYWxlIHdoZW4gem9vbSBpcyBvdXQgYXMgaW5pdGlhbFxuXHRcdFx0aWYgKGZvcmNlIHx8IGlzZnVsbHlTaG93bikge1xuXHRcdFx0XHQkJC54QXhpcy5zY2FsZSgkJC5zdWJYKTtcblx0XHRcdFx0JCQueC5kb21haW4oJCQuc3ViWC5vcmdEb21haW4oKSk7XG5cdFx0XHRcdCQkLnpvb21TY2FsZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBdHRhY2ggem9vbSBldmVudCBvbiA8cmVjdD5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGJpbmRab29tT25FdmVudFJlY3QoZXZlbnRSZWN0cywgdHlwZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBiZWhhdmlvdXIgPSB0eXBlID09PSBcImRyYWdcIiA/ICQkLnpvb21CZWhhdmlvdXIgOiAkJC56b29tO1xuXG5cdFx0ZXZlbnRSZWN0c1xuXHRcdFx0LmNhbGwoYmVoYXZpb3VyKVxuXHRcdFx0Lm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgZHJhZyBiZWhhdmlvdXIgdXNlZCBmb3Igem9vbWluZy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRab29tQmVoYXZpb3VyKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRsZXQgc3RhcnQgPSAwO1xuXHRcdGxldCBlbmQgPSAwO1xuXHRcdGxldCB6b29tUmVjdCA9IG51bGw7XG5cblx0XHRjb25zdCBwcm9wID0ge1xuXHRcdFx0YXhpczogaXNSb3RhdGVkID8gXCJ5XCIgOiBcInhcIixcblx0XHRcdGF0dHI6IGlzUm90YXRlZCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG5cdFx0XHRpbmRleDogaXNSb3RhdGVkID8gMSA6IDBcblx0XHR9O1xuXG5cdFx0JCQuem9vbUJlaGF2aW91ciA9IGQzRHJhZygpXG5cdFx0XHQuY2xpY2tEaXN0YW5jZSg0KVxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCF6b29tUmVjdCkge1xuXHRcdFx0XHRcdHpvb21SZWN0ID0gJCQubWFpbi5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aClcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbUJydXNoKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IDApXG5cdFx0XHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCBpc1JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXJ0ID0gZDNNb3VzZSh0aGlzKVtwcm9wLmluZGV4XTtcblx0XHRcdFx0ZW5kID0gc3RhcnQ7XG5cblx0XHRcdFx0em9vbVJlY3Rcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIHN0YXJ0KVxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XG5cblx0XHRcdFx0JCQub25ab29tU3RhcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRlbmQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xuXG5cdFx0XHRcdHpvb21SZWN0XG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBNYXRoLm1pbihzdGFydCwgZW5kKSlcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIE1hdGguYWJzKGVuZCAtIHN0YXJ0KSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblxuXHRcdFx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcblxuXHRcdFx0XHR6b29tUmVjdFxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgMClcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIDApO1xuXG5cdFx0XHRcdGlmIChzdGFydCA+IGVuZCkge1xuXHRcdFx0XHRcdFtzdGFydCwgZW5kXSA9IFtlbmQsIHN0YXJ0XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGFydCA8IDApIHtcblx0XHRcdFx0XHRlbmQgKz0gTWF0aC5hYnMoc3RhcnQpO1xuXHRcdFx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGFydCAhPT0gZW5kKSB7XG5cdFx0XHRcdFx0JCQuYXBpLnpvb20oW3N0YXJ0LCBlbmRdLm1hcCh2ID0+IHNjYWxlLmludmVydCh2KSkpO1xuXHRcdFx0XHRcdCQkLm9uWm9vbUVuZCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQgfHwgZDNFdmVudDtcblx0XHRcdFx0XHRcdGNvbnN0IFt4LCB5XSA9IFwiY2xpZW50WFwiIGluIGV2ZW50ID8gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldIDogW2V2ZW50LngsIGV2ZW50LnldO1xuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcblxuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRhcmdldCkoZDNTZWxlY3QodGFyZ2V0KS5kYXR1bSgpLCAkJCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXHRzZXRab29tUmVzZXRCdXR0b24oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCByZXNldEJ1dHRvbiA9IGNvbmZpZy56b29tX3Jlc2V0QnV0dG9uO1xuXG5cdFx0aWYgKHJlc2V0QnV0dG9uICYmIGNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCIpIHtcblx0XHRcdGlmICghJCQuem9vbS5yZXNldEJ0bikge1xuXHRcdFx0XHQkJC56b29tLnJlc2V0QnRuID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uLCB0cnVlKVxuXHRcdFx0XHRcdC5hcHBlbmQoXCJzcGFuXCIpXG5cdFx0XHRcdFx0Lm9uKFwiY2xpY2tcIiwgJCQuYXBpLnVuem9vbS5iaW5kKCQkKSlcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5idXR0b25ab29tUmVzZXQsIHRydWUpXG5cdFx0XHRcdFx0LnRleHQocmVzZXRCdXR0b24udGV4dCB8fCBcIlJlc2V0IFpvb21cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkJC56b29tLnJlc2V0QnRuLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2NhbGVPcmRpbmFsIGFzIGQzU2NhbGVPcmRpbmFsfSBmcm9tIFwiZDMtc2NhbGVcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7bm90RW1wdHksIGV4dGVuZCwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzU3RyaW5nfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8qKlxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXG4gKiAoaXQgYWRkcyBhIDxyZWN0PiBlbGVtZW50IHRvIHNpbXVsYXRlIGJnLWNvbG9yKVxuICogQHBhcmFtIHtTVkdQYXR0ZXJuRWxlbWVudH0gcGF0dGVybiBTVkcgcGF0dGVybiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgSUQgdG8gYmUgc2V0XG4gKiBAcmV0dXJuIHt7aWQ6IHN0cmluZywgbm9kZTogU1ZHUGF0dGVybkVsZW1lbnR9fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY29sb3JpemVQYXR0ZXJuID0gKHBhdHRlcm4sIGNvbG9yLCBpZCkgPT4ge1xuXHRjb25zdCBub2RlID0gZDNTZWxlY3QocGF0dGVybi5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdG5vZGVcblx0XHQuYXR0cihcImlkXCIsIGlkKVxuXHRcdC5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpXG5cdFx0LmF0dHIoXCJ3aWR0aFwiLCBub2RlLmF0dHIoXCJ3aWR0aFwiKSlcblx0XHQuYXR0cihcImhlaWdodFwiLCBub2RlLmF0dHIoXCJoZWlnaHRcIikpXG5cdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cblx0cmV0dXJuIHtcblx0XHRpZCxcblx0XHRub2RlOiBub2RlLm5vZGUoKVxuXHR9O1xufTtcblxuLy8gUmVwbGFjZW1lbnQgb2YgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5cbi8vIENvbnRhaW5lZCBkaWZmZXJlbnRseSBkZXBlbmQgb24gZDMgdmVyc2lvbjogdjQoZDMtc2NhbGUpLCB2NShkMy1zY2FsZS1jaHJvbWF0aWMpXG5jb25zdCBzY2hlbWVDYXRlZ29yeTEwID0gW1wiIzFmNzdiNFwiLCBcIiNmZjdmMGVcIiwgXCIjMmNhMDJjXCIsIFwiI2Q2MjcyOFwiLCBcIiM5NDY3YmRcIiwgXCIjOGM1NjRiXCIsIFwiI2UzNzdjMlwiLCBcIiM3ZjdmN2ZcIiwgXCIjYmNiZDIyXCIsIFwiIzE3YmVjZlwiXTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZXQgY29sb3IgcGF0dGVybiBmcm9tIENTUyBmaWxlXG5cdCAqIENTUyBzaG91bGQgYmUgZGVmaW5lZCBhczogYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiIzAwYzczYzsjZmE3MTcxOyAuLi5cIik7XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q29sb3JGcm9tQ3NzKCkge1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCJfX2NvbG9yUGF0dGVybl9fXCI7XG5cdFx0Y29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0bGV0IHBhdHRlcm4gPSBib2R5W2NhY2hlS2V5XTtcblxuXHRcdGlmICghcGF0dGVybikge1xuXHRcdFx0Y29uc3QgZGVsaW1pdGVyID0gXCI7XCI7XG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cblx0XHRcdHNwYW4uY2xhc3NOYW1lID0gQ0xBU1MuY29sb3JQYXR0ZXJuO1xuXHRcdFx0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xuXG5cdFx0XHRjb25zdCBjb250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuYmFja2dyb3VuZEltYWdlO1xuXG5cdFx0XHRzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XG5cblx0XHRcdGlmIChjb250ZW50LmluZGV4T2YoZGVsaW1pdGVyKSA+IC0xKSB7XG5cdFx0XHRcdHBhdHRlcm4gPSBjb250ZW50XG5cdFx0XHRcdFx0LnJlcGxhY2UoL3VybFteI10qfFtcIicoKV18KFxcc3wlMjApL2csIFwiXCIpXG5cdFx0XHRcdFx0LnNwbGl0KGRlbGltaXRlcilcblx0XHRcdFx0XHQubWFwKHYgPT4gdi50cmltKCkucmVwbGFjZSgvW1xcXCInXFxzXS9nLCBcIlwiKSlcblx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdFx0XHRcdGJvZHlbY2FjaGVLZXldID0gcGF0dGVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0dGVybjtcblx0fSxcblxuXHRnZW5lcmF0ZUNvbG9yKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY29sb3JzID0gY29uZmlnLmRhdGFfY29sb3JzO1xuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XG5cdFx0Y29uc3QgaWRzID0gW107XG5cblx0XHRsZXQgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5jb2xvcl9wYXR0ZXJuKSA/IGNvbmZpZy5jb2xvcl9wYXR0ZXJuIDpcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XG5cblx0XHRjb25zdCBvcmlnaW5hbENvbG9yUGF0dGVybiA9IHBhdHRlcm47XG5cblx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcuY29sb3JfdGlsZXMpKSB7XG5cdFx0XHRjb25zdCB0aWxlcyA9IGNvbmZpZy5jb2xvcl90aWxlcygpO1xuXG5cdFx0XHQvLyBBZGQgYmFja2dyb3VuZCBjb2xvciB0byBwYXR0ZXJuc1xuXHRcdFx0Y29uc3QgY29sb3JpemVkUGF0dGVybnMgPSBwYXR0ZXJuLm1hcCgocCwgaW5kZXgpID0+IHtcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBwLnJlcGxhY2UoL1sjXFwoXFwpXFxzLF0vZywgXCJcIik7XG5cdFx0XHRcdGNvbnN0IGlkID0gYCR7JCQuZGF0ZXRpbWVJZH0tcGF0dGVybi0ke2NvbG9yfS0ke2luZGV4fWA7XG5cblx0XHRcdFx0cmV0dXJuIGNvbG9yaXplUGF0dGVybih0aWxlc1tpbmRleCAlIHRpbGVzLmxlbmd0aF0sIHAsIGlkKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRwYXR0ZXJuID0gY29sb3JpemVkUGF0dGVybnMubWFwKHAgPT4gYHVybCgjJHtwLmlkfSlgKTtcblx0XHRcdCQkLnBhdHRlcm5zID0gY29sb3JpemVkUGF0dGVybnM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IGlkID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcblx0XHRcdGNvbnN0IGlzTGluZSA9ICQkLmlzVHlwZU9mKGlkLCBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwic3RlcFwiXSkgfHwgISQkLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcblx0XHRcdGxldCBjb2xvcjtcblxuXHRcdFx0Ly8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWRcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbG9yc1tpZF0pKSB7XG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXShkKTtcblxuXHRcdFx0Ly8gaWYgc3BlY2lmaWVkLCBjaG9vc2UgdGhhdCBjb2xvclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXTtcblxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxuXHRcdFx0XHRcdHBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgcGF0dGVybi5sZW5ndGhdO1xuXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cblx0XHRcdFx0Y2FsbGJhY2soY29sb3IsIGQpIDogY29sb3I7XG5cdFx0fTtcblx0fSxcblxuXHRnZW5lcmF0ZUxldmVsQ29sb3IoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjb2xvcnMgPSBjb25maWcuY29sb3JfcGF0dGVybjtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSBjb25maWcuY29sb3JfdGhyZXNob2xkO1xuXG5cdFx0Y29uc3QgYXNWYWx1ZSA9IHRocmVzaG9sZC51bml0ID09PSBcInZhbHVlXCI7XG5cdFx0Y29uc3QgbWF4ID0gdGhyZXNob2xkLm1heCB8fCAxMDA7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhyZXNob2xkLnZhbHVlcyAmJlxuXHRcdFx0dGhyZXNob2xkLnZhbHVlcy5sZW5ndGggPyB0aHJlc2hvbGQudmFsdWVzIDogW107XG5cblx0XHRyZXR1cm4gbm90RW1wdHkodGhyZXNob2xkKSA/IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRsZXQgY29sb3IgPSBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgdiwgdmFsOyAodmFsID0gdmFsdWVzW2ldKTsgaSsrKSB7XG5cdFx0XHRcdHYgPSBhc1ZhbHVlID8gdmFsdWUgOiAodmFsdWUgKiAxMDAgLyBtYXgpO1xuXG5cdFx0XHRcdGlmICh2IDwgdmFsKSB7XG5cdFx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbG9yO1xuXHRcdH0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRhdGEgb3ZlciBjb2xvci5cblx0ICogV2hlbiBpcyBvdXQsIHdpbGwgcmVzdG9yZSBpbiBpdHMgcHJldmlvdXMgY29sb3IgdmFsdWVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc092ZXIgdHJ1ZTogc2V0IG92ZXJlZCBjb2xvciwgZmFsc2U6IHJlc3RvcmVcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldE92ZXJDb2xvcihpc092ZXIsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG9ub3ZlciA9IGNvbmZpZy5jb2xvcl9vbm92ZXI7XG5cdFx0bGV0IGNvbG9yID0gaXNPdmVyID8gb25vdmVyIDogJCQuY29sb3I7XG5cblx0XHRpZiAoaXNPYmplY3QoY29sb3IpKSB7XG5cdFx0XHRjb2xvciA9IGQgPT4ge1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuaWQ7XG5cblx0XHRcdFx0cmV0dXJuIGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3IpKSB7XG5cdFx0XHRjb2xvciA9ICgpID0+IG9ub3Zlcjtcblx0XHR9XG5cblx0XHQvLyB3aGVuIGlzIEFyYyB0eXBlXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfS0ke2QuaWR9YClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcihkKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBjb2xvcihkKTtcblxuXHRcdFx0XHRcdHRoaXMuc3R5bGUuc3Ryb2tlID0gdmFsO1xuXHRcdFx0XHRcdHRoaXMuc3R5bGUuZmlsbCA9IHZhbDtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7aXNWYWx1ZSwgaXNGdW5jdGlvbiwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuY29uc3QgZ2V0Rm9ybWF0ID0gKCQkLCB0eXBlVmFsdWUsIHYpID0+IHtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRjb25zdCB0eXBlID0gYGF4aXNfJHt0eXBlVmFsdWV9X3RpY2tfZm9ybWF0YDtcblx0Y29uc3QgZm9ybWF0ID0gY29uZmlnW3R5cGVdID9cblx0XHRjb25maWdbdHlwZV0gOiAkJC5kZWZhdWx0VmFsdWVGb3JtYXQ7XG5cblx0cmV0dXJuIGZvcm1hdCh2KTtcbn07XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZXRZRm9ybWF0KGZvckFyYykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgZm9ybWF0Rm9yWSA9ICQkLnlGb3JtYXQ7XG5cdFx0bGV0IGZvcm1hdEZvclkyID0gJCQueTJGb3JtYXQ7XG5cblx0XHRpZiAoZm9yQXJjICYmICEkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGZvcm1hdEZvclkgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XG5cdFx0XHRmb3JtYXRGb3JZMiA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odiwgcmF0aW8sIGlkKSB7XG5cdFx0XHRjb25zdCBmb3JtYXQgPSAkJC5heGlzLmdldElkKGlkKSA9PT0gXCJ5MlwiID9cblx0XHRcdFx0Zm9ybWF0Rm9yWTIgOiBmb3JtYXRGb3JZO1xuXG5cdFx0XHRyZXR1cm4gZm9ybWF0LmNhbGwoJCQsIHYsIHJhdGlvKTtcblx0XHR9O1xuXHR9LFxuXG5cdHlGb3JtYXQodikge1xuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xuXHR9LFxuXG5cdHkyRm9ybWF0KHYpIHtcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieTJcIiwgdik7XG5cdH0sXG5cblx0ZGVmYXVsdFZhbHVlRm9ybWF0KHYpIHtcblx0XHRyZXR1cm4gaXNWYWx1ZSh2KSA/ICt2IDogXCJcIjtcblx0fSxcblxuXHRkZWZhdWx0QXJjVmFsdWVGb3JtYXQodiwgcmF0aW8pIHtcblx0XHRyZXR1cm4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDEpfSVgO1xuXHR9LFxuXG5cdGRhdGFMYWJlbEZvcm1hdCh0YXJnZXRJZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzO1xuXHRcdGNvbnN0IGRlZmF1bHRGb3JtYXQgPSB2ID0+IChpc1ZhbHVlKHYpID8gK3YgOiBcIlwiKTtcblx0XHRsZXQgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdDtcblxuXHRcdC8vIGZpbmQgZm9ybWF0IGFjY29yZGluZyB0byBheGlzIGlkXG5cdFx0aWYgKGlzRnVuY3Rpb24oZGF0YUxhYmVscy5mb3JtYXQpKSB7XG5cdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdDtcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzLmZvcm1hdCkpIHtcblx0XHRcdGlmIChkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF0pIHtcblx0XHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID9cblx0XHRcdFx0XHRkZWZhdWx0Rm9ybWF0IDogZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9ybWF0ID0gKCkgPT4gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZm9ybWF0O1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7dG9BcnJheSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQWRkIGNhY2hlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGF0YVR5cGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFkZENhY2hlKGtleSwgdmFsdWUsIGlzRGF0YVR5cGUgPSBmYWxzZSkge1xuXHRcdHRoaXMuY2FjaGVba2V5XSA9IGlzRGF0YVR5cGUgPyB0aGlzLmNsb25lVGFyZ2V0KHZhbHVlKSA6IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgY2FjaGVcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVtb3ZlQ2FjaGUoa2V5KSB7XG5cdFx0dG9BcnJheShrZXkpLmZvckVhY2godiA9PiBkZWxldGUgdGhpcy5jYWNoZVt2XSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjYWhjZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEYXRhVHlwZVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q2FjaGUoa2V5LCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcblx0XHRpZiAoaXNEYXRhVHlwZSkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWQ7IChpZCA9IGtleVtpXSk7IGkrKykge1xuXHRcdFx0XHRpZiAoaWQgaW4gdGhpcy5jYWNoZSkge1xuXHRcdFx0XHRcdHRhcmdldHMucHVzaCh0aGlzLmNsb25lVGFyZ2V0KHRoaXMuY2FjaGVbaWRdKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV0gfHwgbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIHJlc2V0IGNhY2hlZCBkYXRhXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIHRydWU6IHJlc2V0IGFsbCBkYXRhLCBmYWxzZTogcmVzZXQgb25seSAnJCcgcHJlZml4ZWQga2V5IGRhdGFcblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRyZXNldENhY2hlKGFsbCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGZvciAoY29uc3QgeCBpbiAkJC5jYWNoZSkge1xuXHRcdFx0Ly8gcmVzZXQgdGhlIHByZWZpeGVkICckJyBrZXkod2hpY2ggaXMgaW50ZXJuYWwgdXNlIGRhdGEpIG9ubHkuXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XG5cdFx0XHRcdCQkLmNhY2hlW3hdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdlbmVyYXRlQ2xhc3MocHJlZml4LCB0YXJnZXRJZCkge1xuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XG5cdH0sXG5cblx0Y2xhc3NUZXh0KGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHQsIGQuaW5kZXgpO1xuXHR9LFxuXG5cdGNsYXNzVGV4dHMoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dHMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzU2hhcGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xuXHR9LFxuXG5cdGNsYXNzU2hhcGVzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlcywgZC5pZCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVFeHRyYUxpbmVDbGFzcygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XG5cdFx0Y29uc3QgaWRzID0gW107XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xuXHRcdFx0Y29uc3QgaWQgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xuXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xuXHRcdFx0XHRpZHMucHVzaChpZCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGFzc2VzW2lkcy5pbmRleE9mKGlkKSAlIGNsYXNzZXMubGVuZ3RoXTtcblx0XHR9O1xuXHR9LFxuXG5cdGNsYXNzTGluZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc0xpbmVzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lcywgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaXJjbGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuY2lyY2xlLCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc0NpcmNsZXMoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZXMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQmFyKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhciwgZC5pbmRleCk7XG5cdH0sXG5cblx0Y2xhc3NCYXJzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5iYXJzLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyYyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyYywgZC5kYXRhLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyY3MoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjcywgZC5kYXRhLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyZWEoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYSwgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NBcmVhcyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYXMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzUmVnaW9uKGQsIGkpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnJlZ2lvbiwgaSl9ICR7XCJjbGFzc1wiIGluIGQgPyBkLmNsYXNzIDogXCJcIn1gO1xuXHR9LFxuXG5cdGNsYXNzRXZlbnQoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuZXZlbnRSZWN0LCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc1RhcmdldChpZCkge1xuXHRcdGNvbnN0IGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCA9IHRoaXMuY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF07XG5cdFx0bGV0IGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XG5cblx0XHRpZiAoYWRkaXRpb25hbENsYXNzU3VmZml4KSB7XG5cdFx0XHRhZGRpdGlvbmFsQ2xhc3MgPSBgICR7Q0xBU1MudGFyZ2V0fS0ke2FkZGl0aW9uYWxDbGFzc1N1ZmZpeH1gO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XG5cdH0sXG5cblx0Y2xhc3NGb2N1cyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NGb2N1c2VkKGQpICsgdGhpcy5jbGFzc0RlZm9jdXNlZChkKTtcblx0fSxcblxuXHRjbGFzc0ZvY3VzZWQoZCkge1xuXHRcdHJldHVybiBgICR7dGhpcy5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiBcIlwifWA7XG5cdH0sXG5cblx0Y2xhc3NEZWZvY3VzZWQoZCkge1xuXHRcdHJldHVybiBgICR7dGhpcy5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogXCJcIn1gO1xuXHR9LFxuXG5cdGNsYXNzQ2hhcnRUZXh0KGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRUZXh0ICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcblx0fSxcblxuXHRjbGFzc0NoYXJ0TGluZShkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydEJhcihkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcblx0fSxcblxuXHRjbGFzc0NoYXJ0QXJjKGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRBcmMgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuZGF0YS5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydFJhZGFyKGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRSYWRhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Z2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgP1xuXHRcdFx0YC0ke3RhcmdldElkfWAucmVwbGFjZSgvW1xccz8hQCMkJV4mKigpXz0rLC48PidcIjo7XFxbXFxdXFwvfH5ge31cXFxcXS9nLCBcIi1cIikgOiBcIlwiO1xuXHR9LFxuXG5cdHNlbGVjdG9yVGFyZ2V0KGlkLCBwcmVmaXgpIHtcblx0XHRyZXR1cm4gYCR7cHJlZml4IHx8IFwiXCJ9LiR7Q0xBU1MudGFyZ2V0ICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YDtcblx0fSxcblxuXHRzZWxlY3RvclRhcmdldHMoaWRzVmFsdWUsIHByZWZpeCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpZHMgPSBpZHNWYWx1ZSB8fCBbXTtcblxuXHRcdHJldHVybiBpZHMubGVuZ3RoID9cblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQsIHByZWZpeCkpIDogbnVsbDtcblx0fSxcblxuXHRzZWxlY3RvckxlZ2VuZChpZCkge1xuXHRcdHJldHVybiBgLiR7Q0xBU1MubGVnZW5kSXRlbSArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XG5cdH0sXG5cblx0c2VsZWN0b3JMZWdlbmRzKGlkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBpZHMgJiYgaWRzLmxlbmd0aCA/XG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yTGVnZW5kKGlkKSkgOiBudWxsO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuXHQgKiBAbWV0aG9kIGZvY3VzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBkYXRhMSB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XG5cdCAqICBjaGFydC5mb2N1cyhcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxuXHQgKiBjaGFydC5mb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZFxuXHQgKiBjaGFydC5mb2N1cygpO1xuXHQgKi9cblx0Zm9jdXModGFyZ2V0SWRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKFxuXHRcdFx0JCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZXZlcnQoKTtcblx0XHR0aGlzLmRlZm9jdXMoKTtcblxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCB0cnVlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xuXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XG5cblx0XHQkJC5mb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9ICQkLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgQVBJIGZhZGVzIG91dCBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgcmV2ZXJ0cyB0aGUgb3RoZXJzLjxicj48YnI+XG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxuXHQgKiBAbWV0aG9kIGRlZm9jdXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gVGFyZ2V0IGlkcyB0byBiZSBmYWRlZCBvdXQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LmRlZm9jdXMoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LmRlZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxuXHQgKiBjaGFydC5kZWZvY3VzKCk7XG5cdCAqL1xuXHRkZWZvY3VzKHRhcmdldElkc1ZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuc3ZnLnNlbGVjdEFsbChcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXG5cdFx0KTtcblxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCBmYWxzZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIHRydWUpO1xuXHRcdCQkLmhhc0FyY1R5cGUoKSAmJiAkJC51bmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgZmFsc2UpO1xuXG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9ICQkLmZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBBUEkgcmV2ZXJ0cyBzcGVjaWZpZWQgdGFyZ2V0cy48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBAbWV0aG9kIHJldmVydFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBUYXJnZXQgaWRzIHRvIGJlIHJldmVydGVkXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LnJldmVydChcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSByZXZlcnRlZC5cblx0ICogY2hhcnQucmV2ZXJ0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBjaGFydC5yZXZlcnQoKTtcblx0ICovXG5cdHJldmVydCh0YXJnZXRJZHNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXG5cblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XG5cblx0XHRpZiAoJCQuY29uZmlnLmxlZ2VuZF9zaG93KSB7XG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcblx0XHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXG5cdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdCQkLmZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcblx0XHQkJC5kZWZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBTaG93L0hpZGUgZGF0YSBzZXJpZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zaG93SGlkZShzaG93LCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XG5cblx0XHQkJFtgJHtzaG93ID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJ9SGlkZGVuVGFyZ2V0SWRzYF0odGFyZ2V0SWRzKTtcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XG5cdFx0Y29uc3Qgb3BhY2l0eSA9IHNob3cgPyBcIjFcIiA6IFwiMFwiO1xuXG5cdFx0dGFyZ2V0cy50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSwgXCJpbXBvcnRhbnRcIilcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgKCkgPT4ge1xuXHRcdFx0XHR0YXJnZXRzLnN0eWxlKFwib3BhY2l0eVwiLCBudWxsKS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XG5cdFx0XHR9KTtcblxuXHRcdG9wdGlvbnMud2l0aExlZ2VuZCAmJiAkJFtgJHtzaG93ID8gXCJzaG93XCIgOiBcImhpZGVcIn1MZWdlbmRgXSh0YXJnZXRJZHMpO1xuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgZGF0YSBzZXJpZXMgb24gY2hhcnRcblx0ICogQG1ldGhvZCBzaG93XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHNob3cgJ2RhdGExJ1xuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIHNob3cgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xuXHQgKi9cblx0c2hvdyh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fc2hvd0hpZGUodHJ1ZSwgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcblx0ICogQG1ldGhvZCBoaWRlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGhpZGUgJ2RhdGExJ1xuXHQgKiBjaGFydC5oaWRlKFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIGhpZGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xuXHQgKi9cblx0aGlkZSh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fc2hvd0hpZGUoZmFsc2UsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXG5cdCAqIEBtZXRob2QgdG9nZ2xlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnXG5cdCAqIGNoYXJ0LnRvZ2dsZShcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC50b2dnbGUoW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XG5cdCAqL1xuXHR0b2dnbGUodGFyZ2V0SWRzLCBvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHtzaG93OiBbXSwgaGlkZTogW119O1xuXG5cdFx0Ly8gc29ydCBzaG93ICYgaGlkZSB0YXJnZXQgaWRzXG5cdFx0JCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKVxuXHRcdFx0LmZvckVhY2goaWQgPT4gdGFyZ2V0c1skJC5pc1RhcmdldFRvU2hvdyhpZCkgPyBcImhpZGVcIiA6IFwic2hvd1wiXS5wdXNoKGlkKSk7XG5cblx0XHQvLyBwZXJmb3JtIHNob3cgJiBoaWRlIHRhc2sgc2VwYXJhdGVseVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ1NFxuXHRcdHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyk7XG5cdFx0dGFyZ2V0cy5oaWRlLmxlbmd0aCAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGlkZSh0YXJnZXRzLmhpZGUsIG9wdGlvbnMpLCAwKTtcblx0fVxufSk7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7em9vbUlkZW50aXR5IGFzIGQzWm9vbUlkZW50aXR5LCB6b29tVHJhbnNmb3JtIGFzIGQzWm9vbVRyYW5zZm9ybX0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2NhbGxGbiwgZXh0ZW5kLCBnZXRNaW5NYXgsIGlzRGVmaW5lZCwgaXNPYmplY3QsIGlzU3RyaW5nfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZG9tYWluIGlzIHdpdGhpbiB6b29tIHJhbmdlXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoaW5SYW5nZSA9IChkb21haW4sIHJhbmdlKSA9PiB7XG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcblxuXHRyZXR1cm4gZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiAoXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXG5cdCkpO1xufTtcblxuLyoqXG4gKiBab29tIGJ5IGdpdmluZyB4IGRvbWFpbi5cbiAqIC0gKipOT1RFOioqXG4gKiAgLSBGb3IgYHdoZWVsYCB0eXBlIHpvb20sIHRoZSBtaW5pbXVtIHpvb20gcmFuZ2Ugd2lsbCBiZSBzZXQgYXMgdGhlIGdpdmVuIGRvbWFpbi4gVG8gZ2V0IHRoZSBpbml0aWFsIHN0YXRlLCBbLnVuem9vbSgpXSgjdW56b29tKSBzaG91bGQgYmUgY2FsbGVkLlxuICogIC0gVG8gYmUgdXNlZCBbem9vbS5lbmFibGVkXShPcHRpb25zLmh0bWwjLnpvb20pIG9wdGlvbiBzaG91bGQgYmUgc2V0IGFzIGB0cnV0aHlgLlxuICogQG1ldGhvZCB6b29tXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0FycmF5fSBkb21haW4gdmFsdWUgaW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbShbMTAsIDIwXSk7XG4gKlxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbSgpO1xuICovXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWUpIHtcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XG5cdGxldCByZXN1bHREb21haW47XG5cblx0aWYgKCQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xuXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xuXHRcdFx0ZG9tYWluID0gZG9tYWluLm1hcCh4ID0+ICQkLnBhcnNlRGF0ZSh4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmNvbmZpZy5zdWJjaGFydF9zaG93KSB7XG5cdFx0XHRjb25zdCB4U2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblxuXHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBbeFNjYWxlKGRvbWFpblswXSksIHhTY2FsZShkb21haW5bMV0pXSk7XG5cdFx0XHRyZXN1bHREb21haW4gPSBkb21haW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLnguZG9tYWluKGRvbWFpbik7XG5cdFx0XHQkJC56b29tU2NhbGUgPSAkJC54O1xuXHRcdFx0JCQueEF4aXMuc2NhbGUoJCQuem9vbVNjYWxlKTtcblxuXHRcdFx0cmVzdWx0RG9tYWluID0gJCQuem9vbVNjYWxlLm9yZ0RvbWFpbigpO1xuXHRcdH1cblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcdHdpdGhZOiAkJC5jb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLnNldFpvb21SZXNldEJ1dHRvbigpO1xuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb20sIHJlc3VsdERvbWFpbik7XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0RG9tYWluID0gJCQuem9vbVNjYWxlID9cblx0XHRcdCQkLnpvb21TY2FsZS5kb21haW4oKSA6ICQkLngub3JnRG9tYWluKCk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0RG9tYWluO1xufTtcblxuZXh0ZW5kKHpvb20sIHtcblx0LyoqXG5cdCAqIEVuYWJsZSBhbmQgZGlzYWJsZSB6b29taW5nLlxuXHQgKiBAbWV0aG9kIHpvb23igKRlbmFibGVcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBlbmFibGVkIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXMgYXJlIFwid2hlZWxcIiBvciBcImRyYWdcIi4gSWYgZW5hYmxlZCBpcyB0cnVlLCBcIndoZWVsXCIgd2lsbCBiZSB1c2VkLiBJZiBmYWxzZSBpcyBnaXZlbiwgem9vbWluZyB3aWxsIGJlIGRpc2FibGVkLjxicj5XaGVuIHNldCB0byBmYWxzZSwgdGhlIGN1cnJlbnQgem9vbWluZyBzdGF0dXMgd2lsbCBiZSByZXNldC5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSB3aGVlbFxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUodHJ1ZSk7XG5cdCAqICAvLyBPclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJ3aGVlbFwiKTtcblx0ICpcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcImRyYWdcIik7XG5cdCAqXG5cdCAqICAvLyBEaXNhYmxlIHpvb21pbmdcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKGZhbHNlKTtcblx0ICovXG5cdGVuYWJsZTogZnVuY3Rpb24oZW5hYmxlZCA9IFwid2hlZWxcIikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IGVuYWJsZVR5cGUgPSBlbmFibGVkO1xuXG5cdFx0aWYgKGVuYWJsZWQpIHtcblx0XHRcdGVuYWJsZVR5cGUgPSBpc1N0cmluZyhlbmFibGVkKSAmJiAvXihkcmFnfHdoZWVsKSQvLnRlc3QoZW5hYmxlZCkgP1xuXHRcdFx0XHR7dHlwZTogZW5hYmxlZH0gOiBlbmFibGVkO1xuXHRcdH1cblxuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgPSBlbmFibGVUeXBlO1xuXG5cdFx0aWYgKCEkJC56b29tKSB7XG5cdFx0XHQkJC5pbml0Wm9vbSgpO1xuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoZmFsc2UpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgb3IgZ2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2UgdmFsdWVcblx0ICogQG1ldGhvZCB6b29t4oCkbWF4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXG5cdCAqIEByZXR1cm4ge051bWJlcn0gem9vbSBtYXggdmFsdWVcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIFNldCBtYXhpbXVtIHJhbmdlIHZhbHVlXG5cdCAqICBjaGFydC56b29tLm1heCgyMCk7XG5cdCAqL1xuXHRtYXg6IGZ1bmN0aW9uKG1heCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAobWF4ID09PSAwIHx8IG1heCkge1xuXHRcdFx0Y29uZmlnLnpvb21feF9tYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgWyQkLm9yZ1hEb21haW5bMV0sIG1heF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21heDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlIHZhbHVlXG5cdCAqIEBtZXRob2Qgem9vbeKApG1pblxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWluIHZhbHVlXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxuXHQgKiAgY2hhcnQuem9vbS5taW4oLTEpO1xuXHQgKi9cblx0bWluOiBmdW5jdGlvbihtaW4pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcblx0XHRcdGNvbmZpZy56b29tX3hfbWluID0gZ2V0TWluTWF4KFwibWluXCIsIFskJC5vcmdYRG9tYWluWzBdLCBtaW5dKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9taW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB6b29tIHJhbmdlXG5cdCAqIEBtZXRob2Qgem9vbeKApHJhbmdlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtyYW5nZV1cblx0ICogQHJldHVybiB7T2JqZWN0fSB6b29tIHJhbmdlIHZhbHVlXG5cdCAqIHtcblx0ICogICBtaW46IDAsXG5cdCAqICAgbWF4OiAxMDBcblx0ICogfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgY2hhcnQuem9vbS5yYW5nZSh7XG5cdCAqICAgICAgbWluOiAxMCxcblx0ICogICAgICBtYXg6IDEwMFxuXHQgKiAgfSk7XG5cdCAqL1xuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRjb25zdCB6b29tID0gdGhpcy56b29tO1xuXG5cdFx0aWYgKGlzT2JqZWN0KHJhbmdlKSkge1xuXHRcdFx0Y29uc3Qge21pbiwgbWF4fSA9IHJhbmdlO1xuXG5cdFx0XHRpc0RlZmluZWQobWluKSAmJiB6b29tLm1pbihtaW4pO1xuXHRcdFx0aXNEZWZpbmVkKG1heCkgJiYgem9vbS5tYXgobWF4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiB6b29tLm1pbigpLFxuXHRcdFx0bWF4OiB6b29tLm1heCgpXG5cdFx0fTtcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0em9vbSxcblxuXHQvKipcblx0ICogVW56b29tIHpvb21lZCBhcmVhXG5cdCAqIEBtZXRob2QgdW56b29tXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQGV4YW1wbGVcblx0ICogIGNoYXJ0LnVuem9vbSgpO1xuXHQgKi9cblx0dW56b29tKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuem9vbVNjYWxlKSB7XG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyA/XG5cdFx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgbnVsbCkgOlxuXHRcdFx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKGQzWm9vbUlkZW50aXR5KTtcblxuXHRcdFx0JCQudXBkYXRlWm9vbSh0cnVlKTtcblx0XHRcdCQkLnpvb20ucmVzZXRCdG4gJiYgJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG5cdFx0XHQvLyByZXNldCB0cmFuc2Zvcm1cblx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcblxuXHRcdFx0aWYgKGQzWm9vbVRyYW5zZm9ybShldmVudFJlY3RzLm5vZGUoKSkgIT09IGQzWm9vbUlkZW50aXR5KSB7XG5cdFx0XHRcdCQkLnpvb20udHJhbnNmb3JtKGV2ZW50UmVjdHMsIGQzWm9vbUlkZW50aXR5KTtcblx0XHRcdH1cblxuXHRcdFx0JCQucmVkcmF3KHtcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGVcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmQsIGlzU3RyaW5nLCBpc0FycmF5fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogTG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XG5cdCAqICAgLSB1bmxvYWQgc2hvdWxkIGJlIHVzZWQgaWYgc29tZSBkYXRhIG5lZWRzIHRvIGJlIHVubG9hZGVkIHNpbXVsdGFuZW91c2x5LlxuXHQgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxuXHQgKiAgIC0gZG9uZSB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy5cblx0ICogICAgIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxuXHQgKiAgICB8IC0tLSB8IC0tLSB8XG5cdCAqICAgIHwgLSB1cmw8YnI+LSBqc29uPGJyPi0gcm93czxicj4tIGNvbHVtbnMgfCBUaGUgZGF0YSB3aWxsIGJlIGxvYWRlZC4gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkIHxcblx0ICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZCB8XG5cdCAqICAgIHwgbmFtZXMgfCBTYW1lIGFzIGRhdGEubmFtZXMoKSB8XG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XG5cdCAqICAgIHwgY2xhc3NlcyB8IFRoZSBjbGFzc2VzIHNwZWNpZmllZCBieSBkYXRhLmNsYXNzZXMgd2lsbCBiZSB1cGRhdGVkLiBjbGFzc2VzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XG5cdCAqICAgIHwgY2F0ZWdvcmllcyB8IFRoZSBjYXRlZ29yaWVzIHNwZWNpZmllZCBieSBheGlzLnguY2F0ZWdvcmllcyBvciBkYXRhLnggd2lsbCBiZSB1cGRhdGVkLiBjYXRlZ29yaWVzIG11c3QgYmUgQXJyYXkuIHxcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcblx0ICogICAgfCBjb2xvcnMgfCBUaGUgY29sb3JzIHNwZWNpZmllZCBieSBkYXRhLmNvbG9ycyB3aWxsIGJlIHVwZGF0ZWQuIGNvbG9ycyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxuXHQgKiAgICB8IGhlYWRlcnMgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIGRhdGEudXJsLjxicj5Ac2VlIFtkYXRh4oCkaGVhZGVyc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0aGVhZGVycykgfFxuXHQgKiAgICB8IGtleXMgfCAgQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0cyBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLjxicj4qKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuPGJyPkBzZWUgW2RhdGHigKRrZXlzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKSB8XG5cdCAqICAgIHwgbWltZVR5cGUgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIHVybC48YnI+QHNlZSBbZGF0YeKApG1pbWVUeXBlXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRtaW1lVHlwZSkgfFxuXHQgKiAgICB8IC0gdHlwZTxicj4tIHR5cGVzIHwgVGhlIHR5cGUgb2YgdGFyZ2V0cyB3aWxsIGJlIHVwZGF0ZWQuIHR5cGUgbXVzdCBiZSBTdHJpbmcgYW5kIHR5cGVzIG11c3QgYmUgT2JqZWN0LiB8XG5cdCAqICAgIHwgdW5sb2FkIHwgU3BlY2lmeSB0aGUgZGF0YSB3aWxsIGJlIHVubG9hZGVkIGJlZm9yZSBsb2FkaW5nIG5ldyBkYXRhLiBJZiB0cnVlIGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiBJZiB0YXJnZXQgaWRzIGdpdmVuIGFzIFN0cmluZyBvciBBcnJheSwgc3BlY2lmaWVkIHRhcmdldHMgd2lsbCBiZSB1bmxvYWRlZC4gSWYgYWJzZW50IG9yIGZhbHNlIGdpdmVuLCB1bmxvYWQgd2lsbCBub3Qgb2NjdXIuIHxcblx0ICogICAgfCBkb25lIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZC58XG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFGcm9tVVJMKVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBMb2FkIGRhdGExIGFuZCB1bmxvYWQgZGF0YTIgYW5kIGRhdGEzXG5cdCAqIGNoYXJ0LmxvYWQoe1xuXHQgKiAgICAgY29sdW1uczogW1xuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMTAwLCAyMDAsIDE1MCwgLi4uXSxcblx0ICogICAgICAgIC4uLlxuXHQgKiAgICBdLFxuXHQgKiAgICB1bmxvYWQ6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXG5cdCAqICAgIHVybDogXCIuLi5cIixcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7IC4uLiB9XG5cdCAqIH0pO1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBteUFQSS5qc29uXG5cdCAqIC8vIHtcblx0ICogLy8gICBcImRhdGExXCI6IFsyMjAsIDI0MCwgMjcwLCAyNTAsIDI4MF0sXG5cdCAqIC8vICAgXCJkYXRhMlwiOiBbMTgwLCAxNTAsIDMwMCwgNzAsIDEyMF1cblx0ICogLy8gfVxuXHQgKlxuXHQgKiBjaGFydC5sb2FkKHtcblx0ICogICAgIHVybDogJy4vZGF0YS9teUFQSS5qc29uJyxcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxuXHQgKiB9KTtcblx0ICovXG5cdGxvYWQoYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQvLyB1cGRhdGUgeHMgaWYgc3BlY2lmaWVkXG5cdFx0YXJncy54cyAmJiAkJC5hZGRYcyhhcmdzLnhzKTtcblxuXHRcdC8vIHVwZGF0ZSBuYW1lcyBpZiBleGlzdHNcblx0XHRcIm5hbWVzXCIgaW4gYXJncyAmJiB0aGlzLmRhdGEubmFtZXMoYXJncy5uYW1lcyk7XG5cblx0XHQvLyB1cGRhdGUgY2xhc3NlcyBpZiBleGlzdHNcblx0XHRcImNsYXNzZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY2xhc3NlcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XG5cdFx0fSk7XG5cblx0XHQvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcblx0XHRpZiAoXCJjYXRlZ29yaWVzXCIgaW4gYXJncyAmJiAkJC5pc0NhdGVnb3JpemVkKCkpIHtcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGFyZ3MuY2F0ZWdvcmllcztcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgYXhlcyBpZiBleGlzdHNcblx0XHRcImF4ZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuYXhlcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XG5cdFx0fSk7XG5cblx0XHQvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xuXHRcdFwiY29sb3JzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNvbG9ycykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9jb2xvcnNbaWRdID0gYXJncy5jb2xvcnNbaWRdO1xuXHRcdH0pO1xuXG5cdFx0Ly8gdW5sb2FkIGlmIG5lZWRlZFxuXHRcdGlmIChcInVubG9hZFwiIGluIGFyZ3MgJiYgYXJncy51bmxvYWQgIT09IGZhbHNlKSB7XG5cdFx0XHQvLyBUT0RPOiBkbyBub3QgdW5sb2FkIGlmIHRhcmdldCB3aWxsIGxvYWQgKGluY2x1ZGVkIGluIHVybC9yb3dzL2NvbHVtbnMpXG5cdFx0XHQkJC51bmxvYWQoJCQubWFwVG9UYXJnZXRJZHMoYXJncy51bmxvYWQgPT09IHRydWUgPyBudWxsIDogYXJncy51bmxvYWQpLCAoKSA9PlxuXHRcdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncylcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVubG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XG5cdCAqIElmIHlvdSBjYWxsIGxvYWQgQVBJIHNvb24gYWZ0ZXIvYmVmb3JlIHVubG9hZCwgdW5sb2FkIHBhcmFtIG9mIGxvYWQgc2hvdWxkIGJlIHVzZWQuIE90aGVyd2lzZSBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxuXHQgKiBgZG9uZWAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nLlxuXHQgKiBAbWV0aG9kIHVubG9hZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG5cdCAqICB8IGtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XG5cdCAqICB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdCAqICB8IGlkcyB8IFN0cmluZyAmdmVydDsgQXJyYXkgfCBUYXJnZXQgaWQgZGF0YSB0byBiZSB1bmxvYWRlZC4gSWYgbm90IGdpdmVuLCBhbGwgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiB8XG5cdCAqICB8IGRvbmUgfCBGdWN0aW9uIHwgQ2FsbGJhY2sgYWZ0ZXIgZGF0YSBpcyB1bmxvYWRlZC4gfFxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gVW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xuXHQgKiAgY2hhcnQudW5sb2FkKHtcblx0ICogICAgaWRzOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHtcblx0ICogICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSB1bmxvYWRlZFxuXHQgKiAgICB9XG5cdCAqICB9KTtcblx0ICovXG5cdHVubG9hZChhcmdzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0bGV0IGFyZ3MgPSBhcmdzVmFsdWUgfHwge307XG5cblx0XHRpZiAoaXNBcnJheShhcmdzKSkge1xuXHRcdFx0YXJncyA9IHtpZHM6IGFyZ3N9O1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJncykpIHtcblx0XHRcdGFyZ3MgPSB7aWRzOiBbYXJnc119O1xuXHRcdH1cblxuXHRcdGNvbnN0IGlkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MuaWRzKTtcblxuXHRcdCQkLnVubG9hZChpZHMsICgpID0+IHtcblx0XHRcdCQkLnJlZHJhdyh7XG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxuXHRcdFx0fSk7XG5cblx0XHRcdCQkLnJlbW92ZUNhY2hlKGlkcyk7XG5cdFx0XHRhcmdzLmRvbmUgJiYgYXJncy5kb25lKCk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7ZWFzZUxpbmVhciBhcyBkM0Vhc2VMaW5lYXJ9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtpc0RlZmluZWQsIGlzVmFsdWUsIGRpZmZEb21haW4sIGV4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEZsb3cgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cblx0ICogQnkgdGhpcyBBUEksIHlvdSBjYW4gYXBwZW5kIG5ldyBkYXRhIHBvaW50cyB0byB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgZmxvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IGpzb24gfCBPYmplY3QgfCBEYXRhIGFzIEpTT04gZm9ybWF0IChAc2VlIFtkYXRh4oCkanNvbl0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcblx0ICogICAgfCByb3dzIHwgQXJyYXkgfCBEYXRhIGluIGFycmF5IGFzIHJvdyBmb3JtYXQgKEBzZWUgW2RhdGHigKRyb3dzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxuXHQgKiAgICB8IGNvbHVtbnMgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgY29sdW1uIGZvcm1hdCAoQHNlZSBbZGF0YeKApGNvbHVtbnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbHVtbnMpKSB8XG5cdCAqICAgIHwgdG8gfCBTdHJpbmcgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSB0byB0aGF0IHBvaW50LiBJZiBub3QgZ2l2ZW4sIHRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgZ2l2ZW4gZGF0YSBwb2ludHMgfFxuXHQgKiAgICB8IGxlbmd0aCB8IE51bWJlciB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgdGhpcyBhcmd1bWVudCB8XG5cdCAqICAgIHwgZHVyYXRpb24gfCBOdW1iZXIgfCBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBzcGVjaWZpZWQgdmFsdWUuIElmIG5vdCBnaXZlbiwgdHJhbnNpdGlvbi5kdXJhdGlvbiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB8XG5cdCAqICAgIHwgZG9uZSB8IEZ1bmN0aW9uIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIGZsb3cgZW5kcyB8XG5cdCAqXG5cdCAqIC0gKipOT1RFOioqXG5cdCAqICAgLSBJZiBqc29uLCByb3dzIGFuZCBjb2x1bW5zIGdpdmVuLCB0aGUgZGF0YSB3aWxsIGJlIGxvYWRlZC5cblx0ICogICAtIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSBhcHBlbmRlZC5cblx0ICogICAtIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkLiBPbmUgb2YgdGhlc2UgaXMgcmVxdWlyZWQgd2hlbiBjYWxsaW5nLlxuXHQgKiAgIC0gSWYganNvbiBzcGVjaWZpZWQsIGtleXMgaXMgcmVxdWlyZWQgYXMgd2VsbCBhcyBkYXRhLmpzb24uXG5cdCAqIFx0IC0gSWYgdGFiIGlzbid0IHZpc2libGUoYnkgZXZhbHVhdGluZyBgZG9jdW1lbnQuaGlkZGVuYCksIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnkgd29yay5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gMiBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcHJlbmRlZCB0byB0aGUgdGFpbCBhbmQgcG9wcGVkIGZyb20gdGhlIGhlYWQuXG5cdCAqIC8vIEFmdGVyIHRoYXQsIDQgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHBlbmRlZCBhbmQgbm8gZGF0YSBwb2ludHMgd2lsbCBiZSBwb3Bwb2VkLlxuXHQgKiBjaGFydC5mbG93KHtcblx0ICogIGNvbHVtbnM6IFtcblx0ICogICAgW1wieFwiLCBcIjIwMTgtMDEtMTFcIiwgXCIyMDE4LTAxLTIxXCJdLFxuXHQgKiAgICBbXCJkYXRhMVwiLCA1MDAsIDIwMF0sXG5cdCAqICAgIFtcImRhdGEyXCIsIDEwMCwgMzAwXSxcblx0ICogICAgW1wiZGF0YTNcIiwgMjAwLCAxMjBdXG5cdCAqICBdLFxuXHQgKiAgdG86IFwiMjAxMy0wMS0xMVwiLFxuXHQgKiAgZG9uZTogZnVuY3Rpb24gKCkge1xuXHQgKiAgICBjaGFydC5mbG93KHtcblx0ICogICAgICBjb2x1bW5zOiBbXG5cdCAqICAgICAgICBbXCJ4XCIsIFwiMjAxOC0wMi0xMVwiLCBcIjIwMTgtMDItMTJcIiwgXCIyMDE4LTAyLTEzXCIsIFwiMjAxOC0wMi0xNFwiXSxcblx0ICogICAgICAgIFtcImRhdGExXCIsIDIwMCwgMzAwLCAxMDAsIDI1MF0sXG5cdCAqICAgICAgICBbXCJkYXRhMlwiLCAxMDAsIDkwLCA0MCwgMTIwXSxcblx0ICogICAgICAgIFtcImRhdGEzXCIsIDEwMCwgMTAwLCAzMDAsIDUwMF1cblx0ICogICAgICBdLFxuXHQgKiAgICAgIGxlbmd0aDogMixcbiAgICAgKiAgICAgIGR1cmF0aW9uOiAxNTAwXG5cdCAqICAgIH0pO1xuXHQgKiAgfVxuXHQgKiB9KTtcblx0ICovXG5cdGZsb3coYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgZGF0YTtcblx0XHRsZXQgZG9tYWluO1xuXHRcdGxldCBsZW5ndGggPSAwO1xuXHRcdGxldCB0YWlsID0gMDtcblx0XHRsZXQgZGlmZjtcblx0XHRsZXQgdG87XG5cblx0XHRpZiAoYXJncy5qc29uIHx8IGFyZ3Mucm93cyB8fCBhcmdzLmNvbHVtbnMpIHtcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0RGF0YShhcmdzKTtcblx0XHR9XG5cblx0XHRpZiAoIWRhdGEgfHwgISQkLmlzVGFiVmlzaWJsZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm90Zm91bmRJZHMgPSBbXTtcblx0XHRjb25zdCBvcmdEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgdHJ1ZSk7XG5cblx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHQuaWQgPT09IHRhcmdldHNbaV0uaWQpIHtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAodC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0pIHtcblx0XHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGVuZ3RoID0gdGFyZ2V0c1tpXS52YWx1ZXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0uaW5kZXggPSB0YWlsICsgajtcblxuXHRcdFx0XHRcdFx0aWYgKCEkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzW2ldLnZhbHVlc1tqXS54ID0gdGFpbCArIGo7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xuXHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCFmb3VuZCAmJiBub3Rmb3VuZElkcy5wdXNoKHQuaWQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5vdGZvdW5kSWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xuXHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR0LnZhbHVlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aWQ6IHQuaWQsXG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0YWlsICsgaixcblx0XHRcdFx0XHRcdFx0eDogJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5nZXRPdGhlclRhcmdldFgodGFpbCArIGopIDogdGFpbCArIGosXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEdlbmVyYXRlIG51bGwgdmFsdWVzIGZvciBuZXcgdGFyZ2V0XG5cdFx0aWYgKCQkLmRhdGEudGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0Y29uc3QgbWlzc2luZyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzWzBdLmluZGV4OyBpIDwgdGFpbDsgaSsrKSB7XG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKHtcblx0XHRcdFx0XHRcdGlkOiB0LmlkLFxuXHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHR2LmluZGV4ICs9IHRhaWw7XG5cblx0XHRcdFx0XHRpZiAoISQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0XHR2LnggKz0gdGFpbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXG5cblx0XHQvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXRcInMgb25seSBvbmVcblx0XHQvLyBjb25zdCBkYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcblx0XHRjb25zdCBiYXNlVGFyZ2V0ID0gJCQuZGF0YS50YXJnZXRzWzBdO1xuXHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VUYXJnZXQudmFsdWVzWzBdO1xuXG5cdFx0Ly8gVXBkYXRlIGxlbmd0aCB0byBmbG93IGlmIG5lZWRlZFxuXHRcdGlmIChpc0RlZmluZWQoYXJncy50bykpIHtcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHR0byA9ICQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGFyZ3MudG8pIDogYXJncy50bztcblxuXHRcdFx0YmFzZVRhcmdldC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0di54IDwgdG8gJiYgbGVuZ3RoKys7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLmxlbmd0aCkpIHtcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIElmIG9ubHkgb25lIGRhdGEsIHVwZGF0ZSB0aGUgZG9tYWluIHRvIGZsb3cgZnJvbSBsZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHtcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0XHRkaWZmID0gYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoID4gMSA/XG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcblx0XHRcdFx0XHRiYXNlVmFsdWUueCAtICQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKVswXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpZmYgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XG5cdFx0fSBlbHNlIGlmIChvcmdEYXRhQ291bnQgPT09IDEgJiYgJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdGRpZmYgPSAoYmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54KSAvIDI7XG5cdFx0XHRkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcblx0XHR9XG5cblx0XHRkb21haW4gJiYgJCQudXBkYXRlWERvbWFpbihudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgZG9tYWluKTtcblxuXHRcdC8vIFNldCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0Zmxvdzoge1xuXHRcdFx0XHRpbmRleDogYmFzZVZhbHVlLmluZGV4LFxuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcblx0XHRcdFx0ZHVyYXRpb246IGlzVmFsdWUoYXJncy5kdXJhdGlvbikgPyBhcmdzLmR1cmF0aW9uIDogJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24sXG5cdFx0XHRcdGRvbmU6IGFyZ3MuZG9uZSxcblx0XHRcdFx0b3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnQsXG5cdFx0XHR9LFxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZSxcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxuXHRcdFx0d2l0aFRyaW1YRG9tYWluOiBmYWxzZSxcblx0XHRcdHdpdGhVcGRhdGVYQXhpczogdHJ1ZVxuXHRcdH0pO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBmbG93XG5cdCAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKi9cblx0Z2VuZXJhdGVGbG93KGFyZ3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IGFyZ3MudGFyZ2V0cztcblx0XHRcdGNvbnN0IGZsb3cgPSBhcmdzLmZsb3c7XG5cblx0XHRcdGNvbnN0IHtiYXI6IGRyYXdCYXIsIGxpbmU6IGRyYXdMaW5lLCBhcmVhOiBkcmF3QXJlYX0gPSBhcmdzLnNoYXBlLnR5cGU7XG5cdFx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gYXJncy5zaGFwZS5wb3M7XG5cdFx0XHRjb25zdCB4diA9IGFyZ3MueHY7XG5cdFx0XHRjb25zdCBkdXJhdGlvbiA9IGFyZ3MuZHVyYXRpb247XG5cblx0XHRcdGxldCB0cmFuc2xhdGVYO1xuXHRcdFx0bGV0IHNjYWxlWCA9IDE7XG5cdFx0XHRjb25zdCBmbG93SW5kZXggPSBmbG93LmluZGV4O1xuXHRcdFx0Y29uc3QgZmxvd0xlbmd0aCA9IGZsb3cubGVuZ3RoO1xuXHRcdFx0bGV0IGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCBmbG93SW5kZXgpO1xuXHRcdFx0bGV0IGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgZmxvd0luZGV4ICsgZmxvd0xlbmd0aCk7XG5cdFx0XHRjb25zdCBvcmdEb21haW4gPSAkJC54LmRvbWFpbigpO1xuXHRcdFx0Y29uc3QgZHVyYXRpb25Gb3JGbG93ID0gZmxvdy5kdXJhdGlvbiB8fCBkdXJhdGlvbjtcblx0XHRcdGNvbnN0IGRvbmUgPSBmbG93LmRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdGNvbnN0IHdhaXQgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcblxuXHRcdFx0Y29uc3QgeGdyaWQgPSAkJC54Z3JpZCB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCB4Z3JpZExpbmVzID0gJCQueGdyaWRMaW5lcyB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluUmVnaW9uID0gJCQubWFpblJlZ2lvbiB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluVGV4dCA9ICQkLm1haW5UZXh0IHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5CYXIgPSAkJC5tYWluQmFyIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5MaW5lID0gJCQubWFpbkxpbmUgfHwgZDNTZWxlY3RBbGwoW10pO1xuXHRcdFx0Y29uc3QgbWFpbkFyZWEgPSAkJC5tYWluQXJlYSB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluQ2lyY2xlID0gJCQubWFpbkNpcmNsZSB8fCBkM1NlbGVjdEFsbChbXSk7XG5cblx0XHRcdC8vIHNldCBmbGFnXG5cdFx0XHQkJC5mbG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGhlYWQgZGF0YSBhZnRlciByZW5kZXJlZFxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XG5cdFx0XHRcdGQudmFsdWVzLnNwbGljZSgwLCBmbG93TGVuZ3RoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyB1cGRhdGUgeCBkb21haW4gdG8gZ2VuZXJhdGUgYXhpcyBlbGVtZW50cyBmb3IgZmxvd1xuXHRcdFx0Y29uc3QgZG9tYWluID0gJCQudXBkYXRlWERvbWFpbih0YXJnZXRzLCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxuXHRcdFx0aWYgKCQkLnVwZGF0ZVhHcmlkKSB7ICQkLnVwZGF0ZVhHcmlkKHRydWUpOyB9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRyYW5zZm9ybSB0byBmbG93XG5cdFx0XHRpZiAoIWZsb3cub3JnRGF0YUNvdW50KSB7IC8vIGlmIGVtcHR5XG5cdFx0XHRcdGlmICgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0XHRmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgMCk7XG5cdFx0XHRcdFx0XHRmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVYID0gJCQueChmbG93U3RhcnQueCkgLSAkJC54KGZsb3dFbmQueCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmbG93Lm9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xuXHRcdFx0XHR0cmFuc2xhdGVYID0gJCQueChvcmdEb21haW5bMF0pIC0gJCQueChkb21haW5bMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9ICgkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAoJCQueChmbG93U3RhcnQueCkgLSAkJC54KGZsb3dFbmQueCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNjYWxlWCA9IChkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbikpO1xuXHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LDApIHNjYWxlKCR7c2NhbGVYfSwxKWA7XG5cblx0XHRcdCQkLmhpZGVYR3JpZEZvY3VzKCk7XG5cblx0XHRcdGNvbnN0IGd0ID0gZDNUcmFuc2l0aW9uKCkuZWFzZShkM0Vhc2VMaW5lYXIpXG5cdFx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckZsb3cpO1xuXG5cdFx0XHR3YWl0LmFkZChbXG5cdFx0XHRcdCQkLmF4ZXMueFxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5jYWxsKGcgPT4gJCQueEF4aXMuc2V0VHJhbnNpdGlvbihndCkuY3JlYXRlKGcpKSxcblxuXHRcdFx0XHRtYWluQmFyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHRtYWluTGluZVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXG5cblx0XHRcdFx0bWFpbkFyZWFcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5UZXh0XG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHRtYWluUmVnaW9uXG5cdFx0XHRcdFx0LmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdHhncmlkXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHR4Z3JpZExpbmVzXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblx0XHRcdF0pO1xuXG5cdFx0XHRndC5jYWxsKHdhaXQsICgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gW107XG5cdFx0XHRcdGNvbnN0IHRleHRzID0gW107XG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBbXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgZmxvd2VkIGVsZW1lbnRzXG5cdFx0XHRcdGlmIChmbG93TGVuZ3RoKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZmxvd0luZGV4ICsgaTtcblxuXHRcdFx0XHRcdFx0c2hhcGVzLnB1c2goYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApO1xuXHRcdFx0XHRcdFx0dGV4dHMucHVzaChgLiR7Q0xBU1MudGV4dH0tJHtpbmRleH1gKTtcblx0XHRcdFx0XHRcdGV2ZW50UmVjdHMucHVzaChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxuXHRcdFx0XHRcdFx0LnNlbGVjdEFsbChzaGFwZXMpXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHQkJC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy50ZXh0c31gKVxuXHRcdFx0XHRcdFx0LnNlbGVjdEFsbCh0ZXh0cylcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YClcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoZXZlbnRSZWN0cylcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLnhncmlkfWApXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkcmF3IGFnYWluIGZvciByZW1vdmluZyBmbG93ZWQgZWxlbWVudHMgYW5kIHJldmVydGluZyBhdHRyXG5cdFx0XHRcdHhncmlkLnNpemUoKSAmJiB4Z3JpZFxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoJCQueGdyaWRBdHRyKTtcblxuXHRcdFx0XHR4Z3JpZExpbmVzXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cblx0XHRcdFx0eGdyaWRMaW5lcy5zZWxlY3QoXCJsaW5lXCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gMCA6IHh2KVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogeHYpO1xuXG5cdFx0XHRcdHhncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB4dik7XG5cblx0XHRcdFx0bWFpbkJhclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpO1xuXG5cdFx0XHRcdG1haW5MaW5lXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpO1xuXG5cdFx0XHRcdG1haW5BcmVhXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpO1xuXG5cdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcblxuXHRcdFx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XG5cdFx0XHRcdFx0bWFpbkNpcmNsZVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHhGdW5jID0gZCA9PiBjeChkKSAtIGNvbmZpZy5wb2ludF9yO1xuXHRcdFx0XHRcdGNvbnN0IHlGdW5jID0gZCA9PiBjeShkKSAtIGNvbmZpZy5wb2ludF9yO1xuXG5cdFx0XHRcdFx0bWFpbkNpcmNsZVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhGdW5jKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGdW5jKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCBjeCkgLy8gd2hlbiBwYXR0ZXJuIGlzIHVzZWQsIGl0IHBvc3NpYmx5IGNvbnRhaW4gJ2NpcmNsZScgYWxzby5cblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFpblRleHRcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yVGV4dClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcblxuXHRcdFx0XHRtYWluUmVnaW9uXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cblx0XHRcdFx0bWFpblJlZ2lvbi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcblx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKTtcblxuXHRcdFx0XHRjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAkJC5yZWRyYXdFdmVudFJlY3QoKTtcblxuXHRcdFx0XHQvLyBjYWxsYmFjayBmb3IgZW5kIG9mIGZsb3dcblx0XHRcdFx0ZG9uZSgpO1xuXG5cdFx0XHRcdCQkLmZsb3dpbmcgPSBmYWxzZTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IHNlbGVjdGVkIGRhdGEgcG9pbnRzLjxicj48YnI+XG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGdldCBzZWxlY3RlZCBkYXRhIHBvaW50cyBpbmZvcm1hdGlvbi4gVG8gdXNlIHRoaXMgQVBJLCBkYXRhLnNlbGVjdGlvbi5lbmFibGVkIG5lZWRzIHRvIGJlIHNldCB0cnVlLlxuXHQgKiBAbWV0aG9kIHNlbGVjdGVkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRJZF0gWW91IGNhbiBmaWx0ZXIgdGhlIHJlc3VsdCBieSBnaXZpbmcgdGFyZ2V0IGlkIHRoYXQgeW91IHdhbnQgdG8gZ2V0LiBJZiBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZGF0YVBvaW50IEFycmF5IG9mIHRoZSBkYXRhIHBvaW50cy48YnI+ZXguKSBgW3t4OiAxLCB2YWx1ZTogMjAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMSwgbmFtZTogXCJkYXRhMVwifSwgLi4uXWBcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiAgY2hhcnQuc2VsZWN0ZWQoKTtcblx0ICogIC8vIC0tPiBleC4pIFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLiBdXG5cdCAqXG5cdCAqICAvLyBhbGwgc2VsZWN0ZWQgZGF0YSBwb2ludHMgb2YgZGF0YTEgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogIGNoYXJ0LnNlbGVjdGVkKFwiZGF0YTFcIik7XG5cdCAqL1xuXHRzZWxlY3RlZCh0YXJnZXRJZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBkYXRhUG9pbnQgPSBbXTtcblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZCA9PiBkYXRhUG9pbnQucHVzaChkKSk7XG5cblx0XHRyZXR1cm4gZGF0YVBvaW50O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcblx0ICogQG1ldGhvZCBzZWxlY3Rcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gZ2V0IHNlbGVjdGVkLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXNldE90aGVyXSBVbnNlbGVjdCBhbHJlYWR5IHNlbGVjdGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xuXHQgKiAgY2hhcnQuc2VsZWN0KCk7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTJcIik7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xuXHQgKiAgY2hhcnQuc2VsZWN0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFsyXSwgdHJ1ZSk7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFswLCAzLCA1XSk7XG5cdCAqL1xuXHRzZWxlY3QoaWRzLCBpbmRpY2VzLCByZXNldE90aGVyKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XG5cdFx0XHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKTtcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MubGluZSkgfHwgc2hhcGUuY2xhc3NlZChDTEFTUy5hcmVhKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXgpIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSAmJiAhaXNTZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0dG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKHJlc2V0T3RoZXIpICYmIHJlc2V0T3RoZXIgJiYgaXNTZWxlY3RlZCkge1xuXHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSB1bi1zZWxlY3RlZC5cblx0ICogQG1ldGhvZCB1bnNlbGVjdFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbaWRzXSBpZCB2YWx1ZSB0byBiZSB1bnNlbGVjdGVkLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGRhdGEgcG9pbnRzXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xuXHQgKlxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGZyb20gJ2RhdGExJ1xuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogIC8vIHVuc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XG5cdCAqL1xuXHR1bnNlbGVjdChpZHMsIGluZGljZXMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xuXHRcdFx0XHRjb25zdCBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMDtcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzVGFyZ2V0SWQgJiYgaXNUYXJnZXRJbmRleCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpICYmIGlzU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBjaGFydC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNGb3JSZWRyYXdcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVG8odGFyZ2V0SWRzLCB0eXBlLCBvcHRpb25zRm9yUmVkcmF3KSB7XG5cdGNvbnN0ICQkID0gdGhpcztcblx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNGb3JSZWRyYXcgfHwge3dpdGhUcmFuc2l0aW9uRm9yQXhpczogISQkLmhhc0FyY1R5cGUoKX07XG5cblx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGZhbHNlO1xuXHQkJC50cmFuc2l0aW5nID0gZmFsc2U7XG5cblx0JCQuc2V0VGFyZ2V0VHlwZSh0YXJnZXRJZHMsIHR5cGUpO1xuXHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7IC8vIHRoaXMgaXMgbmVlZGVkIHdoZW4gdHJhbnNmb3JtaW5nIHRvIGFyY1xuXHQkJC51cGRhdGVBbmRSZWRyYXcob3B0aW9ucyk7XG59XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgdHlwZSBvZiB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgdHJhbnNmb3JtXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgU3BlY2lmeSB0aGUgdHlwZSB0byBiZSB0cmFuc2Zvcm1lZC4gVGhlIHR5cGVzIGxpc3RlZCBpbiBkYXRhLnR5cGUgY2FuIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgU3BlY2lmeSB0YXJnZXRzIHRvIGJlIHRyYW5zZm9ybWVkLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YXJnZXRzIHdpbGwgYmUgdGhlIGNhbmRpZGF0ZS5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgYmFyIGNoYXJ0LlxuXHQgKiAgY2hhcnQudHJhbnNmb3JtKFwiYmFyXCIpO1xuXHQgKlxuXHQgKiAgLy8gb25seSBkYXRhMSB3aWxsIGJlIGJhciBjaGFydC5cblx0ICogIGNoYXJ0LnRyYW5zZm9ybShcImJhclwiLCBcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAgLy8gb25seSBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBiYXIgY2hhcnQuXG5cdCAqICBjaGFydC50cmFuc2Zvcm0oXCJiYXJcIiwgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqL1xuXHR0cmFuc2Zvcm0odHlwZSwgdGFyZ2V0SWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBbXCJwaWVcIiwgXCJkb251dFwiXVxuXHRcdFx0LmluZGV4T2YodHlwZSkgPj0gMCA/IHt3aXRoVHJhbnNmb3JtOiB0cnVlfSA6IG51bGw7XG5cblx0XHR0cmFuc2Zvcm1Uby5iaW5kKCQkKSh0YXJnZXRJZHMsIHR5cGUsIG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVW5kZWZpbmVkLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBVcGRhdGUgZ3JvdXBzIGZvciB0aGUgdGFyZ2V0cy5cblx0ICogQG1ldGhvZCBncm91cHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgVGhpcyBhcmd1bWVudCBuZWVkcyB0byBiZSBhbiBBcnJheSB0aGF0IGluY2x1ZGVzIG9uZSBvciBtb3JlIEFycmF5IHRoYXQgaW5jbHVkZXMgdGFyZ2V0IGlkcyB0byBiZSBncm91cGVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gR3JvdXBlZCBkYXRhIG5hbWVzIGFycmF5XG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cblx0ICogIGNoYXJ0Lmdyb3VwcyhbXG5cdCAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXG5cdCAqICBdKTtcblx0ICovXG5cdGdyb3Vwcyhncm91cHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGdyb3VwcykpIHtcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xuXHRcdCQkLnJlZHJhdygpO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3Vwcztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFVwZGF0ZSB4IGdyaWQgbGluZXMuXG4gKiBAbWV0aG9kIHhncmlkc1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueC5saW5lcy5cbiAqIEBleGFtcGxlXG4gKiAgLy8gU2hvdyAyIHggZ3JpZCBsaW5lc1xuICogY2hhcnQueGdyaWRzKFtcbiAqICAgIHt2YWx1ZTogMSwgdGV4dDogXCJMYWJlbCAxXCJ9LFxuICogICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAqIF0pO1xuICovXG5jb25zdCB4Z3JpZHMgPSBmdW5jdGlvbihncmlkcykge1xuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRpZiAoIWdyaWRzKSB7XG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XG5cdH1cblxuXHRjb25maWcuZ3JpZF94X2xpbmVzID0gZ3JpZHM7XG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XG59O1xuXG5leHRlbmQoeGdyaWRzLCB7XG5cdC8qKlxuXHQgKiBBZGQgeCBncmlkIGxpbmVzLjxicj5cblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxuXHQgKiBAbWV0aG9kIHhncmlkc+KApGFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeCBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogKTtcblx0ICpcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcblx0ICogY2hhcnQueGdyaWRzLmFkZChbXG5cdCAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogXSk7XG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzKSB7XG5cdFx0cmV0dXJuIHRoaXMueGdyaWRzKFxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF94X2xpbmVzXG5cdFx0XHRcdC5jb25jYXQoZ3JpZHMgfHwgW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHggZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxuXHQgKiBAbWV0aG9kIHhncmlkc+KApHJlbW92ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB4IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8geCBncmlkIGxpbmUgb24geCA9IDIgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe3ZhbHVlOiAyfSk7XG5cdCAqXG5cdCAqIC8vIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe1xuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKCk7XG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcykgeyAvLyBUT0RPOiBtdWx0aXBsZVxuXHRcdHRoaXMuaW50ZXJuYWwucmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG5cbi8qKlxuICogVXBkYXRlIHkgZ3JpZCBsaW5lcy5cbiAqIEBtZXRob2QgeWdyaWRzXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWSBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzLlxuICogQGV4YW1wbGVcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXG4gKiBjaGFydC55Z3JpZHMoW1xuICogICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSxcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAqIF0pO1xuICovXG5jb25zdCB5Z3JpZHMgPSBmdW5jdGlvbihncmlkcykge1xuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRpZiAoIWdyaWRzKSB7XG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XG5cdH1cblxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7XG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XG59O1xuXG5leHRlbmQoeWdyaWRzLCB7XG5cdC8qKlxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeSBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeWdyaWRzLlxuXHQgKiBAbWV0aG9kIHlncmlkc+KApGFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeSBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxuXHQgKiApO1xuXHQgKlxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFtcblx0ICogICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCAyXCJ9LFxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogXSk7XG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzKSB7XG5cdFx0cmV0dXJuIHRoaXMueWdyaWRzKFxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXG5cdFx0XHRcdC5jb25jYXQoZ3JpZHMgfHwgW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxuXHQgKiBAbWV0aG9kIHlncmlkc+KApHJlbW92ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8geSBncmlkIGxpbmUgb24geSA9IDIwMCB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xuXHQgKlxuXHQgKiAvLyB5IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxuXHQgKiB9KTtcblx0ICpcblx0ICogLy8gYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSgpO1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXMpIHsgLy8gVE9ETzogbXVsdGlwbGVcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZhbHNlKTtcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0eGdyaWRzLFxuXHR5Z3JpZHNcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7Z2V0T3B0aW9uLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFVwZGF0ZSByZWdpb25zLlxuICogQG1ldGhvZCByZWdpb25zXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gcmVnaW9ucyBSZWdpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucy5cbiAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zXG4gKiBAZXhhbXBsZVxuICogLy8gU2hvdyAyIHJlZ2lvbnNcbiAqIGNoYXJ0LnJlZ2lvbnMoW1xuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcbiAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuICogXSk7XG4gKi9cbmNvbnN0IHJlZ2lvbnMgPSBmdW5jdGlvbihyZWdpb25zKSB7XG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdGlmICghcmVnaW9ucykge1xuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcblx0fVxuXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcblxuXHRyZXR1cm4gcmVnaW9ucztcbn07XG5cbmV4dGVuZChyZWdpb25zLCB7XG5cdC8qKlxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyByZWdpb24gaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSByZWdpb25zLlxuXHQgKiBAbWV0aG9kIHJlZ2lvbnPigKRhZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBBZGQgYSBuZXcgcmVnaW9uXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxuXHQgKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9XG5cdCAqICk7XG5cdCAqXG5cdCAqIC8vIEFkZCBuZXcgcmVnaW9uc1xuXHQgKiBjaGFydC5yZWdpb25zLmFkZChbXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXG5cdCAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuXHQgKl0pO1xuXHQgKi9cblx0YWRkOiBmdW5jdGlvbihyZWdpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghcmVnaW9ucykge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xuXHRcdH1cblxuXHRcdGNvbmZpZy5yZWdpb25zID0gY29uZmlnLnJlZ2lvbnMuY29uY2F0KHJlZ2lvbnMpO1xuXHRcdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSByZWdpb25zLjxicj48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgcmVnaW9ucy5cblx0ICogQG1ldGhvZCByZWdpb25z4oCkcmVtb3ZlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlZ2lvbnMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XG5cdCAqICAgY2xhc3NlczogW1xuXHQgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcblx0ICogICBdXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKCk7XG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCBvcHRpb25zID0gb3B0aW9uc1ZhbHVlIHx8IHt9O1xuXHRcdGNvbnN0IGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xuXHRcdGNvbnN0IGNsYXNzZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJjbGFzc2VzXCIsIFtDTEFTUy5yZWdpb25dKTtcblx0XHRsZXQgcmVnaW9ucyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXG5cdFx0XHQuc2VsZWN0QWxsKGNsYXNzZXMubWFwKGMgPT4gYC4ke2N9YCkpO1xuXG5cdFx0KGR1cmF0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pIDogcmVnaW9ucylcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRyZWdpb25zID0gY29uZmlnLnJlZ2lvbnM7XG5cblx0XHRpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG5cdFx0XHRyZWdpb25zID0gcmVnaW9ucy5maWx0ZXIocmVnaW9uID0+IHtcblx0XHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCFyZWdpb24uY2xhc3MpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlZ2lvbi5jbGFzcy5zcGxpdChcIiBcIikuZm9yRWFjaChjID0+IHtcblx0XHRcdFx0XHRpZiAoY2xhc3Nlcy5pbmRleE9mKGMpID49IDApIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiAhZm91bmQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25maWcucmVnaW9ucyA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZWdpb25zO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge3JlZ2lvbnN9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZCwgaXNVbmRlZmluZWQsIGlzQXJyYXl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIEdldCBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG4gKiBAbWV0aG9kIGRhdGFcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIENoYXJ0XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIHJldHVybnMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZGF0YS4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IG9ubHkgZGF0YTEgZGF0YVxuICogY2hhcnQuZGF0YShcImRhdGExXCIpO1xuICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXG4gKlxuICogLy8gR2V0IGRhdGExIGFuZCBkYXRhMiBkYXRhXG4gKiBjaGFydC5kYXRhKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuICpcbiAqIC8vIEdldCBhbGwgZGF0YVxuICogY2hhcnQuZGF0YSgpO1xuICovXG5jb25zdCBkYXRhID0gZnVuY3Rpb24odGFyZ2V0SWRzKSB7XG5cdGNvbnN0IHRhcmdldHMgPSB0aGlzLmludGVybmFsLmRhdGEudGFyZ2V0cztcblxuXHRyZXR1cm4gaXNVbmRlZmluZWQodGFyZ2V0SWRzKSA/XG5cdFx0dGFyZ2V0cyA6IHRhcmdldHMuZmlsdGVyKHQgPT4gdGFyZ2V0SWRzLmluZGV4T2YodC5pZCkgPj0gMCk7XG59O1xuXG5leHRlbmQoZGF0YSwge1xuXHQvKipcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKRzaG93blxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBBUEkgZmlsdGVycyB0aGUgZGF0YSB3aXRoIHNwZWNpZmllZCB0YXJnZXQgaWRzLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgYWxsIHNob3duIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgc2hvd24gZGF0YSBieSBmaWx0ZXJpbmcgdG8gaW5jbHVkZSBvbmx5IGRhdGExIGRhdGFcblx0ICogY2hhcnQuZGF0YS5zaG93bihcImRhdGExXCIpO1xuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cblx0ICpcblx0ICogLy8gR2V0IHNob3duIGRhdGEgYnkgZmlsdGVyaW5nIHRvIGluY2x1ZGUgZGF0YTEgYW5kIGRhdGEyIGRhdGFcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogLy8gR2V0IGFsbCBzaG93biBkYXRhXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcblx0ICovXG5cdHNob3duOiBmdW5jdGlvbih0YXJnZXRJZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5maWx0ZXJUYXJnZXRzVG9TaG93KHRoaXMuZGF0YSh0YXJnZXRJZHMpKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKR2YWx1ZXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIFRoaXMgQVBJIHJldHVybnMgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgbnVsbCB3aWxsIGJlIHJldHJ1bmVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIHZhbHVlc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgZGF0YTEgdmFsdWVzXG5cdCAqIGNoYXJ0LmRhdGEudmFsdWVzKFwiZGF0YTFcIik7XG5cdCAqIC8vIC0tPiBbMTAsIDIwLCAzMCwgNDBdXG5cdCAqL1xuXHR2YWx1ZXM6IGZ1bmN0aW9uKHRhcmdldElkLCBmbGF0ID0gdHJ1ZSkge1xuXHRcdGxldCB2YWx1ZXMgPSBudWxsO1xuXG5cdFx0aWYgKHRhcmdldElkKSB7XG5cdFx0XHRjb25zdCB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkKTtcblxuXHRcdFx0aWYgKHRhcmdldHMgJiYgaXNBcnJheSh0YXJnZXRzKSkge1xuXHRcdFx0XHR2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YVZhbHVlID0gdi52YWx1ZXMubWFwKGQgPT4gZC52YWx1ZSk7XG5cblx0XHRcdFx0XHRmbGF0ID8gKHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoZGF0YVZhbHVlKSkgOiB2YWx1ZXMucHVzaChkYXRhVmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBuYW1lcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKRuYW1lc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbmFtZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgbmFtZXNcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xuXHQgKiAvLyAtLT4ge2RhdGExOiBcInRlc3QxXCIsIGRhdGEyOiBcInRlc3QyXCJ9XG5cdCAqXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xuXHQgKiBjaGFydC5kYXRhLm5hbWVzKHtcblx0ICogIGRhdGExOiBcIk5ldyBOYW1lIDFcIixcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxuXHQgKn0pO1xuXHQgKi9cblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzKSB7XG5cdFx0dGhpcy5pbnRlcm5hbC5jbGVhckxlZ2VuZEl0ZW1UZXh0Qm94Q2FjaGUoKTtcblxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwibmFtZXNcIiwgbmFtZXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBjb2xvcnMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkY29sb3JzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY29sb3JzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGNvbG9ycyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgW2RhdGEuY29sb3JzXSguL09wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbG9ycykuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBkYXRhIGNvbG9yIHZhbHVlIGFjY29yZGluZyBpdHMga2V5IHZhbHVlLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgY3VycmVudCBjb2xvcnNcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoKTtcblx0ICogLy8gLS0+IHtkYXRhMTogXCIjMDBjNzNjXCIsIGRhdGEyOiBcIiNmYTcxNzFcIn1cblx0ICpcblx0ICogLy8gVXBkYXRlIGNvbG9yc1xuXHQgKiBjaGFydC5kYXRhLmNvbG9ycyh7XG5cdCAqICBkYXRhMTogXCIjRkZGRkZGXCIsXG5cdCAqICBkYXRhMjogXCIjMDAwMDAwXCJcblx0ICogfSk7XG5cdCAqL1xuXHRjb2xvcnM6IGZ1bmN0aW9uKGNvbG9ycykge1xuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIGNvbG9ycyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkYXhlc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBheGVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBheGVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGF4ZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBheGVzIHZhbHVlIGZvciBkYXRhLCBpZiBzcGVjaWZpZWQgYXhlcyB2YWx1ZS5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuXHQgKiBjaGFydC5kYXRhLmF4ZXMoKTtcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XG5cdCAqXG5cdCAqIC8vIFVwZGF0ZSBheGVzXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcyh7XG5cdCAqICBkYXRhMTogXCJ5XCIsXG5cdCAqICBkYXRhMjogXCJ5MlwiXG5cdCAqIH0pO1xuXHQgKi9cblx0YXhlczogZnVuY3Rpb24oYXhlcykge1xuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBheGVzKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBtaW5pbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XG5cdCAqIEBtZXRob2QgZGF0YeKApG1pblxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuXHQgKiBjaGFydC5kYXRhLm1pbigpO1xuXHQgKiAvLyAtLT4gW3t4OiAwLCB2YWx1ZTogMzAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAwfSwgLi4uXVxuXHQgKi9cblx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWluO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1heGltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcblx0ICogQG1ldGhvZCBkYXRh4oCkbWF4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXG5cdCAqIGNoYXJ0LmRhdGEubWF4KCk7XG5cdCAqIC8vIC0tPiBbe3g6IDMsIHZhbHVlOiA0MDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAzfSwgLi4uXVxuXHQgKi9cblx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWF4O1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge2RhdGF9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIFNldCBzcGVjaWZpZWQgY2F0ZWdvcnkgbmFtZSBvbiBjYXRlZ29yeSBheGlzLlxuXHQgKiBAbWV0aG9kIGNhdGVnb3J5XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGkgaW5kZXggb2YgY2F0ZWdvcnkgdG8gYmUgY2hhbmdlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgdmFsdWUgdG8gYmUgY2hhbmdlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5jYXRlZ29yeSgyLCBcIkNhdGVnb3J5IDNcIik7XG5cdCAqL1xuXHRjYXRlZ29yeShpLCBjYXRlZ29yeSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA9IGNhdGVnb3J5O1xuXHRcdFx0JCQucmVkcmF3KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXG5cdCAqIEBtZXRob2QgY2F0ZWdvcmllc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNhdGVnb3JpZXMgVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmNhdGVnb3JpZXMoW1xuXHQgKiAgICAgIFwiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXG5cdCAqIF0pO1xuXHQgKi9cblx0Y2F0ZWdvcmllcyhjYXRlZ29yaWVzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcblx0XHR9XG5cblx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuXHRcdCQkLnJlZHJhdygpO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNvbG9yXG5cdCAqIEBtZXRob2QgY29sb3Jcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5jb2xvcihcImRhdGExXCIpO1xuXHQgKi9cblx0Y29sb3IoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5jb2xvcihpZCk7IC8vIG1vcmUgcGF0dGVybnNcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCB4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtBcnJheX0geCBJZiB4IGlzIGdpdmVuLCB4IHZhbHVlcyBvZiBldmVyeSB0YXJnZXQgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cblx0ICogQHJldHVybiB7T2JqZWN0fSB4c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcblx0ICogIGNoYXJ0LngoKTtcblx0ICpcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcblx0ICogIGNoYXJ0LngoWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXSk7XG5cdCAqL1xuXHR4KHgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblxuXHRcdGlmIChpc0FycmF5KHgpKSB7XG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xuXHRcdFx0XHQkJC5hcGkuY2F0ZWdvcmllcyh4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldFgoJCQuZGF0YS50YXJnZXRzLCB4KTtcblxuXHRcdFx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpc0NhdGVnb3JpemVkID8gJCQuYXBpLmNhdGVnb3JpZXMoKSA6ICQkLmRhdGEueHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgeHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fSB4cyBJZiB4cyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIHggdmFsdWVzIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXG5cdCAqICBjaGFydC54cygpO1xuXHQgKlxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xuXHQgKiAgY2hhcnQueHMoe1xuXHQgKiAgICBkYXRhMTogWzEwLCAyMCwgMzAsIDQwLCAuLi5dLFxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxuXHQgKiAgfSk7XG5cdCAqL1xuXHR4cyh4cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdGlmIChpc09iamVjdCh4cykpIHtcblx0XHRcdCQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xuXG5cdFx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiAkJC5kYXRhLnhzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFNldCB0aGUgbWluL21heCB2YWx1ZVxuICogQHBhcmFtIHtDaGFydH0gJCRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNldE1pbk1heCA9ICgkJCwgdHlwZSwgdmFsdWUpID0+IHtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRjb25zdCBheGlzWCA9IGBheGlzX3hfJHt0eXBlfWA7XG5cdGNvbnN0IGF4aXNZID0gYGF4aXNfeV8ke3R5cGV9YDtcblx0Y29uc3QgYXhpc1kyID0gYGF4aXNfeTJfJHt0eXBlfWA7XG5cblx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcblx0XHRpZiAoaXNPYmplY3RUeXBlKHZhbHVlKSkge1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS54KSAmJiAoY29uZmlnW2F4aXNYXSA9IHZhbHVlLngpO1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55KSAmJiAoY29uZmlnW2F4aXNZXSA9IHZhbHVlLnkpO1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55MikgJiYgKGNvbmZpZ1theGlzWTJdID0gdmFsdWUueTIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25maWdbYXhpc1ldID0gdmFsdWU7XG5cdFx0XHRjb25maWdbYXhpc1kyXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pbi9tYXggdmFsdWVcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7e3gsIHksIHkyfX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldE1pbk1heCA9ICgkJCwgdHlwZSkgPT4ge1xuXHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0cmV0dXJuIHtcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXG5cdFx0eTogY29uZmlnW2BheGlzX3lfJHt0eXBlfWBdLFxuXHRcdHkyOiBjb25maWdbYGF4aXNfeTJfJHt0eXBlfWBdXG5cdH07XG59O1xuXG4vKipcbiAqIERlZmluZSBheGlzXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGF4aXMgPSBleHRlbmQoKCkgPT4ge30sIHtcblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxuXHQgKiBAbWV0aG9kIGF4aXPigKRsYWJlbHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxzIHNwZWNpZmllZCBheGlzJyBsYWJlbCB0byBiZSB1cGRhdGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcblx0ICogY2hhcnQuYXhpcy5sYWJlbHMoe1xuXHQgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxuXHQgKiAgIHk6IFwiTmV3IFkgQXhpcyBMYWJlbFwiXG5cdCAqIH0pO1xuXHQgKi9cblx0bGFiZWxzOiBmdW5jdGlvbihsYWJlbHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0T2JqZWN0LmtleXMobGFiZWxzKS5mb3JFYWNoKGF4aXNJZCA9PiB7XG5cdFx0XHRcdCQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdCQkLmF4aXMudXBkYXRlTGFiZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiB2YWx1ZS5cblx0ICogQG1ldGhvZCBheGlz4oCkbWluXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG1pbiBJZiBtaW4gaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtaW4gdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWluIHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIG1pblxuXHQgKiBjaGFydC5heGlzLm1pbih7XG5cdCAqICAgeDogLTEwLFxuXHQgKiAgIHk6IDEwMDAsXG5cdCAqICAgeTI6IDEwMFxuXHQgKiB9KTtcblx0ICovXG5cdG1pbjogZnVuY3Rpb24obWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1pblwiLCBtaW4pIDpcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtaW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxuXHQgKiBAbWV0aG9kIGF4aXPigKRtYXhcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxuXHQgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtYXggdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtYXggdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcblx0ICogY2hhcnQuYXhpcy5tYXgoe1xuXHQgKiAgICB4OiAxMDAsXG5cdCAqICAgIHk6IDEwMDAsXG5cdCAqICAgIHkyOiAxMDAwMFxuXHQgKiB9KTtcblx0ICovXG5cdG1heDogZnVuY3Rpb24obWF4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1heFwiLCBtYXgpIDpcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtYXhcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXG5cdCAqIEBtZXRob2QgYXhpc+KApHJhbmdlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXG5cdCAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xuXHQgKiAgIG1pbjoge1xuXHQgKiAgICAgeDogLTEwLFxuXHQgKiAgICAgeTogLTEwMDAsXG5cdCAqICAgICB5MjogLTEwMDAwXG5cdCAqICAgfSxcblx0ICogICBtYXg6IHtcblx0ICogICAgIHg6IDEwMCxcblx0ICogICAgIHk6IDEwMDAsXG5cdCAqICAgICB5MjogMTAwMDBcblx0ICogICB9LFxuXHQgKiB9KTtcblx0ICovXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1heCkgJiYgYXhpcy5tYXgocmFuZ2UubWF4KTtcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5taW4pICYmIGF4aXMubWluKHJhbmdlLm1pbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1heDogYXhpcy5tYXgoKSxcblx0XHRcdFx0bWluOiBheGlzLm1pbigpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7YXhpc30pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBEZWZpbmUgbGVnZW5kXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGxlZ2VuZCA9IGV4dGVuZCgoKSA9PiB7fSwge1xuXHQvKipcblx0ICogU2hvdyBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxuXHQgKiBAbWV0aG9kIGxlZ2VuZOKApHNob3dcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG5cdCAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMS5cblx0ICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cblx0ICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIFNob3cgYWxsIGxlZ2VuZC5cblx0ICogY2hhcnQubGVnZW5kLnNob3coKTtcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdCQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cblx0ICogQG1ldGhvZCBsZWdlbmTigKRoaWRlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXG5cdCAqIC0gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMS5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIEhpZGUgYWxsIGxlZ2VuZC5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoKTtcblx0ICovXG5cdGhpZGU6IGZ1bmN0aW9uKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdCQkLmhpZGVMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7bGVnZW5kfSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IHtub3RFbXB0eSwgaXNEZWZpbmVkLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIHJlc2l6ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaXplIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFJlc2l6ZSB0byA2NDB4NDgwXG5cdCAqIGNoYXJ0LnJlc2l6ZSh7XG5cdCAqICAgIHdpZHRoOiA2NDAsXG5cdCAqICAgIGhlaWdodDogNDgwXG5cdCAqIH0pO1xuXHQgKi9cblx0cmVzaXplKHNpemUpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmludGVybmFsLmNvbmZpZztcblxuXHRcdGNvbmZpZy5zaXplX3dpZHRoID0gc2l6ZSA/IHNpemUud2lkdGggOiBudWxsO1xuXHRcdGNvbmZpZy5zaXplX2hlaWdodCA9IHNpemUgPyBzaXplLmhlaWdodCA6IG51bGw7XG5cblx0XHR0aGlzLmZsdXNoKGZhbHNlLCB0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogRm9yY2UgdG8gcmVkcmF3LlxuXHQgKiBAbWV0aG9kIGZsdXNoXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc29mdF0gRm9yIHNvZnQgcmVkcmF3LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0Zyb21SZXNpemVdIEZvciBzb2Z0IHJlZHJhdy5cblx0ICogQGV4YW1wbGVcblx0ICogY2hhcnQuZmx1c2goKTtcblx0ICpcblx0ICogLy8gZm9yIHNvZnQgcmVkcmF3XG5cdCAqIGNoYXJ0LmZsdXNoKHRydWUpO1xuXHQgKi9cblx0Zmx1c2goc29mdCwgaXNGcm9tUmVzaXplKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZVxuXHRcdGlmIChpc0Zyb21SZXNpemUpIHtcblx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyByZS11cGRhdGUgY29uZmlnIGluZm9cblx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcblx0XHR9XG5cblx0XHQkJC56b29tU2NhbGUgPSBudWxsO1xuXG5cdFx0c29mdCA/ICQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcblx0XHR9KSA6ICQkLnVwZGF0ZUFuZFJlZHJhdyh7XG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgY2hhcnQgb2JqZWN0IGFuZCByZW1vdmUgZWxlbWVudCBhbmQgZXZlbnRzIGNvbXBsZXRlbHkuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmRlc3Ryb3koKTtcblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xuXHRcdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkd2lsbERlc3Ryb3lcIik7XG5cdFx0XHQkJC5jaGFydHMuc3BsaWNlKCQkLmNoYXJ0cy5pbmRleE9mKHRoaXMpLCAxKTtcblxuXHRcdFx0Ly8gY2xlYXIgdGltZXJzICYmIHBlbmRpbmcgdHJhbnNpdGlvblxuXHRcdFx0JCQuc3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCk7XG5cdFx0XHRpc0RlZmluZWQoJCQucmVzaXplVGltZW91dCkgJiYgd2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcblxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xuXHRcdFx0JCQuc2VsZWN0Q2hhcnQuY2xhc3NlZChcImJiXCIsIGZhbHNlKS5odG1sKFwiXCIpO1xuXG5cdFx0XHQvLyByZWxlYXNpbmcgcmVmZXJlbmNlc1xuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRrZXkgPT09IFwiaW50ZXJuYWxcIiAmJiBPYmplY3Qua2V5cygkJCkuZm9yRWFjaChrID0+IHtcblx0XHRcdFx0XHQkJFtrXSA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXNba2V5XSA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IG9yIHNldCBzaW5nbGUgY29uZmlnIG9wdGlvbiB2YWx1ZS5cblx0ICogQG1ldGhvZCBjb25maWdcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWRyYXddIFNldCB0byByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvbiBjaGFuZ2VzLlxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XG5cdCAqXG5cdCAqIC8vIFNldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcblx0ICpcblx0ICogLy8gU2V0dGVyICYgcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb25cblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XG5cdCAqL1xuXHRjb25maWcobmFtZSwgdmFsdWUsIHJlZHJhdykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcblx0XHRsZXQgcmVzO1xuXG5cdFx0aWYgKGtleSBpbiAkJC5jb25maWcpIHtcblx0XHRcdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRcdCQkLmNvbmZpZ1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xuXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMgPSAkJC5jb25maWdba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBEZWZpbmUgdG9vbHRpcFxuICogQGlnbm9yZVxuICovXG5jb25zdCB0b29sdGlwID0gZXh0ZW5kKCgpID0+IHt9LCB7XG5cdC8qKlxuXHQgKiBTaG93IHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcblx0ICogICAgfCB4IHwgTnVtYmVyICZ2ZXJ0OyBEYXRlIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IHggQXhpcyBpbmRleCB8XG5cdCAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkIHggQXhpcyBlbGVtZW50Ljxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge051bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge051bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7U3RyaW5nfTogQXhpcyBpZC4gJ3knIG9yICd5MicoZGVmYXVsdCAneScpPGJyPi0gdmFsdWUge051bWJlcn06IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciB0b29sdGlwLiB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBzaG93IHRoZSAybmQgeCBBeGlzIGNvb3JkaW5hdGUgdG9vbHRpcFxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcblx0ICogICAgaW5kZXg6IDFcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gc2hvdyB0b29sdGlwIGZvciB0aGUgM3JkIHggQXhpcyBpbiB4OjUwIGFuZCB5OjEwMCBjb29yZGluYXRlIHJlbGF0aXZlIHRoZSB4IEF4aXMgZWxlbWVudC5cblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHt4OiAyfSxcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xuXHQgKiAgICB4OiBuZXcgRGF0ZShcIjIwMTgtMDEtMDIgMDA6MDBcIilcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzIHVzZWRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIHg6IDMsICAvLyB4IEF4aXMgdmFsdWVcblx0ICogICAgICAgIGlkOiBcInlcIiwgIC8vIGF4aXMgaWQuICd5JyBvciAneTInIChkZWZhdWx0ICd5Jylcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcblx0ICogICAgfVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyB3aGVuIGRhdGEueHMgaXNuJ3QgdXNlZCwgYnV0IHRvb2x0aXAuZ3JvdXBlZD1mYWxzZSBpcyBzZXRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIGluZGV4OiAzLCAgLy8gb3IgJ3gnIGtleSB2YWx1ZVxuXHQgKiAgICAgICAgaWQ6IFwieVwiLCAgLy8gYXhpcyBpZC4gJ3knIG9yICd5MicgKGRlZmF1bHQgJ3knKVxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxuXHQgKiAgICB9XG5cdCAqICB9KTtcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MgPSB7fSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgaW5kZXg7XG5cdFx0bGV0IG1vdXNlO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIG1vdXNlIHBvc2l0aW9uIG9uIHRoZSBjaGFydFxuXHRcdGlmIChhcmdzLm1vdXNlKSB7XG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcblx0XHRpZiAoYXJncy5kYXRhKSB7XG5cdFx0XHRjb25zdCB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcblxuXHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdFx0Ly8gaWYgbXVsdGlwbGUgeHMsIHRhcmdldCBwb2ludCB3aWxsIGJlIGRldGVybWluZWQgYnkgbW91c2Vcblx0XHRcdFx0bW91c2UgPSBbJCQueChhcmdzLmRhdGEueCksIHldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkJC5jb25maWcudG9vbHRpcF9ncm91cGVkKSB7XG5cdFx0XHRcdFx0bW91c2UgPSBbMCwgeV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCA9IGlzVmFsdWUoYXJncy5kYXRhLmluZGV4KSA/IGFyZ3MuZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGFyZ3MuZGF0YS54KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XG5cdFx0XHRpbmRleCA9ICQkLmdldEluZGV4QnlYKGFyZ3MueCk7XG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5pbmRleCkpIHtcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcblx0XHR9XG5cblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XG5cdFx0KCQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiID9cblx0XHRcdFtcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiXSA6IFtcInRvdWNoc3RhcnRcIl1cblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcblx0XHRcdCQkLmRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBpbmRleCwgbW91c2UpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkaGlkZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHQkJC5oaWRlVG9vbHRpcCh0cnVlKTtcblx0XHQkJC5oaWRlWEdyaWRGb2N1cygpO1xuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge3Rvb2x0aXB9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbiwgdG9BcnJheSwgZ2V0Q3NzUnVsZXN9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIEVuY29kZSB0byBiYXNlNjRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3dCYXNlNjQvQmFzZTY0X2VuY29kaW5nX2FuZF9kZWNvZGluZ1xuICovXG5jb25zdCBiNjRFbmNvZGVVbmljb2RlID0gc3RyID0+IGJ0b2EoXG5cdGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG5cdFx0LnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csIChtYXRjaCwgcCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShgMHgke3B9YCkpXG4pO1xuXG4vKipcbiAqIENvbnZlcnQgc3ZnIG5vZGUgdG8gZGF0YSB1cmxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vZGVUb1N2Z0RhdGFVcmwgPSAobm9kZSwgc2l6ZSkgPT4ge1xuXHRjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcblx0Y29uc3QgY2xvbmUgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcblx0Y29uc3QgY3NzVGV4dCA9IGdldENzc1J1bGVzKHRvQXJyYXkoZG9jdW1lbnQuc3R5bGVTaGVldHMpKVxuXHRcdC5maWx0ZXIociA9PiByLmNzc1RleHQpXG5cdFx0Lm1hcChyID0+IHIuY3NzVGV4dCk7XG5cblx0Y2xvbmUuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgZDNOYW1lc3BhY2VzLnhodG1sKTtcblxuXHRjb25zdCBub2RlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhjbG9uZSk7XG5cblx0Ly8gZXNjYXBlIGNzcyBmb3IgWE1MXG5cdGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQuam9pbihcIlxcblwiKSkpO1xuXG5cdGNvbnN0IHN0eWxlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdHlsZSk7XG5cblx0Ly8gZm9yZWlnbk9iamVjdCBub3Qgc3VwcG9ydGVkIGluIElFMTEgYW5kIGJlbG93XG5cdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFxuXHRjb25zdCBkYXRhU3RyID0gYDxzdmcgeG1sbnM9XCIke2QzTmFtZXNwYWNlcy5zdmd9XCIgd2lkdGg9XCIke3NpemUud2lkdGh9XCIgaGVpZ2h0PVwiJHtzaXplLmhlaWdodH1cIj5cblx0XHRcdDxmb3JlaWduT2JqZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cblx0XHRcdFx0JHtzdHlsZVhtbH1cblx0XHRcdFx0JHtub2RlWG1sLnJlcGxhY2UoLyh1cmxcXCgpW14jXSsvZywgXCIkMVwiKX1cblx0XHRcdDwvZm9yZWlnbk9iamVjdD48L3N2Zz5gXG5cdFx0LnJlcGxhY2UoXCIvXFxuL2dcIiwgXCIlMEFcIik7XG5cblx0cmV0dXJuIGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7YjY0RW5jb2RlVW5pY29kZShkYXRhU3RyKX1gO1xufTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogRXhwb3J0IGNoYXJ0IGFzIGFuIGltYWdlLlxuXHQgKiAtICoqTk9URToqKlxuXHQgKiAgIC0gSUUxMSBhbmQgYmVsb3cgbm90IHdvcmsgcHJvcGVybHkgZHVlIHRvIHRoZSBsYWNrIG9mIHRoZSBmZWF0dXJlKDxhIGhyZWY9XCJodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2hoODM0Njc1KHY9dnMuODUpLmFzcHhcIj5mb3JlaWduT2JqZWN0PC9hPikgc3VwcG9ydFxuXHQgKiAgIC0gVGhlIGJhc2ljIENTUyBmaWxlKGV4LiBiaWxsYm9hcmQuY3NzKSBzaG91bGQgYmUgYXQgc2FtZSBkb21haW4gYXMgQVBJIGNhbGwgY29udGV4dCB0byBnZXQgY29ycmVjdCBzdHlsZWQgZXhwb3J0IGltYWdlLlxuXHQgKiBAbWV0aG9kIGV4cG9ydFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9aW1hZ2UvcG5nXSBUaGUgZGVzaXJlZCBvdXRwdXQgaW1hZ2UgZm9ybWF0LiAoZXguICdpbWFnZS9wbmcnIGZvciBwbmcsICdpbWFnZS9qcGVnJyBmb3IganBlZyBmb3JtYXQpXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBleHBvcnQgaXMgcmVhZHkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gZGF0YVVSSVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgY2hhcnQuZXhwb3J0KCk7XG5cdCAqICAvLyAtLT4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITi4uLlwiXG5cdCAqXG5cdCAqICAvLyBJbml0aWFsaXplIHRoZSBkb3dubG9hZCBhdXRvbWF0aWNhbGx5XG5cdCAqICBjaGFydC5leHBvcnQoXCJpbWFnZS9wbmdcIiwgZGF0YVVybCA9PiB7XG5cdCAqICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdCAqXG5cdCAqICAgICBsaW5rLmRvd25sb2FkID0gYCR7RGF0ZS5ub3coKX0ucG5nYDtcblx0ICogICAgIGxpbmsuaHJlZiA9IGRhdGFVcmw7XG5cdCAqICAgICBsaW5rLmlubmVySFRNTCA9IFwiRG93bmxvYWQgY2hhcnQgYXMgaW1hZ2VcIjtcblx0ICpcblx0ICogICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG5cdCAqICB9KTtcblx0ICovXG5cdGV4cG9ydChtaW1lVHlwZSwgY2FsbGJhY2spIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3Qgc2l6ZSA9IHt3aWR0aDogJCQuY3VycmVudFdpZHRoLCBoZWlnaHQ6ICQkLmN1cnJlbnRIZWlnaHR9O1xuXHRcdGNvbnN0IHN2Z0RhdGFVcmwgPSBub2RlVG9TdmdEYXRhVXJsKHRoaXMuZWxlbWVudCwgc2l6ZSk7XG5cblx0XHRpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG5cdFx0XHRpbWcuY3Jvc3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcblx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cblx0XHRcdFx0Y2FudmFzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cblx0XHRcdFx0Y2FsbGJhY2soY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSkpO1xuXHRcdFx0fTtcblxuXHRcdFx0aW1nLnNyYyA9IHN2Z0RhdGFVcmw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN2Z0RhdGFVcmw7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuL2F4aXMvQXhpc1wiO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2VPYmp9IGZyb20gXCIuL2ludGVybmFscy91dGlsXCI7XG5cbmltcG9ydCBcIi4vY29uZmlnL2NvbmZpZ1wiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvc2NhbGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2RvbWFpblwiO1xuaW1wb3J0IFwiLi9kYXRhL2RhdGFcIjtcbmltcG9ydCBcIi4vZGF0YS9kYXRhLmNvbnZlcnRcIjtcbmltcG9ydCBcIi4vZGF0YS9kYXRhLmxvYWRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NhdGVnb3J5XCI7XG5pbXBvcnQgXCIuL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvblwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvc2l6ZVwiO1xuaW1wb3J0IFwiLi9zaGFwZS9zaGFwZVwiO1xuaW1wb3J0IFwiLi9zaGFwZS9hcmNcIjtcbmltcG9ydCBcIi4vc2hhcGUvYmFyXCI7XG5pbXBvcnQgXCIuL3NoYXBlL2J1YmJsZVwiO1xuaW1wb3J0IFwiLi9zaGFwZS9saW5lXCI7XG5pbXBvcnQgXCIuL3NoYXBlL3BvaW50XCI7XG5pbXBvcnQgXCIuL3NoYXBlL3JhZGFyXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy90ZXh0XCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy90eXBlXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9ncmlkXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy90b29sdGlwXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9sZWdlbmRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3RpdGxlXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9jbGlwXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9yZWdpb25cIjtcbmltcG9ydCBcIi4vaW50ZXJhY3Rpb25zL2RyYWdcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3NlbGVjdGlvblwiO1xuaW1wb3J0IFwiLi9pbnRlcmFjdGlvbnMvc3ViY2hhcnRcIjtcbmltcG9ydCBcIi4vaW50ZXJhY3Rpb25zL3pvb21cIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NvbG9yXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9mb3JtYXRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NhY2hlXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9jbGFzc1wiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmZvY3VzXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuc2hvd1wiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLnpvb21cIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5sb2FkXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZmxvd1wiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLnNlbGVjdGlvblwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLnRyYW5zZm9ybVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmdyb3VwXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZ3JpZFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLnJlZ2lvblwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmRhdGFcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5jYXRlZ29yeVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmNvbG9yXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkueFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmF4aXNcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5sZWdlbmRcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5jaGFydFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLnRvb2x0aXBcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5leHBvcnRcIjtcblxuLy8gYmFzZSBDU1NcbmltcG9ydCBcIi4vc2Nzcy9iaWxsYm9hcmQuc2Nzc1wiO1xuXG5sZXQgZGVmYXVsdHMgPSB7fTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGJiXG4gKiBAdmVyc2lvbiAxLjkuMlxuICovXG5jb25zdCBiYiA9IHtcblx0LyoqXG5cdCAqIFZlcnNpb24gaW5mb3JtYXRpb25cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IHZlcnNpb24gdmVyc2lvblxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgICBiYi52ZXJzaW9uOyAgLy8gXCIxLjAuMFwiXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKi9cblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBjaGFydFxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICogQHJldHVybiB7Q2hhcnR9XG5cdCAqIEBzZWUge0BsaW5rIE9wdGlvbnN9IGZvciBkaWZmZXJlbnQgZ2VuZXJhdGlvbiBvcHRpb25zXG5cdCAqIEBzZWUge0BsaW5rIENoYXJ0fSBmb3IgZGlmZmVyZW50IG1ldGhvZHMgQVBJXG5cdCAqIEBleGFtcGxlXG5cdCAqICA8IS0tIGNoYXJ0IGhvbGRlciAtLT5cblx0ICogPGRpdiBpZD1cIkxpbmVDaGFydFwiPjwvZGl2PlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIGdlbmVyYXRlIGNoYXJ0IHdpdGggb3B0aW9uc1xuXHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuXHQgKiAgICAgIFwiYmluZHRvXCI6IFwiI0xpbmVDaGFydFwiXG5cdCAqICAgICAgXCJkYXRhXCI6IHtcblx0ICogICAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMCwgNDAwLCAxNTAsIDI1MF0sXG5cdCAqICAgICAgICAgICAgICBbXCJkYXRhMlwiLCA1MCwgMjAsIDEwLCA0MCwgMTUsIDI1XVxuXHQgKiAgICAgICAgICAgXVxuXHQgKiAgICAgIH1cblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gY2FsbCBzb21lIEFQSVxuXHQgKiAgLy8gZXgpIGdldCB0aGUgZGF0YSBvZiAnZGF0YTEnXG5cdCAqICBjaGFydC5kYXRhKFwiZGF0YTFcIik7XG5cdCAqL1xuXHRnZW5lcmF0ZShjb25maWcpIHtcblx0XHRjb25zdCBvcHRpb25zID0gbWVyZ2VPYmooe30sIGRlZmF1bHRzLCBjb25maWcpO1xuXHRcdGNvbnN0IGluc3QgPSBuZXcgQ2hhcnQob3B0aW9ucyk7XG5cblx0XHRpbnN0LmludGVybmFsLmNoYXJ0cyA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0dGhpcy5pbnN0YW5jZS5wdXNoKGluc3QpO1xuXG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cblx0ICogLSAqKk5PVEU6Kipcblx0ICogICAtIFRoZSBvcHRpb25zIHZhbHVlcyBzZXR0aW5ncyBhcmUgdmFsaWQgd2l0aGluIHBhZ2UgY29udGV4dCBvbmx5LlxuXHQgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICogQHJldHVybiB7T3B0aW9uc31cblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc31cblx0ICogQGV4YW1wbGVcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXG5cdCAqIGJiLmRlZmF1bHRzKHtcblx0ICogICBkYXRhOiB7XG5cdCAqICAgICB0eXBlOiBcImJhclwiXG5cdCAqICAgfVxuXHQgKiB9KTtcblx0ICpcblx0ICogYmIuZGVmYXVsdHMoKTsgIC8vIHtkYXRhOnt0eXBlOiBcImJhclwifX1cblx0ICpcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXG5cdCAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuXHQgKi9cblx0ZGVmYXVsdHMob3B0aW9ucykge1xuXHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHRcdFx0ZGVmYXVsdHMgPSBvcHRpb25zO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZhdWx0cztcblx0fSxcblxuXHQvKipcblx0ICogQW4gYXJyYXkgY29udGFpbmluZyBpbnN0YW5jZSBjcmVhdGVkXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IGluc3RhbmNlIGluc3RhbmNlIGFycmF5XG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBnZW5lcmF0ZSBjaGFydHNcblx0ICogIHZhciBjaGFydDEgPSBiYi5nZW5lcmF0ZSguLi4pO1xuXHQgKiAgdmFyIGNoYXJ0MiA9IGJiLmdlbmVyYXRlKC4uLik7XG5cdCAqXG5cdCAqICBiYi5pbnN0YW5jZTsgIC8vIFsgY2hhcnQxLCBjaGFydDIsIC4uLiBdXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKi9cblx0aW5zdGFuY2U6IFtdLFxuXG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgZm9yIHBsdWdpbnNcblx0ICogQHByb3BlcnR5IHtPYmplY3R9IHBsdWdpbiBwbHVnaW4gbmFtZXNwYWNlXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBTdGFuZm9yZCBkaWFncmFtIHBsdWdpblxuXHQgKiAgYmIucGx1Z2luLnN0YW5mb3JkO1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICovXG5cdHBsdWdpbjoge30sXG5cblx0LyoqXG5cdCAqIEludGVybmFsIGNoYXJ0IG9iamVjdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2hhcnQ6IHtcblx0XHRmbjogQ2hhcnQucHJvdG90eXBlLFxuXHRcdGludGVybmFsOiB7XG5cdFx0XHRmbjogQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsXG5cdFx0XHRheGlzOiB7XG5cdFx0XHRcdGZuOiBBeGlzLnByb3RvdHlwZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuZXhwb3J0IHtiYn07XG5leHBvcnQgZGVmYXVsdCBiYjtcbiJdLCJzb3VyY2VSb290IjoiIn0=