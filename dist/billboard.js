(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-axis", "d3-brush", "d3-scale", "d3-dsv", "d3-drag", "d3-shape", "d3-interpolate", "d3-color", "d3-zoom", "d3-ease"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__52__, __WEBPACK_EXTERNAL_MODULE__54__, __WEBPACK_EXTERNAL_MODULE__55__, __WEBPACK_EXTERNAL_MODULE__56__, __WEBPACK_EXTERNAL_MODULE__57__, __WEBPACK_EXTERNAL_MODULE__58__, __WEBPACK_EXTERNAL_MODULE__59__, __WEBPACK_EXTERNAL_MODULE__60__, __WEBPACK_EXTERNAL_MODULE__61__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(33);
module.exports = __webpack_require__(62);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(10);

var _require = __webpack_require__(16),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(18);

var reloadApp = __webpack_require__(19);

var createSocketUrl = __webpack_require__(22);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(31);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(9);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.3.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(11);

var _require = __webpack_require__(12),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(13),
  Html4Entities: __webpack_require__(14),
  Html5Entities: __webpack_require__(15),
  AllHtmlEntities: __webpack_require__(15)
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(17).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(16),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(20);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(21);
module.exports = new EventEmitter();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(23);

var querystring = __webpack_require__(27);

var getCurrentScriptSource = __webpack_require__(30);

function createSocketUrl(resourceQuery) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    urlParts = url.parse(resourceQuery.substr(1));
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape

    scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
    urlParts = url.parse(scriptHost || '/', false, true);
  }

  if (!urlParts.port || urlParts.port === '0') {
    urlParts.port = self.location.port;
  }

  var _urlParts = urlParts,
      auth = _urlParts.auth,
      path = _urlParts.path;
  var _urlParts2 = urlParts,
      hostname = _urlParts2.hostname,
      protocol = _urlParts2.protocol; // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  var isAnyHostname = (hostname === '0.0.0.0' || hostname === '::') && self.location.hostname && // eslint-disable-next-line no-bitwise
  !!~self.location.protocol.indexOf('http');

  if (isAnyHostname) {
    hostname = self.location.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = self.location.protocol;
  } // default values of the sock url if they are not provided


  var sockHost = hostname;
  var sockPath = '/sockjs-node';
  var sockPort = urlParts.port; // eslint-disable-next-line no-undefined

  var shouldParsePath = path !== null && path !== undefined && path !== '/';

  if (shouldParsePath) {
    var parsedQuery = querystring.parse(path); // all of these sock url params are optionally passed in through
    // resourceQuery, so we need to fall back to the default if
    // they are not provided

    sockHost = parsedQuery.sockHost || sockHost;
    sockPath = parsedQuery.sockPath || sockPath;
    sockPort = parsedQuery.sockPort || sockPort;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(24);
var util = __webpack_require__(26);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(27);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(25)(module), __webpack_require__(8)))

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(28);
exports.encode = exports.stringify = __webpack_require__(29);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 32
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 31;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(34);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(36)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(35)(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px GothamPro;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  fill: #5D5C71; }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px GothamPro; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: none; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n\nh2#title {\n  font-size: 16px;\n  text-transform: \"uppercase\"; }\n", ""]);


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stylesInDom = {};

var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

function listToStyles(list, options) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}

function addStylesToDom(styles, options) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i];
    var domStyle = stylesInDom[item.id];
    var j = 0;

    if (domStyle) {
      domStyle.refs++;

      for (; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j]);
      }

      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j], options));
      }
    } else {
      var parts = [];

      for (; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j], options));
      }

      stylesInDom[item.id] = {
        id: item.id,
        refs: 1,
        parts: parts
      };
    }
  }
}

function insertStyleElement(options) {
  var style = document.createElement('style');

  if (typeof options.attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      options.attributes.nonce = nonce;
    }
  }

  Object.keys(options.attributes).forEach(function (key) {
    style.setAttribute(key, options.attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {};
  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  var styles = listToStyles(list, options);
  addStylesToDom(styles, options);
  return function update(newList) {
    var mayRemove = [];

    for (var i = 0; i < styles.length; i++) {
      var item = styles[i];
      var domStyle = stylesInDom[item.id];

      if (domStyle) {
        domStyle.refs--;
        mayRemove.push(domStyle);
      }
    }

    if (newList) {
      var newStyles = listToStyles(newList, options);
      addStylesToDom(newStyles, options);
    }

    for (var _i = 0; _i < mayRemove.length; _i++) {
      var _domStyle = mayRemove[_i];

      if (_domStyle.refs === 0) {
        for (var j = 0; j < _domStyle.parts.length; j++) {
          _domStyle.parts[j]();
        }

        delete stylesInDom[_domStyle.id];
      }
    }
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(39);

var iterableToArrayLimit = __webpack_require__(40);

var nonIterableRest = __webpack_require__(41);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(48);

var iterableToArray = __webpack_require__(49);

var nonIterableSpread = __webpack_require__(50);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 51 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__52__;

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return doc; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */
var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    doc = win && win.document;
/* eslint-enable no-new-func, no-undef */



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__54__;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__55__;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__56__;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__57__;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__58__;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__59__;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__60__;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__61__;

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(37);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(38);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(42);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(43);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(44);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(45);

// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/config/classes.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_"
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(47);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(51);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(52);

// EXTERNAL MODULE: ./src/internals/browser.js
var browser = __webpack_require__(53);

// CONCATENATED MODULE: ./src/internals/util.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */





var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof_default()(v) === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return arr && arr.constructor === Array;
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
},
    getOption = function (options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
},
    util_hasValue = function (dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
},
    callFn = function (fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
},
    sanitise = function (str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
},
    setTextValue = function (node, text) {
  var dy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-1, 1],
      toMiddle = !!(arguments.length > 3 && arguments[3] !== undefined) && arguments[3];
  if (node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", "".concat(i === 0 ? dy[0] * len : dy[1], "em")).text(v);
      });
    }
  }
},
    getRectSegList = function (path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height // seg3

  }];
},
    getPathBox = function (path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
},
    getBrushSelection = function (ctx) {
  var selection = null,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = ctx.context || ctx.main;
  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select(".".concat(config_classes.brush)).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
},
    getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
},
    getRandom = function () {
  var asStr = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
  return Math.random() + (asStr ? "" : 0);
},
    brushEmpty = function (ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
},
    extend = function () {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      source = arguments.length > 1 ? arguments[1] : undefined;

  for (var p in source) target[p] = source[p];

  return target;
},
    capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
},
    getCssRules = function (styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from ".concat(sheet.href, ": ").concat(e.toString()));
    }
  }), rules;
},
    getUnique = function (data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
},
    mergeArray = function (arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
},
    mergeObj = function (_mergeObj) {
  function mergeObj() {
    return _mergeObj.apply(this, arguments);
  }

  return mergeObj.toString = function () {
    return _mergeObj.toString();
  }, mergeObj;
}(function (target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}),
    sortValue = function (data) {
  var fn,
      isAsc = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
},
    getMinMax = function (type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, toConsumableArray_default()(res)) : res[0] instanceof Date && (res = sortValue(res, type === "min")[0]) : res = undefined, res;
},
    getRange = function (start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams();
        el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams(),
            mouseEvent = browser["document"].createEvent("MouseEvent");
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, browser["window"], 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
},
    tplProcess = function (tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=".concat(x, "}"), "g"), data[x]);

  return res;
};


// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(54);

// CONCATENATED MODULE: ./src/axis/AxisRendererHelper.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(config, params) {
    classCallCheck_default()(this, AxisRendererHelper);

    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])();
    this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = scale.rangeExtent ? scale.rangeExtent() : this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  return createClass_default()(AxisRendererHelper, [{
    key: "axisX",
    value: function axisX(selection, x) {
      var _this = this;

      selection.attr("transform", function (d) {
        return "translate(".concat(Math.ceil(x(d) + _this.config.tickOffset), ",0)");
      });
    }
  }, {
    key: "axisY",
    value: function axisY(selection, y) {
      selection.attr("transform", function (d) {
        return "translate(0,".concat(Math.ceil(y(d)), ")");
      });
    }
  }, {
    key: "scaleExtent",
    value: function scaleExtent(domain) {
      var start = domain[0],
          stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
    }
  }, {
    key: "generateTicks",
    value: function generateTicks(scale) {
      var ticks = [];
      if (scale.ticks) return scale.ticks.apply(scale, toConsumableArray_default()(this.config.tickArguments || [])).map(function (v) {
        return (// round the tick value if is number
          isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
        );
      });

      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      return ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0])), ticks;
    }
  }, {
    key: "copyScale",
    value: function copyScale() {
      var newScale = this.scale.copy();
      return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
    }
  }, {
    key: "textFormatted",
    value: function textFormatted(v) {
      var tickFormat = this.config.tickFormat,
          value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
          formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
      // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
      // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

      return isDefined(formatted) ? formatted : "";
    }
  }, {
    key: "transitionise",
    value: function transitionise(selection) {
      var config = this.config;
      return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
    }
  }], [{
    key: "getSizeFor1Char",
    value: function getSizeFor1Char(node) {
      // default size for one character
      var size = {
        w: 5.5,
        h: 11.5
      };
      return node.empty() || node.select("text").text("0").call(function (el) {
        try {
          var _el$node$getBBox = el.node().getBBox(),
              width = _el$node$getBBox.width,
              height = _el$node$getBBox.height;

          width && height && (size.w = width, size.h = height), el.text("");
        } catch (e) {}
      }), this.getSizeFor1Char = function () {
        return size;
      }, size;
    }
  }]), AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/axis/AxisRenderer.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AxisRenderer);

    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.helper = new AxisRendererHelper_AxisRendererHelper(config, params), this.config = config, this.params = params;
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  return createClass_default()(AxisRenderer, [{
    key: "create",
    value: function create(g) {
      var ctx = this,
          config = this.config,
          params = this.params,
          helperInst = this.helper,
          scale = helperInst.scale,
          orient = config.orient,
          splitTickText = this.splitTickText.bind(this),
          isLeftRight = /^(left|right)$/.test(orient),
          isTopBottom = /^(top|bottom)$/.test(orient),
          tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
          axisPx = tickTransform === helperInst.axisX ? "y" : "x",
          sign = /^(top|left)$/.test(orient) ? -1 : 1,
          rotate = params.tickTextRotate;
      this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
      var _config = config,
          innerTickSize = _config.innerTickSize,
          tickLength = _config.tickLength,
          range = _config.range,
          name = params.name,
          tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_".concat(name, "_tick_text_position")] : {
        x: 0,
        y: 0
      },
          prefix = name === "subX" ? "subchart_axis_x" : "axis_".concat(name),
          axisShow = params.config["".concat(prefix, "_show")],
          tickShow = {
        tick: !!axisShow && params.config["".concat(prefix, "_tick_show")],
        text: !!axisShow && params.config["".concat(prefix, "_tick_text_show")]
      },
          $g = null; // // get the axis' tick position configuration

      g.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            scale0 = this.__chart__ || scale,
            scale1 = helperInst.copyScale();
        $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
        // update selection - data join
        var path = g.selectAll(".domain").data([0]); // enter + update selection

        if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
          var outerTickSized = config.outerTickSize * sign;
          return isTopBottom ? "M".concat(range[0], ",").concat(outerTickSized, "V0H").concat(range[1], "V").concat(outerTickSized) : "M".concat(outerTickSized, ",").concat(range[0], "H0V").concat(range[1], "H").concat(outerTickSized);
        }), tickShow.tick || tickShow.text) {
          // count of tick data in array
          var ticks = config.tickValues || helperInst.generateTicks(scale1),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
              tickExit = tick.exit().remove(); // update selection

          tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
          var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
              counts = [],
              tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
            var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
            return counts[index] = split.length, split.map(function (splitted) {
              return {
                index: index,
                splitted: splitted
              };
            });
          });
          tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
            return d.splitted;
          }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
            var dx = 0;
            return orient === "bottom" && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180))), dx + (tickTextPos.x || 0);
          }()).attr("dy", function (d, i) {
            var dy = 0;
            return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
          });
          var lineUpdate = tick.select("line"),
              textUpdate = tick.select("text");

          if (tickEnter.select("line").attr("".concat(axisPx, "2"), innerTickSize * sign), tickEnter.select("text").attr("".concat(axisPx), tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
            Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
          }), scale1.bandwidth) {
            var x = scale1,
                dx = x.bandwidth() / 2;
            scale0 = function (d) {
              return x(d) + dx;
            }, scale1 = scale0;
          } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

          tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
        }
      }), this.g = $g;
    }
    /**
     * Get tick x/y coordinate
     * @return {{x: number, y: number}}
     * @private
     */

  }, {
    key: "getTickXY",
    value: function getTickXY() {
      var config = this.config,
          pos = {
        x: 0,
        y: 0
      };
      return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
    }
    /**
     * Get tick size
     * @param d
     * @return {number}
     * @private
     */

  }, {
    key: "getTickSize",
    value: function getTickSize(d) {
      var scale = this.helper.scale,
          config = this.config,
          innerTickSize = config.innerTickSize,
          range = config.range,
          tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
      return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
    }
    /**
     * Set tick's line & text position
     * @param lineUpdate
     * @param textUpdate
     * @param scale
     * @private
     */

  }, {
    key: "setTickLineTextPosition",
    value: function setTickLineTextPosition(lineUpdate, textUpdate) {
      var tickPos = this.getTickXY(),
          _this$config = this.config,
          innerTickSize = _this$config.innerTickSize,
          orient = _this$config.orient,
          tickLength = _this$config.tickLength,
          tickOffset = _this$config.tickOffset,
          rotate = this.params.tickTextRotate;
      orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", function yForText(r) {
        return r ? 11.5 - 2.5 * (r / 15) * (r > 0 ? 1 : -1) : tickLength;
      }(rotate)).style("text-anchor", function textAnchorForText(r) {
        return r ? r > 0 ? "start" : "end" : "middle";
      }(rotate)).attr("transform", function textTransform(r) {
        return r ? "rotate(".concat(r, ")") : null;
      }(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -tickLength * 2).style("text-anchor", "middle")) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
    } // this should be called only when category axis

  }, {
    key: "splitTickText",
    value: function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
      function split(splitted, text) {
        for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
        if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

        return splitted.concat(text);
      }

      var params = this.params,
          tickText = this.helper.textFormatted(d),
          splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
      if (splitted.length) return splitted;
      if (isArray(tickText)) return tickText;
      var tickWidth = params.tickWidth;
      return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
    }
  }, {
    key: "scale",
    value: function scale(x) {
      return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
    }
  }, {
    key: "orient",
    value: function orient(x) {
      return arguments.length ? (this.config.orient = x in {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      } ? x + "" : "bottom", this) : this.config.orient;
    }
  }, {
    key: "tickFormat",
    value: function tickFormat(format) {
      return arguments.length ? (this.config.tickFormat = format, this) : this.config.tickFormat;
    }
  }, {
    key: "tickCentered",
    value: function tickCentered(isCentered) {
      var config = this.config;
      return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
    }
    /**
     * Return tick's offset value.
     * The value will be set for 'category' axis type.
     * @return {number}
     * @private
     */

  }, {
    key: "tickOffset",
    value: function tickOffset() {
      return this.config.tickOffset;
    }
    /**
     * Get tick interval count
     * @private
     * @param {Number} size Total data size
     * @return {number}
     */

  }, {
    key: "tickInterval",
    value: function tickInterval(size) {
      var interval;
      if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
        var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
        interval = length / (size || this.g.selectAll("line").size());
      }
      return interval === Infinity ? 0 : interval;
    }
  }, {
    key: "ticks",
    value: function ticks() {
      for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
    }
  }, {
    key: "tickCulling",
    value: function tickCulling(culling) {
      var config = this.config;
      return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
    }
  }, {
    key: "tickValues",
    value: function tickValues(x) {
      var _this = this,
          config = this.config;

      if (isFunction(x)) config.tickValues = function () {
        return x(_this.helper.scale.domain());
      };else {
        if (!arguments.length) return config.tickValues;
        config.tickValues = x;
      }
      return this;
    }
  }, {
    key: "setTransition",
    value: function setTransition(t) {
      return this.config.transition = t, this;
    }
  }]), AxisRenderer;
}();


// CONCATENATED MODULE: ./src/axis/Axis.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var isHorizontal = function ($$, forHorizontal) {
  var isRotated = $$.config.axis_rotated;
  return forHorizontal ? isRotated : !isRotated;
},
    getAxisClassName = function (id) {
  return "".concat(config_classes.axis, " ").concat(config_classes["axis".concat(capitalize(id))]);
};

var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    classCallCheck_default()(this, Axis), this.owner = owner, this.setOrient();
  }

  return createClass_default()(Axis, [{
    key: "init",
    value: function init() {
      var _this = this,
          $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          main = $$.main,
          target = ["x", "y"];

      config.axis_y2_show && target.push("y2"), $$.axesList = {}, target.forEach(function (v) {
        var classAxis = getAxisClassName(v),
            axisId = v.toUpperCase(),
            classLabel = config_classes["axis".concat(axisId, "Label")];
        $$.axes[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
          var res = null;
          return v === "x" ? res = $$.clipPathForXAxis : v === "y" && config.axis_y_inner && (res = $$.clipPathForYAxis), res;
        }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_".concat(v, "_show")] ? "visible" : "hidden"), $$.axes[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this["textAnchorFor".concat(axisId, "AxisLabel")].bind(_this)), _this.generateAxes(v);
      });
    }
    /**
     * Set axis orient according option value
     * @private
     */

  }, {
    key: "setOrient",
    value: function setOrient() {
      var $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          yInner = config.axis_y_inner,
          y2Inner = config.axis_y2_inner;
      $$.xOrient = isRotated ? "left" : "bottom", $$.yOrient = isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left", $$.y2Orient = isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right", $$.subXOrient = isRotated ? "left" : "bottom";
    }
    /**
     * Generate axes
     * It's used when axis' axes option is set
     * @param {String} id Axis id
     * @private
     */

  }, {
    key: "generateAxes",
    value: function generateAxes(id) {
      var d3Axis,
          $$ = this.owner,
          config = $$.config,
          axes = [],
          axesConfig = config["axis_".concat(id, "_axes")],
          isRotated = config.axis_rotated;
      id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
        var tick = v.tick;
        axes.push(d3Axis($$[id]).ticks(tick.count).tickFormat(tick.format || function (x) {
          return x;
        }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
      }), $$.axesList[id] = axes;
    }
    /**
     * Update axes nodes
     * @private
     */

  }, {
    key: "updateAxes",
    value: function updateAxes() {
      var $$ = this.owner,
          config = $$.config;
      Object.keys($$.axesList).forEach(function (id) {
        var range = $$[id].range();
        $$.axesList[id].forEach(function (v, i) {
          var axisRange = v.scale().range(); // adjust range value with the current
          // https://github.com/naver/billboard.js/issues/859

          range.every(function (v, i) {
            return v === axisRange[i];
          }) || v.scale().range(range);
          var className = "".concat(getAxisClassName(id), "-").concat(i + 1),
              g = $$.main.select(".".concat(className.replace(/\s/, ".")));
          g.empty() ? g = $$.main.append("g").attr("class", className).style("visibility", config["axis_".concat(id, "_show")] ? "visible" : "hidden").call(v) : $$.xAxis.helper.transitionise(g).call(v.scale($$[id])), g.attr("transform", $$.getTranslate(id, i + 1));
        });
      });
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getAxis",
    value: function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          isX = /^(x|subX)$/.test(name),
          type = isX ? "x" : "y",
          isCategory = isX && $$.isCategorized(),
          orient = $$["".concat(name, "Orient")],
          tickFormat = isX ? $$.xAxisTickFormat : config["axis_".concat(name, "_tick_format")],
          tickValues = isX ? $$.xAxisTickValues : $$["".concat(name, "AxisTickValues")],
          axisParams = mergeObj({
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickTextRotate: noTickTextRotate ? 0 : config["axis_".concat(type, "_tick_rotate")]
      }, isX && {
        isCategory: isCategory,
        tickMultiline: config.axis_x_tick_multiline,
        tickWidth: config.axis_x_tick_width,
        tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
        orgXScale: $$.x
      }),
          axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.zoomScale || scale).orient(orient);
      return isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues) ? tickValues = tickValues.map(function (v) {
        return $$.parseDate(v);
      }) : !isX && $$.isTimeSeriesY() && (axis.ticks(config.axis_y_tick_time_value), tickValues = null), tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
        return "".concat(x, "%");
      }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config["axis_".concat(type, "_tick_count")] && axis.ticks(config["axis_".concat(type, "_tick_count")]), axis;
    }
  }, {
    key: "updateXAxisTickValues",
    value: function updateXAxisTickValues(targets, axis) {
      var values,
          $$ = this.owner,
          config = $$.config,
          fit = config.axis_x_tick_fit,
          count = config.axis_x_tick_count;
      return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.xAxis && ($$.xAxis.tickValues(values), $$.subXAxis.tickValues(values)), values;
    }
  }, {
    key: "getId",
    value: function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : "y";
    }
  }, {
    key: "getXAxisTickFormat",
    value: function getXAxisTickFormat() {
      var format,
          $$ = this.owner,
          config = $$.config,
          tickFormat = config.axis_x_tick_format,
          isTimeSeries = $$.isTimeSeries(),
          isCategorized = $$.isCategorized();
      return tickFormat ? isFunction(tickFormat) ? format = tickFormat : isTimeSeries && (format = function (date) {
        return date ? $$.axisTimeFormat(tickFormat)(date) : "";
      }) : format = isTimeSeries ? $$.defaultAxisTimeFormat : isCategorized ? $$.categoryName : function (v) {
        return v < 0 ? v.toFixed(0) : v;
      }, isFunction(format) ? function (v) {
        return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
      } : format;
    }
  }, {
    key: "getTickValues",
    value: function getTickValues(id) {
      var $$ = this.owner,
          tickValues = $$.config["axis_".concat(id, "_tick_values")],
          axis = $$["".concat(id, "Axis")];
      return (isFunction(tickValues) ? tickValues() : tickValues) || (axis ? axis.tickValues() : undefined);
    }
  }, {
    key: "getLabelOptionByAxisId",
    value: function getLabelOptionByAxisId(id) {
      return this.owner.config["axis_".concat(id, "_label")];
    }
  }, {
    key: "getLabelText",
    value: function getLabelText(id) {
      var option = this.getLabelOptionByAxisId(id);
      return isString(option) ? option : option ? option.text : null;
    }
  }, {
    key: "setLabelText",
    value: function setLabelText(id, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(id);
      isString(option) ? config["axis_".concat(id, "_label")] = text : option && (option.text = text);
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(id, defaultPosition) {
      var isRotated = this.owner.config.axis_rotated,
          option = this.getLabelOptionByAxisId(id),
          position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
          has = function (v) {
        return !!~position.indexOf(v);
      };

      return {
        isInner: has("inner"),
        isOuter: has("outer"),
        isLeft: has("left"),
        isCenter: has("center"),
        isRight: has("right"),
        isTop: has("top"),
        isMiddle: has("middle"),
        isBottom: has("bottom")
      };
    }
  }, {
    key: "getXAxisLabelPosition",
    value: function getXAxisLabelPosition() {
      return this.getLabelPosition("x", ["inner-top", "inner-right"]);
    }
  }, {
    key: "getYAxisLabelPosition",
    value: function getYAxisLabelPosition() {
      return this.getLabelPosition("y", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getY2AxisLabelPosition",
    value: function getY2AxisLabelPosition() {
      return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getLabelPositionById",
    value: function getLabelPositionById(id) {
      return this["get".concat(id.toUpperCase(), "AxisLabelPosition")]();
    }
  }, {
    key: "textForXAxisLabel",
    value: function textForXAxisLabel() {
      return this.getLabelText("x");
    }
  }, {
    key: "textForYAxisLabel",
    value: function textForYAxisLabel() {
      return this.getLabelText("y");
    }
  }, {
    key: "textForY2AxisLabel",
    value: function textForY2AxisLabel() {
      return this.getLabelText("y2");
    }
  }, {
    key: "xForAxisLabel",
    value: function xForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          x = position.isMiddle ? -$$.height / 2 : 0;
      return isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom && (x = -$$.height), x;
    }
  }, {
    key: "dxForAxisLabel",
    value: function dxForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          dx = position.isBottom ? "0.5em" : "0";
      return isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
    }
  }, {
    key: "textAnchorForAxisLabel",
    value: function textAnchorForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          anchor = position.isMiddle ? "middle" : "end";
      return isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
    }
  }, {
    key: "xForXAxisLabel",
    value: function xForXAxisLabel() {
      return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "xForYAxisLabel",
    value: function xForYAxisLabel() {
      return this.xForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "xForY2AxisLabel",
    value: function xForY2AxisLabel() {
      return this.xForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dxForXAxisLabel",
    value: function dxForXAxisLabel() {
      return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "dxForYAxisLabel",
    value: function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "dxForY2AxisLabel",
    value: function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dyForXAxisLabel",
    value: function dyForXAxisLabel() {
      var $$ = this.owner,
          config = $$.config,
          isInner = this.getXAxisLabelPosition().isInner,
          xHeight = config.axis_x_height;
      return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
    }
  }, {
    key: "dyForYAxisLabel",
    value: function dyForYAxisLabel() {
      var $$ = this.owner,
          isInner = this.getYAxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
    }
  }, {
    key: "dyForY2AxisLabel",
    value: function dyForY2AxisLabel() {
      var $$ = this.owner,
          isInner = this.getY2AxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
    }
  }, {
    key: "textAnchorForXAxisLabel",
    value: function textAnchorForXAxisLabel() {
      return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "textAnchorForYAxisLabel",
    value: function textAnchorForYAxisLabel() {
      return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "textAnchorForY2AxisLabel",
    value: function textAnchorForY2AxisLabel() {
      return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "getMaxTickWidth",
    value: function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          currentTickMax = $$.currentMaxTickWidths[id],
          maxWidth = 0;
      if (withoutRecompute || !config["axis_".concat(id, "_show")]) return currentTickMax.size;

      if ($$.svg) {
        var isYAxis = /^y2?$/.test(id),
            targetsToShow = $$.filterTargetsToShow($$.data.targets),
            scale = $$[id].copy().domain($$["get".concat(isYAxis ? "Y" : "X", "Domain")](targetsToShow, id)),
            domain = scale.domain();
        // do not compute if domain is same
        if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
          return v === domain[i];
        })) return currentTickMax.size;
        currentTickMax.domain = domain;
        var axis = this.getAxis(id, scale, !1, !1, !0),
            tickCount = config["axis_".concat(id, "_tick_count")];
        tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
        var dummy = $$.selectChart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
        axis.create(dummy), dummy.selectAll("text").each(function () {
          maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
        }), dummy.remove();
      }

      return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
    }
  }, {
    key: "updateLabels",
    value: function updateLabels(withTransition) {
      var _this2 = this,
          $$ = this.owner,
          labels = {
        X: $$.main.select(".".concat(config_classes.axisX, " .").concat(config_classes.axisXLabel)),
        Y: $$.main.select(".".concat(config_classes.axisY, " .").concat(config_classes.axisYLabel)),
        Y2: $$.main.select(".".concat(config_classes.axisY2, " .").concat(config_classes.axisY2Label))
      };

      Object.keys(labels).filter(function (id) {
        return !labels[id].empty();
      }).forEach(function (v) {
        var node = labels[v],
            axisLabel = "".concat(v, "AxisLabel");
        (withTransition ? node.transition() : node).attr("x", _this2["xFor".concat(axisLabel)].bind(_this2)).attr("dx", _this2["dxFor".concat(axisLabel)].bind(_this2)).attr("dy", _this2["dyFor".concat(axisLabel)].bind(_this2)).text(_this2["textFor".concat(axisLabel)].bind(_this2));
      });
    }
  }, {
    key: "getPadding",
    value: function getPadding(padding, key, defaultValue, domainLength) {
      var p = isNumber(padding) ? padding : padding[key];
      return isValue(p) ? padding.unit === "ratio" ? padding[key] * domainLength : this.convertPixelsToAxisPadding(p, domainLength) : defaultValue; // assume padding is pixels if unit is not specified
    }
  }, {
    key: "convertPixelsToAxisPadding",
    value: function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    }
  }, {
    key: "generateTickValues",
    value: function generateTickValues(values, tickCount, forTimeSeries) {
      var start,
          end,
          count,
          interval,
          i,
          tickValue,
          tickValues = values;

      if (tickCount) {
        var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

        if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
          for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);

          tickValues.push(end);
        }
      }

      return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
        return a - b;
      })), tickValues;
    }
  }, {
    key: "generateTransitions",
    value: function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes,
          _map = ["x", "y", "y2", "subx"].map(function (v) {
        var axis = axes[v];
        return axis && duration && (axis = axis.transition().duration(duration)), axis;
      }),
          _map2 = slicedToArray_default()(_map, 4),
          axisX = _map2[0],
          axisY = _map2[1],
          axisY2 = _map2[2],
          axisSubX = _map2[3];

      return {
        axisX: axisX,
        axisY: axisY,
        axisY2: axisY2,
        axisSubX: axisSubX
      };
    }
  }, {
    key: "redraw",
    value: function redraw(transitions, isHidden, isInit) {
      var $$ = this.owner,
          opacity = isHidden ? "0" : "1";
      ["x", "y", "y2", "subX"].forEach(function (id) {
        var axis = $$["".concat(id, "Axis")];
        axis && (!isInit && (axis.config.withoutTransition = !$$.config.transition_duration), $$.axes[id.toLowerCase()].style("opacity", opacity), axis.create(transitions["axis".concat(capitalize(id))]));
      }), this.updateAxes();
    }
    /**
     * Redraw axis
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} wth
     * @param {Ojbect} transitions
     * @param {Object} flow
     * @private
     */

  }, {
    key: "redrawAxis",
    value: function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
      var xDomainForZoom,
          _this3 = this,
          $$ = this.owner,
          config = $$.config,
          hasZoom = !!$$.zoomScale;

      !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), $$.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.xAxis && ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = $$.x.orgDomain()), ["y", "y2"].forEach(function (key) {
        var axis = $$[key];

        if (axis) {
          var tickValues = config["axis_".concat(key, "_tick_values")],
              tickCount = config["axis_".concat(key, "_tick_count")];

          if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
            var domain = axis.domain();
            $$["".concat(key, "Axis")].tickValues(_this3.generateTickValues(domain, domain.every(function (v) {
              return v === 0;
            }) ? 1 : tickCount, $$.isTimeSeriesY()));
          }
        }
      }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis) && targetsToShow.length && this.setCulling(), wth.Y && ($$.subY && $$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2 && $$.subY2.domain($$.getYDomain(targetsToShow, "y2")));
    }
    /**
     * Set manual culling
     * @private
     */

  }, {
    key: "setCulling",
    value: function setCulling() {
      var $$ = this.owner,
          config = $$.config;
      ["subx", "x", "y", "y2"].forEach(function (type) {
        var axis = $$.axes[type],
            id = type === "subx" ? "x" : type,
            toCull = config["axis_".concat(id, "_tick_culling")]; // subchart x axis should be aligned with x axis culling

        if (axis && toCull) {
          var intervalForCulling,
              tickText = axis.selectAll(".tick text"),
              tickValues = sortValue(tickText.data()),
              tickSize = tickValues.length,
              cullingMax = config["axis_".concat(id, "_tick_culling_max")];

          if (tickSize) {
            for (var _i = 1; _i < tickSize; _i++) if (tickSize / _i < cullingMax) {
              intervalForCulling = _i;
              break;
            }

            tickText.each(function (d) {
              this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
            });
          } else tickText.style("display", "block");
        }
      });
    }
  }]), Axis;
}();


// CONCATENATED MODULE: ./src/internals/ChartInternal.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */







/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  function ChartInternal(api) {
    classCallCheck_default()(this, ChartInternal);

    var $$ = this;
    $$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {}, $$.rendered = !1;
  }

  return createClass_default()(ChartInternal, [{
    key: "beforeInit",
    value: function beforeInit() {
      var $$ = this;
      $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$, $$.api);
    }
  }, {
    key: "afterInit",
    value: function afterInit() {
      var $$ = this;
      $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$, $$.api);
    }
  }, {
    key: "init",
    value: function init() {
      var $$ = this,
          config = $$.config;
      $$.initParams();
      var bindto = {
        element: config.bindto,
        classname: "bb"
      };
      isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $$.selectChart.empty() && ($$.selectChart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].body.appendChild(browser["document"].createElement("div")))), $$.selectChart.html("").classed(bindto.classname, !0), $$.initToRender();
    }
    /**
     * Initialize the rendering process
     * @param {Boolean} forced Force to render process
     * @private
     */

  }, {
    key: "initToRender",
    value: function initToRender(forced) {
      var $$ = this,
          config = $$.config,
          target = $$.selectChart,
          isHidden = function () {
        return target.style("display") === "none" || target.style("visibility") === "hidden";
      },
          isLazy = config.render.lazy || isHidden(),
          MutationObserver = browser["window"].MutationObserver;

      if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
        isHidden() || (observer.disconnect(), !$$.rendered && $$.initToRender(!0));
      }).observe(target.node(), {
        attributes: !0,
        attributeFilter: ["class", "style"]
      }), !isLazy || forced) {
        var convertedData = $$.convertData(config, $$.initWithData);
        convertedData && $$.initWithData(convertedData);
      }
    }
  }, {
    key: "initParams",
    value: function initParams() {
      var _this = this,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated;

      $$.datetimeId = "bb-".concat(+new Date()), $$.initClip(), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], $$.axisTimeFormat = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
      $$.defaultAxisTimeFormat = function (d) {
        var isZoomed = isDragZoom ? _this.zoomScale : _this.zoomScale && $$.x.orgDomain().toString() !== _this.zoomScale.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return $$.axisTimeFormat(specifier)(d);
      }, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
        x: {
          size: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      }, $$.rotated_padding_left = 30, $$.rotated_padding_right = isRotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.inputType = $$.convertInputType(), $$.axes.subx = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
    }
  }, {
    key: "initWithData",
    value: function initWithData(data) {
      var $$ = this,
          config = $$.config;

      if ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom(), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.hasType("gauge") && (config.legend_show = !1), $$.updateSizes(), $$.updateScales(!0), $$.x && ($$.x.domain(sortValue($$.getXDomain($$.data.targets))), $$.subX.domain($$.x.domain()), $$.orgXDomain = $$.x.domain()), $$.y && ($$.y.domain($$.getYDomain($$.data.targets, "y")), $$.subY.domain($$.y.domain())), $$.y2 && ($$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subY2 && $$.subY2.domain($$.y2.domain())), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
        var isTouch = $$.inputType === "touch";
        $$.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
          return callFn(config.onover, $$, $$.api);
        }).on(isTouch ? "touchend" : "mouseleave", function () {
          return callFn(config.onout, $$, $$.api);
        });
      }

      config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
        return $$.defs.append(function () {
          return p.node;
        });
      }), $$.updateSvgSize();
      // Define regions
      var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

      // data.onmin/max callback
      if ($$.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", "".concat(config_classes.text, " ").concat(config_classes.empty)).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
      .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", $$.clipPath), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g.".concat(config_classes.regions)).attr("class", config_classes.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$, $$.api), $$.redraw({
        withTransition: !1,
        withTransform: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withTransitionForAxis: !1,
        initializing: !0
      }), config.data_onmin || config.data_onmax) {
        var minMax = $$.getMinMaxData();
        callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
      } // Bind resize event


      $$.bindResize(), $$.api.element = $$.selectChart.node(), $$.rendered = !0;
    }
  }, {
    key: "initChartElements",
    value: function initChartElements() {
      var $$ = this;
      ["Bar", "Radar", "Line", "Bubble", "Arc", "Gauge", "Pie"].forEach(function (v) {
        $$["init".concat(v)]();
      }), notEmpty($$.config.data_labels) && $$.initText();
    }
  }, {
    key: "setChartElements",
    value: function setChartElements() {
      var $$ = this;
      $$.api.$ = {
        chart: $$.selectChart,
        svg: $$.svg,
        defs: $$.defs,
        main: $$.main,
        tooltip: $$.tooltip,
        legend: $$.legend,
        title: $$.title,
        grid: $$.grid,
        arc: $$.arcs,
        bar: {
          bars: $$.mainBar
        },
        line: {
          lines: $$.mainLine,
          areas: $$.mainArea,
          circles: $$.mainCircle
        },
        text: {
          texts: $$.mainText
        }
      };
    }
  }, {
    key: "smoothLines",
    value: function smoothLines(el, type) {
      type === "grid" && el.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            _map = ["x1", "x2", "y1", "y2"].map(function (v) {
          return Math.ceil(g.attr(v));
        }),
            _map2 = slicedToArray_default()(_map, 4),
            x1 = _map2[0],
            x2 = _map2[1],
            y1 = _map2[2],
            y2 = _map2[3];

        g.attr({
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        });
      });
    }
    /**
     * Update size values
     * @param {Boolean} isInit If is called at initialization
     * @private
     */

  }, {
    key: "updateSizes",
    value: function updateSizes(isInit) {
      var $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          hasArc = $$.hasArcType(),
          legend = {
        width: $$.legend ? $$.getLegendWidth() : 0,
        height: $$.legend ? $$.getLegendHeight() : 0
      },
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legend.height,
          xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
          subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
          subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
      isInit || $$.setContainerSize(), $$.margin = isRotated ? {
        top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        // for top tick text
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      }, $$.margin2 = isRotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: subchartXAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      }, $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      }, $$.updateSizeForLegend && $$.updateSizeForLegend(legend), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = isRotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = isRotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legend.width + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1);
    }
    /**
     * Update targeted element with given data
     * @param {Object} targets Data object formatted as 'target'
     * @private
     */

  }, {
    key: "updateTargets",
    value: function updateTargets(targets) {
      var $$ = this; // Text

      $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
    }
    /**
     * Display targeted elements
     * @private
     */

  }, {
    key: "showTargets",
    value: function showTargets() {
      var $$ = this;
      $$.svg.selectAll(".".concat(config_classes.target)).filter(function (d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", "1");
    }
  }, {
    key: "getWithOption",
    value: function getWithOption(options) {
      var withOptions = {
        Y: !0,
        Subchart: !0,
        Transition: !0,
        EventRect: !0,
        Dimension: !0,
        TrimXDomain: !0,
        Transform: !1,
        UpdateXDomain: !1,
        UpdateOrgXDomain: !1,
        Legend: !1,
        UpdateXAxis: "UpdateXDomain",
        TransitionForExit: "Transition",
        TransitionForAxis: "Transition"
      };
      return Object.keys(withOptions).forEach(function (key) {
        var defVal = withOptions[key];
        isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with".concat(key), defVal);
      }), withOptions;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          transitionsValue = arguments.length > 1 ? arguments[1] : undefined,
          $$ = this,
          main = $$.main,
          config = $$.config,
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          initializing = options.initializing,
          flow = options.flow,
          wth = $$.getWithOption(options),
          duration = wth.Transition ? config.transition_duration : 0,
          durationForExit = wth.TransitionForExit ? duration : 0,
          durationForAxis = wth.TransitionForAxis ? duration : 0,
          transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
      initializing && config.tooltip_init_show || $$.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), $$.updateXgridFocus(), config.data_empty_label_text && main.select("text.".concat(config_classes.text, ".").concat(config_classes.empty)).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(duration, durationForExit), $$.mainText && main.selectAll(".".concat(config_classes.selectedCircles)).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && ($$.redrawEventRect(), $$.bindZoomEvent()), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
    }
    /**
     * Generate redraw list
     * @param {Object} targets targets data to be shown
     * @param {Object} flow
     * @param {Object} duration
     * @param {Boolean} withSubchart whether or not to show subchart
     * @private
     */

  }, {
    key: "generateRedrawList",
    value: function generateRedrawList(targets, flow, duration, withSubchart) {
      var $$ = this,
          config = $$.config,
          shape = $$.getDrawShape();
      config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
      // generate flow
      var flowFn = flow && $$.generateFlow({
        targets: targets,
        flow: flow,
        duration: flow.duration,
        shape: shape,
        xv: $$.xv.bind($$)
      }),
          isTransition = (duration || flowFn) && $$.isTabVisible(),
          redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
          afterRedraw = flow || config.onrendered ? function () {
        flowFn && flowFn(), callFn(config.onrendered, $$, $$.api);
      } : null;
      if (afterRedraw) // Only use transition when current tab is visible.
        if (isTransition) {
          // Wait for end of transitions for callback
          var waitForDraw = $$.generateWait(); // transition should be derived from one transition

          Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
            redrawList.reduce(function (acc, t1) {
              return acc.concat(t1);
            }, []).forEach(function (t) {
              return waitForDraw.add(t);
            });
          }).call(waitForDraw, afterRedraw);
        } else afterRedraw(); // update fadein condition

      $$.mapToIds($$.data.targets).forEach(function (id) {
        $$.withoutFadeIn[id] = !0;
      });
    }
    /**
     * Get the shape draw function
     * @return {Object}
     * @private
     */

  }, {
    key: "getDrawShape",
    value: function getDrawShape() {
      var $$ = this,
          isRotated = $$.config.axis_rotated,
          hasRadar = $$.hasType("radar"),
          shape = {
        type: {},
        indices: {}
      };

      // setup drawer - MEMO: these must be called after axis updated
      if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
        var indices = $$.getShapeIndices($$.isLineType);

        if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
          var _indices = $$.getShapeIndices($$.isAreaType);

          shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
        }
      }

      if ($$.hasType("bar")) {
        var _indices2 = $$.getShapeIndices($$.isBarType);

        shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
      }

      return shape.pos = {
        xForText: $$.generateXYForText(shape.indices, !0),
        yForText: $$.generateXYForText(shape.indices, !1),
        // generate circle x/y functions depending on updated params
        cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
        cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
      }, shape;
    }
  }, {
    key: "getRedrawList",
    value: function getRedrawList(shape, flow, flowFn, isTransition) {
      var $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          _shape$pos = shape.pos,
          cx = _shape$pos.cx,
          cy = _shape$pos.cy,
          xForText = _shape$pos.xForText,
          yForText = _shape$pos.yForText,
          list = [];

      if (!hasArcType) {
        var _shape$type = shape.type,
            area = _shape$type.area,
            bar = _shape$type.bar,
            line = _shape$type.line;
        (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition));
      }

      return (!hasArcType || $$.hasType("radar")) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
    }
  }, {
    key: "updateAndRedraw",
    value: function updateAndRedraw() {
      var transitions,
          options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          $$ = this,
          config = $$.config;
      options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
    }
  }, {
    key: "redrawWithoutRescale",
    value: function redrawWithoutRescale() {
      this.redraw({
        withY: !1,
        withSubchart: !1,
        withEventRect: !1,
        withTransitionForAxis: !1
      });
    }
  }, {
    key: "isTimeSeries",
    value: function isTimeSeries() {
      return this.config.axis_x_type === "timeseries";
    }
  }, {
    key: "isCategorized",
    value: function isCategorized() {
      return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
    }
  }, {
    key: "isCustomX",
    value: function isCustomX() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    }
  }, {
    key: "isTimeSeriesY",
    value: function isTimeSeriesY() {
      return this.config.axis_y_type === "timeseries";
    }
  }, {
    key: "getTranslate",
    value: function getTranslate(target) {
      var x,
          y,
          index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          padding = 0;
      if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel($$.margin.left), y = asHalfPixel($$.margin.top);else if (target === "context") x = asHalfPixel($$.margin2.left), y = asHalfPixel($$.margin2.top);else if (target === "legend") x = $$.margin3.left, y = $$.margin3.top;else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : $$.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? $$.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : $$.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subx") x = 0, y = isRotated ? 0 : $$.height2;else if (target === "arc") x = $$.arcWidth / 2, y = $$.arcHeight / 2;else if (target === "radar") {
        var _$$$getRadarSize = $$.getRadarSize(),
            _$$$getRadarSize2 = slicedToArray_default()(_$$$getRadarSize, 1),
            width = _$$$getRadarSize2[0];

        x = $$.width / 2 - width, y = asHalfPixel($$.margin.top);
      }
      return "translate(".concat(x, ", ").concat(y, ")");
    }
  }, {
    key: "initialOpacity",
    value: function initialOpacity(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? "1" : "0";
    }
  }, {
    key: "initialOpacityForCircle",
    value: function initialOpacityForCircle(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
    }
  }, {
    key: "opacityForCircle",
    value: function opacityForCircle(d) {
      var opacity = this.config.point_show ? "1" : "0";
      return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
    }
  }, {
    key: "opacityForText",
    value: function opacityForText() {
      return this.hasDataLabel() ? "1" : "0";
    }
  }, {
    key: "xx",
    value: function xx(d) {
      var fn = this.config.zoom_enabled && this.zoomScale ? this.zoomScale : this.x;
      return d ? fn(d.x) : null;
    }
  }, {
    key: "xv",
    value: function xv(d) {
      var $$ = this,
          value = $$.getBaseValue(d);
      return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = $$.config.axis_x_categories.indexOf(value)), Math.ceil($$.x(value));
    }
  }, {
    key: "yv",
    value: function yv(d) {
      var $$ = this,
          yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;
      return Math.ceil(yScale($$.getBaseValue(d)));
    }
  }, {
    key: "subxx",
    value: function subxx(d) {
      return d ? this.subX(d.x) : null;
    }
  }, {
    key: "transformMain",
    value: function transformMain(withTransition, transitions) {
      var xAxis,
          yAxis,
          y2Axis,
          $$ = this;
      transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select(".".concat(config_classes.axisX)), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select(".".concat(config_classes.axisY)), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select(".".concat(config_classes.axisY2)), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select(".".concat(config_classes.chartArcs)).attr("transform", $$.getTranslate("arc"));
    }
  }, {
    key: "transformAll",
    value: function transformAll(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
    }
  }, {
    key: "updateSvgSize",
    value: function updateSvgSize() {
      var $$ = this,
          brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), $$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#".concat($$.clipId), "#".concat($$.clipIdForGrid)]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#".concat($$.clipIdForXAxis)).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForYAxis)).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForSubchart)).select("rect").attr("width", $$.width).attr("height", brushSize.height), $$.svg.select(".".concat(config_classes.zoomRect)).attr("width", $$.width).attr("height", $$.height);
    }
  }, {
    key: "updateDimension",
    value: function updateDimension(withoutAxis) {
      var $$ = this;
      withoutAxis || ($$.xAxis && $$.config.axis_rotated ? ($$.xAxis.create($$.axes.x), $$.subXAxis.create($$.axes.subx)) : ($$.yAxis && $$.yAxis.create($$.axes.y), $$.y2Axis && $$.y2Axis.create($$.axes.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
    }
  }, {
    key: "bindResize",
    value: function bindResize() {
      var $$ = this,
          config = $$.config;
      $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(function () {
        return callFn(config.onresize, $$, $$.api);
      }), config.resize_auto && $$.resizeFunction.add(function () {
        $$.resizeTimeout && (browser["window"].clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = browser["window"].setTimeout(function () {
          $$.api.flush(!1, !0);
        }, 200);
      }), $$.resizeFunction.add(function () {
        return callFn(config.onresized, $$, $$.api);
      }), browser["window"].addEventListener("resize", $$.resizeFunction);
    }
  }, {
    key: "generateResize",
    value: function generateResize() {
      function callResizeFunctions() {
        resizeFunctions.forEach(function (f) {
          return f();
        });
      }

      var resizeFunctions = [];
      return callResizeFunctions.add = function (f) {
        return resizeFunctions.push(f);
      }, callResizeFunctions.remove = function (f) {
        return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
      }, callResizeFunctions;
    }
  }, {
    key: "endall",
    value: function endall(transition, callback) {
      var n = 0;
      transition.each(function () {
        return ++n;
      }).on("end", function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

        --n || callback.apply.apply(callback, [this].concat(args));
      });
    }
  }, {
    key: "generateWait",
    value: function generateWait() {
      var transitionsToWait = [],
          f = function (transition, callback) {
        function loop() {
          for (var t, done = 0, i = 0; t = transitionsToWait[i]; i++) {
            if (t.empty()) {
              done++;
              continue;
            }

            try {
              t.transition();
            } catch (e) {
              done++;
            }
          }

          timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
        }

        var timer;
        loop();
      };

      return f.add = function (transition) {
        isArray(transition) ? transitionsToWait = transitionsToWait.concat(transition) : transitionsToWait.push(transition);
      }, f;
    }
  }, {
    key: "parseDate",
    value: function parseDate(date) {
      var parsedDate,
          $$ = this;
      return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '".concat(date, "' to Date object")), parsedDate;
    }
  }, {
    key: "isTabVisible",
    value: function isTabVisible() {
      return !browser["document"].hidden;
    }
  }, {
    key: "convertInputType",
    value: function convertInputType() {
      var $$ = this,
          config = $$.config,
          isMobile = !1;

      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop
      if (/Mobi/.test(browser["window"].navigator.userAgent) && config.interaction_inputType_touch) {
        // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
        var hasTouchPoints = browser["window"].navigator && "maxTouchPoints" in browser["window"].navigator && browser["window"].navigator.maxTouchPoints > 0,
            hasTouch = "ontouchmove" in browser["window"] || browser["window"].DocumentTouch && browser["document"] instanceof browser["window"].DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
        // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

        isMobile = hasTouchPoints || hasTouch;
      }

      var hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in browser["window"];
      return hasMouse && "mouse" || isMobile && "touch" || null;
    }
    /**
     * Call plugin hook
     * @param {String} phase The lifecycle phase
     * @private
     */

  }, {
    key: "callPluginHook",
    value: function callPluginHook(phase) {
      for (var _this2 = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

      this.config.plugins.forEach(function (v) {
        phase === "$beforeInit" && (v.$$ = _this2, _this2.api.plugins.push(v)), v[phase].apply(v, args);
      });
    }
  }]), ChartInternal;
}();


// CONCATENATED MODULE: ./src/internals/Chart.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access instance's primary node elements
 * @member {Object} $
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart = function Chart(config) {
  classCallCheck_default()(this, Chart);

  var $$ = new ChartInternal_ChartInternal(this);
  /**
   * Plugin instance array
   * @member {Array} plugins
   * @memberof Chart
   * @instance
   	 * @example
   *  var chart = bb.generate({
   *     ...
   *     plugins: [
   *        new bb.plugin.stanford({ ... }),
   *        new PluginA()
   *     ]
   *  });
   *
   *  chart.plugins; // [Stanford, PluginA] - instance array
   */

  // bind "this" to nested API
  this.plugins = [], this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), $$.afterInit(config), function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this);
};


// CONCATENATED MODULE: ./src/config/Options.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */
var Options_Options = function Options() {
  return classCallCheck_default()(this, Options), {
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set zoom options
     * @name zoom
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [zoom.enabled=false] Enable zooming.
     * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
     *  - **Available types:**
     *    - wheel
     *    - drag
     * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
     *  If true set, y domain will be updated according to the zoomed region.
     * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
     * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
     * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
     * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
     *  Specified function receives the zoom event.
     * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
     *  Specified function receives the zoomed domain.
     * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
     *  Specified function receives the zoomed domain.
     * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
     * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
     * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
     * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
     * @example
     *  zoom: {
     *      enabled: {
              *          type: "drag"
              *      },
     *      rescale: true,
     *      extent: [1, 100]  // enable more zooming
     *      x: {
     *          min: -1,  // set min range
     *          max: 10  // set max range
     *      },
     *      onzoomstart: function(event) { ... },
     *      onzoom: function(domain) { ... },
     *      onzoomend: function(domain) { ... },
     *
     *      // show reset button when is zoomed-in
     *      resetButton: true,
     *
     *      // customized text value for reset zoom button
     *      resetButton: {
     *          text: "Unzoom"
     *      }
     *  }
     */
    zoom_enabled: undefined,
    zoom_extent: undefined,
    zoom_privileged: !1,
    zoom_rescale: !1,
    zoom_onzoom: undefined,
    zoom_onzoomstart: undefined,
    zoom_onzoomend: undefined,
    zoom_resetButton: !0,
    zoom_x_min: undefined,
    zoom_x_max: undefined,

    /**
     * Interaction options
     * @name interaction
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
     *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
     * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
     * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
     * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
     * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
     * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
     * @example
     * interaction: {
              *    enabled: false,
              *    brighten: false,
              *    inputType: {
              *        mouse: true,
              *        touch: false
              *
              *        // or declare preventDefault explicitly.
              *        // In this case touch inputType is enabled by default
              *        touch: {
              *            preventDefault: true
              *
              *            // or threshold pixel value (pixel moved from touchstart to touchmove)
              *            preventDefault: 5
              *        }
              *    }
     * }
     */
    interaction_enabled: !0,
    interaction_brighten: !0,
    interaction_inputType_mouse: !0,
    interaction_inputType_touch: {},

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * SSet a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Specify the key of x values in the data.<br><br>
     * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
     * @name datax
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
              *   x: "date"
     * }
     */
    data_x: undefined,

    /**
     * Specify the keys of the x values for each data.<br><br>
     * This option can be used if we want to show the data that has different x values.
     * @name dataxs
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   xs: {
              *      data1: "x1",
              *      data2: "x2"
              *   }
     * }
     */
    data_xs: {},

    /**
     * Set a format specifier to parse string specifed as x.
     * @name dataxFormat
     * @memberof Options
     * @type {String}
     * @default %Y-%m-%d
     * @example
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "01012019", "02012019", "03012019"],
     *        ["data1", 30, 200, 100]
     *    ],
     *    // Format specifier to parse as datetime for given 'x' string value
     *    xFormat: "%m%d%Y"
     * },
     * axis: {
     *    x: {
     *        type: "timeseries"
     *    }
     * }
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     */
    data_xFormat: "%Y-%m-%d",

    /**
     * Set localtime format to parse x axis.
     * @name dataxLocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xLocaltime: false
     * }
     */
    data_xLocaltime: !0,

    /**
     * Sort on x axis.
     * @name dataxSort
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xSort: false
     * }
     */
    data_xSort: !0,

    /**
     * Converts data id value
     * @name dataidConverter
     * @memberof Options
     * @type {Function}
     * @default function(id) { return id; }
     * @example
     * data: {
              *    idConverter: function(id) {
              *       // when id is 'data1', converts to be 'data2'
              *       // 'data2' should be given as the initial data value
              *       if (id === "data1") {
              *          return "data2";
              *       } else {
              *          return id;
              *       }
              *    }
     * }
     */
    data_idConverter: function data_idConverter(id) {
      return id;
    },

    /**
     * Set custom data name.
     * @name datanames
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
     * @example
     * data: {
              *   names: {
              *     data1: "Data Name 1",
              *     data2: "Data Name 2"
              *   }
     * }
     */
    data_names: {},

    /**
     * Set custom data class.<br><br>
     * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
     * @name dataclasses
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   classes: {
              *     data1: "additional-data1-class",
              *     data2: "additional-data2-class"
              *   }
     * }
     */
    data_classes: {},

    /**
     * Set groups for the data for stacking.
     * @name datagroups
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * data: {
              *   groups: [
              *     ["data1", "data2"],
              *     ["data3"]
              *   ]
     * }
     */
    data_groups: [],

    /**
     * Set y axis the data related to. y and y2 can be used.
     * @name dataaxes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   axes: {
     *     data1: "y",
     *     data2: "y2"
     *   }
     * }
     */
    data_axes: {},

    /**
     * Set chart type at once.<br><br>
     * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
     * **Available Values:**
     * - area
     * - area-line-range
     * - area-spline
     * - area-spline-range
     * - area-step
     * - bar
     * - bubble
     * - donut
     * - gauge
     * - line
     * - pie
     * - radar
     * - scatter
     * - spline
     * - step
     * @name datatype
     * @memberof Options
     * @type {String}
     * @default line
     * @example
     * data: {
     *    type: "bar"
     * }
     */
    data_type: undefined,

    /**
     * Set chart type for each data.<br>
     * This setting overwrites data.type setting.
     * - **NOTE:** `radar` type can't be combined with other types.
     * @name datatypes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   types: {
     *     data1: "bar",
     *     data2: "spline"
     *   }
     * }
     */
    data_types: {},

    /**
     * Set labels options
     * @name datalabels
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [data.labels=false] Show or hide labels on each data points
     * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
     * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
     * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
     *  - `v` is the value of the data point where the label is shown.
     *  - `id` is the id of the data where the label is shown.
     *  - `i` is the index of the data point where the label is shown.
     *  - `j` is the sub index of the data point where the label is shown.<br><br>
     * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
    	 * @property {String|Object} [data.labels.colors] Set label text colors.
     * @property {Boolean|Object} [data.labels.overlap=true] Prevents label overlap using [Voronoi layout](https://en.wikipedia.org/wiki/Voronoi_diagram) if set to `false`.
     		 * @property {Number} [data.labels.overlap.extent=1] Set extent of label overlap prevention.
      		 * @property {Number} [data.labels.overlap.area=0] Set minimum area needed to show a data label.
     * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
     * @property {NUmber} [data.labels.position.y=0] y coordinate position, relative the original.
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
     * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
     * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
     * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
     * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
     * @example
     * data: {
     *   labels: true,
     *
     *   // or set specific options
     *   labels: {
     *     format: function(v, id, i, j) { ... },
     *
     *     // it's possible to set for each data
     *     format: {
     *         data1: function(v, id, i, j) { ... },
     *         ...
     *     },
     *
     *     // align text to center of the 'bar' shape (works only for 'bar' type)
     *     centered: true,
     *
     *     // apply for all label texts
     *     colors: "red",
     *
     *     // or set different colors per dataset
     *     // for not specified dataset, will have the default color value
     *     colors: {
     *        data1: "yellow",
     *        data3: "green"
     *     },
     *
     *     // set x, y coordinate position
     *     position: {
     *        x: -10,
     *        y: 10
     *     }
     *   }
     * }
     */
    data_labels: {},
    data_labels_colors: undefined,
    data_labels_position: {},

    /**
     *  This option changes the order of stacking data and pieces of pie/donut.
     *  - If `null` specified, it will be the order the data loaded.
     *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
     *
     *  **Available Values:**
     *  - `desc`: In descending order
     *  - `asc`: In ascending order
     *  - `null`: It keeps the data load order
     *  - `function(data1, data2) { ... }`: Array.sort compareFunction
     * @name dataorder
     * @memberof Options
     * @type {String|Function|null}
     * @default desc
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
     * @example
     * data: {
     *   // in descending order (default)
     *   order: "desc"
     *
     *   // in ascending order
     *   order: "asc"
     *
     *   // keeps data input order
     *   order: null
     *
     *   // specifying sort function
     *   order: function(a, b) {
     *       // param data passed format
     *       {
     *          id: "data1", id_org: "data1", values: [
     *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
     *              ...
     *          ]
     *       }
     *   }
     * }
     */
    data_order: "desc",

    /**
     * Define regions for each data.<br>
     * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
     * - The object type should be as:
     *   - start {Number}: Start data point number. If not set, the start will be the first data point.
     *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
     *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
     * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
     * @name dataregions
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   regions: {
     *     data1: [{
     *         start: 1,
     *         end: 2,
     *         style: {
     *             dasharray: "5 2"
     *         }
     *     }, {
     *         start: 3
     *     }],
     *     ...
     *   }
     * }
     */
    data_regions: {},

    /**
     * Set color converter function.<br><br>
     * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
     * @name datacolor
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
     * @example
     * data: {
     *   color: function(color, d) { ... }
     * }
     */
    data_color: undefined,

    /**
     * Set color for each data.
     * @name datacolors
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   colors: {
     *     data1: "#ff0000",
     *     data2: function(d) {
     *        return "#000";
     *     }
     *     ...
     *   }
     * }
     */
    data_colors: {},

    /**
     * Hide each data when the chart appears.<br><br>
     * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
     * @name datahide
     * @memberof Options
     * @type {Boolean|Array}
     * @default false
     * @example
     * data: {
     *   // all of data will be hidden
     *   hide: true
     *
     *   // specified data will be hidden
     *   hide: ["data1", ...]
     * }
     */
    data_hide: !1,

    /**
     * Filter values to be shown
     * The data value is the same as the returned by `.data()`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     * @name datafilter
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * data: {
     *   // filter for id value
     *   filter: function(v) {
     *      // v: [{id: "data1", id_org: "data1", values: [
     *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
     *      //    }, ...]
     *      return v.id !== "data1";
     *   }
     */
    data_filter: undefined,

    /**
     * Set the stacking to be normalized
     * - **NOTE:**
     *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
     *   - y Axis will be set in percentage value (0 ~ 100%)
     *   - Must have postive values
     * @name datastacknormalize
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
     * @example
     * data: {
        *   stack: {
        *      normalize: true
        *   }
        * }
     */
    data_stack_normalize: !1,

    /**
     * Set data selection enabled<br><br>
     * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
     * @name dataselectionenabled
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
     * @example
     * data: {
     *    selection: {
     *       enabled: true
     *    }
     * }
     */
    data_selection_enabled: !1,

    /**
     * Set grouped selection enabled.<br><br>
     * If this option set true, multiple data points that have same x value will be selected by one selection.
     * @name dataselectiongrouped
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       grouped: true
     *    }
     * }
     */
    data_selection_grouped: !1,

    /**
     * Set a callback for each data point to determine if it's selectable or not.<br><br>
     * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
     * @name dataselectionisselectable
     * @memberof Options
     * @type {Function}
     * @default function() { return true; }
     * @example
     * data: {
     *    selection: {
     *       isselectable: function(d) { ... }
     *    }
     * }
     */
    data_selection_isselectable: function data_selection_isselectable() {
      return !0;
    },

    /**
     * Set multiple data points selection enabled.<br><br>
     * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
     * @name dataselectionmultiple
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
     *    selection: {
     *       multiple: false
     *    }
     * }
     */
    data_selection_multiple: !0,

    /**
     * Enable to select data points by dragging.
     * If this option set true, data points can be selected by dragging.
     * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
     * @name dataselectiondraggable
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       draggable: true
     *   }
     * }
     */
    data_selection_draggable: !1,

    /**
     * Set a callback for click event on each data point.<br><br>
     * This callback will be called when each data point clicked and will receive d and element as the arguments. d is the data clicked and element is the element clicked. In this callback, this will be the Chart object.
     * @name dataonclick
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onclick: function(d, element) { ... }
     * }
     */
    data_onclick: function data_onclick() {},

    /**
     * Set a callback for mouse/touch over event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves onto each data point and will receive d as the argument. d is the data where mouse cursor moves onto. In this callback, this will be the Chart object.
     * @name dataonover
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onover: function(d) { ... }
     * }
     */
    data_onover: function data_onover() {},

    /**
     * Set a callback for mouse/touch out event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves out each data point and will receive d as the argument. d is the data where mouse cursor moves out. In this callback, this will be the Chart object.
     * @name dataonout
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onout: function(d) { ... }
     * }
     */
    data_onout: function data_onout() {},

    /**
     * Set a callback for on data selection.
     * @name dataonselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onselected: function data_onselected() {},

    /**
     * Set a callback for on data un-selection.
     * @name dataonunselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onunselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onunselected: function data_onunselected() {},

    /**
     * Set a callback for minimum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmin
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmin: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmin: undefined,

    /**
     * Set a callback for maximum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmax
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmax: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmax: undefined,

    /**
     * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
     * @name dataurl
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
     * @example
     * data: {
     *     url: "/data/test.csv"
     * }
     */
    data_url: undefined,

    /**
     * XHR header value
     * - **NOTE:** Should be used with `data.url` option
     * @name dataheaders
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
     * @example
     * data: {
     *     url: "/data/test.csv",
     *     headers: {
     *        "Content-Type": "text/xml",
     *        ...
     *     }
     * }
     */
    data_headers: undefined,

    /**
     * Parse a JSON object for data. See also data.keys.
     * @name datajson
     * @memberof Options
     * @type {Object}
     * @default undefined
     * @see [datakeys](#.data%25E2%2580%25A4keys)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_json: undefined,

    /**
     * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
     * @name datarows
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
     * @example
     * data: {
     *   rows: [
     *     ["A", "B", "C"],
     *     [90, 120, 300],
     *     [40, 160, 240],
     *     [50, 200, 290],
     *     [120, 160, 230],
     *     [80, 130, 300],
     *     [90, 220, 320]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {high:150, mid: 140, low: 110}, 120
     *        [150, 140, 110], 120
     *      ],
     *      [[155, 130, 115], 55],
     *      [[160, 135, 120], 60]
     *   ],
     *   types: {
     *       data1: "area-line-range",
     *       data2: "line"
     *   }
     * }
     *
     * // for 'bubble' type, data can contain dimension value:
     * // - an array of [y, z] data following the order
     * // - or an object with 'y' and 'z' key value
     * // 'y' is for y axis coordination and 'z' is the bubble radius value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {y:10, z: 140}, 120
     *        [10, 140], 120
     *      ],
     *      [[100, 30], 55],
     *      [[50, 100], 60]
     *   ],
     *   types: {
     *       data1: "bubble",
     *       data2: "line"
     *   }
     * }
     */
    data_rows: undefined,

    /**
     * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
     * @name datacolumns
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
     * @example
     * data: {
     *   columns: [
     *      ["data1", 30, 20, 50, 40, 60, 50],
     *      ["data2", 200, 130, 90, 240, 130, 220],
     *      ["data3", 300, 200, 160, 400, 250, 250]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   columns: [
     *      ["data1",
     *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
     *          [150, 140, 110],
     *          [150, 140, 110]
     *      ]
     *   ],
     *   type: "area-line-range"
     * }
     *
     * // for 'bubble' type, data can contain dimension value:
     * // - an array of [y, z] data following the order
     * // - or an object with 'y' and 'z' key value
     * // 'y' is for y axis coordination and 'z' is the bubble radius value
     * data: {
     *   columns: [
     *      ["data1",
     *          [10, 140],  // or {y:10, z: 140}
     *          [100, 30],
     *          [50, 100]
     *      ]
     *   ],
     *   type: "bubble"
     * }
     */
    data_columns: undefined,

    /**
     * Used if loading JSON via data.url.
     * - **Available Values:**
     *   - json
     *   - csv
     *   - tsv
     * @name datamimeType
     * @memberof Options
     * @type {String}
     * @default csv
     * @example
     * data: {
     *     mimeType: "json"
     * }
     */
    data_mimeType: "csv",

    /**
     * Choose which JSON object keys correspond to desired data.
     * - **NOTE:** Only for JSON object given as array.
     * @name datakeys
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_keys: undefined,

    /**
     * Set text label to be displayed when there's no data to show.
     * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
     * @name dataemptylabeltext
     * @memberof Options
     * @type {String}
     * @default ""
     * @example
     * data: {
     *   empty: {
     *     label: {
     *       text: "No Data"
     *     }
     *   }
     * }
     */
    data_empty_label_text: "",

    /**
     * Set subchart options
     * @name subchart
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
     * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
     * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
     * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
     * @property {Number} [subchart.size.height] Change the height of the subchart.
     * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
     *  Specified function receives the current zoomed x domain.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
     * @example
     *  subchart: {
     *      axis: {
     *      	x: {
     *      	  show: true,
     *      	    tick: {
     *      	      show: true,
     *      	      text: {
     *      	        show: false
     *      	      }
     *      	    }
     *      	}
     *      },
     *      show: true,
     *      size: {
     *          height: 20
     *      },
     *      onbrush: function(domain) { ... }
     *  }
     */
    subchart_show: !1,
    subchart_size_height: 60,
    subchart_axis_x_show: !0,
    subchart_axis_x_tick_show: !0,
    subchart_axis_x_tick_text_show: !0,
    subchart_onbrush: function subchart_onbrush() {},

    /**
     * Set color of the data values
     * @name color
     * @memberof Options
     * @type {Object}
     * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
     * @property {Array} [color.pattern] custom color pattern
     * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
     *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
     *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
     *    - `bb-colorize-pattern-red`
     *    - `bb-colorize-pattern-fff`
     * @property {Object} [color.threshold] color threshold for gauge and tooltip color
     * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
     * @property {Array} [color.threshold.values] Threshold values for each steps
     * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
     * @example
     *  color: {
     *      pattern: ["#1f77b4", "#aec7e8", ...],
     *
     *      // Set colors' patterns
     *      // it should return an array of SVGPatternElement
     *      tiles: function() {
     *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
     *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
     *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
     *
     *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
     *         pattern.setAttribute("width", "32");
     *         pattern.setAttribute("height", "32");
     *
     *         g.style.fill = "#000";
     *         g.style.opacity = "0.2";
              *
     *         circle1.setAttribute("cx", "3");
     *         circle1.setAttribute("cy", "3");
     *         circle1.setAttribute("r", "3");
              *
     *         g.appendChild(circle1);
     *         pattern.appendChild(g);
     *
     *         return [pattern];
     *      },
     *
     *      // for threshold usage, pattern values should be set for each steps
     *      pattern: ["grey", "green", "yellow", "orange", "red"],
     *      threshold: {
     *          unit: "value",
     *
     *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
     *          values: [10, 20, 30, 40, 50],
     *
     *          // the equation for max:
     *          // - unit == 'value': max => 30
     *          // - unit != 'value': max => value*100/30
     *          max: 30
     *      },
     *
     *      // set all data to 'red'
     *      onover: "red",
     *
     *      // set different color for data
     *      onover: {
     *          data1: "red",
     *          data2: "yellow"
     *      },
     *
     *      // will pass data object to the callback
     *      onover: function(d) {
     *          return d.id === "data1" ? "red" : "green";
     *      }
     *  }
     */
    color_pattern: [],
    color_tiles: undefined,
    color_threshold: {},
    color_onover: undefined,

    /**
     * Legend options
     * @name legend
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [legend.show=true] Show or hide legend.
     * @property {Boolean} [legend.hide=false] Hide legend
     *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
     * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
     * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
     *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
     *    - {=COLOR}: data color value
     *    - {=TITLE}: data title value
     *  - If set `function` value, will pass following arguments to the given function:
     *   - title {String}: data's id value
     *   - color {String}: color string
     *   - data {Array}: data array
     * @property {String} [legend.position=bottom] Change the position of legend.<br>
     *  Available values are: `bottom`, `right` and `inset` are supported.
     * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
     *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
     *  - **anchor** decides the position of the legend:
     *   - top-left
     *   - top-right
     *   - bottom-left
     *   - bottom-right
     *  - **x** and **y**:
     *   - set the position of the legend based on the anchor.
     *  - **step**:
     *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
     * @property {Boolean} [legend.equally=false] Set to all items have same width size.
     * @property {Boolean} [legend.padding=0] Set padding value
     * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
     * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
     * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
     * @property {Number} [legend.item.tile.width=10] Set width of item tile element
     * @property {Number} [legend.item.tile.height=10] Set height of item tile element
     * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
     * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
     * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
     * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
     * @example
     *  legend: {
     *      show: true,
     *      hide: true,
     *      //or hide: "data1"
              *      //or hide: ["data1", "data2"]
     *      contents: {
     *          bindto: "#legend",   // <ul id='legend'></ul>
     *
     *          // will be as: <li style='background-color:#1f77b4'>data1</li>
     *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
     *
     *          // or using function
     *          template: function(id, color, data) {
     *               // if you want omit some legend, return falsy value
     *               if (title !== "data1") {
     *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
     *               }
     *          }
     *      },
              *      position: "bottom",  // bottom, right, inset
     *      inset: {
     *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
     *          x: 20,
     *          y: 10,
     *          step: 2
     *      },
              *      equally: false,
              *      padding: 10,
              *      item: {
     *          onclick: function(id) { ... },
     *          onover: function(id) { ... },
     *          onout: function(id) { ... },
     *
     *          // set tile's size
     *          tile: {
     *              width: 20,
     *              height: 15
     *          }
     *      },
     *      usePoint: true
     *  }
     */
    legend_show: !0,
    legend_hide: !1,
    legend_contents_bindto: undefined,
    legend_contents_template: undefined,
    legend_position: "bottom",
    legend_inset_anchor: "top-left",
    legend_inset_x: 10,
    legend_inset_y: 10,
    legend_inset_step: undefined,
    legend_item_onclick: undefined,
    legend_item_onover: undefined,
    legend_item_onout: undefined,
    legend_equally: !1,
    legend_padding: 0,
    legend_item_tile_width: 10,
    legend_item_tile_height: 10,
    legend_usePoint: !1,

    /**
     * Switch x and y axis position.
     * @name axisrotated
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   rotated: true
     * }
     */
    axis_rotated: !1,

    /**
     * Set clip-path attribute for x axis element
     * @name axisxclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo]()
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_x_clipPath: !0,

    /**
     * Show or hide x axis.
     * @name axisxshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     show: false
     *   }
     * }
     */
    axis_x_show: !0,

    /**
     * Set type of x axis.<br><br>
     * **Available Values:**
     * - timeseries
     * - category
     * - indexed
     * @name axisxtype
     * @memberof Options
     * @type {String}
     * @default indexed
     * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
     * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
     * @example
     * axis: {
     *   x: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_x_type: "indexed",

    /**
     * Set how to treat the timezone of x values.<br>
     * If true, treat x value as localtime. If false, convert to UTC internally.
     * @name axisxlocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     localtime: false
     *   }
     * }
     */
    axis_x_localtime: !0,

    /**
     * Set category names on category axis.
     * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
     * @name axisxcategories
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * axis: {
     *   x: {
     *     categories: ["Category 1", "Category 2", ...]
     *   }
     * }
     */
    axis_x_categories: [],

    /**
     * centerize ticks on category axis.
     * @name axisxtickcentered
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       centered: true
     *     }
     *   }
     * }
     */
    axis_x_tick_centered: !1,

    /**
     * A function to format tick value. Format string is also available for timeseries data.
     * @name axisxtickformat
     * @memberof Options
     * @type {Function|String}
     * @default undefined
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *        // for timeseries, a 'datetime' object is given as parameter
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *
     *       // for category, index(Number) and categoryName(String) are given as parameter
     *       format: function(index, categoryName) {
     *           return categoryName.substr(0, 10);
     *       },
     *
     *        // for timeseries format specifier
     *        format: "%Y-%m-%d %H:%M:%S"
     *     }
     *   }
     * }
     */
    axis_x_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.x.tick.culling.max.
     * @name axisxtickculling
     * @memberof Options
     * @type {Boolean}
     * @default
     * - true for indexed axis and timeseries axis
     * - false for category axis
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_x_tick_culling: {},

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisxtickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 10
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_culling_max: 10,

    /**
     * The number of x axis ticks to show.<br><br>
     * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
     * @name axisxtickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_x_tick_count: undefined,

    /**
     * Show or hide x axis tick line.
     * @name axisxtickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_x_tick_show: !0,

    /**
     * Show or hide x axis tick text.
     * @name axisxticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_show: !0,

    /**
     * Set the x Axis tick text's position relatively its original position
     * @name axisxticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Fit x axis ticks.
     * - **true**: ticks will be positioned nicely to have same intervals.
     * - **false**: ticks will be positioned according to x value of the data points.
     * @name axisxtickfit
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
     * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       fit: false
     *     }
     *   }
     * }
     */
    axis_x_tick_fit: !0,

    /**
     * Set the x values of ticks manually.<br><br>
     * If this option is provided, the position of the ticks will be determined based on those values. This option works with timeseries data and the x values will be parsed accoding to the type of the value and data.xFormat option.
     * @name axisxtickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       values: [1, 2, 4, 8, 16, 32, ...]
     *     }
     *   }
     * }
     */
    axis_x_tick_values: null,

    /**
     * Rotate x axis tick text.<br>
     * If you set negative value, it will rotate to opposite direction.
     * @name axisxtickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_x_tick_rotate: 0,

    /**
     * Show x axis outer tick.
     * @name axisxtickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_x_tick_outer: !0,

    /**
     * Set tick text to be multiline
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
     * @name axisxtickmultiline
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       multiline: false
     *     }
     *   }
     * }
     * @example
     * // example of line break with '\n'
     * // In this case, 'axis.x.tick.width' is ignored
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "long\ntext", "Another\nLong\nText"],
     *        ...
     *    ],
     * }
     */
    axis_x_tick_multiline: !0,

    /**
     * Set tick width
     * - **NOTE:**
     *  > When x tick text contains `\n`, this option is ignored.
     * @name axisxtickwidth
     * @memberof Options
     * @type {Number}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       width: 50
     *     }
     *   }
     * }
     */
    axis_x_tick_width: null,

    /**
     * Set to display system tooltip(via 'title' attribute) for tick text
     * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
     * @name axisxticktooltip
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       tooltip: true
     *     }
     *   }
     * }
     */
    axis_x_tick_tooltip: !1,

    /**
     * Set max value of x axis range.
     * @name axisxmax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     max: 100
     *   }
     * }
     */
    axis_x_max: undefined,

    /**
     * Set min value of x axis range.
     * @name axisxmin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     min: -100
     *   }
     * }
     */
    axis_x_min: undefined,

    /**
     * Set padding for x axis.<br><br>
     * If this option is set, the range of x axis will increase/decrease according to the values.
     * If no padding is needed in the rage of x axis, 0 should be set.
     * - **NOTE:**
     *   The padding values aren't based on pixels. It differs according axis types<br>
     *   - **category:** The unit of tick value
     *     ex. the given value `1`, is same as the width of 1 tick width
     *   - **timeseries:** Numeric time value
     *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
     * @name axisxpadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   x: {
     *     padding: {
     *       // when axis type is 'category'
     *       left: 1,  // set left padding width of equivalent value of a tick's width
     *       right: 0.5  // set right padding width as half of equivalent value of tick's width
     *
     *       // when axis type is 'timeseries'
     *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
     *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
     *     }
     *   }
     * }
     */
    axis_x_padding: {},

    /**
     * Set height of x axis.<br><br>
     * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
     * @name axisxheight
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     height: 20
     *   }
     * }
     */
    axis_x_height: undefined,

    /**
     * Set default extent for subchart and zoom. This can be an array or function that returns an array.
     * @name axisxextent
     * @memberof Options
     * @type {Array|Function}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     // extent range as a pixel value
     *     extent: [0, 200],
     *
     *     // when axis is 'timeseries', parsable datetime string
     *     extent: ["2019-03-01", "2019-03-05"],
     *
     *     // return extent value
     *     extent: function(domain, scale) {
     *    	 var extent = domain.map(function(v) {
     *     	    return scale(v);
     *     	 });
     *
     *   	 // it should return a format of array
     *   	 // ex) [0, 584]
     *     	 return extent;
     *     }
     *   }
     * }
     */
    axis_x_extent: undefined,

    /**
     * Set label on x axis.<br><br>
     * You can set x axis label and change its position by this option.
     * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
     * Available position differs according to the axis direction (vertical or horizontal).
     * If string set, the position will be the default.
     *
     *  - **If it's horizontal axis:**
     *    - inner-right [default]
     *    - inner-center
     *    - inner-left
     *    - outer-right
     *    - outer-center
     *    - outer-left
     *  - **If it's vertical axis:**
     *    - inner-top [default]
     *    - inner-middle
     *    - inner-bottom
     *    - outer-top
     *    - outer-middle
     *    - outer-bottom
     * @name axisxlabel
     * @memberof Options
     * @type {String|Object}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     label: "Your X Axis"
     *   }
     * }
     *
     * axis: {
     *   x: {
     *     label: {
     *        text: "Your X Axis",
     *        position: "outer-center"
     *     }
     *   }
     * }
     */
    axis_x_label: {},

    /**
     * Set additional axes for x Axis.
     * - **NOTE:** Axis' scale is based on x Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisxaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * x: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_x_axes: [],

    /**
     * Set clip-path attribute for y axis element
     * @name axisyclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_y_clipPath: !0,

    /**
     * Show or hide y axis.
     * @name axisyshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     show: false
     *   }
     * }
     */
    axis_y_show: !0,

    /**
     * Set type of y axis.<br><br>
     * **Available Values:**
     *   - timeseries
     *   - category
     *   - indexed
     * @name axisytype
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_y_type: undefined,

    /**
     * Set max value of y axis.
     * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     max: 1000
     *   }
     * }
     */
    axis_y_max: undefined,

    /**
     * Set min value of y axis.
     * - **NOTE:**
     *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     min: 1000
     *   }
     * }
     */
    axis_y_min: undefined,

    /**
     * Change the direction of y axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisyinverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inverted: true
     *   }
     * }
     */
    axis_y_inverted: !1,

    /**
     * Set center value of y axis.
     * @name axisycenter
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     center: 0
     *   }
     * }
     */
    axis_y_center: undefined,

    /**
     * Show y axis inside of the chart.
     * @name axisyinner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inner: true
     *   }
     * }
     */
    axis_y_inner: !1,

    /**
     * Set label on y axis.<br><br>
     * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
     * @name axisylabel
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
     * @example
     * axis: {
     *   y: {
     *     label: "Your Y Axis"
     *   }
     * }
     *
     * axis: {
     *   y: {
     *     label: {
     *        text: "Your Y Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y_label: {},

    /**
     * Set formatter for y axis tick text.<br><br>
     * This option accepts d3.format object as well as a function you define.
     * @name axisytickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
     * @name axisytickculling
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_y_tick_culling: !1,

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisytickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 5
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_culling_max: 5,

    /**
     * Show y axis outer tick.
     * @name axisytickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y_tick_outer: !0,

    /**
     * Set y axis tick values manually.
     * @name axisytickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y_tick_values: null,
    axis_y_tick_rotate: 0,

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisytickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y_tick_count: undefined,

    /**
     * Show or hide y axis tick line.
     * @name axisytickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y_tick_show: !0,

    /**
    * Show or hide y axis tick text.
    * @name axisyticktextshow
    * @memberof Options
    * @type {Boolean}
    * @default true
    * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
    * @example
    * axis: {
    *   y: {
    *     tick: {
    *       text: {
    *           show: false
    *       }
    *     }
    *   }
    * }
    */
    axis_y_tick_text_show: !0,

    /**
     * Set the y Axis tick text's position relatively its original position
     * @name axisyticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisyticktime
     * @memberof Options
     * @private
     * @type {Object}
     * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       time: {
     *          // ticks at 15-minute intervals
     *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
     *          value: d3.timeMinute.every(15)
     *       }
     *     }
     *   }
     * }
     */
    // @TODO: not fully implemented yet
    axis_y_tick_time_value: undefined,

    /**
     * Set padding for y axis.<br><br>
     * You can set padding for y axis to create more space on the edge of the axis.
     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
     *
     * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
     * @name axisypadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     padding: {
     *       top: 0,
     *       bottom: 0
     *     }
     *   }
     * }
     */
    axis_y_padding: {},

    /**
     * Set default range of y axis.<br><br>
     * This option set the default value for y axis when there is no data on init.
     * @name axisydefault
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y_default: undefined,

    /**
     * Set additional axes for y Axis.
     * - **NOTE:** Axis' scale is based on y Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisyaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y_axes: [],

    /**
     * Show or hide y2 axis.
     * - **NOTE**:
     *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
     *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
     * @name axisy2show
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     show: true
     *   }
     * }
     */
    axis_y2_show: !1,

    /**
     * Set max value of y2 axis.
     * @name axisy2max
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     max: 1000
     *   }
     * }
     */
    axis_y2_max: undefined,

    /**
     * Set min value of y2 axis.
     * @name axisy2min
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     min: -1000
     *   }
     * }
     */
    axis_y2_min: undefined,

    /**
     * Change the direction of y2 axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisy2inverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inverted: true
     *   }
     * }
     */
    axis_y2_inverted: !1,

    /**
     * Set center value of y2 axis.
     * @name axisy2center
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     center: 0
     *   }
     * }
     */
    axis_y2_center: undefined,

    /**
     * Show y2 axis inside of the chart.
     * @name axisy2inner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inner: true
     *   }
     * }
     */
    axis_y2_inner: !1,

    /**
     * Set label on y2 axis.<br><br>
     * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
     * @name axisy2label
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
     * @example
     * axis: {
     *   y2: {
     *     label: "Your Y2 Axis"
     *   }
     * }
     *
     * axis: {
     *   y2: {
     *     label: {
     *        text: "Your Y2 Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y2_label: {},

    /**
     * Set formatter for y2 axis tick text.<br><br>
     * This option works in the same way as axis.y.format.
     * @name axisy2tickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       format: d3.format("$,")
     *       //or format: function(d) { return "$" + d; }
     *     }
     *   }
     * }
     */
    axis_y2_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
     * @name axisy2tickculling
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_culling: !1,

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisy2tickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 5
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_culling_max: 5,

    /**
     * Show or hide y2 axis outer tick.
     * @name axisy2tickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_outer: !0,

    /**
     * Set y2 axis tick values manually.
     * @name axisy2tickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y2_tick_values: null,

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2tickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y2_tick_count: undefined,

    /**
     * Show or hide y2 axis tick line.
     * @name axisy2tickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_show: !0,

    /**
     * Show or hide y2 axis tick text.
     * @name axisy2ticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_show: !0,

    /**
     * Set the y2 Axis tick text's position relatively its original position
     * @name axisy2ticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2padding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     padding: {
     *       top: 100,
     *       bottom: 100
     *     }
     *   }
     * }
     */
    axis_y2_padding: {},

    /**
     * Set default range of y2 axis.<br><br>
     * This option set the default value for y2 axis when there is no data on init.
     * @name axisy2default
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y2_default: undefined,

    /**
     * Set additional axes for y2 Axis.
     * - **NOTE:** Axis' scale is based on y2 Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisy2axes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y2: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y2_axes: [],

    /**
     * Set related options
     * @name grid
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
     * @property {Boolean} [x.show=false] Show grids along x axis.
     * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
     *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
     *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
     * @property {Boolean} [y.show=false] Show grids along x axis.
     * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
     *  This option accepts array including object that has value, text, position and class.
     * @property {Number} [y.ticks=10] Number of y grids to be shown.
     * @property {Boolean} [focus.show=true] Show grids when focus.
     * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
     * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
     * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
     * @example
     * grid: {
     *   x: {
     *     show: true,
     *     lines: [
     *       {value: 2, text: "Label on 2"},
     *       {value: 5, text: "Label on 5", class: "label-5"},
     *       {value: 6, text: "Label on 6", position: "start"}
     *     ]
     *   },
     *   y: {
     *     show: true,
     *     lines: [
     *       {value: 100, text: "Label on 100"},
     *       {value: 200, text: "Label on 200", class: "label-200"},
     *       {value: 300, text: "Label on 300", position: 'middle'}
     *     ],
     *     ticks: 5
     *   },
     *   front: true,
     *   focus: {
     *      show: false
     *   },
     *   lines: {
     *      front: false
     *   }
     * }
     */
    grid_x_show: !1,
    grid_x_type: "tick",
    grid_x_lines: [],
    grid_y_show: !1,
    grid_y_lines: [],
    grid_y_ticks: 10,
    grid_focus_show: !0,
    grid_front: !1,
    grid_lines_front: !0,

    /**
     * Set point options
     * @name point
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [point.show=true] Whether to show each point in line.
     * @property {Number|Function} [point.r=2.5] The radius size of each point.
     *  - **NOTE:** Disabled for 'bubble' type
     * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
     * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
     *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
     * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
     * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
     * @property {String} [point.type="circle"] The type of point to be drawn
     * - **NOTE:**
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
     * - **NOTE:**
     *  - This is an `experimental` feature and can have some unexpected behaviors.
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     *  - svg shape tag interpreted as string<br>
     *    (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
     * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
     * @example
     *  point: {
     *      show: false,
     *      r: 5,
     *
     *      // or customize the radius
     *      r: function(d) {
     *          ...
     *          return r;
     *      },
     *
     *      focus: {
     *          expand: {
     *              enabled: true,
     *              r: 1
     *          }
     *      },
     *      select: {
     *          r: 3
     *      },
     *
     *      // having lower value, means how closer to be for interaction
     *      sensitivity: 3,
     *
     *      // valid values are "circle" or "rectangle"
     *      type: "rectangle",
     *
     *      // or indicate as pattern
    	 *      pattern: [
    	 *        "circle",
    	 *        "rectangle",
    	 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
    	 *     ],
     *  }
     */
    point_show: !0,
    point_r: 2.5,
    point_sensitivity: 10,
    point_focus_expand_enabled: !0,
    point_focus_expand_r: undefined,
    point_pattern: [],
    point_select_r: undefined,
    point_type: "circle",

    /**
     * Set line options
     * @name line
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
     *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
     * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
     * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
     * **Available values:**
     * - step
     * - step-before
     * - step-after
     * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
     * @example
     *  line: {
     *      connectNull: true,
     *      classes: [
     *          "line-class1",
     *          "line-class2"
     *      ],
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ]
     *  }
     */
    line_connectNull: !1,
    line_step_type: "step",
    line_classes: undefined,
    line_point: !0,

    /**
     * Set bar options
     * @name bar
     * @memberof Options
     * @type {Object}
     * @property {Number} [bar.padding=0] The padding pixel value between each bar.
     * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
     * - **NOTE:** Works only for non-stacked bar
     * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
    	 * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
     * @property {Number} [bar.width] Change the width of bar chart.
     * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.max] The maximum width value for ratio.
     * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
     * - **NOTE:**
     *   - Works only for non-stacked bar
     *   - Bars are centered accoding its total width value
     * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
     * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
     * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
     * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
     * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
     * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
     * @example
     *  bar: {
     *      padding: 1,
     *
     *      // the 'radius' option can be used only for non-stacking bars
     *      radius: 10,
     *      // or
     *      radius: {
     *          ratio: 0.5
     *      }
     *
     *      // will not have offset between each bar elements for interaction
     *      sensitivity: 0,
     *
     *      width: 10,
     *
     *      // or
     *      width: {
     *          ratio: 0.2,
     *          max: 20
     *      },
     *
     *      // or specify width per dataset
     *      width: {
     *          data1: 20,
     *          data2: {
     *              ratio: 0.2,
     *              max: 20
     *          }
     *      },
     *
     *      zerobased: false
     *  }
     */
    bar_padding: 0,
    bar_radius: undefined,
    bar_radius_ratio: undefined,
    bar_sensitivity: 2,
    bar_width: undefined,
    bar_width_ratio: .6,
    bar_width_max: undefined,
    bar_zerobased: !0,

    /**
     * Set bubble options
     * @name bubble
     * @memberof Options
     * @type {Object}
     * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
     * @example
     *  bubble: {
     *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
     *      // And the lesser will have radius relatively from tha max value.
     *      maxR: 50,
     *
     *      // or set radius callback
     *      maxR: function(d) {
     *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
     *          ...
     *          return Math.sqrt(d.value * 2);
     *      }
     *  }
     */
    bubble_maxR: 35,

    /**
     * Set area options
     * @name area
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
     * @property {Boolean} [area.above=false] Set background area above the data chart line.
     * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
     * Or customize by giving below object value:
     *  - x {Array}: `x1`, `x2` value
     *  - y {Array}: `y1`, `y2` value
     *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
     * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
     * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
     * @example
     *  area: {
     *      zerobased: false,
     *      above: true,
     *
     *      // will generate follwing linearGradient:
     *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
     *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
     *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
     *      // </linearGradient>
     *      linearGradient: true,
     *
     *      // Or customized gradient
     *      linearGradient: {
     *      	x: [0, 0],  // x1, x2 attributes
     *      	y: [0, 0],  // y1, y2 attributes
     *      	stops: [
     *      	  // offset, stop-color, stop-opacity
     *      	  [0, "#7cb5ec", 1],
     *
     *      	  // setting 'null' for stop-color, will set its original data color
     *      	  [0.5, null, 0],
     *
     *      	  // setting 'function' for stop-color, will pass data id as argument.
     *      	  // It should return color string or null value
     *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
     *      	]
     *      }
     *  }
     */
    area_zerobased: !0,
    area_above: !1,
    area_linearGradient: !1,

    /**
     * Set pie options
     * @name pie
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
     * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
     * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
     * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
     * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
     * @property {Number} [pie.padAngle=0] Set padding between data.
     * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
     * @example
     *  pie: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *              ...
     *              return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      // set duration of expand transition to 500ms.
     *      expand: {
     *          duration: 500
     *      },
     *
     *      innerRadius: 0,
     *
     *      // set different innerRadius for each data
     *      innerRadius: {
     *      	data1: 10,
     *      	data2: 0
     *      }
     *
     *      padAngle: 0.1,
     *      padding: 0
     *  }
     */
    pie_label_show: !0,
    pie_label_format: undefined,
    pie_label_threshold: .05,
    pie_label_ratio: undefined,
    pie_expand: {},
    pie_expand_duration: 50,
    pie_innerRadius: 0,
    pie_padAngle: 0,
    pie_padding: 0,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Set gauge options
     * @name gauge
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
     * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
     * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
     * @property {Function} [gauge.label.extents] Set customized min/max label text.
     * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
     * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
     * @property {Number} [gauge.min=0] Set min value of the gauge.
     * @property {Number} [gauge.max=100] Set max value of the gauge.
     * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2]
     * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
     * @property {String} [gauge.units] Set units of the gauge.
     * @property {Number} [gauge.width] Set width of gauge chart.
     * @example
     *  gauge: {
     *      fullCircle: false,
     *      label: {
     *          show: false,
     *          format: function(value, ratio) {
     *              return value;
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          extents: function(value, isMax) {
    	 *              return (isMax ? "Max:" : "Min:") + value;
     *          }
     *      },
     *      expand: false,
     *
     *      // or set duration
     *      expand: {
     *          duration: 20
     *      },
     *      min: -100,
     *      max: 200,
     *      title: "Title Text",
     *      units: "%",
     *      width: 10
     *  }
     */
    gauge_fullCircle: !1,
    gauge_label_show: !0,
    gauge_label_format: undefined,
    gauge_min: 0,
    gauge_max: 100,
    gauge_startingAngle: -1 * Math.PI / 2,
    gauge_label_extents: undefined,
    gauge_title: "",
    gauge_units: undefined,
    gauge_width: undefined,
    gauge_expand: {},
    gauge_expand_duration: 50,

    /**
     * Set donut options
     * @name donut
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
     * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
     * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
     * @property {Number} [donut.width] Set width of donut chart.
     * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
     * @property {Number} [donut.padAngle=0] Set padding between data.
     * @example
     *  donut: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *          	...
     *          	return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *      expand: false,
     *      width: 10,
     *      padAngle: 0.2,
     *      title: "Donut Title"
     *
     *      // title with line break
     *      title: "Title1\nTitle2"
     *  }
     */
    donut_label_show: !0,
    donut_label_format: undefined,
    donut_label_threshold: .05,
    donut_label_ratio: undefined,
    donut_width: undefined,
    donut_title: "",
    donut_expand: {},
    donut_expand_duration: 50,
    donut_padAngle: 0,

    /**
     * Set spline options
     * - **Available interpolation type values:**
     *  - basis (d3.curveBasis)
     *  - basis-closed (d3.curveBasisClosed)
     *  - basis-open (d3.curveBasisOpen)
     *  - bundle (d3.curveBundle)
     *  - cardinal (d3.curveCardinal)
     *  - cardinal-closed (d3.curveCardinalClosed)
     *  - cardinal-open (d3.curveCardinalOpen)
     *  - catmull-rom (d3.curveCatmullRom)
     *  - catmull-rom-closed (d3.curveCatmullRomClosed)
     *  - catmull-rom-open (d3.curveCatmullRomOpen)
     *  - monotone-x (d3.curveMonotoneX)
     *  - monotone-y (d3.curveMonotoneY)
     *  - natural (d3.curveNatural)
     *  - linear-closed (d3.curveLinearClosed)
     *  - linear (d3.curveLinear)
     *  - step (d3.curveStep)
     *  - step-after (d3.curveStepAfter)
     *  - step-before (d3.curveStepBefore)
     * @name spline
     * @memberof Options
     * @type {Object}
     * @property {String} [spline.interpolation.type="cardinal"]
     * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
     * @example
     *  spline: {
     *      interpolation: {
     *          type: "cardinal"
     *      }
     *  }
     */
    spline_interpolation_type: "cardinal",

    /**
     * Set radar options
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break.
     * @name radar
     * @memberof Options
     * @type {Object}
     * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
     * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
     * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
     * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
     * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
     * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
     * @property {Number} [radar.level.depth=3] Set the level depth.
     * @property {Boolean} [radar.level.show=true] Show or hide level.
     * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
     * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
     * @property {Number} [radar.size.ratio=0.87] Set size ratio.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
     * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
     * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
     * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
     * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
     * @example
     *  radar: {
     *      axis: {
     *          max: 50,
     *          line: {
     *              show: false
     *          },
     *          text: {
     *              position: {
     *              	x: 0,
     *              	y: 0
     *              },
     *              show: false
     *          }
     *      },
     *      direction: {
     *          clockwise: true
     *      },
     *      level: {
     *          show: false,
     *          text: {
     *              format: function(x) {
     *                  return x + "%";
     *              },
     *              show: true
     *          }
     *      },
     *      size: {
     *          ratio: 0.7
     *      }
     *  }
     */
    radar_axis_max: undefined,
    radar_axis_line_show: !0,
    radar_axis_text_show: !0,
    radar_axis_text_position: {},
    radar_level_depth: 3,
    radar_level_show: !0,
    radar_level_text_format: function radar_level_text_format(x) {
      return x % 1 === 0 ? x : x.toFixed(2);
    },
    radar_level_text_show: !0,
    radar_size_ratio: .87,
    radar_direction_clockwise: !1,

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class. The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end. If not specified, the edge values will be used. If timeseries x axis, date string, Date object and unixtime integer can be used. If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: [],

    /**
     * Tooltip options
     * @name tooltip
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
     * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
     * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
     *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
     * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
     * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
     * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
     *  Specified function receives x of the data point to show.
     * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     *  If undefined returned, the row of that value will be skipped.
     * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
     *  This option can be used to modify the tooltip position by returning object that has top and left.
     * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
     *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
     * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
     *  - **NOTE:** When is specified, will not be updating tooltip's position.
     * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
     *  Within template, below syntax will be replaced using template-like syntax string:
     *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
     *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
     *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
     *    - **{=TITLE}**: title value.
     *    - **{=COLOR}**: data color.
     *    - **{=VALUE}**: data value.
     * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
     *  - **NOTE:** It should contain `{ key: Array, ... }` value
     *    - 'key' name is used as substitution within template as '{=KEY}'
     *    - The value array length should match with the data length
     * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
     * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
     * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
     * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
     * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
     * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
     * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
     * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
     *  **Available Values:**
     *  - `desc`: In descending data value order
     *  - `asc`: In ascending data value order
     *  - `null`: It keeps the data display order<br>
     *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
     *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
     *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
     * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
     * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
     * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
     * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
     * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
     * @example
     *  tooltip: {
     *      show: true,
     *      doNotHide: true,
     *      grouped: false,
     *      format: {
     *          title: function(x) { return "Data " + x; },
     *          name: function(name, ratio, id, index) { return name; },
     *          value: function(value, ratio, id, index) { return ratio; }
     *      },
     *      position: function(data, width, height, element) {
     *          return {top: 0, left: 0}
    		 *      },
     *
    		 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
    		 *          return ... // formatted html as you want
     		 *      },
     *
     *       // specify tooltip contents using template
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
     *      		'}}</ul>'
     *      }
     *
     *       // with additional text value
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	text: {
     *      		// a) 'key' name is used as substitution within template as '{=KEY}'
     *      		// b) the length should match with the data length
     *      		VAR1: ["text1", "text2"],
     *      		VAR2: ["comment1", "comment2"],
     *      	},
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
     *      		'}}</ul>'
     *      }
     		 *
     		 *      // sort tooltip data value display in ascending order
     		 *      order: "asc",
     		 *
     *      // specifying sort function
     *      order: function(a, b) {
     *         // param data passed format
     *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
     *           ...
     *      },
     *
     *      // show at the initialization
     *      init: {
     *          show: true,
     *          x: 2,
     *          position: {
     *              top: "150px",
     *              left: "250px"
     *          }
     *      },
     *
     *      // fires prior tooltip is shown
     *      onshow: function() { ...},
     *      // fires prior tooltip is hidden
     *      onhide: function() { ... },
     *      // fires after tooltip is shown
     *      onshown: function() { ... },
     *      // fires after tooltip is hidden
     *      onhidden: function() { ... },
     *
     *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
     *      // Useful for timeseries correlation
     *      linked: true,
     *
     *      // Specify name to interact those with the same name only.
     *      linked: {
     *          name: "some-group"
     *      }
     *  }
     */
    tooltip_show: !0,
    tooltip_doNotHide: !1,
    tooltip_grouped: !0,
    tooltip_format_title: undefined,
    tooltip_format_name: undefined,
    tooltip_format_value: undefined,
    tooltip_position: undefined,
    tooltip_contents: {},
    tooltip_init_show: !1,
    tooltip_init_x: 0,
    tooltip_init_position: {
      top: "0px",
      left: "50px"
    },
    tooltip_linked: !1,
    tooltip_linked_name: "",
    tooltip_onshow: function tooltip_onshow() {},
    tooltip_onhide: function tooltip_onhide() {},
    tooltip_onshown: function tooltip_onshown() {},
    tooltip_onhidden: function tooltip_onhidden() {},
    tooltip_order: null,

    /**
     * Set title options
     * @name title
     * @memberof Options
     * @type {Object}
     * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
     * @property {Number} [title.padding.top=0] Top padding value.
     * @property {Number} [title.padding.right=0] Right padding value.
     * @property {Number} [title.padding.bottom=0] Bottom padding value.
     * @property {Number} [title.padding.left=0] Left padding value.
     * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
     * @example
     *  title: {
     *      text: "Title Text",
     *
     *      // or Multiline title text
     *      text: "Main title text\nSub title text",
     *
     *      padding: {
     *          top: 10,
     *          right: 10,
     *          bottom: 10,
     *          left: 10
     *      },
     *      position: "center"
     *  }
     */
    title_text: undefined,
    title_padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    title_position: "center"
  };
};


// CONCATENATED MODULE: ./src/config/config.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getOptions: function getOptions() {
    return new Options_Options();
  },

  /**
   * Load configuration option
   * @param {Object} config User's generation config value
   * @private
   */
  loadConfig: function loadConfig(config) {
    var target,
        keys,
        read,
        thisConfig = this.config,
        find = function () {
      var key = keys.shift();
      return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
    };

    Object.keys(thisConfig).forEach(function (key) {
      target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/scale.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.zoomScale || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.xAxis.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    return this.axis.getId(id) === "y2" ? this.y2 : this.y;
  },
  getSubYScale: function getSubYScale(id) {
    return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit) {
    var updateXDomain = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.xMin = isRotated ? 1 : 0, $$.xMax = isRotated ? $$.height : $$.width, $$.yMin = isRotated ? 0 : $$.height, $$.yMax = isRotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = isRotated ? 0 : $$.height2, $$.subYMax = isRotated ? $$.width2 : 1;
    // update scales
    // x Axis
    var xDomain = updateXDomain && $$.x && $$.x.orgDomain(),
        xSubDomain = updateXDomain && $$.orgXDomain;
    // y Axis
    // update for arc
    $$.x = $$.getX($$.xMin, $$.xMax, xDomain, function () {
      return $$.xAxis.tickOffset();
    }), $$.subX = $$.getX($$.xMin, $$.xMax, xSubDomain, function (d) {
      return d % 1 ? 0 : $$.subXAxis.tickOffset();
    }), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getTickValues("x"), $$.xAxis = $$.axis.getAxis("x", $$.x, config.axis_x_tick_outer, isInit), $$.subXAxis = $$.axis.getAxis("subX", $$.subX, config.axis_x_tick_outer, isInit), $$.y = $$.getY($$.yMin, $$.yMax, $$.y ? $$.y.domain() : config.axis_y_default), $$.subY = $$.getY($$.subYMin, $$.subYMax, $$.subY ? $$.subY.domain() : config.axis_y_default), $$.yAxisTickValues = $$.axis.getTickValues("y"), $$.yAxis = $$.axis.getAxis("y", $$.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && ($$.y2 = $$.getY($$.yMin, $$.yMax, $$.y2 ? $$.y2.domain() : config.axis_y2_default), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, $$.subY2 ? $$.subY2.domain() : config.axis_y2_default), $$.y2AxisTickValues = $$.axis.getTickValues("y2"), $$.y2Axis = $$.axis.getAxis("y2", $$.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/internals/domain.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has".concat(isMin ? "Negative" : "Positive", "ValueInTargets")](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
        yMin = config["axis_".concat(axisId, "_min")],
        yMax = config["axis_".concat(axisId, "_max")],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_".concat(axisId, "_center")],
        isZeroBased = $$.hasType("bar", yTargets) && config.bar_zerobased || $$.hasType("area", yTargets) && config.area_zerobased,
        isInverted = config["axis_".concat(axisId, "_inverted")],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    if (yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, yTargets.length === 0) // use current domain if target of axisId is none
      return $$[axisId].domain();
    isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain($$.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_".concat(axisId, "_padding")];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_".concat(type)];
    return isDefined(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        firstX = xDomain[0],
        lastX = xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && ($$.x.domain(domain || sortValue($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? $$.orgXDomain : getBrushSelection($$).map($$.subX.invert);
      $$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        _zoomDomain = slicedToArray_default()(zoomDomain, 2),
        min = _zoomDomain[0],
        max = _zoomDomain[1];

    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/data/data.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return config.data_stack_normalize && config.data_groups.length;
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this;
    Object.keys(xs).forEach(function (id) {
      $$.config.data_xs[id] = xs[id];
    });
  },
  hasMultipleX: function hasMultipleX(xs) {
    return Object.keys(xs).map(function (id) {
      return xs[id];
    }).length > 1;
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this;
    return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  cloneTarget: function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  },
  updateXs: function updateXs(values) {
    values.length && (this.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(toConsumableArray_default()(value))), max = Math.max.apply(Math, [i ? max : -Infinity].concat(toConsumableArray_default()(value)));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.getCache(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.addCache(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.getCache("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.getCache(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.addCache(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, toConsumableArray_default()(this.data.targets.map(function (t) {
      return t.values.length;
    })));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, toConsumableArray_default()(value)) : isObject(value) && "high" in value ? data.push.apply(data, toConsumableArray_default()(Object.values(value))) : $$.isBubbleZType(v) ? data.push($$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = toConsumableArray_default()(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();

    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        minDist = $$.config.point_sensitivity;
    return values.filter(function (v) {
      return v && $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = $$.main.select(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(v.id), " .").concat(config_classes.bar, "-").concat(v.index)).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), values.filter(function (v) {
      return v && !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = ($$.zoomScale || $$.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_".concat(name)];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown.call(api).length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            $$.hiddenTargetIds.length && (total -= dataValues($$.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if ($$.hiddenTargetIds.length) {
          var hiddenSum = dataValues($$.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0)) / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this;
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        tickValues.some(function (d, j) {
          return !(+d.x !== +v.x) && (v.index = j, !0);
        }), isNumber(v.index) && v.index !== -1 || (v.index = i);
      });
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(55);

// CONCATENATED MODULE: ./src/data/data.convert.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data,
        $$ = this;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_".concat(v);
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) $$.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = $$.convertJsonToData(data.json, data.keys);else if (data.rows) data = $$.convertRowsToData(data.rows);else if (data.columns) data = $$.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },
  convertUrlToData: function convertUrlToData(url) {
    var _this = this,
        mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
        headers = arguments.length > 2 ? arguments[2] : undefined,
        keys = arguments.length > 3 ? arguments[3] : undefined,
        done = arguments.length > 4 ? arguments[4] : undefined,
        req = new XMLHttpRequest();

    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert".concat(capitalize(mimeType), "ToData")](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error("".concat(url, ": Something went wrong loading!"));
    }, req.send();
  },
  _convertCsvTsvToData: function _convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];

    for (var i = 1, len1 = rows.length; i < len1; i++) {
      var newRow = {};

      for (var j = 0, len2 = rows[i].length; j < len2; j++) {
        if (isUndefined(rows[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRow[keys[j]] = rows[i][j];
      }

      newRows.push(newRow);
    }

    return newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];

    for (var i = 0, len1 = columns.length; i < len1; i++) {
      var key = columns[i][0];

      for (var j = 1, len2 = columns[i].length; j < len2; j++) {
        if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(columns[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRows[j - 1][key] = columns[i][j];
      }
    }

    return newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        isTimeSeries = $$.isTimeSeries(),
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"".concat(id, "\"."));
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +d[id], isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(d[id]) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.addCache(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/data/data.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.resetCache();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.resetCache(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      $$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll(".".concat(config_classes.legendItem).concat($$.getTargetSelectorSuffix(id))).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// CONCATENATED MODULE: ./src/internals/category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var config = this.config;
    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(56);

// CONCATENATED MODULE: ./src/interactions/interaction.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.main.select(".".concat(config_classes.eventRects)).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll(".".concat(config_classes.eventRect)).remove(), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), isMultipleX) eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $$.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), eventRectUpdate = $$.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $$.updateEventRect(eventRectUpdate), $$.inputType !== "touch" || $$.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(".concat(config_classes.eventRect, "-?|s)"), "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client".concat(config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if ($$.dragging || $$.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) && $$.cancelClick && ($$.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        xScale = $$.zoomScale || $$.x,
        eventRectData = eventRectUpdate || $$.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = $$.width, h = $$.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? $$.height : $$.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? $$.width : rectW, h = isRotated ? rectW : $$.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showXGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideXGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showXGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showXGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select(".".concat(config_classes.eventRect)).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.svg.select(".".concat(config_classes.eventRect)).style("cursor", null), $$.hideXGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      config.color_onover && $$.setOverColor(isOver, d, isArc), isArc ? callback(d) : (isOver && $$.expandCirclesBars(d, null, !0), !$$.isMultipleX() && $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(callback));
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover", function (d) {
      $$.dragging || $$.flowing || $$.hasArcType() || $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!($$.dragging || $$.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.svg.select(".".concat(config_classes.eventRect, "-").concat(index));
        $$.isStepType(d) && $$.config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index);
      }
    }).on("mouseout", function (d) {
      !$$.config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config;
    if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));
    var index = d.index;
    $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll(".".concat(config_classes.shapes).concat($$.getTargetSelectorSuffix(closest.id))).selectAll(".".concat(config_classes.shape, "-").concat(closest.index)).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = ".".concat(isMultipleX ? config_classes.eventRect : "".concat(config_classes.eventRect, "-").concat(index)),
        eventRect = $$.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/internals/size.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this;
    $$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? 10 + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset".concat(capitalize(key)), parent = this.selectChart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser["document"].body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.selectChart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $$.main.select(".".concat(leftAxisClass)).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $$.selectChart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this,
        position = $$.axis.getLabelPositionById(id);
    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        h = 30;
    return id !== "x" || config.axis_x_show ? id === "x" && config.axis_x_height ? config.axis_x_height : id !== "y" || config.axis_y_show ? id !== "y2" || config.axis_y2_show ? ((id === "x" && !isRotated && config.axis_x_tick_rotate || id === "y" && isRotated && config.axis_y_tick_rotate) && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - config["axis_".concat(id, "_tick_rotate")]) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10)) : $$.rotated_padding_top : !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10 : 8; // Calculate x/y axis height when tick rotated
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.xAxis.tickInterval());
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(57);

// CONCATENATED MODULE: ./src/shape/shape.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        indices = {},
        i = 0;
    return $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in indices) {
        indices[d.id] = indices[_row4];
        break;
      }

      isUndefined(indices[d.id]) && (indices[d.id] = i++);
    }), indices.__max__ = i - 1, indices;
  },
  getShapeX: function getShapeX(offset, targetsNum, indices, isSub) {
    var $$ = this,
        scale = isSub ? $$.subX : $$.zoomScale || $$.x,
        barPadding = $$.config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var index = d.id in indices ? indices[d.id] : 0,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = scale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        targetIds = targets.map(function (t) {
      return t.id;
    });
    return function (d, idx) {
      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          offset = y0,
          i = idx;
      return targets.forEach(function (t) {
        var rowValues = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values,
            values = rowValues.map(function (v) {
          return $$.isStackNormalized() ? $$.getRatio("index", v, !0) : v.value;
        });
        t.id === d.id || indices[t.id] !== indices[d.id] || targetIds.indexOf(t.id) < targetIds.indexOf(d.id) && ((isUndefined(rowValues[i]) || +rowValues[i].x !== +d.x) && (i = -1, rowValues.forEach(function (v, j) {
          var x1 = v.x.constructor === Date ? +v.x : v.x,
              x2 = d.x.constructor === Date ? +d.x : d.x;
          x1 === x2 && (i = j);
        })), i in rowValues && rowValues[i].value * d.value >= 0 && (offset += scale(values[i]) - y0));
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        type = $$.config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(58);

// CONCATENATED MODULE: ./src/shape/arc.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        padding = config.pie_padding,
        padAngle = $$.hasType("pie") && padding ? padding * .01 : config["".concat(config.data_type, "_padAngle")] ? config["".concat(config.data_type, "_padAngle")] : 0;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().padAngle(padAngle).sortValues($$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width;
    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2, $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6;
    var innerRadius = radius || (padding ? padding * ($$.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    $$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        radius = $$.innerRadius;
    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded(), $$.svgArcExpandedSub = $$.getSvgArcExpanded(.98);
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
          gStart = config.gauge_startingAngle,
          gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = $$.pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    return pie($$.filterTargetsToShow()).forEach(function (t) {
      found || t.data.id !== d.data.id || (found = !0, d = t);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        ir = $$.getInnerRadius(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radius).innerRadius(isNumber(ir) ? ir : 0),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radiusExpanded * (rate || 1));
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? arc.innerRadius($$.getInnerRadius(d))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        updated = $$.updateAngle(d),
        translate = "";

    if (updated && (!$$.hasType("gauge") || $$.hasMultiTargets())) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, $$.radius, h) : ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(".concat(x * ratio, ",").concat(y * ratio, ")");
    }

    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : null,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          hasGauge = $$.hasType("gauge"),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this; // MEMO: avoid to cancel transition

    if ($$.transiting) {
      var interval = setInterval(function () {
        $$.transiting || (clearInterval(interval), $$.legend.selectAll(".".concat(config_classes.legendItemFocused)).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).each(function (d) {
      if ($$.shouldExpand(d.data.id) && d.value !== 0) {
        var expandDuration = $$.expandDuration(d.data.id);
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", $$.svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this;

    if (!$$.transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).selectAll("path").transition().duration(function (d) {
        return $$.expandDuration(d.data.id);
      }).attr("d", $$.svgArc), $$.svg.selectAll("".concat(config_classes.arc)).style("opacity", "1");
    }
  },
  expandDuration: function expandDuration(id) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config["".concat(type, "_expand_duration")] : 50;
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config["".concat(v, "_label_show")];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config["".concat(type, "_title")] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select(".".concat(config_classes.chartArcs)).selectAll(".".concat(config_classes.chartArc)).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this;
    $$.arcs = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arc)).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      $$.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      $$.transiting = !1;
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        isTouch = $$.inputType === "touch",
        isMouse = $$.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!$$.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        text = main.selectAll(".".concat(config_classes.chartArc)).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && !$$.hasMultiTargets() ? "".concat(Math.round($$.radius / 5), "px") : "";
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    });

    if (main.select(".".concat(config_classes.chartArcsTitle)).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          endAngle = (isFullCircle ? -4 : -1) * config.gauge_startingAngle;
      isFullCircle && text.attr("dy", "".concat(Math.round($$.radius / 14))), $$.arcs.select(".".concat(config_classes.chartArcsBackground)).attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: config.gauge_startingAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      }), $$.arcs.select(".".concat(config_classes.chartArcsGaugeUnit)).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select(".".concat(config_classes.chartArcsGaugeMin)).attr("dx", "".concat(-1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)), "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && $$.arcs.select(".".concat(config_classes.chartArcsGaugeMax)).attr("dx", "".concat($$.innerRadius + ($$.radius - $$.innerRadius) / 2, "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append("path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/shape/bar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  initBar: function initBar() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.main.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $$.mainBar = $$.main.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($$.mainBar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    return [(withTransition ? this.mainBar.transition(getRandom()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        tickInterval = axis.tickInterval($$.getMaxDataCount()),
        isGrouped = config.data_groups.length,
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.bar).concat(suffix));
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a".concat(radius, ",").concat(radius, " ").concat(isNegative ? "1 0 0" : "0 0 1", " ");
        pathRadius[+!isRotated] = "".concat(arc).concat(radius, ",").concat(radius), pathRadius[+isRotated] = "".concat(arc).concat([-radius, radius][isRotated ? "sort" : "reverse"]()), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H".concat(points[1][indexX] - radius, " ").concat(pathRadius[0], "V").concat(points[2][indexY] - radius, " ").concat(pathRadius[1], "H").concat(points[3][indexX]) : "V".concat(points[1][indexY] + (isNegative ? -radius : radius), " ").concat(pathRadius[0], "H").concat(points[2][indexX] - radius, " ").concat(pathRadius[1], "V").concat(points[3][indexY]);
      return "M".concat(points[0][indexX], ",").concat(points[0][indexY]).concat(path, "z");
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        axis = isSub ? $$.subXAxis : $$.xAxis,
        barTargetsNum = barIndices.__max__ + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list2 = slicedToArray_default()(list, 2),
        seg0 = _list2[0],
        seg1 = _list2[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/shape/bubble.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        cacheKey = "$baseLength",
        baseLength = $$.getCache(cacheKey);
    return baseLength || $$.addCache(cacheKey, baseLength = getMinMax("min", [$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {Object|Array} d data value
   * @param {String} type - y or z
   * @return {Number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {Object|array} d data value
   * @return {Boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// CONCATENATED MODULE: ./src/shape/line.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  initLine: function initLine() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = $$.main.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      $$.main.selectAll(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(t.id))).selectAll("".concat(config_classes.selectedCircle)).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this;
    $$.mainLine = $$.main.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function (d) {
      return "".concat($$.classLine.bind($$)(d), " ").concat($$.extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    return [(withTransition ? this.mainLine.transition(getRandom()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? $$.subX : $$.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        lineTargetsNum = lineIndices.__max__ + 1,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineTargetsNum, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M".concat(points[0][0], ",").concat(points[0][1], "L").concat(points[1][0], ",").concat(points[1][1]);
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "M";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          style = isWithinRegions(data.x, regions);
      // Draw as normal
      if (isUndefined(regions) || !style) path += "".concat(_i ? "L" : "").concat(xValue(data), ",").concat(yValue(data));else {
        try {
          style = style.dasharray.split(" ");
        } catch (e) {
          style = dasharray.split(" ");
        } // Draw with region // TODO: Fix for horizotal charts


        xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
        var dx = x(data.x) - x(prevData.x),
            dy = y(data.value) - y(prevData.value),
            dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        diff = style[0] / dd, diffx2 = diff * style[1];

        for (var j = diff; j <= 1; j += diffx2) path += sWithRegion(prevData, data, j, diff), j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
      }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this;
    $$.data.targets.forEach(function (d) {
      var id = "".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id));

      if ($$.isAreaType(d) && $$.defs.select("#".concat(id)).empty()) {
        var color = $$.color(d),
            _$$$config$area_linea = $$.config.area_linearGradient,
            _$$$config$area_linea2 = _$$$config$area_linea.x,
            x = _$$$config$area_linea2 === void 0 ? [0, 0] : _$$$config$area_linea2,
            _$$$config$area_linea3 = _$$$config$area_linea.y,
            y = _$$$config$area_linea3 === void 0 ? [0, 1] : _$$$config$area_linea3,
            _$$$config$area_linea4 = _$$$config$area_linea.stops,
            stops = _$$$config$area_linea4 === void 0 ? [[0, color, 1], [1, color, 0]] : _$$$config$area_linea4,
            linearGradient = $$.defs.append("linearGradient").attr("id", "".concat(id)).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id), ")") : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this;
    $$.config.area_linearGradient && $$.updateAreaGradient(), $$.mainArea = $$.main.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this;
    return [(withTransition ? $$.mainArea.transition(getRandom()) : $$.mainArea).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        areaTargetsNum = areaIndices.__max__ + 1,
        x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  updateCircle: function updateCircle() {
    var $$ = this;

    if ($$.config.point_show) {
      $$.mainCircle = $$.main.selectAll(".".concat(config_classes.circles)).selectAll(".".concat(config_classes.circle)).data(function (d) {
        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
      }), $$.mainCircle.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      $$.mainCircle = $$.mainCircle.enter().append(fn).merge($$.mainCircle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.main.selectAll(".".concat(config_classes.selectedCircle));
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.mainCircle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr("".concat(posAttr, "x"), cx).attr("".concat(posAttr, "y"), cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this;

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? $$.generateGetLinePoints($$.getShapeIndices($$.isLineType))(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.circles).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.circle).concat(suffix));
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(".concat(x, " ").concat(y, ") scale(").concat(scale, ")"));
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(".concat(r(circles) / $$.config.point_r, ")"));
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr("".concat(prefix, "x")),
        cy = +element.attr("".concat(prefix, "y"));

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    var is = Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
    return is;
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/shape/point.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser["document"].createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.defs.select("#".concat(id));
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        pointClass = !1;
    return (isObject(d) || $$.mainCircle) && (pointClass = d === !0 ? $$.mainCircle.attr("class", $$.classCircle.bind($$)) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = "".concat($$.datetimeId, "-point-").concat(id),
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#".concat(id)).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/shape/radar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
extend(ChartInternal_ChartInternal.prototype, {
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min($$.arcWidth, $$.arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        _$$$getRadarSize2 = slicedToArray_default()(_$$$getRadarSize, 2),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize3 = $$.getRadarSize(),
        _$$$getRadarSize4 = slicedToArray_default()(_$$$getRadarSize3, 2),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        points = $$.getCache(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.addCache(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(duration, durationForExit) {
    var $$ = this,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), $$.main.selectAll(".".concat(config_classes.circles)).attr("transform", translate), $$.main.select(".".concat(config_classes.chartTexts)).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(duration, durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var $$ = this,
        points = $$.getCache(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize5 = $$.getRadarSize(),
        _$$$getRadarSize6 = slicedToArray_default()(_$$$getRadarSize5, 2),
        width = _$$$getRadarSize6[0],
        height = _$$$getRadarSize6[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll(".".concat(config_classes.level)).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.level, " ").concat(config_classes.level, "-").concat(i);
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(".concat(width - levelRatio[d], ", ").concat(height - levelRatio[d], ")");
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize7 = $$.getRadarSize(),
        _$$$getRadarSize8 = slicedToArray_default()(_$$$getRadarSize7, 2),
        width = _$$$getRadarSize8[0],
        height = _$$$getRadarSize8[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.axis, "-").concat(i);
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(".concat(posX, " ").concat(posY, ")");
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config;

    if (config.interaction_enabled) {
      var isMouse = $$.inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select(".".concat(config_classes.axis)).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!$$.transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle($$.svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || $$.svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(duration, durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.getCache(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).transition().duration(duration).style("fill", function (d) {
      return $$.color(d);
    }).style("stroke", function (d) {
      return $$.color(d);
    }).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/internals/text.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartTexts), $$.mainText = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.main.select(".".concat(config_classes.chartTexts)).selectAll(".".concat(config_classes.chartText)).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $$.mainText = $$.main.selectAll(".".concat(config_classes.texts)).selectAll(".".concat(config_classes.text)).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").merge($$.mainText).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [this.mainText.each(function () {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x).attr("y", y).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$".concat(text.replace(/\W/g, "_")),
        rect = $$.getCache(cacheKey);
    return rect || ($$.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.addCache(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet".concat(capitalize(v), "Points")](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > $$.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = $$.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + (config.data_labels_position.x || 0);
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !$$.hasPositiveValue && $$.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + (config.data_labels_position.y || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/type.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // defined chart types as category

var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
extend(ChartInternal_ChartInternal.prototype, {
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      $$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        types = $$.config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = $$.config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets) {
    var _this = this,
        exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    return !TYPES[type].filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/internals/grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

extend(ChartInternal_ChartInternal.prototype, {
  initGrid: function initGrid() {
    var $$ = this;
    $$.xgrid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]), $$.initGridLines(), $$.initXYFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.main.insert("g", ".".concat(config_classes.chart).concat(config.grid_lines_front ? " + *" : "")).attr("clip-path", $$.clipPathForGrid).attr("class", "".concat(config_classes.grid, " ").concat(config_classes.gridLines)), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), $$.xgridLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, $$.x),
        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0,
        pos = function (d) {
      return (($$.zoomScale || $$.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    $$.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": $$.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": $$.height
    }, $$.xgrid = $$.main.select(".".concat(config_classes.xgrids)).selectAll(".".concat(config_classes.xgrid)).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", config_classes.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys($$.xgridAttr).forEach(function (id) {
        grid.attr(id, $$.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? $$.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.y(d));
    };

    $$.ygrid = $$.main.select(".".concat(config_classes.ygrids)).selectAll(".".concat(config_classes.ygrid)).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", config_classes.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : $$.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? $$.height : pos), $$.smoothLines($$.ygrid, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this;
    // hide if arc type
    $$.gridLines || $$.initGridLines(), $$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden"), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select(".".concat(config_classes.xgridLines)).selectAll(".".concat(config_classes.xgridLine)).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = $$.xgridLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), $$.xgridLines.attr("class", function (d) {
      return "".concat(config_classes.xgridLine, " ").concat(d["class"] || "").trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select(".".concat(config_classes.ygridLines)).selectAll(".".concat(config_classes.ygridLine)).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = $$.ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);
    // update
    var yv = $$.yv.bind($$);
    $$.ygridLines.attr("class", function (d) {
      return "".concat(config_classes.ygridLine, " ").concat(d["class"] || "").trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : $$.width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, $$.width, $$.height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xv = $$.xv.bind($$),
        lines = $$.xgridLines.select("line"),
        texts = $$.xgridLines.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, $$.width, $$.height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initXYFocusGrid: function initXYFocusGrid() {
    var $$ = this,
        config = $$.config,
        isFront = config.grid_front,
        className = ".".concat(config_classes[isFront && $$.gridLines ? "gridLines" : "chart"]).concat(isFront ? " + *" : "");
    $$.grid = $$.main.insert("g", className).attr("clip-path", $$.clipPathForGrid).attr("class", config_classes.grid), config.grid_x_show && $$.grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && $$.grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus);
  },
  showXGridFocus: function showXGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        focusEl = $$.main.selectAll("line.".concat(config_classes.xgridFocus)),
        xx = $$.xx.bind($$);
    !config.tooltip_show || $$.hasType("bubble") || $$.hasType("scatter") || $$.hasArcType() || (focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(isRotated ? "y1" : "x1", xx).attr(isRotated ? "y2" : "x2", xx), $$.smoothLines(focusEl, "grid")); // Hide when bubble/scatter/stanford plot exists
  },
  hideXGridFocus: function hideXGridFocus() {
    this.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden");
  },
  updateXgridFocus: function updateXgridFocus() {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    $$.main.select("line.".concat(config_classes.xgridFocus)).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? $$.width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : $$.height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.main.select(".".concat(config_classes.axisX)).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date("".concat(i, "-01-01 00:00:00")));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line["class"] === param["class"]) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.main.select(".".concat(classLines)).selectAll(".".concat(classLine)).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_".concat(forX ? "x" : "y", "_lines");
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/tooltip.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($$.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $$.tooltip.empty() && ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $$.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$ = $$).getTooltipContent.apply(_$$, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return "".concat((ratio * 100).toFixed(2), "%");
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">".concat(title, "</th></tr>") : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(toConsumableArray_default()(param)))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(toConsumableArray_default()(param))));
        }),
            _map2 = slicedToArray_default()(_map, 2),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> ".concat(value, " <b>High:</b> ").concat(high, " <b>Low:</b> ").concat(low);
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(toConsumableArray_default()(param)))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:".concat(color, "\" width=\"10\" height=\"10\"></rect></svg>"),
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return "".concat(text, "</table>");
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">".concat(this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>", "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>")).replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        _d3Mouse2 = slicedToArray_default()(_d3Mouse, 2),
        left = _d3Mouse2[0],
        top = _d3Mouse2[1],
        svgLeft = $$.getSvgLeft(!0),
        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = $$.inputType === "touch" || $$.hasType("radar");
      raw || (top += $$.height / 2, left += ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = $$.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + ($$.zoomScale ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > $$.currentHeight && (top -= tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        positionFunction = config.tooltip_position || $$.tooltipPosition;

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = $$.tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          width = datum && datum.width || 0,
          height = datum && datum.height || 0;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$), $$.tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = $$.tooltip.property("offsetWidth"),
          height: height = $$.tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        // Get tooltip dimensions
        var position = positionFunction.call(this, dataToShow, width, height, element); // Set tooltip position

        $$.tooltip.style("top", "".concat(position.top, "px")).style("left", "".concat(position.left, "px"));
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config;
    (!config.tooltip_doNotHide || force) && (callFn(config.tooltip_onhide, $$), this.tooltip.style("display", "none").style("visibility", "hidden") // for IE9
    .datum(null), callFn(config.tooltip_onhidden, $$));
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this;

    if ($$.config.tooltip_linked) {
      var linkedName = $$.config.tooltip_linked_name;
      ($$.api.internal.charts || []).forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser["document"].body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/internals/legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config;
    $$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !$$.zoomScale), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $$.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.margin3 = {
      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - height,
      right: NaN,
      bottom: 0,
      left: $$.isLegendRight ? $$.currentWidth - width : $$.isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this;
    (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.legendItemHeight = h;
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight ? $$.currentHeight : Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.legend.selectAll(".".concat(config_classes.legendItem)).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Clear the LegendItemTextBox cache.
   * @private
   */
  clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
    this.legendItemTextBox = {};
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        isTouch = $$.inputType === "touch";
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        getTextBox = function (textElement, id) {
      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
    },
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = getTextBox(textElement, id),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    $$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : $$.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = $$.legend.selectAll(".".concat(config_classes.legendItem)).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = $$.config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser["document"].createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#".concat($$.datetimeId, "-point-").concat(data) : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = $$.legend.select(".".concat(config_classes.legendBackground, " rect")), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", ".".concat(config_classes.legendItem)).attr("class", config_classes.legendBackground).append("rect"));
    var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = $$.legend.selectAll("rect.".concat(config_classes.legendItemEvent)).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = $$.legend.selectAll(".".concat(config_classes.legendItemPoint)).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = $$.config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = $$.legend.selectAll("line.".concat(config_classes.legendItemTile)).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/internals/title.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

var getTextPos = function () {
  var position,
      pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "left",
      width = arguments.length > 1 ? arguments[1] : undefined,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
};

extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this;

    if ($$.config.title_text) {
      $$.title = $$.svg.append("g");
      var text = $$.title.append("text").style("text-anchor", getTextPos($$.config.title_position)).attr("class", config_classes.title);
      setTextValue(text, $$.config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this;

    if ($$.title) {
      var y = $$.yForTitle.call($$);
      /g/i.test($$.title.node().tagName) ? $$.title.attr("transform", "translate(".concat(getTextPos($$.config.title_position, $$.currentWidth), ", ").concat(y, ")")) : $$.title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        position = config.title_position || "left";
    return /(right|center)/.test(position) ? (x = $$.currentWidth - $$.getTextRect($$.title, config_classes.title).width, position.indexOf("right") >= 0 ? x -= config.title_padding.right || 0 : position.indexOf("center") >= 0 && (x /= 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/clip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  initClip: function initClip() {
    var $$ = this; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist

    // Define 'clip-path' attribute values
    $$.clipId = "".concat($$.datetimeId, "-clip"), $$.clipIdForXAxis = "".concat($$.clipId, "-xaxis"), $$.clipIdForYAxis = "".concat($$.clipId, "-yaxis"), $$.clipIdForGrid = "".concat($$.clipId, "-grid"), $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!browser["window"].navigator && browser["window"].navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(".concat(isIE9 ? "" : browser["document"].URL.split("#")[0], "#").concat(id, ")");
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    // axis line width + padding for left
    var left = Math.max(30, this.margin.left);
    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    return forHorizontal ? -20 : -this.margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        left = Math.max(30, $$.margin.left),
        right = Math.max(30, $$.margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    // less than 20 is not enough to show the axis label 'outer' without legend
    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/internals/region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection




extend(ChartInternal_ChartInternal.prototype, {
  initRegion: function initRegion() {
    var $$ = this;
    $$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config;
    // hide if arc type
    // select <g> element
    $$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select(".".concat(config_classes.regions)).selectAll(".".concat(config_classes.region)).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.mainRegion.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], pos = scale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, pos = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = $$[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], end = scale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, end = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// CONCATENATED MODULE: ./src/interactions/drag.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        main = $$.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _$$$dragStart = slicedToArray_default()($$.dragStart, 2),
            sx = _$$$dragStart[0],
            sy = _$$$dragStart[1],
            _mouse = slicedToArray_default()(mouse, 2),
            mx = _mouse[0],
            my = _mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

        main.select(".".concat(config_classes.dragarea)).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = shape.attr("cx") * 1,
                y = shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return;

          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select(".".concat(config_classes.chart)).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.main.select(".".concat(config_classes.dragarea)).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll(".".concat(config_classes.shape)).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(59);

// CONCATENATED MODULE: ./src/internals/selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this;
    // remove selected-circle from low layer g
    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = "".concat(selected ? "" : "un", "selectPoint");
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this["".concat(selected ? "" : "un", "selectPath")](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = ".".concat(config_classes.shapes);
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll(selector).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/interactions/subchart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = $$.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map($$.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && $$.context && $$.context.select(".".concat(config_classes.brush)).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return $$.context ? $$.context.select(".".concat(config_classes.brush)) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([]);
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = "".concat($$.clipId, "-subchart"),
        clipPath = $$.getClipPath(clipId);
    $$.clipIdForSubchart = clipId, $$.appendClip($$.defs, clipId), $$.initBrush(), $$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));
    var context = $$.context;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars), context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        context = $$.context,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var contextBarUpdate = context.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", classChartBar),
          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
      contextBarEnter.append("g").attr("class", classBars);
      // -- Line --//
      var contextLineUpdate = context.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", classChartLine),
          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll(".".concat(config_classes.brush, " rect")).attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this;
    $$.contextBar = $$.context.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this;
    $$.contextLine = $$.context.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this;
    $$.contextArea = $$.context.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.contextArea).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config;
    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw".concat(name)](shape.indices[v], !0);
      $$["update".concat(name, "ForSubchart")](duration), $$["redraw".concat(name, "ForSubchart")](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this;
    $$.redraw({
      withTransition: !1,
      withY: $$.config.zoom_rescale,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), $$.config.subchart_onbrush.call($$.api, $$.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select(".".concat(config_classes.axisX)), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        extent = $$.config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), $$.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return $$.subX($$.parseDate(v));
    }))), extent;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(60);

// CONCATENATED MODULE: ./src/interactions/zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.zoomScale = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent() {
    var bind = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0],
        $$ = this,
        zoomEnabled = $$.config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = $$.main.select(".".concat(config_classes.eventRects));
    zoomEnabled && bind ? $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      $$.orgXScale && $$.orgXScale.range($$.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"]($$.orgXScale || $$.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, $$.orgXDomain), $$.zoomScale = $$.getCustomizedScale(newScale), $$.xAxis.scale($$.zoomScale), rescale && (!$$.orgXScale && ($$.orgXScale = $$.x.copy()), $$.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && ($$.zoomScale || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && $$.x.domain().every(function (v, i) {
        return v !== $$.orgXDomain[i];
      }) && $$.x.domain($$.orgXDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && $$.x.orgDomain()[0] === $$.orgXDomain[0] && $$.x.domain([$$.orgXDomain[0] - 1e-10, $$.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, $$.zoomScale.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn($$.config.zoom_onzoomend, $$.api, $$[$$.zoomScale ? "zoomScale" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        _$$$orgXDomain = slicedToArray_default()($$.orgXDomain, 2),
        min = _$$$orgXDomain[0],
        max = _$$$orgXDomain[1];

    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this;

    if ($$.zoomScale) {
      var zoomDomain = $$.zoomScale.domain(),
          xDomain = $$.subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.xAxis.scale($$.subX), $$.x.domain($$.subX.orgDomain()), $$.zoomScale = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        zoomRect = null,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.main.append("rect").attr("clip-path", $$.clipPath).attr("class", config_classes.zoomBrush).attr("width", isRotated ? $$.width : 0).attr("height", isRotated ? 0 : $$.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.zoomScale || $$.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
            _ref3 = slicedToArray_default()(_ref2, 2),
            x = _ref3[0],
            y = _ref3[1],
            target = browser["document"].elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.selectChart.append("div").classed(config_classes.button, !0).append("span").on("click", $$.api.unzoom.bind($$)).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/internals/color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser["document"].body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser["document"].createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = browser["window"].getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = "".concat($$.datetimeId, "-pattern-").concat(color, "-").concat(index);
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#".concat(p.id, ")");
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restore in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? $$.main.selectAll(".".concat(config_classes.arc, "-").concat(d.id)).style("fill", color(d)) : $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/internals/format.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



var getFormat = function ($$, typeValue, v) {
  var config = $$.config,
      type = "axis_".concat(typeValue, "_tick_format"),
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
};

extend(ChartInternal_ChartInternal.prototype, {
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        formatForY = $$.yFormat,
        formatForY2 = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return "".concat((ratio * 100).toFixed(1), "%");
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/internals/cache.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  addCache: function addCache(key, value) {
    var isDataType = !!(arguments.length > 2 && arguments[2] !== undefined) && arguments[2];
    this.cache[key] = isDataType ? this.cloneTarget(value) : value;
  },

  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  removeCache: function removeCache(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  },

  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  getCache: function getCache(key) {
    var isDataType = !!(arguments.length > 1 && arguments[1] !== undefined) && arguments[1];

    if (isDataType) {
      var targets = [];

      for (var id, i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  },

  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  resetCache: function resetCache(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
});
// CONCATENATED MODULE: ./src/internals/class.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  generateClass: function generateClass(prefix, targetId) {
    return " ".concat(prefix, " ").concat(prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return "".concat(this.generateClass(config_classes.region, i), " ").concat("class" in d ? d["class"] : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " ".concat(config_classes.target, "-").concat(additionalClassSuffix)), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " ".concat(this.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " ".concat(this.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? "-".concat(targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return "".concat(prefix || "", ".").concat(config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return ".".concat(config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/api/api.focus.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && $$.expandArc(targetIds), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && $$.unexpandArc(targetIds), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), $$.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/api/api.show.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Show/Hide data series
   * @private
   */
  _showHide: function _showHide(show, targetIdsValue, options) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue);
    $$["".concat(show ? "remove" : "add", "HiddenTargetIds")](targetIds);
    var targets = $$.svg.selectAll($$.selectorTargets(targetIds)),
        opacity = show ? "1" : "0";
    targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
      targets.style("opacity", null).style("opacity", opacity);
    }), options.withLegend && $$["".concat(show ? "show" : "hide", "Legend")](targetIds), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    });
  },

  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds) {
    var _this = this,
        options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };

    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/api/api.zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

var withinRange = function (domain, range) {
  var _range = slicedToArray_default()(range, 2),
      min = _range[0],
      max = _range[1];

  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
},
    api_zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      domain = domainValue;

  if ($$.config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), $$.config.subchart_show) {
      var xScale = $$.zoomScale || $$.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else $$.x.domain(domain), $$.zoomScale = $$.x, $$.xAxis.scale($$.zoomScale), resultDomain = $$.zoomScale.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: $$.config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn($$.config.zoom_onzoom, resultDomain);
  } else resultDomain = $$.zoomScale ? $$.zoomScale.domain() : $$.x.orgDomain();

  return resultDomain;
};
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


extend(api_zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoomenable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "wheel",
        $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoommax
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [$$.orgXDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoommin
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [$$.orgXDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoomrange
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range2) {
    var zoom = this.zoom;

    if (isObject(_range2)) {
      var min = _range2.min,
          max = _range2.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
}), extend(Chart_Chart.prototype, {
  zoom: api_zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.zoomScale) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.main.select(".".concat(config_classes.eventRects));
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/api/api.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [dataheaders](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [datakeys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [datamimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.removeCache(ids), args.done && args.done();
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(61);

// CONCATENATED MODULE: ./src/api/api.flow.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(Chart_Chart.prototype, {
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [datajson](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [datarows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [datacolumns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
}), extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $$.xgrid || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          xgridLines = $$.xgridLines || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainRegion = $$.mainRegion || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainText = $$.mainText || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainBar = $$.mainBar || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainLine = $$.mainLine || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainArea = $$.mainArea || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainCircle = $$.mainCircle || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);

      $$.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(".concat(translateX, ",0) scale(").concat(scaleX, ",1)");
      $$.hideXGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.axes.x.transition(gt).call(function (g) {
        return $$.xAxis.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var isRotated = config.axis_rotated; // remove flowed elements

        if (flowLength) {
          for (var target = {
            shapes: [],
            texts: [],
            eventRects: []
          }, i = 0; i < flowLength; i++) target.shapes.push(".".concat(config_classes.shape, "-").concat(i)), target.texts.push(".".concat(config_classes.text, "-").concat(i)), target.eventRects.push(".".concat(config_classes.eventRect, "-").concat(i));

          ["shapes", "texts", "eventRects"].forEach(function (v) {
            $$.svg.selectAll(".".concat(config_classes[v])).selectAll(target[v]).remove();
          }), $$.svg.select(".".concat(config_classes.xgrid)).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv), xgridLines.select("text").attr("x", isRotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
      });
    };
  }
});
// CONCATENATED MODULE: ./src/api/api.selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.main.selectAll(".".concat(config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll(".".concat(config_classes.shape)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/api/api.transform.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Change the type of the chart.
 * @private
 * @param {String|Array} targetIds
 * @param {String} type
 * @param {Object} optionsForRedraw
 */

function transformTo(targetIds, type, optionsForRedraw) {
  var $$ = this,
      options = optionsForRedraw || {
    withTransitionForAxis: !$$.hasArcType()
  };
  // this is needed when transforming to arc
  options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
}

extend(Chart_Chart.prototype, {
  /**
   * Change the type of the chart.
   * @method transform
   * @instance
   * @memberof Chart
   * @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
   * @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
   * @example
   *  // all targets will be bar chart.
   *  chart.transform("bar");
   *
   *  // only data1 will be bar chart.
   *  chart.transform("bar", "data1");
   *
   *  // only data1 and data2 will be bar chart.
   *  chart.transform("bar", ["data1", "data2"]);
   */
  transform: function transform(type, targetIds) {
    var $$ = this.internal,
        options = ["pie", "donut"].indexOf(type) >= 0 ? {
      withTransform: !0
    } : null;
    transformTo.bind($$)(targetIds, type, options);
  }
});
// CONCATENATED MODULE: ./src/api/api.group.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/api/api.grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

var xgrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
};

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */
var ygrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
};

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
}), extend(Chart_Chart.prototype, {
  xgrids: xgrids,
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/api/api.region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

var api_region_regions = function (_regions) {
  var $$ = this.internal,
      config = $$.config;
  return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), _regions) : config.regions;
};

extend(api_region_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regionsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regionsremove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.main.select(".".concat(config_classes.regions)).selectAll(classes.map(function (c) {
      return ".".concat(c);
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region["class"] || (region["class"].split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
}), extend(Chart_Chart.prototype, {
  regions: api_region_regions
});
// CONCATENATED MODULE: ./src/api/api.data.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

var api_data_data = function (targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
};

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method datashown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method datavalues
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId) {
    var flat = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        values = null;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method datanames
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method datacolors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * @method dataaxes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method datamin
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method datamax
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
}), extend(Chart_Chart.prototype, {
  data: api_data_data
});
// CONCATENATED MODULE: ./src/api/api.category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/api/api.color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/api/api.x.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? $$.api.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? $$.api.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// CONCATENATED MODULE: ./src/api/api.axis.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

var setMinMax = function ($$, type, value) {
  var config = $$.config,
      axisX = "axis_x_".concat(type),
      axisY = "axis_y_".concat(type),
      axisY2 = "axis_y2_".concat(type);
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config[axisX] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
},
    api_axis_getMinMax = function ($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_".concat(type)],
    y: config["axis_y_".concat(type)],
    y2: config["axis_y2_".concat(type)]
  };
},
    api_axis_axis = extend(function () {}, {
  /**
   * Get and set axis labels.
   * @method axislabels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axismin
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "min", _min) : api_axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axismax
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : api_axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axisrange
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
});
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


extend(Chart_Chart.prototype, {
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/api/api.legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define legend
 * @ignore
 */

var legend = extend(function () {}, {
  /**
   * Show legend for each target.
   * @method legendshow
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legendhide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
});
extend(Chart_Chart.prototype, {
  legend: legend
});
// CONCATENATED MODULE: ./src/api/api.chart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(Chart_Chart.prototype, {
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @param {Boolean} [isFromResize] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, isFromResize) {
    var $$ = this.internal;
    $$.rendered ? (isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.zoomScale = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $$.svg.select("*").interrupt(), isDefined($$.resizeTimeout) && browser["window"].clearTimeout($$.resizeTimeout), browser["window"].removeEventListener("resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function config(name, value, redraw) {
    var res,
        $$ = this.internal,
        key = name && name.replace(/\./g, "_");
    return key in $$.config && (isDefined(value) ? ($$.config[key] = value, res = value, redraw && this.flush()) : res = $$.config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/api/api.tooltip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define tooltip
 * @ignore
 */

var tooltip = extend(function () {}, {
  /**
   * Show tooltip
   * @method tooltipshow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted x Axis element.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: Axis id. 'y' or 'y2'(default 'y')<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate relative the x Axis element.
   *  chart.tooltip.show({
   *    data: {x: 2},
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show() {
    var index,
        mouse,
        args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        $$ = this.internal;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.x(args.data.x), y] : (!$$.config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    ($$.inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltiphide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideXGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
});
extend(Chart_Chart.prototype, {
  tooltip: tooltip
});
// CONCATENATED MODULE: ./src/api/api.export.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode("0x".concat(p));
  }));
},
    nodeToSvgDataUrl = function (node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser["document"].styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser["document"].createElement("style"); // escape css for XML

  style.appendChild(browser["document"].createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = "<svg xmlns=\"".concat(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, "\" width=\"").concat(size.width, "\" height=\"").concat(size.height, "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t").concat(styleXml, "\n\t\t\t\t").concat(nodeXml.replace(/(url\()[^#]+/g, "$1"), "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64,".concat(b64EncodeUnicode(dataStr));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @return {String}
 * @private
 */


extend(Chart_Chart.prototype, {
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  "export": function _export(mimeType, callback) {
    var $$ = this.internal,
        size = {
      width: $$.currentWidth,
      height: $$.currentHeight
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (isFunction(callback)) {
      var img = new Image();
      img.crosssOrigin = "Anonymous", img.onload = function () {
        var canvas = browser["document"].createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/core.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */























































var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "1.10.2",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {},

  /**
   * Internal chart object
   * @private
   */
  chart: {
    fn: Chart_Chart.prototype,
    internal: {
      fn: ChartInternal_ChartInternal.prototype,
      axis: {
        fn: Axis_Axis.prototype
      }
    }
  }
};
/**
 * @namespace bb
 * @version 1.10.2
 */


/* harmony default export */ var core = __webpack_exports__["default"] = (bb);

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1NvY2tKU0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9CYXNlQ2xpZW50LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz9hNmRlIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2JpbGxib2FyZC5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdGltZS1mb3JtYXRcIixcImNvbW1vbmpzMlwiOlwiZDMtdGltZS1mb3JtYXRcIixcImFtZFwiOlwiZDMtdGltZS1mb3JtYXRcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2VsZWN0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXNlbGVjdGlvblwiLFwiYW1kXCI6XCJkMy1zZWxlY3Rpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdHJhbnNpdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJhbWRcIjpcImQzLXRyYW5zaXRpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYXhpc1wiLFwiY29tbW9uanMyXCI6XCJkMy1heGlzXCIsXCJhbWRcIjpcImQzLWF4aXNcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1icnVzaFwiLFwiY29tbW9uanMyXCI6XCJkMy1icnVzaFwiLFwiYW1kXCI6XCJkMy1icnVzaFwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9icm93c2VyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2NhbGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2NhbGVcIixcImFtZFwiOlwiZDMtc2NhbGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHN2XCIsXCJjb21tb25qczJcIjpcImQzLWRzdlwiLFwiYW1kXCI6XCJkMy1kc3ZcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHJhZ1wiLFwiY29tbW9uanMyXCI6XCJkMy1kcmFnXCIsXCJhbWRcIjpcImQzLWRyYWdcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2hhcGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2hhcGVcIixcImFtZFwiOlwiZDMtc2hhcGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtaW50ZXJwb2xhdGVcIixcImNvbW1vbmpzMlwiOlwiZDMtaW50ZXJwb2xhdGVcIixcImFtZFwiOlwiZDMtaW50ZXJwb2xhdGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtY29sb3JcIixcImNvbW1vbmpzMlwiOlwiZDMtY29sb3JcIixcImFtZFwiOlwiZDMtY29sb3JcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtem9vbVwiLFwiY29tbW9uanMyXCI6XCJkMy16b29tXCIsXCJhbWRcIjpcImQzLXpvb21cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZWFzZVwiLFwiY29tbW9uanMyXCI6XCJkMy1lYXNlXCIsXCJhbWRcIjpcImQzLWVhc2VcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY2xhc3Nlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F4aXMvQXhpc1JlbmRlcmVySGVscGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9heGlzL0F4aXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXhpcy9BeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL0NoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3NjYWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvZG9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZGF0YS5jb252ZXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2RhdGEubG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2NhdGVnb3J5LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9zaXplLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9zaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvYXJjLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9iYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL2J1YmJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL3JhZGFyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9ncmlkLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3RpdGxlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3JlZ2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJhY3Rpb25zL2RyYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVyYWN0aW9ucy9zdWJjaGFydC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJhY3Rpb25zL3pvb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2NhY2hlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuc2hvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS56b29tLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkudHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmdyb3VwLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmdyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkucmVnaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuY2F0ZWdvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkueC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5heGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmxlZ2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5jaGFydC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS50b29sdGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmV4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS5qcyJdLCJuYW1lcyI6WyJ3aW4iLCJkZWYiLCJvIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsImRvYyIsImRvY3VtZW50IiwiYXJjIiwiYXJjcyIsImFyZWEiLCJhcmVhcyIsImF4aXMiLCJheGlzWCIsImF4aXNYTGFiZWwiLCJheGlzWSIsImF4aXNZMiIsImF4aXNZMkxhYmVsIiwiYXhpc1lMYWJlbCIsImJhciIsImJhcnMiLCJicnVzaCIsImJ1dHRvbiIsImJ1dHRvblpvb21SZXNldCIsImNoYXJ0IiwiY2hhcnRBcmMiLCJjaGFydEFyY3MiLCJjaGFydEFyY3NCYWNrZ3JvdW5kIiwiY2hhcnRBcmNzR2F1Z2VNYXgiLCJjaGFydEFyY3NHYXVnZU1pbiIsImNoYXJ0QXJjc0dhdWdlVW5pdCIsImNoYXJ0QXJjc1RpdGxlIiwiY2hhcnRBcmNzR2F1Z2VUaXRsZSIsImNoYXJ0QmFyIiwiY2hhcnRCYXJzIiwiY2hhcnRMaW5lIiwiY2hhcnRMaW5lcyIsImNoYXJ0UmFkYXIiLCJjaGFydFJhZGFycyIsImNoYXJ0VGV4dCIsImNoYXJ0VGV4dHMiLCJjaXJjbGUiLCJjaXJjbGVzIiwiY29sb3JQYXR0ZXJuIiwiY29sb3JTY2FsZSIsImRlZm9jdXNlZCIsImRyYWdhcmVhIiwiZW1wdHkiLCJldmVudFJlY3QiLCJldmVudFJlY3RzIiwiZXZlbnRSZWN0c011bHRpcGxlIiwiZXZlbnRSZWN0c1NpbmdsZSIsImZvY3VzZWQiLCJnYXVnZVZhbHVlIiwiZ3JpZCIsImdyaWRMaW5lcyIsImxlZ2VuZEJhY2tncm91bmQiLCJsZWdlbmRJdGVtIiwibGVnZW5kSXRlbUV2ZW50IiwibGVnZW5kSXRlbUZvY3VzZWQiLCJsZWdlbmRJdGVtSGlkZGVuIiwibGVnZW5kSXRlbVBvaW50IiwibGVnZW5kSXRlbVRpbGUiLCJsZXZlbCIsImxldmVscyIsImxpbmUiLCJsaW5lcyIsInJlZ2lvbiIsInJlZ2lvbnMiLCJzZWxlY3RlZENpcmNsZSIsInNlbGVjdGVkQ2lyY2xlcyIsInNoYXBlIiwic2hhcGVzIiwic3RhbmZvcmRFbGVtZW50cyIsInN0YW5mb3JkTGluZSIsInN0YW5mb3JkTGluZXMiLCJzdGFuZm9yZFJlZ2lvbiIsInN0YW5mb3JkUmVnaW9ucyIsInRhcmdldCIsInRleHQiLCJ0ZXh0cyIsInRpdGxlIiwidG9vbHRpcCIsInRvb2x0aXBDb250YWluZXIiLCJ0b29sdGlwTmFtZSIsInhncmlkIiwieGdyaWRGb2N1cyIsInhncmlkTGluZSIsInhncmlkTGluZXMiLCJ4Z3JpZHMiLCJ5Z3JpZCIsInlncmlkTGluZSIsInlncmlkTGluZXMiLCJ5Z3JpZHMiLCJ6b29tQnJ1c2giLCJ6b29tUmVjdCIsIkVYUEFOREVEIiwiU0VMRUNURUQiLCJJTkNMVURFRCIsImlzVmFsdWUiLCJ2IiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzRGVmaW5lZCIsImlzQm9vbGVhbiIsImNlaWwxMCIsIk1hdGgiLCJjZWlsIiwiYXNIYWxmUGl4ZWwiLCJuIiwiZGlmZkRvbWFpbiIsImQiLCJpc09iamVjdFR5cGUiLCJpc0VtcHR5IiwibGVuZ3RoIiwiRGF0ZSIsIk9iamVjdCIsImtleXMiLCJpc05hTiIsIm5vdEVtcHR5IiwiaXNBcnJheSIsImFyciIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJpc09iamVjdCIsIm9iaiIsIm5vZGVUeXBlIiwiZ2V0T3B0aW9uIiwib3B0aW9ucyIsImtleSIsImRlZmF1bHRWYWx1ZSIsImhhc1ZhbHVlIiwiZGljdCIsInZhbHVlIiwiZm91bmQiLCJmb3JFYWNoIiwiY2FsbEZuIiwiZm4iLCJpc0ZuIiwiYXJncyIsImNhbGwiLCJzYW5pdGlzZSIsInN0ciIsInJlcGxhY2UiLCJzZXRUZXh0VmFsdWUiLCJub2RlIiwiZHkiLCJ0b01pZGRsZSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJsZW4iLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsInBhdGgiLCJnZXRCQm94IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsImdldFBhdGhCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpdGVtcyIsIm1pbiIsImdldEJydXNoU2VsZWN0aW9uIiwiY3R4Iiwic2VsZWN0aW9uIiwiZXZlbnQiLCJkM0V2ZW50IiwibWFpbiIsImNvbnRleHQiLCJuYW1lIiwic2VsZWN0IiwiQ0xBU1MiLCJkM0JydXNoU2VsZWN0aW9uIiwiZ2V0Qm91bmRpbmdSZWN0IiwicmVjdCIsImdldFJhbmRvbSIsImFzU3RyIiwicmFuZG9tIiwiYnJ1c2hFbXB0eSIsImV4dGVuZCIsInNvdXJjZSIsInAiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInRvQXJyYXkiLCJnZXRDc3NSdWxlcyIsInN0eWxlU2hlZXRzIiwicnVsZXMiLCJzaGVldCIsImNzc1J1bGVzIiwiY29uY2F0IiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImhyZWYiLCJ0b1N0cmluZyIsImdldFVuaXF1ZSIsImRhdGEiLCJpc0RhdGUiLCJOdW1iZXIiLCJmaWx0ZXIiLCJtZXJnZUFycmF5IiwicmVkdWNlIiwiYyIsIm1lcmdlT2JqIiwib2JqZWN0TiIsInNoaWZ0Iiwic29ydFZhbHVlIiwiaXNBc2MiLCJhIiwiYiIsImV2ZXJ5Iiwic29ydCIsImdldE1pbk1heCIsInR5cGUiLCJyZXMiLCJ1bmRlZmluZWQiLCJnZXRSYW5nZSIsInN0YXJ0IiwiZW5kIiwicHVzaCIsImVtdWxhdGVFdmVudCIsIm1vdXNlIiwiZ2V0UGFyYW1zIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwiTW91c2VFdmVudCIsImVsIiwiZXZlbnRUeXBlIiwicGFyYW1zIiwiZGlzcGF0Y2hFdmVudCIsIm1vdXNlRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50IiwidG91Y2giLCJ0b3VjaE9iaiIsIlRvdWNoIiwiaWRlbnRpZmllciIsIm5vdyIsInJhZGl1c1giLCJyYWRpdXNZIiwicm90YXRpb25BbmdsZSIsImZvcmNlIiwiVG91Y2hFdmVudCIsInNoaWZ0S2V5IiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsInRwbFByb2Nlc3MiLCJ0cGwiLCJSZWdFeHAiLCJBeGlzUmVuZGVyZXJIZWxwZXIiLCJjb25maWciLCJzY2FsZSIsImQzU2NhbGVMaW5lYXIiLCJub1RyYW5zaXRpb24iLCJ0cmFuc2l0aW9uX2R1cmF0aW9uIiwid2l0aG91dFRyYW5zaXRpb24iLCJyYW5nZSIsInJhbmdlRXh0ZW50Iiwic2NhbGVFeHRlbnQiLCJvcmdYU2NhbGUiLCJ0aWNrT2Zmc2V0IiwiZG9tYWluIiwic3RvcCIsInRpY2tzIiwidGlja0FyZ3VtZW50cyIsInJvdW5kIiwidW5zaGlmdCIsIm5ld1NjYWxlIiwiY29weSIsInRpY2tGb3JtYXQiLCJ0ZXN0IiwiZm9ybWF0dGVkIiwiaW50ZXJydXB0IiwidHJhbnNpdGlvbiIsInNpemUiLCJ3IiwiaCIsImdldFNpemVGb3IxQ2hhciIsIkF4aXNSZW5kZXJlciIsImlubmVyVGlja1NpemUiLCJvdXRlclRpY2tTaXplIiwib3V0ZXJUaWNrIiwib3JpZW50IiwidGlja0NlbnRlcmVkIiwidGlja0N1bGxpbmciLCJ0aWNrTGVuZ3RoIiwidGlja1BhZGRpbmciLCJ0aWNrVmFsdWVzIiwibWF4IiwiaGVscGVyIiwiSGVscGVyIiwiZyIsImhlbHBlckluc3QiLCJzcGxpdFRpY2tUZXh0IiwiYmluZCIsImlzTGVmdFJpZ2h0IiwiaXNUb3BCb3R0b20iLCJ0aWNrVHJhbnNmb3JtIiwiYXhpc1B4Iiwic2lnbiIsInJvdGF0ZSIsInRpY2tUZXh0Um90YXRlIiwidGlja1RleHRQb3MiLCJwcmVmaXgiLCJheGlzU2hvdyIsInRpY2tTaG93IiwidGljayIsIiRnIiwiZWFjaCIsImQzU2VsZWN0Iiwic2NhbGUwIiwiX19jaGFydF9fIiwic2NhbGUxIiwiY29weVNjYWxlIiwiaXNDYXRlZ29yeSIsInNlbGVjdEFsbCIsImVudGVyIiwibWVyZ2UiLCJ0cmFuc2l0aW9uaXNlIiwib3V0ZXJUaWNrU2l6ZWQiLCJnZW5lcmF0ZVRpY2tzIiwidGlja0VudGVyIiwiaW5zZXJ0Iiwic3R5bGUiLCJ0aWNrRXhpdCIsImV4aXQiLCJyZW1vdmUiLCJzaXplRm9yMUNoYXIiLCJjb3VudHMiLCJ0c3BhbiIsImluZGV4IiwidGlja011bHRpbGluZSIsInRleHRGb3JtYXR0ZWQiLCJzcGxpdHRlZCIsImR4Iiwic2luIiwiUEkiLCJsaW5lVXBkYXRlIiwidGV4dFVwZGF0ZSIsInNldFRpY2tMaW5lVGV4dFBvc2l0aW9uIiwidGlja1RpdGxlIiwiYmFuZHdpZHRoIiwicG9zIiwidGlja1Bvc2l0aW9uIiwidGlja1BvcyIsImdldFRpY2tYWSIsImdldFRpY2tTaXplIiwiciIsImNoYXJXaWR0aCIsInN1YnRleHQiLCJzcGFjZUluZGV4IiwidGV4dFdpZHRoIiwic3Vic3RyIiwidGlja1dpZHRoIiwidGlja1RleHQiLCJhcmd1bWVudHMiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJmb3JtYXQiLCJpc0NlbnRlcmVkIiwiaW50ZXJ2YWwiLCJnZXRUb3RhbExlbmd0aCIsIkluZmluaXR5IiwiY3VsbGluZyIsInQiLCJpc0hvcml6b250YWwiLCIkJCIsImZvckhvcml6b250YWwiLCJpc1JvdGF0ZWQiLCJheGlzX3JvdGF0ZWQiLCJnZXRBeGlzQ2xhc3NOYW1lIiwiaWQiLCJBeGlzIiwib3duZXIiLCJzZXRPcmllbnQiLCJheGlzX3kyX3Nob3ciLCJheGVzTGlzdCIsImNsYXNzQXhpcyIsImF4aXNJZCIsImNsYXNzTGFiZWwiLCJheGVzIiwiY2xpcFBhdGhGb3JYQXhpcyIsImF4aXNfeV9pbm5lciIsImNsaXBQYXRoRm9yWUF4aXMiLCJnZXRUcmFuc2xhdGUiLCJnZW5lcmF0ZUF4ZXMiLCJ5SW5uZXIiLCJ5MklubmVyIiwiYXhpc195Ml9pbm5lciIsInhPcmllbnQiLCJ5T3JpZW50IiwieTJPcmllbnQiLCJzdWJYT3JpZW50IiwiZDNBeGlzIiwiYXhlc0NvbmZpZyIsImQzQXhpc0xlZnQiLCJkM0F4aXNCb3R0b20iLCJkM0F4aXNUb3AiLCJkM0F4aXNSaWdodCIsImNvdW50IiwidmFsdWVzIiwidGlja1NpemVPdXRlciIsIm91dGVyIiwiYXhpc1JhbmdlIiwiY2xhc3NOYW1lIiwieEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiaXNYIiwiaXNDYXRlZ29yaXplZCIsInhBeGlzVGlja0Zvcm1hdCIsInhBeGlzVGlja1ZhbHVlcyIsImF4aXNQYXJhbXMiLCJheGlzX3hfdGlja19tdWx0aWxpbmUiLCJheGlzX3hfdGlja193aWR0aCIsImF4aXNfeF90aWNrX3Rvb2x0aXAiLCJhcGkiLCJjYXRlZ29yaWVzIiwiem9vbVNjYWxlIiwiaXNUaW1lU2VyaWVzIiwicGFyc2VEYXRlIiwiaXNUaW1lU2VyaWVzWSIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJpc1N0YWNrTm9ybWFsaXplZCIsImF4aXNfeF90aWNrX2NlbnRlcmVkIiwiYXhpc194X3RpY2tfY3VsbGluZyIsInRhcmdldHMiLCJmaXQiLCJheGlzX3hfdGlja19maXQiLCJheGlzX3hfdGlja19jb3VudCIsImdlbmVyYXRlVGlja1ZhbHVlcyIsIm1hcFRhcmdldHNUb1VuaXF1ZVhzIiwic3ViWEF4aXMiLCJkYXRhX2F4ZXMiLCJheGlzX3hfdGlja19mb3JtYXQiLCJkYXRlIiwiYXhpc1RpbWVGb3JtYXQiLCJkZWZhdWx0QXhpc1RpbWVGb3JtYXQiLCJjYXRlZ29yeU5hbWUiLCJ0b0ZpeGVkIiwiYXBwbHkiLCJvcHRpb24iLCJnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldExhYmVsUG9zaXRpb24iLCJnZXRMYWJlbFRleHQiLCJhbmNob3IiLCJ4Rm9yQXhpc0xhYmVsIiwiZ2V0WEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WUF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbiIsImR4Rm9yQXhpc0xhYmVsIiwieEhlaWdodCIsImF4aXNfeF9oZWlnaHQiLCJnZXRNYXhUaWNrV2lkdGgiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwid2l0aG91dFJlY29tcHV0ZSIsImN1cnJlbnRUaWNrTWF4IiwiY3VycmVudE1heFRpY2tXaWR0aHMiLCJtYXhXaWR0aCIsInN2ZyIsImlzWUF4aXMiLCJ0YXJnZXRzVG9TaG93IiwiZmlsdGVyVGFyZ2V0c1RvU2hvdyIsImdldEF4aXMiLCJ0aWNrQ291bnQiLCJ1cGRhdGVYQXhpc1RpY2tWYWx1ZXMiLCJkdW1teSIsInNlbGVjdENoYXJ0IiwiY3JlYXRlIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJYIiwiWSIsIlkyIiwiYXhpc0xhYmVsIiwicGFkZGluZyIsImRvbWFpbkxlbmd0aCIsInVuaXQiLCJjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyIsInBpeGVscyIsImZvclRpbWVTZXJpZXMiLCJ0aWNrVmFsdWUiLCJ0YXJnZXRDb3VudCIsImR1cmF0aW9uIiwiYXhpc1N1YlgiLCJ0cmFuc2l0aW9ucyIsImlzSGlkZGVuIiwiaXNJbml0Iiwib3BhY2l0eSIsInRvTG93ZXJDYXNlIiwidXBkYXRlQXhlcyIsInd0aCIsImZsb3ciLCJ4RG9tYWluRm9yWm9vbSIsImhhc1pvb20iLCJ1cGRhdGVYRG9tYWluIiwiVXBkYXRlWERvbWFpbiIsIlVwZGF0ZU9yZ1hEb21haW4iLCJUcmltWERvbWFpbiIsImF4aXNfeF90aWNrX3ZhbHVlcyIsInpvb21fcmVzY2FsZSIsIm9yZ0RvbWFpbiIsImdldFlEb21haW4iLCJyZWRyYXciLCJoYXNBcmNUeXBlIiwidXBkYXRlTGFiZWxzIiwiVHJhbnNpdGlvbiIsIlVwZGF0ZVhBeGlzIiwic2V0Q3VsbGluZyIsInN1YlkiLCJzdWJZMiIsInRvQ3VsbCIsImludGVydmFsRm9yQ3VsbGluZyIsInRpY2tTaXplIiwiY3VsbGluZ01heCIsImRpc3BsYXkiLCJDaGFydEludGVybmFsIiwiZ2V0T3B0aW9ucyIsImNhY2hlIiwicmVuZGVyZWQiLCJjYWxsUGx1Z2luSG9vayIsIm9uYmVmb3JlaW5pdCIsIm9uYWZ0ZXJpbml0IiwiaW5pdFBhcmFtcyIsImJpbmR0byIsImVsZW1lbnQiLCJjbGFzc25hbWUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NlZCIsImluaXRUb1JlbmRlciIsImZvcmNlZCIsImlzTGF6eSIsInJlbmRlciIsImxhenkiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsIm11dGF0aW9uIiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImNvbnZlcnRlZERhdGEiLCJjb252ZXJ0RGF0YSIsImluaXRXaXRoRGF0YSIsImRhdGV0aW1lSWQiLCJpbml0Q2xpcCIsImRyYWdTdGFydCIsImRyYWdnaW5nIiwiZmxvd2luZyIsImNhbmNlbENsaWNrIiwibW91c2VvdmVyIiwidHJhbnNpdGluZyIsImNvbG9yIiwiZ2VuZXJhdGVDb2xvciIsImxldmVsQ29sb3IiLCJnZW5lcmF0ZUxldmVsQ29sb3IiLCJwb2ludCIsImdlbmVyYXRlUG9pbnQiLCJleHRyYUxpbmVDbGFzc2VzIiwiZ2VuZXJhdGVFeHRyYUxpbmVDbGFzcyIsImRhdGFUaW1lRm9ybWF0IiwiZGF0YV94TG9jYWx0aW1lIiwiZDNUaW1lUGFyc2UiLCJkM1V0Y1BhcnNlIiwiYXhpc194X2xvY2FsdGltZSIsImQzVGltZUZvcm1hdCIsImQzVXRjRm9ybWF0IiwiaXNEcmFnWm9vbSIsInpvb21fZW5hYmxlZCIsImlzWm9vbWVkIiwic3BlY2lmaWVyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldERhdGUiLCJnZXRNb250aCIsImhpZGRlblRhcmdldElkcyIsImhpZGRlbkxlZ2VuZElkcyIsImZvY3VzZWRUYXJnZXRJZHMiLCJkZWZvY3VzZWRUYXJnZXRJZHMiLCJpc0xlZ2VuZFJpZ2h0IiwibGVnZW5kX3Bvc2l0aW9uIiwiaXNMZWdlbmRJbnNldCIsImlzTGVnZW5kVG9wIiwibGVnZW5kX2luc2V0X2FuY2hvciIsImlzTGVnZW5kTGVmdCIsImxlZ2VuZFN0ZXAiLCJsZWdlbmRJdGVtV2lkdGgiLCJsZWdlbmRJdGVtSGVpZ2h0IiwieTIiLCJyb3RhdGVkX3BhZGRpbmdfbGVmdCIsInJvdGF0ZWRfcGFkZGluZ19yaWdodCIsImF4aXNfeF9zaG93Iiwicm90YXRlZF9wYWRkaW5nX3RvcCIsIndpdGhvdXRGYWRlSW4iLCJpbnB1dFR5cGUiLCJjb252ZXJ0SW5wdXRUeXBlIiwic3VieCIsImQzU2VsZWN0QWxsIiwiaW5pdFpvb20iLCJ4cyIsImNvbnZlcnREYXRhVG9UYXJnZXRzIiwiZGF0YV9maWx0ZXIiLCJkYXRhX2hpZGUiLCJhZGRIaWRkZW5UYXJnZXRJZHMiLCJtYXBUb0lkcyIsImxlZ2VuZF9oaWRlIiwiYWRkSGlkZGVuTGVnZW5kSWRzIiwiaGFzVHlwZSIsImxlZ2VuZF9zaG93IiwidXBkYXRlU2l6ZXMiLCJ1cGRhdGVTY2FsZXMiLCJnZXRYRG9tYWluIiwic3ViWCIsIm9yZ1hEb21haW4iLCJpbnRlcmFjdGlvbl9lbmFibGVkIiwiaXNUb3VjaCIsIm9uIiwib25vdmVyIiwib25vdXQiLCJzdmdfY2xhc3NuYW1lIiwiZGVmcyIsImNsaXBDaGFydCIsImFwcGVuZENsaXAiLCJjbGlwSWQiLCJjbGlwWEF4aXMiLCJjbGlwSWRGb3JYQXhpcyIsImNsaXBZQXhpcyIsImNsaXBJZEZvcllBeGlzIiwiY2xpcEdyaWQiLCJjbGlwSWRGb3JHcmlkIiwiY29sb3JfdGlsZXMiLCJwYXR0ZXJucyIsInVwZGF0ZVN2Z1NpemUiLCJzdWJjaGFydF9zaG93IiwiaW5pdFN1YmNoYXJ0IiwiaW5pdFRvb2x0aXAiLCJpbml0TGVnZW5kIiwiaW5pdFRpdGxlIiwiZGF0YV9lbXB0eV9sYWJlbF90ZXh0IiwiaW5pdFJlZ2lvbiIsImNsaXBQYXRoIiwiaW5pdCIsImluaXRFdmVudFJlY3QiLCJpbml0Q2hhcnRFbGVtZW50cyIsImluaXRHcmlkIiwiem9vbV9wcml2aWxlZ2VkIiwidXBkYXRlVGFyZ2V0cyIsInVwZGF0ZURpbWVuc2lvbiIsIm9uaW5pdCIsIndpdGhUcmFuc2Zvcm0iLCJ3aXRoVXBkYXRlWERvbWFpbiIsIndpdGhVcGRhdGVPcmdYRG9tYWluIiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwiaW5pdGlhbGl6aW5nIiwiZGF0YV9vbm1pbiIsImRhdGFfb25tYXgiLCJtaW5NYXgiLCJnZXRNaW5NYXhEYXRhIiwiYmluZFJlc2l6ZSIsImRhdGFfbGFiZWxzIiwiaW5pdFRleHQiLCIkIiwibGVnZW5kIiwibWFpbkJhciIsIm1haW5MaW5lIiwibWFpbkFyZWEiLCJtYWluQ2lyY2xlIiwibWFpblRleHQiLCJ4MSIsIngyIiwieTEiLCJoYXNBcmMiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsImxlZ2VuZEhlaWdodEZvckJvdHRvbSIsInhBeGlzSGVpZ2h0IiwiZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQiLCJzdWJjaGFydFhBeGlzSGVpZ2h0Iiwic3ViY2hhcnRfYXhpc194X3Nob3ciLCJzdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3ciLCJzdWJjaGFydEhlaWdodCIsInN1YmNoYXJ0X3NpemVfaGVpZ2h0Iiwic2V0Q29udGFpbmVyU2l6ZSIsIm1hcmdpbiIsImdldEN1cnJlbnRQYWRkaW5nVG9wIiwiZ2V0Q3VycmVudFBhZGRpbmdSaWdodCIsImdldEN1cnJlbnRQYWRkaW5nQm90dG9tIiwiZ2V0Q3VycmVudFBhZGRpbmdMZWZ0IiwibWFyZ2luMiIsIk5hTiIsImN1cnJlbnRIZWlnaHQiLCJtYXJnaW4zIiwidXBkYXRlU2l6ZUZvckxlZ2VuZCIsImN1cnJlbnRXaWR0aCIsIndpZHRoMiIsImhlaWdodDIiLCJhcmNXaWR0aCIsImFyY0hlaWdodCIsImdhdWdlX2Z1bGxDaXJjbGUiLCJnZXRHYXVnZUxhYmVsSGVpZ2h0IiwidXBkYXRlUmFkaXVzIiwicmFkaXVzRXhwYW5kZWQiLCJ1cGRhdGVUYXJnZXRzRm9yVGV4dCIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsInVwZGF0ZVRhcmdldHNGb3JSYWRhciIsInVwZGF0ZVRhcmdldHNGb3JBcmMiLCJ1cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQiLCJzaG93VGFyZ2V0cyIsImlzVGFyZ2V0VG9TaG93Iiwid2l0aE9wdGlvbnMiLCJTdWJjaGFydCIsIkV2ZW50UmVjdCIsIkRpbWVuc2lvbiIsIlRyYW5zZm9ybSIsIkxlZ2VuZCIsIlRyYW5zaXRpb25Gb3JFeGl0IiwiVHJhbnNpdGlvbkZvckF4aXMiLCJkZWZWYWwiLCJ0cmFuc2l0aW9uc1ZhbHVlIiwiZ2V0V2l0aE9wdGlvbiIsImR1cmF0aW9uRm9yRXhpdCIsImR1cmF0aW9uRm9yQXhpcyIsImdlbmVyYXRlVHJhbnNpdGlvbnMiLCJ0b29sdGlwX2luaXRfc2hvdyIsImhpZGVUb29sdGlwIiwidXBkYXRlTGVnZW5kIiwicmVkcmF3QXhpcyIsInVwZGF0ZUNpcmNsZVkiLCJ1cGRhdGVYZ3JpZEZvY3VzIiwidXBkYXRlR3JpZCIsInVwZGF0ZVJlZ2lvbiIsInVwZGF0ZUJhciIsInVwZGF0ZUxpbmUiLCJ1cGRhdGVBcmVhIiwidXBkYXRlQ2lyY2xlIiwiaGFzRGF0YUxhYmVsIiwidXBkYXRlVGV4dCIsInJlZHJhd1RpdGxlIiwicmVkcmF3QXJjIiwicmFkYXJzIiwicmVkcmF3UmFkYXIiLCJpc0JhclR5cGUiLCJyZWRyYXdFdmVudFJlY3QiLCJiaW5kWm9vbUV2ZW50Iiwic2V0Q2hhcnRFbGVtZW50cyIsImdlbmVyYXRlUmVkcmF3TGlzdCIsIndpdGhTdWJjaGFydCIsImdldERyYXdTaGFwZSIsInJlZHJhd1N1YmNoYXJ0IiwiZmxvd0ZuIiwiZ2VuZXJhdGVGbG93IiwieHYiLCJpc1RyYW5zaXRpb24iLCJpc1RhYlZpc2libGUiLCJyZWRyYXdMaXN0IiwiZ2V0UmVkcmF3TGlzdCIsImFmdGVyUmVkcmF3Iiwib25yZW5kZXJlZCIsIndhaXRGb3JEcmF3IiwiZ2VuZXJhdGVXYWl0IiwiZDNUcmFuc2l0aW9uIiwiYWNjIiwidDEiLCJhZGQiLCJoYXNSYWRhciIsImluZGljZXMiLCJoYXNUeXBlT2YiLCJnZXRTaGFwZUluZGljZXMiLCJpc0xpbmVUeXBlIiwiZ2VuZXJhdGVEcmF3TGluZSIsImlzQXJlYVR5cGUiLCJnZW5lcmF0ZURyYXdBcmVhIiwiZ2VuZXJhdGVEcmF3QmFyIiwieEZvclRleHQiLCJnZW5lcmF0ZVhZRm9yVGV4dCIsInlGb3JUZXh0IiwiY3giLCJyYWRhckNpcmNsZVgiLCJjaXJjbGVZIiwiY2lyY2xlWCIsImN5IiwicmFkYXJDaXJjbGVZIiwibGlzdCIsImdyaWRfeF9saW5lcyIsImdyaWRfeV9saW5lcyIsInJlZHJhd0dyaWQiLCJyZWRyYXdSZWdpb24iLCJyZWRyYXdMaW5lIiwicmVkcmF3QXJlYSIsInJlZHJhd0JhciIsInJlZHJhd1RleHQiLCJyZWRyYXdDaXJjbGUiLCJ3aXRoTGVnZW5kIiwid2l0aFRyYW5zaXRpb25Gb3JFeGl0Iiwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1BbGwiLCJ3aXRoWSIsIndpdGhFdmVudFJlY3QiLCJheGlzX3hfdHlwZSIsImRhdGFfeCIsImRhdGFfeHMiLCJheGlzX3lfdHlwZSIsImdldEF4aXNTaXplIiwiZ2V0UmFkYXJTaXplIiwiZ2V0QmFzZVZhbHVlIiwib3BhY2l0eUZvckNpcmNsZSIsInBvaW50X3Nob3ciLCJpc0J1YmJsZVR5cGUiLCJpc1NjYXR0ZXJUeXBlIiwiYXhpc194X2NhdGVnb3JpZXMiLCJ5U2NhbGUiLCJ5QXhpcyIsInkyQXhpcyIsInRyYW5zZm9ybU1haW4iLCJ0cmFuc2Zvcm1Db250ZXh0IiwidHJhbnNmb3JtTGVnZW5kIiwiYnJ1c2hTaXplIiwiZ2V0WEF4aXNDbGlwWCIsImdldFhBeGlzQ2xpcFkiLCJnZXRYQXhpc0NsaXBXaWR0aCIsImdldFhBeGlzQ2xpcEhlaWdodCIsImdldFlBeGlzQ2xpcFgiLCJnZXRZQXhpc0NsaXBZIiwiZ2V0WUF4aXNDbGlwV2lkdGgiLCJnZXRZQXhpc0NsaXBIZWlnaHQiLCJjbGlwSWRGb3JTdWJjaGFydCIsIndpdGhvdXRBeGlzIiwicmVzaXplRnVuY3Rpb24iLCJnZW5lcmF0ZVJlc2l6ZSIsIm9ucmVzaXplIiwicmVzaXplX2F1dG8iLCJyZXNpemVUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImZsdXNoIiwib25yZXNpemVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbGxSZXNpemVGdW5jdGlvbnMiLCJyZXNpemVGdW5jdGlvbnMiLCJmIiwic3BsaWNlIiwiY2FsbGJhY2siLCJ0cmFuc2l0aW9uc1RvV2FpdCIsImxvb3AiLCJkb25lIiwidGltZXIiLCJwYXJzZWREYXRlIiwiZGF0YV94Rm9ybWF0IiwiaGlkZGVuIiwiaXNNb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2giLCJoYXNUb3VjaFBvaW50cyIsIm1heFRvdWNoUG9pbnRzIiwiaGFzVG91Y2giLCJEb2N1bWVudFRvdWNoIiwiaGFzTW91c2UiLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2UiLCJwaGFzZSIsInBsdWdpbnMiLCJDaGFydCIsImludGVybmFsIiwibG9hZENvbmZpZyIsImJlZm9yZUluaXQiLCJhZnRlckluaXQiLCJiaW5kVGhpcyIsImFyZ1RoaXMiLCJwcm90b3R5cGUiLCJPcHRpb25zIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJ6b29tX2V4dGVudCIsInpvb21fb256b29tIiwiem9vbV9vbnpvb21zdGFydCIsInpvb21fb256b29tZW5kIiwiem9vbV9yZXNldEJ1dHRvbiIsInpvb21feF9taW4iLCJ6b29tX3hfbWF4IiwiaW50ZXJhY3Rpb25fYnJpZ2h0ZW4iLCJkYXRhX3hTb3J0IiwiZGF0YV9pZENvbnZlcnRlciIsImRhdGFfbmFtZXMiLCJkYXRhX2NsYXNzZXMiLCJkYXRhX2dyb3VwcyIsImRhdGFfdHlwZSIsImRhdGFfdHlwZXMiLCJkYXRhX2xhYmVsc19jb2xvcnMiLCJkYXRhX2xhYmVsc19wb3NpdGlvbiIsImRhdGFfb3JkZXIiLCJkYXRhX3JlZ2lvbnMiLCJkYXRhX2NvbG9yIiwiZGF0YV9jb2xvcnMiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJkYXRhX29uY2xpY2siLCJkYXRhX29ub3ZlciIsImRhdGFfb25vdXQiLCJkYXRhX29uc2VsZWN0ZWQiLCJkYXRhX29udW5zZWxlY3RlZCIsImRhdGFfdXJsIiwiZGF0YV9oZWFkZXJzIiwiZGF0YV9qc29uIiwiZGF0YV9yb3dzIiwiZGF0YV9jb2x1bW5zIiwiZGF0YV9taW1lVHlwZSIsImRhdGFfa2V5cyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3ciLCJzdWJjaGFydF9vbmJydXNoIiwiY29sb3JfcGF0dGVybiIsImNvbG9yX3RocmVzaG9sZCIsImNvbG9yX29ub3ZlciIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfaW5zZXRfeCIsImxlZ2VuZF9pbnNldF95IiwibGVnZW5kX2luc2V0X3N0ZXAiLCJsZWdlbmRfaXRlbV9vbmNsaWNrIiwibGVnZW5kX2l0ZW1fb25vdmVyIiwibGVnZW5kX2l0ZW1fb25vdXQiLCJsZWdlbmRfZXF1YWxseSIsImxlZ2VuZF9wYWRkaW5nIiwibGVnZW5kX2l0ZW1fdGlsZV93aWR0aCIsImxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0IiwibGVnZW5kX3VzZVBvaW50IiwiYXhpc194X2NsaXBQYXRoIiwiYXhpc194X3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3hfdGlja19zaG93IiwiYXhpc194X3RpY2tfdGV4dF9zaG93IiwiYXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeF90aWNrX3JvdGF0ZSIsImF4aXNfeF90aWNrX291dGVyIiwiYXhpc194X21heCIsImF4aXNfeF9taW4iLCJheGlzX3hfcGFkZGluZyIsImF4aXNfeF9leHRlbnQiLCJheGlzX3hfbGFiZWwiLCJheGlzX3hfYXhlcyIsImF4aXNfeV9jbGlwUGF0aCIsImF4aXNfeV9zaG93IiwiYXhpc195X21heCIsImF4aXNfeV9taW4iLCJheGlzX3lfaW52ZXJ0ZWQiLCJheGlzX3lfY2VudGVyIiwiYXhpc195X2xhYmVsIiwiYXhpc195X3RpY2tfZm9ybWF0IiwiYXhpc195X3RpY2tfY3VsbGluZyIsImF4aXNfeV90aWNrX2N1bGxpbmdfbWF4IiwiYXhpc195X3RpY2tfb3V0ZXIiLCJheGlzX3lfdGlja192YWx1ZXMiLCJheGlzX3lfdGlja19yb3RhdGUiLCJheGlzX3lfdGlja19jb3VudCIsImF4aXNfeV90aWNrX3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195X3BhZGRpbmciLCJheGlzX3lfZGVmYXVsdCIsImF4aXNfeV9heGVzIiwiYXhpc195Ml9tYXgiLCJheGlzX3kyX21pbiIsImF4aXNfeTJfaW52ZXJ0ZWQiLCJheGlzX3kyX2NlbnRlciIsImF4aXNfeTJfbGFiZWwiLCJheGlzX3kyX3RpY2tfZm9ybWF0IiwiYXhpc195Ml90aWNrX2N1bGxpbmciLCJheGlzX3kyX3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3kyX3RpY2tfb3V0ZXIiLCJheGlzX3kyX3RpY2tfdmFsdWVzIiwiYXhpc195Ml90aWNrX2NvdW50IiwiYXhpc195Ml90aWNrX3Nob3ciLCJheGlzX3kyX3RpY2tfdGV4dF9zaG93IiwiYXhpc195Ml90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3kyX3BhZGRpbmciLCJheGlzX3kyX2RlZmF1bHQiLCJheGlzX3kyX2F4ZXMiLCJncmlkX3hfc2hvdyIsImdyaWRfeF90eXBlIiwiZ3JpZF95X3Nob3ciLCJncmlkX3lfdGlja3MiLCJncmlkX2ZvY3VzX3Nob3ciLCJncmlkX2Zyb250IiwiZ3JpZF9saW5lc19mcm9udCIsInBvaW50X3IiLCJwb2ludF9zZW5zaXRpdml0eSIsInBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkIiwicG9pbnRfZm9jdXNfZXhwYW5kX3IiLCJwb2ludF9wYXR0ZXJuIiwicG9pbnRfc2VsZWN0X3IiLCJwb2ludF90eXBlIiwibGluZV9jb25uZWN0TnVsbCIsImxpbmVfc3RlcF90eXBlIiwibGluZV9jbGFzc2VzIiwibGluZV9wb2ludCIsImJhcl9wYWRkaW5nIiwiYmFyX3JhZGl1cyIsImJhcl9yYWRpdXNfcmF0aW8iLCJiYXJfc2Vuc2l0aXZpdHkiLCJiYXJfd2lkdGgiLCJiYXJfd2lkdGhfcmF0aW8iLCJiYXJfd2lkdGhfbWF4IiwiYmFyX3plcm9iYXNlZCIsImJ1YmJsZV9tYXhSIiwiYXJlYV96ZXJvYmFzZWQiLCJhcmVhX2Fib3ZlIiwiYXJlYV9saW5lYXJHcmFkaWVudCIsInBpZV9sYWJlbF9zaG93IiwicGllX2xhYmVsX2Zvcm1hdCIsInBpZV9sYWJlbF90aHJlc2hvbGQiLCJwaWVfbGFiZWxfcmF0aW8iLCJwaWVfZXhwYW5kIiwicGllX2V4cGFuZF9kdXJhdGlvbiIsInBpZV9pbm5lclJhZGl1cyIsInBpZV9wYWRBbmdsZSIsInBpZV9wYWRkaW5nIiwiZ2F1Z2VfbGFiZWxfc2hvdyIsImdhdWdlX2xhYmVsX2Zvcm1hdCIsImdhdWdlX21pbiIsImdhdWdlX21heCIsImdhdWdlX3N0YXJ0aW5nQW5nbGUiLCJnYXVnZV9sYWJlbF9leHRlbnRzIiwiZ2F1Z2VfdGl0bGUiLCJnYXVnZV91bml0cyIsImdhdWdlX3dpZHRoIiwiZ2F1Z2VfZXhwYW5kIiwiZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uIiwiZG9udXRfbGFiZWxfc2hvdyIsImRvbnV0X2xhYmVsX2Zvcm1hdCIsImRvbnV0X2xhYmVsX3RocmVzaG9sZCIsImRvbnV0X2xhYmVsX3JhdGlvIiwiZG9udXRfd2lkdGgiLCJkb251dF90aXRsZSIsImRvbnV0X2V4cGFuZCIsImRvbnV0X2V4cGFuZF9kdXJhdGlvbiIsImRvbnV0X3BhZEFuZ2xlIiwic3BsaW5lX2ludGVycG9sYXRpb25fdHlwZSIsInJhZGFyX2F4aXNfbWF4IiwicmFkYXJfYXhpc19saW5lX3Nob3ciLCJyYWRhcl9heGlzX3RleHRfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbiIsInJhZGFyX2xldmVsX2RlcHRoIiwicmFkYXJfbGV2ZWxfc2hvdyIsInJhZGFyX2xldmVsX3RleHRfZm9ybWF0IiwicmFkYXJfbGV2ZWxfdGV4dF9zaG93IiwicmFkYXJfc2l6ZV9yYXRpbyIsInJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2UiLCJ0b29sdGlwX3Nob3ciLCJ0b29sdGlwX2RvTm90SGlkZSIsInRvb2x0aXBfZ3JvdXBlZCIsInRvb2x0aXBfZm9ybWF0X3RpdGxlIiwidG9vbHRpcF9mb3JtYXRfbmFtZSIsInRvb2x0aXBfZm9ybWF0X3ZhbHVlIiwidG9vbHRpcF9wb3NpdGlvbiIsInRvb2x0aXBfY29udGVudHMiLCJ0b29sdGlwX2luaXRfeCIsInRvb2x0aXBfaW5pdF9wb3NpdGlvbiIsInRvb2x0aXBfbGlua2VkIiwidG9vbHRpcF9saW5rZWRfbmFtZSIsInRvb2x0aXBfb25zaG93IiwidG9vbHRpcF9vbmhpZGUiLCJ0b29sdGlwX29uc2hvd24iLCJ0b29sdGlwX29uaGlkZGVuIiwidG9vbHRpcF9vcmRlciIsInRpdGxlX3RleHQiLCJ0aXRsZV9wYWRkaW5nIiwidGl0bGVfcG9zaXRpb24iLCJyZWFkIiwidGhpc0NvbmZpZyIsImZpbmQiLCJnZXRTY2FsZSIsImZvclRpbWVzZXJpZXMiLCJkM1NjYWxlVGltZSIsImdldFgiLCJvZmZzZXQiLCJnZXRDdXN0b21pemVkU2NhbGUiLCJnZXRZIiwic2NhbGVWYWx1ZSIsIm9mZnNldFZhbHVlIiwicmF3Iiwib3JnU2NhbGUiLCJkb21haW5WYWx1ZSIsImdldFlTY2FsZSIsImdldElkIiwiZ2V0U3ViWVNjYWxlIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsInN1YlhNaW4iLCJzdWJYTWF4Iiwic3ViWU1pbiIsInN1YllNYXgiLCJ4RG9tYWluIiwieFN1YkRvbWFpbiIsImdldFhBeGlzVGlja0Zvcm1hdCIsImdldFRpY2tWYWx1ZXMiLCJ5QXhpc1RpY2tWYWx1ZXMiLCJ5MkF4aXNUaWNrVmFsdWVzIiwidXBkYXRlQXJjIiwiZ2V0WURvbWFpbk1pbk1heCIsImlzTWluIiwiZGF0YUdyb3VwcyIsImlkcyIsInlzIiwiZ2V0VmFsdWVzQXNJZEtleWVkIiwiaWRzSW5Hcm91cCIsImoiLCJiYXNlSWQiLCJiYXNlQXhpc0lkIiwiayIsInZhbCIsIm1lZXRDb25kaXRpb24iLCJnZXRZRG9tYWluTWluIiwiZ2V0WURvbWFpbk1heCIsInRhcmdldHNCeUF4aXNJZCIsInlUYXJnZXRzIiwiZmlsdGVyQnlYRG9tYWluIiwieURvbWFpbk1pbiIsInlEb21haW5NYXgiLCJjZW50ZXIiLCJpc1plcm9CYXNlZCIsImlzSW52ZXJ0ZWQiLCJzaG93SG9yaXpvbnRhbERhdGFMYWJlbCIsInNob3dWZXJ0aWNhbERhdGFMYWJlbCIsImlzQWxsUG9zaXRpdmUiLCJpc0FsbE5lZ2F0aXZlIiwiYWJzIiwieURvbWFpbkFicyIsInJhdGlvIiwiZ2V0RGF0YUxhYmVsTGVuZ3RoIiwibGVuZ3RocyIsImdldFBhZGRpbmciLCJyZXZlcnNlIiwiZ2V0WERvbWFpbk1pbk1heCIsImdldFhEb21haW5NaW4iLCJnZXRYRG9tYWluTWF4IiwiZ2V0WERvbWFpblBhZGRpbmciLCJtYXhEYXRhQ291bnQiLCJ4UGFkZGluZyIsImdldE1heERhdGFDb3VudCIsImZpcnN0WCIsImxhc3RYIiwiZ2V0VGltZSIsIndpdGhUcmltIiwiem9vbUVuYWJsZWQiLCJ6b29tIiwidXBkYXRlU2NhbGVFeHRlbnQiLCJpbnZlcnQiLCJ0cmltWERvbWFpbiIsInpvb21Eb21haW4iLCJnZXRab29tRG9tYWluIiwiZGF0YUtleSIsImV4aXN0VmFsdWUiLCJpc05vdFgiLCJpc0dyb3VwZWQiLCJnZXRYS2V5IiwiZ2V0WFZhbHVlc09mWEtleSIsInhWYWx1ZXMiLCJnZXRJbmRleEJ5WCIsImJhc2VkWCIsImZpbHRlckJ5WCIsImdldFhWYWx1ZSIsImdldE90aGVyVGFyZ2V0WHMiLCJpZHNGb3JYIiwiZ2V0T3RoZXJUYXJnZXRYIiwiYWRkWHMiLCJoYXNNdWx0aXBsZVgiLCJpc011bHRpcGxlWCIsImFkZE5hbWUiLCJnZXRBbGxWYWx1ZXNPbkluZGV4IiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsImdlbmVyYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwicmF3WCIsImlzQ3VzdG9tWCIsImNsb25lVGFyZ2V0IiwiaWRfb3JnIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiaXNBcmVhUmFuZ2VUeXBlIiwiZ2V0QXJlYVJhbmdlRGF0YSIsImlzQnViYmxlWlR5cGUiLCJnZXRCdWJibGVaRGF0YSIsImdldE1pbk1heFZhbHVlIiwiY2FjaGVLZXkiLCJtaW5NYXhEYXRhIiwiZ2V0Q2FjaGUiLCJtaW5EYXRhIiwiZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSIsIm1heERhdGEiLCJhZGRDYWNoZSIsImdldFRvdGFsUGVySW5kZXgiLCJzdW0iLCJyb3ciLCJnZXRUb3RhbERhdGFTdW0iLCJ0b3RhbERhdGFTdW0iLCJ0b3RhbCIsImdldE1heERhdGFDb3VudFRhcmdldCIsIm1hcFRvVGFyZ2V0SWRzIiwiaGFzVGFyZ2V0IiwidGFyZ2V0SWQiLCJpc0xlZ2VuZFRvU2hvdyIsInRhcmdldElkcyIsInJlbW92ZUhpZGRlblRhcmdldElkcyIsInJlbW92ZUhpZGRlbkxlZ2VuZElkcyIsImNoZWNrVmFsdWVJblRhcmdldHMiLCJjaGVja2VyIiwiaGFzTXVsdGlUYXJnZXRzIiwiaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyIsImhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHMiLCJfY2hlY2tPcmRlciIsIm9yZGVyIiwiaXNPcmRlckRlc2MiLCJpc09yZGVyQXNjIiwib3JkZXJUYXJnZXRzIiwidGFyZ2V0c1ZhbHVlIiwib3JkZXJBc2MiLCJvcmRlckRlc2MiLCJ0MiIsInJlZHVjZXIiLCJ0MVN1bSIsInQyU3VtIiwiZmlsdGVyUmVtb3ZlTnVsbCIsImRhdGFMYWJlbHMiLCJkYXRhTGFiZWxGb3JtYXQiLCJpc05vbmVBcmMiLCJpc0FyYyIsImZpbmRTYW1lWE9mVmFsdWVzIiwidGFyZ2V0WCIsInNhbWVzIiwiZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyIsImNhbmRpZGF0ZXMiLCJmaW5kQ2xvc2VzdCIsImNsb3Nlc3QiLCJtaW5EaXN0IiwiZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgiLCJpc1dpdGhpbkJhciIsImRpc3QiLCJ4SW5kZXgiLCJ5SW5kZXgiLCJzcXJ0IiwicG93IiwiY29udmVydFZhbHVlc1RvU3RlcCIsInN0ZXBUeXBlIiwiY29udmVydGVkIiwiY29udmVydFZhbHVlc1RvUmFuZ2UiLCJyYW5nZXMiLCJ1cGRhdGVEYXRhQXR0cmlidXRlcyIsImF0dHJzIiwiY3VycmVudCIsImdldFJhdGlvIiwiYXNQZXJjZW50Iiwic2hvd24iLCJkYXRhVmFsdWVzIiwicGllIiwicGFkQW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0QW5nbGUiLCJoaWRkZW5TdW0iLCJjdXJyIiwicGFyc2VGbG9hdCIsIm1heFZhbHVlIiwidXBkYXRlRGF0YUluZGV4QnlYIiwic29tZSIsInVybCIsImNvbnZlcnRVcmxUb0RhdGEiLCJtaW1lVHlwZSIsImhlYWRlcnMiLCJqc29uIiwiY29udmVydEpzb25Ub0RhdGEiLCJyb3dzIiwiY29udmVydFJvd3NUb0RhdGEiLCJjb2x1bW5zIiwiY29udmVydENvbHVtbnNUb0RhdGEiLCJFcnJvciIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJKU09OIiwicGFyc2UiLCJzZW5kIiwiX2NvbnZlcnRDc3ZUc3ZUb0RhdGEiLCJwYXJzZXIiLCJ4c3YiLCJjb252ZXJ0Q3N2VG9EYXRhIiwiZDNDc3ZQYXJzZVJvd3MiLCJkM0NzdlBhcnNlIiwiY29udmVydFRzdlRvRGF0YSIsInRzdiIsImQzVHN2UGFyc2VSb3dzIiwiZDNUc3ZQYXJzZSIsImtleXNQYXJhbSIsInRhcmdldEtleXMiLCJuZXdSb3dzIiwibmV3Um93IiwiZmluZFZhbHVlSW5Kc29uIiwidG1wIiwib2JqZWN0IiwiY29udmVydGVkUGF0aCIsInBhdGhBcnJheSIsImxlbjEiLCJsZW4yIiwiYXBwZW5kWHMiLCJ4c0RhdGEiLCJkYXRhS2V5cyIsInhLZXkiLCJjb252ZXJ0ZWRJZCIsImhhc0NhdGVnb3J5IiwidjEiLCJ2MiIsImhhc05lZ2F0aXZlVmFsdWUiLCJoYXNQb3NpdGl2ZVZhbHVlIiwic2V0VGFyZ2V0VHlwZSIsImxvYWQiLCJyYXdUYXJnZXRzIiwidHlwZXMiLCJsb2FkRnJvbUFyZ3MiLCJyZXNldENhY2hlIiwidW5sb2FkIiwicmF3VGFyZ2V0SWRzIiwiY3VzdG9tRG9uZUNiIiwic2VsZWN0b3JUYXJnZXQiLCJlbmRhbGwiLCJldmVudFJlY3RVcGRhdGUiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzIiwidXBkYXRlUG9pbnRDbGFzcyIsImRhdHVtIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWCIsInVwZGF0ZUV2ZW50UmVjdCIsImJpbmRUb3VjaE9uRXZlbnRSZWN0Iiwic3RhcnRQeCIsImdldEV2ZW50UmVjdCIsImVsZW1lbnRGcm9tUG9pbnQiLCJnZXRJbmRleCIsInNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyIsImNhbGxPdmVyT3V0Rm9yVG91Y2giLCJ1bnNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yU2luZ2xlIiwicHJldmVudERlZmF1bHQiLCJpc1ByZXZlbnRlZCIsInByZXZlbnRUaHJlc2hvbGQiLCJwcmV2ZW50RXZlbnQiLCJjdXJyZW50WFkiLCJ0b2dnbGVTaGFwZSIsInhTY2FsZSIsImV2ZW50UmVjdERhdGEiLCJyZWN0VyIsInJlY3RYIiwiZ2V0RXZlbnRSZWN0V2lkdGgiLCJnZXRQcmV2TmV4dFgiLCJwcmV2IiwibmV4dCIsInRoaXNYIiwiY2xhc3NFdmVudCIsImlzU2VsZWN0aW9uRW5hYmxlZCIsImlzU2VsZWN0aW9uR3JvdXBlZCIsImlzVG9vbHRpcEdyb3VwZWQiLCJzZWxlY3RlZERhdGEiLCJzaG93VG9vbHRpcCIsInNob3dYR3JpZEZvY3VzIiwiaGlkZVhHcmlkRm9jdXMiLCJleHBhbmRDaXJjbGVzQmFycyIsImlzV2l0aGluU2hhcGUiLCJzZWxlY3RlZCIsInVuZXhwYW5kQ2lyY2xlcyIsInJlc2V0IiwiZXhwYW5kQ2lyY2xlcyIsImV4cGFuZEJhcnMiLCJkM01vdXNlIiwic2FtZVhEYXRhIiwiX2hhbmRsZUxpbmtlZENoYXJ0cyIsInVuZXhwYW5kQmFycyIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJsYXN0IiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZHJhZyIsImQzRHJhZyIsImRyYWdzdGFydCIsImRyYWdlbmQiLCJldmVudFJlY3RFbnRlciIsImNsaWNrSGFuZGxlckZvclNpbmdsZVgiLCJpc1N0ZXBUeXBlIiwiZDIiLCJjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTIiwic2VsZWN0b3IiLCJnZXRDdXJyZW50V2lkdGgiLCJnZXRDdXJyZW50SGVpZ2h0IiwiZ2V0UGFyZW50V2lkdGgiLCJnZXRQYXJlbnRIZWlnaHQiLCJnZXRBeGlzV2lkdGhCeUF4aXNJZCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJsZWdlbmRXaWR0aE9uUmlnaHQiLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsInBhcmVudE5vZGUiLCJib2R5V2lkdGgiLCJvZmZzZXRXaWR0aCIsInBhcnNlSW50IiwiZ2V0U3ZnTGVmdCIsImhhc0xlZnRBeGlzUmVjdCIsImxlZnRBeGlzQ2xhc3MiLCJsZWZ0QXhpcyIsInN2Z1JlY3QiLCJjaGFydFJlY3QiLCJzdmdMZWZ0IiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJjb3MiLCJ0aWNrSW50ZXJ2YWwiLCJ0eXBlRmlsdGVyIiwiZ3JvdXBzIiwiX19tYXhfXyIsImdldFNoYXBlWCIsInRhcmdldHNOdW0iLCJpc1N1YiIsImJhclBhZGRpbmciLCJoYWxmV2lkdGgiLCJ4UG9zIiwiZ2V0U2hhcGVZIiwiZ2V0U2hhcGVPZmZzZXQiLCJpZHgiLCJ5MCIsInJvd1ZhbHVlcyIsInRoYXQiLCJpc1dpdGhpbiIsImhhc1ZhbGlkUG9pbnRUeXBlIiwibm9kZU5hbWUiLCJpc1dpdGhpblN0ZXAiLCJpc1dpdGhpbkNpcmNsZSIsInBvaW50U2VsZWN0UiIsImdldEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGlvbiIsImdldEludGVycG9sYXRlVHlwZSIsImQzQ3VydmVCYXNpcyIsImQzQ3VydmVCYXNpc0Nsb3NlZCIsImQzQ3VydmVCYXNpc09wZW4iLCJkM0N1cnZlQnVuZGxlIiwiZDNDdXJ2ZUNhcmRpbmFsIiwiZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkIiwiZDNDdXJ2ZUNhcmRpbmFsT3BlbiIsImQzQ3VydmVDYXRtdWxsUm9tIiwiZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQiLCJkM0N1cnZlQ2F0bXVsbFJvbU9wZW4iLCJkM0N1cnZlTW9ub3RvbmVYIiwiZDNDdXJ2ZU1vbm90b25lWSIsImQzQ3VydmVOYXR1cmFsIiwiZDNDdXJ2ZUxpbmVhckNsb3NlZCIsImQzQ3VydmVMaW5lYXIiLCJkM0N1cnZlU3RlcCIsImQzQ3VydmVTdGVwQWZ0ZXIiLCJkM0N1cnZlU3RlcEJlZm9yZSIsImlzSW50ZXJwb2xhdGlvblR5cGUiLCJpc1NwbGluZVR5cGUiLCJpbml0UGllIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwicmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImlubmVyUmFkaXVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwic3ZnQXJjRXhwYW5kZWRTdWIiLCJ1cGRhdGVBbmdsZSIsImRWYWx1ZSIsImlzR2F1Z2VUeXBlIiwidG90YWxTdW0iLCJnU3RhcnQiLCJnRW5kIiwiaXIiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwid2l0aG91dFVwZGF0ZSIsInVwZGF0ZWQiLCJjZW50cm9pZCIsInJhdGUiLCJnZXRBcmMiLCJpc0FyY1R5cGUiLCJ0cmFuc2Zvcm1Gb3JBcmNMYWJlbCIsInRyYW5zbGF0ZSIsImNvbnZlcnRUb0FyY0RhdGEiLCJ0ZXh0Rm9yQXJjTGFiZWwiLCJzaG91bGRTaG93QXJjTGFiZWwiLCJoYXNHYXVnZSIsImlzVW5kZXJUaHJlc2hvbGQiLCJtZWV0c0FyY0xhYmVsVGhyZXNob2xkIiwiZ2V0QXJjTGFiZWxGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJ0ZXh0Rm9yR2F1Z2VNaW5NYXgiLCJpc01heCIsImdldEdhdWdlTGFiZWxFeHRlbnRzIiwiZXhwYW5kQXJjIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2VsZWN0b3JUYXJnZXRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJ1bmV4cGFuZEFyYyIsImlzRG9udXRUeXBlIiwiaXNQaWVUeXBlIiwidGhyZXNob2xkIiwiZ2V0QXJjVGl0bGUiLCJjbGFzc0NoYXJ0QXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NGb2N1cyIsIm1haW5QaWVVcGRhdGUiLCJtYWluUGllRW50ZXIiLCJpbml0QXJjIiwic2V0QXJjVGl0bGUiLCJoYXNJbnRlcmFjdGlvbiIsIm1haW5BcmMiLCJhcmNEYXRhIiwiY2xhc3NBcmMiLCJfY3VycmVudCIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJzZWxlY3RBcmMiLCJfdGhpcyIsImZvY3VzIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJ1bnNlbGVjdEFyYyIsInJldmVydCIsInJldmVydExlZ2VuZCIsImlzTW91c2UiLCJnZXRFdmVudEFyYyIsImV2ZW50QXJjIiwiaGFuZGxlciIsImlzRnVsbENpcmNsZSIsImluaXRHYXVnZSIsImFwcGVuZFRleHQiLCJpbml0QmFyIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQmFycyIsIm1haW5CYXJVcGRhdGUiLCJtYWluQmFyRW50ZXIiLCJiYXJEYXRhIiwiY2xhc3NCYXIiLCJpbml0aWFsT3BhY2l0eSIsImRyYXdCYXIiLCJnZXRCYXJXIiwiYmFyVGFyZ2V0c051bSIsInJlc3VsdCIsImdldFdpZHRoIiwiZ2V0QmFycyIsInN1ZmZpeCIsImJhckluZGljZXMiLCJnZXRQb2ludHMiLCJnZW5lcmF0ZUdldEJhclBvaW50cyIsImJhclJhZGl1cyIsImJhclJhZGl1c1JhdGlvIiwiZ2V0UmFkaXVzIiwicG9pbnRzIiwiaW5kZXhYIiwiaW5kZXhZIiwiaXNOZWdhdGl2ZSIsInBhdGhSYWRpdXMiLCJiYXJXIiwiYmFyWCIsImJhclkiLCJiYXJPZmZzZXQiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJjbGFzc0NoYXJ0TGluZSIsImNsYXNzTGluZXMiLCJjbGFzc0FyZWFzIiwiY2xhc3NDaXJjbGVzIiwibWFpbkxpbmVVcGRhdGUiLCJtYWluTGluZUVudGVyIiwiZ2VuZXJhdGVDbGFzcyIsImxpbmVEYXRhIiwiY2xhc3NMaW5lIiwiZHJhd0xpbmUiLCJnZXRDdXJ2ZSIsImlzUm90YXRlZFN0ZXBUeXBlIiwic3RlcCIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJsaW5lSW5kaWNlcyIsImxpbmVDb25uZWN0TnVsbCIsImdlbmVyYXRlR2V0TGluZVBvaW50cyIsInlTY2FsZUdldHRlciIsInhWYWx1ZSIsInN1Ynh4IiwieHgiLCJ5VmFsdWUiLCJkM0xpbmUiLCJkZWZpbmVkIiwieDAiLCJsaW5lV2l0aFJlZ2lvbnMiLCJjdXJ2ZSIsImlzU3ViVmFsdWUiLCJsaW5lVGFyZ2V0c051bSIsImxpbmVPZmZzZXQiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJ4T2Zmc2V0IiwiZGFzaGFycmF5IiwiaXNXaXRoaW5SZWdpb25zIiwid2l0aGluWCIsIndpdGhpblJlZ2lvbnMiLCJyZWciLCJnZXRWYWx1ZSIsImR0IiwiZ2VuZXJhdGVNIiwic1dpdGhSZWdpb24iLCJkMCIsImQxIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiZGQiLCJ1cGRhdGVBcmVhR3JhZGllbnQiLCJzdG9wcyIsImxpbmVhckdyYWRpZW50Iiwic3RvcENvbG9yIiwidXBkYXRlQXJlYUNvbG9yIiwiY2xhc3NBcmVhIiwib3JnQXJlYU9wYWNpdHkiLCJkcmF3QXJlYSIsImFyZWFJbmRpY2VzIiwiZ2VuZXJhdGVHZXRBcmVhUG9pbnRzIiwidmFsdWUwIiwidmFsdWUxIiwiZDNBcmVhIiwiYXJlYVRhcmdldHNOdW0iLCJhcmVhT2Zmc2V0Iiwic2hvdWxkRHJhd1BvaW50c0ZvckxpbmUiLCJsYWJlbGlzaERhdGEiLCJwb2ludFIiLCJpbml0aWFsT3BhY2l0eUZvckNpcmNsZSIsIm1haW5DaXJjbGVzIiwicG9zQXR0ciIsImlzQ2lyY2xlUG9pbnQiLCJnZXRDaXJjbGVzIiwicG9pbnRFeHBhbmRlZFIiLCJzZWxlY3RSIiwiaXMiLCJsaW5lUG9pbnQiLCJoYXNWYWxpZFBvaW50RHJhd01ldGhvZHMiLCJwb2ludFR5cGUiLCJ1cGRhdGUiLCJpbnNlcnRQb2ludEluZm9EZWZzIiwiY29weUF0dHIiLCJmcm9tIiwiYXR0cmlicyIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNsb25lIiwiY3JlYXRlRWxlbWVudE5TIiwiZDNOYW1lc3BhY2VzIiwiZmlsbCIsInN0cm9rZSIsImNoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJwb2ludEZyb21EZWZzIiwicG9pbnRDbGFzcyIsImNsYXNzQ2lyY2xlIiwicGF0dGVybiIsIm1ldGhvZCIsInBvaW50SWQiLCJjdXN0b20iLCJnZXRUcmFuc2l0aW9uTmFtZSIsInNpemVGbiIsImZpbGxTdHlsZUZuIiwieFBvc0ZuIiwieVBvc0ZuIiwib3BhY2l0eVN0eWxlRm4iLCJ4UG9zRm4yIiwidHJhbnNpdGlvbk5hbWUiLCJyZWN0YW5nbGUiLCJyZWN0U2l6ZUZuIiwicmVjdFhQb3NGbiIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibCIsImxldmVsVGV4dEZvcm1hdCIsImpvaW4iLCJsZXZlbEVudGVyIiwiYXhpc0VudGVyIiwiZmlyc3RDaGlsZCIsImJpbmRFdmVudCIsImhpZGUiLCJub0luZGV4IiwiYXJlYXNFbnRlciIsImNsYXNzQ2hhcnRSYWRhciIsImNsYXNzQ2hhcnRUZXh0IiwiY2xhc3NUZXh0cyIsIm1haW5UZXh0VXBkYXRlIiwibWFpblRleHRFbnRlciIsImRhdGFGbiIsImNsYXNzVGV4dCIsImlzUmFkYXJUeXBlIiwidXBkYXRlVGV4dENvbG9yIiwibGFiZWxDb2xvcnMiLCJmb3JGbG93Iiwib3BhY2l0eUZvclRleHQiLCJnZXRUZXh0UmVjdCIsImJhc2UiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJmb3JYIiwiZ2V0dGVyIiwiZ2V0WEZvclRleHQiLCJnZXRZRm9yVGV4dCIsImdldENlbnRlcmVkVGV4dFBvcyIsInRleHRFbGVtZW50IiwiY2VudGVyZWQiLCJpc1Bvc2l0aXZlIiwieVBvcyIsImJhc2VZIiwiYm94SGVpZ2h0IiwiVFlQRVMiLCJBcmVhIiwiQXJlYVJhbmdlIiwiQXJjIiwiTGluZSIsIlN0ZXAiLCJTcGxpbmUiLCJleGNsdWRlIiwiaXNUeXBlT2YiLCJkYXRhVHlwZSIsImJhckxpbmVCdWJibGVEYXRhIiwiZ2V0R3JpZFRleHRBbmNob3IiLCJnZXRHcmlkVGV4dER4IiwiZ2V0R3JpZFRleHRYIiwiaW5pdEdyaWRMaW5lcyIsImluaXRYWUZvY3VzR3JpZCIsImNsaXBQYXRoRm9yR3JpZCIsInVwZGF0ZVhHcmlkIiwieGdyaWREYXRhIiwiZ2VuZXJhdGVHcmlkRGF0YSIsInhncmlkQXR0ciIsInVwZGF0ZVlHcmlkIiwiZ3JpZFZhbHVlcyIsInNtb290aExpbmVzIiwidXBkYXRlWEdyaWRMaW5lcyIsInVwZGF0ZVlHcmlkTGluZXMiLCJ0cmltIiwieXYiLCJpc0Zyb250IiwiZGF0YVRvU2hvdyIsImZvY3VzRWwiLCJ0aWNrTnVtIiwiZ3JpZERhdGEiLCJmaXJzdFllYXIiLCJnZXRGdWxsWWVhciIsImxhc3RZZWFyIiwiZ2V0R3JpZEZpbHRlclRvUmVtb3ZlIiwicGFyYW0iLCJyZW1vdmVHcmlkTGluZXMiLCJ0b1JlbW92ZSIsImdldFRvb2x0aXBIVE1MIiwiZ2V0WUZvcm1hdCIsImdldFRvb2x0aXBDb250ZW50IiwiZGVmYXVsdFRpdGxlRm9ybWF0IiwiZGVmYXVsdFZhbHVlRm9ybWF0IiwidGl0bGVGb3JtYXQiLCJuYW1lRm9ybWF0IiwidmFsdWVGb3JtYXQiLCJnZXRSb3dWYWx1ZSIsImdldEJnQ29sb3IiLCJjb250ZW50cyIsInRwbFN0ciIsInRlbXBsYXRlIiwiaTIiLCJnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlIiwiQ0xBU1NfVE9PTFRJUCIsIlRJVExFIiwiaGlnaCIsImxvdyIsImNvbnRlbnRWYWx1ZSIsIkNMQVNTX1RPT0xUSVBfTkFNRSIsIkNPTE9SIiwiTkFNRSIsIlZBTFVFIiwidG9vbHRpcFBvc2l0aW9uIiwidFdpZHRoIiwidEhlaWdodCIsImNoYXJ0UmlnaHQiLCJkYXRhU2NhbGUiLCJmb3JBcmMiLCJwb3NpdGlvbkZ1bmN0aW9uIiwiZGF0YVN0ciIsInN0cmluZ2lmeSIsInByb3BlcnR5Iiwic2hvdyIsImxpbmtlZE5hbWUiLCJjaGFydHMiLCJpc0xpbmtlZCIsImlzSW5Eb20iLCJjb250YWlucyIsImlzTm90U2FtZUluZGV4IiwibGVnZW5kSXRlbVRleHRCb3giLCJsZWdlbmRIYXNSZW5kZXJlZCIsIm9wdGlvbnoiLCJ1cGRhdGVMZWdlbmRUZW1wbGF0ZSIsInVwZGF0ZUxlZ2VuZEVsZW1lbnQiLCJ3cmFwcGVyIiwiY29udGVudCIsInNldExlZ2VuZEl0ZW0iLCJpbnNldExlZ2VuZFBvc2l0aW9uIiwidXBkYXRlTGVnZW5kU3RlcCIsInVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCIsInVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJvcGFjaXR5Rm9yTGVnZW5kIiwib3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZCIsInRhcmdldElkeiIsInNob3dMZWdlbmQiLCJzZWxlY3RvckxlZ2VuZHMiLCJoaWRlTGVnZW5kIiwiY2xlYXJMZWdlbmRJdGVtVGV4dEJveENhY2hlIiwiaXRlbSIsIml0ZW1DbGFzcyIsImFsdEtleSIsInRvZ2dsZSIsInhGb3JMZWdlbmQiLCJ5Rm9yTGVnZW5kIiwiYmFja2dyb3VuZCIsInBvc01pbiIsInRpbGVXaWR0aCIsIm1heEhlaWdodCIsInRvdGFsTGVuZ3RoIiwib2Zmc2V0cyIsIndpZHRocyIsImhlaWdodHMiLCJtYXJnaW5zIiwic3RlcHMiLCJpc0xlZ2VuZFJpZ2h0T3JJbnNldCIsImdldFRleHRCb3giLCJ1cGRhdGVQb3NpdGlvbnMiLCJpc0xhc3QiLCJib3giLCJpdGVtV2lkdGgiLCJpdGVtSGVpZ2h0IiwiaXRlbUxlbmd0aCIsImFyZWFMZW5ndGgiLCJ1cGRhdGVWYWx1ZXMiLCJpZDIiLCJ3aXRob3V0U3RlcCIsIm1heExlbmd0aCIsInhGb3JMZWdlbmRUZXh0IiwieEZvckxlZ2VuZFJlY3QiLCJ4MUZvckxlZ2VuZFRpbGUiLCJ4MkZvckxlZ2VuZFRpbGUiLCJ5Rm9yTGVnZW5kVGV4dCIsInlGb3JMZWdlbmRSZWN0IiwieUZvckxlZ2VuZFRpbGUiLCJ1c2VQb2ludCIsInJlY3RzIiwidGlsZXMiLCJ5T2Zmc2V0IiwiZ2V0VGV4dFBvcyIsImlzTnVtIiwieUZvclRpdGxlIiwieEZvclRpdGxlIiwiZ2V0Q2xpcFBhdGgiLCJpc0lFOSIsImFwcFZlcnNpb24iLCJVUkwiLCJnZXRBeGlzQ2xpcFgiLCJnZXRBeGlzQ2xpcFkiLCJnZXRBeGlzQ2xpcFdpZHRoIiwiZ2V0QXhpc0NsaXBIZWlnaHQiLCJtYWluUmVnaW9uIiwiY2xhc3NSZWdpb24iLCJyZWdpb25YIiwicmVnaW9uWSIsInJlZ2lvbldpZHRoIiwicmVnaW9uSGVpZ2h0IiwiZ2V0UmVnaW9uWFkiLCJnZXRSZWdpb25TaXplIiwiaXNXaWR0aCIsImlzUmVnaW9uT25YIiwiYWx0RG9tYWluIiwic3giLCJzeSIsIm14IiwibXkiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwiaXNTZWxlY3RlZCIsImlzSW5jbHVkZWQiLCJ0b2dnbGVQb2ludCIsInRvZ2dsZVBhdGgiLCJzZXREcmFnU3RhdHVzIiwiaXNEcmFnZ2luZyIsInNlbGVjdFBvaW50IiwidW5zZWxlY3RQb2ludCIsInNlbGVjdFBhdGgiLCJkM1JnYiIsImJyaWdodGVyIiwidW5zZWxlY3RQYXRoIiwiZ2V0VG9nZ2xlIiwidG9nZ2xlZFNoYXBlIiwiaW5pdEJydXNoIiwiZDNCcnVzaFkiLCJkM0JydXNoWCIsImxhc3REb21haW4iLCJ0aW1lb3V0IiwiYnJ1c2hIYW5kbGVyIiwicmVkcmF3Rm9yQnJ1c2giLCJnZXRCcnVzaFNpemUiLCJ1cGRhdGVSZXNpemUiLCJnZXRTZWxlY3Rpb24iLCJtb3ZlIiwiZXh0ZW50IiwiZ2V0RXh0ZW50IiwidmlzaWJpbGl0eSIsImNvbnRleHRCYXJVcGRhdGUiLCJjb250ZXh0QmFyRW50ZXIiLCJjb250ZXh0TGluZVVwZGF0ZSIsImNvbnRleHRMaW5lRW50ZXIiLCJ1cGRhdGVCYXJGb3JTdWJjaGFydCIsImNvbnRleHRCYXIiLCJyZWRyYXdCYXJGb3JTdWJjaGFydCIsImRyYXdCYXJPblN1YiIsInVwZGF0ZUxpbmVGb3JTdWJjaGFydCIsImNvbnRleHRMaW5lIiwicmVkcmF3TGluZUZvclN1YmNoYXJ0IiwiZHJhd0xpbmVPblN1YiIsInVwZGF0ZUFyZWFGb3JTdWJjaGFydCIsImNvbnRleHRBcmVhIiwicmVkcmF3QXJlYUZvclN1YmNoYXJ0IiwiZHJhd0FyZWFPblN1YiIsImRyYXciLCJ3aXRoRGltZW5zaW9uIiwiZ2VuZXJhdGVab29tIiwiaW5pdFpvb21CZWhhdmlvdXIiLCJiaW5kWm9vbU9uRXZlbnRSZWN0IiwidW56b29tIiwiZDNab29tIiwib25ab29tU3RhcnQiLCJvblpvb20iLCJvblpvb21FbmQiLCJvcmdTY2FsZUV4dGVudCIsInVwZGF0ZVRyYW5zZm9ybVNjYWxlIiwidHJhbnNmb3JtIiwicmVzY2FsZSIsInNvdXJjZUV2ZW50Iiwic3RhcnRFdmVudCIsImlzTW91c2Vtb3ZlIiwiaXNab29tT3V0Iiwid2hlZWxEZWx0YSIsInVwZGF0ZVpvb20iLCJkZWx0YSIsImlzZnVsbHlTaG93biIsImJlaGF2aW91ciIsInpvb21CZWhhdmlvdXIiLCJwcm9wIiwiY2xpY2tEaXN0YW5jZSIsInNldFpvb21SZXNldEJ1dHRvbiIsInJlc2V0QnV0dG9uIiwicmVzZXRCdG4iLCJjb2xvcml6ZVBhdHRlcm4iLCJjbG9uZU5vZGUiLCJzY2hlbWVDYXRlZ29yeTEwIiwiZ2V0Q29sb3JGcm9tQ3NzIiwic3BhbiIsImdldENvbXB1dGVkU3R5bGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJyZW1vdmVDaGlsZCIsIkJvb2xlYW4iLCJjb2xvcnMiLCJkM1NjYWxlT3JkaW5hbCIsIm9yaWdpbmFsQ29sb3JQYXR0ZXJuIiwiY29sb3JpemVkUGF0dGVybnMiLCJpc0xpbmUiLCJhc1ZhbHVlIiwiZ2V0Rm9ybWF0IiwidHlwZVZhbHVlIiwiZm9ybWF0Rm9yWSIsInlGb3JtYXQiLCJmb3JtYXRGb3JZMiIsInkyRm9ybWF0IiwiZGVmYXVsdEZvcm1hdCIsImlzRGF0YVR5cGUiLCJyZW1vdmVDYWNoZSIsImFsbCIsImNsYXNzU2hhcGUiLCJjbGFzc1NoYXBlcyIsImNsYXNzZXMiLCJjbGFzc1RhcmdldCIsImFkZGl0aW9uYWxDbGFzc1N1ZmZpeCIsImFkZGl0aW9uYWxDbGFzcyIsImNsYXNzRm9jdXNlZCIsImNsYXNzRGVmb2N1c2VkIiwiaWRzVmFsdWUiLCJzZWxlY3RvckxlZ2VuZCIsInRhcmdldElkc1ZhbHVlIiwiZGVmb2N1cyIsIl9zaG93SGlkZSIsIndpdGhpblJhbmdlIiwicmVzdWx0RG9tYWluIiwiZW5hYmxlIiwiZW5hYmxlZCIsImVuYWJsZVR5cGUiLCJ1cGRhdGVBbmRSZWRyYXciLCJkM1pvb21JZGVudGl0eSIsImQzWm9vbVRyYW5zZm9ybSIsIm5hbWVzIiwiYXJnc1ZhbHVlIiwidG8iLCJ0YWlsIiwibm90Zm91bmRJZHMiLCJvcmdEYXRhQ291bnQiLCJtaXNzaW5nIiwiYmFzZVRhcmdldCIsImJhc2VWYWx1ZSIsIndpdGhUcmltWERvbWFpbiIsIndpdGhVcGRhdGVYQXhpcyIsInRyYW5zbGF0ZVgiLCJzY2FsZVgiLCJmbG93SW5kZXgiLCJmbG93TGVuZ3RoIiwiZmxvd1N0YXJ0IiwiZmxvd0VuZCIsImR1cmF0aW9uRm9yRmxvdyIsIndhaXQiLCJndCIsImVhc2UiLCJkM0Vhc2VMaW5lYXIiLCJzZXRUcmFuc2l0aW9uIiwieEZ1bmMiLCJ5RnVuYyIsImRhdGFQb2ludCIsInJlc2V0T3RoZXIiLCJpc1RhcmdldElkIiwiaXNUYXJnZXRJbmRleCIsInVuc2VsZWN0IiwidHJhbnNmb3JtVG8iLCJvcHRpb25zRm9yUmVkcmF3IiwiZ3JpZHMiLCJyZWRyYXdXaXRob3V0UmVzY2FsZSIsIm9wdGlvbnNWYWx1ZSIsImZsYXQiLCJkYXRhVmFsdWUiLCJjYXRlZ29yeSIsInNldE1pbk1heCIsInNldExhYmVsVGV4dCIsInJlc2l6ZSIsInNvZnQiLCJpc0Zyb21SZXNpemUiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImI2NEVuY29kZVVuaWNvZGUiLCJidG9hIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJub2RlVG9TdmdEYXRhVXJsIiwic2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJjc3NUZXh0IiwieGh0bWwiLCJub2RlWG1sIiwic2VyaWFsaXplVG9TdHJpbmciLCJjcmVhdGVUZXh0Tm9kZSIsInN0eWxlWG1sIiwic3ZnRGF0YVVybCIsImltZyIsIkltYWdlIiwiY3Jvc3NzT3JpZ2luIiwib25sb2FkIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsInNyYyIsImRlZmF1bHRzIiwiYmIiLCJ2ZXJz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QU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSw4WEFBOFg7QUFDalk7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGdGQUFnRjtBQUNuRjtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdHQUF3RztBQUMzRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUscUZBQXFGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhC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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHlCQUF5QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSxpQ0FBaUM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLGtHQUFrRztBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLENBQUMsRUFBRSwrRkFBK0Y7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7O0FBRUEsQ0FBQyxFQUFFLDBFQUEwRTtBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLENBQUMsRUFBRSx1R0FBdUc7QUFDMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsNkhBQTZIO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0MsaURBQWlEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBb0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzN0QkE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLEtBQTBCO0FBQzdDO0FBQ0Esa0JBQWtCLEtBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RFI7QUFBQSxRQUVWeTNELElBQUksR0FBRyxJQUFJcndDLFdBQUosQ0FBVTd2QixPQUFWLENBRkc7QUFPaEIsV0FIQWtnRSxJQUFJLENBQUNwd0MsUUFBTCxDQUFjbStCLE1BQWQsR0FBdUIsS0FBS2tTLFFBRzVCLEVBRkEsS0FBS0EsUUFBTCxDQUFjOTVELElBQWQsQ0FBbUI2NUQsSUFBbkIsQ0FFQSxFQUFPQSxJQUFQO0FBQ0EsR0E1Q1M7O0FBOENWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBSixVQXBFVSxvQkFvRUQ5L0QsT0FwRUMsRUFvRVE7QUFLakIsV0FKSUosUUFBUSxDQUFDSSxPQUFELENBSVosS0FIQzgvRCxTQUFRLEdBQUc5L0QsT0FHWixHQUFPOC9ELFNBQVA7QUFDQSxHQTFFUzs7QUE0RVY7Ozs7Ozs7Ozs7O0FBV0FLLFVBQVEsRUFBRSxFQXZGQTs7QUF5RlY7Ozs7Ozs7O0FBUUFDLFFBQU0sRUFBRSxFQWpHRTs7QUFtR1Y7Ozs7QUFJQTltRSxPQUFLLEVBQUU7QUFDTm1ILE1BQUUsRUFBRW92QixXQUFLLENBQUNPLFNBREo7QUFFTk4sWUFBUSxFQUFFO0FBQ1RydkIsUUFBRSxFQUFFc1osMkJBQWEsQ0FBQ3FXLFNBRFQ7QUFFVDEzQixVQUFJLEVBQUU7QUFDTCtILFVBQUUsRUFBRTRQLFNBQUksQ0FBQytmO0FBREo7QUFGRztBQUZKO0FBdkdHLEM7QUFKWDs7Ozs7QUFzSEE7QUFDZTJ2Qyw0RUFBZixFIiwiZmlsZSI6ImJpbGxib2FyZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImQzLXRpbWUtZm9ybWF0XCIsIFwiZDMtc2VsZWN0aW9uXCIsIFwiZDMtdHJhbnNpdGlvblwiLCBcImQzLWF4aXNcIiwgXCJkMy1icnVzaFwiLCBcImQzLXNjYWxlXCIsIFwiZDMtZHN2XCIsIFwiZDMtZHJhZ1wiLCBcImQzLXNoYXBlXCIsIFwiZDMtaW50ZXJwb2xhdGVcIiwgXCJkMy1jb2xvclwiLCBcImQzLXpvb21cIiwgXCJkMy1lYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181Ml9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181OF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181OV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MV9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gKi9cblxuLyogZXNsaW50LWRpc2FibGVcbiAgY2FtZWxjYXNlXG4qL1xuLy8gdGhpcyBTb2NrSlNDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgaW5saW5lIG1vZGVcbi8vIGlzIG9mZiBvciB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZC4gVGhpcyB3aWxsIGJlIHN3aXRjaGVkIHRvXG4vLyBXZWJzb2NrZXRDbGllbnQgd2hlbiBpdCBiZWNvbWVzIHRoZSBkZWZhdWx0XG4vLyBpbXBvcnRhbnQ6IHRoZSBwYXRoIHRvIFNvY2tKU0NsaWVudCBoZXJlIGlzIG1hZGUgdG8gd29yayBpbiB0aGUgJ2NsaWVudCdcbi8vIGRpcmVjdG9yeSwgYnV0IGlzIHVwZGF0ZWQgdmlhIHRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIHdoZW4gY29tcGlsZWQgZnJvbVxuLy8gdGhlICdjbGllbnQtc3JjJyBkaXJlY3RvcnlcblxudmFyIENsaWVudCA9IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlQ2xpZW50KSB7XG4gIF9pbmhlcml0cyhTb2NrSlNDbGllbnQsIF9CYXNlQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTb2NrSlNDbGllbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgICBfdGhpcy5zb2NrLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7Ly8gVE9ETzogdXNlIGxvZ2dlciB0byBsb2cgdGhlIGVycm9yIGV2ZW50IG9uY2UgY2xpZW50IGFuZCBjbGllbnQtc3JjXG4gICAgICAvLyBhcmUgcmVvcmdhbml6ZWQgdG8gaGF2ZSB0aGUgc2FtZSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrSlNDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5zb2NrLm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmKGUuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKCcuL1NvY2tKU0NsaWVudCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyIsIi8qIHNvY2tqcy1jbGllbnQgdjEuMy4wIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwOidcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgRXZlbnRTb3VyY2VSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvZXZlbnRzb3VyY2UnKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFFdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xufTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2V2ZW50c291cmNlXCI6MjksXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9odG1sZmlsZVwiOjMwLFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi91dGlscy9yYW5kb21cIjo1MCxcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCIuL3JlY2VpdmVyL2pzb25wXCI6MzEsXCIuL3NlbmRlci9qc29ucFwiOjMzLFwiaW5oZXJpdHNcIjo1N31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo0OSxcIi4uL2lmcmFtZVwiOjIyLFwiaW5oZXJpdHNcIjo1N31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XG59XG5cbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xuICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID9cbiAgICAgIGlmcmFtZVV0aWxzLmNyZWF0ZUh0bWxmaWxlIDogaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lO1xuXG4gIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcbiAgICAgIHNlbGYuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIH1cbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfVxuICAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0b3AnKTtcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgfVxuICB9O1xuICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnY2FsbGJhY2snKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UoJ3Blcm1hbmVudCcpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSHRtbGZpbGVSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ19jbG9zZScsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoYXhvIGluIGdsb2JhbCkge1xuICB0cnkge1xuICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcIi4veGRyLXN0cmVhbWluZ1wiOjQwLFwiaW5oZXJpdHNcIjo1N31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcImluaGVyaXRzXCI6NTd9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuMy4wJztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2NvbW1vblwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cblxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5lZWRzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDbGllbnQ7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKSxcbiAgICBBbGxIdG1sRW50aXRpZXMgPSBfcmVxdWlyZS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBBbGxIdG1sRW50aXRpZXMoKTtcbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXG4gIGJsYWNrOiAnMTgxODE4JyxcbiAgcmVkOiAnRTM2MDQ5JyxcbiAgZ3JlZW46ICdCM0NCNzQnLFxuICB5ZWxsb3c6ICdGRkQwODAnLFxuICBibHVlOiAnN0NBRkMyJyxcbiAgbWFnZW50YTogJzdGQUNDQScsXG4gIGN5YW46ICdDM0MyRUYnLFxuICBsaWdodGdyZXk6ICdFQkU3RTMnLFxuICBkYXJrZ3JleTogJzZENzg5MSdcbn07XG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKG9uT3ZlcmxheURpdlJlYWR5KSB7XG4gIGlmIChvdmVybGF5RGl2KSB7XG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICBvbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxuICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIGNhbGxzLCBsYXN0IGNhbGxiYWNrIHdpbnMuXG5cblxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcblxuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBpdC5cbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cblxuXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBvdmVybGF5RGl2ID0gYWRkT3ZlcmxheURpdlRvKG92ZXJsYXlJZnJhbWUpOyAvLyBOb3cgd2UgY2FuIHRhbGshXG5cbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gIH0pOyAvLyBaYWxnbyBhbGVydDogb25JZnJhbWVMb2FkKCkgd2lsbCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHlcbiAgLy8gb3IgYXN5bmNocm9ub3VzbHkgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLlxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG59IC8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5cblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9IC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cblxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2UobWVzc2FnZXMpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI1wiLmNvbmNhdChjb2xvcnMucmVkLCBcIlxcXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+XCIpLmNvbmNhdChhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZXNbMF0pKSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xlYXI6IGNsZWFyLFxuICBzaG93TWVzc2FnZTogc2hvd01lc3NhZ2Vcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxuICBIdG1sNEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNC1lbnRpdGllcy5qcycpLFxuICBIdG1sNUVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpLFxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcbn07XG4iLCJ2YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcblxudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcblxudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88fD58XCJ8J3wmL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XG4iLCJ2YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuXG52YXIgaSA9IDA7XG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG53aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgbnVtSW5kZXhbY10gPSBhO1xuICAgIGkrKztcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw0RW50aXRpZXM7XG4iLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIElORk86XG4gICAgY2FzZSBXQVJOOlxuICAgIGNhc2UgRVJST1I6XG4gICAgY2FzZSBERUJVRzpcbiAgICBjYXNlIFRSQUNFOlxuICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgV0FSTklORzpcbiAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIE5PTkU6XG4gICAgY2FzZSBTSUxFTlQ6XG4gICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cblxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZW5kTXNnOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIGhvdFJlbG9hZCA9IF9yZWYuaG90UmVsb2FkLFxuICAgICAgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICAgIGN1cnJlbnRIYXNoID0gX3JlZjIuY3VycmVudEhhc2g7XG5cbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7XG5cbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcblxuICAgIGhvdEVtaXR0ZXIuZW1pdCgnd2VicGFja0hvdFVwZGF0ZScsIGN1cnJlbnRIYXNoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChjdXJyZW50SGFzaCksICcqJyk7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQpIHtcbiAgICAgIHZhciByb290V2luZG93ID0gc2VsZjsgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG5cbiAgICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcblxuICAgICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVsb2FkQXBwOyIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBzZWxmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxudmFyIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgPSByZXF1aXJlKCcuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UnKTtcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VXJsKHJlc291cmNlUXVlcnkpIHtcbiAgdmFyIHVybFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2VRdWVyeSA9PT0gJ3N0cmluZycgJiYgcmVzb3VyY2VRdWVyeSAhPT0gJycpIHtcbiAgICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gICAgc2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnJyk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcbiAgICB1cmxQYXJ0cy5wb3J0ID0gc2VsZi5sb2NhdGlvbi5wb3J0O1xuICB9XG5cbiAgdmFyIF91cmxQYXJ0cyA9IHVybFBhcnRzLFxuICAgICAgYXV0aCA9IF91cmxQYXJ0cy5hdXRoLFxuICAgICAgcGF0aCA9IF91cmxQYXJ0cy5wYXRoO1xuICB2YXIgX3VybFBhcnRzMiA9IHVybFBhcnRzLFxuICAgICAgaG9zdG5hbWUgPSBfdXJsUGFydHMyLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2wgPSBfdXJsUGFydHMyLnByb3RvY29sOyAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cbiAgdmFyIGlzQW55SG9zdG5hbWUgPSAoaG9zdG5hbWUgPT09ICcwLjAuMC4wJyB8fCBob3N0bmFtZSA9PT0gJzo6JykgJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAhIX5zZWxmLmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKTtcblxuICBpZiAoaXNBbnlIb3N0bmFtZSkge1xuICAgIGhvc3RuYW1lID0gc2VsZi5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgfSAvLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4gIC8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcbiAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5cblxuICBpZiAoaG9zdG5hbWUgJiYgKHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XG4gICAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xuICB9IC8vIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBzb2NrIHVybCBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuXG4gIHZhciBzb2NrSG9zdCA9IGhvc3RuYW1lO1xuICB2YXIgc29ja1BhdGggPSAnL3NvY2tqcy1ub2RlJztcbiAgdmFyIHNvY2tQb3J0ID0gdXJsUGFydHMucG9ydDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuXG4gIHZhciBzaG91bGRQYXJzZVBhdGggPSBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHVuZGVmaW5lZCAmJiBwYXRoICE9PSAnLyc7XG5cbiAgaWYgKHNob3VsZFBhcnNlUGF0aCkge1xuICAgIHZhciBwYXJzZWRRdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHBhdGgpOyAvLyBhbGwgb2YgdGhlc2Ugc29jayB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoXG4gICAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgICAvLyB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuICAgIHNvY2tIb3N0ID0gcGFyc2VkUXVlcnkuc29ja0hvc3QgfHwgc29ja0hvc3Q7XG4gICAgc29ja1BhdGggPSBwYXJzZWRRdWVyeS5zb2NrUGF0aCB8fCBzb2NrUGF0aDtcbiAgICBzb2NrUG9ydCA9IHBhcnNlZFF1ZXJ5LnNvY2tQb3J0IHx8IHNvY2tQb3J0O1xuICB9XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBhdXRoOiBhdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrSG9zdCxcbiAgICBwb3J0OiBzb2NrUG9ydCxcbiAgICAvLyBJZiBzb2NrUGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgICAvLyBxdWVyeSBwYXJhbSBzbyBpdCBoYXMgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcXVlcnlzdHJpbmcgaW4gb3JkZXIgZm9yIHRoZVxuICAgIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgcGF0aG5hbWU6IHNvY2tQYXRoXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNvY2tldFVybDsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDMyXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzE7IiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9iaWxsYm9hcmQuc2Nzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qLS0gQ2hhcnQgLS0qL1xcbi5iYiBzdmcge1xcbiAgZm9udDogMTBweCBHb3RoYW1Qcm87XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxuICBmaWxsOiAjNUQ1QzcxOyB9XFxuXFxuLmJiIHBhdGgsIC5iYiBsaW5lIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMwMDA7IH1cXG5cXG4uYmIgdGV4dCwgLmJiIC5iYi1idXR0b24ge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS10aWxlLFxcbi5iYi14Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQsXFxuLmJiLWV2ZW50LXJlY3QsXFxuLmJiLWJhcnMgcGF0aCB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHBhdGgge1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyB0ZXh0IHtcXG4gIGZpbGw6ICNmZmY7XFxuICBmb250LXNpemU6IDEzcHg7IH1cXG5cXG4vKi0tIEF4aXMgLS0qL1xcbi5iYi1heGlzIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi8qLS0gR3JpZCAtLSovXFxuLmJiLWdyaWQgbGluZSB7XFxuICBzdHJva2U6ICNhYWE7IH1cXG5cXG4uYmItZ3JpZCB0ZXh0IHtcXG4gIGZpbGw6ICNhYWE7IH1cXG5cXG4uYmIteGdyaWQsIC5iYi15Z3JpZCB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAzIDM7IH1cXG5cXG4vKi0tIFRleHQgb24gQ2hhcnQgLS0qL1xcbi5iYi10ZXh0LmJiLWVtcHR5IHtcXG4gIGZpbGw6ICM4MDgwODA7XFxuICBmb250LXNpemU6IDJlbTsgfVxcblxcbi8qLS0gTGluZSAtLSovXFxuLmJiLWxpbmUge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIFBvaW50IC0tKi9cXG4uYmItY2lyY2xlLl9leHBhbmRlZF8ge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxuICBzdHJva2U6IHdoaXRlOyB9XFxuXFxuLmJiLXNlbGVjdGVkLWNpcmNsZSB7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLyotLSBCYXIgLS0qL1xcbi5iYi1iYXIge1xcbiAgc3Ryb2tlLXdpZHRoOiAwOyB9XFxuICAuYmItYmFyLl9leHBhbmRlZF8ge1xcbiAgICBmaWxsLW9wYWNpdHk6IDAuNzU7IH1cXG5cXG4vKi0tIEZvY3VzIC0tKi9cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMTsgfVxcblxcbi5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLXN0ZXAge1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWRlZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAwLjMgIWltcG9ydGFudDsgfVxcblxcbi8qLS0gUmVnaW9uIC0tKi9cXG4uYmItcmVnaW9uIHtcXG4gIGZpbGw6IHN0ZWVsYmx1ZTtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFpvb20gcmVnaW9uIC0tKi9cXG4uYmItem9vbS1icnVzaCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBCcnVzaCAtLSovXFxuLmJiLWJydXNoIC5leHRlbnQge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gU2VsZWN0IC0gRHJhZyAtLSovXFxuLyotLSBMZWdlbmQgLS0qL1xcbi5iYi1sZWdlbmQtaXRlbSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMC4xNTsgfVxcblxcbi5iYi1sZWdlbmQtYmFja2dyb3VuZCB7XFxuICBvcGFjaXR5OiAwLjc1O1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2U6IGxpZ2h0Z3JheTtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi8qLS0gVGl0bGUgLS0qL1xcbi5iYi10aXRsZSB7XFxuICBmb250OiAxNHB4IEdvdGhhbVBybzsgfVxcblxcbi8qLS0gVG9vbHRpcCAtLSovXFxuLmJiLXRvb2x0aXAtY29udGFpbmVyIHtcXG4gIHotaW5kZXg6IDEwOyB9XFxuXFxuLmJiLXRvb2x0aXAge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGVtcHR5LWNlbGxzOiBzaG93O1xcbiAgb3BhY2l0eTogMC45O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgLW1vei1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NzsgfVxcbiAgLmJiLXRvb2x0aXAgdHIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDOyB9XFxuICAuYmItdG9vbHRpcCB0aCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgcGFkZGluZzogMnB4IDVweDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgY29sb3I6ICNGRkY7IH1cXG4gIC5iYi10b29sdGlwIHRkIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBwYWRkaW5nOiAzcHggNnB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRvdHRlZCAjOTk5OyB9XFxuICAgIC5iYi10b29sdGlwIHRkID4gc3BhbiwgLmJiLXRvb2x0aXAgdGQgPiBzdmcge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogMTBweDtcXG4gICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7IH1cXG4gIC5iYi10b29sdGlwLnZhbHVlIHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4vKi0tIEFyZWEgLS0qL1xcbi5iYi1hcmVhIHtcXG4gIHN0cm9rZS13aWR0aDogMDtcXG4gIG9wYWNpdHk6IDAuMjsgfVxcblxcbi8qLS0gQXJjIC0tKi9cXG4uYmItY2hhcnQtYXJjcy10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAxLjNlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDIuN2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZCB7XFxuICBmaWxsOiAjZTBlMGUwO1xcbiAgc3Ryb2tlOiBub25lOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdCB7XFxuICBmaWxsOiAjMDAwO1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4IHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1taW4ge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi5iYi1jaGFydC1hcmMgLmJiLWdhdWdlLXZhbHVlIHtcXG4gIGZpbGw6ICMwMDA7IH1cXG5cXG4vKi0tIFJhZGFyIC0tKi9cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgcG9seWdvbiB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHRleHQge1xcbiAgZmlsbDogIzg0ODI4MjsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgbGluZSB7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIHRleHQge1xcbiAgZm9udC1zaXplOiAxLjE1ZW07XFxuICBjdXJzb3I6IGRlZmF1bHQ7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1zaGFwZXMgcG9seWdvbiB7XFxuICBmaWxsLW9wYWNpdHk6IC4yO1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIEJ1dHRvbiAtLSovXFxuLmJiLWJ1dHRvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwcHg7XFxuICByaWdodDogMTBweDsgfVxcbiAgLmJiLWJ1dHRvbiAuYmItem9vbS1yZXNldCB7XFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggI2NjYztcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbmgyI3RpdGxlIHtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIHRleHQtdHJhbnNmb3JtOiBcXFwidXBwZXJjYXNlXFxcIjsgfVxcblwiLCBcIlwiXSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIntcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gbW9kdWxlc1tfaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiKFwiLmNvbmNhdChpdGVtWzJdLCBcIikgYW5kIChcIikuY29uY2F0KG1lZGlhUXVlcnksIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290KS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZXMgPSBbXTtcbiAgdmFyIG5ld1N0eWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY3NzID0gaXRlbVsxXTtcbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdO1xuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH07XG5cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcGFydHM6IFtwYXJ0XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrKztcblxuICAgICAgZm9yICg7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHJlZnM6IDEsXG4gICAgICAgIHBhcnRzOiBwYXJ0c1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYXR0cmlidXRlcyA6IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG4gICAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgICAgZG9tU3R5bGUucmVmcy0tO1xuICAgICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICBhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtYXlSZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2RvbVN0eWxlID0gbWF5UmVtb3ZlW19pXTtcblxuICAgICAgaWYgKF9kb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2RvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgX2RvbVN0eWxlLnBhcnRzW2pdKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bX2RvbVN0eWxlLmlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXzsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181Ml9fOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogV2luZG93IG9iamVjdFxuICogQG1vZHVsZVxuICogQGlnbm9yZVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cbmNvbnN0IHdpbiA9ICgoKSA9PiB7XG5cdGNvbnN0IGRlZiA9IG8gPT4gdHlwZW9mIG8gIT09IFwidW5kZWZpbmVkXCIgJiYgbztcblxuXHRyZXR1cm4gZGVmKHNlbGYpIHx8IGRlZih3aW5kb3cpIHx8IGRlZihnbG9iYWwpIHx8IGRlZihnbG9iYWxUaGlzKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59KSgpO1xuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cblxuY29uc3QgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuZXhwb3J0IHtcblx0d2luIGFzIHdpbmRvdyxcblx0ZG9jIGFzIGRvY3VtZW50XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181N19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNThfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjFfXzsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKipcbiAqIENTUyBjbGFzcyBuYW1lcyBkZWZpbml0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cdGFyYzogXCJiYi1hcmNcIixcblx0YXJjczogXCJiYi1hcmNzXCIsXG5cdGFyZWE6IFwiYmItYXJlYVwiLFxuXHRhcmVhczogXCJiYi1hcmVhc1wiLFxuXHRheGlzOiBcImJiLWF4aXNcIixcblx0YXhpc1g6IFwiYmItYXhpcy14XCIsXG5cdGF4aXNYTGFiZWw6IFwiYmItYXhpcy14LWxhYmVsXCIsXG5cdGF4aXNZOiBcImJiLWF4aXMteVwiLFxuXHRheGlzWTI6IFwiYmItYXhpcy15MlwiLFxuXHRheGlzWTJMYWJlbDogXCJiYi1heGlzLXkyLWxhYmVsXCIsXG5cdGF4aXNZTGFiZWw6IFwiYmItYXhpcy15LWxhYmVsXCIsXG5cdGJhcjogXCJiYi1iYXJcIixcblx0YmFyczogXCJiYi1iYXJzXCIsXG5cdGJydXNoOiBcImJiLWJydXNoXCIsXG5cdGJ1dHRvbjogXCJiYi1idXR0b25cIixcblx0YnV0dG9uWm9vbVJlc2V0OiBcImJiLXpvb20tcmVzZXRcIixcblx0Y2hhcnQ6IFwiYmItY2hhcnRcIixcblx0Y2hhcnRBcmM6IFwiYmItY2hhcnQtYXJjXCIsXG5cdGNoYXJ0QXJjczogXCJiYi1jaGFydC1hcmNzXCIsXG5cdGNoYXJ0QXJjc0JhY2tncm91bmQ6IFwiYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kXCIsXG5cdGNoYXJ0QXJjc0dhdWdlTWF4OiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4XCIsXG5cdGNoYXJ0QXJjc0dhdWdlTWluOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluXCIsXG5cdGNoYXJ0QXJjc0dhdWdlVW5pdDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXVuaXRcIixcblx0Y2hhcnRBcmNzVGl0bGU6IFwiYmItY2hhcnQtYXJjcy10aXRsZVwiLFxuXHRjaGFydEFyY3NHYXVnZVRpdGxlOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGVcIixcblx0Y2hhcnRCYXI6IFwiYmItY2hhcnQtYmFyXCIsXG5cdGNoYXJ0QmFyczogXCJiYi1jaGFydC1iYXJzXCIsXG5cdGNoYXJ0TGluZTogXCJiYi1jaGFydC1saW5lXCIsXG5cdGNoYXJ0TGluZXM6IFwiYmItY2hhcnQtbGluZXNcIixcblx0Y2hhcnRSYWRhcjogXCJiYi1jaGFydC1yYWRhclwiLFxuXHRjaGFydFJhZGFyczogXCJiYi1jaGFydC1yYWRhcnNcIixcblx0Y2hhcnRUZXh0OiBcImJiLWNoYXJ0LXRleHRcIixcblx0Y2hhcnRUZXh0czogXCJiYi1jaGFydC10ZXh0c1wiLFxuXHRjaXJjbGU6IFwiYmItY2lyY2xlXCIsXG5cdGNpcmNsZXM6IFwiYmItY2lyY2xlc1wiLFxuXHRjb2xvclBhdHRlcm46IFwiYmItY29sb3ItcGF0dGVyblwiLFxuXHRjb2xvclNjYWxlOiBcImJiLWNvbG9yc2NhbGVcIixcblx0ZGVmb2N1c2VkOiBcImJiLWRlZm9jdXNlZFwiLFxuXHRkcmFnYXJlYTogXCJiYi1kcmFnYXJlYVwiLFxuXHRlbXB0eTogXCJiYi1lbXB0eVwiLFxuXHRldmVudFJlY3Q6IFwiYmItZXZlbnQtcmVjdFwiLFxuXHRldmVudFJlY3RzOiBcImJiLWV2ZW50LXJlY3RzXCIsXG5cdGV2ZW50UmVjdHNNdWx0aXBsZTogXCJiYi1ldmVudC1yZWN0cy1tdWx0aXBsZVwiLFxuXHRldmVudFJlY3RzU2luZ2xlOiBcImJiLWV2ZW50LXJlY3RzLXNpbmdsZVwiLFxuXHRmb2N1c2VkOiBcImJiLWZvY3VzZWRcIixcblx0Z2F1Z2VWYWx1ZTogXCJiYi1nYXVnZS12YWx1ZVwiLFxuXHRncmlkOiBcImJiLWdyaWRcIixcblx0Z3JpZExpbmVzOiBcImJiLWdyaWQtbGluZXNcIixcblx0bGVnZW5kQmFja2dyb3VuZDogXCJiYi1sZWdlbmQtYmFja2dyb3VuZFwiLFxuXHRsZWdlbmRJdGVtOiBcImJiLWxlZ2VuZC1pdGVtXCIsXG5cdGxlZ2VuZEl0ZW1FdmVudDogXCJiYi1sZWdlbmQtaXRlbS1ldmVudFwiLFxuXHRsZWdlbmRJdGVtRm9jdXNlZDogXCJiYi1sZWdlbmQtaXRlbS1mb2N1c2VkXCIsXG5cdGxlZ2VuZEl0ZW1IaWRkZW46IFwiYmItbGVnZW5kLWl0ZW0taGlkZGVuXCIsXG5cdGxlZ2VuZEl0ZW1Qb2ludDogXCJiYi1sZWdlbmQtaXRlbS1wb2ludFwiLFxuXHRsZWdlbmRJdGVtVGlsZTogXCJiYi1sZWdlbmQtaXRlbS10aWxlXCIsXG5cdGxldmVsOiBcImJiLWxldmVsXCIsXG5cdGxldmVsczogXCJiYi1sZXZlbHNcIixcblx0bGluZTogXCJiYi1saW5lXCIsXG5cdGxpbmVzOiBcImJiLWxpbmVzXCIsXG5cdHJlZ2lvbjogXCJiYi1yZWdpb25cIixcblx0cmVnaW9uczogXCJiYi1yZWdpb25zXCIsXG5cdHNlbGVjdGVkQ2lyY2xlOiBcImJiLXNlbGVjdGVkLWNpcmNsZVwiLFxuXHRzZWxlY3RlZENpcmNsZXM6IFwiYmItc2VsZWN0ZWQtY2lyY2xlc1wiLFxuXHRzaGFwZTogXCJiYi1zaGFwZVwiLFxuXHRzaGFwZXM6IFwiYmItc2hhcGVzXCIsXG5cdHN0YW5mb3JkRWxlbWVudHM6IFwiYmItc3RhbmZvcmQtZWxlbWVudHNcIixcblx0c3RhbmZvcmRMaW5lOiBcImJiLXN0YW5mb3JkLWxpbmVcIixcblx0c3RhbmZvcmRMaW5lczogXCJiYi1zdGFuZm9yZC1saW5lc1wiLFxuXHRzdGFuZm9yZFJlZ2lvbjogXCJiYi1zdGFuZm9yZC1yZWdpb25cIixcblx0c3RhbmZvcmRSZWdpb25zOiBcImJiLXN0YW5mb3JkLXJlZ2lvbnNcIixcblx0dGFyZ2V0OiBcImJiLXRhcmdldFwiLFxuXHR0ZXh0OiBcImJiLXRleHRcIixcblx0dGV4dHM6IFwiYmItdGV4dHNcIixcblx0dGl0bGU6IFwiYmItdGl0bGVcIixcblx0dG9vbHRpcDogXCJiYi10b29sdGlwXCIsXG5cdHRvb2x0aXBDb250YWluZXI6IFwiYmItdG9vbHRpcC1jb250YWluZXJcIixcblx0dG9vbHRpcE5hbWU6IFwiYmItdG9vbHRpcC1uYW1lXCIsXG5cdHhncmlkOiBcImJiLXhncmlkXCIsXG5cdHhncmlkRm9jdXM6IFwiYmIteGdyaWQtZm9jdXNcIixcblx0eGdyaWRMaW5lOiBcImJiLXhncmlkLWxpbmVcIixcblx0eGdyaWRMaW5lczogXCJiYi14Z3JpZC1saW5lc1wiLFxuXHR4Z3JpZHM6IFwiYmIteGdyaWRzXCIsXG5cdHlncmlkOiBcImJiLXlncmlkXCIsXG5cdHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXG5cdHlncmlkTGluZXM6IFwiYmIteWdyaWQtbGluZXNcIixcblx0eWdyaWRzOiBcImJiLXlncmlkc1wiLFxuXHR6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxuXHR6b29tUmVjdDogXCJiYi16b29tLXJlY3RcIixcblx0RVhQQU5ERUQ6IFwiX2V4cGFuZGVkX1wiLFxuXHRTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXG5cdElOQ0xVREVEOiBcIl9pbmNsdWRlZF9cIlxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cbmltcG9ydCB7ZXZlbnQgYXMgZDNFdmVudH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHticnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9ufSBmcm9tIFwiZDMtYnJ1c2hcIjtcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4vYnJvd3NlclwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuXG5jb25zdCBpc1ZhbHVlID0gdiA9PiB2IHx8IHYgPT09IDA7XG5jb25zdCBpc0Z1bmN0aW9uID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNOdW1iZXIgPSB2ID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xuY29uc3QgaXNVbmRlZmluZWQgPSB2ID0+IHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgaXNEZWZpbmVkID0gdiA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzQm9vbGVhbiA9IHYgPT4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xuY29uc3QgY2VpbDEwID0gdiA9PiBNYXRoLmNlaWwodiAvIDEwKSAqIDEwO1xuY29uc3QgYXNIYWxmUGl4ZWwgPSBuID0+IE1hdGguY2VpbChuKSArIDAuNTtcbmNvbnN0IGRpZmZEb21haW4gPSBkID0+IGRbMV0gLSBkWzBdO1xuY29uc3QgaXNPYmplY3RUeXBlID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzRW1wdHkgPSBvID0+IChcblx0aXNVbmRlZmluZWQobykgfHwgbyA9PT0gbnVsbCB8fFxuXHQoaXNTdHJpbmcobykgJiYgby5sZW5ndGggPT09IDApIHx8XG5cdChpc09iamVjdFR5cGUobykgJiYgIShvIGluc3RhbmNlb2YgRGF0ZSkgJiYgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwKSB8fFxuXHQoaXNOdW1iZXIobykgJiYgaXNOYU4obykpXG4pO1xuY29uc3Qgbm90RW1wdHkgPSBvID0+ICFpc0VtcHR5KG8pO1xuXG4vKipcbiAqIENoZWNrIGlmIGlzIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaXNBcnJheSA9IGFyciA9PiBhcnIgJiYgYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheTtcblxuLyoqXG4gKiBDaGVjayBpZiBpcyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSBvYmogPT4gb2JqICYmICFvYmoubm9kZVR5cGUgJiYgaXNPYmplY3RUeXBlKG9iaikgJiYgIWlzQXJyYXkob2JqKTtcblxuY29uc3QgZ2V0T3B0aW9uID0gKG9wdGlvbnMsIGtleSwgZGVmYXVsdFZhbHVlKSA9PiAoXG5cdGlzRGVmaW5lZChvcHRpb25zW2tleV0pID8gb3B0aW9uc1trZXldIDogZGVmYXVsdFZhbHVlXG4pO1xuXG5jb25zdCBoYXNWYWx1ZSA9IChkaWN0LCB2YWx1ZSkgPT4ge1xuXHRsZXQgZm91bmQgPSBmYWxzZTtcblxuXHRPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGtleSA9PiAoZGljdFtrZXldID09PSB2YWx1ZSkgJiYgKGZvdW5kID0gdHJ1ZSkpO1xuXG5cdHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogQ2FsbCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0geyp9IGFyZ3MgQXJndW1lbnRzXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlOiBmbiBpcyBmdW5jdGlvbiwgZmFsc2U6IGZuIGlzIG5vdCBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FsbEZuID0gKGZuLCAuLi5hcmdzKSA9PiB7XG5cdGNvbnN0IGlzRm4gPSBpc0Z1bmN0aW9uKGZuKTtcblxuXHRpc0ZuICYmIGZuLmNhbGwoLi4uYXJncyk7XG5cdHJldHVybiBpc0ZuO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRhZyBzaWduIHRvIGh0bWwgZW50aXR5XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzYW5pdGlzZSA9IHN0ciA9PiAoaXNTdHJpbmcoc3RyKSA/IHN0ci5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKSA6IHN0cik7XG5cbi8qKlxuICogU2V0IHRleHQgdmFsdWUuIElmIHRoZXJlJ3MgbXVsdGlsaW5lIGFkZCBub2Rlcy5cbiAqIEBwYXJhbSB7ZDNTZWxlY3Rpb259IG5vZGUgVGV4dCBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHZhbHVlIHN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gZHkgZHkgdmFsdWUgZm9yIG11bHRpbGluZWQgdGV4dFxuICogQHBhcmFtIHtCb29sZWFufSB0b01pZGRsZSBUbyBiZSBhbGluZ25lZCB2ZXJ0aWNhbGx5IG1pZGRsZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc2V0VGV4dFZhbHVlID0gKG5vZGUsIHRleHQsIGR5ID0gWy0xLCAxXSwgdG9NaWRkbGUgPSBmYWxzZSkgPT4ge1xuXHRpZiAoIW5vZGUgfHwgIWlzU3RyaW5nKHRleHQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHRleHQuaW5kZXhPZihcIlxcblwiKSA9PT0gLTEpIHtcblx0XHRub2RlLnRleHQodGV4dCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgZGlmZiA9IFtub2RlLnRleHQoKSwgdGV4dF0ubWFwKHYgPT4gdi5yZXBsYWNlKC9bXFxzXFxuXS9nLCBcIlwiKSk7XG5cblx0XHRpZiAoZGlmZlswXSAhPT0gZGlmZlsxXSkge1xuXHRcdFx0Y29uc3QgbXVsdGlsaW5lID0gdGV4dC5zcGxpdChcIlxcblwiKTtcblx0XHRcdGNvbnN0IGxlbiA9IHRvTWlkZGxlID8gbXVsdGlsaW5lLmxlbmd0aCAtIDEgOiAxO1xuXG5cdFx0XHQvLyByZXNldCBwb3NzaWJsZSB0ZXh0XG5cdFx0XHRub2RlLmh0bWwoXCJcIik7XG5cblx0XHRcdG11bHRpbGluZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kKFwidHNwYW5cIilcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIGAke2kgPT09IDAgPyBkeVswXSAqIGxlbiA6IGR5WzFdfWVtYClcblx0XHRcdFx0XHQudGV4dCh2KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufTtcblxuLy8gc3Vic3RpdHV0aW9uIG9mIFNWR1BhdGhTZWcgQVBJIHBvbHlmaWxsXG5jb25zdCBnZXRSZWN0U2VnTGlzdCA9IHBhdGggPT4ge1xuXHQvKlxuXHQgKiBzZWcxIC0tLS0tLS0tLS0gc2VnMlxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcblx0ICogICB8ICAgICAgICAgICAgICAgfFxuXHQgKiBzZWcwIC0tLS0tLS0tLS0gc2VnM1xuXHQgKiAqL1xuXHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJCb3goKTtcblxuXHRyZXR1cm4gW1xuXHRcdHt4LCB5OiB5ICsgaGVpZ2h0fSwgLy8gc2VnMFxuXHRcdHt4LCB5fSwgLy8gc2VnMVxuXHRcdHt4OiB4ICsgd2lkdGgsIHl9LCAvLyBzZWcyXG5cdFx0e3g6IHggKyB3aWR0aCwgeTogeSArIGhlaWdodH0gLy8gc2VnM1xuXHRdO1xufTtcblxuY29uc3QgZ2V0UGF0aEJveCA9IHBhdGggPT4ge1xuXHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRjb25zdCBpdGVtcyA9IGdldFJlY3RTZWdMaXN0KHBhdGgpO1xuXHRjb25zdCB4ID0gaXRlbXNbMF0ueDtcblx0Y29uc3QgeSA9IE1hdGgubWluKGl0ZW1zWzBdLnksIGl0ZW1zWzFdLnkpO1xuXG5cdHJldHVybiB7XG5cdFx0eCwgeSwgd2lkdGgsIGhlaWdodFxuXHR9O1xufTtcblxuLy8gcmV0dXJuIGJydXNoIHNlbGVjdGlvbiBhcnJheVxuY29uc3QgZ2V0QnJ1c2hTZWxlY3Rpb24gPSBjdHggPT4ge1xuXHRsZXQgc2VsZWN0aW9uID0gbnVsbDtcblx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xuXHRjb25zdCBtYWluID0gY3R4LmNvbnRleHQgfHwgY3R4Lm1haW47XG5cblx0Ly8gY2hlY2sgZnJvbSBldmVudFxuXHRpZiAoZXZlbnQgJiYgZXZlbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJCcnVzaEV2ZW50XCIpIHtcblx0XHRzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb247XG5cdC8vIGNoZWNrIGZyb20gYnJ1c2ggYXJlYSBzZWxlY3Rpb25cblx0fSBlbHNlIGlmIChtYWluICYmIChzZWxlY3Rpb24gPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkubm9kZSgpKSkge1xuXHRcdHNlbGVjdGlvbiA9IGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblx0fVxuXG5cdHJldHVybiBzZWxlY3Rpb247XG59O1xuXG4vLyBHZXQgYm91bmRpbmdDbGllbnRSZWN0LiBDYWNoZSB0aGUgZXZhbHVhdGVkIHZhbHVlIG9uY2UgaXQgd2FzIGNhbGxlZC5cbmNvbnN0IGdldEJvdW5kaW5nUmVjdCA9IG5vZGUgPT4gbm9kZS5yZWN0IHx8IChub2RlLnJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblxuLy8gcmV0cnVuIHJhbmRvbSBudW1iZXJcbmNvbnN0IGdldFJhbmRvbSA9IChhc1N0ciA9IHRydWUpID0+IE1hdGgucmFuZG9tKCkgKyAoYXNTdHIgPyBcIlwiIDogMCk7XG5cbmNvbnN0IGJydXNoRW1wdHkgPSBjdHggPT4ge1xuXHRjb25zdCBzZWxlY3Rpb24gPSBnZXRCcnVzaFNlbGVjdGlvbihjdHgpO1xuXG5cdGlmIChzZWxlY3Rpb24pIHtcblx0XHQvLyBicnVzaCBzZWxlY3RlZCBhcmVhXG5cdFx0Ly8gdHdvLWRpbWVuc2lvbmFsOiBbW3gwLCB5MF0sIFt4MSwgeTFdXVxuXHRcdC8vIG9uZS1kaW1lbnNpb25hbDogW3gwLCB4MV0gb3IgW3kwLCB5MV1cblx0XHRyZXR1cm4gc2VsZWN0aW9uWzBdID09PSBzZWxlY3Rpb25bMV07XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGV4dGVuZCA9ICh0YXJnZXQgPSB7fSwgc291cmNlKSA9PiB7XG5cdGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcblx0XHR0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNhcGl0YWxpemVkIHN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IHN0ciA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG5cbi8qKlxuICogQ29udmVydCB0byBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IHZcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvQXJyYXkgPSB2ID0+IFtdLnNsaWNlLmNhbGwodik7XG5cbi8qKlxuICogR2V0IGNzcyBydWxlcyBmb3Igc3BlY2lmaWVkIHN0eWxlc2hlZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdHlsZVNoZWV0cyBUaGUgc3R5bGVzaGVldHMgdG8gZ2V0IHRoZSBydWxlcyBmcm9tXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRDc3NSdWxlcyA9IHN0eWxlU2hlZXRzID0+IHtcblx0bGV0IHJ1bGVzID0gW107XG5cblx0c3R5bGVTaGVldHMuZm9yRWFjaChzaGVldCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzaGVldC5jc3NSdWxlcyAmJiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0cnVsZXMgPSBydWxlcy5jb25jYXQodG9BcnJheShzaGVldC5jc3NSdWxlcykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHJlYWRpbmcgcnVsZXMgZnJvbSAke3NoZWV0LmhyZWZ9OiAke2UudG9TdHJpbmcoKX1gKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBydWxlcztcbn07XG5cbi8qKlxuICogR2V0IHVuaXF1ZSB2YWx1ZSBmcm9tIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcmV0dXJuIHtBcnJheX0gVW5pcXVlIGFycmF5IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRVbmlxdWUgPSBkYXRhID0+IHtcblx0Y29uc3QgaXNEYXRlID0gZGF0YVswXSBpbnN0YW5jZW9mIERhdGU7XG5cdGNvbnN0IGQgPSAoaXNEYXRlID8gZGF0YS5tYXAoTnVtYmVyKSA6IGRhdGEpXG5cdFx0LmZpbHRlcigodiwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpKTtcblxuXHRyZXR1cm4gaXNEYXRlID8gZC5tYXAodiA9PiBuZXcgRGF0ZSh2KSkgOiBkO1xufTtcblxuLyoqXG4gKiBNZXJnZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG1lcmdlQXJyYXkgPSBhcnIgPT4gKGFyciAmJiBhcnIubGVuZ3RoID8gYXJyLnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYykpIDogW10pO1xuXG4vKipcbiAqIE1lcmdlIG9iamVjdCByZXR1cm5pbmcgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdE5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG1lcmdlZCB0YXJnZXQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtZXJnZU9iaiA9ICh0YXJnZXQsIC4uLm9iamVjdE4pID0+IHtcblx0aWYgKCFvYmplY3ROLmxlbmd0aCB8fCAob2JqZWN0Ti5sZW5ndGggPT09IDEgJiYgIW9iamVjdE5bMF0pKSB7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdGNvbnN0IHNvdXJjZSA9IG9iamVjdE4uc2hpZnQoKTtcblxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG5cdFx0T2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRcdCF0YXJnZXRba2V5XSAmJiAodGFyZ2V0W2tleV0gPSB7fSk7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gaXNBcnJheSh2YWx1ZSkgP1xuXHRcdFx0XHRcdHZhbHVlLmNvbmNhdCgpIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VPYmoodGFyZ2V0LCAuLi5vYmplY3ROKTtcbn07XG5cbi8qKlxuICogU29ydCB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSB2YWx1ZSB0byBiZSBzb3J0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBc2MgdHJ1ZTogYXNjLCBmYWxzZTogZGVzY1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ3xEYXRlfSBzb3J0ZWQgZGF0ZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc29ydFZhbHVlID0gKGRhdGEsIGlzQXNjID0gdHJ1ZSkgPT4ge1xuXHRsZXQgZm47XG5cblx0aWYgKGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0Zm4gPSBpc0FzYyA/IChhLCBiKSA9PiBhIC0gYiA6IChhLCBiKSA9PiBiIC0gYTtcblx0fSBlbHNlIHtcblx0XHRpZiAoaXNBc2MgJiYgIWRhdGEuZXZlcnkoaXNOYU4pKSB7XG5cdFx0XHRmbiA9IChhLCBiKSA9PiBhIC0gYjtcblx0XHR9IGVsc2UgaWYgKCFpc0FzYykge1xuXHRcdFx0Zm4gPSAoYSwgYikgPT4gKGEgPiBiICYmIC0xKSB8fCAoYSA8IGIgJiYgMSkgfHwgKGEgPT09IGIgJiYgMCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGEuY29uY2F0KCkuc29ydChmbik7XG59O1xuXG4vKipcbiAqIEdldCBtaW4vbWF4IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAnbWluJyBvciAnbWF4J1xuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBkYXRhIHZhbHVlXG4gKiBAcmV0dW4ge051bWJlcnxEYXRlfHVuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldE1pbk1heCA9ICh0eXBlLCBkYXRhKSA9PiB7XG5cdGxldCByZXMgPSBkYXRhLmZpbHRlcih2ID0+IG5vdEVtcHR5KHYpKTtcblxuXHRpZiAocmVzLmxlbmd0aCkge1xuXHRcdGlmIChpc051bWJlcihyZXNbMF0pKSB7XG5cdFx0XHRyZXMgPSBNYXRoW3R5cGVdKC4uLnJlcyk7XG5cdFx0fSBlbHNlIGlmIChyZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRyZXMgPSBzb3J0VmFsdWUocmVzLCB0eXBlID09PSBcIm1pblwiKVswXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0cmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogR2V0IHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgbnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBudW1iZXJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0UmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuXHRjb25zdCByZXMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdHJlcy5wdXNoKGkpO1xuXHR9XG5cblx0cmV0dXJuIHJlcztcbn07XG5cbi8vIGVtdWxhdGUgZXZlbnRcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcblx0bW91c2U6ICgoKSA9PiB7XG5cdFx0Y29uc3QgZ2V0UGFyYW1zID0gKCkgPT4gKHtcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxuXHRcdH0pO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblx0XHRcdG5ldyBNb3VzZUV2ZW50KFwidFwiKTtcblxuXHRcdFx0cmV0dXJuIChlbCwgZXZlbnRUeXBlLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zKSk7XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIFBvbHlmaWxscyBET000IE1vdXNlRXZlbnRcblx0XHRcdHJldHVybiAoZWwsIGV2ZW50VHlwZSwgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcblx0XHRcdFx0Y29uc3QgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcblxuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9pbml0TW91c2VFdmVudFxuXHRcdFx0XHRtb3VzZUV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0XHRwYXJhbXMuYnViYmxlcyxcblx0XHRcdFx0XHRwYXJhbXMuY2FuY2VsYWJsZSxcblx0XHRcdFx0XHR3aW5kb3csXG5cdFx0XHRcdFx0MCwgLy8gdGhlIGV2ZW50J3MgbW91c2UgY2xpY2sgY291bnRcblx0XHRcdFx0XHRwYXJhbXMuc2NyZWVuWCwgcGFyYW1zLnNjcmVlblksXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChtb3VzZUV2ZW50KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9KSgpLFxuXHR0b3VjaDogKGVsLCBldmVudFR5cGUsIHBhcmFtcykgPT4ge1xuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKG1lcmdlT2JqKHtcblx0XHRcdGlkZW50aWZpZXI6IERhdGUubm93KCksXG5cdFx0XHR0YXJnZXQ6IGVsLFxuXHRcdFx0cmFkaXVzWDogMi41LFxuXHRcdFx0cmFkaXVzWTogMi41LFxuXHRcdFx0cm90YXRpb25BbmdsZTogMTAsXG5cdFx0XHRmb3JjZTogMC41XG5cdFx0fSwgcGFyYW1zKSk7XG5cblx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBUb3VjaEV2ZW50KGV2ZW50VHlwZSwge1xuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0XHRzaGlmdEtleTogdHJ1ZSxcblx0XHRcdHRvdWNoZXM6IFt0b3VjaE9ial0sXG5cdFx0XHR0YXJnZXRUb3VjaGVzOiBbXSxcblx0XHRcdGNoYW5nZWRUb3VjaGVzOiBbdG91Y2hPYmpdXG5cdFx0fSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlICAmIHJldHVybiBib3VuZCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cGwgVGVtcGxhdGUgc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIHZhbHVlIHRvIGJlIHJlcGxhY2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0cGxQcm9jZXNzID0gKHRwbCwgZGF0YSkgPT4ge1xuXHRsZXQgcmVzID0gdHBsO1xuXG5cdGZvciAoY29uc3QgeCBpbiBkYXRhKSB7XG5cdFx0cmVzID0gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cChgez0ke3h9fWAsIFwiZ1wiKSwgZGF0YVt4XSk7XG5cdH1cblxuXHRyZXR1cm4gcmVzO1xufTtcblxuZXhwb3J0IHtcblx0YXNIYWxmUGl4ZWwsXG5cdGJydXNoRW1wdHksXG5cdGNhbGxGbixcblx0Y2FwaXRhbGl6ZSxcblx0Y2VpbDEwLFxuXHRkaWZmRG9tYWluLFxuXHRlbXVsYXRlRXZlbnQsXG5cdGV4dGVuZCxcblx0Z2V0QnJ1c2hTZWxlY3Rpb24sXG5cdGdldEJvdW5kaW5nUmVjdCxcblx0Z2V0Q3NzUnVsZXMsXG5cdGdldE1pbk1heCxcblx0Z2V0T3B0aW9uLFxuXHRnZXRQYXRoQm94LFxuXHRnZXRSYW5kb20sXG5cdGdldFJhbmdlLFxuXHRnZXRSZWN0U2VnTGlzdCxcblx0Z2V0VW5pcXVlLFxuXHRoYXNWYWx1ZSxcblx0aXNBcnJheSxcblx0aXNCb29sZWFuLFxuXHRpc0RlZmluZWQsXG5cdGlzRW1wdHksXG5cdGlzRnVuY3Rpb24sXG5cdGlzTnVtYmVyLFxuXHRpc09iamVjdCxcblx0aXNPYmplY3RUeXBlLFxuXHRpc1N0cmluZyxcblx0aXNVbmRlZmluZWQsXG5cdGlzVmFsdWUsXG5cdG1lcmdlQXJyYXksXG5cdG1lcmdlT2JqLFxuXHRub3RFbXB0eSxcblx0c2FuaXRpc2UsXG5cdHNldFRleHRWYWx1ZSxcblx0c29ydFZhbHVlLFxuXHR0b0FycmF5LFxuXHR0cGxQcm9jZXNzXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIEBpZ25vcmVcbiAqL1xuaW1wb3J0IHtzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyfSBmcm9tIFwiZDMtc2NhbGVcIjtcbmltcG9ydCB7aXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmd9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXJIZWxwZXIge1xuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBhcmFtcykge1xuXHRcdGNvbnN0IHNjYWxlID0gZDNTY2FsZUxpbmVhcigpO1xuXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XG5cdFx0dGhpcy5zY2FsZSA9IHNjYWxlO1xuXG5cdFx0aWYgKGNvbmZpZy5ub1RyYW5zaXRpb24gfHwgIXBhcmFtcy5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbikge1xuXHRcdFx0Y29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBzZXQgcmFuZ2Vcblx0XHRjb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGUgYSBjaGFyYWN0ZXIgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBub2RlXG5cdCAqIEByZXR1cm4ge3t3OiBudW1iZXIsIGg6IG51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgZ2V0U2l6ZUZvcjFDaGFyKG5vZGUpIHtcblx0XHQvLyBkZWZhdWx0IHNpemUgZm9yIG9uZSBjaGFyYWN0ZXJcblx0XHRjb25zdCBzaXplID0ge1xuXHRcdFx0dzogNS41LFxuXHRcdFx0aDogMTEuNVxuXHRcdH07XG5cblx0XHQhbm9kZS5lbXB0eSgpICYmIG5vZGUuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0LnRleHQoXCIwXCIpXG5cdFx0XHQuY2FsbChlbCA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcblxuXHRcdFx0XHRcdGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xuXHRcdFx0XHRcdFx0c2l6ZS5oID0gaGVpZ2h0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsLnRleHQoXCJcIik7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuZ2V0U2l6ZUZvcjFDaGFyID0gKCkgPT4gc2l6ZTtcblxuXHRcdHJldHVybiBzaXplO1xuXHR9XG5cblx0YXhpc1goc2VsZWN0aW9uLCB4KSB7XG5cdFx0c2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7TWF0aC5jZWlsKHgoZCkgKyB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0KX0sMClgKTtcblx0fVxuXG5cdGF4aXNZKHNlbGVjdGlvbiwgeSkge1xuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgwLCR7TWF0aC5jZWlsKHkoZCkpfSlgKTtcblx0fVxuXG5cdHNjYWxlRXh0ZW50KGRvbWFpbikge1xuXHRcdGNvbnN0IHN0YXJ0ID0gZG9tYWluWzBdO1xuXHRcdGNvbnN0IHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG5cdFx0cmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFtzdGFydCwgc3RvcF0gOiBbc3RvcCwgc3RhcnRdO1xuXHR9XG5cblx0Z2VuZXJhdGVUaWNrcyhzY2FsZSkge1xuXHRcdGNvbnN0IHRpY2tzID0gW107XG5cblx0XHRpZiAoc2NhbGUudGlja3MpIHtcblx0XHRcdHJldHVybiBzY2FsZS50aWNrcyhcblx0XHRcdFx0Li4uKHRoaXMuY29uZmlnLnRpY2tBcmd1bWVudHMgfHwgW10pXG5cdFx0XHQpLm1hcCh2ID0+IChcblx0XHRcdFx0Ly8gcm91bmQgdGhlIHRpY2sgdmFsdWUgaWYgaXMgbnVtYmVyXG5cdFx0XHRcdChpc1N0cmluZyh2KSAmJiBpc051bWJlcih2KSAmJiAhaXNOYU4odikgJiZcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMFxuXHRcdFx0XHQpIHx8IHZcblx0XHRcdCkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbChkb21haW5bMF0pOyBpIDwgZG9tYWluWzFdOyBpKyspIHtcblx0XHRcdHRpY2tzLnB1c2goaSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA+IDAgJiYgdGlja3NbMF0gPiAwKSB7XG5cdFx0XHR0aWNrcy51bnNoaWZ0KHRpY2tzWzBdIC0gKHRpY2tzWzFdIC0gdGlja3NbMF0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGlja3M7XG5cdH1cblxuXHRjb3B5U2NhbGUoKSB7XG5cdFx0Y29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlLmNvcHkoKTtcblxuXHRcdGlmICghbmV3U2NhbGUuZG9tYWluKCkubGVuZ3RoKSB7XG5cdFx0XHRuZXdTY2FsZS5kb21haW4odGhpcy5zY2FsZS5kb21haW4oKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1NjYWxlO1xuXHR9XG5cblx0dGV4dEZvcm1hdHRlZCh2KSB7XG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XG5cblx0XHQvLyB0byByb3VuZCBmbG9hdCBudW1iZXJzIGZyb20gJ2JpbmFyeSBmbG9hdGluZyBwb2ludCdcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxuXHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODQ5MTAxL2xheW1hbnMtZXhwbGFuYXRpb24tZm9yLXdoeS1qYXZhc2NyaXB0LWhhcy13ZWlyZC1mbG9hdGluZy1tYXRoLWllZWUtNzU0LXN0YW5kXG5cdFx0Y29uc3QgdmFsdWUgPSAvXFxkK1xcLlxcZCswezUsfVxcZCQvLnRlc3QodikgPyArU3RyaW5nKHYpLnJlcGxhY2UoLzArXFxkJC8sIFwiXCIpIDogdjtcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcblxuXHRcdHJldHVybiBpc0RlZmluZWQoZm9ybWF0dGVkKSA/IGZvcm1hdHRlZCA6IFwiXCI7XG5cdH1cblxuXHR0cmFuc2l0aW9uaXNlKHNlbGVjdGlvbikge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA/XG5cdFx0XHRzZWxlY3Rpb24uaW50ZXJydXB0KCkgOiBzZWxlY3Rpb24udHJhbnNpdGlvbihjb25maWcudHJhbnNpdGlvbik7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgSGVscGVyIGZyb20gXCIuL0F4aXNSZW5kZXJlckhlbHBlclwiO1xuaW1wb3J0IHtpc0FycmF5LCB0b0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXJ9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXIge1xuXHRjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHtcblx0XHRcdGlubmVyVGlja1NpemU6IDYsXG5cdFx0XHRvdXRlclRpY2tTaXplOiBwYXJhbXMub3V0ZXJUaWNrID8gNiA6IDAsXG5cdFx0XHRvcmllbnQ6IFwiYm90dG9tXCIsXG5cdFx0XHRyYW5nZTogW10sXG5cdFx0XHR0aWNrQXJndW1lbnRzOiBudWxsLFxuXHRcdFx0dGlja0NlbnRlcmVkOiBudWxsLFxuXHRcdFx0dGlja0N1bGxpbmc6IHRydWUsXG5cdFx0XHR0aWNrRm9ybWF0OiBudWxsLFxuXHRcdFx0dGlja0xlbmd0aDogOSxcblx0XHRcdHRpY2tPZmZzZXQ6IDAsXG5cdFx0XHR0aWNrUGFkZGluZzogMyxcblx0XHRcdHRpY2tWYWx1ZXM6IG51bGwsXG5cdFx0XHR0cmFuc2l0aW9uOiBudWxsLFxuXHRcdFx0bm9UcmFuc2l0aW9uOiBwYXJhbXMubm9UcmFuc2l0aW9uXG5cdFx0fTtcblxuXHRcdGNvbmZpZy50aWNrTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLmlubmVyVGlja1NpemUsIDApICsgY29uZmlnLnRpY2tQYWRkaW5nO1xuXG5cdFx0dGhpcy5oZWxwZXIgPSBuZXcgSGVscGVyKGNvbmZpZywgcGFyYW1zKTtcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYXhpcyBlbGVtZW50XG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjcmVhdGUoZykge1xuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cdFx0Y29uc3QgaGVscGVySW5zdCA9IHRoaXMuaGVscGVyO1xuXHRcdGNvbnN0IHNjYWxlID0gaGVscGVySW5zdC5zY2FsZTtcblx0XHRjb25zdCBvcmllbnQgPSBjb25maWcub3JpZW50O1xuXHRcdGNvbnN0IHNwbGl0VGlja1RleHQgPSB0aGlzLnNwbGl0VGlja1RleHQuYmluZCh0aGlzKTtcblxuXHRcdGNvbnN0IGlzTGVmdFJpZ2h0ID0gL14obGVmdHxyaWdodCkkLy50ZXN0KG9yaWVudCk7XG5cdFx0Y29uc3QgaXNUb3BCb3R0b20gPSAvXih0b3B8Ym90dG9tKSQvLnRlc3Qob3JpZW50KTtcblxuXHRcdC8vIGxpbmUvdGV4dCBlbnRlciBhbmQgcGF0aCB1cGRhdGVcblx0XHRjb25zdCB0aWNrVHJhbnNmb3JtID0gaGVscGVySW5zdFtpc1RvcEJvdHRvbSA/IFwiYXhpc1hcIiA6IFwiYXhpc1lcIl07XG5cdFx0Y29uc3QgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVySW5zdC5heGlzWCA/IFwieVwiIDogXCJ4XCI7XG5cdFx0Y29uc3Qgc2lnbiA9IC9eKHRvcHxsZWZ0KSQvLnRlc3Qob3JpZW50KSA/IC0xIDogMTtcblxuXHRcdC8vIHRpY2sgdGV4dCBoZWxwZXJzXG5cdFx0Y29uc3Qgcm90YXRlID0gcGFyYW1zLnRpY2tUZXh0Um90YXRlO1xuXG5cdFx0dGhpcy5jb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcblx0XHRcdGhlbHBlckluc3Quc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xuXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHRpY2tMZW5ndGgsIHJhbmdlfSA9IGNvbmZpZztcblxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXG5cdFx0Y29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuXHRcdGNvbnN0IHRpY2tUZXh0UG9zID0gbmFtZSAmJiAvXih4fHl8eTIpJC8udGVzdChuYW1lKSA/XG5cdFx0XHRwYXJhbXMuY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja190ZXh0X3Bvc2l0aW9uYF0gOiB7eDogMCwgeTogMH07XG5cblx0XHQvLyB0aWNrIHZpc2libGl0eVxuXHRcdGNvbnN0IHByZWZpeCA9IG5hbWUgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke25hbWV9YDtcblx0XHRjb25zdCBheGlzU2hvdyA9IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV9zaG93YF07XG5cdFx0Y29uc3QgdGlja1Nob3cgPSB7XG5cdFx0XHR0aWNrOiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3Nob3dgXSA6IGZhbHNlLFxuXHRcdFx0dGV4dDogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja190ZXh0X3Nob3dgXSA6IGZhbHNlXG5cdFx0fTtcblxuXHRcdGxldCAkZyA9IG51bGw7XG5cblx0XHRnLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRsZXQgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGU7XG5cdFx0XHRsZXQgc2NhbGUxID0gaGVscGVySW5zdC5jb3B5U2NhbGUoKTtcblxuXHRcdFx0JGcgPSBnO1xuXHRcdFx0dGhpcy5fX2NoYXJ0X18gPSBzY2FsZTE7XG5cblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xuXHRcdFx0XHRNYXRoLmNlaWwoKHNjYWxlMSgxKSAtIHNjYWxlMSgwKSkgLyAyKSA6IDA7XG5cblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cblx0XHRcdGNvbnN0IHBhdGggPSBnLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbMF0pO1xuXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cblx0XHRcdHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcblx0XHRcdFx0Lm1lcmdlKGhlbHBlckluc3QudHJhbnNpdGlvbmlzZShwYXRoKSlcblx0XHRcdFx0LmF0dHIoXCJkXCIsICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcblxuXHRcdFx0XHRcdHJldHVybiBpc1RvcEJvdHRvbSA/XG5cdFx0XHRcdFx0XHRgTSR7cmFuZ2VbMF19LCR7b3V0ZXJUaWNrU2l6ZWR9VjBIJHtyYW5nZVsxXX1WJHtvdXRlclRpY2tTaXplZH1gIDpcblx0XHRcdFx0XHRcdGBNJHtvdXRlclRpY2tTaXplZH0sJHtyYW5nZVswXX1IMFYke3JhbmdlWzFdfUgke291dGVyVGlja1NpemVkfWA7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGlja1Nob3cudGljayB8fCB0aWNrU2hvdy50ZXh0KSB7XG5cdFx0XHRcdC8vIGNvdW50IG9mIHRpY2sgZGF0YSBpbiBhcnJheVxuXHRcdFx0XHRjb25zdCB0aWNrcyA9IGNvbmZpZy50aWNrVmFsdWVzIHx8IGhlbHBlckluc3QuZ2VuZXJhdGVUaWNrcyhzY2FsZTEpO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb25cblx0XHRcdFx0bGV0IHRpY2sgPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpXG5cdFx0XHRcdFx0LmRhdGEodGlja3MsIHNjYWxlMSk7XG5cblx0XHRcdFx0Ly8gZW50ZXIgc2VsZWN0aW9uXG5cdFx0XHRcdGNvbnN0IHRpY2tFbnRlciA9IHRpY2tcblx0XHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHRcdC5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpXG5cdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cblx0XHRcdFx0Ly8gTUVNTzogTm8gZXhpdCB0cmFuc2l0aW9uLiBUaGUgcmVhc29uIGlzIHRoaXMgdHJhbnNpdGlvbiBhZmZlY3RzIG1heCB0aWNrIHdpZHRoIGNhbGN1bGF0aW9uIGJlY2F1c2Ugb2xkIHRpY2sgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgdGlja3MuXG5cdFx0XHRcdGNvbnN0IHRpY2tFeGl0ID0gdGljay5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0Ly8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXG5cdFx0XHRcdHRpY2sgPSB0aWNrRW50ZXIubWVyZ2UodGljayk7XG5cblx0XHRcdFx0dGlja1Nob3cudGljayAmJiB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcblx0XHRcdFx0dGlja1Nob3cudGV4dCAmJiB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuXHRcdFx0XHRjb25zdCBzaXplRm9yMUNoYXIgPSBIZWxwZXIuZ2V0U2l6ZUZvcjFDaGFyKHRpY2spO1xuXHRcdFx0XHRjb25zdCBjb3VudHMgPSBbXTtcblxuXHRcdFx0XHRsZXQgdHNwYW4gPSB0aWNrLnNlbGVjdChcInRleHRcIilcblx0XHRcdFx0XHQuc2VsZWN0QWxsKFwidHNwYW5cIilcblx0XHRcdFx0XHQuZGF0YSgoZCwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0ID0gcGFyYW1zLnRpY2tNdWx0aWxpbmUgP1xuXHRcdFx0XHRcdFx0XHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlMSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBzaXplRm9yMUNoYXIudykgOiAoXG5cdFx0XHRcdFx0XHRcdFx0aXNBcnJheShoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCkpID9cblx0XHRcdFx0XHRcdFx0XHRcdGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKS5jb25jYXQoKSA6IFtoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCldXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGNvdW50c1tpbmRleF0gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzcGxpdC5tYXAoc3BsaXR0ZWQgPT4gKHtpbmRleCwgc3BsaXR0ZWR9KSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dHNwYW4uZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0XHRcdHRzcGFuID0gdHNwYW5cblx0XHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0c3BhblwiKVxuXHRcdFx0XHRcdC5tZXJnZSh0c3Bhbilcblx0XHRcdFx0XHQudGV4dChkID0+IGQuc3BsaXR0ZWQpO1xuXG5cdFx0XHRcdC8vIHNldCA8dHNwYW4+J3MgcG9zaXRpb25cblx0XHRcdFx0dHNwYW5cblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNUb3BCb3R0b20gPyAwIDogdGlja0xlbmd0aCAqIHNpZ24pXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGR4ID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiAmJiByb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0ZHggPSA4ICogTWF0aC5zaW4oTWF0aC5QSSAqIChyb3RhdGUgLyAxODApKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGR4ICsgKHRpY2tUZXh0UG9zLnggfHwgMCk7XG5cdFx0XHRcdFx0fSkoKSlcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIChkLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWZWYWx1ZSA9IFwiLjcxZW1cIjtcblx0XHRcdFx0XHRcdGxldCBkeSA9IDA7XG5cblx0XHRcdFx0XHRcdGlmIChvcmllbnQgIT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0ZHkgPSBzaXplRm9yMUNoYXIuaDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGR5ID0gaXNMZWZ0UmlnaHQgPyAtKChjb3VudHNbZC5pbmRleF0gLSAxKSAqIChzaXplRm9yMUNoYXIuaCAvIDIpIC0gMykgOlxuXHRcdFx0XHRcdFx0XHRcdFx0KHRpY2tUZXh0UG9zLnkgPT09IDAgPyBkZWZWYWx1ZSA6IDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBpc051bWJlcihkeSkgJiYgdGlja1RleHRQb3MueSA/XG5cdFx0XHRcdFx0XHRcdGR5ICsgdGlja1RleHRQb3MueSA6IGR5IHx8IGRlZlZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbnN0IGxpbmVVcGRhdGUgPSB0aWNrLnNlbGVjdChcImxpbmVcIik7XG5cdFx0XHRcdGNvbnN0IHRleHRVcGRhdGUgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcImxpbmVcIikuYXR0cihgJHtheGlzUHh9MmAsIGlubmVyVGlja1NpemUgKiBzaWduKTtcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcInRleHRcIikuYXR0cihgJHtheGlzUHh9YCwgdGlja0xlbmd0aCAqIHNpZ24pO1xuXG5cdFx0XHRcdGN0eC5zZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKTtcblxuXHRcdFx0XHQvLyBBcHBlbmQgPHRpdGxlPiBmb3IgdG9vbHRpcCBkaXNwbGF5XG5cdFx0XHRcdHBhcmFtcy50aWNrVGl0bGUgJiYgdGV4dFVwZGF0ZS5hcHBlbmQgJiYgdGV4dFVwZGF0ZS5hcHBlbmQoXCJ0aXRsZVwiKVxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS50ZXh0KHBhcmFtcy50aWNrVGl0bGVbaW5kZXhdKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBzY2FsZTE7XG5cdFx0XHRcdFx0Y29uc3QgZHggPSB4LmJhbmR3aWR0aCgpIC8gMjtcblxuXHRcdFx0XHRcdHNjYWxlMCA9IGQgPT4geChkKSArIGR4O1xuXHRcdFx0XHRcdHNjYWxlMSA9IHNjYWxlMDtcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XG5cdFx0XHRcdFx0c2NhbGUwID0gc2NhbGUxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRXhpdCwgc2NhbGUxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRW50ZXIsIHNjYWxlMCk7XG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCBoZWxwZXJJbnN0LnRyYW5zaXRpb25pc2UodGljaykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSwgc2NhbGUxKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuZyA9ICRnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aWNrIHgveSBjb29yZGluYXRlXG5cdCAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUaWNrWFkoKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcG9zID0ge3g6IDAsIHk6IDB9O1xuXG5cdFx0aWYgKHRoaXMucGFyYW1zLmlzQ2F0ZWdvcnkpIHtcblx0XHRcdHBvcy54ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldDtcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aWNrIHNpemVcblx0ICogQHBhcmFtIGRcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VGlja1NpemUoZCkge1xuXHRcdGNvbnN0IHNjYWxlID0gdGhpcy5oZWxwZXIuc2NhbGU7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgaW5uZXJUaWNrU2l6ZSA9IGNvbmZpZy5pbm5lclRpY2tTaXplO1xuXHRcdGNvbnN0IHJhbmdlID0gY29uZmlnLnJhbmdlO1xuXG5cdFx0Y29uc3QgdGlja1Bvc2l0aW9uID0gc2NhbGUoZCkgK1xuXHRcdFx0KGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQpO1xuXG5cdFx0cmV0dXJuIHJhbmdlWzBdIDwgdGlja1Bvc2l0aW9uICYmIHRpY2tQb3NpdGlvbiA8IHJhbmdlWzFdID8gaW5uZXJUaWNrU2l6ZSA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRpY2sncyBsaW5lICYgdGV4dCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gbGluZVVwZGF0ZVxuXHQgKiBAcGFyYW0gdGV4dFVwZGF0ZVxuXHQgKiBAcGFyYW0gc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpIHtcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgb3JpZW50LCB0aWNrTGVuZ3RoLCB0aWNrT2Zmc2V0fSA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IHJvdGF0ZSA9IHRoaXMucGFyYW1zLnRpY2tUZXh0Um90YXRlO1xuXG5cdFx0Y29uc3QgdGV4dEFuY2hvckZvclRleHQgPSByID0+ICghciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyBcInN0YXJ0XCIgOiBcImVuZFwiKSk7XG5cdFx0Y29uc3QgdGV4dFRyYW5zZm9ybSA9IHIgPT4gKHIgPyBgcm90YXRlKCR7cn0pYCA6IG51bGwpO1xuXHRcdGNvbnN0IHlGb3JUZXh0ID0gciA9PiAociA/IDExLjUgLSAyLjUgKiAociAvIDE1KSAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoKTtcblxuXHRcdHN3aXRjaCAob3JpZW50KSB7XG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIHRpY2tQb3MueClcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHRoaXMuZ2V0VGlja1NpemUuYmluZCh0aGlzKSk7XG5cblx0XHRcdFx0dGV4dFVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yVGV4dChyb3RhdGUpKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zZm9ybShyb3RhdGUpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidG9wXCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIDApXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XG5cblx0XHRcdFx0dGV4dFVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCAtdGlja0xlbmd0aCAqIDIpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRcdFx0bGluZVVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB0aWNrUG9zLnkpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB0aWNrUG9zLnkpO1xuXG5cdFx0XHRcdHRleHRVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgLXRpY2tMZW5ndGgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlubmVyVGlja1NpemUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcblxuXHRcdFx0XHR0ZXh0VXBkYXRlXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIDApXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcblx0c3BsaXRUaWNrVGV4dChkLCBzY2FsZSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBjaGFyV2lkdGgpIHtcblx0XHRjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcblx0XHRjb25zdCB0aWNrVGV4dCA9IHRoaXMuaGVscGVyLnRleHRGb3JtYXR0ZWQoZCk7XG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cblx0XHRcdHRpY2tUZXh0LnNwbGl0KFwiXFxuXCIpIDogW107XG5cblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJyYXkodGlja1RleHQpKSB7XG5cdFx0XHRyZXR1cm4gdGlja1RleHQ7XG5cdFx0fVxuXG5cdFx0bGV0IHRpY2tXaWR0aCA9IHBhcmFtcy50aWNrV2lkdGg7XG5cblx0XHRpZiAoIXRpY2tXaWR0aCB8fCB0aWNrV2lkdGggPD0gMCkge1xuXHRcdFx0dGlja1dpZHRoID0gaXNMZWZ0UmlnaHQgPyA5NSA6IChcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xuXHRcdFx0XHRcdChNYXRoLmNlaWwoc2NhbGUodGlja3NbMV0pIC0gc2NhbGUodGlja3NbMF0pKSAtIDEyKSA6IDExMFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzcGxpdChzcGxpdHRlZCwgdGV4dCkge1xuXHRcdFx0bGV0IHN1YnRleHQ7XG5cdFx0XHRsZXQgc3BhY2VJbmRleDtcblx0XHRcdGxldCB0ZXh0V2lkdGg7XG5cblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiIFwiKSB7XG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xuXHRcdFx0XHR0ZXh0V2lkdGggPSBjaGFyV2lkdGggKiBzdWJ0ZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XG5cdFx0XHRcdGlmICh0aWNrV2lkdGggPCB0ZXh0V2lkdGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3BsaXQoXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXG5cdFx0XHRcdFx0XHR0ZXh0LnNsaWNlKHNwYWNlSW5kZXggPyBzcGFjZUluZGV4ICsgMSA6IGkpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XG5cdH1cblxuXHRzY2FsZSh4KSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXIuc2NhbGU7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXIuc2NhbGUgPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRvcmllbnQoeCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9yaWVudDtcblx0XHR9XG5cblx0XHR0aGlzLmNvbmZpZy5vcmllbnQgPSB4IGluIHtcblx0XHRcdHRvcDogMSxcblx0XHRcdHJpZ2h0OiAxLFxuXHRcdFx0Ym90dG9tOiAxLFxuXHRcdFx0bGVmdDogMVxuXHRcdH0gPyBTdHJpbmcoeCkgOiBcImJvdHRvbVwiO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrRm9ybWF0KGZvcm1hdCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dGlja0NlbnRlcmVkKGlzQ2VudGVyZWQpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ2VudGVyZWQ7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tDZW50ZXJlZCA9IGlzQ2VudGVyZWQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cblx0ICogVGhlIHZhbHVlIHdpbGwgYmUgc2V0IGZvciAnY2F0ZWdvcnknIGF4aXMgdHlwZS5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja09mZnNldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja09mZnNldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGljayBpbnRlcnZhbCBjb3VudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0dGlja0ludGVydmFsKHNpemUpIHtcblx0XHRsZXQgaW50ZXJ2YWw7XG5cblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xuXHRcdFx0aW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0ICogMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5nLnNlbGVjdChcInBhdGguZG9tYWluXCIpXG5cdFx0XHRcdC5ub2RlKClcblx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCkgLSB0aGlzLmNvbmZpZy5vdXRlclRpY2tTaXplICogMjtcblxuXHRcdFx0aW50ZXJ2YWwgPSBsZW5ndGggLyAoc2l6ZSB8fCB0aGlzLmcuc2VsZWN0QWxsKFwibGluZVwiKS5zaXplKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XG5cdH1cblxuXHR0aWNrcyguLi5hcmdzKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoIWFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrQ3VsbGluZyhjdWxsaW5nKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBjb25maWcudGlja0N1bGxpbmc7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tDdWxsaW5nID0gY3VsbGluZztcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dGlja1ZhbHVlcyh4KSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoaXNGdW5jdGlvbih4KSkge1xuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSAoKSA9PiB4KHRoaXMuaGVscGVyLnNjYWxlLmRvbWFpbigpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBjb25maWcudGlja1ZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSB4O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c2V0VHJhbnNpdGlvbih0KSB7XG5cdFx0dGhpcy5jb25maWcudHJhbnNpdGlvbiA9IHQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXG5cdGF4aXNCb3R0b20gYXMgZDNBeGlzQm90dG9tLFxuXHRheGlzTGVmdCBhcyBkM0F4aXNMZWZ0LFxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcbn0gZnJvbSBcImQzLWF4aXNcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIG1lcmdlT2JqLCBzb3J0VmFsdWV9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuaW1wb3J0IEF4aXNSZW5kZXJlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJcIjtcblxuY29uc3QgaXNIb3Jpem9udGFsID0gKCQkLCBmb3JIb3Jpem9udGFsKSA9PiB7XG5cdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0cmV0dXJuIGZvckhvcml6b250YWwgPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkO1xufTtcblxuY29uc3QgZ2V0QXhpc0NsYXNzTmFtZSA9IGlkID0+IGAke0NMQVNTLmF4aXN9ICR7Q0xBU1NbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdfWA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXMge1xuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcblx0XHR0aGlzLnNldE9yaWVudCgpO1xuXHR9XG5cblx0aW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XG5cblx0XHRjb25maWcuYXhpc195Ml9zaG93ICYmIHRhcmdldC5wdXNoKFwieTJcIik7XG5cblx0XHQkJC5heGVzTGlzdCA9IHt9O1xuXG5cdFx0dGFyZ2V0LmZvckVhY2godiA9PiB7XG5cdFx0XHRjb25zdCBjbGFzc0F4aXMgPSBnZXRBeGlzQ2xhc3NOYW1lKHYpO1xuXHRcdFx0Y29uc3QgYXhpc0lkID0gdi50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0Y29uc3QgY2xhc3NMYWJlbCA9IENMQVNTW2BheGlzJHtheGlzSWR9TGFiZWxgXTtcblxuXHRcdFx0JCQuYXhlc1t2XSA9IG1haW4uYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXhpcylcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGxldCByZXMgPSBudWxsO1xuXG5cdFx0XHRcdFx0aWYgKHYgPT09IFwieFwiKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSAkJC5jbGlwUGF0aEZvclhBeGlzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ5XCIgJiYgY29uZmlnLmF4aXNfeV9pbm5lcikge1xuXHRcdFx0XHRcdFx0cmVzID0gJCQuY2xpcFBhdGhGb3JZQXhpcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUodikpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7dn1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcblxuXHRcdFx0JCQuYXhlc1t2XS5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMYWJlbClcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgW1wicm90YXRlKC05MClcIiwgbnVsbF1bXG5cdFx0XHRcdFx0diA9PT0gXCJ4XCIgPyArIWlzUm90YXRlZCA6ICtpc1JvdGF0ZWRcblx0XHRcdFx0XSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpc1tgdGV4dEFuY2hvckZvciR7YXhpc0lkfUF4aXNMYWJlbGBdLmJpbmQodGhpcykpO1xuXG5cdFx0XHR0aGlzLmdlbmVyYXRlQXhlcyh2KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgYXhpcyBvcmllbnQgYWNjb3JkaW5nIG9wdGlvbiB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0T3JpZW50KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCB5SW5uZXIgPSBjb25maWcuYXhpc195X2lubmVyO1xuXHRcdGNvbnN0IHkySW5uZXIgPSBjb25maWcuYXhpc195Ml9pbm5lcjtcblxuXHRcdCQkLnhPcmllbnQgPSBpc1JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCI7XG5cdFx0JCQueU9yaWVudCA9IGlzUm90YXRlZCA/ICh5SW5uZXIgPyBcInRvcFwiIDogXCJib3R0b21cIikgOiAoeUlubmVyID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuXHRcdCQkLnkyT3JpZW50ID0gaXNSb3RhdGVkID8gKHkySW5uZXIgPyBcImJvdHRvbVwiIDogXCJ0b3BcIikgOiAoeTJJbm5lciA/IFwibGVmdFwiIDogXCJyaWdodFwiKTtcblx0XHQkJC5zdWJYT3JpZW50ID0gaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGF4ZXNcblx0ICogSXQncyB1c2VkIHdoZW4gYXhpcycgYXhlcyBvcHRpb24gaXMgc2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBBeGlzIGlkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZUF4ZXMoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGF4ZXMgPSBbXTtcblx0XHRjb25zdCBheGVzQ29uZmlnID0gY29uZmlnW2BheGlzXyR7aWR9X2F4ZXNgXTtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCBkM0F4aXM7XG5cblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNMZWZ0IDogZDNBeGlzQm90dG9tO1xuXHRcdH0gZWxzZSBpZiAoaWQgPT09IFwieVwiKSB7XG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNCb3R0b20gOiBkM0F4aXNMZWZ0O1xuXHRcdH0gZWxzZSBpZiAoaWQgPT09IFwieTJcIikge1xuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzVG9wIDogZDNBeGlzUmlnaHQ7XG5cdFx0fVxuXG5cdFx0aWYgKGF4ZXNDb25maWcubGVuZ3RoKSB7XG5cdFx0XHRheGVzQ29uZmlnLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IHRpY2sgPSB2LnRpY2s7XG5cblx0XHRcdFx0YXhlcy5wdXNoKFxuXHRcdFx0XHRcdGQzQXhpcygkJFtpZF0pXG5cdFx0XHRcdFx0XHQudGlja3ModGljay5jb3VudClcblx0XHRcdFx0XHRcdC50aWNrRm9ybWF0KHRpY2suZm9ybWF0IHx8ICh4ID0+IHgpKVxuXHRcdFx0XHRcdFx0LnRpY2tWYWx1ZXModGljay52YWx1ZXMpXG5cdFx0XHRcdFx0XHQudGlja1NpemVPdXRlcih0aWNrLm91dGVyID09PSBmYWxzZSA/IDAgOiA2KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCQuYXhlc0xpc3RbaWRdID0gYXhlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgYXhlcyBub2Rlc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlQXhlcygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0T2JqZWN0LmtleXMoJCQuYXhlc0xpc3QpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSAkJFtpZF0ucmFuZ2UoKTtcblxuXHRcdFx0JCQuYXhlc0xpc3RbaWRdLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0Y29uc3QgYXhpc1JhbmdlID0gdi5zY2FsZSgpLnJhbmdlKCk7XG5cblx0XHRcdFx0Ly8gYWRqdXN0IHJhbmdlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnRcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvODU5XG5cdFx0XHRcdGlmICghcmFuZ2UuZXZlcnkoKHYsIGkpID0+IHYgPT09IGF4aXNSYW5nZVtpXSkpIHtcblx0XHRcdFx0XHR2LnNjYWxlKCkucmFuZ2UocmFuZ2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY2xhc3NOYW1lID0gYCR7Z2V0QXhpc0NsYXNzTmFtZShpZCl9LSR7aSArIDF9YDtcblx0XHRcdFx0bGV0IGcgPSAkJC5tYWluLnNlbGVjdChgLiR7Y2xhc3NOYW1lLnJlcGxhY2UoL1xccy8sIFwiLlwiKX1gKTtcblxuXHRcdFx0XHRpZiAoZy5lbXB0eSgpKSB7XG5cdFx0XHRcdFx0ZyA9ICQkLm1haW4uYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpXG5cdFx0XHRcdFx0XHQuY2FsbCh2KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkJC54QXhpcy5oZWxwZXIudHJhbnNpdGlvbmlzZShnKVxuXHRcdFx0XHRcdFx0LmNhbGwodi5zY2FsZSgkJFtpZF0pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGcuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoaWQsIGkgKyAxKSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIGNhbGxlZCBmcm9tIDogdXBkYXRlU2NhbGVzKCkgJiBnZXRNYXhUaWNrV2lkdGgoKVxuXHRnZXRBeGlzKG5hbWUsIHNjYWxlLCBvdXRlclRpY2ssIG5vVHJhbnNpdGlvbiwgbm9UaWNrVGV4dFJvdGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNYID0gL14oeHxzdWJYKSQvLnRlc3QobmFtZSk7XG5cdFx0Y29uc3QgdHlwZSA9IGlzWCA/IFwieFwiIDogXCJ5XCI7XG5cblx0XHRjb25zdCBpc0NhdGVnb3J5ID0gaXNYICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblx0XHRjb25zdCBvcmllbnQgPSAkJFtgJHtuYW1lfU9yaWVudGBdO1xuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBpc1ggPyAkJC54QXhpc1RpY2tGb3JtYXQgOiBjb25maWdbYGF4aXNfJHtuYW1lfV90aWNrX2Zvcm1hdGBdO1xuXHRcdGxldCB0aWNrVmFsdWVzID0gaXNYID8gJCQueEF4aXNUaWNrVmFsdWVzIDogJCRbYCR7bmFtZX1BeGlzVGlja1ZhbHVlc2BdO1xuXG5cdFx0Y29uc3QgYXhpc1BhcmFtcyA9IG1lcmdlT2JqKHtcblx0XHRcdG91dGVyVGljayxcblx0XHRcdG5vVHJhbnNpdGlvbixcblx0XHRcdGNvbmZpZyxcblx0XHRcdG5hbWUsXG5cdFx0XHR0aWNrVGV4dFJvdGF0ZTogbm9UaWNrVGV4dFJvdGF0ZSA/IDAgOiBjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX3JvdGF0ZWBdXG5cdFx0fSwgaXNYICYmIHtcblx0XHRcdGlzQ2F0ZWdvcnksXG5cdFx0XHR0aWNrTXVsdGlsaW5lOiBjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lLFxuXHRcdFx0dGlja1dpZHRoOiBjb25maWcuYXhpc194X3RpY2tfd2lkdGgsXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcblx0XHRcdG9yZ1hTY2FsZTogJCQueFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgYXhpcyA9IG5ldyBBeGlzUmVuZGVyZXIoYXhpc1BhcmFtcylcblx0XHRcdC5zY2FsZSgoaXNYICYmICQkLnpvb21TY2FsZSkgfHwgc2NhbGUpXG5cdFx0XHQub3JpZW50KG9yaWVudCk7XG5cblx0XHRpZiAoaXNYICYmICQkLmlzVGltZVNlcmllcygpICYmIHRpY2tWYWx1ZXMgJiYgIWlzRnVuY3Rpb24odGlja1ZhbHVlcykpIHtcblx0XHRcdHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLm1hcCh2ID0+ICQkLnBhcnNlRGF0ZSh2KSk7XG5cdFx0fSBlbHNlIGlmICghaXNYICYmICQkLmlzVGltZVNlcmllc1koKSkge1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvbWFzdGVyL0NIQU5HRVMubWQjdGltZS1pbnRlcnZhbHMtZDMtdGltZVxuXHRcdFx0YXhpcy50aWNrcyhjb25maWcuYXhpc195X3RpY2tfdGltZV92YWx1ZSk7XG5cdFx0XHR0aWNrVmFsdWVzID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aWNrVmFsdWVzICYmIGF4aXMudGlja1ZhbHVlcyh0aWNrVmFsdWVzKTtcblxuXHRcdC8vIFNldCB0aWNrXG5cdFx0YXhpcy50aWNrRm9ybWF0KFxuXHRcdFx0dGlja0Zvcm1hdCB8fCAoXG5cdFx0XHRcdCFpc1ggJiYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgKHggPT4gYCR7eH0lYCkpXG5cdFx0XHQpXG5cdFx0KTtcblxuXHRcdGlmIChpc0NhdGVnb3J5KSB7XG5cdFx0XHRheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xuXG5cdFx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X3RpY2tfY3VsbGluZykpIHtcblx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX2NvdW50YF0gJiYgYXhpcy50aWNrcyhjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX2NvdW50YF0pO1xuXG5cdFx0cmV0dXJuIGF4aXM7XG5cdH1cblxuXHR1cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0cywgYXhpcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZml0ID0gY29uZmlnLmF4aXNfeF90aWNrX2ZpdDtcblx0XHRjb25zdCBjb3VudCA9IGNvbmZpZy5heGlzX3hfdGlja19jb3VudDtcblx0XHRsZXQgdmFsdWVzO1xuXG5cdFx0aWYgKGZpdCB8fCAoY291bnQgJiYgZml0KSkge1xuXHRcdFx0dmFsdWVzID0gdGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXG5cdFx0XHRcdCQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpLFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdFx0JCQuaXNUaW1lU2VyaWVzKClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXMpIHtcblx0XHRcdGF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpO1xuXHRcdH0gZWxzZSBpZiAoJCQueEF4aXMpIHtcblx0XHRcdCQkLnhBeGlzLnRpY2tWYWx1ZXModmFsdWVzKTtcblx0XHRcdCQkLnN1YlhBeGlzLnRpY2tWYWx1ZXModmFsdWVzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG5cblx0Z2V0SWQoaWQpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLm93bmVyLmNvbmZpZztcblxuXHRcdHJldHVybiBpZCBpbiBjb25maWcuZGF0YV9heGVzID8gY29uZmlnLmRhdGFfYXhlc1tpZF0gOiBcInlcIjtcblx0fVxuXG5cdGdldFhBeGlzVGlja0Zvcm1hdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBjb25maWcuYXhpc194X3RpY2tfZm9ybWF0O1xuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSAkJC5pc0NhdGVnb3JpemVkKCk7XG5cdFx0bGV0IGZvcm1hdDtcblxuXHRcdGlmICh0aWNrRm9ybWF0KSB7XG5cdFx0XHRpZiAoaXNGdW5jdGlvbih0aWNrRm9ybWF0KSkge1xuXHRcdFx0XHRmb3JtYXQgPSB0aWNrRm9ybWF0O1xuXHRcdFx0fSBlbHNlIGlmIChpc1RpbWVTZXJpZXMpIHtcblx0XHRcdFx0Zm9ybWF0ID0gZGF0ZSA9PiAoZGF0ZSA/ICQkLmF4aXNUaW1lRm9ybWF0KHRpY2tGb3JtYXQpKGRhdGUpIDogXCJcIik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvcm1hdCA9IGlzVGltZVNlcmllcyA/ICQkLmRlZmF1bHRBeGlzVGltZUZvcm1hdCA6IChcblx0XHRcdFx0aXNDYXRlZ29yaXplZCA/XG5cdFx0XHRcdFx0JCQuY2F0ZWdvcnlOYW1lIDogdiA9PiAodiA8IDAgPyB2LnRvRml4ZWQoMCkgOiB2KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gdiA9PlxuXHRcdFx0Zm9ybWF0LmFwcGx5KCQkLCBpc0NhdGVnb3JpemVkID9cblx0XHRcdFx0W3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl1cblx0XHRcdCkgOiBmb3JtYXQ7XG5cdH1cblxuXHRnZXRUaWNrVmFsdWVzKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSAkJC5jb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcblx0XHRjb25zdCBheGlzID0gJCRbYCR7aWR9QXhpc2BdO1xuXG5cdFx0cmV0dXJuIChpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpID8gdGlja1ZhbHVlcygpIDogdGlja1ZhbHVlcykgfHxcblx0XHRcdChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xuXHR9XG5cblx0Z2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCkge1xuXHRcdHJldHVybiB0aGlzLm93bmVyLmNvbmZpZ1tgYXhpc18ke2lkfV9sYWJlbGBdO1xuXHR9XG5cblx0Z2V0TGFiZWxUZXh0KGlkKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblxuXHRcdHJldHVybiBpc1N0cmluZyhvcHRpb24pID8gb3B0aW9uIDogKFxuXHRcdFx0b3B0aW9uID8gb3B0aW9uLnRleHQgOiBudWxsXG5cdFx0KTtcblx0fVxuXG5cdHNldExhYmVsVGV4dChpZCwgdGV4dCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblxuXHRcdGlmIChpc1N0cmluZyhvcHRpb24pKSB7XG5cdFx0XHRjb25maWdbYGF4aXNfJHtpZH1fbGFiZWxgXSA9IHRleHQ7XG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcblx0XHRcdG9wdGlvbi50ZXh0ID0gdGV4dDtcblx0XHR9XG5cdH1cblxuXHRnZXRMYWJlbFBvc2l0aW9uKGlkLCBkZWZhdWx0UG9zaXRpb24pIHtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IChpc09iamVjdFR5cGUob3B0aW9uKSAmJiBvcHRpb24ucG9zaXRpb24pID9cblx0XHRcdG9wdGlvbi5wb3NpdGlvbiA6IGRlZmF1bHRQb3NpdGlvblsrIWlzUm90YXRlZF07XG5cblx0XHRjb25zdCBoYXMgPSB2ID0+ICEhfnBvc2l0aW9uLmluZGV4T2Yodik7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aXNJbm5lcjogaGFzKFwiaW5uZXJcIiksXG5cdFx0XHRpc091dGVyOiBoYXMoXCJvdXRlclwiKSxcblx0XHRcdGlzTGVmdDogaGFzKFwibGVmdFwiKSxcblx0XHRcdGlzQ2VudGVyOiBoYXMoXCJjZW50ZXJcIiksXG5cdFx0XHRpc1JpZ2h0OiBoYXMoXCJyaWdodFwiKSxcblx0XHRcdGlzVG9wOiBoYXMoXCJ0b3BcIiksXG5cdFx0XHRpc01pZGRsZTogaGFzKFwibWlkZGxlXCIpLFxuXHRcdFx0aXNCb3R0b206IGhhcyhcImJvdHRvbVwiKVxuXHRcdH07XG5cdH1cblxuXHRnZXRYQXhpc0xhYmVsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInhcIiwgW1wiaW5uZXItdG9wXCIsIFwiaW5uZXItcmlnaHRcIl0pO1xuXHR9XG5cblx0Z2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ5XCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcblx0fVxuXG5cdGdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInkyXCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcblx0fVxuXG5cdGdldExhYmVsUG9zaXRpb25CeUlkKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXNbYGdldCR7aWQudG9VcHBlckNhc2UoKX1BeGlzTGFiZWxQb3NpdGlvbmBdKCk7XG5cdH1cblxuXHR0ZXh0Rm9yWEF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ4XCIpO1xuXHR9XG5cblx0dGV4dEZvcllBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieVwiKTtcblx0fVxuXG5cdHRleHRGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ5MlwiKTtcblx0fVxuXG5cdHhGb3JBeGlzTGFiZWwocG9zaXRpb24sIGZvckhvcml6b250YWwgPSB0cnVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGxldCB4ID0gcG9zaXRpb24uaXNNaWRkbGUgPyAtJCQuaGVpZ2h0IC8gMiA6IDA7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xuXHRcdFx0eCA9IHBvc2l0aW9uLmlzTGVmdCA/IDAgOiAoXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gJCQud2lkdGggLyAyIDogJCQud2lkdGhcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xuXHRcdFx0eCA9IC0kJC5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRkeEZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcblxuXHRcdGlmIChpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XG5cdFx0XHRkeCA9IHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IChcblx0XHRcdFx0cG9zaXRpb24uaXNSaWdodCA/IFwiLTAuNWVtXCIgOiBcIjBcIlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzVG9wKSB7XG5cdFx0XHRkeCA9IFwiLTAuNWVtXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGR4O1xuXHR9XG5cblx0dGV4dEFuY2hvckZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0bGV0IGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xuXHRcdFx0YW5jaG9yID0gcG9zaXRpb24uaXNMZWZ0ID8gXCJzdGFydFwiIDogKFxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYW5jaG9yO1xuXHR9XG5cblx0eEZvclhBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLCBmYWxzZSk7XG5cdH1cblxuXHR4Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0eEZvclkyQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0ZHhGb3JYQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcblx0fVxuXG5cdGR4Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5keEZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdGR4Rm9yWTJBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0ZHlGb3JYQXhpc0xhYmVsKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcblx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XG5cblx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSB0aGlzLmdldE1heFRpY2tXaWR0aChcInhcIik7XG5cdFx0fSBlbHNlIGlmIChpc0lubmVyKSB7XG5cdFx0XHRyZXR1cm4gXCItMC41ZW1cIjtcblx0XHR9IGVsc2UgaWYgKHhIZWlnaHQpIHtcblx0XHRcdHJldHVybiB4SGVpZ2h0IC0gMTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcIjNlbVwiO1xuXHRcdH1cblx0fVxuXG5cdGR5Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcblxuXHRcdGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiBcIjNlbVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiMS4yZW1cIiA6IC0xMCAtICgkJC5jb25maWcuYXhpc195X2lubmVyID8gMCA6ICh0aGlzLmdldE1heFRpY2tXaWR0aChcInlcIikgKyAxMCkpO1xuXHRcdH1cblx0fVxuXG5cdGR5Rm9yWTJBeGlzTGFiZWwoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKS5pc0lubmVyO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCIxLjJlbVwiIDogXCItMi4yZW1cIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIi0wLjVlbVwiIDogMTUgKyAoJCQuY29uZmlnLmF4aXNfeTJfaW5uZXIgPyAwIDogKHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieTJcIikgKyAxNSkpO1xuXHRcdH1cblx0fVxuXG5cdHRleHRBbmNob3JGb3JYQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xuXHR9XG5cblx0dGV4dEFuY2hvckZvcllBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdHRleHRBbmNob3JGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdGdldE1heFRpY2tXaWR0aChpZCwgd2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY3VycmVudFRpY2tNYXggPSAkJC5jdXJyZW50TWF4VGlja1dpZHRoc1tpZF07XG5cdFx0bGV0IG1heFdpZHRoID0gMDtcblxuXHRcdGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcblx0XHR9XG5cblx0XHRpZiAoJCQuc3ZnKSB7XG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcblx0XHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRjb25zdCBzY2FsZSA9ICQkW2lkXS5jb3B5KCkuZG9tYWluKCQkW2BnZXQke2lzWUF4aXMgPyBcIllcIiA6IFwiWFwifURvbWFpbmBdKHRhcmdldHNUb1Nob3csIGlkKSk7XG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcblxuXHRcdFx0Ly8gZG8gbm90IGNvbXB1dGUgaWYgZG9tYWluIGlzIHNhbWVcblx0XHRcdGlmIChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBkb21haW5baV0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFRpY2tNYXguZG9tYWluID0gZG9tYWluO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBheGlzID0gdGhpcy5nZXRBeGlzKGlkLCBzY2FsZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcblx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2NvdW50YF07XG5cblx0XHRcdC8vIE1ha2UgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHRpY2sgdGV4dCB0byBiZSByZW5kZXJlZFxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvOTIwXG5cdFx0XHRpZiAodGlja0NvdW50KSB7XG5cdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcblx0XHRcdFx0XHR0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcblx0XHRcdFx0XHRcdGRvbWFpbixcblx0XHRcdFx0XHRcdHRpY2tDb3VudCxcblx0XHRcdFx0XHRcdGlzWUF4aXMgPyAkJC5pc1RpbWVTZXJpZXNZKCkgOiAkJC5pc1RpbWVTZXJpZXMoKVxuXHRcdFx0XHRcdCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQhaXNZQXhpcyAmJiB0aGlzLnVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzVG9TaG93LCBheGlzKTtcblxuXHRcdFx0Y29uc3QgZHVtbXkgPSAkJC5zZWxlY3RDaGFydC5hcHBlbmQoXCJzdmdcIilcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcImZpeGVkXCIpXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBcIjBweFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIFwiMHB4XCIpO1xuXG5cdFx0XHRheGlzLmNyZWF0ZShkdW1teSk7XG5cblx0XHRcdGR1bW15LnNlbGVjdEFsbChcInRleHRcIilcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRkdW1teS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRpZiAobWF4V2lkdGggPiAwKSB7XG5cdFx0XHRjdXJyZW50VGlja01heC5zaXplID0gbWF4V2lkdGg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XG5cdH1cblxuXHR1cGRhdGVMYWJlbHMod2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgbGFiZWxzID0ge1xuXHRcdFx0WDogJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfSAuJHtDTEFTUy5heGlzWExhYmVsfWApLFxuXHRcdFx0WTogJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfSAuJHtDTEFTUy5heGlzWUxhYmVsfWApLFxuXHRcdFx0WTI6ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9IC4ke0NMQVNTLmF4aXNZMkxhYmVsfWApXG5cdFx0fTtcblxuXHRcdE9iamVjdC5rZXlzKGxhYmVscykuZmlsdGVyKGlkID0+ICFsYWJlbHNbaWRdLmVtcHR5KCkpXG5cdFx0XHQuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGxhYmVsc1t2XTtcblx0XHRcdFx0Y29uc3QgYXhpc0xhYmVsID0gYCR7dn1BeGlzTGFiZWxgO1xuXG5cdFx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IG5vZGUudHJhbnNpdGlvbigpIDogbm9kZSlcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgdGhpc1tgeEZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCB0aGlzW2BkeEZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCB0aGlzW2BkeUZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXG5cdFx0XHRcdFx0LnRleHQodGhpc1tgdGV4dEZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRnZXRQYWRkaW5nKHBhZGRpbmcsIGtleSwgZGVmYXVsdFZhbHVlLCBkb21haW5MZW5ndGgpIHtcblx0XHRjb25zdCBwID0gaXNOdW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xuXG5cdFx0aWYgKCFpc1ZhbHVlKHApKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChwYWRkaW5nLnVuaXQgPT09IFwicmF0aW9cIikge1xuXHRcdFx0cmV0dXJuIHBhZGRpbmdba2V5XSAqIGRvbWFpbkxlbmd0aDtcblx0XHR9XG5cblx0XHQvLyBhc3N1bWUgcGFkZGluZyBpcyBwaXhlbHMgaWYgdW5pdCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocCwgZG9tYWluTGVuZ3RoKTtcblx0fVxuXG5cdGNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHBpeGVscywgZG9tYWluTGVuZ3RoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aCA6ICQkLmhlaWdodDtcblxuXHRcdHJldHVybiBkb21haW5MZW5ndGggKiAocGl4ZWxzIC8gbGVuZ3RoKTtcblx0fVxuXG5cdGdlbmVyYXRlVGlja1ZhbHVlcyh2YWx1ZXMsIHRpY2tDb3VudCwgZm9yVGltZVNlcmllcykge1xuXHRcdGxldCB0aWNrVmFsdWVzID0gdmFsdWVzO1xuXHRcdGxldCBzdGFydDtcblx0XHRsZXQgZW5kO1xuXHRcdGxldCBjb3VudDtcblx0XHRsZXQgaW50ZXJ2YWw7XG5cdFx0bGV0IGk7XG5cdFx0bGV0IHRpY2tWYWx1ZTtcblxuXHRcdGlmICh0aWNrQ291bnQpIHtcblx0XHRcdGNvbnN0IHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGlja3MgYWNjb3JkaW5nIHRvIHRpY2tDb3VudFxuXHRcdFx0aWYgKHRhcmdldENvdW50ID09PSAxKSB7XG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbdmFsdWVzWzBdXTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Q291bnQgPT09IDIpIHtcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXRDb3VudCA+IDIpIHtcblx0XHRcdFx0Y291bnQgPSB0YXJnZXRDb3VudCAtIDI7XG5cdFx0XHRcdHN0YXJ0ID0gdmFsdWVzWzBdO1xuXHRcdFx0XHRlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpbnRlcnZhbCA9IChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKTtcblxuXHRcdFx0XHQvLyByZS1jb25zdHJ1Y3QgdW5pcXVlIHZhbHVlc1xuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3N0YXJ0XTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHRpY2tWYWx1ZSA9ICtzdGFydCArIGludGVydmFsICogKGkgKyAxKTtcblx0XHRcdFx0XHR0aWNrVmFsdWVzLnB1c2goZm9yVGltZVNlcmllcyA/IG5ldyBEYXRlKHRpY2tWYWx1ZSkgOiB0aWNrVmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGVuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFmb3JUaW1lU2VyaWVzKSB7XG5cdFx0XHR0aWNrVmFsdWVzID0gdGlja1ZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpY2tWYWx1ZXM7XG5cdH1cblxuXHRnZW5lcmF0ZVRyYW5zaXRpb25zKGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGF4ZXMgPSAkJC5heGVzO1xuXG5cdFx0Y29uc3QgW2F4aXNYLCBheGlzWSwgYXhpc1kyLCBheGlzU3ViWF0gPSBbXCJ4XCIsIFwieVwiLCBcInkyXCIsIFwic3VieFwiXVxuXHRcdFx0Lm1hcCh2ID0+IHtcblx0XHRcdFx0bGV0IGF4aXMgPSBheGVzW3ZdO1xuXG5cdFx0XHRcdGlmIChheGlzICYmIGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0YXhpcyA9IGF4aXMudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBheGlzO1xuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4ge2F4aXNYLCBheGlzWSwgYXhpc1kyLCBheGlzU3ViWH07XG5cdH1cblxuXHRyZWRyYXcodHJhbnNpdGlvbnMsIGlzSGlkZGVuLCBpc0luaXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3Qgb3BhY2l0eSA9IGlzSGlkZGVuID8gXCIwXCIgOiBcIjFcIjtcblxuXHRcdFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0Y29uc3QgYXhpcyA9ICQkW2Ake2lkfUF4aXNgXTtcblxuXHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0aWYgKCFpc0luaXQpIHtcblx0XHRcdFx0XHRheGlzLmNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9ICEkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQkLmF4ZXNbaWQudG9Mb3dlckNhc2UoKV0uc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xuXHRcdFx0XHRheGlzLmNyZWF0ZSh0cmFuc2l0aW9uc1tgYXhpcyR7Y2FwaXRhbGl6ZShpZCl9YF0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy51cGRhdGVBeGVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVkcmF3IGF4aXNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNUb1Nob3cgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3dGhcblx0ICogQHBhcmFtIHtPamJlY3R9IHRyYW5zaXRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmbG93XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZWRyYXdBeGlzKHRhcmdldHNUb1Nob3csIHd0aCwgdHJhbnNpdGlvbnMsIGZsb3csIGlzSW5pdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhJCQuem9vbVNjYWxlO1xuXHRcdGxldCB4RG9tYWluRm9yWm9vbTtcblxuXHRcdGlmICghaGFzWm9vbSAmJiAkJC5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcblx0XHRcdCQkLnguZG9tYWluKFswLCAkJC5heGVzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSk7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcblx0XHRcdCFoYXNab29tICYmXG5cdFx0XHRcdCQkLnVwZGF0ZVhEb21haW4odGFyZ2V0c1RvU2hvdywgd3RoLlVwZGF0ZVhEb21haW4sIHd0aC5VcGRhdGVPcmdYRG9tYWluLCB3dGguVHJpbVhEb21haW4pO1xuXG5cdFx0XHRpZiAoIWNvbmZpZy5heGlzX3hfdGlja192YWx1ZXMpIHtcblx0XHRcdFx0dGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICgkJC54QXhpcykge1xuXHRcdFx0JCQueEF4aXMudGlja1ZhbHVlcyhbXSk7XG5cdFx0XHQkJC5zdWJYQXhpcy50aWNrVmFsdWVzKFtdKTtcblx0XHR9XG5cblx0XHRpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhZmxvdykge1xuXHRcdFx0eERvbWFpbkZvclpvb20gPSAkJC54Lm9yZ0RvbWFpbigpO1xuXHRcdH1cblxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRjb25zdCBheGlzID0gJCRba2V5XTtcblxuXHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcblx0XHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX2NvdW50YF07XG5cblx0XHRcdFx0YXhpcy5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBrZXksIHhEb21haW5Gb3Jab29tKSk7XG5cblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXMuZG9tYWluKCk7XG5cblx0XHRcdFx0XHQkJFtgJHtrZXl9QXhpc2BdLnRpY2tWYWx1ZXMoXG5cdFx0XHRcdFx0XHR0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcblx0XHRcdFx0XHRcdFx0ZG9tYWluLFxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXG5cdFx0XHRcdFx0XHRcdCQkLmlzVGltZVNlcmllc1koKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGF4ZXNcblx0XHR0aGlzLnJlZHJhdyh0cmFuc2l0aW9ucywgJCQuaGFzQXJjVHlwZSgpLCBpc0luaXQpO1xuXG5cdFx0Ly8gVXBkYXRlIGF4aXMgbGFiZWxcblx0XHR0aGlzLnVwZGF0ZUxhYmVscyh3dGguVHJhbnNpdGlvbik7XG5cblx0XHQvLyBzaG93L2hpZGUgaWYgbWFudWFsIGN1bGxpbmcgbmVlZGVkXG5cdFx0aWYgKCh3dGguVXBkYXRlWERvbWFpbiB8fCB3dGguVXBkYXRlWEF4aXMpICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnNldEN1bGxpbmcoKTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgc3ViIGRvbWFpblxuXHRcdGlmICh3dGguWSkge1xuXHRcdFx0JCQuc3ViWSAmJiAkJC5zdWJZLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInkyXCIpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0IG1hbnVhbCBjdWxsaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRDdWxsaW5nKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRbXCJzdWJ4XCIsIFwieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKHR5cGUgPT4ge1xuXHRcdFx0Y29uc3QgYXhpcyA9ICQkLmF4ZXNbdHlwZV07XG5cblx0XHRcdC8vIHN1YmNoYXJ0IHggYXhpcyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHggYXhpcyBjdWxsaW5nXG5cdFx0XHRjb25zdCBpZCA9IHR5cGUgPT09IFwic3VieFwiID8gXCJ4XCIgOiB0eXBlO1xuXHRcdFx0Y29uc3QgdG9DdWxsID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ2BdO1xuXG5cdFx0XHRpZiAoYXhpcyAmJiB0b0N1bGwpIHtcblx0XHRcdFx0Y29uc3QgdGlja1RleHQgPSBheGlzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIik7XG5cdFx0XHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSBzb3J0VmFsdWUodGlja1RleHQuZGF0YSgpKTtcblx0XHRcdFx0Y29uc3QgdGlja1NpemUgPSB0aWNrVmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0Y29uc3QgY3VsbGluZ01heCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2N1bGxpbmdfbWF4YF07XG5cdFx0XHRcdGxldCBpbnRlcnZhbEZvckN1bGxpbmc7XG5cblx0XHRcdFx0aWYgKHRpY2tTaXplKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAodGlja1NpemUgLyBpIDwgY3VsbGluZ01heCkge1xuXHRcdFx0XHRcdFx0XHRpbnRlcnZhbEZvckN1bGxpbmcgPSBpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aWNrVGV4dC5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IHRpY2tWYWx1ZXMuaW5kZXhPZihkKSAlIGludGVydmFsRm9yQ3VsbGluZyA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tUZXh0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cbmltcG9ydCB7XG5cdHRpbWVQYXJzZSBhcyBkM1RpbWVQYXJzZSxcblx0dGltZUZvcm1hdCBhcyBkM1RpbWVGb3JtYXQsXG5cdHV0Y1BhcnNlIGFzIGQzVXRjUGFyc2UsXG5cdHV0Y0Zvcm1hdCBhcyBkM1V0Y0Zvcm1hdFxufSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi4vYXhpcy9BeGlzXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IHtub3RFbXB0eSwgYXNIYWxmUGl4ZWwsIGdldE9wdGlvbiwgaXNWYWx1ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc09iamVjdCwgY2FsbEZuLCBzb3J0VmFsdWV9IGZyb20gXCIuL3V0aWxcIjtcblxuLyoqXG4gKiBJbnRlcm5hbCBjaGFydCBjbGFzcy5cbiAqIC0gTm90ZTogSW5zdGFudGlhdGVkIGludGVybmFsbHksIG5vdCBleHBvc2VkIGZvciBwdWJsaWMuXG4gKiBAY2xhc3MgQ2hhcnRJbnRlcm5hbFxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnRJbnRlcm5hbCB7XG5cdGNvbnN0cnVjdG9yKGFwaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmFwaSA9IGFwaTtcblx0XHQkJC5jb25maWcgPSAkJC5nZXRPcHRpb25zKCk7XG5cdFx0JCQuZGF0YSA9IHt9O1xuXHRcdCQkLmNhY2hlID0ge307XG5cdFx0JCQuYXhlcyA9IHt9O1xuXHRcdCQkLnJlbmRlcmVkID0gZmFsc2U7XG5cdH1cblxuXHRiZWZvcmVJbml0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XG5cblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkLCAkJC5hcGkpO1xuXHR9XG5cblx0YWZ0ZXJJbml0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGFmdGVySW5pdFwiKTtcblxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcblx0XHRjYWxsRm4oJCQuY29uZmlnLm9uYWZ0ZXJpbml0LCAkJCwgJCQuYXBpKTtcblx0fVxuXG5cdGluaXQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLmluaXRQYXJhbXMoKTtcblxuXHRcdGNvbnN0IGJpbmR0byA9IHtcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXG5cdFx0XHRjbGFzc25hbWU6IFwiYmJcIlxuXHRcdH07XG5cblx0XHRpZiAoaXNPYmplY3QoY29uZmlnLmJpbmR0bykpIHtcblx0XHRcdGJpbmR0by5lbGVtZW50ID0gY29uZmlnLmJpbmR0by5lbGVtZW50IHx8IFwiI2NoYXJ0XCI7XG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XG5cdFx0JCQuc2VsZWN0Q2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cblx0XHRcdGNvbmZpZy5iaW5kdG8uZWxlbWVudCA6IGQzU2VsZWN0KGJpbmR0by5lbGVtZW50IHx8IFtdKTtcblxuXHRcdGlmICgkJC5zZWxlY3RDaGFydC5lbXB0eSgpKSB7XG5cdFx0XHQkJC5zZWxlY3RDaGFydCA9IGQzU2VsZWN0KGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpO1xuXHRcdH1cblxuXHRcdCQkLnNlbGVjdENoYXJ0Lmh0bWwoXCJcIikuY2xhc3NlZChiaW5kdG8uY2xhc3NuYW1lLCB0cnVlKTtcblx0XHQkJC5pbml0VG9SZW5kZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSByZW5kZXJpbmcgcHJvY2Vzc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlZCBGb3JjZSB0byByZW5kZXIgcHJvY2Vzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFRvUmVuZGVyKGZvcmNlZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gJCQuc2VsZWN0Q2hhcnQ7XG5cdFx0Y29uc3QgaXNIaWRkZW4gPSAoKSA9PiB0YXJnZXQuc3R5bGUoXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIiB8fCB0YXJnZXQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xuXG5cdFx0Y29uc3QgaXNMYXp5ID0gY29uZmlnLnJlbmRlci5sYXp5IHx8IGlzSGlkZGVuKCk7XG5cdFx0Y29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xuXG5cdFx0aWYgKGlzTGF6eSAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGNvbmZpZy5yZW5kZXIub2JzZXJ2ZSAhPT0gZmFsc2UgJiYgIWZvcmNlZCkge1xuXHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uLCBvYnNlcnZlcikgPT4ge1xuXHRcdFx0XHRpZiAoIWlzSGlkZGVuKCkpIHtcblx0XHRcdFx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdFx0ISQkLnJlbmRlcmVkICYmICQkLmluaXRUb1JlbmRlcih0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkub2JzZXJ2ZSh0YXJnZXQubm9kZSgpLCB7XG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHRydWUsXG5cdFx0XHRcdGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIiwgXCJzdHlsZVwiXVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0xhenkgfHwgZm9yY2VkKSB7XG5cdFx0XHRjb25zdCBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xuXG5cdFx0XHRjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKTtcblx0XHR9XG5cdH1cblxuXHRpbml0UGFyYW1zKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIGRhdGV0aW1lIHRvIGJlIHVzZWQgZm9yIHVuaXF1ZW5lc3Ncblx0XHQkJC5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcblx0XHQkJC5pbml0Q2xpcCgpO1xuXG5cdFx0JCQuZHJhZ1N0YXJ0ID0gbnVsbDtcblx0XHQkJC5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdCQkLmZsb3dpbmcgPSBmYWxzZTtcblx0XHQkJC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdCQkLm1vdXNlb3ZlciA9IGZhbHNlO1xuXHRcdCQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcblxuXHRcdCQkLmNvbG9yID0gJCQuZ2VuZXJhdGVDb2xvcigpO1xuXHRcdCQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcblx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcblxuXHRcdCQkLmV4dHJhTGluZUNsYXNzZXMgPSAkJC5nZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk7XG5cblx0XHQkJC5kYXRhVGltZUZvcm1hdCA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XG5cdFx0JCQuYXhpc1RpbWVGb3JtYXQgPSBjb25maWcuYXhpc194X2xvY2FsdGltZSA/IGQzVGltZUZvcm1hdCA6IGQzVXRjRm9ybWF0O1xuXG5cdFx0Y29uc3QgaXNEcmFnWm9vbSA9ICQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIjtcblxuXHRcdCQkLmRlZmF1bHRBeGlzVGltZUZvcm1hdCA9IGQgPT4ge1xuXHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gdGhpcy56b29tU2NhbGUgOlxuXHRcdFx0XHR0aGlzLnpvb21TY2FsZSAmJiAkJC54Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHRoaXMuem9vbVNjYWxlLmRvbWFpbigpLnRvU3RyaW5nKCk7XG5cblx0XHRcdGNvbnN0IHNwZWNpZmllciA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XG5cdFx0XHRcdChkLmdldFNlY29uZHMoKSAmJiBcIi46JVNcIikgfHxcblx0XHRcdFx0KGQuZ2V0TWludXRlcygpICYmIFwiJUk6JU1cIikgfHxcblx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XG5cdFx0XHRcdChkLmdldERhdGUoKSAhPT0gMSAmJiBcIiViICVkXCIpIHx8XG5cdFx0XHRcdChpc1pvb21lZCAmJiBkLmdldERhdGUoKSA9PT0gMSAmJiBcIiViXFwnJXlcIikgfHxcblx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xuXG5cdFx0XHRyZXR1cm4gJCQuYXhpc1RpbWVGb3JtYXQoc3BlY2lmaWVyKShkKTtcblx0XHR9O1xuXG5cdFx0JCQuaGlkZGVuVGFyZ2V0SWRzID0gW107XG5cdFx0JCQuaGlkZGVuTGVnZW5kSWRzID0gW107XG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXG5cdFx0JCQuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiO1xuXG5cdFx0JCQuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtcmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZExlZnQgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJib3R0b20tbGVmdFwiO1xuXG5cdFx0JCQubGVnZW5kU3RlcCA9IDA7XG5cdFx0JCQubGVnZW5kSXRlbVdpZHRoID0gMDtcblx0XHQkJC5sZWdlbmRJdGVtSGVpZ2h0ID0gMDtcblxuXHRcdCQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzID0ge1xuXHRcdFx0eDoge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXG5cdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcblx0XHRcdHkyOiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifVxuXHRcdH07XG5cblx0XHQkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCA9IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ19yaWdodCA9IGlzUm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeF9zaG93ID8gMCA6IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ190b3AgPSA1O1xuXG5cdFx0JCQud2l0aG91dEZhZGVJbiA9IHt9O1xuXHRcdCQkLmlucHV0VHlwZSA9ICQkLmNvbnZlcnRJbnB1dFR5cGUoKTtcblxuXHRcdCQkLmF4ZXMuc3VieCA9IGQzU2VsZWN0QWxsKFtdKTsgLy8gbmVlZHMgd2hlbiBleGNsdWRpbmcgc3ViY2hhcnQuanNcblx0fVxuXG5cdGluaXRXaXRoRGF0YShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXG5cdFx0Ly8gJCQuaGFzQXJjVHlwZSgpICYmIFtcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChpZCA9PiAoY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA9IGZhbHNlKSk7XG5cblx0XHQkJC5heGlzID0gbmV3IEF4aXMoJCQpO1xuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcblxuXHRcdC8vIEluaXQgZGF0YSBhcyB0YXJnZXRzXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpO1xuXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0YXJnZXRzIHRvIGhpZGUgaWYgbmVlZGVkXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlblRhcmdldElkcyhcblx0XHRcdFx0Y29uZmlnLmRhdGFfaGlkZSA9PT0gdHJ1ZSA/XG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5kYXRhX2hpZGVcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGlmIChjb25maWcubGVnZW5kX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyhcblx0XHRcdFx0Y29uZmlnLmxlZ2VuZF9oaWRlID09PSB0cnVlID9cblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmxlZ2VuZF9oaWRlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gZ2F1Z2UsIGhpZGUgbGVnZW5kIC8vIFRPRE86IGZpeFxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgc2l6ZXMgYW5kIHNjYWxlc1xuXHRcdCQkLnVwZGF0ZVNpemVzKCk7XG5cdFx0JCQudXBkYXRlU2NhbGVzKHRydWUpO1xuXG5cdFx0Ly8gU2V0IGRvbWFpbnMgZm9yIGVhY2ggc2NhbGVcblx0XHRpZiAoJCQueCkge1xuXHRcdFx0JCQueC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xuXHRcdFx0JCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG5cblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXG5cdFx0XHQkJC5vcmdYRG9tYWluID0gJCQueC5kb21haW4oKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueSkge1xuXHRcdFx0JCQueS5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZLmRvbWFpbigkJC55LmRvbWFpbigpKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueTIpIHtcblx0XHRcdCQkLnkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQueTIuZG9tYWluKCkpO1xuXHRcdH1cblxuXHRcdC8vIC0tIEJhc2ljIEVsZW1lbnRzIC0tXG5cdFx0JCQuc3ZnID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpXG5cdFx0XHQuc3R5bGUoXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKVxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLmlucHV0VHlwZSkge1xuXHRcdFx0Y29uc3QgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuXG5cdFx0XHQkJC5zdmdcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2VlbnRlclwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3ZlciwgJCQsICQkLmFwaSkpXG5cdFx0XHRcdC5vbihpc1RvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZWxlYXZlXCIsICgpID0+IGNhbGxGbihjb25maWcub25vdXQsICQkLCAkJC5hcGkpKTtcblx0XHR9XG5cblx0XHRjb25maWcuc3ZnX2NsYXNzbmFtZSAmJiAkJC5zdmcuYXR0cihcImNsYXNzXCIsIGNvbmZpZy5zdmdfY2xhc3NuYW1lKTtcblxuXHRcdC8vIERlZmluZSBkZWZzXG5cdFx0JCQuZGVmcyA9ICQkLnN2Zy5hcHBlbmQoXCJkZWZzXCIpO1xuXG5cdFx0JCQuY2xpcENoYXJ0ID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWQpO1xuXHRcdCQkLmNsaXBYQXhpcyA9ICQkLmFwcGVuZENsaXAoJCQuZGVmcywgJCQuY2xpcElkRm9yWEF4aXMpO1xuXHRcdCQkLmNsaXBZQXhpcyA9ICQkLmFwcGVuZENsaXAoJCQuZGVmcywgJCQuY2xpcElkRm9yWUF4aXMpO1xuXHRcdCQkLmNsaXBHcmlkID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWRGb3JHcmlkKTtcblxuXHRcdC8vIHNldCBjb2xvciBwYXR0ZXJuc1xuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykgJiYgJCQucGF0dGVybnMpIHtcblx0XHRcdCQkLnBhdHRlcm5zLmZvckVhY2gocCA9PiAkJC5kZWZzLmFwcGVuZCgoKSA9PiBwLm5vZGUpKTtcblx0XHR9XG5cblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XG5cblx0XHQvLyBEZWZpbmUgcmVnaW9uc1xuXHRcdGNvbnN0IG1haW4gPSAkJC5zdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcIm1haW5cIikpO1xuXG5cdFx0JCQubWFpbiA9IG1haW47XG5cblx0XHQvLyBpbml0aWFsaXplIHN1YmNoYXJ0IHdoZW4gc3ViY2hhcnQgc2hvdyBvcHRpb24gaXMgc2V0XG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCk7XG5cblx0XHQkJC5pbml0VG9vbHRpcCAmJiAkJC5pbml0VG9vbHRpcCgpO1xuXHRcdCQkLmluaXRMZWdlbmQgJiYgJCQuaW5pdExlZ2VuZCgpO1xuXHRcdCQkLmluaXRUaXRsZSAmJiAkJC5pbml0VGl0bGUoKTtcblxuXHRcdC8vIC0tIE1haW4gUmVnaW9uIC0tXG5cblx0XHQvLyB0ZXh0IHdoZW4gZW1wdHlcblx0XHRpZiAoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkge1xuXHRcdFx0bWFpbi5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYCR7Q0xBU1MudGV4dH0gJHtDTEFTUy5lbXB0eX1gKVxuXHRcdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRcdC5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIik7IC8vIHZlcnRpY2FsIGNlbnRlcmluZyBvZiB0ZXh0IGF0IHkgcG9zaXRpb24gaW4gYWxsIGJyb3dzZXJzLCBleGNlcHQgSUUuXG5cdFx0fVxuXG5cdFx0Ly8gUmVnaW9uc1xuXHRcdCQkLmluaXRSZWdpb24oKTtcblxuXHRcdC8vIEFkZCBBeGlzIGhlcmUsIHdoZW4gY2xpcFBhdGggaXMgJ2ZhbHNlJ1xuXHRcdCFjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcy5pbml0KCk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aCk7XG5cblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRpbml0XCIpO1xuXG5cdFx0Ly8gQ292ZXIgd2hvbGUgd2l0aCByZWN0cyBmb3IgZXZlbnRzXG5cdFx0JCQuaW5pdEV2ZW50UmVjdCgpO1xuXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0XG5cdFx0JCQuaW5pdENoYXJ0RWxlbWVudHMoKTtcblxuXHRcdC8vIEdyaWRzXG5cdFx0JCQuaW5pdEdyaWQoKTtcblxuXHRcdC8vIGlmIHpvb20gcHJpdmlsZWdlZCwgaW5zZXJ0IHJlY3QgdG8gZm9yZWZyb250XG5cdFx0Ly8gVE9ETzogaXMgdGhpcyBuZWVkZWQ/XG5cdFx0bWFpbi5pbnNlcnQoXCJyZWN0XCIsIGNvbmZpZy56b29tX3ByaXZpbGVnZWQgPyBudWxsIDogYGcuJHtDTEFTUy5yZWdpb25zfWApXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnpvb21SZWN0KVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xuXG5cdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAndHJ1ZSdcblx0XHRjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcy5pbml0KCk7XG5cblx0XHQvLyBTZXQgdGFyZ2V0c1xuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdC8vIERyYXcgd2l0aCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlRGltZW5zaW9uKCk7XG5cblx0XHQvLyBvbmluaXQgY2FsbGJhY2tcblx0XHRjYWxsRm4oY29uZmlnLm9uaW5pdCwgJCQsICQkLmFwaSk7XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlLFxuXHRcdFx0aW5pdGlhbGl6aW5nOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyBkYXRhLm9ubWluL21heCBjYWxsYmFja1xuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4RGF0YSgpO1xuXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKTtcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1heCwgJCQsIG1pbk1heC5tYXgpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgcmVzaXplIGV2ZW50XG5cdFx0JCQuYmluZFJlc2l6ZSgpO1xuXG5cdFx0Ly8gZXhwb3J0IGVsZW1lbnQgb2YgdGhlIGNoYXJ0XG5cdFx0JCQuYXBpLmVsZW1lbnQgPSAkJC5zZWxlY3RDaGFydC5ub2RlKCk7XG5cblx0XHQkJC5yZW5kZXJlZCA9IHRydWU7XG5cdH1cblxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRbXCJCYXJcIiwgXCJSYWRhclwiLCBcIkxpbmVcIiwgXCJCdWJibGVcIiwgXCJBcmNcIiwgXCJHYXVnZVwiLCBcIlBpZVwiXS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0JCRbYGluaXQke3Z9YF0oKTtcblx0XHR9KTtcblxuXHRcdG5vdEVtcHR5KCQkLmNvbmZpZy5kYXRhX2xhYmVscykgJiYgJCQuaW5pdFRleHQoKTtcblx0fVxuXG5cdHNldENoYXJ0RWxlbWVudHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuYXBpLiQgPSB7XG5cdFx0XHRjaGFydDogJCQuc2VsZWN0Q2hhcnQsXG5cdFx0XHRzdmc6ICQkLnN2Zyxcblx0XHRcdGRlZnM6ICQkLmRlZnMsXG5cdFx0XHRtYWluOiAkJC5tYWluLFxuXHRcdFx0dG9vbHRpcDogJCQudG9vbHRpcCxcblx0XHRcdGxlZ2VuZDogJCQubGVnZW5kLFxuXHRcdFx0dGl0bGU6ICQkLnRpdGxlLFxuXHRcdFx0Z3JpZDogJCQuZ3JpZCxcblx0XHRcdGFyYzogJCQuYXJjcyxcblx0XHRcdGJhcjoge1xuXHRcdFx0XHRiYXJzOiAkJC5tYWluQmFyXG5cdFx0XHR9LFxuXHRcdFx0bGluZToge1xuXHRcdFx0XHRsaW5lczogJCQubWFpbkxpbmUsXG5cdFx0XHRcdGFyZWFzOiAkJC5tYWluQXJlYSxcblx0XHRcdFx0Y2lyY2xlczogJCQubWFpbkNpcmNsZVxuXHRcdFx0fSxcblx0XHRcdHRleHQ6IHtcblx0XHRcdFx0dGV4dHM6ICQkLm1haW5UZXh0XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdHNtb290aExpbmVzKGVsLCB0eXBlKSB7XG5cdFx0aWYgKHR5cGUgPT09IFwiZ3JpZFwiKSB7XG5cdFx0XHRlbC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IFt4MSwgeDIsIHkxLCB5Ml0gPSBbXCJ4MVwiLCBcIngyXCIsIFwieTFcIiwgXCJ5MlwiXVxuXHRcdFx0XHRcdC5tYXAodiA9PiBNYXRoLmNlaWwoZy5hdHRyKHYpKSk7XG5cblx0XHRcdFx0Zy5hdHRyKHt4MSwgeDIsIHkxLCB5Mn0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzaXplIHZhbHVlc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCBJZiBpcyBjYWxsZWQgYXQgaW5pdGlhbGl6YXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZVNpemVzKGlzSW5pdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XG5cblx0XHRjb25zdCBsZWdlbmQgPSB7XG5cdFx0XHR3aWR0aDogJCQubGVnZW5kID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6ICQkLmxlZ2VuZCA/ICQkLmdldExlZ2VuZEhlaWdodCgpIDogMFxuXHRcdH07XG5cblx0XHRjb25zdCBsZWdlbmRIZWlnaHRGb3JCb3R0b20gPSAkJC5pc0xlZ2VuZFJpZ2h0IHx8ICQkLmlzTGVnZW5kSW5zZXQgPyAwIDogbGVnZW5kLmhlaWdodDtcblx0XHRjb25zdCB4QXhpc0hlaWdodCA9IGlzUm90YXRlZCB8fCBoYXNBcmMgPyAwIDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ4XCIpO1xuXG5cdFx0Y29uc3Qgc3ViY2hhcnRYQXhpc0hlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyAmJiBjb25maWcuc3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93ID9cblx0XHRcdHhBeGlzSGVpZ2h0IDogMzA7XG5cdFx0Y29uc3Qgc3ViY2hhcnRIZWlnaHQgPSBjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAhaGFzQXJjID9cblx0XHRcdChjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgKyBzdWJjaGFydFhBeGlzSGVpZ2h0KSA6IDA7XG5cblx0XHQhaXNJbml0ICYmICQkLnNldENvbnRhaW5lclNpemUoKTtcblxuXHRcdC8vIGZvciBtYWluXG5cdFx0JCQubWFyZ2luID0gaXNSb3RhdGVkID8ge1xuXHRcdFx0dG9wOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSxcblx0XHRcdHJpZ2h0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpLFxuXHRcdFx0Ym90dG9tOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInlcIikgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxuXHRcdFx0bGVmdDogc3ViY2hhcnRIZWlnaHQgKyAoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpKVxuXHRcdH0gOiB7XG5cdFx0XHR0b3A6IDQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLCAvLyBmb3IgdG9wIHRpY2sgdGV4dFxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXG5cdFx0XHRib3R0b206IHhBeGlzSGVpZ2h0ICsgc3ViY2hhcnRIZWlnaHQgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxuXHRcdFx0bGVmdDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpXG5cdFx0fTtcblxuXHRcdC8vIGZvciBzdWJjaGFydFxuXHRcdCQkLm1hcmdpbjIgPSBpc1JvdGF0ZWQgPyB7XG5cdFx0XHR0b3A6ICQkLm1hcmdpbi50b3AsXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiAyMCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcblx0XHRcdGxlZnQ6ICQkLnJvdGF0ZWRfcGFkZGluZ19sZWZ0XG5cdFx0fSA6IHtcblx0XHRcdHRvcDogJCQuY3VycmVudEhlaWdodCAtIHN1YmNoYXJ0SGVpZ2h0IC0gbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuXHRcdFx0cmlnaHQ6IE5hTixcblx0XHRcdGJvdHRvbTogc3ViY2hhcnRYQXhpc0hlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcblx0XHRcdGxlZnQ6ICQkLm1hcmdpbi5sZWZ0XG5cdFx0fTtcblxuXHRcdC8vIGZvciBsZWdlbmRcblx0XHQkJC5tYXJnaW4zID0ge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IE5hTixcblx0XHRcdGJvdHRvbTogMCxcblx0XHRcdGxlZnQ6IDBcblx0XHR9O1xuXG5cdFx0JCQudXBkYXRlU2l6ZUZvckxlZ2VuZCAmJiAkJC51cGRhdGVTaXplRm9yTGVnZW5kKGxlZ2VuZCk7XG5cblx0XHQkJC53aWR0aCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLm1hcmdpbi5sZWZ0IC0gJCQubWFyZ2luLnJpZ2h0O1xuXHRcdCQkLmhlaWdodCA9ICQkLmN1cnJlbnRIZWlnaHQgLSAkJC5tYXJnaW4udG9wIC0gJCQubWFyZ2luLmJvdHRvbTtcblxuXHRcdGlmICgkJC53aWR0aCA8IDApIHtcblx0XHRcdCQkLndpZHRoID0gMDtcblx0XHR9XG5cblx0XHRpZiAoJCQuaGVpZ2h0IDwgMCkge1xuXHRcdFx0JCQuaGVpZ2h0ID0gMDtcblx0XHR9XG5cblx0XHQkJC53aWR0aDIgPSBpc1JvdGF0ZWQgP1xuXHRcdFx0JCQubWFyZ2luLmxlZnQgLSAkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCAtICQkLnJvdGF0ZWRfcGFkZGluZ19yaWdodCA6ICQkLndpZHRoO1xuXG5cdFx0JCQuaGVpZ2h0MiA9IGlzUm90YXRlZCA/XG5cdFx0XHQkJC5oZWlnaHQgOiAkJC5jdXJyZW50SGVpZ2h0IC0gJCQubWFyZ2luMi50b3AgLSAkJC5tYXJnaW4yLmJvdHRvbTtcblxuXHRcdGlmICgkJC53aWR0aDIgPCAwKSB7XG5cdFx0XHQkJC53aWR0aDIgPSAwO1xuXHRcdH1cblxuXHRcdGlmICgkJC5oZWlnaHQyIDwgMCkge1xuXHRcdFx0JCQuaGVpZ2h0MiA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gZm9yIGFyY1xuXHRcdCQkLmFyY1dpZHRoID0gJCQud2lkdGggLSAoJCQuaXNMZWdlbmRSaWdodCA/IGxlZ2VuZC53aWR0aCArIDEwIDogMCk7XG5cdFx0JCQuYXJjSGVpZ2h0ID0gJCQuaGVpZ2h0IC0gKCQkLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApO1xuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUpIHtcblx0XHRcdCQkLmFyY0hlaWdodCArPSAkJC5oZWlnaHQgLSAkJC5nZXRHYXVnZUxhYmVsSGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0JCQudXBkYXRlUmFkaXVzICYmICQkLnVwZGF0ZVJhZGl1cygpO1xuXG5cdFx0aWYgKCQkLmlzTGVnZW5kUmlnaHQgJiYgaGFzQXJjKSB7XG5cdFx0XHQkJC5tYXJnaW4zLmxlZnQgPSAkJC5hcmNXaWR0aCAvIDIgKyAkJC5yYWRpdXNFeHBhbmRlZCAqIDEuMTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRhcmdldGVkIGVsZW1lbnQgd2l0aCBnaXZlbiBkYXRhXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIERhdGEgb2JqZWN0IGZvcm1hdHRlZCBhcyAndGFyZ2V0J1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlVGFyZ2V0cyh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Ly8gVGV4dFxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JUZXh0KHRhcmdldHMpO1xuXG5cdFx0Ly8gQmFyXG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKTtcblxuXHRcdC8vIExpbmVcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKTtcblxuXHRcdC8vIEFyYyAmIFJhZGFyXG5cdFx0JCQuaGFzQXJjVHlwZSh0YXJnZXRzKSAmJiAoXG5cdFx0XHQkJC5oYXNUeXBlKFwicmFkYXJcIikgP1xuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cykgOlxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpXG5cdFx0KTtcblxuXHRcdC8vIFN1YiBDaGFydFxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCAmJlxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpO1xuXG5cdFx0Ly8gRmFkZS1pbiBlYWNoIGNoYXJ0XG5cdFx0JCQuc2hvd1RhcmdldHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5IHRhcmdldGVkIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzaG93VGFyZ2V0cygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy50YXJnZXR9YClcblx0XHRcdC5maWx0ZXIoZCA9PiAkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXHR9XG5cblx0Z2V0V2l0aE9wdGlvbihvcHRpb25zKSB7XG5cdFx0Y29uc3Qgd2l0aE9wdGlvbnMgPSB7XG5cdFx0XHRZOiB0cnVlLFxuXHRcdFx0U3ViY2hhcnQ6IHRydWUsXG5cdFx0XHRUcmFuc2l0aW9uOiB0cnVlLFxuXHRcdFx0RXZlbnRSZWN0OiB0cnVlLFxuXHRcdFx0RGltZW5zaW9uOiB0cnVlLFxuXHRcdFx0VHJpbVhEb21haW46IHRydWUsXG5cdFx0XHRUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0VXBkYXRlWERvbWFpbjogZmFsc2UsXG5cdFx0XHRVcGRhdGVPcmdYRG9tYWluOiBmYWxzZSxcblx0XHRcdExlZ2VuZDogZmFsc2UsXG5cdFx0XHRVcGRhdGVYQXhpczogXCJVcGRhdGVYRG9tYWluXCIsXG5cdFx0XHRUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXG5cdFx0XHRUcmFuc2l0aW9uRm9yQXhpczogXCJUcmFuc2l0aW9uXCJcblx0XHR9O1xuXG5cdFx0T2JqZWN0LmtleXMod2l0aE9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGxldCBkZWZWYWwgPSB3aXRoT3B0aW9uc1trZXldO1xuXG5cdFx0XHRpZiAoaXNTdHJpbmcoZGVmVmFsKSkge1xuXHRcdFx0XHRkZWZWYWwgPSB3aXRoT3B0aW9uc1tkZWZWYWxdO1xuXHRcdFx0fVxuXG5cdFx0XHR3aXRoT3B0aW9uc1trZXldID0gZ2V0T3B0aW9uKG9wdGlvbnMsIGB3aXRoJHtrZXl9YCwgZGVmVmFsKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB3aXRoT3B0aW9ucztcblx0fVxuXG5cdHJlZHJhdyhvcHRpb25zID0ge30sIHRyYW5zaXRpb25zVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHRjb25zdCBpbml0aWFsaXppbmcgPSBvcHRpb25zLmluaXRpYWxpemluZztcblx0XHRjb25zdCBmbG93ID0gb3B0aW9ucy5mbG93O1xuXHRcdGNvbnN0IHd0aCA9ICQkLmdldFdpdGhPcHRpb24ob3B0aW9ucyk7XG5cdFx0Y29uc3QgZHVyYXRpb24gPSB3dGguVHJhbnNpdGlvbiA/IGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uIDogMDtcblx0XHRjb25zdCBkdXJhdGlvbkZvckV4aXQgPSB3dGguVHJhbnNpdGlvbkZvckV4aXQgPyBkdXJhdGlvbiA6IDA7XG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JBeGlzID0gd3RoLlRyYW5zaXRpb25Gb3JBeGlzID8gZHVyYXRpb24gOiAwO1xuXHRcdGNvbnN0IHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnNWYWx1ZSB8fCAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb25Gb3JBeGlzKTtcblxuXHRcdCEoaW5pdGlhbGl6aW5nICYmIGNvbmZpZy50b29sdGlwX2luaXRfc2hvdykgJiZcblx0XHRcdCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmhpZGVUb29sdGlwKCk7XG5cblx0XHQkJC51cGRhdGVTaXplcyhpbml0aWFsaXppbmcpO1xuXG5cdFx0Ly8gdXBkYXRlIGxlZ2VuZCBhbmQgdHJhbnNmb3JtIGVhY2ggZ1xuXG5cdFx0aWYgKHd0aC5MZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSB7XG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSwgb3B0aW9ucywgdHJhbnNpdGlvbnMpO1xuXHRcdH0gZWxzZSBpZiAod3RoLkRpbWVuc2lvbikge1xuXHRcdFx0Ly8gbmVlZCB0byB1cGRhdGUgZGltZW5zaW9uIChlLmcuIGF4aXMueS50aWNrLnZhbHVlcykgYmVjYXVzZSB5IHRpY2sgdmFsdWVzIHNob3VsZCBjaGFuZ2Vcblx0XHRcdC8vIG5vIG5lZWQgdG8gdXBkYXRlIGF4aXMgaW4gaXQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgdXBkYXRlZCBpbiByZWRyYXcoKVxuXHRcdFx0JCQudXBkYXRlRGltZW5zaW9uKHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBheGlzXG5cdFx0Ly8gQFRPRE86IE1ha2UgJ2luaXQnIHN0YXRlIHRvIGJlIGFjY2Vzc2libGUgZXZlcnl3aGVyZSBub3QgcGFzc2luZyBhcyBhcmd1bWVudC5cblx0XHQkJC5heGlzLnJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaW5pdGlhbGl6aW5nKTtcblxuXHRcdC8vIHVwZGF0ZSBjaXJjbGVZIGJhc2VkIG9uIHVwZGF0ZWQgcGFyYW1ldGVyc1xuXHRcdCQkLnVwZGF0ZUNpcmNsZVkoKTtcblxuXHRcdC8vIHhncmlkIGZvY3VzXG5cdFx0JCQudXBkYXRlWGdyaWRGb2N1cygpO1xuXG5cdFx0Ly8gRGF0YSBlbXB0eSBsYWJlbCBwb3NpdGlvbmluZyBhbmQgdGV4dC5cblx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLndpZHRoIC8gMilcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5oZWlnaHQgLyAyKVxuXHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyBcIm5vbmVcIiA6IG51bGwpO1xuXG5cdFx0Ly8gZ3JpZFxuXHRcdCQkLnVwZGF0ZUdyaWQoZHVyYXRpb24pO1xuXG5cdFx0Ly8gcmVjdCBmb3IgcmVnaW9uc1xuXHRcdCQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XG5cblx0XHQvLyBiYXJzXG5cdFx0JCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcblx0XHQkJC51cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk7XG5cdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xuXHRcdCQkLnVwZGF0ZUNpcmNsZSgpO1xuXG5cdFx0Ly8gdGV4dFxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcblxuXHRcdC8vIHRpdGxlXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcblxuXHRcdC8vIGFyY1xuXHRcdCQkLmFyY3MgJiYgJCQucmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHd0aC5UcmFuc2Zvcm0pO1xuXG5cdFx0Ly8gcmFkYXJcblx0XHQkJC5yYWRhcnMgJiYgJCQucmVkcmF3UmFkYXIoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3Rcblx0XHQkJC5tYWluVGV4dCAmJiBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfWApXG5cdFx0XHQuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSlcblx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGV2ZW50IHJlY3RzIHdpbGwgcmVkcmF3biB3aGVuIGZsb3cgY2FsbGVkXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICFmbG93ICYmIHd0aC5FdmVudFJlY3QpIHtcblx0XHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xuXHRcdH1cblxuXHRcdGluaXRpYWxpemluZyAmJiAkJC5zZXRDaGFydEVsZW1lbnRzKCk7XG5cblx0XHQkJC5nZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0c1RvU2hvdywgZmxvdywgZHVyYXRpb24sIHd0aC5TdWJjaGFydCk7XG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkcmVkcmF3XCIsIG9wdGlvbnMsIGR1cmF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSByZWRyYXcgbGlzdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0cyB0YXJnZXRzIGRhdGEgdG8gYmUgc2hvd25cblx0ICogQHBhcmFtIHtPYmplY3R9IGZsb3dcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzLCBmbG93LCBkdXJhdGlvbiwgd2l0aFN1YmNoYXJ0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBzaGFwZSA9ICQkLmdldERyYXdTaGFwZSgpO1xuXG5cdFx0Ly8gc3ViY2hhcnRcblx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5yZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIGR1cmF0aW9uLCBzaGFwZSk7XG5cblx0XHQvLyBnZW5lcmF0ZSBmbG93XG5cdFx0Y29uc3QgZmxvd0ZuID0gZmxvdyAmJiAkJC5nZW5lcmF0ZUZsb3coe1xuXHRcdFx0dGFyZ2V0cyxcblx0XHRcdGZsb3csXG5cdFx0XHRkdXJhdGlvbjogZmxvdy5kdXJhdGlvbixcblx0XHRcdHNoYXBlLFxuXHRcdFx0eHY6ICQkLnh2LmJpbmQoJCQpXG5cdFx0fSk7XG5cdFx0Y29uc3QgaXNUcmFuc2l0aW9uID0gKGR1cmF0aW9uIHx8IGZsb3dGbikgJiYgJCQuaXNUYWJWaXNpYmxlKCk7XG5cblx0XHQvLyByZWRyYXcgbGlzdFxuXHRcdGNvbnN0IHJlZHJhd0xpc3QgPSAkJC5nZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbik7XG5cblx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiBhZnRlciByZWRyYXcgZW5kc1xuXHRcdGNvbnN0IGFmdGVyUmVkcmF3ID0gZmxvdyB8fCBjb25maWcub25yZW5kZXJlZCA/ICgpID0+IHtcblx0XHRcdGZsb3dGbiAmJiBmbG93Rm4oKTtcblx0XHRcdGNhbGxGbihjb25maWcub25yZW5kZXJlZCwgJCQsICQkLmFwaSk7XG5cdFx0fSA6IG51bGw7XG5cblx0XHRpZiAoYWZ0ZXJSZWRyYXcpIHtcblx0XHRcdC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gd2hlbiBjdXJyZW50IHRhYiBpcyB2aXNpYmxlLlxuXHRcdFx0aWYgKGlzVHJhbnNpdGlvbikge1xuXHRcdFx0XHQvLyBXYWl0IGZvciBlbmQgb2YgdHJhbnNpdGlvbnMgZm9yIGNhbGxiYWNrXG5cdFx0XHRcdGNvbnN0IHdhaXRGb3JEcmF3ID0gJCQuZ2VuZXJhdGVXYWl0KCk7XG5cblx0XHRcdFx0Ly8gdHJhbnNpdGlvbiBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIG9uZSB0cmFuc2l0aW9uXG5cdFx0XHRcdGQzVHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0XHRcdC5lYWNoKCgpID0+IHtcblx0XHRcdFx0XHRcdHJlZHJhd0xpc3Rcblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCB0MSkgPT4gYWNjLmNvbmNhdCh0MSksIFtdKVxuXHRcdFx0XHRcdFx0XHQuZm9yRWFjaCh0ID0+IHdhaXRGb3JEcmF3LmFkZCh0KSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY2FsbCh3YWl0Rm9yRHJhdywgYWZ0ZXJSZWRyYXcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWZ0ZXJSZWRyYXcoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgZmFkZWluIGNvbmRpdGlvblxuXHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHQkJC53aXRob3V0RmFkZUluW2lkXSA9IHRydWU7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBzaGFwZSBkcmF3IGZ1bmN0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldERyYXdTaGFwZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBoYXNSYWRhciA9ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcblx0XHRjb25zdCBzaGFwZSA9IHt0eXBlOiB7fSwgaW5kaWNlczoge319O1xuXG5cdFx0Ly8gc2V0dXAgZHJhd2VyIC0gTUVNTzogdGhlc2UgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYXhpcyB1cGRhdGVkXG5cdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNUeXBlKFwic2NhdHRlclwiKSkge1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKTtcblxuXHRcdFx0c2hhcGUuaW5kaWNlcy5saW5lID0gaW5kaWNlcztcblx0XHRcdHNoYXBlLnR5cGUubGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkFyZWFcIikpIHtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0FyZWFUeXBlKTtcblxuXHRcdFx0XHRzaGFwZS5pbmRpY2VzLmFyZWEgPSBpbmRpY2VzO1xuXHRcdFx0XHRzaGFwZS50eXBlLmFyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcblx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNCYXJUeXBlKTtcblxuXHRcdFx0c2hhcGUuaW5kaWNlcy5iYXIgPSBpbmRpY2VzO1xuXHRcdFx0c2hhcGUudHlwZS5iYXIgPSAkJC5nZW5lcmF0ZURyYXdCYXIgPyAkJC5nZW5lcmF0ZURyYXdCYXIoaW5kaWNlcykgOiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0c2hhcGUucG9zID0ge1xuXHRcdFx0eEZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIHRydWUpLFxuXHRcdFx0eUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIGZhbHNlKSxcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgY2lyY2xlIHgveSBmdW5jdGlvbnMgZGVwZW5kaW5nIG9uIHVwZGF0ZWQgcGFyYW1zXG5cdFx0XHRjeDogKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVYIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKSkuYmluZCgkJCksXG5cdFx0XHRjeTogKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVZIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKSkuYmluZCgkJClcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHNoYXBlO1xuXHR9XG5cblx0Z2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGhhc0FyY1R5cGUgPSAkJC5oYXNBcmNUeXBlKCk7XG5cdFx0Y29uc3Qge2N4LCBjeSwgeEZvclRleHQsIHlGb3JUZXh0fSA9IHNoYXBlLnBvcztcblx0XHRjb25zdCBsaXN0ID0gW107XG5cblx0XHRpZiAoIWhhc0FyY1R5cGUpIHtcblx0XHRcdGNvbnN0IHthcmVhLCBiYXIsIGxpbmV9ID0gc2hhcGUudHlwZTtcblxuXHRcdFx0aWYgKGNvbmZpZy5ncmlkX3hfbGluZXMubGVuZ3RoIHx8IGNvbmZpZy5ncmlkX3lfbGluZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdHcmlkKGlzVHJhbnNpdGlvbikpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29uZmlnLnJlZ2lvbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdSZWdpb24oaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpKSB7XG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdMaW5lKGxpbmUsIGlzVHJhbnNpdGlvbikpO1xuXHRcdFx0XHQkJC5oYXNUeXBlT2YoXCJBcmVhXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdBcmVhKGFyZWEsIGlzVHJhbnNpdGlvbikpO1xuXHRcdFx0fVxuXG5cdFx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdCYXIoYmFyLCBpc1RyYW5zaXRpb24pKTtcblxuXHRcdFx0bm90RW1wdHkoY29uZmlnLmRhdGFfbGFiZWxzKSAmJlxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3VGV4dCh4Rm9yVGV4dCwgeUZvclRleHQsIGZsb3csIGlzVHJhbnNpdGlvbikpO1xuXHRcdH1cblxuXHRcdCghaGFzQXJjVHlwZSB8fCAkJC5oYXNUeXBlKFwicmFkYXJcIikpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdDaXJjbGUoY3gsIGN5LCBpc1RyYW5zaXRpb24sIGZsb3dGbikpO1xuXG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH1cblxuXHR1cGRhdGVBbmRSZWRyYXcob3B0aW9ucyA9IHt9KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRsZXQgdHJhbnNpdGlvbnM7XG5cblx0XHQvLyBzYW1lIHdpdGggcmVkcmF3XG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xuXHRcdG9wdGlvbnMud2l0aFRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2Zvcm1cIiwgZmFsc2UpO1xuXHRcdG9wdGlvbnMud2l0aExlZ2VuZCA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhMZWdlbmRcIiwgZmFsc2UpO1xuXG5cdFx0Ly8gTk9UIHNhbWUgd2l0aCByZWRyYXdcblx0XHRvcHRpb25zLndpdGhVcGRhdGVYRG9tYWluID0gdHJ1ZTtcblx0XHRvcHRpb25zLndpdGhVcGRhdGVPcmdYRG9tYWluID0gdHJ1ZTtcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yRXhpdCA9IGZhbHNlO1xuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybVwiLCBvcHRpb25zLndpdGhUcmFuc2l0aW9uKTtcblxuXHRcdC8vIE1FTU86IGNhbGxlZCBpbiB1cGRhdGVMZWdlbmQgaW4gcmVkcmF3IGlmIHdpdGhMZWdlbmRcblx0XHRpZiAoIShvcHRpb25zLndpdGhMZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSkge1xuXHRcdFx0dHJhbnNpdGlvbnMgPSAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoXG5cdFx0XHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JBeGlzID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBVcGRhdGUgc2NhbGVzXG5cdFx0XHQkJC51cGRhdGVTY2FsZXMoKTtcblx0XHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXG5cdFx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgd2l0aCBuZXcgc2l6ZXMgJiBzY2FsZXNcblx0XHQkJC5yZWRyYXcob3B0aW9ucywgdHJhbnNpdGlvbnMpO1xuXHR9XG5cblx0cmVkcmF3V2l0aG91dFJlc2NhbGUoKSB7XG5cdFx0dGhpcy5yZWRyYXcoe1xuXHRcdFx0d2l0aFk6IGZhbHNlLFxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0aXNUaW1lU2VyaWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XG5cdH1cblxuXHRpc0NhdGVnb3JpemVkKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZS5pbmRleE9mKFwiY2F0ZWdvcnlcIikgPj0gMCB8fCB0aGlzLmhhc1R5cGUoXCJyYWRhclwiKTtcblx0fVxuXG5cdGlzQ3VzdG9tWCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuICEkJC5pc1RpbWVTZXJpZXMoKSAmJiAoY29uZmlnLmRhdGFfeCB8fCBub3RFbXB0eShjb25maWcuZGF0YV94cykpO1xuXHR9XG5cblx0aXNUaW1lU2VyaWVzWSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuYXhpc195X3R5cGUgPT09IFwidGltZXNlcmllc1wiO1xuXHR9XG5cblx0Z2V0VHJhbnNsYXRlKHRhcmdldCwgaW5kZXggPSAwKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCBwYWRkaW5nID0gMDtcblx0XHRsZXQgeDtcblx0XHRsZXQgeTtcblxuXHRcdGlmIChpbmRleCAmJiAvXih4fHkyPykkLy50ZXN0KHRhcmdldCkpIHtcblx0XHRcdHBhZGRpbmcgPSAkJC5nZXRBeGlzU2l6ZSh0YXJnZXQpICogaW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKHRhcmdldCA9PT0gXCJtYWluXCIpIHtcblx0XHRcdHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4ubGVmdCk7XG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoJCQubWFyZ2luLnRvcCk7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiY29udGV4dFwiKSB7XG5cdFx0XHR4ID0gYXNIYWxmUGl4ZWwoJCQubWFyZ2luMi5sZWZ0KTtcblx0XHRcdHkgPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4yLnRvcCk7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwibGVnZW5kXCIpIHtcblx0XHRcdHggPSAkJC5tYXJnaW4zLmxlZnQ7XG5cdFx0XHR5ID0gJCQubWFyZ2luMy50b3A7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieFwiKSB7XG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gLXBhZGRpbmcgOiAwO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQgKyBwYWRkaW5nO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInlcIikge1xuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiAtcGFkZGluZztcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5MlwiKSB7XG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6ICQkLndpZHRoICsgcGFkZGluZztcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAxIC0gcGFkZGluZyA6IDA7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwic3VieFwiKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0Mjtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJhcmNcIikge1xuXHRcdFx0eCA9ICQkLmFyY1dpZHRoIC8gMjtcblx0XHRcdHkgPSAkJC5hcmNIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInJhZGFyXCIpIHtcblx0XHRcdGNvbnN0IFt3aWR0aF0gPSAkJC5nZXRSYWRhclNpemUoKTtcblxuXHRcdFx0eCA9ICQkLndpZHRoIC8gMiAtIHdpZHRoO1xuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi50b3ApO1xuXHRcdH1cblxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYDtcblx0fVxuXG5cdGluaXRpYWxPcGFjaXR5KGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcblx0XHRcdHRoaXMud2l0aG91dEZhZGVJbltkLmlkXSA/IFwiMVwiIDogXCIwXCI7XG5cdH1cblxuXHRpbml0aWFsT3BhY2l0eUZvckNpcmNsZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXG5cdFx0XHR0aGlzLndpdGhvdXRGYWRlSW5bZC5pZF0gPyB0aGlzLm9wYWNpdHlGb3JDaXJjbGUoZCkgOiBcIjBcIjtcblx0fVxuXG5cdG9wYWNpdHlGb3JDaXJjbGUoZCkge1xuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLmNvbmZpZy5wb2ludF9zaG93ID8gXCIxXCIgOiBcIjBcIjtcblxuXHRcdHJldHVybiBpc1ZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKGQpKSA/XG5cdFx0XHQodGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID9cblx0XHRcdFx0XCIwLjVcIiA6IG9wYWNpdHkpIDogXCIwXCI7XG5cdH1cblxuXHRvcGFjaXR5Rm9yVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IFwiMVwiIDogXCIwXCI7XG5cdH1cblxuXHR4eChkKSB7XG5cdFx0Y29uc3QgZm4gPSB0aGlzLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgdGhpcy56b29tU2NhbGUgP1xuXHRcdFx0dGhpcy56b29tU2NhbGUgOiB0aGlzLng7XG5cblx0XHRyZXR1cm4gZCA/IGZuKGQueCkgOiBudWxsO1xuXHR9XG5cblx0eHYoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgdmFsdWUgPSAkJC5nZXRCYXNlVmFsdWUoZCk7XG5cblx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdHZhbHVlID0gJCQucGFyc2VEYXRlKHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gJCQuY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLmNlaWwoJCQueCh2YWx1ZSkpO1xuXHR9XG5cblx0eXYoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB5U2NhbGUgPSBkLmF4aXMgJiYgZC5heGlzID09PSBcInkyXCIgPyAkJC55MiA6ICQkLnk7XG5cblx0XHRyZXR1cm4gTWF0aC5jZWlsKHlTY2FsZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcblx0fVxuXG5cdHN1Ynh4KGQpIHtcblx0XHRyZXR1cm4gZCA/IHRoaXMuc3ViWChkLngpIDogbnVsbDtcblx0fVxuXG5cdHRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCB4QXhpcztcblx0XHRsZXQgeUF4aXM7XG5cdFx0bGV0IHkyQXhpcztcblxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWCkge1xuXHRcdFx0eEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eEF4aXMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YCk7XG5cblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xuXHRcdFx0XHR4QXhpcyA9IHhBeGlzLnRyYW5zaXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kpIHtcblx0XHRcdHlBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1k7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHlBeGlzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfWApO1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0eUF4aXMgPSB5QXhpcy50cmFuc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZMikge1xuXHRcdFx0eTJBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1kyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR5MkF4aXMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfWApO1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0eTJBeGlzID0geTJBeGlzLnRyYW5zaXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQod2l0aFRyYW5zaXRpb24gPyAkJC5tYWluLnRyYW5zaXRpb24oKSA6ICQkLm1haW4pXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcblxuXHRcdHhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieFwiKSk7XG5cdFx0eUF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5XCIpKTtcblx0XHR5MkF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5MlwiKSk7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpO1xuXHR9XG5cblx0dHJhbnNmb3JtQWxsKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcblxuXHRcdCQkLmNvbmZpZy5zdWJjaGFydF9zaG93ICYmXG5cdFx0XHQkJC50cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk7XG5cblx0XHQkJC5sZWdlbmQgJiYgJCQudHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKTtcblx0fVxuXG5cdHVwZGF0ZVN2Z1NpemUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGJydXNoID0gJCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9IC5vdmVybGF5YCk7XG5cdFx0Y29uc3QgYnJ1c2hTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG5cdFx0aWYgKGJydXNoLnNpemUoKSkge1xuXHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcblx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcblx0XHR9XG5cblx0XHQkJC5zdmdcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQuY3VycmVudFdpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuY3VycmVudEhlaWdodCk7XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKFtgIyR7JCQuY2xpcElkfWAsIGAjJHskJC5jbGlwSWRGb3JHcmlkfWBdKVxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5oZWlnaHQpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgIyR7JCQuY2xpcElkRm9yWEF4aXN9YClcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WEF4aXNDbGlwWC5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5nZXRYQXhpc0NsaXBZLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFhBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XG5cblx0XHQkJC5zdmcuc2VsZWN0KGAjJHskJC5jbGlwSWRGb3JZQXhpc31gKVxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwieFwiLCAkJC5nZXRZQXhpc0NsaXBYLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFlBeGlzQ2xpcFkuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0WUF4aXNDbGlwSGVpZ2h0LmJpbmQoJCQpKTtcblxuXHRcdCQkLnN2Zy5zZWxlY3QoYCMkeyQkLmNsaXBJZEZvclN1YmNoYXJ0fWApXG5cdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGJydXNoU2l6ZS5oZWlnaHQpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5oZWlnaHQpO1xuXHR9XG5cblx0dXBkYXRlRGltZW5zaW9uKHdpdGhvdXRBeGlzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCF3aXRob3V0QXhpcykge1xuXHRcdFx0aWYgKCQkLnhBeGlzICYmICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdFx0JCQueEF4aXMuY3JlYXRlKCQkLmF4ZXMueCk7XG5cdFx0XHRcdCQkLnN1YlhBeGlzLmNyZWF0ZSgkJC5heGVzLnN1YngpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQueUF4aXMgJiYgJCQueUF4aXMuY3JlYXRlKCQkLmF4ZXMueSk7XG5cdFx0XHRcdCQkLnkyQXhpcyAmJiAkJC55MkF4aXMuY3JlYXRlKCQkLmF4ZXMueTIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBhc3MgJ3dpdGhvdXRBeGlzJyBwYXJhbSB0byBub3QgYW5pbWF0ZSBhdCB0aGUgaW5pdCByZW5kZXJpbmdcblx0XHQkJC51cGRhdGVTY2FsZXMod2l0aG91dEF4aXMpO1xuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcblx0XHQkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xuXHR9XG5cblx0YmluZFJlc2l6ZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0JCQucmVzaXplRnVuY3Rpb24gPSAkJC5nZW5lcmF0ZVJlc2l6ZSgpO1xuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiBjYWxsRm4oY29uZmlnLm9ucmVzaXplLCAkJCwgJCQuYXBpKSk7XG5cblx0XHRpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4ge1xuXHRcdFx0XHRpZiAoJCQucmVzaXplVGltZW91dCkge1xuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XG5cdFx0XHRcdFx0JCQucmVzaXplVGltZW91dCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdCQkLmFwaS5mbHVzaChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH0sIDIwMCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4gY2FsbEZuKGNvbmZpZy5vbnJlc2l6ZWQsICQkLCAkJC5hcGkpKTtcblxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAkJC5yZXNpemVGdW5jdGlvbik7XG5cdH1cblxuXHRnZW5lcmF0ZVJlc2l6ZSgpIHtcblx0XHRjb25zdCByZXNpemVGdW5jdGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNhbGxSZXNpemVGdW5jdGlvbnMoKSB7XG5cdFx0XHRyZXNpemVGdW5jdGlvbnMuZm9yRWFjaChmID0+IGYoKSk7XG5cdFx0fVxuXG5cdFx0Y2FsbFJlc2l6ZUZ1bmN0aW9ucy5hZGQgPSBmID0+IHJlc2l6ZUZ1bmN0aW9ucy5wdXNoKGYpO1xuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMucmVtb3ZlID0gZiA9PiByZXNpemVGdW5jdGlvbnMuc3BsaWNlKHJlc2l6ZUZ1bmN0aW9ucy5pbmRleE9mKGYpLCAxKTtcblxuXHRcdHJldHVybiBjYWxsUmVzaXplRnVuY3Rpb25zO1xuXHR9XG5cblx0ZW5kYWxsKHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG5cdFx0bGV0IG4gPSAwO1xuXG5cdFx0dHJhbnNpdGlvblxuXHRcdFx0LmVhY2goKCkgPT4gKytuKVxuXHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRcdFx0IS0tbiAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCAuLi5hcmdzKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0Z2VuZXJhdGVXYWl0KCkge1xuXHRcdGxldCB0cmFuc2l0aW9uc1RvV2FpdCA9IFtdO1xuXHRcdGNvbnN0IGYgPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuXHRcdFx0bGV0IHRpbWVyO1xuXG5cdFx0XHRmdW5jdGlvbiBsb29wKCkge1xuXHRcdFx0XHRsZXQgZG9uZSA9IDA7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIHQ7ICh0ID0gdHJhbnNpdGlvbnNUb1dhaXRbaV0pOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodC5lbXB0eSgpKSB7XG5cdFx0XHRcdFx0XHRkb25lKys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dC50cmFuc2l0aW9uKCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0ZG9uZSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0XHRcdFx0aWYgKGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIDUwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsb29wKCk7XG5cdFx0fTtcblxuXHRcdGYuYWRkID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xuXHRcdFx0aXNBcnJheSh0cmFuc2l0aW9uKSA/XG5cdFx0XHRcdCh0cmFuc2l0aW9uc1RvV2FpdCA9IHRyYW5zaXRpb25zVG9XYWl0LmNvbmNhdCh0cmFuc2l0aW9uKSkgOlxuXHRcdFx0XHR0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHRyYW5zaXRpb24pO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gZjtcblx0fVxuXG5cdHBhcnNlRGF0ZShkYXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBwYXJzZWREYXRlO1xuXG5cdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRwYXJzZWREYXRlID0gZGF0ZTtcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XG5cdFx0XHRwYXJzZWREYXRlID0gJCQuZGF0YVRpbWVGb3JtYXQoJCQuY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihkYXRlKSAmJiAhaXNOYU4oZGF0ZSkpIHtcblx0XHRcdHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJzZWREYXRlIHx8IGlzTmFOKCtwYXJzZWREYXRlKSkge1xuXHRcdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB4ICcke2RhdGV9JyB0byBEYXRlIG9iamVjdGApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZWREYXRlO1xuXHR9XG5cblx0aXNUYWJWaXNpYmxlKCkge1xuXHRcdHJldHVybiAhZG9jdW1lbnQuaGlkZGVuO1xuXHR9XG5cblx0Y29udmVydElucHV0VHlwZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBpc01vYmlsZSA9IGZhbHNlO1xuXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3Bcblx0XHRpZiAoL01vYmkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpICYmIGNvbmZpZy5pbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2gpIHtcblx0XHRcdC8vIFNvbWUgRWRnZSBkZXNrdG9wIHJldHVybiB0cnVlOiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8yMDQxNzA3NC9cblx0XHRcdGNvbnN0IGhhc1RvdWNoUG9pbnRzID0gd2luZG93Lm5hdmlnYXRvciAmJiBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcblxuXHRcdFx0Ly8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvdG91Y2hldmVudHMuanNcblx0XHRcdC8vIE9uIElFMTEgd2l0aCBJRTkgZW11bGF0aW9uIG1vZGUsICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIGlzIHJldHVybmluZyB0cnVlXG5cdFx0XHRjb25zdCBoYXNUb3VjaCA9IChcIm9udG91Y2htb3ZlXCIgaW4gd2luZG93IHx8ICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XG5cblx0XHRcdGlzTW9iaWxlID0gaGFzVG91Y2hQb2ludHMgfHwgaGFzVG91Y2g7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGFzTW91c2UgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xuXG5cdFx0cmV0dXJuIChoYXNNb3VzZSAmJiBcIm1vdXNlXCIpIHx8IChpc01vYmlsZSAmJiBcInRvdWNoXCIpIHx8IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbCBwbHVnaW4gaG9va1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGhhc2UgVGhlIGxpZmVjeWNsZSBwaGFzZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsbFBsdWdpbkhvb2socGhhc2UsIC4uLmFyZ3MpIHtcblx0XHR0aGlzLmNvbmZpZy5wbHVnaW5zLmZvckVhY2godiA9PiB7XG5cdFx0XHRpZiAocGhhc2UgPT09IFwiJGJlZm9yZUluaXRcIikge1xuXHRcdFx0XHR2LiQkID0gdGhpcztcblx0XHRcdFx0dGhpcy5hcGkucGx1Z2lucy5wdXNoKHYpO1xuXHRcdFx0fVxuXG5cdFx0XHR2W3BoYXNlXSguLi5hcmdzKTtcblx0XHR9KTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuXG4vKipcbiAqIE1haW4gY2hhcnQgY2xhc3MuXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCB2aWEgYGJiLmdlbmVyYXRlKClgLlxuICogQGNsYXNzIENoYXJ0XG4gKiBAZXhhbXBsZVxuICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuICogIGRhdGE6IHtcbiAqICAgIGNvbHVtbnM6IFtcbiAqXHQgICAgW1wieFwiLCBcIjIwMTUtMTEtMDJcIiwgXCIyMDE1LTEyLTAxXCIsIFwiMjAxNi0wMS0wMVwiLCBcIjIwMTYtMDItMDFcIiwgXCIyMDE2LTAzLTAxXCJdLFxuICogXHQgICAgW1wiY291bnQxXCIsIDExLCA4LCA3LCA2LCA1IF0sXG4gKlx0ICAgIFtcImNvdW50MlwiLCA5LCAzLCA2LCAyLCA4IF1cbiAqICAgXX1cbiAqIH1cbiAqIEBzZWUge0BsaW5rIGJiLmdlbmVyYXRlfSBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxuKi9cbi8qKlxuICogQWNjZXNzIGluc3RhbmNlJ3MgcHJpbWFyeSBub2RlIGVsZW1lbnRzXG4gKiBAbWVtYmVyIHtPYmplY3R9ICRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaGFydCBXcmFwcGVyIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5kZWZzIERlZmluaXRpb24gZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubWFpbiBNYWluIGdyb3VwaW5nIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5sZWdlbmQgTGVnZW5kIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRpdGxlIFRpdGxlIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5hcmMgQXJjIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLmJhclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYmFyLmJhcnMgQmFyIGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC5saW5lXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmxpbmVzIExpbmUgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuYXJlYXMgQXJlYXMgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuY2lyY2xlcyBEYXRhIHBvaW50IGNpcmNsZSBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9ICQudGV4dFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGV4dC50ZXh0cyBEYXRhIGxhYmVsIHRleHQgZWxlbWVudHNcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuICpcbiAqIGNoYXJ0LiQuY2hhcnQ7IC8vIHdyYXBwZXIgZWxlbWVudFxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xuXHRjb25zdHJ1Y3Rvcihjb25maWcpIHtcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogUGx1Z2luIGluc3RhbmNlIGFycmF5XG5cdFx0ICogQG1lbWJlciB7QXJyYXl9IHBsdWdpbnNcblx0XHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0XHQgKiBAaW5zdGFuY2VcbiBcdCBcdCAqIEBleGFtcGxlXG5cdFx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcblx0XHQgKiAgICAgLi4uXG5cdFx0ICogICAgIHBsdWdpbnM6IFtcblx0XHQgKiAgICAgICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcblx0XHQgKiAgICAgICAgbmV3IFBsdWdpbkEoKVxuXHRcdCAqICAgICBdXG5cdFx0ICogIH0pO1xuXHRcdCAqXG5cdFx0ICogIGNoYXJ0LnBsdWdpbnM7IC8vIFtTdGFuZm9yZCwgUGx1Z2luQV0gLSBpbnN0YW5jZSBhcnJheVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2lucyA9IFtdO1xuXHRcdHRoaXMuaW50ZXJuYWwgPSAkJDtcblxuXHRcdCQkLmxvYWRDb25maWcoY29uZmlnKTtcblx0XHQkJC5iZWZvcmVJbml0KGNvbmZpZyk7XG5cdFx0JCQuaW5pdCgpO1xuXHRcdCQkLmFmdGVySW5pdChjb25maWcpO1xuXG5cdFx0Ly8gYmluZCBcInRoaXNcIiB0byBuZXN0ZWQgQVBJXG5cdFx0KGZ1bmN0aW9uIGJpbmRUaGlzKGZuLCB0YXJnZXQsIGFyZ1RoaXMpIHtcblx0XHRcdE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gZm5ba2V5XS5iaW5kKGFyZ1RoaXMpO1xuXG5cdFx0XHRcdE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCAmJlxuXHRcdFx0XHRcdGJpbmRUaGlzKGZuW2tleV0sIHRhcmdldFtrZXldLCBhcmdUaGlzKTtcblx0XHRcdH0pO1xuXHRcdH0pKENoYXJ0LnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogQ2xhc3MgdG8gc2V0IG9wdGlvbnMgb24gZ2VuZXJhdGluZyBjaGFydC5cbiAqIC0gSXQncyBpbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cbiAqIEBjbGFzcyBPcHRpb25zXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gdG8gdXNlIHRoZXNlIG9wdGlvbnMgb24gZ2VuZXJhdGluZyB0aGUgY2hhcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9ucyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cblx0XHRcdCAqIElmIG90aGVyIGNoYXJ0IGlzIHNldCBhbHJlYWR5LCBpdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG5ldyBvbmUgKG9ubHkgb25lIGNoYXJ0IGNhbiBiZSBzZXQgaW4gb25lIGVsZW1lbnQpLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogSW4gY2FzZSBvZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgb3Igbm90IHNwZWNpZmllZCwgd2lsbCBhZGQgYSBgPGRpdj5gIGVsZW1lbnQgdG8gdGhlIGJvZHkuXG5cdFx0XHQgKiBAbmFtZSBiaW5kdG9cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0bz0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG8uZWxlbWVudD0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtiaW5kdG8uY2xhc3NuYW1lPWJiXSBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIG9mIGJpbmQgZWxlbWVudC48YnI+XG5cdFx0XHQgKiAgICAgKipOT1RFOioqIFdoZW4gY2xhc3MgbmFtZSBpc24ndCBgYmJgLCB0aGVuIHlvdSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBkZWZhdWx0IENTUyB0byBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXG5cdFx0XHQgKiBAZGVmYXVsdCAjY2hhcnRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBiaW5kdG86IFwiI215Q29udGFpbmVyXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBvciBIVE1MRWxlbWVudFxuXHRcdFx0ICogYmluZHRvOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q29udGFpbmVyXCIpXG5cdFx0XHQgKlxuXHRcdFx0ICogLy8gb3IgRDMgc2VsZWN0aW9uIG9iamVjdFxuXHRcdFx0ICogYmluZHRvOiBkMy5zZWxlY3QoXCIjbXlDb250YWluZXJcIilcblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBvciB0byBjaGFuZ2UgZGVmYXVsdCBjbGFzc25hbWVcblx0XHRcdCAqIGJpbmR0bzoge1xuXHRcdFx0ICogICAgZWxlbWVudDogXCIjY2hhcnRcIixcblx0XHRcdCAqICAgIGNsYXNzbmFtZTogXCJiaWxsLWJvYXJkXCIgIC8vIGV4KSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2JpbGwtYm9hcmQnPlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRiaW5kdG86IFwiI2NoYXJ0XCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSBmb3IgY2hhcnQgZWxlbWVudFxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICA+IFdoZW4gaXMgZmFsc2UsIGNoYXJ0IG5vZGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFmdGVyIHRoZSBheGlzIG5vZGUgaW4gRE9NIHRyZWUgaGllcmFyY2h5LlxuXHRcdFx0ICogID4gSXMgdG8gbWFrZSBjaGFydCBlbGVtZW50IHBvc2l0aW9uZWQgb3ZlciBheGlzIGVsZW1lbnQuXG5cdFx0XHQgKiBAbmFtZSBjbGlwUGF0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5jbGlwUGF0aClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXG5cdFx0XHQgKiBjbGlwUGF0aDogZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0Y2xpcFBhdGg6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHN2ZyBlbGVtZW50J3MgY2xhc3MgbmFtZVxuXHRcdFx0ICogQG5hbWUgc3ZnXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3ZnLmNsYXNzbmFtZV0gY2xhc3MgbmFtZSBmb3Igc3ZnIGVsZW1lbnRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBzdmc6IHtcbiAgICAgICAgICAgICAqICAgY2xhc3NuYW1lOiBcInRlc3RfY2xhc3NcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRzdmdfY2xhc3NuYW1lOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgY2hhcnQgZWxlbWVudC5cblx0XHRcdCAqIElmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpdCdzIGFwcGVuZGVkIHRvLlxuXHRcdFx0ICogQG5hbWUgc2l6ZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUud2lkdGhdIHdpZHRoIG9mIHRoZSBjaGFydCBlbGVtZW50XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQ2hhcnRTaXplKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNpemU6IHtcbiAgICAgICAgICAgICAqICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgICAqICAgaGVpZ2h0OiA0ODBcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0c2l6ZV93aWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0c2l6ZV9oZWlnaHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgcGFkZGluZyBvZiB0aGUgY2hhcnQgZWxlbWVudC5cblx0XHRcdCAqIEBuYW1lIHBhZGRpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcucmlnaHRdIHBhZGRpbmcgb24gdGhlIHJpZ2h0IG9mIGNoYXJ0XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcuYm90dG9tXSBwYWRkaW5nIG9uIHRoZSBib3R0b20gb2YgY2hhcnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogcGFkZGluZzoge1xuICAgICAgICAgICAgICogICB0b3A6IDIwLFxuICAgICAgICAgICAgICogICByaWdodDogMjAsXG4gICAgICAgICAgICAgKiAgIGJvdHRvbTogMjAsXG4gICAgICAgICAgICAgKiAgIGxlZnQ6IDIwXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdHBhZGRpbmdfbGVmdDogdW5kZWZpbmVkLFxuXHRcdFx0cGFkZGluZ19yaWdodDogdW5kZWZpbmVkLFxuXHRcdFx0cGFkZGluZ190b3A6IHVuZGVmaW5lZCxcblx0XHRcdHBhZGRpbmdfYm90dG9tOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHJlc2l6ZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSByZXNpemVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVzaXplLmF1dG89dHJ1ZV0gU2V0IGNoYXJ0IHJlc2l6ZSBhdXRvbWF0aWNhbGx5IG9uIHZpZXdwb3J0IGNoYW5nZXMuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHJlc2l6ZToge1xuXHRcdFx0ICogICAgICBhdXRvOiBmYWxzZVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cmVzaXplX2F1dG86IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHpvb20gb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgem9vbVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt6b29tLmVuYWJsZWQ9ZmFsc2VdIEVuYWJsZSB6b29taW5nLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt6b29tLmVuYWJsZWQudHlwZT0nd2hlZWwnXSBTZXQgem9vbSBpbnRlcmFjdGlvbiB0eXBlLlxuXHRcdFx0ICogIC0gKipBdmFpbGFibGUgdHlwZXM6Kipcblx0XHRcdCAqICAgIC0gd2hlZWxcblx0XHRcdCAqICAgIC0gZHJhZ1xuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cblx0XHRcdCAqICBJZiB0cnVlIHNldCwgeSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgem9vbWVkIHJlZ2lvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt6b29tLmV4dGVudD1bMSwgMTBdXSBDaGFuZ2Ugem9vbSBleHRlbnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfERhdGV9IFt6b29tLngubWF4XSBTZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZVxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tc3RhcnQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIHN0YXJ0cy48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHpvb21pbmcuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3pvb20ucmVzZXRCdXR0b249dHJ1ZV0gU2V0IHRvIGRpc3BsYXkgem9vbSByZXNldCBidXR0b24gZm9yICdkcmFnJyB0eXBlIHpvb21cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbem9vbS5yZXNldEJ1dHRvbi50ZXh0PSdSZXNldCBab29tJ10gVGV4dCB2YWx1ZSBmb3Igem9vbSByZXNldCBidXR0b24uXG5cdFx0XHQgKiBAc2VlIFtEZW1vOnpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5ab29tKVxuXHRcdFx0ICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgem9vbToge1xuXHRcdFx0ICogICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICAgKiAgICAgICAgICB0eXBlOiBcImRyYWdcIlxuICAgICAgICAgICAgICogICAgICB9LFxuXHRcdFx0ICogICAgICByZXNjYWxlOiB0cnVlLFxuXHRcdFx0ICogICAgICBleHRlbnQ6IFsxLCAxMDBdICAvLyBlbmFibGUgbW9yZSB6b29taW5nXG5cdFx0XHQgKiAgICAgIHg6IHtcblx0XHRcdCAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXG5cdFx0XHQgKiAgICAgICAgICBtYXg6IDEwICAvLyBzZXQgbWF4IHJhbmdlXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgb256b29tOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgIG9uem9vbWVuZDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2hvdyByZXNldCBidXR0b24gd2hlbiBpcyB6b29tZWQtaW5cblx0XHRcdCAqICAgICAgcmVzZXRCdXR0b246IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBjdXN0b21pemVkIHRleHQgdmFsdWUgZm9yIHJlc2V0IHpvb20gYnV0dG9uXG5cdFx0XHQgKiAgICAgIHJlc2V0QnV0dG9uOiB7XG5cdFx0XHQgKiAgICAgICAgICB0ZXh0OiBcIlVuem9vbVwiXG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHpvb21fZW5hYmxlZDogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV9leHRlbnQ6IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fcHJpdmlsZWdlZDogZmFsc2UsXG5cdFx0XHR6b29tX3Jlc2NhbGU6IGZhbHNlLFxuXHRcdFx0em9vbV9vbnpvb206IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fb256b29tc3RhcnQ6IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fb256b29tZW5kOiB1bmRlZmluZWQsXG5cdFx0XHR6b29tX3Jlc2V0QnV0dG9uOiB0cnVlLFxuXHRcdFx0em9vbV94X21pbjogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV94X21heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEludGVyYWN0aW9uIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmVuYWJsZWQ9dHJ1ZV0gSW5kaWNhdGUgaWYgdGhlIGNoYXJ0IHNob3VsZCBoYXZlIGludGVyYWN0aW9ucy48YnI+XG5cdFx0XHQgKiAgICAgSWYgYGZhbHNlYCBpcyBzZXQsIGFsbCBvZiBpbnRlcmFjdGlvbnMgKHNob3dpbmcvaGlkaW5nIHRvb2x0aXAsIHNlbGVjdGlvbiwgbW91c2UgZXZlbnRzLCBldGMpIHdpbGwgYmUgZGlzYWJsZWQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5icmlnaHRlbj10cnVlXSBNYWtlIGJyaWdodGVyIGZvciB0aGUgc2VsZWN0ZWQgYXJlYSAoZXguICdwaWUnIHR5cGUgZGF0YSBzZWxlY3RlZCBhcmVhKVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2g9dHJ1ZV0gZW5hYmxlIG9yIGRpc2FibGUgIHRvdWNoIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58TnVtYmVyfSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0PWZhbHNlXSBlbmFibGUgb3IgZGlzYWJsZSB0byBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0IG9uIHRvdWNoc3RhcnQgJiB0b3VjaG1vdmUgZXZlbnQuIEl0J3MgdXN1YWxseSB1c2VkIHRvIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nLlxuXHRcdFx0ICogQHNlZSBbRGVtbzogdG91Y2gucHJldmVudERlZmF1bHRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5QcmV2ZW50U2Nyb2xsT25Ub3VjaClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgICogICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICBicmlnaHRlbjogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICBpbnB1dFR5cGU6IHtcbiAgICAgICAgICAgICAqICAgICAgICBtb3VzZTogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICB0b3VjaDogZmFsc2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gb3IgZGVjbGFyZSBwcmV2ZW50RGVmYXVsdCBleHBsaWNpdGx5LlxuICAgICAgICAgICAgICogICAgICAgIC8vIEluIHRoaXMgY2FzZSB0b3VjaCBpbnB1dFR5cGUgaXMgZW5hYmxlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgKiAgICAgICAgdG91Y2g6IHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIC8vIG9yIHRocmVzaG9sZCBwaXhlbCB2YWx1ZSAocGl4ZWwgbW92ZWQgZnJvbSB0b3VjaHN0YXJ0IHRvIHRvdWNobW92ZSlcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IDVcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGludGVyYWN0aW9uX2VuYWJsZWQ6IHRydWUsXG5cdFx0XHRpbnRlcmFjdGlvbl9icmlnaHRlbjogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZTogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIG1vdXNlL3RvdWNoIGVudGVycyB0aGUgY2hhcnQuXG5cdFx0XHQgKiBAbmFtZSBvbm92ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcblx0XHRcdCAqIG9ub3ZlcjogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbm92ZXI6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIG9ub3V0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXG5cdFx0XHQgKiBvbm91dDogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbm91dDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB1c2VyIHJlc2l6ZXMgdGhlIHNjcmVlbi5cblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXG5cdFx0XHQgKiBvbnJlc2l6ZTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbnJlc2l6ZTogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyZWVuIHJlc2l6ZSBmaW5pc2hlZC5cblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuXHRcdFx0ICogb25yZXNpemVkOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdCAqICAgLi4uXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdG9ucmVzaXplZDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxuXHRcdFx0ICogQG5hbWUgb25iZWZvcmVpbml0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXG5cdFx0XHQgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25iZWZvcmVpbml0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cblx0XHRcdCAqIEBuYW1lIG9uaW5pdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuXHRcdFx0ICogb25pbml0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdCAqICAgLi4uXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdG9uaW5pdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXG5cdFx0XHQgKiBAbmFtZSBvbmFmdGVyaW5pdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxuXHRcdFx0ICogb25hZnRlcmluaXQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25hZnRlcmluaXQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBjaGFydCBpcyByZW5kZXJlZC4gQmFzaWNhbGx5LCB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGluIGVhY2ggdGltZSB3aGVuIHRoZSBjaGFydCBpcyByZWRyYXdlZC5cblx0XHRcdCAqIEBuYW1lIG9ucmVuZGVyZWRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcblx0XHRcdCAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25yZW5kZXJlZDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cblx0XHRcdCAqIC0gKipOT1RFOioqIElmIGAwIGBvciBgbnVsbGAgc2V0LCB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZC4gU28sIHRoaXMgbWFrZXMgaW5pdGlhbCByZW5kZXJpbmcgZmFzdGVyIGVzcGVjaWFsbHkgaW4gY2FzZSB5b3UgaGF2ZSBhIGxvdCBvZiBkYXRhLlxuXHRcdFx0ICogQG5hbWUgdHJhbnNpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RyYW5zaXRpb24uZHVyYXRpb249MzUwXSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB0cmFuc2l0aW9uOiB7XG5cdFx0XHQgKiAgICBkdXJhdGlvbjogNTAwXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdHRyYW5zaXRpb25fZHVyYXRpb246IDM1MCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZ5IHRoZSBrZXkgb2YgeCB2YWx1ZXMgaW4gdGhlIGRhdGEuPGJyPjxicj5cblx0XHRcdCAqIFdlIGNhbiBzaG93IHRoZSBkYXRhIHdpdGggbm9uLWluZGV4IHggdmFsdWVzIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHRoZSB0eXBlIG9mIHggYXhpcyBpcyB0aW1lc2VyaWVzLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgb24gY2F0ZWdvcnkgYXhpcywgdGhlIHZhbHVlcyBvZiB0aGUgZGF0YSBvbiB0aGUga2V5IHdpbGwgYmUgdXNlZCBmb3IgY2F0ZWdvcnkgbmFtZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHg6IFwiZGF0ZVwiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZnkgdGhlIGtleXMgb2YgdGhlIHggdmFsdWVzIGZvciBlYWNoIGRhdGEuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeHNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHhzOiB7XG4gICAgICAgICAgICAgKiAgICAgIGRhdGExOiBcIngxXCIsXG4gICAgICAgICAgICAgKiAgICAgIGRhdGEyOiBcIngyXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3hzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBmb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIHN0cmluZyBzcGVjaWZlZCBhcyB4LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHhGb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgJVktJW0tJWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICB4OiBcInhcIixcblx0XHRcdCAqICAgIGNvbHVtbnM6IFtcblx0XHRcdCAqICAgICAgICBbXCJ4XCIsIFwiMDEwMTIwMTlcIiwgXCIwMjAxMjAxOVwiLCBcIjAzMDEyMDE5XCJdLFxuXHRcdFx0ICogICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1cblx0XHRcdCAqICAgIF0sXG5cdFx0XHQgKiAgICAvLyBGb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIGFzIGRhdGV0aW1lIGZvciBnaXZlbiAneCcgc3RyaW5nIHZhbHVlXG5cdFx0XHQgKiAgICB4Rm9ybWF0OiBcIiVtJWQlWVwiXG5cdFx0XHQgKiB9LFxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICAgeDoge1xuXHRcdFx0ICogICAgICAgIHR5cGU6IFwidGltZXNlcmllc1wiXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV94Rm9ybWF0OiBcIiVZLSVtLSVkXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxvY2FsdGltZSBmb3JtYXQgdG8gcGFyc2UgeCBheGlzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHhMb2NhbHRpbWVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgIHhMb2NhbHRpbWU6IGZhbHNlXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeExvY2FsdGltZTogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTb3J0IG9uIHggYXhpcy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKR4U29ydFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgeFNvcnQ6IGZhbHNlXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeFNvcnQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ29udmVydHMgZGF0YSBpZCB2YWx1ZVxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgKiAgICAgICAvLyB3aGVuIGlkIGlzICdkYXRhMScsIGNvbnZlcnRzIHRvIGJlICdkYXRhMidcbiAgICAgICAgICAgICAqICAgICAgIC8vICdkYXRhMicgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBpbml0aWFsIGRhdGEgdmFsdWVcbiAgICAgICAgICAgICAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gXCJkYXRhMlwiO1xuICAgICAgICAgICAgICogICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAqICAgICAgIH1cbiAgICAgICAgICAgICAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9pZENvbnZlcnRlcjogaWQgPT4gaWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGN1c3RvbSBkYXRhIG5hbWUuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbmFtZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFOYW1lKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgbmFtZXM6IHtcbiAgICAgICAgICAgICAqICAgICBkYXRhMTogXCJEYXRhIE5hbWUgMVwiLFxuICAgICAgICAgICAgICogICAgIGRhdGEyOiBcIkRhdGEgTmFtZSAyXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX25hbWVzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY3VzdG9tIGRhdGEgY2xhc3MuPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY2xhc3Nlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICogICAgIGRhdGExOiBcImFkZGl0aW9uYWwtZGF0YTEtY2xhc3NcIixcbiAgICAgICAgICAgICAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcbiAgICAgICAgICAgICAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2NsYXNzZXM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBncm91cHMgZm9yIHRoZSBkYXRhIGZvciBzdGFja2luZy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRncm91cHNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgZ3JvdXBzOiBbXG4gICAgICAgICAgICAgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcbiAgICAgICAgICAgICAqICAgICBbXCJkYXRhM1wiXVxuICAgICAgICAgICAgICogICBdXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfZ3JvdXBzOiBbXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgeSBheGlzIHRoZSBkYXRhIHJlbGF0ZWQgdG8uIHkgYW5kIHkyIGNhbiBiZSB1c2VkLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGF4ZXM6IHtcblx0XHRcdCAqICAgICBkYXRhMTogXCJ5XCIsXG5cdFx0XHQgKiAgICAgZGF0YTI6IFwieTJcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfYXhlczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHR5cGUgYXQgb25jZS48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgdHlwZSB3aWxsIGJlIGFwcGxpZWQgdG8gZXZlcnkgZGF0YS4gVGhpcyBzZXR0aW5nIGNhbiBiZSBvdmVyd3JpdHRlbiBieSBkYXRhLnR5cGVzLjxicj48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqIC0gYXJlYVxuXHRcdFx0ICogLSBhcmVhLWxpbmUtcmFuZ2Vcblx0XHRcdCAqIC0gYXJlYS1zcGxpbmVcblx0XHRcdCAqIC0gYXJlYS1zcGxpbmUtcmFuZ2Vcblx0XHRcdCAqIC0gYXJlYS1zdGVwXG5cdFx0XHQgKiAtIGJhclxuXHRcdFx0ICogLSBidWJibGVcblx0XHRcdCAqIC0gZG9udXRcblx0XHRcdCAqIC0gZ2F1Z2Vcblx0XHRcdCAqIC0gbGluZVxuXHRcdFx0ICogLSBwaWVcblx0XHRcdCAqIC0gcmFkYXJcblx0XHRcdCAqIC0gc2NhdHRlclxuXHRcdFx0ICogLSBzcGxpbmVcblx0XHRcdCAqIC0gc3RlcFxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgbGluZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHR5cGU6IFwiYmFyXCJcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV90eXBlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNoYXJ0IHR5cGUgZm9yIGVhY2ggZGF0YS48YnI+XG5cdFx0XHQgKiBUaGlzIHNldHRpbmcgb3ZlcndyaXRlcyBkYXRhLnR5cGUgc2V0dGluZy5cblx0XHRcdCAqIC0gKipOT1RFOioqIGByYWRhcmAgdHlwZSBjYW4ndCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHR5cGVzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHR5cGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICB0eXBlczoge1xuXHRcdFx0ICogICAgIGRhdGExOiBcImJhclwiLFxuXHRcdFx0ICogICAgIGRhdGEyOiBcInNwbGluZVwiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV90eXBlczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxhYmVscyBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbGFiZWxzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzLmNlbnRlcmVkPWZhbHNlXSBDZW50ZXJpemUgbGFiZWxzIG9uIGBiYXJgIHNoYXBlLiAoKipOT1RFOioqIHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGF0YS5sYWJlbHMuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZ1bmN0aW9uIGZvciBkYXRhIGxhYmVscy48YnI+XG5cdFx0XHQgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cblx0XHRcdCAqICAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxuXHRcdFx0ICogIC0gYGlkYCBpcyB0aGUgaWQgb2YgdGhlIGRhdGEgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxuXHRcdFx0ICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG5cdFx0XHQgKiAgLSBgamAgaXMgdGhlIHN1YiBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uPGJyPjxicj5cblx0XHRcdCAqIEZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgZGVmaW5lZCBmb3IgZWFjaCBkYXRhIGJ5IHNwZWNpZnlpbmcgYXMgYW4gb2JqZWN0IGFuZCBEMyBmb3JtYXR0ZXIgZnVuY3Rpb24gY2FuIGJlIHNldCAoZXguIGQzLmZvcm1hdCgnJCcpKVxuIFx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdH0gW2RhdGEubGFiZWxzLmNvbG9yc10gU2V0IGxhYmVsIHRleHQgY29sb3JzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW2RhdGEubGFiZWxzLm92ZXJsYXA9dHJ1ZV0gUHJldmVudHMgbGFiZWwgb3ZlcmxhcCB1c2luZyBbVm9yb25vaSBsYXlvdXRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Zvcm9ub2lfZGlhZ3JhbSkgaWYgc2V0IHRvIGBmYWxzZWAuXG4gICAgXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGF0YS5sYWJlbHMub3ZlcmxhcC5leHRlbnQ9MV0gU2V0IGV4dGVudCBvZiBsYWJlbCBvdmVybGFwIHByZXZlbnRpb24uXG4gICAgIFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLm92ZXJsYXAuYXJlYT0wXSBTZXQgbWluaW11bSBhcmVhIG5lZWRlZCB0byBzaG93IGEgZGF0YSBsYWJlbC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueD0wXSB4IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TlVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGxhYmVsIGNvbG9yc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsQ29sb3JzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogbGFiZWwgZm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxGb3JtYXQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBvdmVybGFwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxPdmVybGFwKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogbGFiZWwgcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbFBvc2l0aW9uKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgbGFiZWxzOiB0cnVlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8gb3Igc2V0IHNwZWNpZmljIG9wdGlvbnNcblx0XHRcdCAqICAgbGFiZWxzOiB7XG5cdFx0XHQgKiAgICAgZm9ybWF0OiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBzZXQgZm9yIGVhY2ggZGF0YVxuXHRcdFx0ICogICAgIGZvcm1hdDoge1xuXHRcdFx0ICogICAgICAgICBkYXRhMTogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIGFsaWduIHRleHQgdG8gY2VudGVyIG9mIHRoZSAnYmFyJyBzaGFwZSAod29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcblx0XHRcdCAqICAgICBjZW50ZXJlZDogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gYXBwbHkgZm9yIGFsbCBsYWJlbCB0ZXh0c1xuXHRcdFx0ICogICAgIGNvbG9yczogXCJyZWRcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gb3Igc2V0IGRpZmZlcmVudCBjb2xvcnMgcGVyIGRhdGFzZXRcblx0XHRcdCAqICAgICAvLyBmb3Igbm90IHNwZWNpZmllZCBkYXRhc2V0LCB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgY29sb3IgdmFsdWVcblx0XHRcdCAqICAgICBjb2xvcnM6IHtcblx0XHRcdCAqICAgICAgICBkYXRhMTogXCJ5ZWxsb3dcIixcblx0XHRcdCAqICAgICAgICBkYXRhMzogXCJncmVlblwiXG5cdFx0XHQgKiAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxuXHRcdFx0ICogICAgIHBvc2l0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgeDogLTEwLFxuXHRcdFx0ICogICAgICAgIHk6IDEwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfbGFiZWxzOiB7fSxcblx0XHRcdGRhdGFfbGFiZWxzX2NvbG9yczogdW5kZWZpbmVkLFxuXHRcdFx0ZGF0YV9sYWJlbHNfcG9zaXRpb246IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqICBUaGlzIG9wdGlvbiBjaGFuZ2VzIHRoZSBvcmRlciBvZiBzdGFja2luZyBkYXRhIGFuZCBwaWVjZXMgb2YgcGllL2RvbnV0LlxuXHRcdFx0ICogIC0gSWYgYG51bGxgIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB0aGUgb3JkZXIgdGhlIGRhdGEgbG9hZGVkLlxuXHRcdFx0ICogIC0gSWYgZnVuY3Rpb24gc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpPGJyPjxicj5cblx0XHRcdCAqXG5cdFx0XHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXG5cdFx0XHQgKiAgLSBgZGVzY2A6IEluIGRlc2NlbmRpbmcgb3JkZXJcblx0XHRcdCAqICAtIGBhc2NgOiBJbiBhc2NlbmRpbmcgb3JkZXJcblx0XHRcdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgbG9hZCBvcmRlclxuXHRcdFx0ICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IEFycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb3JkZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG5cdFx0XHQgKiBAZGVmYXVsdCBkZXNjXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhT3JkZXIpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAvLyBpbiBkZXNjZW5kaW5nIG9yZGVyIChkZWZhdWx0KVxuXHRcdFx0ICogICBvcmRlcjogXCJkZXNjXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIGluIGFzY2VuZGluZyBvcmRlclxuXHRcdFx0ICogICBvcmRlcjogXCJhc2NcIlxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8ga2VlcHMgZGF0YSBpbnB1dCBvcmRlclxuXHRcdFx0ICogICBvcmRlcjogbnVsbFxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXG5cdFx0XHQgKiAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHQgKiAgICAgICAvLyBwYXJhbSBkYXRhIHBhc3NlZCBmb3JtYXRcblx0XHRcdCAqICAgICAgIHtcblx0XHRcdCAqICAgICAgICAgIGlkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcblx0XHRcdCAqICAgICAgICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn0sXG5cdFx0XHQgKiAgICAgICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICBdXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vcmRlcjogXCJkZXNjXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRGVmaW5lIHJlZ2lvbnMgZm9yIGVhY2ggZGF0YS48YnI+XG5cdFx0XHQgKiBUaGUgdmFsdWVzIG11c3QgYmUgYW4gYXJyYXkgZm9yIGVhY2ggZGF0YSBhbmQgaXQgc2hvdWxkIGluY2x1ZGUgYW4gb2JqZWN0IHRoYXQgaGFzIGBzdGFydGAsIGBlbmRgIGFuZCBgc3R5bGVgLlxuXHRcdFx0ICogLSBUaGUgb2JqZWN0IHR5cGUgc2hvdWxkIGJlIGFzOlxuXHRcdFx0ICogICAtIHN0YXJ0IHtOdW1iZXJ9OiBTdGFydCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIHN0YXJ0IHdpbGwgYmUgdGhlIGZpcnN0IGRhdGEgcG9pbnQuXG5cdFx0XHQgKiAgIC0gW2VuZF0ge051bWJlcn06IEVuZCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIGVuZCB3aWxsIGJlIHRoZSBsYXN0IGRhdGEgcG9pbnQuXG5cdFx0XHQgKiAgIC0gW3N0eWxlLmRhc2hhcnJheT1cIjIgMlwiXSB7T2JqZWN0fTogVGhlIGZpcnN0IG51bWJlciBzcGVjaWZpZXMgYSBkaXN0YW5jZSBmb3IgdGhlIGZpbGxlZCBhcmVhLCBhbmQgdGhlIHNlY29uZCBhIGRpc3RhbmNlIGZvciB0aGUgdW5maWxsZWQgYXJlYS5cblx0XHRcdCAqIC0gKipOT1RFOioqIEN1cnJlbnRseSB0aGlzIG9wdGlvbiBzdXBwb3J0cyBvbmx5IGxpbmUgY2hhcnQgYW5kIGRhc2hlZCBzdHlsZS4gSWYgdGhpcyBvcHRpb24gc3BlY2lmaWVkLCB0aGUgbGluZSB3aWxsIGJlIGRhc2hlZCBvbmx5IGluIHRoZSByZWdpb25zLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHJlZ2lvbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHJlZ2lvbnM6IHtcblx0XHRcdCAqICAgICBkYXRhMTogW3tcblx0XHRcdCAqICAgICAgICAgc3RhcnQ6IDEsXG5cdFx0XHQgKiAgICAgICAgIGVuZDogMixcblx0XHRcdCAqICAgICAgICAgc3R5bGU6IHtcblx0XHRcdCAqICAgICAgICAgICAgIGRhc2hhcnJheTogXCI1IDJcIlxuXHRcdFx0ICogICAgICAgICB9XG5cdFx0XHQgKiAgICAgfSwge1xuXHRcdFx0ICogICAgICAgICBzdGFydDogM1xuXHRcdFx0ICogICAgIH1dLFxuXHRcdFx0ICogICAgIC4uLlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfcmVnaW9uczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNvbG9yIGNvbnZlcnRlciBmdW5jdGlvbi48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gc2hvdWxkIGEgZnVuY3Rpb24gYW5kIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgY29sb3IgKGUuZy4gJyNmZjAwMDAnKSBhbmQgZCB0aGF0IGhhcyBkYXRhIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LCBldGMuIEFuZCBpdCBtdXN0IHJldHVybiBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgY29sb3IgKGUuZy4gJyMwMGZmMDAnKS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRjb2xvclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUNvbG9yKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sb3I6IGZ1bmN0aW9uKGNvbG9yLCBkKSB7IC4uLiB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfY29sb3I6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY29sb3IgZm9yIGVhY2ggZGF0YS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRjb2xvcnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGNvbG9yczoge1xuXHRcdFx0ICogICAgIGRhdGExOiBcIiNmZjAwMDBcIixcblx0XHRcdCAqICAgICBkYXRhMjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgIHJldHVybiBcIiMwMDBcIjtcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgICAgLi4uXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9jb2xvcnM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpZGUgZWFjaCBkYXRhIHdoZW4gdGhlIGNoYXJ0IGFwcGVhcnMuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkaGlkZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXG5cdFx0XHQgKiAgIGhpZGU6IHRydWVcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXG5cdFx0XHQgKiAgIGhpZGU6IFtcImRhdGExXCIsIC4uLl1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9oaWRlOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWx0ZXIgdmFsdWVzIHRvIGJlIHNob3duXG5cdFx0XHQgKiBUaGUgZGF0YSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuZWQgYnkgYC5kYXRhKClgLlxuXHRcdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcblx0XHRcdCAqIEBuYW1lIGRhdGHigKRmaWx0ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIC8vIGZpbHRlciBmb3IgaWQgdmFsdWVcblx0XHRcdCAqICAgZmlsdGVyOiBmdW5jdGlvbih2KSB7XG5cdFx0XHQgKiAgICAgIC8vIHY6IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xuXHRcdFx0ICogICAgICAvLyAgICAgIHt4OiAwLCB2YWx1ZTogMTMwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogMH0sIC4uLl1cblx0XHRcdCAqICAgICAgLy8gICAgfSwgLi4uXVxuXHRcdFx0ICogICAgICByZXR1cm4gdi5pZCAhPT0gXCJkYXRhMVwiO1xuXHRcdFx0ICogICB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfZmlsdGVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSBzdGFja2luZyB0byBiZSBub3JtYWxpemVkXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogICAtIEZvciBzdGFja2luZywgJ1tkYXRhLmdyb3Vwc10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0Z3JvdXBzKScgb3B0aW9uIHNob3VsZCBiZSBzZXRcblx0XHRcdCAqICAgLSB5IEF4aXMgd2lsbCBiZSBzZXQgaW4gcGVyY2VudGFnZSB2YWx1ZSAoMCB+IDEwMCUpXG5cdFx0XHQgKiAgIC0gTXVzdCBoYXZlIHBvc3RpdmUgdmFsdWVzXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc3RhY2vigKRub3JtYWxpemVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU3RhY2tOb3JtYWxpemVkKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHQgICAgICogICBzdGFjazoge1xuXHRcdCAgICAgKiAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxuXHRcdCAgICAgKiAgIH1cblx0XHQgICAgICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3N0YWNrX25vcm1hbGl6ZTogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkYXRhIHNlbGVjdGlvbiBlbmFibGVkPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0cnVlLCB3ZSBjYW4gc2VsZWN0IHRoZSBkYXRhIHBvaW50cyBhbmQgZ2V0L3NldCBpdHMgc3RhdGUgb2Ygc2VsZWN0aW9uIGJ5IEFQSSAoZS5nLiBzZWxlY3QsIHVuc2VsZWN0LCBzZWxlY3RlZCkuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZW5hYmxlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTZWxlY3Rpb24pXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBlbmFibGVkOiB0cnVlXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBncm91cGVkIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgbXVsdGlwbGUgZGF0YSBwb2ludHMgdGhhdCBoYXZlIHNhbWUgeCB2YWx1ZSB3aWxsIGJlIHNlbGVjdGVkIGJ5IG9uZSBzZWxlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZ3JvdXBlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICBzZWxlY3Rpb246IHtcblx0XHRcdCAqICAgICAgIGdyb3VwZWQ6IHRydWVcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBkIGFzIGFuIGFyZ3VtZW50IGFuZCBpdCBoYXMgc29tZSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleC4gVGhpcyBjYWxsYmFjayBzaG91bGQgcmV0dXJuIGJvb2xlYW4uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtdWx0aXBsZSBkYXRhIHBvaW50cyBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApG11bHRpcGxlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBtdWx0aXBsZTogZmFsc2Vcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRW5hYmxlIHRvIHNlbGVjdCBkYXRhIHBvaW50cyBieSBkcmFnZ2luZy5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBkYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQgYnkgZHJhZ2dpbmcuXG5cdFx0XHQgKiAtICoqTk9URToqKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgc2Nyb2xsaW5nIG9uIHRoZSBjaGFydCB3aWxsIGJlIGRpc2FibGVkIGJlY2F1c2UgZHJhZ2dpbmcgZXZlbnQgd2lsbCBoYW5kbGUgdGhlIGV2ZW50LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGRyYWdnYWJsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICBzZWxlY3Rpb246IHtcblx0XHRcdCAqICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZTogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGNsaWNrIGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIGVhY2ggZGF0YSBwb2ludCBjbGlja2VkIGFuZCB3aWxsIHJlY2VpdmUgZCBhbmQgZWxlbWVudCBhcyB0aGUgYXJndW1lbnRzLiBkIGlzIHRoZSBkYXRhIGNsaWNrZWQgYW5kIGVsZW1lbnQgaXMgdGhlIGVsZW1lbnQgY2xpY2tlZC4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25jbGlja1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgb25jbGljazogZnVuY3Rpb24oZCwgZWxlbWVudCkgeyAuLi4gfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdmVyIGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIG1vdXNlIGN1cnNvciBvciB2aWEgdG91Y2ggbW92ZXMgb250byBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBkIGFzIHRoZSBhcmd1bWVudC4gZCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb250by4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25vdmVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbm92ZXI6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdXQgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgZCBhcyB0aGUgYXJndW1lbnQuIGQgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG91dC4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25vdXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIG9ub3V0OiBmdW5jdGlvbihkKSB7IC4uLiB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25vdXQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHNlbGVjdGlvbi5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRvbnNlbGVjdGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG5cdFx0XHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cblx0XHRcdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cblx0XHRcdCAqICAgICAgICAuLi5cblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbnNlbGVjdGVkOiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSB1bi1zZWxlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb251bnNlbGVjdGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbnVuc2VsZWN0ZWQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcblx0XHRcdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxuXHRcdFx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxuXHRcdFx0ICogICAgICAgIC4uLlxuXHRcdFx0ICogICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29udW5zZWxlY3RlZDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxuXHRcdFx0ICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25taW5cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIG9ubWluOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxuXHRcdCAgICAgKiAgICAuLi5cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25taW46IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXG5cdFx0XHQgKiAtICoqTk9URToqKiBGb3IgJ2FyZWEtbGluZS1yYW5nZScgYW5kICdhcmVhLXNwbGluZS1yYW5nZScsIGBtaWRgIGRhdGEgd2lsbCBiZSB0YWtlbiBmb3IgdGhlIGNvbXBhcmlzb25cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRvbm1heFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdCAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXG5cdFx0ICAgICAqICAgIC4uLlxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbm1heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHVybFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkxvYWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3VybDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFhIUiBoZWFkZXIgdmFsdWVcblx0XHRcdCAqIC0gKipOT1RFOioqIFNob3VsZCBiZSB1c2VkIHdpdGggYGRhdGEudXJsYCBvcHRpb25cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRoZWFkZXJzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvc2V0UmVxdWVzdEhlYWRlclxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIixcblx0XHRcdCAqICAgICBoZWFkZXJzOiB7XG5cdFx0XHQgKiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3htbFwiLFxuXHRcdFx0ICogICAgICAgIC4uLlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9oZWFkZXJzOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUGFyc2UgYSBKU09OIG9iamVjdCBmb3IgZGF0YS4gU2VlIGFsc28gZGF0YS5rZXlzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGpzb25cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtkYXRh4oCka2V5c10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cylcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBqc29uOiBbXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxuXHRcdFx0ICogICAgIF0sXG5cdFx0XHQgKiAgICAga2V5czoge1xuXHRcdFx0ICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXG5cdFx0XHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfanNvbjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluaW5nIHRoZSBkYXRhIG5hbWVzLCB0aGUgZm9sbG93aW5nIGNvbnRhaW5pbmcgcmVsYXRlZCBkYXRhIGluIHRoYXQgb3JkZXIuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkcm93c1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuUm93T3JpZW50ZWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgcm93czogW1xuXHRcdFx0ICogICAgIFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcblx0XHRcdCAqICAgICBbOTAsIDEyMCwgMzAwXSxcblx0XHRcdCAqICAgICBbNDAsIDE2MCwgMjQwXSxcblx0XHRcdCAqICAgICBbNTAsIDIwMCwgMjkwXSxcblx0XHRcdCAqICAgICBbMTIwLCAxNjAsIDIzMF0sXG5cdFx0XHQgKiAgICAgWzgwLCAxMzAsIDMwMF0sXG5cdFx0XHQgKiAgICAgWzkwLCAyMjAsIDMyMF1cblx0XHRcdCAqICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxuXHRcdFx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuXHRcdFx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgcm93czogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxuXHRcdFx0ICogICAgICBbXG5cdFx0XHQgKiAgICAgICAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9LCAxMjBcblx0XHRcdCAqICAgICAgICBbMTUwLCAxNDAsIDExMF0sIDEyMFxuXHRcdFx0ICogICAgICBdLFxuXHRcdFx0ICogICAgICBbWzE1NSwgMTMwLCAxMTVdLCA1NV0sXG5cdFx0XHQgKiAgICAgIFtbMTYwLCAxMzUsIDEyMF0sIDYwXVxuXHRcdFx0ICogICBdLFxuXHRcdFx0ICogICB0eXBlczoge1xuXHRcdFx0ICogICAgICAgZGF0YTE6IFwiYXJlYS1saW5lLXJhbmdlXCIsXG5cdFx0XHQgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcblx0XHRcdCAqIC8vIC0gYW4gYXJyYXkgb2YgW3ksIHpdIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuXHRcdFx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAneScgYW5kICd6JyBrZXkgdmFsdWVcblx0XHRcdCAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHJvd3M6IFtcblx0XHRcdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcblx0XHRcdCAqICAgICAgW1xuXHRcdFx0ICogICAgICAgIC8vIG9yIHt5OjEwLCB6OiAxNDB9LCAxMjBcblx0XHRcdCAqICAgICAgICBbMTAsIDE0MF0sIDEyMFxuXHRcdFx0ICogICAgICBdLFxuXHRcdFx0ICogICAgICBbWzEwMCwgMzBdLCA1NV0sXG5cdFx0XHQgKiAgICAgIFtbNTAsIDEwMF0sIDYwXVxuXHRcdFx0ICogICBdLFxuXHRcdFx0ICogICB0eXBlczoge1xuXHRcdFx0ICogICAgICAgZGF0YTE6IFwiYnViYmxlXCIsXG5cdFx0XHQgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3Jvd3M6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggZWFjaCBlbGVtZW50IGNvbnRhaW5pbmcgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBhIGRhdHVtIG5hbWUgYW5kIGFzc29jaWF0ZWQgZGF0YSB2YWx1ZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ29sdW1uT3JpZW50ZWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLCAzMCwgMjAsIDUwLCA0MCwgNjAsIDUwXSxcblx0XHRcdCAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcblx0XHRcdCAqICAgICAgW1wiZGF0YTNcIiwgMzAwLCAyMDAsIDE2MCwgNDAwLCAyNTAsIDI1MF1cblx0XHRcdCAqICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxuXHRcdFx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuXHRcdFx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLFxuXHRcdFx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9XG5cdFx0XHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXG5cdFx0XHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF1cblx0XHRcdCAqICAgICAgXVxuXHRcdFx0ICogICBdLFxuXHRcdFx0ICogICB0eXBlOiBcImFyZWEtbGluZS1yYW5nZVwiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKlxuXHRcdFx0ICogLy8gZm9yICdidWJibGUnIHR5cGUsIGRhdGEgY2FuIGNvbnRhaW4gZGltZW5zaW9uIHZhbHVlOlxuXHRcdFx0ICogLy8gLSBhbiBhcnJheSBvZiBbeSwgel0gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXG5cdFx0XHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxuXHRcdFx0ICogLy8gJ3knIGlzIGZvciB5IGF4aXMgY29vcmRpbmF0aW9uIGFuZCAneicgaXMgdGhlIGJ1YmJsZSByYWRpdXMgdmFsdWVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLFxuXHRcdFx0ICogICAgICAgICAgWzEwLCAxNDBdLCAgLy8gb3Ige3k6MTAsIHo6IDE0MH1cblx0XHRcdCAqICAgICAgICAgIFsxMDAsIDMwXSxcblx0XHRcdCAqICAgICAgICAgIFs1MCwgMTAwXVxuXHRcdFx0ICogICAgICBdXG5cdFx0XHQgKiAgIF0sXG5cdFx0XHQgKiAgIHR5cGU6IFwiYnViYmxlXCJcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9jb2x1bW5zOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVXNlZCBpZiBsb2FkaW5nIEpTT04gdmlhIGRhdGEudXJsLlxuXHRcdFx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAgLSBqc29uXG5cdFx0XHQgKiAgIC0gY3N2XG5cdFx0XHQgKiAgIC0gdHN2XG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkbWltZVR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgY3N2XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX21pbWVUeXBlOiBcImNzdlwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENob29zZSB3aGljaCBKU09OIG9iamVjdCBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCka2V5c1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAganNvbjogW1xuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cblx0XHRcdCAqICAgICBdLFxuXHRcdFx0ICogICAgIGtleXM6IHtcblx0XHRcdCAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xuXHRcdFx0ICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2tleXM6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGV4dCBsYWJlbCB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGVyZSdzIG5vIGRhdGEgdG8gc2hvdy5cblx0XHRcdCAqIC0gZXguIFRvZ2dsaW5nIGFsbCB2aXNpYmxlIGRhdGEgdG8gbm90IGJlIHNob3duLCB1bmxvYWRpbmcgYWxsIGN1cnJlbnQgZGF0YSwgZXRjLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGVtcHR54oCkbGFiZWzigKR0ZXh0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGVtcHR5OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IFwiTm8gRGF0YVwiXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfZW1wdHlfbGFiZWxfdGV4dDogXCJcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgc3ViY2hhcnQgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgc3ViY2hhcnRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuc2hvdz1mYWxzZV0gU2hvdyBzdWIgY2hhcnQgb24gdGhlIGJvdHRvbSBvZiB0aGUgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLnguc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2suc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3ViY2hhcnQuc2l6ZS5oZWlnaHRdIENoYW5nZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJjaGFydC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtzdWJjaGFydC5vbmJydXNoXSBTZXQgY2FsbGJhY2sgZm9yIGJydXNoIGV2ZW50Ljxicj5cblx0XHRcdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGN1cnJlbnQgem9vbWVkIHggZG9tYWluLlxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlN1YkNoYXJ0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBzdWJjaGFydDoge1xuXHRcdFx0ICogICAgICBheGlzOiB7XG5cdFx0XHQgKiAgICAgIFx0eDoge1xuXHRcdFx0ICogICAgICBcdCAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICAgXHQgICAgdGljazoge1xuXHRcdFx0ICogICAgICBcdCAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIFx0ICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICBcdCAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICAgXHQgICAgICB9XG5cdFx0XHQgKiAgICAgIFx0ICAgIH1cblx0XHRcdCAqICAgICAgXHR9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIHNpemU6IHtcblx0XHRcdCAqICAgICAgICAgIGhlaWdodDogMjBcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgb25icnVzaDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRzdWJjaGFydF9zaG93OiBmYWxzZSxcblx0XHRcdHN1YmNoYXJ0X3NpemVfaGVpZ2h0OiA2MCxcblx0XHRcdHN1YmNoYXJ0X2F4aXNfeF9zaG93OiB0cnVlLFxuXHRcdFx0c3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcblx0XHRcdHN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdzogdHJ1ZSxcblx0XHRcdHN1YmNoYXJ0X29uYnJ1c2g6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjb2xvciBvZiB0aGUgZGF0YSB2YWx1ZXNcblx0XHRcdCAqIEBuYW1lIGNvbG9yXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gW2NvbG9yLm9ub3Zlcl0gU2V0IHRoZSBjb2xvciB2YWx1ZSBmb3IgZWFjaCBkYXRhIHBvaW50IHdoZW4gbW91c2UvdG91Y2ggb25vdmVyIGV2ZW50IG9jY3Vycy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci5wYXR0ZXJuXSBjdXN0b20gY29sb3IgcGF0dGVyblxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbG9yLnRpbGVzXSBpZiBkZWZpbmVkLCBhbGxvd3MgdXNlIHN2ZydzIHBhdHRlcm5zIHRvIGZpbGwgZGF0YSBhcmVhLiBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFtTVkdQYXR0ZXJuRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR1BhdHRlcm5FbGVtZW50KS5cblx0XHRcdCAqICAtICoqTk9URToqKiBUaGUgcGF0dGVybiBlbGVtZW50J3MgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLSRDT0xPUi1WQUxVRWAuPGJyPlxuXHRcdFx0ICogICAgZXguIFdoZW4gY29sb3IgcGF0dGVybiB2YWx1ZSBpcyBgWydyZWQnLCAnI2ZmZiddYCBhbmQgZGVmaW5lZCAyIHBhdHRlcm5zLHRoZW4gaWRzIGZvciBwYXR0ZXJuIGVsZW1lbnRzIGFyZTo8YnI+XG5cdFx0XHQgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLXJlZGBcblx0XHRcdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tZmZmYFxuXHRcdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IFtjb2xvci50aHJlc2hvbGRdIGNvbG9yIHRocmVzaG9sZCBmb3IgZ2F1Z2UgYW5kIHRvb2x0aXAgY29sb3Jcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29sb3IudGhyZXNob2xkLnVuaXRdIElmIHNldCB0byBgdmFsdWVgLCB0aGUgdGhyZXNob2xkIHdpbGwgYmUgYmFzZWQgb24gdGhlIGRhdGEgdmFsdWUuIE90aGVyd2lzZSBpdCdsbCBiZSBiYXNlZCBvbiBlcXVhdGlvbiBvZiB0aGUgYHRocmVzaG9sZC5tYXhgIG9wdGlvbiB2YWx1ZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci50aHJlc2hvbGQudmFsdWVzXSBUaHJlc2hvbGQgdmFsdWVzIGZvciBlYWNoIHN0ZXBzXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbG9yLnRocmVzaG9sZC5tYXg9MTAwXSBUaGUgYmFzZSB2YWx1ZSB0byBkZXRlcm1pbmUgdGhyZXNob2xkIHN0ZXAgdmFsdWUgY29uZGl0aW9uLiBXaGVuIHRoZSBnaXZlbiB2YWx1ZSBpcyAxNSBhbmQgbWF4IDEwLCB0aGVuIHRoZSB2YWx1ZSBmb3IgdGhyZXNob2xkIGlzIGAxNSoxMDAvMTBgLlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBjb2xvcjoge1xuXHRcdFx0ICogICAgICBwYXR0ZXJuOiBbXCIjMWY3N2I0XCIsIFwiI2FlYzdlOFwiLCAuLi5dLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gU2V0IGNvbG9ycycgcGF0dGVybnNcblx0XHRcdCAqICAgICAgLy8gaXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBTVkdQYXR0ZXJuRWxlbWVudFxuXHRcdFx0ICogICAgICB0aWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICAgIHZhciBwYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXR0ZXJuXCIpO1xuXHRcdFx0ICogICAgICAgICB2YXIgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcblx0XHRcdCAqICAgICAgICAgdmFyIGNpcmNsZTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG5cdFx0XHQgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIzMlwiKTtcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIzMlwiKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgIGcuc3R5bGUuZmlsbCA9IFwiIzAwMFwiO1xuXHRcdFx0ICogICAgICAgICBnLnN0eWxlLm9wYWNpdHkgPSBcIjAuMlwiO1xuICAgICAgICAgICAgICpcblx0XHRcdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjNcIik7XG5cdFx0XHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIzXCIpO1xuXHRcdFx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcInJcIiwgXCIzXCIpO1xuICAgICAgICAgICAgICpcblx0XHRcdCAqICAgICAgICAgZy5hcHBlbmRDaGlsZChjaXJjbGUxKTtcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5hcHBlbmRDaGlsZChnKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgIHJldHVybiBbcGF0dGVybl07XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBmb3IgdGhyZXNob2xkIHVzYWdlLCBwYXR0ZXJuIHZhbHVlcyBzaG91bGQgYmUgc2V0IGZvciBlYWNoIHN0ZXBzXG5cdFx0XHQgKiAgICAgIHBhdHRlcm46IFtcImdyZXlcIiwgXCJncmVlblwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcInJlZFwiXSxcblx0XHRcdCAqICAgICAgdGhyZXNob2xkOiB7XG5cdFx0XHQgKiAgICAgICAgICB1bml0OiBcInZhbHVlXCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyAyMCA9PiAnZ3JlZW4nLCB2YWx1ZSBpcyA0MCA9PiAnb3JhbmdlJyB3aWxsIGJlIHNldC5cblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzAsIDQwLCA1MF0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gdGhlIGVxdWF0aW9uIGZvciBtYXg6XG5cdFx0XHQgKiAgICAgICAgICAvLyAtIHVuaXQgPT0gJ3ZhbHVlJzogbWF4ID0+IDMwXG5cdFx0XHQgKiAgICAgICAgICAvLyAtIHVuaXQgIT0gJ3ZhbHVlJzogbWF4ID0+IHZhbHVlKjEwMC8zMFxuXHRcdFx0ICogICAgICAgICAgbWF4OiAzMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2V0IGFsbCBkYXRhIHRvICdyZWQnXG5cdFx0XHQgKiAgICAgIG9ub3ZlcjogXCJyZWRcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgY29sb3IgZm9yIGRhdGFcblx0XHRcdCAqICAgICAgb25vdmVyOiB7XG5cdFx0XHQgKiAgICAgICAgICBkYXRhMTogXCJyZWRcIixcblx0XHRcdCAqICAgICAgICAgIGRhdGEyOiBcInllbGxvd1wiXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB3aWxsIHBhc3MgZGF0YSBvYmplY3QgdG8gdGhlIGNhbGxiYWNrXG5cdFx0XHQgKiAgICAgIG9ub3ZlcjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgICAgcmV0dXJuIGQuaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImdyZWVuXCI7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGNvbG9yX3BhdHRlcm46IFtdLFxuXHRcdFx0Y29sb3JfdGlsZXM6IHVuZGVmaW5lZCxcblx0XHRcdGNvbG9yX3RocmVzaG9sZDoge30sXG5cdFx0XHRjb2xvcl9vbm92ZXI6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMZWdlbmQgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgbGVnZW5kXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZWdlbmQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuaGlkZT1mYWxzZV0gSGlkZSBsZWdlbmRcblx0XHRcdCAqICBJZiB0cnVlIGdpdmVuLCBhbGwgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLiBJZiBzdHJpbmcgb3IgYXJyYXkgZ2l2ZW4sIG9ubHkgdGhlIGxlZ2VuZCB0aGF0IGhhcyB0aGUgaWQgd2lsbCBiZSBoaWRkZW4uXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW2xlZ2VuZC5jb250ZW50cy5iaW5kdG89dW5kZWZpbmVkXSBTZXQgQ1NTIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHRvIGJpbmQgbGVnZW5kIGl0ZW1zLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8RnVuY3Rpb259IFtsZWdlbmQuY29udGVudHMudGVtcGxhdGU9dW5kZWZpbmVkXSBTZXQgaXRlbSdzIHRlbXBsYXRlLjxicj5cblx0XHRcdCAqICAtIElmIHNldCBgc3RyaW5nYCB2YWx1ZSwgd2l0aGluIHRlbXBsYXRlIHRoZSAnY29sb3InIGFuZCAndGl0bGUnIGNhbiBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XG5cdFx0XHQgKiAgICAtIHs9Q09MT1J9OiBkYXRhIGNvbG9yIHZhbHVlXG5cdFx0XHQgKiAgICAtIHs9VElUTEV9OiBkYXRhIHRpdGxlIHZhbHVlXG5cdFx0XHQgKiAgLSBJZiBzZXQgYGZ1bmN0aW9uYCB2YWx1ZSwgd2lsbCBwYXNzIGZvbGxvd2luZyBhcmd1bWVudHMgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uOlxuXHRcdFx0ICogICAtIHRpdGxlIHtTdHJpbmd9OiBkYXRhJ3MgaWQgdmFsdWVcblx0XHRcdCAqICAgLSBjb2xvciB7U3RyaW5nfTogY29sb3Igc3RyaW5nXG5cdFx0XHQgKiAgIC0gZGF0YSB7QXJyYXl9OiBkYXRhIGFycmF5XG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2xlZ2VuZC5wb3NpdGlvbj1ib3R0b21dIENoYW5nZSB0aGUgcG9zaXRpb24gb2YgbGVnZW5kLjxicj5cblx0XHRcdCAqICBBdmFpbGFibGUgdmFsdWVzIGFyZTogYGJvdHRvbWAsIGByaWdodGAgYW5kIGBpbnNldGAgYXJlIHN1cHBvcnRlZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbGVnZW5kLmluc2V0PXthbmNob3I6ICd0b3AtbGVmdCcseDogMTAseTogMCxzdGVwOiB1bmRlZmluZWR9XSBDaGFuZ2UgaW5zZXQgbGVnZW5kIGF0dHJpYnV0ZXMuPGJyPlxuXHRcdFx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IHRoYXQgaGFzIHRoZSBrZXlzIGBhbmNob3JgLCBgeGAsIGB5YCBhbmQgYHN0ZXBgLlxuXHRcdFx0ICogIC0gKiphbmNob3IqKiBkZWNpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kOlxuXHRcdFx0ICogICAtIHRvcC1sZWZ0XG5cdFx0XHQgKiAgIC0gdG9wLXJpZ2h0XG5cdFx0XHQgKiAgIC0gYm90dG9tLWxlZnRcblx0XHRcdCAqICAgLSBib3R0b20tcmlnaHRcblx0XHRcdCAqICAtICoqeCoqIGFuZCAqKnkqKjpcblx0XHRcdCAqICAgLSBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgYmFzZWQgb24gdGhlIGFuY2hvci5cblx0XHRcdCAqICAtICoqc3RlcCoqOlxuXHRcdFx0ICogICAtIGRlZmluZXMgdGhlIG1heCBzdGVwIHRoZSBsZWdlbmQgaGFzIChlLmcuIElmIDIgc2V0IGFuZCBsZWdlbmQgaGFzIDMgbGVnZW5kIGl0ZW0sIHRoZSBsZWdlbmQgMiBjb2x1bW5zKS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5lcXVhbGx5PWZhbHNlXSBTZXQgdG8gYWxsIGl0ZW1zIGhhdmUgc2FtZSB3aWR0aCBzaXplLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnBhZGRpbmc9MF0gU2V0IHBhZGRpbmcgdmFsdWVcblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbmNsaWNrPXVuZGVmaW5lZF0gU2V0IGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3Zlcj11bmRlZmluZWRdIFNldCBtb3VzZS90b3VjaCBvdmVyIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9ub3V0PXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS53aWR0aD0xMF0gU2V0IHdpZHRoIG9mIGl0ZW0gdGlsZSBlbGVtZW50XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUuaGVpZ2h0PTEwXSBTZXQgaGVpZ2h0IG9mIGl0ZW0gdGlsZSBlbGVtZW50XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQudXNlUG9pbnQ9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIGN1c3RvbSBwb2ludHMgaW4gbGVnZW5kLlxuXHRcdFx0ICogQHNlZSBbRGVtbzogcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kUG9zaXRpb24pXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBjb250ZW50cy50ZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC5MZWdlbmRUZW1wbGF0ZTEpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiB1c2VQb2ludF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC51c2VQb2ludClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgbGVnZW5kOiB7XG5cdFx0XHQgKiAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIGhpZGU6IHRydWUsXG5cdFx0XHQgKiAgICAgIC8vb3IgaGlkZTogXCJkYXRhMVwiXG4gICAgICAgICAgICAgKiAgICAgIC8vb3IgaGlkZTogW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxuXHRcdFx0ICogICAgICBjb250ZW50czoge1xuXHRcdFx0ICogICAgICAgICAgYmluZHRvOiBcIiNsZWdlbmRcIiwgICAvLyA8dWwgaWQ9J2xlZ2VuZCc+PC91bD5cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyB3aWxsIGJlIGFzOiA8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IzFmNzdiNCc+ZGF0YTE8L2xpPlxuXHRcdFx0ICogICAgICAgICAgdGVtcGxhdGU6IFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOns9Q09MT1J9Jz57PVRJVExFfTwvbGk+XCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyBvciB1c2luZyBmdW5jdGlvblxuXHRcdFx0ICogICAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKGlkLCBjb2xvciwgZGF0YSkge1xuXHRcdFx0ICogICAgICAgICAgICAgICAvLyBpZiB5b3Ugd2FudCBvbWl0IHNvbWUgbGVnZW5kLCByZXR1cm4gZmFsc3kgdmFsdWVcblx0XHRcdCAqICAgICAgICAgICAgICAgaWYgKHRpdGxlICE9PSBcImRhdGExXCIpIHtcblx0XHRcdCAqICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6XCIrIGNvbG9yICtcIj5cIisgdGl0bGUgK1wiPC9saT5cIjtcblx0XHRcdCAqICAgICAgICAgICAgICAgfVxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuICAgICAgICAgICAgICogICAgICBwb3NpdGlvbjogXCJib3R0b21cIiwgIC8vIGJvdHRvbSwgcmlnaHQsIGluc2V0XG5cdFx0XHQgKiAgICAgIGluc2V0OiB7XG5cdFx0XHQgKiAgICAgICAgICBhbmNob3I6IFwidG9wLXJpZ2h0XCIgIC8vIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1sZWZ0LCBib3R0b20tcmlnaHRcblx0XHRcdCAqICAgICAgICAgIHg6IDIwLFxuXHRcdFx0ICogICAgICAgICAgeTogMTAsXG5cdFx0XHQgKiAgICAgICAgICBzdGVwOiAyXG5cdFx0XHQgKiAgICAgIH0sXG4gICAgICAgICAgICAgKiAgICAgIGVxdWFsbHk6IGZhbHNlLFxuICAgICAgICAgICAgICogICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgICAgICAqICAgICAgaXRlbToge1xuXHRcdFx0ICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgICAgICBvbm92ZXI6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICAgICAgb25vdXQ6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgIC8vIHNldCB0aWxlJ3Mgc2l6ZVxuXHRcdFx0ICogICAgICAgICAgdGlsZToge1xuXHRcdFx0ICogICAgICAgICAgICAgIHdpZHRoOiAyMCxcblx0XHRcdCAqICAgICAgICAgICAgICBoZWlnaHQ6IDE1XG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHVzZVBvaW50OiB0cnVlXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRsZWdlbmRfc2hvdzogdHJ1ZSxcblx0XHRcdGxlZ2VuZF9oaWRlOiBmYWxzZSxcblx0XHRcdGxlZ2VuZF9jb250ZW50c19iaW5kdG86IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX3Bvc2l0aW9uOiBcImJvdHRvbVwiLFxuXHRcdFx0bGVnZW5kX2luc2V0X2FuY2hvcjogXCJ0b3AtbGVmdFwiLFxuXHRcdFx0bGVnZW5kX2luc2V0X3g6IDEwLFxuXHRcdFx0bGVnZW5kX2luc2V0X3k6IDEwLFxuXHRcdFx0bGVnZW5kX2luc2V0X3N0ZXA6IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9pdGVtX29uY2xpY2s6IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9pdGVtX29ub3ZlcjogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX2l0ZW1fb25vdXQ6IHVuZGVmaW5lZCxcblx0XHRcdGxlZ2VuZF9lcXVhbGx5OiBmYWxzZSxcblx0XHRcdGxlZ2VuZF9wYWRkaW5nOiAwLFxuXHRcdFx0bGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXG5cdFx0XHRsZWdlbmRfaXRlbV90aWxlX2hlaWdodDogMTAsXG5cdFx0XHRsZWdlbmRfdXNlUG9pbnQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFN3aXRjaCB4IGFuZCB5IGF4aXMgcG9zaXRpb24uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkcm90YXRlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHJvdGF0ZWQ6IHRydWVcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc19yb3RhdGVkOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeCBheGlzIGVsZW1lbnRcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkY2xpcFBhdGhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXG5cdFx0XHQgKiBjbGlwUGF0aDogZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2NsaXBQYXRoOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB4IGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0eXBlIG9mIHggYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogKipBdmFpbGFibGUgVmFsdWVzOioqXG5cdFx0XHQgKiAtIHRpbWVzZXJpZXNcblx0XHRcdCAqIC0gY2F0ZWdvcnlcblx0XHRcdCAqIC0gaW5kZXhlZFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0eXBlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IGluZGV4ZWRcblx0XHRcdCAqIEBzZWUgW0RlbW86IGluZGV4ZWRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiB0aW1lc2VyaWVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuVGltZXNlcmllc0NoYXJ0KVxuXHRcdFx0ICogQHNlZSBbRGVtbzogY2F0ZWdvcnldKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNhdGVnb3J5RGF0YSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90eXBlOiBcImluZGV4ZWRcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgaG93IHRvIHRyZWF0IHRoZSB0aW1lem9uZSBvZiB4IHZhbHVlcy48YnI+XG5cdFx0XHQgKiBJZiB0cnVlLCB0cmVhdCB4IHZhbHVlIGFzIGxvY2FsdGltZS4gSWYgZmFsc2UsIGNvbnZlcnQgdG8gVVRDIGludGVybmFsbHkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGxvY2FsdGltZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGxvY2FsdGltZTogZmFsc2Vcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfbG9jYWx0aW1lOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxuXHRcdFx0ICogVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGNhdGVnb3JpZXM6IFtcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLl1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfY2F0ZWdvcmllczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogY2VudGVyaXplIHRpY2tzIG9uIGNhdGVnb3J5IGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjZW50ZXJlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjZW50ZXJlZDogdHJ1ZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19jZW50ZXJlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQSBmdW5jdGlvbiB0byBmb3JtYXQgdGljayB2YWx1ZS4gRm9ybWF0IHN0cmluZyBpcyBhbHNvIGF2YWlsYWJsZSBmb3IgdGltZXNlcmllcyBkYXRhLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZm9ybWF0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRDMncyB0aW1lIHNwZWNpZmllcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0I2xvY2FsZV9mb3JtYXQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzLCBhICdkYXRldGltZScgb2JqZWN0IGlzIGdpdmVuIGFzIHBhcmFtZXRlclxuXHRcdFx0ICogICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgICAgcmV0dXJuIHguZ2V0RnVsbFllYXIoKTtcblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyBmb3IgY2F0ZWdvcnksIGluZGV4KE51bWJlcikgYW5kIGNhdGVnb3J5TmFtZShTdHJpbmcpIGFyZSBnaXZlbiBhcyBwYXJhbWV0ZXJcblx0XHRcdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGNhdGVnb3J5TmFtZSkge1xuXHRcdFx0ICogICAgICAgICAgIHJldHVybiBjYXRlZ29yeU5hbWUuc3Vic3RyKDAsIDEwKTtcblx0XHRcdCAqICAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzIGZvcm1hdCBzcGVjaWZpZXJcblx0XHRcdCAqICAgICAgICBmb3JtYXQ6IFwiJVktJW0tJWQgJUg6JU06JVNcIlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cblx0XHRcdCAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLngudGljay5jdWxsaW5nLm1heC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0XG5cdFx0XHQgKiAtIHRydWUgZm9yIGluZGV4ZWQgYXhpcyBhbmQgdGltZXNlcmllcyBheGlzXG5cdFx0XHQgKiAtIGZhbHNlIGZvciBjYXRlZ29yeSBheGlzXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY3VsbGluZzogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfY3VsbGluZzoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjdWxsaW5n4oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IDEwXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY3VsbGluZzoge1xuXHRcdFx0ICogICAgICAgICAgIG1heDogNVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19jdWxsaW5nX21heDogMTAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIG51bWJlciBvZiB4IGF4aXMgdGlja3MgdG8gc2hvdy48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gaGlkZXMgdGljayBsaW5lcyB0b2dldGhlciB3aXRoIHRpY2sgdGV4dC4gSWYgdGhpcyBvcHRpb24gaXMgdXNlZCBvbiB0aW1lc2VyaWVzIGF4aXMsIHRoZSB0aWNrcyBwb3NpdGlvbiB3aWxsIGJlIGRldGVybWluZWQgcHJlY2lzZWx5IGFuZCBub3QgbmljZWx5IHBvc2l0aW9uZWQgKGUuZy4gaXQgd2lsbCBoYXZlIHJvdWdoIHNlY29uZCB2YWx1ZSkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjb3VudFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjb3VudDogNVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19jb3VudDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3RleHRfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIHggQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICBwb3NpdGlvbjoge1xuXHRcdFx0ICogICAgICAgICAgIHg6IDEwLFxuXHRcdFx0ICogICAgICAgICAgIHk6IDEwXG5cdFx0XHQgKiAgICAgICAgIH1cblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpdCB4IGF4aXMgdGlja3MuXG5cdFx0XHQgKiAtICoqdHJ1ZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgbmljZWx5IHRvIGhhdmUgc2FtZSBpbnRlcnZhbHMuXG5cdFx0XHQgKiAtICoqZmFsc2UqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIGFjY29yZGluZyB0byB4IHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZpdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrRml0dGluZylcblx0XHRcdCAqIEBzZWUgW0RlbW86IGZvciB0aW1lc2VyaWVzIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja1RpbWVzZXJpZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgZml0OiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19maXQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSB4IHZhbHVlcyBvZiB0aWNrcyBtYW51YWxseS48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gaXMgcHJvdmlkZWQsIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBkZXRlcm1pbmVkIGJhc2VkIG9uIHRob3NlIHZhbHVlcy4gVGhpcyBvcHRpb24gd29ya3Mgd2l0aCB0aW1lc2VyaWVzIGRhdGEgYW5kIHRoZSB4IHZhbHVlcyB3aWxsIGJlIHBhcnNlZCBhY2NvZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYW5kIGRhdGEueEZvcm1hdCBvcHRpb24uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR2YWx1ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdmFsdWVzOiBbMSwgMiwgNCwgOCwgMTYsIDMyLCAuLi5dXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3ZhbHVlczogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSb3RhdGUgeCBheGlzIHRpY2sgdGV4dC48YnI+XG5cdFx0XHQgKiBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRyb3RhdGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgMFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuUm90YXRlWEF4aXNUaWNrVGV4dClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICByb3RhdGU6IDYwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3JvdGF0ZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkb3V0ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBvdXRlcjogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfb3V0ZXI6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRpY2sgdGV4dCB0byBiZSBtdWx0aWxpbmVcblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbmQgJ2F4aXMueC50aWNrLndpZHRoJyBvcHRpb24gaXMgaWdub3JlZC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG11bHRpbGluZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrTXVsdGlsaW5lKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIG11bHRpbGluZTogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAvLyBleGFtcGxlIG9mIGxpbmUgYnJlYWsgd2l0aCAnXFxuJ1xuXHRcdFx0ICogLy8gSW4gdGhpcyBjYXNlLCAnYXhpcy54LnRpY2sud2lkdGgnIGlzIGlnbm9yZWRcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHg6IFwieFwiLFxuXHRcdFx0ICogICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICAgIFtcInhcIiwgXCJsb25nXFxudGV4dFwiLCBcIkFub3RoZXJcXG5Mb25nXFxuVGV4dFwiXSxcblx0XHRcdCAqICAgICAgICAuLi5cblx0XHRcdCAqICAgIF0sXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX211bHRpbGluZTogdHJ1ZSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aWNrIHdpZHRoXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB3aWR0aDogNTBcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfd2lkdGg6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRvIGRpc3BsYXkgc3lzdGVtIHRvb2x0aXAodmlhICd0aXRsZScgYXR0cmlidXRlKSBmb3IgdGljayB0ZXh0XG5cdFx0XHQgKiAtICoqTk9URToqKiBPbmx5IGF2YWlsYWJsZSBmb3IgY2F0ZWdvcnkgYXhpcyB0eXBlIChgYXhpcy54LnR5cGU9J2NhdGVnb3J5J2ApXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0b29sdGlwXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRvb2x0aXA6IHRydWVcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfdG9vbHRpcDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IG1heCB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApG1heFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBtYXg6IDEwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9tYXg6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWluIHZhbHVlIG9mIHggYXhpcyByYW5nZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkbWluXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIG1pbjogLTEwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9taW46IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgcGFkZGluZyBmb3IgeCBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSByYW5nZSBvZiB4IGF4aXMgd2lsbCBpbmNyZWFzZS9kZWNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlcy5cblx0XHRcdCAqIElmIG5vIHBhZGRpbmcgaXMgbmVlZGVkIGluIHRoZSByYWdlIG9mIHggYXhpcywgMCBzaG91bGQgYmUgc2V0LlxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgVGhlIHBhZGRpbmcgdmFsdWVzIGFyZW4ndCBiYXNlZCBvbiBwaXhlbHMuIEl0IGRpZmZlcnMgYWNjb3JkaW5nIGF4aXMgdHlwZXM8YnI+XG5cdFx0XHQgKiAgIC0gKipjYXRlZ29yeToqKiBUaGUgdW5pdCBvZiB0aWNrIHZhbHVlXG5cdFx0XHQgKiAgICAgZXguIHRoZSBnaXZlbiB2YWx1ZSBgMWAsIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxuXHRcdFx0ICogICAtICoqdGltZXNlcmllczoqKiBOdW1lcmljIHRpbWUgdmFsdWVcblx0XHRcdCAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxMDAwKjYwKjYwKjI0YCwgd2hpY2ggaXMgbnVtZXJpYyB0aW1lIGVxdWl2YWxlbnQgb2YgYSBkYXksIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRwYWRkaW5nXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgcGFkZGluZzoge1xuXHRcdFx0ICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ2NhdGVnb3J5J1xuXHRcdFx0ICogICAgICAgbGVmdDogMSwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIHRpY2sncyB3aWR0aFxuXHRcdFx0ICogICAgICAgcmlnaHQ6IDAuNSAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIHRpY2sncyB3aWR0aFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICd0aW1lc2VyaWVzJ1xuXHRcdFx0ICogICAgICAgbGVmdDogMTAwMCo2MCo2MCoyNCwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcblx0XHRcdCAqICAgICAgIHJpZ2h0OiAxMDAwKjYwKjYwKjEyICAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgZGF5IHRpY2sncyB3aWR0aFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfcGFkZGluZzoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGhlaWdodCBvZiB4IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFRoZSBoZWlnaHQgb2YgeCBheGlzIGNhbiBiZSBzZXQgbWFudWFsbHkgYnkgdGhpcyBvcHRpb24uIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UgZm9yIHggYXhpcywgcGxlYXNlIHVzZSB0aGlzIG9wdGlvbiBmb3IgdGhhdC4gVGhlIHVuaXQgaXMgcGl4ZWwuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApGhlaWdodFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBoZWlnaHQ6IDIwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2hlaWdodDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkZWZhdWx0IGV4dGVudCBmb3Igc3ViY2hhcnQgYW5kIHpvb20uIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkZXh0ZW50XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgLy8gZXh0ZW50IHJhbmdlIGFzIGEgcGl4ZWwgdmFsdWVcblx0XHRcdCAqICAgICBleHRlbnQ6IFswLCAyMDBdLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAvLyB3aGVuIGF4aXMgaXMgJ3RpbWVzZXJpZXMnLCBwYXJzYWJsZSBkYXRldGltZSBzdHJpbmdcblx0XHRcdCAqICAgICBleHRlbnQ6IFtcIjIwMTktMDMtMDFcIiwgXCIyMDE5LTAzLTA1XCJdLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAvLyByZXR1cm4gZXh0ZW50IHZhbHVlXG5cdFx0XHQgKiAgICAgZXh0ZW50OiBmdW5jdGlvbihkb21haW4sIHNjYWxlKSB7XG5cdFx0XHQgKiAgICBcdCB2YXIgZXh0ZW50ID0gZG9tYWluLm1hcChmdW5jdGlvbih2KSB7XG5cdFx0XHQgKiAgICAgXHQgICAgcmV0dXJuIHNjYWxlKHYpO1xuXHRcdFx0ICogICAgIFx0IH0pO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgXHQgLy8gaXQgc2hvdWxkIHJldHVybiBhIGZvcm1hdCBvZiBhcnJheVxuXHRcdFx0ICogICBcdCAvLyBleCkgWzAsIDU4NF1cblx0XHRcdCAqICAgICBcdCByZXR1cm4gZXh0ZW50O1xuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfZXh0ZW50OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxhYmVsIG9uIHggYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogWW91IGNhbiBzZXQgeCBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLlxuXHRcdFx0ICogYHN0cmluZ2AgYW5kIGBvYmplY3RgIGNhbiBiZSBwYXNzZWQgYW5kIHdlIGNhbiBjaGFuZ2UgdGhlIHBvaXNpdG9uIGJ5IHBhc3Npbmcgb2JqZWN0IHRoYXQgaGFzIHBvc2l0aW9uIGtleS48YnI+XG5cdFx0XHQgKiBBdmFpbGFibGUgcG9zaXRpb24gZGlmZmVycyBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgZGlyZWN0aW9uICh2ZXJ0aWNhbCBvciBob3Jpem9udGFsKS5cblx0XHRcdCAqIElmIHN0cmluZyBzZXQsIHRoZSBwb3NpdGlvbiB3aWxsIGJlIHRoZSBkZWZhdWx0LlxuXHRcdFx0ICpcblx0XHRcdCAqICAtICoqSWYgaXQncyBob3Jpem9udGFsIGF4aXM6Kipcblx0XHRcdCAqICAgIC0gaW5uZXItcmlnaHQgW2RlZmF1bHRdXG5cdFx0XHQgKiAgICAtIGlubmVyLWNlbnRlclxuXHRcdFx0ICogICAgLSBpbm5lci1sZWZ0XG5cdFx0XHQgKiAgICAtIG91dGVyLXJpZ2h0XG5cdFx0XHQgKiAgICAtIG91dGVyLWNlbnRlclxuXHRcdFx0ICogICAgLSBvdXRlci1sZWZ0XG5cdFx0XHQgKiAgLSAqKklmIGl0J3MgdmVydGljYWwgYXhpczoqKlxuXHRcdFx0ICogICAgLSBpbm5lci10b3AgW2RlZmF1bHRdXG5cdFx0XHQgKiAgICAtIGlubmVyLW1pZGRsZVxuXHRcdFx0ICogICAgLSBpbm5lci1ib3R0b21cblx0XHRcdCAqICAgIC0gb3V0ZXItdG9wXG5cdFx0XHQgKiAgICAtIG91dGVyLW1pZGRsZVxuXHRcdFx0ICogICAgLSBvdXRlci1ib3R0b21cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkbGFiZWxcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGxhYmVsOiBcIllvdXIgWCBBeGlzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFggQXhpc1wiLFxuXHRcdFx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLWNlbnRlclwiXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9sYWJlbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeCBBeGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxuXHRcdFx0ICpcblx0XHRcdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxuXHRcdFx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHRcdFx0ICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxuXHRcdFx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XG5cdFx0XHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcblx0XHRcdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRheGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHg6IHtcblx0XHRcdCAqICAgIGF4ZXM6IFtcblx0XHRcdCAqICAgICAge1xuXHRcdFx0ICogICAgICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICBjb3VudDogMixcblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICAuLi5cblx0XHRcdCAqICAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2F4ZXM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB5IGF4aXMgZWxlbWVudFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRjbGlwUGF0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcblx0XHRcdCAqIGNsaXBQYXRoOiBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfY2xpcFBhdGg6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHR5cGUgb2YgeSBheGlzLjxicj48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAgLSB0aW1lc2VyaWVzXG5cdFx0XHQgKiAgIC0gY2F0ZWdvcnlcblx0XHRcdCAqICAgLSBpbmRleGVkXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdHlwZTogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtYXggdmFsdWUgb2YgeSBheGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIG1heDogMTAwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9tYXg6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWluIHZhbHVlIG9mIHkgYXhpcy5cblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApG1pblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBtaW46IDEwMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfbWluOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeSBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRpbnZlcnRlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9pbnZlcnRlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5IGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBjZW50ZXI6IDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfY2VudGVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyB5IGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkaW5uZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgaW5uZXI6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfaW5uZXI6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBsYWJlbCBvbiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFlvdSBjYW4gc2V0IHkgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGxhYmVsXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ3xPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQHNlZSBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpIGZvciBwb3NpdGlvbiBzdHJpbmcgdmFsdWUuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IFwiWW91ciBZIEF4aXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKlxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWSBBeGlzXCIsXG5cdFx0XHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2xhYmVsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZm9ybWF0dGVyIGZvciB5IGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRmb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cblx0XHRcdCAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLnkudGljay5jdWxsaW5nLm1heC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGN1bGxpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY3VsbGluZzogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3RpY2tfY3VsbGluZzogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjdWxsaW5n4oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IDVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjdWxsaW5nOiB7XG5cdFx0XHQgKiAgICAgICAgICAgbWF4OiA1XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX2N1bGxpbmdfbWF4OiA1LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRvdXRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIG91dGVyOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19vdXRlcjogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgeSBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdmFsdWVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHZhbHVlczogWzEwMCwgMTAwMCwgMTAwMDBdXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX3ZhbHVlczogbnVsbCxcblx0XHRcdGF4aXNfeV90aWNrX3JvdGF0ZTogMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cblx0XHRcdCAqIC0gKipOT1RFOioqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBjYWxjdWxhdGVkIHByZWNpc2VseSwgc28gdGhlIHZhbHVlcyBvbiB0aGUgdGlja3Mgd2lsbCBub3QgYmUgcm91bmRlZCBuaWNlbHkuIEluIHRoZSBjYXNlLCBheGlzLnkudGljay5mb3JtYXQgb3IgYXhpcy55LnRpY2sudmFsdWVzIHdpbGwgYmUgaGVscGZ1bC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGNvdW50XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNvdW50OiA1XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX2NvdW50OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIGxpbmUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0KiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgdGV4dC5cblx0XHRcdCogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcblx0XHRcdCogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHRcdCogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCogQGV4YW1wbGVcblx0XHRcdCogYXhpczoge1xuXHRcdFx0KiAgIHk6IHtcblx0XHRcdCogICAgIHRpY2s6IHtcblx0XHRcdCogICAgICAgdGV4dDoge1xuXHRcdFx0KiAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCogICAgICAgfVxuXHRcdFx0KiAgICAgfVxuXHRcdFx0KiAgIH1cblx0XHRcdCogfVxuXHRcdFx0Ki9cblx0XHRcdGF4aXNfeV90aWNrX3RleHRfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIHkgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICBwb3NpdGlvbjoge1xuXHRcdFx0ICogICAgICAgICAgIHg6IDEwLFxuXHRcdFx0ICogICAgICAgICAgIHk6IDEwXG5cdFx0XHQgKiAgICAgICAgIH1cblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcy48YnI+PGJyPlxuXHRcdFx0ICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3RpbWUudmFsdWVdIEQzJ3MgdGltZSBpbnRlcnZhbCBmdW5jdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUjaW50ZXJ2YWxzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRpbWU6IHtcblx0XHRcdCAqICAgICAgICAgIC8vIHRpY2tzIGF0IDE1LW1pbnV0ZSBpbnRlcnZhbHNcblx0XHRcdCAqICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjdGltZV90aWNrc1xuXHRcdFx0ICogICAgICAgICAgdmFsdWU6IGQzLnRpbWVNaW51dGUuZXZlcnkoMTUpXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdC8vIEBUT0RPOiBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0XG5cdFx0XHRheGlzX3lfdGlja190aW1lX3ZhbHVlOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBhZGRpbmcgZm9yIHkgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogWW91IGNhbiBzZXQgcGFkZGluZyBmb3IgeSBheGlzIHRvIGNyZWF0ZSBtb3JlIHNwYWNlIG9uIHRoZSBlZGdlIG9mIHRoZSBheGlzLlxuXHRcdFx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxuXHRcdFx0ICpcblx0XHRcdCAqIC0gKipOT1RFOioqIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRwYWRkaW5nXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgcGFkZGluZzoge1xuXHRcdFx0ICogICAgICAgdG9wOiAwLFxuXHRcdFx0ICogICAgICAgYm90dG9tOiAwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9wYWRkaW5nOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeSBheGlzIHdoZW4gdGhlcmUgaXMgbm8gZGF0YSBvbiBpbml0LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRkZWZhdWx0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2RlZmF1bHQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5IEF4aXMuXG5cdFx0XHQgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB5IEF4aXMgdmFsdWVcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG5cdFx0XHQgKlxuXHRcdFx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdFx0XHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdFx0XHQgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XG5cdFx0XHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcblx0XHRcdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuXHRcdFx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGF4ZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogeToge1xuXHRcdFx0ICogICAgYXhlczogW1xuXHRcdFx0ICogICAgICB7XG5cdFx0XHQgKiAgICAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxuXHRcdFx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xuXHRcdFx0ICogICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgIGNvdW50OiAyLFxuXHRcdFx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIC4uLlxuXHRcdFx0ICogICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfYXhlczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMuXG5cdFx0XHQgKiAtICoqTk9URSoqOlxuXHRcdFx0ICogICAtIFdoZW4gc2V0IHRvIGBmYWxzZWAgd2lsbCBub3QgZ2VuZXJhdGUgeTIgYXhpcyBub2RlLiBJbiB0aGlzIGNhc2UsIGFsbCAneTInIGF4aXMgcmVsYXRlZCBmdW5jdGlvbmFsaXR5IHdvbid0IHdvcmsgcHJvcGVybHkuXG5cdFx0XHQgKiAgIC0gSWYgbmVlZCB0byB1c2UgJ3kyJyByZWxhdGVkIG9wdGlvbnMgd2hpbGUgeTIgaXNuJ3QgdmlzaWJsZSwgc2V0IHRoZSB2YWx1ZSBgdHJ1ZWAgYW5kIGNvbnRyb2wgdmlzaWJpbGl0eSBieSBjc3MgZGlzcGxheSBwcm9wZXJ0eS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHNob3c6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3Nob3c6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtYXggdmFsdWUgb2YgeTIgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApG1heFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgbWF4OiAxMDAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9tYXg6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWluIHZhbHVlIG9mIHkyIGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRtaW5cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIG1pbjogLTEwMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX21pbjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHkyIGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRpbnZlcnRlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgaW52ZXJ0ZWQ6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX2ludmVydGVkOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkyIGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRjZW50ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIGNlbnRlcjogMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfY2VudGVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyB5MiBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRpbm5lclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgaW5uZXI6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX2lubmVyOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbGFiZWwgb24geTIgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogWW91IGNhbiBzZXQgeTIgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRsYWJlbFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBzZWUgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKSBmb3IgcG9zaXRpb24gc3RyaW5nIHZhbHVlLlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBsYWJlbDogXCJZb3VyIFkyIEF4aXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKlxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFkyIEF4aXNcIixcblx0XHRcdCAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1taWRkbGVcIlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX2xhYmVsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZm9ybWF0dGVyIGZvciB5MiBheGlzIHRpY2sgdGV4dC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS5mb3JtYXQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkZm9ybWF0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGZvcm1hdDogZDMuZm9ybWF0KFwiJCxcIilcblx0XHRcdCAqICAgICAgIC8vb3IgZm9ybWF0OiBmdW5jdGlvbihkKSB7IHJldHVybiBcIiRcIiArIGQ7IH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX2Zvcm1hdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxuXHRcdFx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGN1bGxpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja19jdWxsaW5nOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5n4oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IDVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgY3VsbGluZzoge1xuXHRcdFx0ICogICAgICAgICAgIG1heDogNVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfY3VsbGluZ19tYXg6IDUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgb3V0ZXIgdGljay5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRvdXRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBvdXRlcjogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX291dGVyOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB5MiBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHZhbHVlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX3ZhbHVlczogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIG51bWJlciBvZiB5MiBheGlzIHRpY2tzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogVGhpcyB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy55LnRpY2suY291bnQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY291bnRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNvdW50OiA1XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja19jb3VudDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgbGluZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyB0aWNrIHRleHQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdGV4dOKApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfdGV4dF9zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgIHBvc2l0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICAgeDogMTAsXG5cdFx0XHQgKiAgICAgICAgICAgeTogMTBcblx0XHRcdCAqICAgICAgICAgfVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgbnVtYmVyIG9mIHkyIGF4aXMgdGlja3MuXG5cdFx0XHQgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHBhZGRpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgcGFkZGluZzoge1xuXHRcdFx0ICogICAgICAgdG9wOiAxMDAsXG5cdFx0XHQgKiAgICAgICBib3R0b206IDEwMFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3BhZGRpbmc6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkyIGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGRlZmF1bHRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeTIgQXhpcy5cblx0XHRcdCAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkyIEF4aXMgdmFsdWVcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG5cdFx0XHQgKlxuXHRcdFx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdFx0XHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdFx0XHQgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XG5cdFx0XHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcblx0XHRcdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuXHRcdFx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRheGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHkyOiB7XG5cdFx0XHQgKiAgICBheGVzOiBbXG5cdFx0XHQgKiAgICAgIHtcblx0XHRcdCAqICAgICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXG5cdFx0XHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgY291bnQ6IDIsXG5cdFx0XHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgLi4uXG5cdFx0XHQgKiAgICBdXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfYXhlczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHJlbGF0ZWQgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgZ3JpZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmcm9udD1mYWxzZV0gU2V0ICdncmlkICYgZm9jdXMgbGluZXMnIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBncmlkIGxpbmVzIGFuZCBjaGFydCBlbGVtZW50cy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3guc2hvdz1mYWxzZV0gU2hvdyBncmlkcyBhbG9uZyB4IGF4aXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBbeC5saW5lcz1bXV0gU2hvdyBhZGRpdGlvbmFsIGdyaWQgbGluZXMgYWxvbmcgeCBheGlzLjxicj5cblx0XHRcdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXG5cdFx0XHQgKiAgSWYgeCBheGlzIGlzIGNhdGVnb3J5IGF4aXMsIHZhbHVlIGNhbiBiZSBjYXRlZ29yeSBuYW1lLiBJZiB4IGF4aXMgaXMgdGltZXNlcmllcyBheGlzLCB2YWx1ZSBjYW4gYmUgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbeS5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt5LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB5IGF4aXMuPGJyPlxuXHRcdFx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt5LnRpY2tzPTEwXSBOdW1iZXIgb2YgeSBncmlkcyB0byBiZSBzaG93bi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkcyB3aGVuIGZvY3VzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZXMuZnJvbnQ9dHJ1ZV0gU2V0IGdyaWQgbGluZXMgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGNoYXJ0IGVsZW1lbnRzLlxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBYIEdyaWQgTGluZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLk9wdGlvbmFsWEdyaWRMaW5lcylcblx0XHRcdCAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGdyaWQ6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgbGluZXM6IFtcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogNiwgdGV4dDogXCJMYWJlbCBvbiA2XCIsIHBvc2l0aW9uOiBcInN0YXJ0XCJ9XG5cdFx0XHQgKiAgICAgXVxuXHRcdFx0ICogICB9LFxuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICBsaW5lczogW1xuXHRcdFx0ICogICAgICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgb24gMTAwXCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XG5cdFx0XHQgKiAgICAgXSxcblx0XHRcdCAqICAgICB0aWNrczogNVxuXHRcdFx0ICogICB9LFxuXHRcdFx0ICogICBmcm9udDogdHJ1ZSxcblx0XHRcdCAqICAgZm9jdXM6IHtcblx0XHRcdCAqICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgfSxcblx0XHRcdCAqICAgbGluZXM6IHtcblx0XHRcdCAqICAgICAgZnJvbnQ6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0Z3JpZF94X3Nob3c6IGZhbHNlLFxuXHRcdFx0Z3JpZF94X3R5cGU6IFwidGlja1wiLFxuXHRcdFx0Z3JpZF94X2xpbmVzOiBbXSxcblx0XHRcdGdyaWRfeV9zaG93OiBmYWxzZSxcblx0XHRcdGdyaWRfeV9saW5lczogW10sXG5cdFx0XHRncmlkX3lfdGlja3M6IDEwLFxuXHRcdFx0Z3JpZF9mb2N1c19zaG93OiB0cnVlLFxuXHRcdFx0Z3JpZF9mcm9udDogZmFsc2UsXG5cdFx0XHRncmlkX2xpbmVzX2Zyb250OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwb2ludCBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBwb2ludFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwb2ludC5zaG93PXRydWVdIFdoZXRoZXIgdG8gc2hvdyBlYWNoIHBvaW50IGluIGxpbmUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cblx0XHRcdCAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuZm9jdXMuZXhwYW5kLmVuYWJsZWQ9dHJ1ZV0gV2hldGhlciB0byBleHBhbmQgZWFjaCBwb2ludCBvbiBmb2N1cy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cblx0XHRcdCAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2Vuc2l0aXZpdHk9MTBdIFRoZSBzZW5zdGl2aXR5IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2VsZWN0LnI9cG9pbnQucio0XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBzZWxlY3RlZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cblx0XHRcdCAqICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxuXHRcdFx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGNpcmNsZVxuXHRcdFx0ICogIC0gcmVjdGFuZ2xlXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBbcG9pbnQucGF0dGVybj1bXV0gVGhlIHR5cGUgb2YgcG9pbnQgb3Igc3ZnIHNoYXBlIGFzIHN0cmluZywgdG8gYmUgZHJhd24gZm9yIGVhY2ggbGluZVxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAtIFRoaXMgaXMgYW4gYGV4cGVyaW1lbnRhbGAgZmVhdHVyZSBhbmQgY2FuIGhhdmUgc29tZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cblx0XHRcdCAqICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cblx0XHRcdCAqICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxuXHRcdFx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGNpcmNsZVxuXHRcdFx0ICogIC0gcmVjdGFuZ2xlXG5cdFx0XHQgKiAgLSBzdmcgc2hhcGUgdGFnIGludGVycHJldGVkIGFzIHN0cmluZzxicj5cblx0XHRcdCAqICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBwb2ludCB0eXBlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUG9pbnQuUmVjdGFuZ2xlUG9pbnRzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBwb2ludDoge1xuXHRcdFx0ICogICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgcjogNSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIGN1c3RvbWl6ZSB0aGUgcmFkaXVzXG5cdFx0XHQgKiAgICAgIHI6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdCAqICAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgICAgICAgcmV0dXJuIHI7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBmb2N1czoge1xuXHRcdFx0ICogICAgICAgICAgZXhwYW5kOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcblx0XHRcdCAqICAgICAgICAgICAgICByOiAxXG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHNlbGVjdDoge1xuXHRcdFx0ICogICAgICAgICAgcjogM1xuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gaGF2aW5nIGxvd2VyIHZhbHVlLCBtZWFucyBob3cgY2xvc2VyIHRvIGJlIGZvciBpbnRlcmFjdGlvblxuXHRcdFx0ICogICAgICBzZW5zaXRpdml0eTogMyxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHZhbGlkIHZhbHVlcyBhcmUgXCJjaXJjbGVcIiBvciBcInJlY3RhbmdsZVwiXG5cdFx0XHQgKiAgICAgIHR5cGU6IFwicmVjdGFuZ2xlXCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBpbmRpY2F0ZSBhcyBwYXR0ZXJuXG4gXHRcdFx0ICogICAgICBwYXR0ZXJuOiBbXG4gXHRcdFx0ICogICAgICAgIFwiY2lyY2xlXCIsXG4gXHRcdFx0ICogICAgICAgIFwicmVjdGFuZ2xlXCIsXG4gXHRcdFx0ICogICAgICAgIFwiPHBvbHlnb24gcG9pbnRzPScwIDYgNCAwIC00IDAnPjwvcG9seWdvbj5cIlxuIFx0XHRcdCAqICAgICBdLFxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cG9pbnRfc2hvdzogdHJ1ZSxcblx0XHRcdHBvaW50X3I6IDIuNSxcblx0XHRcdHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcblx0XHRcdHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxuXHRcdFx0cG9pbnRfZm9jdXNfZXhwYW5kX3I6IHVuZGVmaW5lZCxcblx0XHRcdHBvaW50X3BhdHRlcm46IFtdLFxuXHRcdFx0cG9pbnRfc2VsZWN0X3I6IHVuZGVmaW5lZCxcblx0XHRcdHBvaW50X3R5cGU6IFwiY2lyY2xlXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxpbmUgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgbGluZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLmNvbm5lY3ROdWxsPWZhbHNlXSBTZXQgaWYgbnVsbCBkYXRhIHBvaW50IHdpbGwgYmUgY29ubmVjdGVkIG9yIG5vdC48YnI+XG5cdFx0XHQgKiAgSWYgdHJ1ZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgYmUgY29ubmVjdGVkIHdpdGhvdXQgYW55IGRhdGEgcG9pbnQuIElmIGZhbHNlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBub3QgYmUgY29ubmVjdGVkIGFuZCBnZXQgZW1wdHkuXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSAgIFtsaW5lLmNsYXNzZXM9dW5kZWZpbmVkXSBJZiBzZXQsIHVzZWQgdG8gc2V0IGEgY3NzIGNsYXNzIG9uIGVhY2ggbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuc3RlcC50eXBlPXN0ZXBdIENoYW5nZSBzdGVwIHR5cGUgZm9yIHN0ZXAgY2hhcnQuPGJyPlxuXHRcdFx0ICogKipBdmFpbGFibGUgdmFsdWVzOioqXG5cdFx0XHQgKiAtIHN0ZXBcblx0XHRcdCAqIC0gc3RlcC1iZWZvcmVcblx0XHRcdCAqIC0gc3RlcC1hZnRlclxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufEFycmF5fSBbbGluZS5wb2ludD10cnVlXSBTZXQgdG8gZmFsc2UgdG8gbm90IGRyYXcgcG9pbnRzIG9uIGxpbmVjaGFydHMuIE9yIHBhc3MgYW4gYXJyYXkgb2YgbGluZSBpZHMgdG8gZHJhdyBwb2ludHMgZm9yLlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBsaW5lOiB7XG5cdFx0XHQgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxuXHRcdFx0ICogICAgICBjbGFzc2VzOiBbXG5cdFx0XHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MxXCIsXG5cdFx0XHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MyXCJcblx0XHRcdCAqICAgICAgXSxcblx0XHRcdCAqICAgICAgc3RlcDoge1xuXHRcdFx0ICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXG5cdFx0XHQgKiAgICAgIHBvaW50OiBmYWxzZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXG5cdFx0XHQgKiAgICAgIHBvaW50OiBbXG5cdFx0XHQgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxuXHRcdFx0ICogICAgICBdXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcblx0XHRcdGxpbmVfc3RlcF90eXBlOiBcInN0ZXBcIixcblx0XHRcdGxpbmVfY2xhc3NlczogdW5kZWZpbmVkLFxuXHRcdFx0bGluZV9wb2ludDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYmFyIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGJhclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5wYWRkaW5nPTBdIFRoZSBwYWRkaW5nIHBpeGVsIHZhbHVlIGJldHdlZW4gZWFjaCBiYXIuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5yYWRpdXNdIFNldCB0aGUgcmFkaXVzIG9mIGJhciBlZGdlIGluIHBpeGVsLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5yYWRpdXMucmF0aW9dIFNldCB0aGUgcmFkaXVzIHJhdGlvIG9mIGJhciBlZGdlIGluIHJlbGF0aXZlIHRoZSBiYXIncyB3aWR0aC5cbiBcdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGhdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGgucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWVdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGZvciBpbmRpY2F0ZWQgZGF0YXNldCBvbmx5LlxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcblx0XHRcdCAqICAgLSBCYXJzIGFyZSBjZW50ZXJlZCBhY2NvZGluZyBpdHMgdG90YWwgd2lkdGggdmFsdWVcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Jhci56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJhciBjaGFydC5cblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciBwYWRkaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclBhZGRpbmcpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aCB2YXJpYW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoVmFyaWFudClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgYmFyOiB7XG5cdFx0XHQgKiAgICAgIHBhZGRpbmc6IDEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB0aGUgJ3JhZGl1cycgb3B0aW9uIGNhbiBiZSB1c2VkIG9ubHkgZm9yIG5vbi1zdGFja2luZyBiYXJzXG5cdFx0XHQgKiAgICAgIHJhZGl1czogMTAsXG5cdFx0XHQgKiAgICAgIC8vIG9yXG5cdFx0XHQgKiAgICAgIHJhZGl1czoge1xuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuNVxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB3aWxsIG5vdCBoYXZlIG9mZnNldCBiZXR3ZWVuIGVhY2ggYmFyIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuXHRcdFx0ICogICAgICBzZW5zaXRpdml0eTogMCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIHdpZHRoOiAxMCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yXG5cdFx0XHQgKiAgICAgIHdpZHRoOiB7XG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogMC4yLFxuXHRcdFx0ICogICAgICAgICAgbWF4OiAyMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Igc3BlY2lmeSB3aWR0aCBwZXIgZGF0YXNldFxuXHRcdFx0ICogICAgICB3aWR0aDoge1xuXHRcdFx0ICogICAgICAgICAgZGF0YTE6IDIwLFxuXHRcdFx0ICogICAgICAgICAgZGF0YTI6IHtcblx0XHRcdCAqICAgICAgICAgICAgICByYXRpbzogMC4yLFxuXHRcdFx0ICogICAgICAgICAgICAgIG1heDogMjBcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2Vcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGJhcl9wYWRkaW5nOiAwLFxuXHRcdFx0YmFyX3JhZGl1czogdW5kZWZpbmVkLFxuXHRcdFx0YmFyX3JhZGl1c19yYXRpbzogdW5kZWZpbmVkLFxuXHRcdFx0YmFyX3NlbnNpdGl2aXR5OiAyLFxuXHRcdFx0YmFyX3dpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRiYXJfd2lkdGhfcmF0aW86IDAuNixcblx0XHRcdGJhcl93aWR0aF9tYXg6IHVuZGVmaW5lZCxcblx0XHRcdGJhcl96ZXJvYmFzZWQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGJ1YmJsZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBidWJibGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtidWJibGUubWF4Uj0zNV0gU2V0IHRoZSBtYXggYnViYmxlIHJhZGl1cyB2YWx1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBidWJibGU6IHtcblx0XHRcdCAqICAgICAgLy8gZXgpIElmIDEwMCBpcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbW9uZyBkYXRhIGJvdW5kLCB0aGUgcmVwcmVzZW50YXRpb24gYnViYmxlIG9mIDEwMCB3aWxsIGhhdmUgcmFkaXVzIG9mIDUwLlxuXHRcdFx0ICogICAgICAvLyBBbmQgdGhlIGxlc3NlciB3aWxsIGhhdmUgcmFkaXVzIHJlbGF0aXZlbHkgZnJvbSB0aGEgbWF4IHZhbHVlLlxuXHRcdFx0ICogICAgICBtYXhSOiA1MCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIHNldCByYWRpdXMgY2FsbGJhY2tcblx0XHRcdCAqICAgICAgbWF4UjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgICAgLy8gZXguIG9mIGQgcGFyYW0gLSB7eDogRnJpIE9jdCAwNiAyMDE3IDAwOjAwOjAwIEdNVCswOTAwLCB2YWx1ZTogODAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA1fVxuXHRcdFx0ICogICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUgKiAyKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0YnViYmxlX21heFI6IDM1LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhcmVhIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGFyZWFcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbYXJlYS56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGFyZWEgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLmFib3ZlPWZhbHNlXSBTZXQgYmFja2dyb3VuZCBhcmVhIGFib3ZlIHRoZSBkYXRhIGNoYXJ0IGxpbmUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbYXJlYS5saW5lYXJHcmFkaWVudD1mYWxzZV0gU2V0IHRoZSBsaW5lYXIgZ3JhZGllbnQgb24gYXJlYS48YnI+PGJyPlxuXHRcdFx0ICogT3IgY3VzdG9taXplIGJ5IGdpdmluZyBiZWxvdyBvYmplY3QgdmFsdWU6XG5cdFx0XHQgKiAgLSB4IHtBcnJheX06IGB4MWAsIGB4MmAgdmFsdWVcblx0XHRcdCAqICAtIHkge0FycmF5fTogYHkxYCwgYHkyYCB2YWx1ZVxuXHRcdFx0ICogIC0gc3RvcHMge0FycmF5fTogRWFjaCBpdGVtIHNob3VsZCBiZSBoYXZpbmcgYFtvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eV1gIHZhbHVlcy5cblx0XHRcdCAqIEBzZWUgW01ETidzICZsdDtsaW5lYXJHcmFkaWVudD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2xpbmVhckdyYWRpZW50KSwgWyZsdDtzdG9wPl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3RvcClcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBhYm92ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuQWJvdmUpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBsaW5lYXJHcmFkaWVudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuTGluZWFyR3JhZGllbnQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGFyZWE6IHtcblx0XHRcdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZSxcblx0XHRcdCAqICAgICAgYWJvdmU6IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB3aWxsIGdlbmVyYXRlIGZvbGx3aW5nIGxpbmVhckdyYWRpZW50OlxuXHRcdFx0ICogICAgICAvLyA8bGluZWFyR3JhZGllbnQgeDE9XCIwXCIgeDI9XCIwXCIgeTE9XCIwXCIgeTI9XCIxXCI+XG5cdFx0XHQgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIxXCI+PC9zdG9wPlxuXHRcdFx0ICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMFwiPjwvc3RvcD5cblx0XHRcdCAqICAgICAgLy8gPC9saW5lYXJHcmFkaWVudD5cblx0XHRcdCAqICAgICAgbGluZWFyR3JhZGllbnQ6IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBPciBjdXN0b21pemVkIGdyYWRpZW50XG5cdFx0XHQgKiAgICAgIGxpbmVhckdyYWRpZW50OiB7XG5cdFx0XHQgKiAgICAgIFx0eDogWzAsIDBdLCAgLy8geDEsIHgyIGF0dHJpYnV0ZXNcblx0XHRcdCAqICAgICAgXHR5OiBbMCwgMF0sICAvLyB5MSwgeTIgYXR0cmlidXRlc1xuXHRcdFx0ICogICAgICBcdHN0b3BzOiBbXG5cdFx0XHQgKiAgICAgIFx0ICAvLyBvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eVxuXHRcdFx0ICogICAgICBcdCAgWzAsIFwiIzdjYjVlY1wiLCAxXSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdudWxsJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBzZXQgaXRzIG9yaWdpbmFsIGRhdGEgY29sb3Jcblx0XHRcdCAqICAgICAgXHQgIFswLjUsIG51bGwsIDBdLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgXHQgIC8vIHNldHRpbmcgJ2Z1bmN0aW9uJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBwYXNzIGRhdGEgaWQgYXMgYXJndW1lbnQuXG5cdFx0XHQgKiAgICAgIFx0ICAvLyBJdCBzaG91bGQgcmV0dXJuIGNvbG9yIHN0cmluZyBvciBudWxsIHZhbHVlXG5cdFx0XHQgKiAgICAgIFx0ICBbMSwgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJibHVlXCI7IH0sIDBdLFxuXHRcdFx0ICogICAgICBcdF1cblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0YXJlYV96ZXJvYmFzZWQ6IHRydWUsXG5cdFx0XHRhcmVhX2Fib3ZlOiBmYWxzZSxcblx0XHRcdGFyZWFfbGluZWFyR3JhZGllbnQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwaWUgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgcGllXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BpZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtwaWUubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtwaWUubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3BpZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIHBpZSBwaWVjZXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8T2JqZWN0fSBbcGllLmlubmVyUmFkaXVzPTBdIFNldHMgdGhlIGlubmVyIHJhZGl1cyBvZiBwaWUgYXJjLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkZGluZz0wXSBTZXRzIHRoZSBnYXAgYmV0d2VlbiBwaWUgYXJjcy5cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgcGllOiB7XG5cdFx0XHQgKiAgICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xuXHRcdFx0ICogICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiAwLjVcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXG5cdFx0XHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXG5cdFx0XHQgKiAgICAgIGV4cGFuZDoge1xuXHRcdFx0ICogICAgICAgICAgZHVyYXRpb246IDUwMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgaW5uZXJSYWRpdXM6IDAsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgZGlmZmVyZW50IGlubmVyUmFkaXVzIGZvciBlYWNoIGRhdGFcblx0XHRcdCAqICAgICAgaW5uZXJSYWRpdXM6IHtcblx0XHRcdCAqICAgICAgXHRkYXRhMTogMTAsXG5cdFx0XHQgKiAgICAgIFx0ZGF0YTI6IDBcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgcGFkQW5nbGU6IDAuMSxcblx0XHRcdCAqICAgICAgcGFkZGluZzogMFxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cGllX2xhYmVsX3Nob3c6IHRydWUsXG5cdFx0XHRwaWVfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG5cdFx0XHRwaWVfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxuXHRcdFx0cGllX2xhYmVsX3JhdGlvOiB1bmRlZmluZWQsXG5cdFx0XHRwaWVfZXhwYW5kOiB7fSxcblx0XHRcdHBpZV9leHBhbmRfZHVyYXRpb246IDUwLFxuXHRcdFx0cGllX2lubmVyUmFkaXVzOiAwLFxuXHRcdFx0cGllX3BhZEFuZ2xlOiAwLFxuXHRcdFx0cGllX3BhZGRpbmc6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBsdWdpbnNcblx0XHRcdCAqIEBuYW1lIHBsdWdpbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHBsdWdpbnM6IFtcblx0XHRcdCAqICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXG5cdFx0XHQgKiAgICBuZXcgUGx1Z2luQSgpLFxuXHRcdFx0ICogICAgLi4uXG5cdFx0XHQgKiBdXG5cdFx0XHQgKi9cblx0XHRcdHBsdWdpbnM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBnYXVnZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBnYXVnZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnYXVnZS5mdWxsQ2lyY2xlPWZhbHNlXSBTaG93IGZ1bGwgY2lyY2xlIGFzIGRvbnV0LiBXaGVuIHNldCB0byAndHJ1ZScsIHRoZSBtYXggbGFiZWwgd2lsbCBub3QgYmUgc2hvd2VkIGR1ZSB0byBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgc2FtZSBsb2NhdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGdhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGdhdWdlLiBMYWJlbCB0ZXh0IGNhbiBiZSBtdWx0aWxpbmVkIHdpdGggYFxcbmAgY2hhcmFjdGVyLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmV4dGVudHNdIFNldCBjdXN0b21pemVkIG1pbi9tYXggbGFiZWwgdGV4dC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IHRoZSBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UubWluPTBdIFNldCBtaW4gdmFsdWUgb2YgdGhlIGdhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5tYXg9MTAwXSBTZXQgbWF4IHZhbHVlIG9mIHRoZSBnYXVnZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uuc3RhcnRpbmdBbmdsZT0tMSAqIE1hdGguUEkgLyAyXVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZ2F1Z2UgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudW5pdHNdIFNldCB1bml0cyBvZiB0aGUgZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLndpZHRoXSBTZXQgd2lkdGggb2YgZ2F1Z2UgY2hhcnQuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGdhdWdlOiB7XG5cdFx0XHQgKiAgICAgIGZ1bGxDaXJjbGU6IGZhbHNlLFxuXHRcdFx0ICogICAgICBsYWJlbDoge1xuXHRcdFx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXG5cdFx0XHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbykge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgZXh0ZW50czogZnVuY3Rpb24odmFsdWUsIGlzTWF4KSB7XG5cdFx0IFx0ICogICAgICAgICAgICAgIHJldHVybiAoaXNNYXggPyBcIk1heDpcIiA6IFwiTWluOlwiKSArIHZhbHVlO1xuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Igc2V0IGR1cmF0aW9uXG5cdFx0XHQgKiAgICAgIGV4cGFuZDoge1xuXHRcdFx0ICogICAgICAgICAgZHVyYXRpb246IDIwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIG1pbjogLTEwMCxcblx0XHRcdCAqICAgICAgbWF4OiAyMDAsXG5cdFx0XHQgKiAgICAgIHRpdGxlOiBcIlRpdGxlIFRleHRcIixcblx0XHRcdCAqICAgICAgdW5pdHM6IFwiJVwiLFxuXHRcdFx0ICogICAgICB3aWR0aDogMTBcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGdhdWdlX2Z1bGxDaXJjbGU6IGZhbHNlLFxuXHRcdFx0Z2F1Z2VfbGFiZWxfc2hvdzogdHJ1ZSxcblx0XHRcdGdhdWdlX2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2VfbWluOiAwLFxuXHRcdFx0Z2F1Z2VfbWF4OiAxMDAsXG5cdFx0XHRnYXVnZV9zdGFydGluZ0FuZ2xlOiAtMSAqIE1hdGguUEkgLyAyLFxuXHRcdFx0Z2F1Z2VfbGFiZWxfZXh0ZW50czogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2VfdGl0bGU6IFwiXCIsXG5cdFx0XHRnYXVnZV91bml0czogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2Vfd2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdGdhdWdlX2V4cGFuZDoge30sXG5cdFx0XHRnYXVnZV9leHBhbmRfZHVyYXRpb246IDUwLFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGRvbnV0IG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGRvbnV0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RvbnV0LmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggZG9udXQgcGllY2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZG9udXQubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbZG9udXQubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBkb251dCBwaWVjZXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LndpZHRoXSBTZXQgd2lkdGggb2YgZG9udXQgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2RvbnV0LnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBkb251dCBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGRvbnV0OiB7XG5cdFx0XHQgKiAgICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG5cdFx0XHQgKiAgICAgICAgICBcdC4uLlxuXHRcdFx0ICogICAgICAgICAgXHRyZXR1cm4gcmF0aW87XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuNVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxuXHRcdFx0ICogICAgICB3aWR0aDogMTAsXG5cdFx0XHQgKiAgICAgIHBhZEFuZ2xlOiAwLjIsXG5cdFx0XHQgKiAgICAgIHRpdGxlOiBcIkRvbnV0IFRpdGxlXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHRpdGxlIHdpdGggbGluZSBicmVha1xuXHRcdFx0ICogICAgICB0aXRsZTogXCJUaXRsZTFcXG5UaXRsZTJcIlxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0ZG9udXRfbGFiZWxfc2hvdzogdHJ1ZSxcblx0XHRcdGRvbnV0X2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuXHRcdFx0ZG9udXRfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxuXHRcdFx0ZG9udXRfbGFiZWxfcmF0aW86IHVuZGVmaW5lZCxcblx0XHRcdGRvbnV0X3dpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRkb251dF90aXRsZTogXCJcIixcblx0XHRcdGRvbnV0X2V4cGFuZDoge30sXG5cdFx0XHRkb251dF9leHBhbmRfZHVyYXRpb246IDUwLFxuXHRcdFx0ZG9udXRfcGFkQW5nbGU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHNwbGluZSBvcHRpb25zXG5cdFx0XHQgKiAtICoqQXZhaWxhYmxlIGludGVycG9sYXRpb24gdHlwZSB2YWx1ZXM6Kipcblx0XHRcdCAqICAtIGJhc2lzIChkMy5jdXJ2ZUJhc2lzKVxuXHRcdFx0ICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxuXHRcdFx0ICogIC0gYmFzaXMtb3BlbiAoZDMuY3VydmVCYXNpc09wZW4pXG5cdFx0XHQgKiAgLSBidW5kbGUgKGQzLmN1cnZlQnVuZGxlKVxuXHRcdFx0ICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXG5cdFx0XHQgKiAgLSBjYXJkaW5hbC1jbG9zZWQgKGQzLmN1cnZlQ2FyZGluYWxDbG9zZWQpXG5cdFx0XHQgKiAgLSBjYXJkaW5hbC1vcGVuIChkMy5jdXJ2ZUNhcmRpbmFsT3Blbilcblx0XHRcdCAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXG5cdFx0XHQgKiAgLSBjYXRtdWxsLXJvbS1jbG9zZWQgKGQzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZClcblx0XHRcdCAqICAtIGNhdG11bGwtcm9tLW9wZW4gKGQzLmN1cnZlQ2F0bXVsbFJvbU9wZW4pXG5cdFx0XHQgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcblx0XHRcdCAqICAtIG1vbm90b25lLXkgKGQzLmN1cnZlTW9ub3RvbmVZKVxuXHRcdFx0ICogIC0gbmF0dXJhbCAoZDMuY3VydmVOYXR1cmFsKVxuXHRcdFx0ICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXG5cdFx0XHQgKiAgLSBsaW5lYXIgKGQzLmN1cnZlTGluZWFyKVxuXHRcdFx0ICogIC0gc3RlcCAoZDMuY3VydmVTdGVwKVxuXHRcdFx0ICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXG5cdFx0XHQgKiAgLSBzdGVwLWJlZm9yZSAoZDMuY3VydmVTdGVwQmVmb3JlKVxuXHRcdFx0ICogQG5hbWUgc3BsaW5lXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3BsaW5lLmludGVycG9sYXRpb24udHlwZT1cImNhcmRpbmFsXCJdXG5cdFx0XHQgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHNwbGluZToge1xuXHRcdFx0ICogICAgICBpbnRlcnBvbGF0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICB0eXBlOiBcImNhcmRpbmFsXCJcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0c3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTogXCJjYXJkaW5hbFwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCByYWRhciBvcHRpb25zXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsuXG5cdFx0XHQgKiBAbmFtZSByYWRhclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLmF4aXMubWF4PXVuZGVmaW5lZF0gVGhlIG1heCB2YWx1ZSBvZiBheGlzLiBJZiBub3QgZ2l2ZW4sIGl0J2xsIHRha2UgdGhlIG1heCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBkYXRhLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy5saW5lLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIuYXhpcy50ZXh0LnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXG5cdFx0XHQgKiBAcHJvcGVydHkge05VbWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi55PTBdIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgdGV4dC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmRpcmVjdGlvbi5jbG9ja3dpc2U9ZmFsc2VdIFNldCB0aGUgZGlyZWN0aW9uIHRvIGJlIGRyYXduLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5sZXZlbC5kZXB0aD0zXSBTZXQgdGhlIGxldmVsIGRlcHRoLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGV2ZWwuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcmFkYXIubGV2ZWwudGV4dC5mb3JtYXQ9KHgpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpXSBTZXQgZm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgbGV2ZWwgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5sZXZlbC50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsIHRleHQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLnNpemUucmF0aW89MC44N10gU2V0IHNpemUgcmF0aW8uXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuUmFkYXJDaGFydClcblx0XHRcdCAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiByYWRhciBsZXZlbF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyTGV2ZWwpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiByYWRhciBzaXplXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJTaXplKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogcmFkYXIgYXhpcyBtdWx0aWxpbmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckF4aXNNdWx0aWxpbmUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHJhZGFyOiB7XG5cdFx0XHQgKiAgICAgIGF4aXM6IHtcblx0XHRcdCAqICAgICAgICAgIG1heDogNTAsXG5cdFx0XHQgKiAgICAgICAgICBsaW5lOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICAgICBcdHg6IDAsXG5cdFx0XHQgKiAgICAgICAgICAgICAgXHR5OiAwXG5cdFx0XHQgKiAgICAgICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBkaXJlY3Rpb246IHtcblx0XHRcdCAqICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBsZXZlbDoge1xuXHRcdFx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXG5cdFx0XHQgKiAgICAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XG5cdFx0XHQgKiAgICAgICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgICAgICBzaG93OiB0cnVlXG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHNpemU6IHtcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiAwLjdcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cmFkYXJfYXhpc19tYXg6IHVuZGVmaW5lZCxcblx0XHRcdHJhZGFyX2F4aXNfbGluZV9zaG93OiB0cnVlLFxuXHRcdFx0cmFkYXJfYXhpc190ZXh0X3Nob3c6IHRydWUsXG5cdFx0XHRyYWRhcl9heGlzX3RleHRfcG9zaXRpb246IHt9LFxuXHRcdFx0cmFkYXJfbGV2ZWxfZGVwdGg6IDMsXG5cdFx0XHRyYWRhcl9sZXZlbF9zaG93OiB0cnVlLFxuXHRcdFx0cmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQ6IHggPT4gKHggJSAxID09PSAwID8geCA6IHgudG9GaXhlZCgyKSksXG5cdFx0XHRyYWRhcl9sZXZlbF90ZXh0X3Nob3c6IHRydWUsXG5cdFx0XHRyYWRhcl9zaXplX3JhdGlvOiAwLjg3LFxuXHRcdFx0cmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ29udHJvbCB0aGUgcmVuZGVyIHRpbWluZ1xuXHRcdFx0ICogQG5hbWUgcmVuZGVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlbmRlci5sYXp5PXRydWVdIE1ha2UgdG8gbm90IHJlbmRlciBhdCBpbml0aWFsaXphdGlvbiAoZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eSBpcyBoaWRkZW4pLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVuZGVyLm9ic2VydmU9dHJ1ZV0gT2JzZXJ2ZSBiaW5kIGVsZW1lbnQncyB2aXNpYmlsaXR5KGBkaXNwbGF5YCBvciBgdmlzaWJsaXR5YCBpbmxpbmUgY3NzIHByb3BlcnR5IG9yIGNsYXNzIHZhbHVlKSAmIHJlbmRlciB3aGVuIGlzIHZpc2libGUgYXV0b21hdGljYWxseSAoZm9yIElFcywgb25seSB3b3JrcyBJRTExKykuIFdoZW4gc2V0IHRvICoqZmFsc2UqKiwgY2FsbCBbYC5mbHVzaCgpYF0oLi9DaGFydC5odG1sI2ZsdXNoKSB0byByZW5kZXIuXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkxhenlSZW5kZXIpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHJlbmRlcjoge1xuXHRcdFx0ICogICAgbGF6eTogdHJ1ZSxcblx0XHRcdCAqICAgIG9ic2VydmU6IHRydWVcblx0XHRcdCAqIH1cblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcdC8vIDwhLS0gcmVuZGVyLmxhenkgd2lsbCBkZXRlY3QgdmlzaWJpbGl0eSBkZWZpbmVkIC0tPlxuXHRcdFx0ICogIC8vIChhKSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2hpZGUnPjwvZGl2PlxuXHRcdFx0ICogIC8vIChiKSA8ZGl2IGlkPSdjaGFydCcgc3R5bGU9J2Rpc3BsYXk6bm9uZSc+PC9kaXY+XG5cdFx0XHQgKlxuXHRcdFx0ICogIC8vIHJlbmRlci5sYXp5IGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGVsZW1lbnQgaXMgaGlkZGVuXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIC8vIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQgYXV0b21hdGljYWxseSB3aGVuIGVsZW1lbnQncyB2aXNpYmlsaXR5IGNoYW5nZXNcblx0XHRcdCAqICAvLyBOb3RlOiB3b3JrcyBvbmx5IGZvciBpbmxpbmVkIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyBhdHRyaWJ1dGUgY2hhbmdlc1xuXHRcdFx0ICogIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKSAgLy8gKGEpXG5cdFx0XHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7ICAvLyAoYilcblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcdC8vIGNoYXJ0IHdvbid0IGJlIHJlbmRlcmVkIGFuZCBub3Qgb2JzZXJ2aW5nIGJpbmQgZWxlbWVudCdzIHZpc2libGl0eSBjaGFuZ2VzXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuXHRcdFx0ICogICAgIHJlbmRlcjoge1xuXHRcdFx0ICogICAgICAgICAgbGF6eTogdHJ1ZSxcblx0XHRcdCAqICAgICAgICAgIG9ic2VydmU6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogIH0pO1xuXHRcdFx0ICpcblx0XHRcdCAqICAvLyBjYWxsIGF0IGFueSBwb2ludCB3aGVuIHlvdSB3YW50IHRvIHJlbmRlclxuXHRcdFx0ICogIGNoYXJ0LmZsdXNoKCk7XG5cdFx0XHQgKi9cblx0XHRcdHJlbmRlcjoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyByZWN0YW5nbGVzIGluc2lkZSB0aGUgY2hhcnQuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyBheGlzLCBzdGFydCwgZW5kIGFuZCBjbGFzcy4gVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxuXHRcdFx0ICogYXhpcyBtdXN0IGJlIHgsIHkgb3IgeTIuIHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHRoZSB2YWx1ZSB3aGVyZSByZWdpb25zIHN0YXJ0IGFuZCBlbmQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuIElmIHRpbWVzZXJpZXMgeCBheGlzLCBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIgY2FuIGJlIHVzZWQuIElmIGNsYXNzIGlzIHNldCwgdGhlIHJlZ2lvbiBlbGVtZW50IHdpbGwgaGF2ZSBpdCBhcyBjbGFzcy5cblx0XHRcdCAqIEBuYW1lIHJlZ2lvbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICByZWdpb25zOiBbXG5cdFx0XHQgKiAgICB7XG5cdFx0XHQgKiAgICAgIGF4aXM6IFwieFwiLFxuXHRcdFx0ICogICAgICBzdGFydDogMSxcblx0XHRcdCAqICAgICAgZW5kOiA0LFxuXHRcdFx0ICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqICBdXG5cdFx0XHQgKi9cblx0XHRcdHJlZ2lvbnM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRvb2x0aXAgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgdG9vbHRpcFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHRvb2x0aXAuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmRvTm90SGlkZT1mYWxzZV0gTWFrZSB0b29sdGlwIGtlZXAgc2hvd2luZyBub3QgaGlkaW5nIG9uIGludGVyYWN0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXG5cdFx0XHQgKiAgIC0gKipOT1RFOioqIFRoZSBvdmVybGFwcGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgZGlzcGxheWVkIGFzIGdyb3VwZWQgZXZlbiBpZiBzZXQgZmFsc2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmxpbmtlZD1mYWxzZV0gU2V0IGlmIHRvb2x0aXBzIG9uIGFsbCB2aXNpYmxlIGNoYXJ0cyB3aXRoIGxpa2UgeCBwb2ludHMgYXJlIHNob3duIHRvZ2V0aGVyIHdoZW4gb25lIGlzIHNob3duLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnRpdGxlXSBTZXQgZm9ybWF0IGZvciB0aGUgdGl0bGUgb2YgdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudmFsdWVdIFNldCBmb3JtYXQgZm9yIHRoZSB2YWx1ZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXG5cdFx0XHQgKiAgSWYgdW5kZWZpbmVkIHJldHVybmVkLCB0aGUgcm93IG9mIHRoYXQgdmFsdWUgd2lsbCBiZSBza2lwcGVkLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAucG9zaXRpb25dIFNldCBjdXN0b20gcG9zaXRpb24gZm9yIHRoZSB0b29sdGlwLjxicj5cblx0XHRcdCAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufE9iamVjdH0gW3Rvb2x0aXAuY29udGVudHNdIFNldCBjdXN0b20gSFRNTCBmb3IgdGhlIHRvb2x0aXAuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBkYXRhLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCBhbmQgY29sb3Igb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gSWYgdG9vbHRpcC5ncm91cGVkIGlzIHRydWUsIGRhdGEgaW5jbHVkZXMgbXVsdGlwbGUgZGF0YSBwb2ludHMuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXG5cdFx0XHQgKiAgLSAqKk5PVEU6KiogV2hlbiBpcyBzcGVjaWZpZWQsIHdpbGwgbm90IGJlIHVwZGF0aW5nIHRvb2x0aXAncyBwb3NpdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdG9vbHRpcC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCB0b29sdGlwJ3MgdGVtcGxhdGUuPGJyPjxicj5cblx0XHRcdCAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcblx0XHRcdCAqICAgIC0gKip7eyAuLi4gfX0qKjogdGhlIGRvdWJseSBjdXJseSBicmFja2V0cyBpbmRpY2F0ZSBsb29wIGJsb2NrIGZvciBkYXRhIHJvd3MuXG5cdFx0XHQgKiAgICAtICoqez1DTEFTU19UT09MVElQfSoqOiBkZWZhdWx0IHRvb2x0aXAgY2xhc3MgbmFtZSBgYmItdG9vbHRpcGAuXG5cdFx0XHQgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcblx0XHRcdCAqICAgIC0gKip7PVRJVExFfSoqOiB0aXRsZSB2YWx1ZS5cblx0XHRcdCAqICAgIC0gKip7PUNPTE9SfSoqOiBkYXRhIGNvbG9yLlxuXHRcdFx0ICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuY29udGVudHMudGV4dD11bmRlZmluZWRdIFNldCBhZGRpdGlvbmFsIHRleHQgY29udGVudCB3aXRoaW4gZGF0YSBsb29wLCB1c2luZyB0ZW1wbGF0ZSBzeW50YXguXG5cdFx0XHQgKiAgLSAqKk5PVEU6KiogSXQgc2hvdWxkIGNvbnRhaW4gYHsga2V5OiBBcnJheSwgLi4uIH1gIHZhbHVlXG5cdFx0XHQgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXG5cdFx0XHQgKiAgICAtIFRoZSB2YWx1ZSBhcnJheSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmluaXQuc2hvdz1mYWxzZV0gU2hvdyB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuaW5pdC5wb3NpdGlvbj17dG9wOiBcIjBweFwiLGxlZnQ6IFwiNTBweFwifV0gU2V0IHRoZSBwb3NpdGlvbiBvZiB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd10gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIHNob3duLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93bl0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZGVuXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cblx0XHRcdCAqICAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXG5cdFx0XHQgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcblx0XHRcdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgZGlzcGxheSBvcmRlcjxicj5cblx0XHRcdCAqICAgICAqKk5PVEU6KiogV2hlbiBgZGF0YS5ncm91cHNgIGlzIHNldCwgdGhlIG9yZGVyIHdpbGwgZm9sbG93IGFzIHRoZSBzdGFja2VkIGdyYXBoIG9yZGVyLjxicj5cblx0XHRcdCAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxuXHRcdFx0ICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogSGlkZSBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5IaWRlVG9vbHRpcClcblx0XHRcdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcblx0XHRcdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgRm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwRm9ybWF0KVxuXHRcdFx0ICogQHNlZSBbRGVtbzogTGlua2VkIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkxpbmtlZFRvb2x0aXBzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICB0b29sdGlwOiB7XG5cdFx0XHQgKiAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIGRvTm90SGlkZTogdHJ1ZSxcblx0XHRcdCAqICAgICAgZ3JvdXBlZDogZmFsc2UsXG5cdFx0XHQgKiAgICAgIGZvcm1hdDoge1xuXHRcdFx0ICogICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFwiRGF0YSBcIiArIHg7IH0sXG5cdFx0XHQgKiAgICAgICAgICBuYW1lOiBmdW5jdGlvbihuYW1lLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiBuYW1lOyB9LFxuXHRcdFx0ICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodCwgZWxlbWVudCkge1xuXHRcdFx0ICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XG4gIFx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG4gIFx0XHRcdCAqICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xuICBcdFx0XHQgKiAgICAgICAgICByZXR1cm4gLi4uIC8vIGZvcm1hdHRlZCBodG1sIGFzIHlvdSB3YW50XG4gICAgXHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyBzcGVjaWZ5IHRvb2x0aXAgY29udGVudHMgdXNpbmcgdGVtcGxhdGVcblx0XHRcdCAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxuXHRcdFx0ICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxuXHRcdFx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPjwvbGk+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj48L2xpPlxuXHRcdFx0ICogICAgICAgLy8gPC91bD5cblx0XHRcdCAqICAgICAgIGNvbnRlbnRzOiB7XG5cdFx0XHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXG5cdFx0XHQgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+PGJyPicgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj48L2xpPicgK1xuXHRcdFx0ICogICAgICBcdFx0J319PC91bD4nXG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyB3aXRoIGFkZGl0aW9uYWwgdGV4dCB2YWx1ZVxuXHRcdFx0ICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XG5cdFx0XHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+Y29tbWVudDE8c3BhbiBzdHlsZT1cImNvbG9yOiMwMGM3M2NcIj5kYXRhMTwvc3Bhbj50ZXh0MTwvbGk+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj5jb21tZW50MjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPnRleHQyPC9saT5cblx0XHRcdCAqICAgICAgIC8vIDwvdWw+XG5cdFx0XHQgKiAgICAgICBjb250ZW50czoge1xuXHRcdFx0ICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxuXHRcdFx0ICogICAgICBcdHRleHQ6IHtcblx0XHRcdCAqICAgICAgXHRcdC8vIGEpICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXG5cdFx0XHQgKiAgICAgIFx0XHQvLyBiKSB0aGUgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxuXHRcdFx0ICogICAgICBcdFx0VkFSMTogW1widGV4dDFcIiwgXCJ0ZXh0MlwiXSxcblx0XHRcdCAqICAgICAgXHRcdFZBUjI6IFtcImNvbW1lbnQxXCIsIFwiY29tbWVudDJcIl0sXG5cdFx0XHQgKiAgICAgIFx0fSxcblx0XHRcdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXG5cdFx0XHQgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj57PVZBUjJ9PGJyPicgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj57PVZBUjF9PC9saT4nICtcblx0XHRcdCAqICAgICAgXHRcdCd9fTwvdWw+J1xuXHRcdFx0ICogICAgICB9XG4gICAgXHRcdCAqXG4gICAgXHRcdCAqICAgICAgLy8gc29ydCB0b29sdGlwIGRhdGEgdmFsdWUgZGlzcGxheSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICBcdFx0ICogICAgICBvcmRlcjogXCJhc2NcIixcbiAgICBcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXG5cdFx0XHQgKiAgICAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxuXHRcdFx0ICogICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn1cblx0XHRcdCAqICAgICAgICAgICAuLi5cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNob3cgYXQgdGhlIGluaXRpYWxpemF0aW9uXG5cdFx0XHQgKiAgICAgIGluaXQ6IHtcblx0XHRcdCAqICAgICAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgICAgICB4OiAyLFxuXHRcdFx0ICogICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICAgICB0b3A6IFwiMTUwcHhcIixcblx0XHRcdCAqICAgICAgICAgICAgICBsZWZ0OiBcIjI1MHB4XCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqICAgICAgb25zaG93OiBmdW5jdGlvbigpIHsgLi4ufSxcblx0XHRcdCAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBoaWRkZW5cblx0XHRcdCAqICAgICAgb25oaWRlOiBmdW5jdGlvbigpIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqICAgICAgb25zaG93bjogZnVuY3Rpb24oKSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIGhpZGRlblxuXHRcdFx0ICogICAgICBvbmhpZGRlbjogZnVuY3Rpb24oKSB7IC4uLiB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcblx0XHRcdCAqICAgICAgLy8gVXNlZnVsIGZvciB0aW1lc2VyaWVzIGNvcnJlbGF0aW9uXG5cdFx0XHQgKiAgICAgIGxpbmtlZDogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIFNwZWNpZnkgbmFtZSB0byBpbnRlcmFjdCB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgb25seS5cblx0XHRcdCAqICAgICAgbGlua2VkOiB7XG5cdFx0XHQgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHR0b29sdGlwX3Nob3c6IHRydWUsXG5cdFx0XHR0b29sdGlwX2RvTm90SGlkZTogZmFsc2UsXG5cdFx0XHR0b29sdGlwX2dyb3VwZWQ6IHRydWUsXG5cdFx0XHR0b29sdGlwX2Zvcm1hdF90aXRsZTogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9mb3JtYXRfbmFtZTogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9mb3JtYXRfdmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdHRvb2x0aXBfcG9zaXRpb246IHVuZGVmaW5lZCxcblx0XHRcdHRvb2x0aXBfY29udGVudHM6IHt9LFxuXHRcdFx0dG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxuXHRcdFx0dG9vbHRpcF9pbml0X3g6IDAsXG5cdFx0XHR0b29sdGlwX2luaXRfcG9zaXRpb246IHtcblx0XHRcdFx0dG9wOiBcIjBweFwiLFxuXHRcdFx0XHRsZWZ0OiBcIjUwcHhcIlxuXHRcdFx0fSxcblx0XHRcdHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcblx0XHRcdHRvb2x0aXBfbGlua2VkX25hbWU6IFwiXCIsXG5cdFx0XHR0b29sdGlwX29uc2hvdzogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29uc2hvd246ICgpID0+IHt9LFxuXHRcdFx0dG9vbHRpcF9vbmhpZGRlbjogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29yZGVyOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aXRsZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSB0aXRsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnRleHRdIFRpdGxlIHRleHQuIElmIGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbGxvd2luZyBtdWx0aWxpbmUgdGl0bGUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcudG9wPTBdIFRvcCBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnJpZ2h0PTBdIFJpZ2h0IHBhZGRpbmcgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcuYm90dG9tPTBdIEJvdHRvbSBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLmxlZnQ9MF0gTGVmdCBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt0aXRsZS5wb3NpdGlvbj1jZW50ZXJdIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiAnY2VudGVyJywgJ3JpZ2h0JyBhbmQgJ2xlZnQnLlxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1RpdGxlLk11bHRpbGluZWRUaXRsZSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgdGl0bGU6IHtcblx0XHRcdCAqICAgICAgdGV4dDogXCJUaXRsZSBUZXh0XCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBNdWx0aWxpbmUgdGl0bGUgdGV4dFxuXHRcdFx0ICogICAgICB0ZXh0OiBcIk1haW4gdGl0bGUgdGV4dFxcblN1YiB0aXRsZSB0ZXh0XCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBwYWRkaW5nOiB7XG5cdFx0XHQgKiAgICAgICAgICB0b3A6IDEwLFxuXHRcdFx0ICogICAgICAgICAgcmlnaHQ6IDEwLFxuXHRcdFx0ICogICAgICAgICAgYm90dG9tOiAxMCxcblx0XHRcdCAqICAgICAgICAgIGxlZnQ6IDEwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHR0aXRsZV90ZXh0OiB1bmRlZmluZWQsXG5cdFx0XHR0aXRsZV9wYWRkaW5nOiB7XG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdGJvdHRvbTogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlX3Bvc2l0aW9uOiBcImNlbnRlclwiXG5cdFx0fTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IE9wdGlvbnMgZnJvbSBcIi4vT3B0aW9uc1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2lzRGVmaW5lZCwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0T3B0aW9ucygpIHtcblx0XHRyZXR1cm4gbmV3IE9wdGlvbnMoKTtcblx0fSxcblxuXHQvKipcblx0ICogTG9hZCBjb25maWd1cmF0aW9uIG9wdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFVzZXIncyBnZW5lcmF0aW9uIGNvbmZpZyB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0bG9hZENvbmZpZyhjb25maWcpIHtcblx0XHRjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0bGV0IHRhcmdldDtcblx0XHRsZXQga2V5cztcblx0XHRsZXQgcmVhZDtcblxuXHRcdGNvbnN0IGZpbmQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBrZXkgPSBrZXlzLnNoaWZ0KCk7XG5cblx0XHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XG5cdFx0XHRcdHJldHVybiBmaW5kKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0T2JqZWN0LmtleXModGhpc0NvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0dGFyZ2V0ID0gY29uZmlnO1xuXHRcdFx0a2V5cyA9IGtleS5zcGxpdChcIl9cIik7XG5cdFx0XHRyZWFkID0gZmluZCgpO1xuXG5cdFx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XG5cdFx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxuXHRzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyXG59IGZyb20gXCJkMy1zY2FsZVwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdldFNjYWxlKG1pbiwgbWF4LCBmb3JUaW1lc2VyaWVzKSB7XG5cdFx0cmV0dXJuIChmb3JUaW1lc2VyaWVzID9cblx0XHRcdGQzU2NhbGVUaW1lKCkgOiBkM1NjYWxlTGluZWFyKClcblx0XHQpLnJhbmdlKFttaW4sIG1heF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgeCBBeGlzIHNjYWxlIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldCBUaGUgb2Zmc2V0IGdldHRlciB0byBiZSBzdW1cblx0ICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRYKG1pbiwgbWF4LCBkb21haW4sIG9mZnNldCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzY2FsZSA9ICQkLnpvb21TY2FsZSB8fCAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuaXNUaW1lU2VyaWVzKCkpO1xuXG5cdFx0cmV0dXJuICQkLmdldEN1c3RvbWl6ZWRTY2FsZShcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXG5cdFx0XHRvZmZzZXRcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2FsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0WShtaW4sIG1heCwgZG9tYWluKSB7XG5cdFx0Y29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKG1pbiwgbWF4LCB0aGlzLmlzVGltZVNlcmllc1koKSk7XG5cblx0XHRkb21haW4gJiYgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cblx0XHRyZXR1cm4gc2NhbGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjdXN0b21pemVkIHNjYWxlXG5cdCAqIEBwYXJhbSB7ZDMuc2NhbGVMaW5lYXJ8ZDMuc2NhbGVUaW1lfSBzY2FsZVZhbHVlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldFZhbHVlIE9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXG5cdCAqIEByZXR1cm4ge30gc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEN1c3RvbWl6ZWRTY2FsZShzY2FsZVZhbHVlLCBvZmZzZXRWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQueEF4aXMudGlja09mZnNldCgpKTtcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xuXHRcdFx0Y29uc3QgdiA9IHNjYWxlVmFsdWUoZCkgKyBvZmZzZXQoKTtcblxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XG5cdFx0fTtcblxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xuXHRcdGZvciAoY29uc3Qga2V5IGluIHNjYWxlVmFsdWUpIHtcblx0XHRcdHNjYWxlW2tleV0gPSBzY2FsZVZhbHVlW2tleV07XG5cdFx0fVxuXG5cdFx0c2NhbGUub3JnRG9tYWluID0gKCkgPT4gc2NhbGVWYWx1ZS5kb21haW4oKTtcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XG5cblx0XHQvLyBkZWZpbmUgY3VzdG9tIGRvbWFpbigpIGZvciBjYXRlZ29yaXplZCBheGlzXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0c2NhbGUuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluVmFsdWUpIHtcblx0XHRcdFx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xuXG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbWFpbiA9IHRoaXMub3JnRG9tYWluKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gW2RvbWFpblswXSwgZG9tYWluWzFdICsgMV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY2FsZVZhbHVlLmRvbWFpbihkb21haW4pO1xuXG5cdFx0XHRcdHJldHVybiBzY2FsZTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNjYWxlO1xuXHR9LFxuXG5cdGdldFlTY2FsZShpZCkge1xuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnkyIDogdGhpcy55O1xuXHR9LFxuXG5cdGdldFN1YllTY2FsZShpZCkge1xuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnN1YlkyIDogdGhpcy5zdWJZO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgLSBwYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcblx0ICovXG5cdHVwZGF0ZVNjYWxlcyhpc0luaXQsIHVwZGF0ZVhEb21haW4gPSB0cnVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Ly8gdXBkYXRlIGVkZ2VzXG5cdFx0JCQueE1pbiA9IGlzUm90YXRlZCA/IDEgOiAwO1xuXHRcdCQkLnhNYXggPSBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcblx0XHQkJC55TWluID0gaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodDtcblx0XHQkJC55TWF4ID0gaXNSb3RhdGVkID8gJCQud2lkdGggOiAxO1xuXHRcdCQkLnN1YlhNaW4gPSAkJC54TWluO1xuXHRcdCQkLnN1YlhNYXggPSAkJC54TWF4O1xuXHRcdCQkLnN1YllNaW4gPSBpc1JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0Mjtcblx0XHQkJC5zdWJZTWF4ID0gaXNSb3RhdGVkID8gJCQud2lkdGgyIDogMTtcblxuXHRcdC8vIHVwZGF0ZSBzY2FsZXNcblx0XHQvLyB4IEF4aXNcblx0XHRjb25zdCB4RG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiAkJC54ICYmICQkLngub3JnRG9tYWluKCk7XG5cdFx0Y29uc3QgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgJCQub3JnWERvbWFpbjtcblxuXHRcdCQkLnggPSAkJC5nZXRYKCQkLnhNaW4sICQkLnhNYXgsIHhEb21haW4sICgpID0+ICQkLnhBeGlzLnRpY2tPZmZzZXQoKSk7XG5cdFx0JCQuc3ViWCA9ICQkLmdldFgoJCQueE1pbiwgJCQueE1heCwgeFN1YkRvbWFpbiwgZCA9PiAoZCAlIDEgPyAwIDogJCQuc3ViWEF4aXMudGlja09mZnNldCgpKSk7XG5cblx0XHQkJC54QXhpc1RpY2tGb3JtYXQgPSAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpO1xuXHRcdCQkLnhBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0VGlja1ZhbHVlcyhcInhcIik7XG5cblx0XHQkJC54QXhpcyA9ICQkLmF4aXNcblx0XHRcdC5nZXRBeGlzKFwieFwiLCAkJC54LCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XG5cblx0XHQkJC5zdWJYQXhpcyA9ICQkLmF4aXNcblx0XHRcdC5nZXRBeGlzKFwic3ViWFwiLCAkJC5zdWJYLCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XG5cblx0XHQvLyB5IEF4aXNcblx0XHQkJC55ID0gJCQuZ2V0WSgkJC55TWluLCAkJC55TWF4LCAkJC55ID8gJCQueS5kb21haW4oKSA6IGNvbmZpZy5heGlzX3lfZGVmYXVsdCk7XG5cdFx0JCQuc3ViWSA9ICQkLmdldFkoJCQuc3ViWU1pbiwgJCQuc3ViWU1heCwgJCQuc3ViWSA/ICQkLnN1YlkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xuXG5cdFx0JCQueUF4aXNUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRUaWNrVmFsdWVzKFwieVwiKTtcblxuXHRcdCQkLnlBeGlzID0gJCQuYXhpc1xuXHRcdFx0LmdldEF4aXMoXCJ5XCIsICQkLnksIGNvbmZpZy5heGlzX3lfdGlja19vdXRlciwgaXNJbml0KTtcblxuXHRcdC8vIHkyIEF4aXNcblx0XHRpZiAoY29uZmlnLmF4aXNfeTJfc2hvdykge1xuXHRcdFx0JCQueTIgPSAkJC5nZXRZKCQkLnlNaW4sICQkLnlNYXgsICQkLnkyID8gJCQueTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcblx0XHRcdCQkLnN1YlkyID0gJCQuZ2V0WSgkJC5zdWJZTWluLCAkJC5zdWJZTWF4LFxuXHRcdFx0XHQkJC5zdWJZMiA/ICQkLnN1YlkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XG5cblx0XHRcdCQkLnkyQXhpc1RpY2tWYWx1ZXMgPSAkJC5heGlzLmdldFRpY2tWYWx1ZXMoXCJ5MlwiKTtcblxuXHRcdFx0JCQueTJBeGlzID0gJCQuYXhpc1xuXHRcdFx0XHQuZ2V0QXhpcyhcInkyXCIsICQkLnkyLCBjb25maWcuYXhpc195Ml90aWNrX291dGVyLCBpc0luaXQpO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBmb3IgYXJjXG5cdFx0JCQudXBkYXRlQXJjICYmICQkLnVwZGF0ZUFyYygpO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgYnJ1c2hFbXB0eSwgZ2V0QnJ1c2hTZWxlY3Rpb24sIGdldE1pbk1heCwgaXNEZWZpbmVkLCBub3RFbXB0eSwgaXNWYWx1ZSwgaXNPYmplY3QsIGlzTnVtYmVyLCBkaWZmRG9tYWluLCBzb3J0VmFsdWV9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNNaW4gPSB0eXBlID09PSBcIm1pblwiO1xuXG5cdFx0Y29uc3QgZGF0YUdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwcztcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKTtcblx0XHRjb25zdCB5cyA9ICQkLmdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKTtcblxuXHRcdGlmIChkYXRhR3JvdXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGhhc1ZhbHVlID0gJCRbYGhhcyR7aXNNaW4gPyBcIk5lZ2F0aXZlXCIgOiBcIlBvc2l0aXZlXCJ9VmFsdWVJblRhcmdldHNgXSh0YXJnZXRzKTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGlkc0luR3JvdXA7IChpZHNJbkdyb3VwID0gZGF0YUdyb3Vwc1tqXSk7IGorKykge1xuXHRcdFx0XHQvLyBEZXRlcm1pbmUgYmFzZUlkXG5cdFx0XHRcdGlkc0luR3JvdXAgPSBpZHNJbkdyb3VwLmZpbHRlcih2ID0+IGlkcy5pbmRleE9mKHYpID49IDApO1xuXG5cdFx0XHRcdGlmIChpZHNJbkdyb3VwLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgYmFzZUlkID0gaWRzSW5Hcm91cFswXTtcblx0XHRcdFx0Y29uc3QgYmFzZUF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKTtcblxuXHRcdFx0XHQvLyBJbml0aWFsaXplIGJhc2UgdmFsdWUuIFNldCB0byAwIGlmIG5vdCBtYXRjaCB3aXRoIHRoZSBjb25kaXRpb25cblx0XHRcdFx0aWYgKGhhc1ZhbHVlICYmIHlzW2Jhc2VJZF0pIHtcblx0XHRcdFx0XHR5c1tiYXNlSWRdID0geXNbYmFzZUlkXS5tYXAodiA9PiAoXG5cdFx0XHRcdFx0XHQoaXNNaW4gPyB2IDwgMCA6IHYgPiAwKSA/IHYgOiAwXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBrID0gMSwgaWQ7IChpZCA9IGlkc0luR3JvdXBba10pOyBrKyspIHtcblx0XHRcdFx0XHRpZiAoIXlzW2lkXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgYXhpc0lkID0gJCQuYXhpcy5nZXRJZChpZCk7XG5cblx0XHRcdFx0XHR5c1tpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsID0gK3Y7XG5cdFx0XHRcdFx0XHRjb25zdCBtZWV0Q29uZGl0aW9uID0gaXNNaW4gPyB2YWwgPiAwIDogdmFsIDwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKGF4aXNJZCA9PT0gYmFzZUF4aXNJZCAmJiAhKGhhc1ZhbHVlICYmIG1lZXRDb25kaXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdHlzW2Jhc2VJZF1baV0gKz0gdmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdldE1pbk1heCh0eXBlLCBPYmplY3Qua2V5cyh5cykubWFwKGtleSA9PiBnZXRNaW5NYXgodHlwZSwgeXNba2V5XSkpKTtcblx0fSxcblxuXHRnZXRZRG9tYWluTWluKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuXHR9LFxuXG5cdGdldFlEb21haW5NYXgodGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XG5cdH0sXG5cblx0Z2V0WURvbWFpbih0YXJnZXRzLCBheGlzSWQsIHhEb21haW4pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHtcblx0XHRcdHJldHVybiBbMCwgMTAwXTtcblx0XHR9XG5cblx0XHRjb25zdCB0YXJnZXRzQnlBeGlzSWQgPSB0YXJnZXRzLmZpbHRlcih0ID0+ICQkLmF4aXMuZ2V0SWQodC5pZCkgPT09IGF4aXNJZCk7XG5cdFx0Y29uc3QgeVRhcmdldHMgPSB4RG9tYWluID8gJCQuZmlsdGVyQnlYRG9tYWluKHRhcmdldHNCeUF4aXNJZCwgeERvbWFpbikgOiB0YXJnZXRzQnlBeGlzSWQ7XG5cdFx0Y29uc3QgeU1pbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fbWluYF07XG5cdFx0Y29uc3QgeU1heCA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fbWF4YF07XG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcblx0XHRsZXQgeURvbWFpbk1heCA9ICQkLmdldFlEb21haW5NYXgoeVRhcmdldHMpO1xuXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9jZW50ZXJgXTtcblx0XHRsZXQgaXNaZXJvQmFzZWQgPSAoJCQuaGFzVHlwZShcImJhclwiLCB5VGFyZ2V0cykgJiYgY29uZmlnLmJhcl96ZXJvYmFzZWQpIHx8ICgkJC5oYXNUeXBlKFwiYXJlYVwiLCB5VGFyZ2V0cykgJiYgY29uZmlnLmFyZWFfemVyb2Jhc2VkKTtcblx0XHRjb25zdCBpc0ludmVydGVkID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9pbnZlcnRlZGBdO1xuXHRcdGNvbnN0IHNob3dIb3Jpem9udGFsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBzaG93VmVydGljYWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiAhY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIE1FTU86IGF2b2lkIGludmVydGluZyBkb21haW4gdW5leHBlY3RlZGx5XG5cdFx0eURvbWFpbk1pbiA9IGlzVmFsdWUoeU1pbikgPyB5TWluIDpcblx0XHRcdChpc1ZhbHVlKHlNYXgpID8gKHlEb21haW5NaW4gPCB5TWF4ID8geURvbWFpbk1pbiA6IHlNYXggLSAxMCkgOiB5RG9tYWluTWluKTtcblx0XHR5RG9tYWluTWF4ID0gaXNWYWx1ZSh5TWF4KSA/IHlNYXggOlxuXHRcdFx0KGlzVmFsdWUoeU1pbikgPyAoeU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwKSA6IHlEb21haW5NYXgpO1xuXG5cdFx0aWYgKHlUYXJnZXRzLmxlbmd0aCA9PT0gMCkgeyAvLyB1c2UgY3VycmVudCBkb21haW4gaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXG5cdFx0XHRyZXR1cm4gJCRbYXhpc0lkXS5kb21haW4oKTtcblx0XHR9XG5cblx0XHRpZiAoaXNOYU4oeURvbWFpbk1pbikpIHsgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcblx0XHRcdHlEb21haW5NaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChpc05hTih5RG9tYWluTWF4KSkgeyAvLyBzZXQgbWF4aW11bSB0byBoYXZlIHNhbWUgdmFsdWUgYXMgeURvbWFpbk1pblxuXHRcdFx0eURvbWFpbk1heCA9IHlEb21haW5NaW47XG5cdFx0fVxuXG5cdFx0aWYgKHlEb21haW5NaW4gPT09IHlEb21haW5NYXgpIHtcblx0XHRcdHlEb21haW5NaW4gPCAwID8geURvbWFpbk1heCA9IDAgOiB5RG9tYWluTWluID0gMDtcblx0XHR9XG5cblx0XHRjb25zdCBpc0FsbFBvc2l0aXZlID0geURvbWFpbk1pbiA+PSAwICYmIHlEb21haW5NYXggPj0gMDtcblx0XHRjb25zdCBpc0FsbE5lZ2F0aXZlID0geURvbWFpbk1pbiA8PSAwICYmIHlEb21haW5NYXggPD0gMDtcblxuXHRcdC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXG5cdFx0aWYgKChpc1ZhbHVlKHlNaW4pICYmIGlzQWxsUG9zaXRpdmUpIHx8IChpc1ZhbHVlKHlNYXgpICYmIGlzQWxsTmVnYXRpdmUpKSB7XG5cdFx0XHRpc1plcm9CYXNlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAoeURvbWFpbk1pbiA9IDApO1xuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAoeURvbWFpbk1heCA9IDApO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKTtcblx0XHRjb25zdCBwYWRkaW5nID0ge3RvcDogZG9tYWluTGVuZ3RoICogMC4xLCBib3R0b206IGRvbWFpbkxlbmd0aCAqIDAuMX07XG5cblx0XHRpZiAoaXNEZWZpbmVkKGNlbnRlcikpIHtcblx0XHRcdGNvbnN0IHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xuXG5cdFx0XHR5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcblx0XHRcdHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xuXHRcdH1cblxuXHRcdC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXG5cdFx0aWYgKHNob3dIb3Jpem9udGFsRGF0YUxhYmVsKSB7XG5cdFx0XHRjb25zdCBkaWZmID0gZGlmZkRvbWFpbigkJC55LnJhbmdlKCkpO1xuXHRcdFx0Y29uc3QgcmF0aW8gPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJ3aWR0aFwiKVxuXHRcdFx0XHQubWFwKHYgPT4gdiAvIGRpZmYpO1xuXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRwYWRkaW5nW3ZdICs9IGRvbWFpbkxlbmd0aCAqIChyYXRpb1tpXSAvICgxIC0gcmF0aW9bMF0gLSByYXRpb1sxXSkpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcblx0XHRcdGNvbnN0IGxlbmd0aHMgPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJoZWlnaHRcIik7XG5cblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdHBhZGRpbmdbdl0gKz0gJCQuYXhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhsZW5ndGhzW2ldLCBkb21haW5MZW5ndGgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKC9eeTI/JC8udGVzdChheGlzSWQpKSB7XG5cdFx0XHRjb25zdCBwID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9wYWRkaW5nYF07XG5cblx0XHRcdGlmIChub3RFbXB0eShwKSkge1xuXHRcdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRwYWRkaW5nW3ZdID0gJCQuYXhpcy5nZXRQYWRkaW5nKHAsIHYsIHBhZGRpbmdbdl0sIGRvbWFpbkxlbmd0aCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xuXHRcdFx0aXNBbGxQb3NpdGl2ZSAmJiAocGFkZGluZy5ib3R0b20gPSB5RG9tYWluTWluKTtcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHBhZGRpbmcudG9wID0gLXlEb21haW5NYXgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbiA9IFt5RG9tYWluTWluIC0gcGFkZGluZy5ib3R0b20sIHlEb21haW5NYXggKyBwYWRkaW5nLnRvcF07XG5cblx0XHRyZXR1cm4gaXNJbnZlcnRlZCA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XG5cdH0sXG5cblx0Z2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHZhbHVlID0gJCQuY29uZmlnW2BheGlzX3hfJHt0eXBlfWBdO1xuXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgP1xuXHRcdFx0KCQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKHZhbHVlKSA6IHZhbHVlKSA6XG5cdFx0XHRnZXRNaW5NYXgodHlwZSwgdGFyZ2V0cy5tYXAodCA9PiBnZXRNaW5NYXgodHlwZSwgdC52YWx1ZXMubWFwKHYgPT4gdi54KSkpKTtcblx0fSxcblxuXHRnZXRYRG9tYWluTWluKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xuXHR9LFxuXG5cdGdldFhEb21haW5NYXgodGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XG5cdH0sXG5cblx0Z2V0WERvbWFpblBhZGRpbmcoZG9tYWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuXHRcdGNvbnN0IHhQYWRkaW5nID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xuXHRcdGxldCBtYXhEYXRhQ291bnQ7XG5cdFx0bGV0IHBhZGRpbmc7XG5cblx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cdFx0XHRwYWRkaW5nID0gMDtcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcblx0XHRcdG1heERhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYWRkaW5nID0gZGlmZiAqIDAuMDE7XG5cdFx0fVxuXG5cdFx0bGV0IGxlZnQgPSBwYWRkaW5nO1xuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XG5cblx0XHRpZiAoaXNPYmplY3QoeFBhZGRpbmcpICYmIG5vdEVtcHR5KHhQYWRkaW5nKSkge1xuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcblx0XHRcdHJpZ2h0ID0gaXNWYWx1ZSh4UGFkZGluZy5yaWdodCkgPyB4UGFkZGluZy5yaWdodCA6IHBhZGRpbmc7XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihjb25maWcuYXhpc194X3BhZGRpbmcpKSB7XG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XG5cdFx0XHRyaWdodCA9IHhQYWRkaW5nO1xuXHRcdH1cblxuXHRcdHJldHVybiB7bGVmdCwgcmlnaHR9O1xuXHR9LFxuXG5cdGdldFhEb21haW4odGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB4RG9tYWluID0gWyQkLmdldFhEb21haW5NaW4odGFyZ2V0cyksICQkLmdldFhEb21haW5NYXgodGFyZ2V0cyldO1xuXHRcdGxldCBmaXJzdFggPSB4RG9tYWluWzBdO1xuXHRcdGxldCBsYXN0WCA9IHhEb21haW5bMV07XG5cdFx0Y29uc3QgcGFkZGluZyA9ICQkLmdldFhEb21haW5QYWRkaW5nKHhEb21haW4pO1xuXHRcdGxldCBtaW4gPSAwO1xuXHRcdGxldCBtYXggPSAwO1xuXG5cdFx0Ly8gc2hvdyBjZW50ZXIgb2YgeCBkb21haW4gaWYgbWluIGFuZCBtYXggYXJlIHRoZSBzYW1lXG5cdFx0aWYgKChmaXJzdFggLSBsYXN0WCkgPT09IDAgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdGZpcnN0WCA9IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgKiAwLjUpO1xuXHRcdFx0XHRsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdFggPSBmaXJzdFggPT09IDAgPyAxIDogKGZpcnN0WCAqIDAuNSk7XG5cdFx0XHRcdGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IChsYXN0WCAqIDEuNSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZpcnN0WCB8fCBmaXJzdFggPT09IDApIHtcblx0XHRcdG1pbiA9ICQkLmlzVGltZVNlcmllcygpID8gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAtIHBhZGRpbmcubGVmdCkgOiBmaXJzdFggLSBwYWRkaW5nLmxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKGxhc3RYIHx8IGxhc3RYID09PSAwKSB7XG5cdFx0XHRtYXggPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSArIHBhZGRpbmcucmlnaHQpIDogbGFzdFggKyBwYWRkaW5nLnJpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBbbWluLCBtYXhdO1xuXHR9LFxuXG5cdHVwZGF0ZVhEb21haW4odGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XG5cblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcblx0XHRcdCQkLnguZG9tYWluKGRvbWFpbiB8fCBzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpO1xuXHRcdFx0JCQub3JnWERvbWFpbiA9ICQkLnguZG9tYWluKCk7XG5cblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcblxuXHRcdFx0JCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZSgkJC5zdWJYKTtcblx0XHR9XG5cblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcblx0XHRcdGNvbnN0IGRvbWFpblZhbHVlID0gZG9tYWluIHx8ICghJCQuYnJ1c2ggfHwgYnJ1c2hFbXB0eSgkJCkpID9cblx0XHRcdFx0JCQub3JnWERvbWFpbiA6IGdldEJydXNoU2VsZWN0aW9uKCQkKS5tYXAoJCQuc3ViWC5pbnZlcnQpO1xuXG5cdFx0XHQkJC54LmRvbWFpbihkb21haW5WYWx1ZSk7XG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpbSBkb21haW4gd2hlbiB0b28gYmlnIGJ5IHpvb20gbW91c2Vtb3ZlIGV2ZW50XG5cdFx0d2l0aFRyaW0gJiYgJCQueC5kb21haW4oJCQudHJpbVhEb21haW4oJCQueC5vcmdEb21haW4oKSkpO1xuXG5cdFx0cmV0dXJuICQkLnguZG9tYWluKCk7XG5cdH0sXG5cblx0dHJpbVhEb21haW4oZG9tYWluKSB7XG5cdFx0Y29uc3Qgem9vbURvbWFpbiA9IHRoaXMuZ2V0Wm9vbURvbWFpbigpO1xuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xuXG5cdFx0aWYgKGRvbWFpblswXSA8PSBtaW4pIHtcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcblx0XHRcdGRvbWFpblswXSA9IG1pbjtcblx0XHR9XG5cblx0XHRpZiAobWF4IDw9IGRvbWFpblsxXSkge1xuXHRcdFx0ZG9tYWluWzBdID0gK2RvbWFpblswXSAtIChkb21haW5bMV0gLSBtYXgpO1xuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xuXHRcdH1cblxuXHRcdHJldHVybiBkb21haW47XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtcblx0ZXh0ZW5kLFxuXHRnZXRVbmlxdWUsXG5cdGhhc1ZhbHVlLFxuXHRpc0FycmF5LFxuXHRpc0Jvb2xlYW4sXG5cdGlzRGVmaW5lZCxcblx0aXNGdW5jdGlvbixcblx0aXNOdW1iZXIsXG5cdGlzT2JqZWN0LFxuXHRpc09iamVjdFR5cGUsXG5cdGlzU3RyaW5nLFxuXHRpc1VuZGVmaW5lZCxcblx0aXNWYWx1ZSxcblx0bm90RW1wdHksXG5cdG1lcmdlQXJyYXksXG5cdHNvcnRWYWx1ZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGlzWChrZXkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcblx0XHRjb25zdCBleGlzdFZhbHVlID0gbm90RW1wdHkoY29uZmlnLmRhdGFfeHMpICYmIGhhc1ZhbHVlKGNvbmZpZy5kYXRhX3hzLCBrZXkpO1xuXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcblx0fSxcblxuXHRpc05vdFgoa2V5KSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzWChrZXkpO1xuXHR9LFxuXG5cdGlzU3RhY2tOb3JtYWxpemVkKCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xuXHR9LFxuXG5cdGlzR3JvdXBlZChpZCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xuXHRcdFx0Lm1hcCh2ID0+IHYuaW5kZXhPZihpZCkgPj0gMClbMF07XG5cdH0sXG5cblx0Z2V0WEtleShpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gY29uZmlnLmRhdGFfeCA/XG5cdFx0XHRjb25maWcuZGF0YV94IDogKG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSA/IGNvbmZpZy5kYXRhX3hzW2lkXSA6IG51bGwpO1xuXHR9LFxuXG5cdGdldFhWYWx1ZXNPZlhLZXkoa2V5LCB0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlkcyA9IHRhcmdldHMgJiYgbm90RW1wdHkodGFyZ2V0cykgPyAkJC5tYXBUb0lkcyh0YXJnZXRzKSA6IFtdO1xuXHRcdGxldCB4VmFsdWVzO1xuXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0aWYgKCQkLmdldFhLZXkoaWQpID09PSBrZXkpIHtcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHhWYWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBpbmRleCBudW1iZXIgYmFzZWQgb24gZ2l2ZW4geCBBeGlzIHZhbHVlXG5cdCAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8U3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlZFggeCBBeGlzIGxpc3QgdG8gYmUgYmFzZWQgb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBpbmRleCBudW1iZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEluZGV4QnlYKHgsIGJhc2VkWCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBiYXNlZFggP1xuXHRcdFx0YmFzZWRYLmluZGV4T2YoaXNTdHJpbmcoeCkgPyB4IDogK3gpIDpcblx0XHRcdCgkJC5maWx0ZXJCeVgoJCQuZGF0YS50YXJnZXRzLCB4KVswXSB8fCB7aW5kZXg6IG51bGx9KS5pbmRleDtcblx0fSxcblxuXHRnZXRYVmFsdWUoaWQsIGkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gaWQgaW4gJCQuZGF0YS54cyAmJlxuXHRcdFx0JCQuZGF0YS54c1tpZF0gJiZcblx0XHRcdGlzVmFsdWUoJCQuZGF0YS54c1tpZF1baV0pID8gJCQuZGF0YS54c1tpZF1baV0gOiBpO1xuXHR9LFxuXG5cdGdldE90aGVyVGFyZ2V0WHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlkc0ZvclggPSBPYmplY3Qua2V5cygkJC5kYXRhLnhzKTtcblxuXHRcdHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xuXHR9LFxuXG5cdGdldE90aGVyVGFyZ2V0WChpbmRleCkge1xuXHRcdGNvbnN0IHhzID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XG5cblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xuXHR9LFxuXG5cdGFkZFhzKHhzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0T2JqZWN0LmtleXMoeHMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0JCQuY29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc011bHRpcGxlWCh4cykge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh4cykubWFwKGlkID0+IHhzW2lkXSkubGVuZ3RoID4gMTtcblx0fSxcblxuXHRpc011bHRpcGxlWCgpIHtcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcblx0XHRcdCF0aGlzLmNvbmZpZy5kYXRhX3hTb3J0IHx8XG5cdFx0XHR0aGlzLmhhc1R5cGUoXCJidWJibGVcIikgfHxcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XG5cdH0sXG5cblx0YWRkTmFtZShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBuYW1lO1xuXG5cdFx0aWYgKGRhdGEpIHtcblx0XHRcdG5hbWUgPSAkJC5jb25maWcuZGF0YV9uYW1lc1tkYXRhLmlkXTtcblx0XHRcdGRhdGEubmFtZSA9IG5hbWUgIT09IHVuZGVmaW5lZCA/IG5hbWUgOiBkYXRhLmlkO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXG5cdFx0XHQubWFwKHQgPT4gJCQuYWRkTmFtZSgkJC5nZXRWYWx1ZU9uSW5kZXgodC52YWx1ZXMsIGluZGV4KSkpO1xuXHR9LFxuXG5cdGdldFZhbHVlT25JbmRleCh2YWx1ZXMsIGluZGV4KSB7XG5cdFx0Y29uc3QgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcih2ID0+IHYuaW5kZXggPT09IGluZGV4KTtcblxuXHRcdHJldHVybiB2YWx1ZU9uSW5kZXgubGVuZ3RoID8gdmFsdWVPbkluZGV4WzBdIDogbnVsbDtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRYKHRhcmdldHMsIHgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdHYueCA9ICQkLmdlbmVyYXRlVGFyZ2V0WCh4W2ldLCB0LmlkLCBpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdID0geDtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRYcyh0YXJnZXRzLCB4cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpbmRleCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgeCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSA/IGluZGV4IDogKHJhd1ggfHwgaW5kZXgpO1xuXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHR4ID0gcmF3WCA/ICQkLnBhcnNlRGF0ZShyYXdYKSA6ICQkLnBhcnNlRGF0ZSgkJC5nZXRYVmFsdWUoaWQsIGluZGV4KSk7XG5cdFx0fSBlbHNlIGlmICgkJC5pc0N1c3RvbVgoKSAmJiAhJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH0sXG5cblx0Y2xvbmVUYXJnZXQodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiB0YXJnZXQuaWQsXG5cdFx0XHRpZF9vcmc6IHRhcmdldC5pZF9vcmcsXG5cdFx0XHR2YWx1ZXM6IHRhcmdldC52YWx1ZXMubWFwKGQgPT4gKHt4OiBkLngsIHZhbHVlOiBkLnZhbHVlLCBpZDogZC5pZH0pKVxuXHRcdH07XG5cdH0sXG5cblx0dXBkYXRlWHModmFsdWVzKSB7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UHJldlgoaSkge1xuXHRcdGNvbnN0IHggPSB0aGlzLnhzW2kgLSAxXTtcblxuXHRcdHJldHVybiBpc0RlZmluZWQoeCkgPyB4IDogbnVsbDtcblx0fSxcblxuXHRnZXROZXh0WChpKSB7XG5cdFx0Y29uc3QgeCA9IHRoaXMueHNbaSArIDFdO1xuXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYmFzZSB2YWx1ZSBpc0FyZWFSYW5nZVR5cGVcblx0ICogQHBhcmFtIGRhdGEgRGF0YSBvYmplY3Rcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0QmFzZVZhbHVlKGRhdGEpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHZhbHVlID0gZGF0YS52YWx1ZTtcblxuXHRcdC8vIEluIGNhc2Ugb2YgYXJlYS1yYW5nZSwgZGF0YSBpcyBnaXZlbiBhczogW2xvdywgbWlkLCBoaWdoXSBvciB7bG93LCBtaWQsIGhpZ2h9XG5cdFx0Ly8gd2lsbCB0YWtlIHRoZSAnbWlkJyBhcyB0aGUgYmFzZSB2YWx1ZVxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShkYXRhKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUoZGF0YSkpIHtcblx0XHRcdFx0dmFsdWUgPSAkJC5nZXRCdWJibGVaRGF0YSh2YWx1ZSwgXCJ5XCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBhcnJheSBkYXRhIHRvIGJlIGV2YWx1YXRlZFxuXHQgKiBAcmV0dXJuIHt7bWluOiB7TnVtYmVyfSwgbWF4OiB7TnVtYmVyfX19XG5cdCAqL1xuXHRnZXRNaW5NYXhWYWx1ZShkYXRhKSB7XG5cdFx0Y29uc3QgZ2V0QmFzZVZhbHVlID0gdGhpcy5nZXRCYXNlVmFsdWUuYmluZCh0aGlzKTtcblx0XHRsZXQgbWluO1xuXHRcdGxldCBtYXg7XG5cblx0XHQoZGF0YSB8fCB0aGlzLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpXG5cdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYubWFwKGdldEJhc2VWYWx1ZSkuZmlsdGVyKGlzTnVtYmVyKTtcblxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihpID8gbWluIDogSW5maW5pdHksIC4uLnZhbHVlKTtcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXgoaSA/IG1heCA6IC1JbmZpbml0eSwgLi4udmFsdWUpO1xuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4ge21pbiwgbWF4fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBtaW4vbWF4IGRhdGFcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybiB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxuXHQgKi9cblx0Z2V0TWluTWF4RGF0YSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiRtaW5NYXhEYXRhXCI7XG5cdFx0bGV0IG1pbk1heERhdGEgPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRpZiAoIW1pbk1heERhdGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSAkJC5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpO1xuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSk7XG5cblx0XHRcdGxldCBtaW4gPSBbXTtcblx0XHRcdGxldCBtYXggPSBbXTtcblxuXHRcdFx0ZGF0YS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBtaW5EYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWluKTtcblx0XHRcdFx0Y29uc3QgbWF4RGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1heCk7XG5cblx0XHRcdFx0aWYgKG1pbkRhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bWluID0gbWluLmNvbmNhdChtaW5EYXRhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXhEYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRcdG1heCA9IG1heC5jb25jYXQobWF4RGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXG5cdFx0XHQkJC5hZGRDYWNoZShjYWNoZUtleSwgbWluTWF4RGF0YSA9IHttaW4sIG1heH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBtaW5NYXhEYXRhO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgc3VtIG9mIGRhdGEgcGVyIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0Z2V0VG90YWxQZXJJbmRleCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiR0b3RhbFBlckluZGV4XCI7XG5cdFx0bGV0IHN1bSA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpICYmICFzdW0pIHtcblx0XHRcdHN1bSA9IFtdO1xuXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChyb3cgPT4ge1xuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRpZiAoIXN1bVtpXSkge1xuXHRcdFx0XHRcdFx0c3VtW2ldID0gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdW1baV0gKz0gaXNOdW1iZXIodi52YWx1ZSkgPyB2LnZhbHVlIDogMDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdG90YWwgZGF0YSBzdW1cblx0ICogQHJldHVybiB7TnVtYmVyfVxuIFx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFRvdGFsRGF0YVN1bSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiR0b3RhbERhdGFTdW1cIjtcblx0XHRsZXQgdG90YWxEYXRhU3VtID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0aWYgKCF0b3RhbERhdGFTdW0pIHtcblx0XHRcdGNvbnN0IHRvdGFsID0gbWVyZ2VBcnJheSgkJC5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxuXHRcdFx0XHQubWFwKHYgPT4gdi52YWx1ZSlcblx0XHRcdFx0LnJlZHVjZSgocCwgYykgPT4gcCArIGMpO1xuXG5cdFx0XHQkJC5hZGRDYWNoZShjYWNoZUtleSwgdG90YWxEYXRhU3VtID0gdG90YWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0b3RhbERhdGFTdW07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xuXHRcdHJldHVybiBkYXRhLmZpbHRlcih0ID0+IHRoaXMuZ2V0QmFzZVZhbHVlKHQpID09PSB2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgZGF0YVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heCBkYXRhIGxlbmd0aFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TWF4RGF0YUNvdW50KCkge1xuXHRcdHJldHVybiBNYXRoLm1heCguLi50aGlzLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcy5sZW5ndGgpKTtcblx0fSxcblxuXHRnZXRNYXhEYXRhQ291bnRUYXJnZXQoKSB7XG5cdFx0bGV0IHRhcmdldCA9IHRoaXMuZmlsdGVyVGFyZ2V0c1RvU2hvdygpIHx8IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG5cblx0XHRpZiAobGVuZ3RoID4gMSkge1xuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxuXHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSlcblx0XHRcdFx0Lm1hcCh2ID0+IHYueCk7XG5cblx0XHRcdHRhcmdldCA9IHNvcnRWYWx1ZShnZXRVbmlxdWUodGFyZ2V0KSlcblx0XHRcdFx0Lm1hcCgoeCwgaW5kZXgpID0+ICh7eCwgaW5kZXh9KSk7XG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcblx0XHRcdHRhcmdldCA9IHRhcmdldFswXS52YWx1ZXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHRtYXBUb0lkcyh0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKGQgPT4gZC5pZCk7XG5cdH0sXG5cblx0bWFwVG9UYXJnZXRJZHMoaWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGlkcyA/IChpc0FycmF5KGlkcykgPyBpZHMuY29uY2F0KCkgOiBbaWRzXSkgOiAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xuXHR9LFxuXG5cdGhhc1RhcmdldCh0YXJnZXRzLCBpZCkge1xuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgdmFsOyAodmFsID0gaWRzW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNUYXJnZXRUb1Nob3codGFyZ2V0SWQpIHtcblx0XHRyZXR1cm4gdGhpcy5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xuXHR9LFxuXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGlkZGVuTGVnZW5kSWRzLmluZGV4T2YodGFyZ2V0SWQpIDwgMDtcblx0fSxcblxuXHRmaWx0ZXJUYXJnZXRzVG9TaG93KHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gKHRhcmdldHMgfHwgJCQuZGF0YS50YXJnZXRzKS5maWx0ZXIodCA9PiAkJC5pc1RhcmdldFRvU2hvdyh0LmlkKSk7XG5cdH0sXG5cblx0bWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgeHMgPSBbXTtcblxuXHRcdGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoKSB7XG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcblx0XHRcdFx0bWVyZ2VBcnJheSh0YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLm1hcCh2ID0+ICt2LngpKSlcblx0XHRcdCk7XG5cblx0XHRcdHhzID0gJCQuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xuXHR9LFxuXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcblx0XHR0aGlzLmhpZGRlblRhcmdldElkcyA9IHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmNvbmNhdCh0YXJnZXRJZHMpO1xuXHR9LFxuXG5cdHJlbW92ZUhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcblx0XHR0aGlzLmhpZGRlblRhcmdldElkcyA9IHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcblx0fSxcblxuXHRhZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcblx0fSxcblxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLmhpZGRlbkxlZ2VuZElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzQXNJZEtleWVkKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgeXMgPSB7fTtcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXG5cdFx0XHQubWFwKHYgPT4gKGlzU3RyaW5nKHYpID8gdiA6ICt2KSkgOiBudWxsO1xuXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IFtdO1xuXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XG5cblx0XHRcdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgXCJoaWdoXCIgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRkYXRhLnB1c2goLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUodikpIHtcblx0XHRcdFx0XHRkYXRhLnB1c2goJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGlzTXVsdGlwbGVYKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyQkLmdldEluZGV4QnlYKHYueCwgeHMpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHlzW3QuaWRdID0gZGF0YTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB5cztcblx0fSxcblxuXHRjaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIGNoZWNrZXIpIHtcblx0XHRjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0YXJnZXRzKTtcblx0XHRsZXQgdmFsdWVzO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlcyA9IHRhcmdldHNbaWRzW2ldXS52YWx1ZXM7XG5cblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChjaGVja2VyKHZhbHVlc1tqXS52YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRoYXNNdWx0aVRhcmdldHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyVGFyZ2V0c1RvU2hvdygpLmxlbmd0aCA+IDE7XG5cdH0sXG5cblx0aGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPCAwKTtcblx0fSxcblxuXHRoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIHYgPT4gdiA+IDApO1xuXHR9LFxuXG5cdF9jaGVja09yZGVyKHR5cGUpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xuXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9yZGVyKSAmJiBvcmRlci50b0xvd2VyQ2FzZSgpID09PSB0eXBlO1xuXHR9LFxuXG5cdGlzT3JkZXJEZXNjKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiZGVzY1wiKTtcblx0fSxcblxuXHRpc09yZGVyQXNjKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiYXNjXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTb3J0IHRhcmdldHMgZGF0YVxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRzVmFsdWVcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvcmRlclRhcmdldHModGFyZ2V0c1ZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0YXJnZXRzID0gWy4uLnRhcmdldHNWYWx1ZV07XG5cdFx0Y29uc3Qgb3JkZXJBc2MgPSAkJC5pc09yZGVyQXNjKCk7XG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcblxuXHRcdGlmIChvcmRlckFzYyB8fCBvcmRlckRlc2MpIHtcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlZHVjZXIgPSAocCwgYykgPT4gcCArIE1hdGguYWJzKGMudmFsdWUpO1xuXHRcdFx0XHRjb25zdCB0MVN1bSA9IHQxLnZhbHVlcy5yZWR1Y2UocmVkdWNlciwgMCk7XG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcblxuXHRcdFx0XHRyZXR1cm4gb3JkZXJBc2MgPyB0MlN1bSAtIHQxU3VtIDogdDFTdW0gLSB0MlN1bTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjb25maWcuZGF0YV9vcmRlcikpIHtcblx0XHRcdHRhcmdldHMuc29ydChjb25maWcuZGF0YV9vcmRlcik7XG5cdFx0fSAvLyBUT0RPOiBhY2NlcHQgbmFtZSBhcnJheSBmb3Igb3JkZXJcblxuXHRcdHJldHVybiB0YXJnZXRzO1xuXHR9LFxuXG5cdGZpbHRlckJ5WCh0YXJnZXRzLCB4KSB7XG5cdFx0cmV0dXJuIG1lcmdlQXJyYXkodGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpLmZpbHRlcih2ID0+IHYueCAtIHggPT09IDApO1xuXHR9LFxuXG5cdGZpbHRlclJlbW92ZU51bGwoZGF0YSkge1xuXHRcdHJldHVybiBkYXRhLmZpbHRlcihkID0+IGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpKTtcblx0fSxcblxuXHRmaWx0ZXJCeVhEb21haW4odGFyZ2V0cywgeERvbWFpbikge1xuXHRcdHJldHVybiB0YXJnZXRzLm1hcCh0ID0+ICh7XG5cdFx0XHRpZDogdC5pZCxcblx0XHRcdGlkX29yZzogdC5pZF9vcmcsXG5cdFx0XHR2YWx1ZXM6IHQudmFsdWVzLmZpbHRlcih2ID0+IHhEb21haW5bMF0gPD0gdi54ICYmIHYueCA8PSB4RG9tYWluWzFdKVxuXHRcdH0pKTtcblx0fSxcblxuXHRoYXNEYXRhTGFiZWwoKSB7XG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9IHRoaXMuY29uZmlnLmRhdGFfbGFiZWxzO1xuXG5cdFx0cmV0dXJuIChpc0Jvb2xlYW4oZGF0YUxhYmVscykgJiYgZGF0YUxhYmVscykgfHxcblx0XHRcdChpc09iamVjdFR5cGUoZGF0YUxhYmVscykgJiYgbm90RW1wdHkoZGF0YUxhYmVscykpO1xuXHR9LFxuXG5cdGdldERhdGFMYWJlbExlbmd0aChtaW4sIG1heCwga2V5KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGxlbmd0aHMgPSBbMCwgMF07XG5cdFx0Y29uc3QgcGFkZGluZ0NvZWYgPSAxLjM7XG5cblx0XHQkJC5zZWxlY3RDaGFydC5zZWxlY3QoXCJzdmdcIikuc2VsZWN0QWxsKFwiLmR1bW15XCIpXG5cdFx0XHQuZGF0YShbbWluLCBtYXhdKVxuXHRcdFx0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQudGV4dChkID0+ICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkKSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0bGVuZ3Roc1tpXSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClba2V5XSAqIHBhZGRpbmdDb2VmO1xuXHRcdFx0fSlcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdHJldHVybiBsZW5ndGhzO1xuXHR9LFxuXG5cdGlzTm9uZUFyYyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmlkKTtcblx0fSxcblxuXHRpc0FyYyhkKSB7XG5cdFx0cmV0dXJuIFwiZGF0YVwiIGluIGQgJiYgdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuZGF0YS5pZCk7XG5cdH0sXG5cblx0ZmluZFNhbWVYT2ZWYWx1ZXModmFsdWVzLCBpbmRleCkge1xuXHRcdGNvbnN0IHRhcmdldFggPSB2YWx1ZXNbaW5kZXhdLng7XG5cdFx0Y29uc3Qgc2FtZXMgPSBbXTtcblx0XHRsZXQgaTtcblxuXHRcdGZvciAoaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0c2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IGluZGV4OyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2FtZXM7XG5cdH0sXG5cblx0ZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzLCBwb3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiAkJC5maW5kQ2xvc2VzdCh0YXJnZXQudmFsdWVzLCBwb3MpKTsgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XG5cblx0XHQvLyBkZWNpZGUgY2xvc2VzdCBwb2ludCBhbmQgcmV0dXJuXG5cdFx0cmV0dXJuICQkLmZpbmRDbG9zZXN0KGNhbmRpZGF0ZXMsIHBvcyk7XG5cdH0sXG5cblx0ZmluZENsb3Nlc3QodmFsdWVzLCBwb3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IG1pbkRpc3QgPSAkJC5jb25maWcucG9pbnRfc2Vuc2l0aXZpdHk7XG5cdFx0bGV0IGNsb3Nlc3Q7XG5cblx0XHQvLyBmaW5kIG1vdXNlb3ZlcmluZyBiYXJcblx0XHR2YWx1ZXNcblx0XHRcdC5maWx0ZXIodiA9PiB2ICYmICQkLmlzQmFyVHlwZSh2LmlkKSlcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5iYXJzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodi5pZCl9IC4ke0NMQVNTLmJhcn0tJHt2LmluZGV4fWApLm5vZGUoKTtcblxuXHRcdFx0XHRpZiAoIWNsb3Nlc3QgJiYgJCQuaXNXaXRoaW5CYXIoc2hhcGUpKSB7XG5cdFx0XHRcdFx0Y2xvc2VzdCA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGZyb20gbm9uLWJhclxuXHRcdHZhbHVlc1xuXHRcdFx0LmZpbHRlcih2ID0+IHYgJiYgISQkLmlzQmFyVHlwZSh2LmlkKSlcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBkID0gJCQuZGlzdCh2LCBwb3MpO1xuXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkO1xuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBjbG9zZXN0O1xuXHR9LFxuXG5cdGRpc3QoZGF0YSwgcG9zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25zdCB4SW5kZXggPSBpc1JvdGF0ZWQgPyAxIDogMDtcblx0XHRjb25zdCB5SW5kZXggPSBpc1JvdGF0ZWQgPyAwIDogMTtcblx0XHRjb25zdCB5ID0gJCQuY2lyY2xlWShkYXRhLCBkYXRhLmluZGV4KTtcblx0XHRjb25zdCB4ID0gKCQkLnpvb21TY2FsZSB8fCAkJC54KShkYXRhLngpO1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zW3hJbmRleF0sIDIpICsgTWF0aC5wb3coeSAtIHBvc1t5SW5kZXhdLCAyKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgZGF0YSBmb3Igc3RlcCB0eXBlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBPYmplY3QgZGF0YSB2YWx1ZXNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHN0ZXBUeXBlID0gY29uZmlnLmxpbmVfc3RlcF90eXBlO1xuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSAkJC5pc0NhdGVnb3JpemVkKCk7XG5cblx0XHRjb25zdCBjb252ZXJ0ZWQgPSBpc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMuY29uY2F0KCkgOiBbdmFsdWVzXTtcblxuXHRcdGlmICghaXNSb3RhdGVkICYmICFpc0NhdGVnb3JpemVkKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH1cblxuXHRcdC8vIGluc2VydCAmIGFwcGVuZCBjbG9uaW5nIGZpcnN0L2xhc3QgdmFsdWUgdG8gYmUgZnVsbHkgcmVuZGVyZWQgY292ZXJpbmcgb24gZWFjaCBnYXAgc2lkZXNcblx0XHRjb25zdCBpZCA9IGNvbnZlcnRlZFswXS5pZDtcblxuXHRcdC8vIGluc2VydFxuXHRcdGxldCB4ID0gY29udmVydGVkWzBdLnggLSAxO1xuXHRcdGxldCB2YWx1ZSA9IGNvbnZlcnRlZFswXS52YWx1ZTtcblxuXHRcdGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnVuc2hpZnQoe3gsIHZhbHVlLCBpZH0pO1xuXG5cdFx0c3RlcFR5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXG5cdFx0XHRjb252ZXJ0ZWQudW5zaGlmdCh7eDogeCAtIDEsIHZhbHVlLCBpZH0pO1xuXG5cdFx0Ly8gYXBwZW5kXG5cdFx0eCA9IGNvbnZlcnRlZC5sZW5ndGg7XG5cdFx0dmFsdWUgPSBjb252ZXJ0ZWRbeCAtIDFdLnZhbHVlO1xuXG5cdFx0aXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQucHVzaCh7eCwgdmFsdWUsIGlkfSk7XG5cblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWJlZm9yZVwiICYmXG5cdFx0XHRjb252ZXJ0ZWQucHVzaCh7eDogeCArIDEsIHZhbHVlLCBpZH0pO1xuXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcblx0fSxcblxuXHRjb252ZXJ0VmFsdWVzVG9SYW5nZSh2YWx1ZXMpIHtcblx0XHRjb25zdCBjb252ZXJ0ZWQgPSBpc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMuY29uY2F0KCkgOiBbdmFsdWVzXTtcblx0XHRjb25zdCByYW5nZXMgPSBbXTtcblxuXHRcdGNvbnZlcnRlZC5mb3JFYWNoKHJhbmdlID0+IHtcblx0XHRcdGNvbnN0IHt4LCBpZH0gPSByYW5nZTtcblxuXHRcdFx0cmFuZ2VzLnB1c2goe1xuXHRcdFx0XHR4LFxuXHRcdFx0XHRpZCxcblx0XHRcdFx0dmFsdWU6IHJhbmdlLnZhbHVlWzBdXG5cdFx0XHR9KTtcblxuXHRcdFx0cmFuZ2VzLnB1c2goe1xuXHRcdFx0XHR4LFxuXHRcdFx0XHRpZCxcblx0XHRcdFx0dmFsdWU6IHJhbmdlLnZhbHVlWzJdXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiByYW5nZXM7XG5cdH0sXG5cblx0dXBkYXRlRGF0YUF0dHJpYnV0ZXMobmFtZSwgYXR0cnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBjb25maWdbYGRhdGFfJHtuYW1lfWBdO1xuXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGF0dHJzKSkge1xuXHRcdFx0cmV0dXJuIGN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0Y3VycmVudFtpZF0gPSBhdHRyc1tpZF07XG5cdFx0fSk7XG5cblx0XHQkJC5yZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcblxuXHRcdHJldHVybiBjdXJyZW50O1xuXHR9LFxuXG5cdGdldEFyZWFSYW5nZURhdGEoZCwgdHlwZSkge1xuXHRcdGNvbnN0IHZhbHVlID0gZC52YWx1ZTtcblxuXHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBbXCJoaWdoXCIsIFwibWlkXCIsIFwibG93XCJdLmluZGV4T2YodHlwZSk7XG5cblx0XHRcdHJldHVybiBpbmRleCA9PT0gLTEgPyBudWxsIDogdmFsdWVbaW5kZXhdO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZVt0eXBlXTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHJhdGlvIHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFJhdGlvIGZvciBnaXZlbiB0eXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgdmFsdWUgb2JqZWN0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNQZXJjZW50IENvbnZlcnQgdGhlIHJldHVybiBhcyBwZXJjZW50IG9yIG5vdFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFJhdGlvIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRSYXRpbyh0eXBlLCBkLCBhc1BlcmNlbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGFwaSA9ICQkLmFwaTtcblx0XHRsZXQgcmF0aW8gPSAwO1xuXG5cdFx0aWYgKGQgJiYgYXBpLmRhdGEuc2hvd24uY2FsbChhcGkpLmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgZGF0YVZhbHVlcyA9IGFwaS5kYXRhLnZhbHVlcy5iaW5kKGFwaSk7XG5cblx0XHRcdHJhdGlvID0gZC5yYXRpbyB8fCBkLnZhbHVlO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xuXHRcdFx0XHQvLyBpZiBoYXMgcGFkQW5nbGUgc2V0LCBjYWxjdWxhdGUgcmF0ZSBiYXNlZCBvbiB2YWx1ZVxuXHRcdFx0XHRpZiAoJCQucGllLnBhZEFuZ2xlKCkoKSkge1xuXHRcdFx0XHRcdGxldCB0b3RhbCA9ICQkLmdldFRvdGFsRGF0YVN1bSgpO1xuXG5cdFx0XHRcdFx0aWYgKCQkLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRvdGFsIC09IGRhdGFWYWx1ZXMoJCQuaGlkZGVuVGFyZ2V0SWRzKS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyYXRpbyA9IGQudmFsdWUgLyB0b3RhbDtcblxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSwgYmFzZWQgb24gdGhlIHJlbmRlcmVkIGFuZ2xlIHZhbHVlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmF0aW8gPSAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAoXG5cdFx0XHRcdFx0XHRNYXRoLlBJICogKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAxIDogMilcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW5kZXhcIikge1xuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcblxuXHRcdFx0XHRpZiAoJCQuaGlkZGVuVGFyZ2V0SWRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKCQkLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xuXG5cdFx0XHRcdFx0aWYgKGhpZGRlblN1bS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxuXHRcdFx0XHRcdFx0XHQucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYy5tYXAoKHYsIGkpID0+IChpc051bWJlcih2KSA/IHYgOiAwKSArIGN1cnJbaV0pKTtcblxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGQucmF0aW8gPSBpc051bWJlcihkLnZhbHVlKSAmJiB0b3RhbCAmJiB0b3RhbFtkLmluZGV4XSA+IDAgP1xuXHRcdFx0XHRcdGQudmFsdWUgLyB0b3RhbFtkLmluZGV4XSA6IDA7XG5cblx0XHRcdFx0cmF0aW8gPSBkLnJhdGlvO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcInJhZGFyXCIpIHtcblx0XHRcdFx0cmF0aW8gPSAocGFyc2VGbG9hdChNYXRoLm1heChkLnZhbHVlLCAwKSkgLyAkJC5tYXhWYWx1ZSkgKiBjb25maWcucmFkYXJfc2l6ZV9yYXRpbztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYXNQZXJjZW50ICYmIHJhdGlvID8gcmF0aW8gKiAxMDAgOiByYXRpbztcblx0fSxcblxuXHQvKipcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRpY2tWYWx1ZXMgVGljayBhcnJheSB2YWx1ZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZURhdGFJbmRleEJ5WCh0aWNrVmFsdWVzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdHRpY2tWYWx1ZXMuc29tZSgoZCwgaikgPT4ge1xuXHRcdFx0XHRcdGlmICgrZC54ID09PSArdi54KSB7XG5cdFx0XHRcdFx0XHR2LmluZGV4ID0gajtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKCFpc051bWJlcih2LmluZGV4KSB8fCB2LmluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdHYuaW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRjc3ZQYXJzZSBhcyBkM0NzdlBhcnNlLFxuXHR0c3ZQYXJzZSBhcyBkM1RzdlBhcnNlLFxuXHRjc3ZQYXJzZVJvd3MgYXMgZDNDc3ZQYXJzZVJvd3MsXG5cdHRzdlBhcnNlUm93cyBhcyBkM1RzdlBhcnNlUm93cyxcbn0gZnJvbSBcImQzLWRzdlwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2lzVW5kZWZpbmVkLCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1ZhbHVlLCBub3RFbXB0eSwgZXh0ZW5kLCBpc0FycmF5LCBjYXBpdGFsaXplfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGRhdGEgYWNjb3JkaW5nIGl0cyB0eXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIGRhdGEgb2JqZWN0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZm9yIHVybChYSFIpIHR5cGUgbG9hZGluZ1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjb252ZXJ0RGF0YShhcmdzLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgZGF0YTtcblxuXHRcdGlmIChhcmdzLmJpbmR0bykge1xuXHRcdFx0ZGF0YSA9IHt9O1xuXG5cdFx0XHRbXCJ1cmxcIiwgXCJtaW1lVHlwZVwiLCBcImhlYWRlcnNcIiwgXCJrZXlzXCIsIFwianNvblwiLCBcImtleXNcIiwgXCJyb3dzXCIsIFwiY29sdW1uc1wiXVxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRjb25zdCBrZXkgPSBgZGF0YV8ke3Z9YDtcblxuXHRcdFx0XHRcdGlmIChrZXkgaW4gYXJncykge1xuXHRcdFx0XHRcdFx0ZGF0YVt2XSA9IGFyZ3Nba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gYXJncztcblx0XHR9XG5cblx0XHRpZiAoZGF0YS51cmwgJiYgY2FsbGJhY2spIHtcblx0XHRcdCQkLmNvbnZlcnRVcmxUb0RhdGEoZGF0YS51cmwsIGRhdGEubWltZVR5cGUsIGRhdGEuaGVhZGVycywgZGF0YS5rZXlzLCBjYWxsYmFjayk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLmpzb24pIHtcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0SnNvblRvRGF0YShkYXRhLmpzb24sIGRhdGEua2V5cyk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLnJvd3MpIHtcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0Um93c1RvRGF0YShkYXRhLnJvd3MpO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5jb2x1bW5zKSB7XG5cdFx0XHRkYXRhID0gJCQuY29udmVydENvbHVtbnNUb0RhdGEoZGF0YS5jb2x1bW5zKTtcblx0XHR9IGVsc2UgaWYgKGFyZ3MuYmluZHRvKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcInVybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC5cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlzQXJyYXkoZGF0YSkgJiYgZGF0YTtcblx0fSxcblxuXHRjb252ZXJ0VXJsVG9EYXRhKHVybCwgbWltZVR5cGUgPSBcImNzdlwiLCBoZWFkZXJzLCBrZXlzLCBkb25lKSB7XG5cdFx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xuXG5cdFx0aWYgKGhlYWRlcnMpIHtcblx0XHRcdE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSByZXEucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0cmVzcG9uc2UgJiYgZG9uZS5jYWxsKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzW2Bjb252ZXJ0JHtjYXBpdGFsaXplKG1pbWVUeXBlKX1Ub0RhdGFgXShcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcblx0XHRcdFx0XHRcdFx0a2V5c1xuXHRcdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke3VybH06IFNvbWV0aGluZyB3ZW50IHdyb25nIGxvYWRpbmchYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVxLnNlbmQoKTtcblx0fSxcblxuXHRfY29udmVydENzdlRzdlRvRGF0YShwYXJzZXIsIHhzdikge1xuXHRcdGNvbnN0IHJvd3MgPSBwYXJzZXIucm93cyh4c3YpO1xuXHRcdGxldCBkO1xuXG5cdFx0aWYgKHJvd3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRkID0gW3t9XTtcblxuXHRcdFx0cm93c1swXS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZDtcblx0fSxcblxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xuXHRcdHJldHVybiB0aGlzLl9jb252ZXJ0Q3N2VHN2VG9EYXRhKHtcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxuXHRcdFx0cGFyc2U6IGQzQ3N2UGFyc2Vcblx0XHR9LCB4c3YpO1xuXHR9LFxuXG5cdGNvbnZlcnRUc3ZUb0RhdGEodHN2KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnZlcnRDc3ZUc3ZUb0RhdGEoe1xuXHRcdFx0cm93czogZDNUc3ZQYXJzZVJvd3MsXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxuXHRcdH0sIHRzdik7XG5cdH0sXG5cblx0Y29udmVydEpzb25Ub0RhdGEoanNvbiwga2V5c1BhcmFtKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgbmV3Um93cyA9IFtdO1xuXHRcdGxldCB0YXJnZXRLZXlzO1xuXHRcdGxldCBkYXRhO1xuXG5cdFx0aWYgKGlzQXJyYXkoanNvbikpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcblxuXHRcdFx0aWYgKGtleXMueCkge1xuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcblx0XHRcdFx0Y29uZmlnLmRhdGFfeCA9IGtleXMueDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XG5cblx0XHRcdGpzb24uZm9yRWFjaChvID0+IHtcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcblx0XHRcdFx0XHQvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIGJlY2F1c2UgdW5kZWZpbmVkIGRhdGEgd2lsbCBiZSByZW1vdmVkIGluIGNvbnZlcnREYXRhVG9UYXJnZXRzKClcblx0XHRcdFx0XHRsZXQgdiA9IHRoaXMuZmluZFZhbHVlSW5Kc29uKG8sIGtleSk7XG5cblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcblx0XHRcdFx0XHRcdHYgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRuZXdSb3dzLnB1c2gobmV3Um93KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Um93c1RvRGF0YShuZXdSb3dzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRjb25zdCB0bXAgPSBqc29uW2tleV0uY29uY2F0KCk7XG5cblx0XHRcdFx0dG1wLnVuc2hpZnQoa2V5KTtcblx0XHRcdFx0bmV3Um93cy5wdXNoKHRtcCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydENvbHVtbnNUb0RhdGEobmV3Um93cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0ZmluZFZhbHVlSW5Kc29uKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIG9iamVjdFtwYXRoXTtcblx0XHR9XG5cblx0XHRjb25zdCBjb252ZXJ0ZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgXCIuJDFcIik7IC8vIGNvbnZlcnQgaW5kZXhlcyB0byBwcm9wZXJ0aWVzIChyZXBsYWNlIFtdIHdpdGggLilcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBjb252ZXJ0ZWRQYXRoLnJlcGxhY2UoL15cXC4vLCBcIlwiKS5zcGxpdChcIi5cIik7IC8vIHN0cmlwIGEgbGVhZGluZyBkb3Rcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xuXG5cdFx0cGF0aEFycmF5LnNvbWUoayA9PiAhKFxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cblx0XHRcdFx0dGFyZ2V0W2tdIDogdW5kZWZpbmVkXG5cdFx0KSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdGNvbnZlcnRSb3dzVG9EYXRhKHJvd3MpIHtcblx0XHRjb25zdCBrZXlzID0gcm93c1swXTtcblx0XHRjb25zdCBuZXdSb3dzID0gW107XG5cblx0XHRmb3IgKGxldCBpID0gMSwgbGVuMSA9IHJvd3MubGVuZ3RoOyBpIDwgbGVuMTsgaSsrKSB7XG5cdFx0XHRjb25zdCBuZXdSb3cgPSB7fTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGxlbjIgPSByb3dzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQocm93c1tpXVtqXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gcm93c1tpXVtqXTtcblx0XHRcdH1cblxuXHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XG5cdH0sXG5cblx0Y29udmVydENvbHVtbnNUb0RhdGEoY29sdW1ucykge1xuXHRcdGNvbnN0IG5ld1Jvd3MgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwLCBsZW4xID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHtcblx0XHRcdGNvbnN0IGtleSA9IGNvbHVtbnNbaV1bMF07XG5cblx0XHRcdGZvciAobGV0IGogPSAxLCBsZW4yID0gY29sdW1uc1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKG5ld1Jvd3NbaiAtIDFdKSkge1xuXHRcdFx0XHRcdG5ld1Jvd3NbaiAtIDFdID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoY29sdW1uc1tpXVtqXSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3Um93c1tqIC0gMV1ba2V5XSA9IGNvbHVtbnNbaV1bal07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XG5cdH0sXG5cblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xuXG5cdFx0Y29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcblx0XHRjb25zdCBpZHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNOb3RYLCAkJCkgOiBbXTtcblx0XHRjb25zdCB4cyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc1gsICQkKSA6IFtdO1xuXG5cdFx0bGV0IHhzRGF0YTtcblxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbnN0IHhLZXkgPSB0aGlzLmdldFhLZXkoaWQpO1xuXG5cdFx0XHRpZiAodGhpcy5pc0N1c3RvbVgoKSB8fCBpc1RpbWVTZXJpZXMpIHtcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxuXHRcdFx0XHRpZiAoeHMuaW5kZXhPZih4S2V5KSA+PSAwKSB7XG5cdFx0XHRcdFx0eHNEYXRhID0gKChhcHBlbmRYcyAmJiAkJC5kYXRhLnhzW2lkXSkgfHwgW10pXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxuXHRcdFx0XHRcdFx0XHRkYXRhLm1hcChkID0+IGRbeEtleV0pXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihpc1ZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbmZpZy5kYXRhX3gpIHtcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxuXHRcdFx0XHRcdHhzRGF0YSA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSkge1xuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcblx0XHRcdFx0XHR4c0RhdGEgPSAkJC5nZXRYVmFsdWVzT2ZYS2V5KHhLZXksICQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eHNEYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IGkpO1xuXHRcdFx0fVxuXG5cdFx0XHR4c0RhdGEgJiYgKHRoaXMuZGF0YS54c1tpZF0gPSB4c0RhdGEpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY2hlY2sgeCBpcyBkZWZpbmVkXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmRhdGEueHNbaWRdKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgeCBpcyBub3QgZGVmaW5lZCBmb3IgaWQgPSBcIiR7aWR9XCIuYCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxuXHRcdGNvbnN0IHRhcmdldHMgPSBpZHMubWFwKChpZCwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGNvbnZlcnRlZElkID0gY29uZmlnLmRhdGFfaWRDb252ZXJ0ZXIoaWQpO1xuXHRcdFx0Y29uc3QgeEtleSA9ICQkLmdldFhLZXkoaWQpO1xuXHRcdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblx0XHRcdGNvbnN0IGhhc0NhdGVnb3J5ID0gaXNDYXRlZ29yaXplZCAmJiBkYXRhLm1hcCh2ID0+IHYueClcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcblx0XHRcdFx0aWRfb3JnOiBpZCxcblx0XHRcdFx0dmFsdWVzOiBkYXRhLm1hcCgoZCwgaSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xuXHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRbaWRdO1xuXHRcdFx0XHRcdGxldCB4O1xuXG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmICFpc09iamVjdCh2YWx1ZSkgP1xuXHRcdFx0XHRcdFx0K2RbaWRdIDogKGlzQXJyYXkodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG5cblx0XHRcdFx0XHQvLyB1c2UgeCBhcyBjYXRlZ29yaWVzIGlmIGN1c3RvbSB4IGFuZCBjYXRlZ29yaXplZFxuXHRcdFx0XHRcdGlmIChpc0NhdGVnb3JpemVkICYmIGluZGV4ID09PSAwICYmICFpc1VuZGVmaW5lZChyYXdYKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFoYXNDYXRlZ29yeSAmJiBpbmRleCA9PT0gMCAmJiBpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YocmF3WCk7XG5cblx0XHRcdFx0XHRcdGlmICh4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLnB1c2gocmF3WCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG1hcmsgYXMgeCA9IHVuZGVmaW5lZCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIGZpbHRlciB0byByZW1vdmUgYWZ0ZXIgbWFwcGVkXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKGRbaWRdKSB8fCAkJC5kYXRhLnhzW2lkXS5sZW5ndGggPD0gaSkge1xuXHRcdFx0XHRcdFx0eCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4ge3gsIHZhbHVlLCBpZDogY29udmVydGVkSWR9O1xuXHRcdFx0XHR9KS5maWx0ZXIodiA9PiBpc0RlZmluZWQodi54KSlcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBmaW5pc2ggdGFyZ2V0c1xuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdC8vIHNvcnQgdmFsdWVzIGJ5IGl0cyB4XG5cdFx0XHRpZiAoY29uZmlnLmRhdGFfeFNvcnQpIHtcblx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5zb3J0KCh2MSwgdjIpID0+IHtcblx0XHRcdFx0XHRjb25zdCB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eTtcblx0XHRcdFx0XHRjb25zdCB4MiA9IHYyLnggfHwgdjIueCA9PT0gMCA/IHYyLnggOiBJbmZpbml0eTtcblxuXHRcdFx0XHRcdHJldHVybiB4MSAtIHgyO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5kZXhpbmcgZWFjaCB2YWx1ZVxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4gKHYuaW5kZXggPSBpKSk7XG5cblx0XHRcdC8vIHRoaXMgbmVlZHMgdG8gYmUgc29ydGVkIGJlY2F1c2UgaXRzIGluZGV4IGFuZCB2YWx1ZS5pbmRleCBpcyBpZGVudGljYWxcblx0XHRcdCQkLmRhdGEueHNbdC5pZF0uc29ydCgodjEsIHYyKSA9PiB2MSAtIHYyKTtcblx0XHR9KTtcblxuXHRcdC8vIGNhY2hlIGluZm9ybWF0aW9uIGFib3V0IHZhbHVlc1xuXHRcdCQkLmhhc05lZ2F0aXZlVmFsdWUgPSAkJC5oYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xuXHRcdCQkLmhhc1Bvc2l0aXZlVmFsdWUgPSAkJC5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xuXG5cdFx0Ly8gc2V0IHRhcmdldCB0eXBlc1xuXHRcdGlmIChjb25maWcuZGF0YV90eXBlKSB7XG5cdFx0XHQkJC5zZXRUYXJnZXRUeXBlKCQkLm1hcFRvSWRzKHRhcmdldHMpXG5cdFx0XHRcdC5maWx0ZXIoaWQgPT4gIShpZCBpbiBjb25maWcuZGF0YV90eXBlcykpLCBjb25maWcuZGF0YV90eXBlKTtcblx0XHR9XG5cblx0XHQvLyBjYWNoZSBhcyBvcmlnaW5hbCBpZCBrZXllZFxuXHRcdHRhcmdldHMuZm9yRWFjaChkID0+ICQkLmFkZENhY2hlKGQuaWRfb3JnLCBkLCB0cnVlKSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGxvYWQocmF3VGFyZ2V0cywgYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgdGFyZ2V0cyA9IHJhd1RhcmdldHM7XG5cblx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0Ly8gZmlsdGVyIGxvYWRpbmcgdGFyZ2V0cyBpZiBuZWVkZWRcblx0XHRcdGlmIChhcmdzLmZpbHRlcikge1xuXHRcdFx0XHR0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoYXJncy5maWx0ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgdHlwZSBpZiBhcmdzLnR5cGVzIHx8IGFyZ3MudHlwZSBzcGVjaWZpZWRcblx0XHRcdGlmIChhcmdzLnR5cGUgfHwgYXJncy50eXBlcykge1xuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChhcmdzLnR5cGVzICYmIGFyZ3MudHlwZXNbdC5pZF0pIHx8IGFyZ3MudHlwZTtcblxuXHRcdFx0XHRcdCQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcblx0XHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xuXHRcdFx0XHRcdFx0ZC52YWx1ZXMgPSB0YXJnZXRzW2ldLnZhbHVlcztcblx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRhcmdldHNcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZSgpO1xuXHR9LFxuXG5cdGxvYWRGcm9tQXJncyhhcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcblx0XHRpZiAoISQkLmNvbmZpZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcblx0XHQkJC5yZXNldENhY2hlKCk7XG5cblx0XHRjb25zdCBkYXRhID0gYXJncy5kYXRhIHx8ICQkLmNvbnZlcnREYXRhKGFyZ3MsIGQgPT4gJCQubG9hZCgkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkKSwgYXJncykpO1xuXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcblx0fSxcblxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XG5cdFx0bGV0IHRhcmdldElkcyA9IHJhd1RhcmdldElkcztcblxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcblx0XHQkJC5yZXNldENhY2hlKCk7XG5cblx0XHRpZiAoIWRvbmUpIHtcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcblx0XHR9XG5cblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XG5cdFx0dGFyZ2V0SWRzID0gdGFyZ2V0SWRzLmZpbHRlcihpZCA9PiAkJC5oYXNUYXJnZXQoJCQuZGF0YS50YXJnZXRzLCBpZCkpO1xuXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxuXHRcdGlmICghdGFyZ2V0SWRzIHx8IHRhcmdldElkcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGRvbmUoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKHRhcmdldElkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQpKSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKClcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgZG9uZSk7XG5cblx0XHR0YXJnZXRJZHMuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXG5cdFx0XHQkJC53aXRob3V0RmFkZUluW2lkXSA9IGZhbHNlO1xuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldCdzIGVsZW1lbnRzXG5cdFx0XHRpZiAoJCQubGVnZW5kKSB7XG5cdFx0XHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgdGFyZ2V0XG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBDYXRlZ29yeSBOYW1lXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBnYXRlZ29yeSBOYW1lXG5cdCAqL1xuXHRjYXRlZ29yeU5hbWUoaSkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGkgPCBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoID8gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzW2ldIDogaTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0bW91c2UgYXMgZDNNb3VzZSxcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRldmVudCBhcyBkM0V2ZW50XG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7ZHJhZyBhcyBkM0RyYWd9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtlbXVsYXRlRXZlbnQsIGV4dGVuZCwgaXNCb29sZWFuLCBpc051bWJlciwgaXNPYmplY3R9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cblx0ICogQWRkIGEgY29udGFpbmVyIGZvciB0aGUgem9uZSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdEV2ZW50UmVjdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdHMpXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXdzIHRoZSBhcmVhIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZWRyYXdFdmVudFJlY3QoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XG5cdFx0bGV0IGV2ZW50UmVjdFVwZGF0ZTtcblxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YClcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCB6b29tRW5hYmxlZCAmJiB6b29tRW5hYmxlZC50eXBlICE9PSBcImRyYWdcIiA/IChcblx0XHRcdFx0Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwibnMtcmVzaXplXCIgOiBcImV3LXJlc2l6ZVwiXG5cdFx0XHQpIDogbnVsbClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNNdWx0aXBsZSwgaXNNdWx0aXBsZVgpXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5ldmVudFJlY3RzU2luZ2xlLCAhaXNNdWx0aXBsZVgpO1xuXG5cdFx0Ly8gY2xlYXIgb2xkIHJlY3RzXG5cdFx0ZXZlbnRSZWN0cy5zZWxlY3RBbGwoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5yZW1vdmUoKTtcblxuXHRcdC8vIG9wZW4gYXMgcHVibGljIGNvbnN0aWFibGVcblx0XHQkJC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xuXG5cdFx0aWYgKGlzTXVsdGlwbGVYKSB7XG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5ldmVudFJlY3QuZGF0YShbMF0pO1xuXHRcdFx0Ly8gdXBkYXRlXG5cdFx0XHQvLyBlbnRlcjogb25seSBvbmUgcmVjdCB3aWxsIGJlIGFkZGVkXG5cdFx0XHQvLyBleGl0OiBub3QgbmVlZGVkIGJlY2F1c2UgYWx3YXlzIG9ubHkgb25lIHJlY3QgZXhpc3RzXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxuXHRcdFx0XHQubWVyZ2UoZXZlbnRSZWN0VXBkYXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU2V0IGRhdGEgYW5kIHVwZGF0ZSAkJC5ldmVudFJlY3Rcblx0XHRcdGNvbnN0IHhBeGlzVGlja1ZhbHVlcyA9ICQkLmdldE1heERhdGFDb3VudFRhcmdldCgpO1xuXG5cdFx0XHQvLyB1cGRhdGUgZGF0YSdzIGluZGV4IHZhbHVlIHRvIGJlIGFsaW5nZWQgd2l0aCB0aGUgeCBBeGlzXG5cdFx0XHQkJC51cGRhdGVEYXRhSW5kZXhCeVgoeEF4aXNUaWNrVmFsdWVzKTtcblx0XHRcdCQkLnVwZGF0ZVhzKHhBeGlzVGlja1ZhbHVlcyk7XG5cdFx0XHQkJC51cGRhdGVQb2ludENsYXNzKHRydWUpO1xuXG5cdFx0XHRldmVudFJlY3RzLmRhdHVtKHhBeGlzVGlja1ZhbHVlcyk7XG5cblx0XHRcdCQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5ldmVudFJlY3QuZGF0YShkID0+IGQpO1xuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRldmVudFJlY3RVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xuXG5cdFx0aWYgKCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICEkJC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHQkJC5iaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCk7XG5cdFx0fVxuXHR9LFxuXG5cdGJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IGdldEV2ZW50UmVjdCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0cmV0dXJuIGQzU2VsZWN0KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xuXHRcdH07XG5cblx0XHRjb25zdCBnZXRJbmRleCA9IGV2ZW50UmVjdCA9PiB7XG5cdFx0XHRsZXQgaW5kZXggPSBldmVudFJlY3QgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKSAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xuXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdGluZGV4ID0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xuXHRcdFx0aWYgKGlzTXVsdGlwbGVYKSB7XG5cdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZXZlbnRSZWN0KTtcblxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcblxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDpcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHQvLyBhY2NvcmRpbmcgJ2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaC5wcmV2ZW50RGVmYXVsdCcgb3B0aW9uXG5cdFx0Y29uc3QgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0O1xuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xuXHRcdGNvbnN0IHByZXZlbnRUaHJlc2hvbGQgPSAoIWlzTmFOKHByZXZlbnREZWZhdWx0KSAmJiBwcmV2ZW50RGVmYXVsdCkgfHwgbnVsbDtcblx0XHRsZXQgc3RhcnRQeDtcblxuXHRcdGNvbnN0IHByZXZlbnRFdmVudCA9IGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0Y29uc3QgY3VycmVudFhZID0gdG91Y2hbYGNsaWVudCR7Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwiWVwiIDogXCJYXCJ9YF07XG5cblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZXZlbnRUeXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZlbnRUaHJlc2hvbGQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRzdGFydFB4ID0gY3VycmVudFhZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQgfHwgc3RhcnRQeCA9PT0gdHJ1ZSB8fCAoXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHQvLyBvbmNlIHByZXZlbnRlZCwga2VlcCBwcmV2ZW50ZWQgZHVyaW5nIHdob2xlICd0b3VjaG1vdmUnIGNvbnRleHRcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXG5cdFx0JCQuc3ZnXG5cdFx0XHQub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdCB0b3VjaG1vdmUuZXZlbnRSZWN0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcblx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xuXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xuXHRcdFx0XHRcdC8vIGlmIHRvdWNoIHBvaW50cyBhcmUgPiAxLCBtZWFucyBkb2luZyB6b29taW5nIGludGVyYWN0aW9uLiBJbiB0aGlzIGNhc2UgZG8gbm90IGV4ZWN1dGUgdG9vbHRpcCBjb2Rlcy5cblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHJldmVudEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRzZWxlY3RSZWN0KHRoaXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xuXHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSlcblx0XHRcdC5vbihcInRvdWNoZW5kLmV2ZW50UmVjdFwiLCAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xuXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xuXHRcdFx0XHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlIHx8ICQkLmNhbmNlbENsaWNrKSB7XG5cdFx0XHRcdFx0XHQkJC5jYW5jZWxDbGljayAmJiAoJCQuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgbG9jYXRpb24gYW5kIHNpemUgb2YgdGhlIGV2ZW50UmVjdC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqL1xuXHR1cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB4U2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblx0XHRjb25zdCBldmVudFJlY3REYXRhID0gZXZlbnRSZWN0VXBkYXRlIHx8ICQkLmV2ZW50UmVjdC5kYXRhKCk7Ly8gc2V0IHVwZGF0ZSBzZWxlY3Rpb24gaWYgbnVsbFxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHg7XG5cdFx0bGV0IHk7XG5cdFx0bGV0IHc7XG5cdFx0bGV0IGg7XG5cblx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xuXHRcdFx0Ly8gVE9ETzogcm90YXRlZCBub3Qgc3VwcG9ydGVkIHlldFxuXHRcdFx0eCA9IDA7XG5cdFx0XHR5ID0gMDtcblx0XHRcdHcgPSAkJC53aWR0aDtcblx0XHRcdGggPSAkJC5oZWlnaHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCByZWN0Vztcblx0XHRcdGxldCByZWN0WDtcblxuXHRcdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0XHRyZWN0VyA9ICQkLmdldEV2ZW50UmVjdFdpZHRoKCk7XG5cdFx0XHRcdHJlY3RYID0gZCA9PiB4U2NhbGUoZC54KSAtIChyZWN0VyAvIDIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZ2V0UHJldk5leHRYID0gZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcblx0XHRcdFx0XHRcdG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmVjdFcgPSBkID0+IHtcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IG1ha2UgdGhlIGV2ZW50UmVjdCBmdWxsIHdpZHRoIChvciBoZWlnaHQpXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHgubmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0eC5uZXh0ID0geFNjYWxlLmRvbWFpbigpWzFdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCgwLCAoeFNjYWxlKHgubmV4dCkgLSB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZWN0WCA9IGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XG5cdFx0XHRcdFx0Y29uc3QgdGhpc1ggPSBkLng7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgcG9zaXRpb24gdGhlIGV2ZW50UmVjdCBhdCAwXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHgucHJldiA9IHhTY2FsZS5kb21haW4oKVswXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gKHhTY2FsZSh0aGlzWCkgKyB4U2NhbGUoeC5wcmV2KSkgLyAyO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHJlY3RYO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHJlY3RYIDogMDtcblx0XHRcdHcgPSBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IHJlY3RXO1xuXHRcdFx0aCA9IGlzUm90YXRlZCA/IHJlY3RXIDogJCQuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdGV2ZW50UmVjdERhdGEuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInhcIiwgeClcblx0XHRcdC5hdHRyKFwieVwiLCB5KVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3KVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaCk7XG5cdH0sXG5cblx0c2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1NlbGVjdGlvbkVuYWJsZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDtcblx0XHRjb25zdCBpc1NlbGVjdGlvbkdyb3VwZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZDtcblx0XHRjb25zdCBpc1Rvb2x0aXBHcm91cGVkID0gY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSAkJC5nZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KTtcblxuXHRcdGlmIChpc1Rvb2x0aXBHcm91cGVkKSB7XG5cdFx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xuXHRcdFx0JCQuc2hvd1hHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcblxuXHRcdFx0aWYgKCFpc1NlbGVjdGlvbkVuYWJsZWQgfHwgaXNTZWxlY3Rpb25Hcm91cGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoaXNTZWxlY3Rpb25FbmFibGVkKSB7XG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIGlzU2VsZWN0aW9uR3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcblx0XHRcdFx0XHQkJC5oaWRlWEdyaWRGb2N1cygpO1xuXHRcdFx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XG5cblx0XHRcdFx0XHQhaXNTZWxlY3Rpb25Hcm91cGVkICYmICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRyZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcblx0XHRcdH0pXG5cdFx0XHQuY2FsbChzZWxlY3RlZCA9PiB7XG5cdFx0XHRcdGNvbnN0IGQgPSBzZWxlY3RlZC5kYXRhKCk7XG5cblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCAmJiAoaXNTZWxlY3Rpb25Hcm91cGVkIHx8IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpKSB7XG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaXNUb29sdGlwR3JvdXBlZCkge1xuXHRcdFx0XHRcdCQkLnNob3dUb29sdGlwKGQsIGNvbnRleHQpO1xuXHRcdFx0XHRcdCQkLnNob3dYR3JpZEZvY3VzKGQpO1xuXG5cdFx0XHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XG5cdFx0XHRcdFx0c2VsZWN0ZWQuZWFjaChkID0+ICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBkLmlkKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdGV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBpZCwgcmVzZXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkICYmXG5cdFx0XHQkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBpZCwgcmVzZXQpO1xuXG5cdFx0JCQuZXhwYW5kQmFycyhpbmRleCwgaWQsIHJlc2V0KTtcblx0fSxcblxuXHRzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gZG8gbm90aGluZyB3aGVuIGRyYWdnaW5nXG5cdFx0aWYgKCQkLmRyYWdnaW5nIHx8ICQkLmhhc0FyY1R5cGUodGFyZ2V0c1RvU2hvdykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UoY29udGV4dCk7XG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xuXG5cdFx0aWYgKCQkLm1vdXNlb3ZlciAmJiAoIWNsb3Nlc3QgfHwgY2xvc2VzdC5pZCAhPT0gJCQubW91c2VvdmVyLmlkKSkge1xuXHRcdFx0Y29uZmlnLmRhdGFfb25vdXQuY2FsbCgkJC5hcGksICQkLm1vdXNlb3Zlcik7XG5cdFx0XHQkJC5tb3VzZW92ZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFjbG9zZXN0KSB7XG5cdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBzYW1lWERhdGEgPSAoXG5cdFx0XHQkJC5pc0J1YmJsZVR5cGUoY2xvc2VzdCkgfHwgJCQuaXNTY2F0dGVyVHlwZShjbG9zZXN0KSB8fCAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZFxuXHRcdCkgPyBbY2xvc2VzdF0gOiAkJC5maWx0ZXJCeVgodGFyZ2V0c1RvU2hvdywgY2xvc2VzdC54KTtcblxuXHRcdC8vIHNob3cgdG9vbHRpcCB3aGVuIGN1cnNvciBpcyBjbG9zZSB0byBzb21lIHBvaW50XG5cdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gc2FtZVhEYXRhLm1hcChkID0+ICQkLmFkZE5hbWUoZCkpO1xuXG5cdFx0JCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KTtcblxuXHRcdC8vIGV4cGFuZCBwb2ludHNcblx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhjbG9zZXN0LmluZGV4LCBjbG9zZXN0LmlkLCB0cnVlKTtcblxuXHRcdC8vIFNob3cgeGdyaWQgZm9jdXMgbGluZVxuXHRcdCQkLnNob3dYR3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XG5cblx0XHQvLyBTaG93IGN1cnNvciBhcyBwb2ludGVyIGlmIHBvaW50IGlzIGNsb3NlIHRvIG1vdXNlIHBvc2l0aW9uXG5cdFx0aWYgKCQkLmlzQmFyVHlwZShjbG9zZXN0LmlkKSB8fCAkJC5kaXN0KGNsb3Nlc3QsIG1vdXNlKSA8IGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSkge1xuXHRcdFx0JCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcblxuXHRcdFx0aWYgKCEkJC5tb3VzZW92ZXIpIHtcblx0XHRcdFx0Y29uZmlnLmRhdGFfb25vdmVyLmNhbGwoJCQuYXBpLCBjbG9zZXN0KTtcblx0XHRcdFx0JCQubW91c2VvdmVyID0gY2xvc2VzdDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVuc2VsZWN0IEV2ZW50UmVjdC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVuc2VsZWN0UmVjdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9YCkuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCk7XG5cdFx0JCQuaGlkZVhHcmlkRm9jdXMoKTtcblx0XHQkJC5oaWRlVG9vbHRpcCgpO1xuXHRcdCQkLl9oYW5kbGVMaW5rZWRDaGFydHMoZmFsc2UpO1xuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIG9wdGlvbnNcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRPdmVyT3V0KGlzT3ZlciwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNBcmMgPSBpc09iamVjdChkKTtcblxuXHRcdC8vIENhbGwgZXZlbnQgaGFuZGxlclxuXHRcdGlmIChpc0FyYyB8fCBkICE9PSAtMSkge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjb25maWdbaXNPdmVyID8gXCJkYXRhX29ub3ZlclwiIDogXCJkYXRhX29ub3V0XCJdLmJpbmQoJCQuYXBpKTtcblxuXHRcdFx0Y29uZmlnLmNvbG9yX29ub3ZlciAmJiAkJC5zZXRPdmVyQ29sb3IoaXNPdmVyLCBkLCBpc0FyYyk7XG5cblx0XHRcdGlmIChpc0FyYykge1xuXHRcdFx0XHRjYWxsYmFjayhkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3ZlciAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0ISQkLmlzTXVsdGlwbGVYKCkgJiYgJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YCkuZWFjaChjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGxPdmVyT3V0Rm9yVG91Y2goZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWxsZWUgPSAkJC5jYWxsT3Zlck91dEZvclRvdWNoO1xuXHRcdGNvbnN0IGxhc3QgPSBjYWxsZWUubGFzdDtcblxuXHRcdGlmIChpc09iamVjdChkKSAmJiBsYXN0ID8gZC5pZCAhPT0gbGFzdC5pZCA6IChkICE9PSBsYXN0KSkge1xuXHRcdFx0KGxhc3QgfHwgaXNOdW1iZXIobGFzdCkpICYmICQkLnNldE92ZXJPdXQoZmFsc2UsIGxhc3QpO1xuXHRcdFx0KGQgfHwgaXNOdW1iZXIoZCkpICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZCk7XG5cblx0XHRcdGNhbGxlZS5sYXN0ID0gZDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiBkcmFnZ2FibGUgc2VsZWN0aW9uIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSAmJiAkJC5kcmFnID9cblx0XHRcdGQzRHJhZygpXG5cdFx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7ICQkLmRyYWcoZDNNb3VzZSh0aGlzKSk7IH0pXG5cdFx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkgeyAkJC5kcmFnc3RhcnQoZDNNb3VzZSh0aGlzKSk7IH0pXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7ICQkLmRyYWdlbmQoKTsgfSkgOiAoKSA9PiB7fTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGV2ZW50UmVjdCBmb3IgZWFjaCBkYXRhIG9uIHRoZSB4LWF4aXMuXG5cdCAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqL1xuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdEVudGVyKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlci5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0aGlzKShkLCAkJCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xuXG5cdFx0aWYgKCQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiKSB7XG5cdFx0XHRyZWN0XG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KHRydWUsIGQuaW5kZXgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmcgd2hpbGUgZHJhZ2dpbmcvZmxvd2luZ1xuXHRcdFx0XHRcdGlmICgkJC5kcmFnZ2luZyB8fCAkJC5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBpbmRleCA9IGQuaW5kZXg7XG5cdFx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gJCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xuXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkgJiZcblx0XHRcdFx0XHRcdCQkLmNvbmZpZy5saW5lX3N0ZXBfdHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcblx0XHRcdFx0XHRcdGQzTW91c2UodGhpcylbMF0gPCAkJC54KCQkLmdldFhWYWx1ZShkLmlkLCBpbmRleCkpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRpbmRleCAtPSAxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4ID09PSAtMSA/XG5cdFx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKSA6ICQkLnNlbGVjdFJlY3RGb3JTaW5nbGUodGhpcywgZXZlbnRSZWN0LCBpbmRleCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxuXHRcdFx0XHRcdGlmICghJCQuY29uZmlnIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGQuaW5kZXgpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHRjbGlja0hhbmRsZXJGb3JTaW5nbGVYKGQsIGN0eCkge1xuXHRcdGNvbnN0ICQkID0gY3R4O1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlIHx8ICQkLmNhbmNlbENsaWNrKSB7XG5cdFx0XHQkJC5jYW5jZWxDbGljayAmJiAoJCQuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBpbmRleCA9IGQuaW5kZXg7XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQyKSB7XG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQyKSkge1xuXHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlKHRoaXMsIGQyLCBpbmRleCk7XG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgZDIsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIGV2ZW50UmVjdCxcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cblx0ICogQHJldHVybnMge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cblx0ICovXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0RW50ZXIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcInhcIiwgMClcblx0XHRcdC5hdHRyKFwieVwiLCAwKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0KVxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xuXG5cdFx0aWYgKCQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiKSB7XG5cdFx0XHRyZWN0XG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlciBtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvck11bHRpcGxlWHModGhpcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcblx0XHRcdFx0XHRpZiAoISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0Y2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUyhjdHgpIHtcblx0XHRjb25zdCAkJCA9IGN0eDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoaXMpO1xuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcblxuXHRcdGlmICghY2xvc2VzdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBpZiBzZWxlY3Rpb24gZW5hYmxlZFxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcblx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChjbG9zZXN0LmlkKX1gKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtjbG9zZXN0LmluZGV4fWApXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGNsb3Nlc3QpKSB7XG5cdFx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KTtcblx0XHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGNsb3Nlc3QsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIG1vdXNlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBldmVudCB0eXBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiBldmVudFJlY3Rcblx0ICogQHBhcmFtIHtBcnJheX0gbW91c2UgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlXG5cdCAqL1xuXHRkaXNwYXRjaEV2ZW50KHR5cGUsIGluZGV4LCBtb3VzZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgLiR7aXNNdWx0aXBsZVggPyBDTEFTUy5ldmVudFJlY3QgOiBgJHtDTEFTUy5ldmVudFJlY3R9LSR7aW5kZXh9YH1gO1xuXHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLm1haW4uc2VsZWN0KHNlbGVjdG9yKS5ub2RlKCk7XG5cdFx0Y29uc3Qge3dpZHRoLCBsZWZ0LCB0b3B9ID0gZXZlbnRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHggPSBsZWZ0ICsgKG1vdXNlID8gbW91c2VbMF0gOiAwKSArIChpc011bHRpcGxlWCA/IDAgOiAod2lkdGggLyAyKSk7XG5cdFx0Y29uc3QgeSA9IHRvcCArIChtb3VzZSA/IG1vdXNlWzFdIDogMCk7XG5cdFx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdFx0c2NyZWVuWDogeCxcblx0XHRcdHNjcmVlblk6IHksXG5cdFx0XHRjbGllbnRYOiB4LFxuXHRcdFx0Y2xpZW50WTogeVxuXHRcdH07XG5cblx0XHRlbXVsYXRlRXZlbnRbL14obW91c2V8Y2xpY2spLy50ZXN0KHR5cGUpID8gXCJtb3VzZVwiIDogXCJ0b3VjaFwiXShldmVudFJlY3QsIHR5cGUsIHBhcmFtcyk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4vYnJvd3NlclwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtpc1ZhbHVlLCBjZWlsMTAsIGV4dGVuZCwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIFVwZGF0ZSBjb250YWluZXIgc2l6ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0Q29udGFpbmVyU2l6ZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jdXJyZW50V2lkdGggPSAkJC5nZXRDdXJyZW50V2lkdGgoKTtcblx0XHQkJC5jdXJyZW50SGVpZ2h0ID0gJCQuZ2V0Q3VycmVudEhlaWdodCgpO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRXaWR0aCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuY29uZmlnLnNpemVfd2lkdGggfHwgJCQuZ2V0UGFyZW50V2lkdGgoKTtcblx0fSxcblxuXHRnZXRDdXJyZW50SGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaCA9IGNvbmZpZy5zaXplX2hlaWdodCB8fCAkJC5nZXRQYXJlbnRIZWlnaHQoKTtcblxuXHRcdHJldHVybiBoID4gMCA/IGggOiAzMjAgLyAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDIgOiAxKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IEF4aXMgc2l6ZSBhY2NvcmRpbmcgaXRzIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBBeGlzIGlkIHZhbHVlIC0geCwgeSBvciB5MlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IHNpemUgQXhpcyBzaXplIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRBeGlzU2l6ZShpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdHJldHVybiAoaXNSb3RhdGVkICYmIGlkID09PSBcInhcIikgfHwgKCFpc1JvdGF0ZWQgJiYgL3kyPy8udGVzdChpZCkpID9cblx0XHRcdCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB0cnVlKSA6XG5cdFx0XHQkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChpZCk7XG5cdH0sXG5cblx0Z2V0Q3VycmVudFBhZGRpbmdUb3AoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XG5cblx0XHRsZXQgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfdG9wKSA/XG5cdFx0XHRjb25maWcucGFkZGluZ190b3AgOiAwO1xuXG5cdFx0aWYgKCQkLnRpdGxlICYmICQkLnRpdGxlLm5vZGUoKSkge1xuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRUaXRsZVBhZGRpbmcoKTtcblx0XHR9XG5cblx0XHRpZiAoYXhlc0xlbiAmJiBjb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKiBheGVzTGVuO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYWRkaW5nO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXhpc0lkID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IFwieVwiIDogXCJ4XCI7XG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcblx0XHRjb25zdCBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ19ib3R0b20pID9cblx0XHRcdGNvbmZpZy5wYWRkaW5nX2JvdHRvbSA6IDA7XG5cblx0XHRyZXR1cm4gcGFkZGluZyArIChcblx0XHRcdGF4ZXNMZW4gPyAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChheGlzSWQpICogYXhlc0xlbiA6IDBcblx0XHQpO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCI7XG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcblx0XHRjb25zdCBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChheGlzSWQsIHdpdGhvdXRSZWNvbXB1dGUpO1xuXHRcdGxldCBwYWRkaW5nO1xuXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfbGVmdCkpIHtcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19sZWZ0O1xuXHRcdH0gZWxzZSBpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHRwYWRkaW5nID0gIWNvbmZpZy5heGlzX3hfc2hvdyA/XG5cdFx0XHRcdDEgOiBNYXRoLm1heChjZWlsMTAoYXhpc1dpZHRoKSwgNDApO1xuXHRcdH0gZWxzZSBpZiAoIWNvbmZpZy5heGlzX3lfc2hvdyB8fCBjb25maWcuYXhpc195X2lubmVyKSB7IC8vICYmICFjb25maWcuYXhpc19yb3RhdGVkXG5cdFx0XHRwYWRkaW5nID0gJCQuYXhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKS5pc091dGVyID8gMzAgOiAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYWRkaW5nID0gY2VpbDEwKGF4aXNXaWR0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoYXhpc1dpZHRoICogYXhlc0xlbik7XG5cdH0sXG5cblx0Z2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gMTA7XG5cdFx0Y29uc3QgbGVnZW5kV2lkdGhPblJpZ2h0ID0gJCQuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgKyAyMCA6IDA7XG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGF4aXNXaWR0aCA9ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKFwieTJcIik7XG5cdFx0bGV0IHBhZGRpbmc7XG5cblx0XHRpZiAoaXNWYWx1ZShjb25maWcucGFkZGluZ19yaWdodCkpIHtcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19yaWdodCArIDE7IC8vIDEgaXMgbmVlZGVkIG5vdCB0byBoaWRlIHRpY2sgbGluZVxuXHRcdH0gZWxzZSBpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoIWNvbmZpZy5heGlzX3kyX3Nob3cgfHwgY29uZmlnLmF4aXNfeTJfaW5uZXIpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcblx0XHRcdHBhZGRpbmcgPSAyICsgbGVnZW5kV2lkdGhPblJpZ2h0ICtcblx0XHRcdFx0KCQkLmF4aXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpLmlzT3V0ZXIgPyAyMCA6IDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYWRkaW5nID0gY2VpbDEwKGF4aXNXaWR0aCkgKyBsZWdlbmRXaWR0aE9uUmlnaHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoYXhpc1dpZHRoICogYXhlc0xlbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcGFyZW50IHJlY3QgZWxlbWVudCdzIHNpemVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleSBwcm9wZXJ0eS9hdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UGFyZW50UmVjdFZhbHVlKGtleSkge1xuXHRcdGNvbnN0IG9mZnNldE5hbWUgPSBgb2Zmc2V0JHtjYXBpdGFsaXplKGtleSl9YDtcblx0XHRsZXQgcGFyZW50ID0gdGhpcy5zZWxlY3RDaGFydC5ub2RlKCk7XG5cdFx0bGV0IHY7XG5cblx0XHR3aGlsZSAoIXYgJiYgcGFyZW50ICYmIHBhcmVudC50YWdOYW1lICE9PSBcIkJPRFlcIikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0diA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAob2Zmc2V0TmFtZSBpbiBwYXJlbnQpIHtcblx0XHRcdFx0XHQvLyBJbiBJRSBpbiBjZXJ0YWluIGNhc2VzIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0XHRcdC8vIHdpbGwgY2F1c2UgYW4gXCJ1bnNwZWNpZmllZCBlcnJvclwiXG5cdFx0XHRcdFx0diA9IHBhcmVudFtvZmZzZXROYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSBcIndpZHRoXCIpIHtcblx0XHRcdC8vIFNvbWV0aW1lcyBlbGVtZW50J3Mgd2lkdGggdmFsdWUgaXMgaW5jb3JyZWN0KGV4LiBmbGV4IGNvbnRhaW5lcilcblx0XHRcdC8vIEluIHRoaXMgY2FzZSwgdXNlIGJvZHkncyBvZmZzZXRXaWR0aCBpbnN0ZWFkLlxuXHRcdFx0Y29uc3QgYm9keVdpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcblxuXHRcdFx0diA+IGJvZHlXaWR0aCAmJiAodiA9IGJvZHlXaWR0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cblx0Z2V0UGFyZW50V2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGFyZW50UmVjdFZhbHVlKFwid2lkdGhcIik7XG5cdH0sXG5cblx0Z2V0UGFyZW50SGVpZ2h0KCkge1xuXHRcdGNvbnN0IGggPSB0aGlzLnNlbGVjdENoYXJ0LnN0eWxlKFwiaGVpZ2h0XCIpO1xuXG5cdFx0cmV0dXJuIGguaW5kZXhPZihcInB4XCIpID4gMCA/IHBhcnNlSW50KGgsIDEwKSA6IDA7XG5cdH0sXG5cblx0Z2V0U3ZnTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBoYXNMZWZ0QXhpc1JlY3QgPSBjb25maWcuYXhpc19yb3RhdGVkIHx8ICghY29uZmlnLmF4aXNfcm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeV9pbm5lcik7XG5cdFx0Y29uc3QgbGVmdEF4aXNDbGFzcyA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBDTEFTUy5heGlzWCA6IENMQVNTLmF4aXNZO1xuXHRcdGNvbnN0IGxlZnRBeGlzID0gJCQubWFpbi5zZWxlY3QoYC4ke2xlZnRBeGlzQ2xhc3N9YCkubm9kZSgpO1xuXHRcdGNvbnN0IHN2Z1JlY3QgPSBsZWZ0QXhpcyAmJiBoYXNMZWZ0QXhpc1JlY3QgPyBsZWZ0QXhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtyaWdodDogMH07XG5cdFx0Y29uc3QgY2hhcnRSZWN0ID0gJCQuc2VsZWN0Q2hhcnQubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcblx0XHRjb25zdCBzdmdMZWZ0ID0gc3ZnUmVjdC5yaWdodCAtIGNoYXJ0UmVjdC5sZWZ0IC1cblx0XHRcdChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGUpKTtcblxuXHRcdHJldHVybiBzdmdMZWZ0ID4gMCA/IHN2Z0xlZnQgOiAwO1xuXHR9LFxuXG5cdGdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB3aXRob3V0UmVjb21wdXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCk7XG5cblx0XHRyZXR1cm4gJCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQsIHdpdGhvdXRSZWNvbXB1dGUpICtcblx0XHRcdChwb3NpdGlvbi5pc0lubmVyID8gMjAgOiA0MCk7XG5cdH0sXG5cblx0Z2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IGggPSAzMDtcblxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgIWNvbmZpZy5heGlzX3hfc2hvdykge1xuXHRcdFx0cmV0dXJuIDg7XG5cdFx0fVxuXG5cdFx0aWYgKGlkID09PSBcInhcIiAmJiBjb25maWcuYXhpc194X2hlaWdodCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmIChpZCA9PT0gXCJ5XCIgJiYgIWNvbmZpZy5heGlzX3lfc2hvdykge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5sZWdlbmRfc2hvdyAmJlxuXHRcdFx0XHQhJCQuaXNMZWdlbmRSaWdodCAmJlxuXHRcdFx0XHQhJCQuaXNMZWdlbmRJbnNldCA/IDEwIDogMTtcblx0XHR9XG5cblx0XHRpZiAoaWQgPT09IFwieTJcIiAmJiAhY29uZmlnLmF4aXNfeTJfc2hvdykge1xuXHRcdFx0cmV0dXJuICQkLnJvdGF0ZWRfcGFkZGluZ190b3A7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHgveSBheGlzIGhlaWdodCB3aGVuIHRpY2sgcm90YXRlZFxuXHRcdGlmICgoaWQgPT09IFwieFwiICYmICFpc1JvdGF0ZWQgJiYgY29uZmlnLmF4aXNfeF90aWNrX3JvdGF0ZSkgfHxcblx0XHRcdChpZCA9PT0gXCJ5XCIgJiYgaXNSb3RhdGVkICYmIGNvbmZpZy5heGlzX3lfdGlja19yb3RhdGUpKSB7XG5cdFx0XHRoID0gMzAgK1xuXHRcdFx0XHQkJC5heGlzLmdldE1heFRpY2tXaWR0aChpZCkgKlxuXHRcdFx0XHRNYXRoLmNvcyhNYXRoLlBJICogKDkwIC0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfcm90YXRlYF0pIC8gMTgwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaCArXG5cdFx0XHQoJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCkuaXNJbm5lciA/IDAgOiAxMCkgK1xuXHRcdFx0KGlkID09PSBcInkyXCIgJiYgIWlzUm90YXRlZCA/IC0xMCA6IDApO1xuXHR9LFxuXG5cdGdldEV2ZW50UmVjdFdpZHRoKCkge1xuXHRcdHJldHVybiBNYXRoLm1heCgwLCB0aGlzLnhBeGlzLnRpY2tJbnRlcnZhbCgpKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRjdXJ2ZVN0ZXBCZWZvcmUgYXMgZDNDdXJ2ZVN0ZXBCZWZvcmUsXG5cdGN1cnZlU3RlcEFmdGVyIGFzIGQzQ3VydmVTdGVwQWZ0ZXIsXG5cdGN1cnZlQmFzaXNDbG9zZWQgYXMgZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxuXHRjdXJ2ZUJhc2lzT3BlbiBhcyBkM0N1cnZlQmFzaXNPcGVuLFxuXHRjdXJ2ZUJhc2lzIGFzIGQzQ3VydmVCYXNpcyxcblx0Y3VydmVCdW5kbGUgYXMgZDNDdXJ2ZUJ1bmRsZSxcblx0Y3VydmVDYXJkaW5hbENsb3NlZCBhcyBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXG5cdGN1cnZlQ2FyZGluYWxPcGVuIGFzIGQzQ3VydmVDYXJkaW5hbE9wZW4sXG5cdGN1cnZlQ2FyZGluYWwgYXMgZDNDdXJ2ZUNhcmRpbmFsLFxuXHRjdXJ2ZUNhdG11bGxSb21DbG9zZWQgYXMgZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXG5cdGN1cnZlQ2F0bXVsbFJvbU9wZW4gYXMgZDNDdXJ2ZUNhdG11bGxSb21PcGVuLFxuXHRjdXJ2ZUNhdG11bGxSb20gYXMgZDNDdXJ2ZUNhdG11bGxSb20sXG5cdGN1cnZlTGluZWFyQ2xvc2VkIGFzIGQzQ3VydmVMaW5lYXJDbG9zZWQsXG5cdGN1cnZlTGluZWFyIGFzIGQzQ3VydmVMaW5lYXIsXG5cdGN1cnZlTW9ub3RvbmVYIGFzIGQzQ3VydmVNb25vdG9uZVgsXG5cdGN1cnZlTW9ub3RvbmVZIGFzIGQzQ3VydmVNb25vdG9uZVksXG5cdGN1cnZlTmF0dXJhbCBhcyBkM0N1cnZlTmF0dXJhbCxcblx0Y3VydmVTdGVwIGFzIGQzQ3VydmVTdGVwXG59IGZyb20gXCJkMy1zaGFwZVwiO1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmQsIGlzT2JqZWN0VHlwZSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBub3RFbXB0eX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZXRTaGFwZUluZGljZXModHlwZUZpbHRlcikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IHt9O1xuXHRcdGxldCBpID0gMDtcblxuXHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKVxuXHRcdCkuZm9yRWFjaChkID0+IHtcblx0XHRcdGZvciAobGV0IGogPSAwLCBncm91cHM7IChncm91cHMgPSBjb25maWcuZGF0YV9ncm91cHNbal0pOyBqKyspIHtcblx0XHRcdFx0aWYgKGdyb3Vwcy5pbmRleE9mKGQuaWQpIDwgMCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChsZXQgayA9IDAsIHJvdzsgKHJvdyA9IGdyb3Vwc1trXSk7IGsrKykge1xuXHRcdFx0XHRcdGlmIChyb3cgaW4gaW5kaWNlcykge1xuXHRcdFx0XHRcdFx0aW5kaWNlc1tkLmlkXSA9IGluZGljZXNbcm93XTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQoaW5kaWNlc1tkLmlkXSkpIHtcblx0XHRcdFx0aW5kaWNlc1tkLmlkXSA9IGkrKztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGluZGljZXMuX19tYXhfXyA9IGkgLSAxO1xuXG5cdFx0cmV0dXJuIGluZGljZXM7XG5cdH0sXG5cblx0Z2V0U2hhcGVYKG9mZnNldCwgdGFyZ2V0c051bSwgaW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLnN1YlggOiAoJCQuem9vbVNjYWxlIHx8ICQkLngpO1xuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSAkJC5jb25maWcuYmFyX3BhZGRpbmc7XG5cdFx0Y29uc3Qgc3VtID0gKHAsIGMpID0+IHAgKyBjO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcblxuXHRcdHJldHVybiBkID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmRpY2VzID8gaW5kaWNlc1tkLmlkXSA6IDA7XG5cdFx0XHRsZXQgeCA9IDA7XG5cblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XG5cdFx0XHRcdGNvbnN0IHhQb3MgPSBzY2FsZShkLngpO1xuXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXG5cdFx0XHRcdFx0XHRvZmZzZXQudG90YWwuc2xpY2UoMCwgaW5kZXggKyAxKS5yZWR1Y2Uoc3VtKSAtXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHhQb3MgLSAoaXNOdW1iZXIob2Zmc2V0KSA/IG9mZnNldCA6IG9mZnNldC53aWR0aCkgKiAodGFyZ2V0c051bSAvIDIgLSBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0c051bSA9PT0gMikge1xuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRTaGFwZVkoaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xuXG5cdFx0cmV0dXJuIGQgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBpc1N0YWNrTm9ybWFsaXplZCA/ICQkLmdldFJhdGlvKFwiaW5kZXhcIiwgZCwgdHJ1ZSkgOiAoXG5cdFx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInlcIikgOiBkLnZhbHVlXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gKGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpKSh2YWx1ZSk7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRTaGFwZU9mZnNldCh0eXBlRmlsdGVyLCBpbmRpY2VzLCBpc1N1Yikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpKTtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSB0YXJnZXRzLm1hcCh0ID0+IHQuaWQpO1xuXG5cdFx0cmV0dXJuIChkLCBpZHgpID0+IHtcblx0XHRcdGNvbnN0IHNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUoZC5pZCkgOiAkJC5nZXRZU2NhbGUoZC5pZCk7XG5cdFx0XHRjb25zdCB5MCA9IHNjYWxlKDApO1xuXHRcdFx0bGV0IG9mZnNldCA9IHkwO1xuXHRcdFx0bGV0IGkgPSBpZHg7XG5cblx0XHRcdHRhcmdldHNcblx0XHRcdFx0LmZvckVhY2godCA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgcm93VmFsdWVzID0gJCQuaXNTdGVwVHlwZShkKSA/ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodC52YWx1ZXMpIDogdC52YWx1ZXM7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gcm93VmFsdWVzLm1hcCh2ID0+ICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCB2LCB0cnVlKSA6IHYudmFsdWUpKTtcblxuXHRcdFx0XHRcdGlmICh0LmlkID09PSBkLmlkIHx8IGluZGljZXNbdC5pZF0gIT09IGluZGljZXNbZC5pZF0pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGFyZ2V0SWRzLmluZGV4T2YodC5pZCkgPCB0YXJnZXRJZHMuaW5kZXhPZihkLmlkKSkge1xuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHggdmFsdWVzIGxpbmUgdXBcblx0XHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChyb3dWYWx1ZXNbaV0pIHx8ICtyb3dWYWx1ZXNbaV0ueCAhPT0gK2QueCkgeyAvLyBcIitcIiBmb3IgdGltZXNlcmllc1xuXHRcdFx0XHRcdFx0XHQvLyBpZiBub3QsIHRyeSB0byBmaW5kIHRoZSB2YWx1ZSB0aGF0IGRvZXMgbGluZSB1cFxuXHRcdFx0XHRcdFx0XHRpID0gLTE7XG5cblx0XHRcdFx0XHRcdFx0cm93VmFsdWVzLmZvckVhY2goKHYsIGopID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB4MSA9IHYueC5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/ICt2LnggOiB2Lng7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgeDIgPSBkLnguY29uc3RydWN0b3IgPT09IERhdGUgPyArZC54IDogZC54O1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHgxID09PSB4Mikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSA9IGo7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGkgaW4gcm93VmFsdWVzICYmIHJvd1ZhbHVlc1tpXS52YWx1ZSAqIGQudmFsdWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gc2NhbGUodmFsdWVzW2ldKSAtIHkwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fTtcblx0fSxcblxuXHRpc1dpdGhpblNoYXBlKHRoYXQsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcblx0XHRsZXQgaXNXaXRoaW47XG5cblx0XHRpZiAoISQkLmlzVGFyZ2V0VG9TaG93KGQuaWQpKSB7XG5cdFx0XHRpc1dpdGhpbiA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVmFsaWRQb2ludFR5cGUodGhhdC5ub2RlTmFtZSkpIHtcblx0XHRcdGlzV2l0aGluID0gJCQuaXNTdGVwVHlwZShkKSA/XG5cdFx0XHRcdCQkLmlzV2l0aGluU3RlcCh0aGF0LCAkJC5nZXRZU2NhbGUoZC5pZCkoZC52YWx1ZSkpIDpcblx0XHRcdFx0JCQuaXNXaXRoaW5DaXJjbGUodGhhdCwgJCQuaXNCdWJibGVUeXBlKGQpID8gJCQucG9pbnRTZWxlY3RSKGQpICogMS41IDogMCk7XG5cdFx0fSBlbHNlIGlmICh0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIikge1xuXHRcdFx0aXNXaXRoaW4gPSBzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikgPyAkJC5pc1dpdGhpbkJhcih0aGF0KSA6IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlzV2l0aGluO1xuXHR9LFxuXG5cdGdldEludGVycG9sYXRlKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmdldEludGVycG9sYXRlVHlwZShkKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRcImJhc2lzXCI6IGQzQ3VydmVCYXNpcyxcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCI6IGQzQ3VydmVCYXNpc0Nsb3NlZCxcblx0XHRcdFwiYmFzaXMtb3BlblwiOiBkM0N1cnZlQmFzaXNPcGVuLFxuXHRcdFx0XCJidW5kbGVcIjogZDNDdXJ2ZUJ1bmRsZSxcblx0XHRcdFwiY2FyZGluYWxcIjogZDNDdXJ2ZUNhcmRpbmFsLFxuXHRcdFx0XCJjYXJkaW5hbC1jbG9zZWRcIjogZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxuXHRcdFx0XCJjYXJkaW5hbC1vcGVuXCI6IGQzQ3VydmVDYXJkaW5hbE9wZW4sXG5cdFx0XHRcImNhdG11bGwtcm9tXCI6IGQzQ3VydmVDYXRtdWxsUm9tLFxuXHRcdFx0XCJjYXRtdWxsLXJvbS1jbG9zZWRcIjogZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIjogZDNDdXJ2ZUNhdG11bGxSb21PcGVuLFxuXHRcdFx0XCJtb25vdG9uZS14XCI6IGQzQ3VydmVNb25vdG9uZVgsXG5cdFx0XHRcIm1vbm90b25lLXlcIjogZDNDdXJ2ZU1vbm90b25lWSxcblx0XHRcdFwibmF0dXJhbFwiOiBkM0N1cnZlTmF0dXJhbCxcblx0XHRcdFwibGluZWFyLWNsb3NlZFwiOiBkM0N1cnZlTGluZWFyQ2xvc2VkLFxuXHRcdFx0XCJsaW5lYXJcIjogZDNDdXJ2ZUxpbmVhcixcblx0XHRcdFwic3RlcFwiOiBkM0N1cnZlU3RlcCxcblx0XHRcdFwic3RlcC1hZnRlclwiOiBkM0N1cnZlU3RlcEFmdGVyLFxuXHRcdFx0XCJzdGVwLWJlZm9yZVwiOiBkM0N1cnZlU3RlcEJlZm9yZVxuXHRcdH1baW50ZXJwb2xhdGlvbl07XG5cdH0sXG5cblx0Z2V0SW50ZXJwb2xhdGVUeXBlKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZSA9ICQkLmNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlO1xuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5pc0ludGVycG9sYXRpb25UeXBlKHR5cGUpID8gdHlwZSA6IFwiY2FyZGluYWxcIjtcblxuXHRcdHJldHVybiAkJC5pc1NwbGluZVR5cGUoZCkgP1xuXHRcdFx0aW50ZXJwb2xhdGlvbiA6IChcblx0XHRcdFx0JCQuaXNTdGVwVHlwZShkKSA/XG5cdFx0XHRcdFx0JCQuY29uZmlnLmxpbmVfc3RlcF90eXBlIDogXCJsaW5lYXJcIlxuXHRcdFx0KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdGV2ZW50IGFzIGQzRXZlbnRcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtcblx0YXJjIGFzIGQzQXJjLFxuXHRwaWUgYXMgZDNQaWVcbn0gZnJvbSBcImQzLXNoYXBlXCI7XG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGQzSW50ZXJwb2xhdGV9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vaW50ZXJuYWxzL2Jyb3dzZXJcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UGllKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcblxuXHRcdGNvbnN0IHBhZEFuZ2xlID0gJCQuaGFzVHlwZShcInBpZVwiKSAmJiBwYWRkaW5nID9cblx0XHRcdHBhZGRpbmcgKiAwLjAxIDogY29uZmlnW2Ake2NvbmZpZy5kYXRhX3R5cGV9X3BhZEFuZ2xlYF0gP1xuXHRcdFx0XHRjb25maWdbYCR7Y29uZmlnLmRhdGFfdHlwZX1fcGFkQW5nbGVgXSA6IDA7XG5cblx0XHQkJC5waWUgPSBkM1BpZSgpXG5cdFx0XHQucGFkQW5nbGUocGFkQW5nbGUpXG5cdFx0XHQuc29ydFZhbHVlcyhcblx0XHRcdFx0JCQuaXNPcmRlckFzYygpIHx8ICQkLmlzT3JkZXJEZXNjKCkgP1xuXHRcdFx0XHRcdChhLCBiKSA9PiAoJCQuaXNPcmRlckFzYygpID8gYSAtIGIgOiBiIC0gYSkgOiBudWxsXG5cdFx0XHQpXG5cdFx0XHQudmFsdWUoZCA9PiBkLnZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSk7XG5cdH0sXG5cblx0dXBkYXRlUmFkaXVzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnBpZV9pbm5lclJhZGl1cztcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nO1xuXHRcdGNvbnN0IHcgPSBjb25maWcuZ2F1Z2Vfd2lkdGggfHwgY29uZmlnLmRvbnV0X3dpZHRoO1xuXG5cdFx0JCQucmFkaXVzRXhwYW5kZWQgPSBNYXRoLm1pbigkJC5hcmNXaWR0aCwgJCQuYXJjSGVpZ2h0KSAvIDI7XG5cdFx0JCQucmFkaXVzID0gJCQucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xuXHRcdCQkLmlubmVyUmFkaXVzUmF0aW8gPSB3ID8gKCQkLnJhZGl1cyAtIHcpIC8gJCQucmFkaXVzIDogMC42O1xuXG5cdFx0Y29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgfHwgKFxuXHRcdFx0cGFkZGluZyA/IHBhZGRpbmcgKiAoJCQuaW5uZXJSYWRpdXNSYXRpbyArIDAuMSkgOiAwXG5cdFx0KTtcblxuXHRcdC8vIE5PVEU6IGlubmVyUmFkaXVzIGNhbiBiZSBhbiBvYmplY3QgYnkgdXNlciBzZXR0aW5nLCBvbmx5IGZvciAncGllJyB0eXBlXG5cdFx0JCQuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cblx0XHRcdCQkLnJhZGl1cyAqICQkLmlubmVyUmFkaXVzUmF0aW8gOiBpbm5lclJhZGl1cztcblx0fSxcblxuXHRnZXRJbm5lclJhZGl1cyhkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCByYWRpdXMgPSAkJC5pbm5lclJhZGl1cztcblxuXHRcdGlmICghaXNOdW1iZXIocmFkaXVzKSAmJiBkKSB7XG5cdFx0XHRyYWRpdXMgPSByYWRpdXNbZC5kYXRhLmlkXSB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiByYWRpdXM7XG5cdH0sXG5cblx0dXBkYXRlQXJjKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpO1xuXHRcdCQkLnN2Z0FyY0V4cGFuZGVkID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoKTtcblx0XHQkJC5zdmdBcmNFeHBhbmRlZFN1YiA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKDAuOTgpO1xuXHR9LFxuXG5cdHVwZGF0ZUFuZ2xlKGRWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IHBpZSA9ICQkLnBpZTtcblx0XHRsZXQgZCA9IGRWYWx1ZTtcblx0XHRsZXQgZm91bmQgPSBmYWxzZTtcblxuXHRcdGlmICghY29uZmlnKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkpIHtcblx0XHRcdGNvbnN0IHRvdGFsU3VtID0gJCQuZ2V0VG90YWxEYXRhU3VtKCk7XG5cblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gdG90YWxTdW0sIG1ha2UgdG90YWxTdW0gdG8gbWF4IHZhbHVlXG5cdFx0XHRpZiAodG90YWxTdW0gPiBjb25maWcuZ2F1Z2VfbWF4KSB7XG5cdFx0XHRcdGNvbmZpZy5nYXVnZV9tYXggPSB0b3RhbFN1bTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gTWF0aC5QSSAqIChjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDIgOiAxKTtcblx0XHRcdGNvbnN0IGdTdGFydCA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXHRcdFx0Y29uc3QgZ0VuZCA9IHJhZGl1cyAqICh0b3RhbFN1bSAvIChjb25maWcuZ2F1Z2VfbWF4IC0gY29uZmlnLmdhdWdlX21pbikpO1xuXG5cdFx0XHRwaWUgPSAkJC5waWVcblx0XHRcdFx0LnN0YXJ0QW5nbGUoZ1N0YXJ0KVxuXHRcdFx0XHQuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XG5cdFx0fVxuXG5cdFx0cGllKCQkLmZpbHRlclRhcmdldHNUb1Nob3coKSkuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGlmICghZm91bmQgJiYgdC5kYXRhLmlkID09PSBkLmRhdGEuaWQpIHtcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRkID0gdDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChpc05hTihkLnN0YXJ0QW5nbGUpKSB7XG5cdFx0XHRkLnN0YXJ0QW5nbGUgPSAwO1xuXHRcdH1cblxuXHRcdGlmIChpc05hTihkLmVuZEFuZ2xlKSkge1xuXHRcdFx0ZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm91bmQgPyBkIDogbnVsbDtcblx0fSxcblxuXHRnZXRTdmdBcmMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlyID0gJCQuZ2V0SW5uZXJSYWRpdXMoKTtcblx0XHRsZXQgYXJjID0gZDNBcmMoKVxuXHRcdFx0Lm91dGVyUmFkaXVzKCQkLnJhZGl1cylcblx0XHRcdC5pbm5lclJhZGl1cyhpc051bWJlcihpcikgPyBpciA6IDApO1xuXG5cdFx0Y29uc3QgbmV3QXJjID0gKGQsIHdpdGhvdXRVcGRhdGUpID0+IHtcblx0XHRcdGxldCBwYXRoID0gXCJNIDAgMFwiO1xuXG5cdFx0XHRpZiAoZC52YWx1ZSB8fCBkLmRhdGEpIHtcblx0XHRcdFx0aWYgKCFpc051bWJlcihpcikpIHtcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXG5cdFx0XHRcdGlmICh3aXRob3V0VXBkYXRlKSB7XG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcblx0XHRcdFx0fSBlbHNlIGlmICh1cGRhdGVkKSB7XG5cdFx0XHRcdFx0cGF0aCA9IGFyYyh1cGRhdGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9O1xuXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cblx0XHRuZXdBcmMuY2VudHJvaWQgPSBhcmMuY2VudHJvaWQ7XG5cblx0XHRyZXR1cm4gbmV3QXJjO1xuXHR9LFxuXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYXJjID0gZDNBcmMoKVxuXHRcdFx0Lm91dGVyUmFkaXVzKCQkLnJhZGl1c0V4cGFuZGVkICogKHJhdGUgfHwgMSkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblxuXHRcdFx0cmV0dXJuIHVwZGF0ZWQgPyBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpKHVwZGF0ZWQpIDogXCJNIDAgMFwiO1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJjKGQsIHdpdGhvdXRVcGRhdGUsIGZvcmNlKSB7XG5cdFx0cmV0dXJuIGZvcmNlIHx8IHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyB0aGlzLnN2Z0FyYyhkLCB3aXRob3V0VXBkYXRlKSA6IFwiTSAwIDBcIjtcblx0fSxcblxuXHR0cmFuc2Zvcm1Gb3JBcmNMYWJlbChkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0bGV0IHRyYW5zbGF0ZSA9IFwiXCI7XG5cblx0XHRpZiAodXBkYXRlZCAmJiAoISQkLmhhc1R5cGUoXCJnYXVnZVwiKSB8fCAkJC5oYXNNdWx0aVRhcmdldHMoKSkpIHtcblx0XHRcdGNvbnN0IGMgPSB0aGlzLnN2Z0FyYy5jZW50cm9pZCh1cGRhdGVkKTtcblx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xuXHRcdFx0Y29uc3QgeSA9IGlzTmFOKGNbMV0pID8gMCA6IGNbMV07XG5cdFx0XHRjb25zdCBoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG5cdFx0XHRsZXQgcmF0aW8gPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbykgfHxcblx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XG5cblx0XHRcdGlmIChyYXRpbykge1xuXHRcdFx0XHRyYXRpbyA9IGlzRnVuY3Rpb24ocmF0aW8pID8gcmF0aW8oZCwgJCQucmFkaXVzLCBoKSA6IHJhdGlvO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmF0aW8gPSAkJC5yYWRpdXMgJiZcblx0XHRcdFx0XHQoaCA/ICgzNiAvICQkLnJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvICQkLnJhZGl1cyA6IDAuOCkgKiAkJC5yYWRpdXMgLyBoIDogMCk7XG5cdFx0XHR9XG5cblx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cmFuc2xhdGU7XG5cdH0sXG5cblx0Y29udmVydFRvQXJjRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkTmFtZSh7XG5cdFx0XHRpZDogZC5kYXRhLmlkLFxuXHRcdFx0dmFsdWU6IGQudmFsdWUsXG5cdFx0XHRyYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcblx0XHRcdGluZGV4OiBkLmluZGV4LFxuXHRcdH0pO1xuXHR9LFxuXG5cdHRleHRGb3JBcmNMYWJlbChzZWxlY3Rpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuc2hvdWxkU2hvd0FyY0xhYmVsKCkpIHtcblx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdXBkYXRlZCA/IHVwZGF0ZWQudmFsdWUgOiBudWxsO1xuXHRcdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldFJhdGlvKFwiYXJjXCIsIHVwZGF0ZWQpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YS5pZDtcblx0XHRcdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XG5cdFx0XHRcdGNvbnN0IGlzVW5kZXJUaHJlc2hvbGQgPSAhKFxuXHRcdFx0XHRcdCFoYXNHYXVnZSAmJiAhJCQubWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbylcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoaXNVbmRlclRocmVzaG9sZCkge1xuXHRcdFx0XHRcdGNvbnN0IHRleHQgPSAoXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxuXHRcdFx0XHRcdCkodmFsdWUsIHJhdGlvLCBpZCkudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRcdHNldFRleHRWYWx1ZShub2RlLCB0ZXh0LCBbLTEsIDFdLCBoYXNHYXVnZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHR0ZXh0Rm9yR2F1Z2VNaW5NYXgodmFsdWUsIGlzTWF4KSB7XG5cdFx0Y29uc3QgZm9ybWF0ID0gdGhpcy5nZXRHYXVnZUxhYmVsRXh0ZW50cygpO1xuXG5cdFx0cmV0dXJuIGZvcm1hdCA/IGZvcm1hdCh2YWx1ZSwgaXNNYXgpIDogdmFsdWU7XG5cdH0sXG5cblx0ZXhwYW5kQXJjKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdC8vIE1FTU86IGF2b2lkIHRvIGNhbmNlbCB0cmFuc2l0aW9uXG5cdFx0aWYgKCQkLnRyYW5zaXRpbmcpIHtcblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0XHRpZiAoISQkLnRyYW5zaXRpbmcpIHtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKGludGVydmFsKTtcblxuXHRcdFx0XHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkfWApLnNpemUoKSA+IDAgJiZcblx0XHRcdFx0XHRcdCQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxMCk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGlmICghJCQuc2hvdWxkRXhwYW5kKGQuZGF0YS5pZCkgfHwgZC52YWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGV4cGFuZER1cmF0aW9uID0gJCQuZXhwYW5kRHVyYXRpb24oZC5kYXRhLmlkKTtcblxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJwYXRoXCIpXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5kdXJhdGlvbihleHBhbmREdXJhdGlvbilcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5kdXJhdGlvbihleHBhbmREdXJhdGlvbiAqIDIpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyY0V4cGFuZGVkU3ViKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdHVuZXhwYW5kQXJjKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICgkJC50cmFuc2l0aW5nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxuXHRcdFx0LnNlbGVjdEFsbChcInBhdGhcIilcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkID0+ICQkLmV4cGFuZER1cmF0aW9uKGQuZGF0YS5pZCkpXG5cdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjKTtcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoYCR7Q0xBU1MuYXJjfWApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHRleHBhbmREdXJhdGlvbihpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IHR5cGU7XG5cblx0XHRpZiAoJCQuaXNEb251dFR5cGUoaWQpKSB7XG5cdFx0XHR0eXBlID0gXCJkb251dFwiO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNHYXVnZVR5cGUoaWQpKSB7XG5cdFx0XHR0eXBlID0gXCJnYXVnZVwiO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNQaWVUeXBlKGlkKSkge1xuXHRcdFx0dHlwZSA9IFwicGllXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHR5cGUgPyBjb25maWdbYCR7dHlwZX1fZXhwYW5kX2R1cmF0aW9uYF0gOiA1MDtcblx0fSxcblxuXHRzaG91bGRFeHBhbmQoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuICgkJC5pc0RvbnV0VHlwZShpZCkgJiYgY29uZmlnLmRvbnV0X2V4cGFuZCkgfHxcblx0XHRcdCgkJC5pc0dhdWdlVHlwZShpZCkgJiYgY29uZmlnLmdhdWdlX2V4cGFuZCkgfHxcblx0XHRcdCgkJC5pc1BpZVR5cGUoaWQpICYmIGNvbmZpZy5waWVfZXhwYW5kKTtcblx0fSxcblxuXHRzaG91bGRTaG93QXJjTGFiZWwoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdHJldHVybiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCJdXG5cdFx0XHQuc29tZSh2ID0+ICQkLmhhc1R5cGUodikgJiYgY29uZmlnW2Ake3Z9X2xhYmVsX3Nob3dgXSk7XG5cdH0sXG5cblx0bWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGhyZXNob2xkID0gJCQuaGFzVHlwZShcImRvbnV0XCIpID8gY29uZmlnLmRvbnV0X2xhYmVsX3RocmVzaG9sZCA6IGNvbmZpZy5waWVfbGFiZWxfdGhyZXNob2xkO1xuXG5cdFx0cmV0dXJuIHJhdGlvID49IHRocmVzaG9sZDtcblx0fSxcblxuXHRnZXRBcmNMYWJlbEZvcm1hdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBmb3JtYXQgPSBjb25maWcucGllX2xhYmVsX2Zvcm1hdDtcblxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5nYXVnZV9sYWJlbF9mb3JtYXQ7XG5cdFx0fSBlbHNlIGlmICgkJC5oYXNUeXBlKFwiZG9udXRcIikpIHtcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5kb251dF9sYWJlbF9mb3JtYXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcm1hdDtcblx0fSxcblxuXHRnZXRHYXVnZUxhYmVsRXh0ZW50cygpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdHJldHVybiBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcblx0fSxcblxuXHRnZXRBcmNUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZSA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgXCJkb251dFwiKSB8fCAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmIFwiZ2F1Z2VcIik7XG5cblx0XHRyZXR1cm4gdHlwZSA/ICQkLmNvbmZpZ1tgJHt0eXBlfV90aXRsZWBdIDogXCJcIjtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XG5cdFx0Y29uc3QgY2xhc3NDaGFydEFyYyA9ICQkLmNsYXNzQ2hhcnRBcmMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NBcmNzID0gJCQuY2xhc3NBcmNzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IG1haW5QaWVVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEFyY31gKVxuXHRcdFx0LmRhdGEoJCQucGllKHRhcmdldHMpKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRBcmMoZCkgKyBjbGFzc0ZvY3VzKGQuZGF0YSkpO1xuXG5cdFx0Y29uc3QgbWFpblBpZUVudGVyID0gbWFpblBpZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEFyYyk7XG5cblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyY3MpXG5cdFx0XHQubWVyZ2UobWFpblBpZVVwZGF0ZSk7XG5cblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJkeVwiLCBoYXNHYXVnZSAmJiAhJCQuaGFzTXVsdGlUYXJnZXRzKCkgPyBcIi0uMWVtXCIgOiBcIi4zNWVtXCIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblx0XHQvLyBNRU1POiBjYW4gbm90IGtlZXAgc2FtZSBjb2xvci4uLiwgYnV0IG5vdCBiYWQgdG8gdXBkYXRlIGNvbG9yIGluIHJlZHJhd1xuXHRcdC8vIG1haW5QaWVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGluaXRBcmMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuYXJjcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcblxuXHRcdCQkLnNldEFyY1RpdGxlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhcmMgdGl0bGUgdGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0QXJjVGl0bGUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRpdGxlID0gJCQuZ2V0QXJjVGl0bGUoKTtcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcblxuXHRcdGlmICh0aXRsZSkge1xuXHRcdFx0Y29uc3QgdGV4dCA9ICQkLmFyY3MuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTW2hhc0dhdWdlID8gXCJjaGFydEFyY3NHYXVnZVRpdGxlXCIgOiBcImNoYXJ0QXJjc1RpdGxlXCJdKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcblxuXHRcdFx0aWYgKGhhc0dhdWdlKSB7XG5cdFx0XHRcdHRleHRcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLTAuM2VtXCIpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMjdweFwiKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIHRpdGxlLCBoYXNHYXVnZSA/IHVuZGVmaW5lZCA6IFstMC42LCAxLjM1XSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3aXRoVHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBoYXNJbnRlcmFjdGlvbiA9IGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkO1xuXG5cdFx0bGV0IG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfWApXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcblxuXHRcdG1haW5BcmMuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRtYWluQXJjID0gbWFpbkFyYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmMuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZC5kYXRhKSlcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChoYXNJbnRlcmFjdGlvbiAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGlmICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XG5cdFx0XHRcdFx0ZC5zdGFydEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XG5cdFx0XHRcdFx0ZC5lbmRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY3VycmVudCA9IGQ7XG5cdFx0XHR9KVxuXHRcdFx0Lm1lcmdlKG1haW5BcmMpO1xuXG5cdFx0bWFpbkFyY1xuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiAoISQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMClcIiA6IFwiXCIpKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdHJldHVybiBkID09PSB0aGlzLl9jdXJyZW50ID8gXCIwXCIgOiBcIjFcIjtcblx0XHRcdH0pXG5cdFx0XHQuZWFjaCgoKSA9PiB7XG5cdFx0XHRcdCQkLnRyYW5zaXRpbmcgPSB0cnVlO1xuXHRcdFx0fSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5hdHRyVHdlZW4oXCJkXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXG5cdFx0XHRcdGlmICghdXBkYXRlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiBcIk0gMCAwXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5zdGFydEFuZ2xlKSkge1xuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5lbmRBbmdsZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50LmVuZEFuZ2xlID0gdGhpcy5fY3VycmVudC5zdGFydEFuZ2xlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIHVwZGF0ZWQpO1xuXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKHQpO1xuXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVkLmRhdGEgPSBkLmRhdGE7IC8vIGRhdGEuaWQgd2lsbCBiZSB1cGRhdGVkIGJ5IGludGVycG9yYXRvclxuXHRcdFx0XHRcdHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgxKVwiIDogXCJcIilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiAoJCQubGV2ZWxDb2xvciA/XG5cdFx0XHRcdCQkLmxldmVsQ29sb3IoZC5kYXRhLnZhbHVlc1swXS52YWx1ZSkgOiAkJC5jb2xvcihkLmRhdGEuaWQpKVxuXHRcdFx0KVxuXHRcdFx0Ly8gV2hlcmUgZ2F1Z2UgcmVhZGluZyBjb2xvciB3b3VsZCByZWNlaXZlIGN1c3RvbWl6YXRpb24uXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCAoKSA9PiB7XG5cdFx0XHRcdCQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gYmluZCBhcmMgZXZlbnRzXG5cdFx0aGFzSW50ZXJhY3Rpb24gJiYgJCQuYmluZEFyY0V2ZW50KG1haW5BcmMpO1xuXG5cdFx0JCQucmVkcmF3QXJjVGV4dChkdXJhdGlvbik7XG5cdH0sXG5cblx0YmluZEFyY0V2ZW50KGFyYykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1RvdWNoID0gJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCI7XG5cdFx0Y29uc3QgaXNNb3VzZSA9ICQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xuXG5cdFx0ZnVuY3Rpb24gc2VsZWN0QXJjKF90aGlzLCBhcmNEYXRhLCBpZCkge1xuXHRcdFx0Ly8gdHJhbnNpdGlvbnNcblx0XHRcdCQkLmV4cGFuZEFyYyhpZCk7XG5cdFx0XHQkJC5hcGkuZm9jdXMoaWQpO1xuXHRcdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQoaWQsIHRydWUpO1xuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCBfdGhpcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YSkge1xuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdCQkLnVuZXhwYW5kQXJjKGlkKTtcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcblx0XHRcdCQkLnJldmVydExlZ2VuZCgpO1xuXHRcdFx0JCQuaGlkZVRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRhcmNcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXHRcdFx0XHRsZXQgYXJjRGF0YTtcblxuXHRcdFx0XHRpZiAodXBkYXRlZCkge1xuXHRcdFx0XHRcdGFyY0RhdGEgPSAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpO1xuXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUgJiYgJCQudG9nZ2xlU2hhcGUodGhpcywgYXJjRGF0YSwgaSk7XG5cdFx0XHRcdFx0JCQuY29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgYXJjRGF0YSwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0Ly8gbW91c2UgZXZlbnRzXG5cdFx0aWYgKGlzTW91c2UpIHtcblx0XHRcdGFyY1xuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdGlmICgkJC50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuXHRcdFx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KHRydWUsIGFyY0RhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcblx0XHRcdFx0XHRpZiAoJCQudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcblxuXHRcdFx0XHRcdHVuc2VsZWN0QXJjKCk7XG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XG5cblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyB0b3VjaCBldmVudHNcblx0XHRpZiAoaXNUb3VjaCAmJiAkJC5oYXNBcmNUeXBlKCkgJiYgISQkLnJhZGFycykge1xuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmMgPSBkM1NlbGVjdChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcblxuXHRcdFx0XHRyZXR1cm4gZXZlbnRBcmM7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICgkJC50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcblx0XHRcdFx0Y29uc3QgZGF0dW0gPSBldmVudEFyYy5kYXR1bSgpO1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGFyY0RhdGEpO1xuXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XG5cdFx0XHRcdFx0dW5zZWxlY3RBcmMoKSA6IHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQkJC5zdmdcblx0XHRcdFx0Lm9uKFwidG91Y2hzdGFydFwiLCBoYW5kbGVyKVxuXHRcdFx0XHQub24oXCJ0b3VjaG1vdmVcIiwgaGFuZGxlcik7XG5cdFx0fVxuXHR9LFxuXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuXG5cdFx0Y29uc3QgdGV4dCA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEFyY31gKVxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gKCQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgPyBDTEFTUy5nYXVnZVZhbHVlIDogbnVsbCkpXG5cdFx0XHQuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC50cmFuc2Zvcm1Gb3JBcmNMYWJlbC5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IGAke01hdGgucm91bmQoJCQucmFkaXVzIC8gNSl9cHhgIDogXCJcIikpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGQgPT4gKCQkLmlzVGFyZ2V0VG9TaG93KGQuZGF0YS5pZCkgJiYgJCQuaXNBcmNUeXBlKGQuZGF0YSkgPyBcIjFcIiA6IFwiMFwiKSk7XG5cblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzVGl0bGV9YClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaGFzVHlwZShcImRvbnV0XCIpIHx8IGhhc0dhdWdlID8gXCIxXCIgOiBcIjBcIik7XG5cblx0XHRpZiAoaGFzR2F1Z2UpIHtcblx0XHRcdGNvbnN0IGlzRnVsbENpcmNsZSA9IGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlO1xuXHRcdFx0Y29uc3QgZW5kQW5nbGUgPSAoaXNGdWxsQ2lyY2xlID8gLTQgOiAtMSkgKiBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcblxuXHRcdFx0aXNGdWxsQ2lyY2xlICYmIHRleHQuYXR0cihcImR5XCIsIGAke01hdGgucm91bmQoJCQucmFkaXVzIC8gMTQpfWApO1xuXG5cdFx0XHQkJC5hcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gKVxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGQgPSB7XG5cdFx0XHRcdFx0XHRkYXRhOiBbe3ZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4fV0sXG5cdFx0XHRcdFx0XHRzdGFydEFuZ2xlOiBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZSxcblx0XHRcdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0JCQuYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdH1gKVxuXHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLjc1ZW1cIilcblx0XHRcdFx0LnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKTtcblxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XG5cdFx0XHRcdCQkLmFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1pbn1gKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7LTEgKiAoJCQuaW5uZXJSYWRpdXMgKyAoKCQkLnJhZGl1cyAtICQkLmlubmVyUmFkaXVzKSAvIChjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDEgOiAyKSkpfXB4YClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcblx0XHRcdFx0XHQudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21pbiwgZmFsc2UpKTtcblxuXHRcdFx0XHQvLyBzaG93IG1heCB0ZXh0IHdoZW4gaXNuJ3QgZnVsbENpcmNsZVxuXHRcdFx0XHQhaXNGdWxsQ2lyY2xlICYmICQkLmFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1heH1gKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7JCQuaW5uZXJSYWRpdXMgKyAoKCQkLnJhZGl1cyAtICQkLmlubmVyUmFkaXVzKSAvIDIpfXB4YClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcblx0XHRcdFx0XHQudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21heCwgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbml0R2F1Z2UoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBhcmNzID0gJCQuYXJjcztcblx0XHRjb25zdCBhcHBlbmRUZXh0ID0gY2xhc3NOYW1lID0+IHtcblx0XHRcdGFyY3MuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXHRcdH07XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XG5cdFx0XHRhcmNzLmFwcGVuZChcInBhdGhcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcblxuXHRcdFx0Y29uZmlnLmdhdWdlX3VuaXRzICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0KTtcblxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XG5cdFx0XHRcdGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW4pO1xuXHRcdFx0XHQhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldEdhdWdlTGFiZWxIZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyAyMCA6IDA7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHttb3VzZSBhcyBkM01vdXNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRSYW5kb20sIGdldFJlY3RTZWdMaXN0LCBpc051bWJlciwgaXNPYmplY3RUeXBlLCBpc1ZhbHVlfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRCYXIoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcblx0XHRjb25zdCBtYWluQmFyVXBkYXRlID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QmFyc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcblx0XHRcdC5kYXRhKHRhcmdldHMpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydEJhcihkKSArIGNsYXNzRm9jdXMoZCkpO1xuXHRcdGNvbnN0IG1haW5CYXJFbnRlciA9IG1haW5CYXJVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXG5cdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXG5cdFx0bWFpbkJhckVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcblx0fSxcblxuXHR1cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGJhckRhdGEgPSAkJC5iYXJEYXRhLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCk7XG5cdFx0Y29uc3QgaW5pdGlhbE9wYWNpdHkgPSAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKTtcblxuXHRcdCQkLm1haW5CYXIgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxuXHRcdFx0LmRhdGEoYmFyRGF0YSk7XG5cblx0XHQkJC5tYWluQmFyLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpbkJhciA9ICQkLm1haW5CYXIuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFyKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcblx0XHRcdC5tZXJnZSgkJC5tYWluQmFyKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBpbml0aWFsT3BhY2l0eSk7XG5cdH0sXG5cblx0cmVkcmF3QmFyKGRyYXdCYXIsIHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRoaXMubWFpbkJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IHRoaXMubWFpbkJhcilcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRdO1xuXHR9LFxuXG5cdGdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGlja0ludGVydmFsID0gYXhpcy50aWNrSW50ZXJ2YWwoJCQuZ2V0TWF4RGF0YUNvdW50KCkpO1xuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XG5cdFx0bGV0IHJlc3VsdDtcblxuXHRcdGNvbnN0IGdldFdpZHRoID0gaWQgPT4ge1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBpZCA/IGNvbmZpZy5iYXJfd2lkdGhbaWRdIDogY29uZmlnLmJhcl93aWR0aDtcblx0XHRcdGNvbnN0IHJhdGlvID0gaWQgPyB3aWR0aC5yYXRpbyA6IGNvbmZpZy5iYXJfd2lkdGhfcmF0aW87XG5cdFx0XHRjb25zdCBtYXggPSBpZCA/IHdpZHRoLm1heCA6IGNvbmZpZy5iYXJfd2lkdGhfbWF4O1xuXHRcdFx0Y29uc3QgdyA9IGlzTnVtYmVyKHdpZHRoKSA/XG5cdFx0XHRcdHdpZHRoIDogYmFyVGFyZ2V0c051bSA/ICh0aWNrSW50ZXJ2YWwgKiByYXRpbykgLyBiYXJUYXJnZXRzTnVtIDogMDtcblxuXHRcdFx0cmV0dXJuIG1heCAmJiB3ID4gbWF4ID8gbWF4IDogdztcblx0XHR9O1xuXG5cdFx0cmVzdWx0ID0gZ2V0V2lkdGgoKTtcblxuXHRcdGlmICghaXNHcm91cGVkICYmIGlzT2JqZWN0VHlwZShjb25maWcuYmFyX3dpZHRoKSkge1xuXHRcdFx0cmVzdWx0ID0ge3dpZHRoOiByZXN1bHQsIHRvdGFsOiBbXX07XG5cblx0XHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRpZiAoY29uZmlnLmJhcl93aWR0aFt2LmlkXSkge1xuXHRcdFx0XHRcdHJlc3VsdFt2LmlkXSA9IGdldFdpZHRoKHYuaWQpO1xuXHRcdFx0XHRcdHJlc3VsdC50b3RhbC5wdXNoKHJlc3VsdFt2LmlkXSB8fCByZXN1bHQud2lkdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdGdldEJhcnMoaSwgaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xuXG5cdFx0cmV0dXJuIChpZCA/ICQkLm1haW5cblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC5tYWluKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfSR7c3VmZml4fWApO1xuXHR9LFxuXG5cdGV4cGFuZEJhcnMoaSwgaWQsIHJlc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCk7XG5cdFx0JCQuZ2V0QmFycyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XG5cdH0sXG5cblx0dW5leHBhbmRCYXJzKGkpIHtcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xuXHR9LFxuXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgaXNHcm91cGVkID0gY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aDtcblx0XHRjb25zdCBiYXJSYWRpdXMgPSBjb25maWcuYmFyX3JhZGl1cztcblx0XHRjb25zdCBiYXJSYWRpdXNSYXRpbyA9IGNvbmZpZy5iYXJfcmFkaXVzX3JhdGlvO1xuXG5cdFx0Ly8gZ2V0IHRoZSBiYXIgcmFkaXVzXG5cdFx0Y29uc3QgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID9cblx0XHRcdCgpID0+IGJhclJhZGl1cyA6IChcblx0XHRcdFx0aXNOdW1iZXIoYmFyUmFkaXVzUmF0aW8pID8gdyA9PiB3ICogYmFyUmFkaXVzUmF0aW8gOiBudWxsXG5cdFx0XHQpO1xuXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGdldFBvaW50cyhkLCBpKTtcblxuXHRcdFx0Ly8gc3dpdGNoIHBvaW50cyBpZiBheGlzIGlzIHJvdGF0ZWQsIG5vdCBhcHBsaWNhYmxlIGZvciBzdWIgY2hhcnRcblx0XHRcdGNvbnN0IGluZGV4WCA9ICtpc1JvdGF0ZWQ7XG5cdFx0XHRjb25zdCBpbmRleFkgPSArIWluZGV4WDtcblxuXHRcdFx0Y29uc3QgaXNOZWdhdGl2ZSA9IGQudmFsdWUgPCAwO1xuXHRcdFx0Y29uc3QgcGF0aFJhZGl1cyA9IFtcIlwiLCBcIlwiXTtcblx0XHRcdGxldCByYWRpdXMgPSAwO1xuXG5cdFx0XHRpZiAoZ2V0UmFkaXVzICYmICFpc0dyb3VwZWQpIHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpc1JvdGF0ZWQgPyBpbmRleFkgOiBpbmRleFg7XG5cdFx0XHRcdGNvbnN0IGJhclcgPSBwb2ludHNbMl1baW5kZXhdIC0gcG9pbnRzWzBdW2luZGV4XTtcblxuXHRcdFx0XHRyYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XG5cblx0XHRcdFx0Y29uc3QgYXJjID0gYGEke3JhZGl1c30sJHtyYWRpdXN9ICR7aXNOZWdhdGl2ZSA/IGAxIDAgMGAgOiBgMCAwIDFgfSBgO1xuXG5cdFx0XHRcdHBhdGhSYWRpdXNbKyFpc1JvdGF0ZWRdID0gYCR7YXJjfSR7cmFkaXVzfSwke3JhZGl1c31gO1xuXHRcdFx0XHRwYXRoUmFkaXVzWytpc1JvdGF0ZWRdID0gYCR7YXJjfSR7Wy1yYWRpdXMsIHJhZGl1c11baXNSb3RhdGVkID8gXCJzb3J0XCIgOiBcInJldmVyc2VcIl0oKX1gO1xuXG5cdFx0XHRcdGlzTmVnYXRpdmUgJiYgcGF0aFJhZGl1cy5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhdGggc3RyaW5nIGRhdGEgc2hvdWxkbid0IGJlIGNvbnRhaW5pbmcgbmV3IGxpbmUgY2hhcnNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzUzMFxuXHRcdFx0Y29uc3QgcGF0aCA9IGlzUm90YXRlZCA/XG5cdFx0XHRcdGBIJHtwb2ludHNbMV1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzBdfVYke3BvaW50c1syXVtpbmRleFldIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMV19SCR7cG9pbnRzWzNdW2luZGV4WF19YCA6XG5cdFx0XHRcdGBWJHtwb2ludHNbMV1baW5kZXhZXSArIChpc05lZ2F0aXZlID8gLXJhZGl1cyA6IHJhZGl1cyl9ICR7cGF0aFJhZGl1c1swXX1IJHtwb2ludHNbMl1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfVYke3BvaW50c1szXVtpbmRleFldfWA7XG5cblx0XHRcdHJldHVybiBgTSR7cG9pbnRzWzBdW2luZGV4WF19LCR7cG9pbnRzWzBdW2luZGV4WV19JHtwYXRofXpgO1xuXHRcdH07XG5cdH0sXG5cblx0Z2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYXhpcyA9IGlzU3ViID8gJCQuc3ViWEF4aXMgOiAkJC54QXhpcztcblx0XHRjb25zdCBiYXJUYXJnZXRzTnVtID0gYmFySW5kaWNlcy5fX21heF9fICsgMTtcblx0XHRjb25zdCBiYXJXID0gJCQuZ2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtKTtcblx0XHRjb25zdCBiYXJYID0gJCQuZ2V0U2hhcGVYKGJhclcsIGJhclRhcmdldHNOdW0sIGJhckluZGljZXMsICEhaXNTdWIpO1xuXHRcdGNvbnN0IGJhclkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XG5cdFx0Y29uc3QgYmFyT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNCYXJUeXBlLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XG5cdFx0XHRjb25zdCBvZmZzZXQgPSBiYXJPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBiYXIgY2hhcnRcblx0XHRcdGNvbnN0IHdpZHRoID0gaXNOdW1iZXIoYmFyVykgPyBiYXJXIDogYmFyV1tkLmlkXSB8fCBiYXJXLndpZHRoO1xuXHRcdFx0Y29uc3QgcG9zWCA9IGJhclgoZCk7XG5cdFx0XHRsZXQgcG9zWSA9IGJhclkoZCk7XG5cblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuXHRcdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxuXHRcdFx0KSkge1xuXHRcdFx0XHRwb3NZID0geTA7XG5cdFx0XHR9XG5cblx0XHRcdHBvc1kgLT0gKHkwIC0gb2Zmc2V0KTtcblxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcblx0XHRcdFx0W3Bvc1gsIHBvc1ldLFxuXHRcdFx0XHRbcG9zWCArIHdpZHRoLCBwb3NZXSxcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgb2Zmc2V0XVxuXHRcdFx0XTtcblx0XHR9O1xuXHR9LFxuXG5cdGlzV2l0aGluQmFyKHRoYXQpIHtcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhhdCk7XG5cdFx0Y29uc3QgbGlzdCA9IGdldFJlY3RTZWdMaXN0KHRoYXQpO1xuXHRcdGNvbnN0IFtzZWcwLCBzZWcxXSA9IGxpc3Q7XG5cdFx0Y29uc3QgeCA9IE1hdGgubWluKHNlZzAueCwgc2VnMS54KTtcblx0XHRjb25zdCB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpO1xuXHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuY29uZmlnLmJhcl9zZW5zaXRpdml0eTtcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGF0LmdldEJCb3goKTtcblx0XHRjb25zdCBzeCA9IHggLSBvZmZzZXQ7XG5cdFx0Y29uc3QgZXggPSB4ICsgd2lkdGggKyBvZmZzZXQ7XG5cdFx0Y29uc3Qgc3kgPSB5ICsgaGVpZ2h0ICsgb2Zmc2V0O1xuXHRcdGNvbnN0IGV5ID0geSAtIG9mZnNldDtcblxuXHRcdHJldHVybiBzeCA8IG1vdXNlWzBdICYmXG5cdFx0XHRtb3VzZVswXSA8IGV4ICYmXG5cdFx0XHRleSA8IG1vdXNlWzFdICYmXG5cdFx0XHRtb3VzZVsxXSA8IHN5O1xuXHR9XG59KTtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgZ2V0TWluTWF4LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3R9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0QnViYmxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xuXHRcdFx0Y29uZmlnLnBvaW50X3Nob3cgPSB0cnVlO1xuXHRcdFx0Y29uZmlnLnBvaW50X3R5cGUgPSBcImNpcmNsZVwiO1xuXHRcdFx0Y29uZmlnLnBvaW50X3NlbnNpdGl2aXR5ID0gMjU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHVzZXIgdW5pdHNcblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dlb21ldHJ5RWxlbWVudC9nZXRUb3RhbExlbmd0aFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRCYXNlTGVuZ3RoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJGJhc2VMZW5ndGhcIjtcblx0XHRsZXQgYmFzZUxlbmd0aCA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW1xuXHRcdFx0XHQkJC5heGVzLnguc2VsZWN0KFwicGF0aFwiKS5ub2RlKClcblx0XHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKSxcblx0XHRcdFx0JCQuYXhlcy55LnNlbGVjdChcInBhdGhcIikubm9kZSgpXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKClcblx0XHRcdF0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYmFzZUxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuIFx0ICovXG5cdGdldEJ1YmJsZVIoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgbWF4UiA9ICQkLmNvbmZpZy5idWJibGVfbWF4UjtcblxuXHRcdGlmIChpc0Z1bmN0aW9uKG1heFIpKSB7XG5cdFx0XHRtYXhSID0gbWF4UihkKTtcblx0XHR9IGVsc2UgaWYgKCFpc051bWJlcihtYXhSKSkge1xuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcblx0XHR9XG5cblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoXG5cdFx0XHQkJC5pc0J1YmJsZVpUeXBlKGQpID9cblx0XHRcdFx0JCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ5XCIpIDogKFxuXHRcdFx0XHRcdGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlXG5cdFx0XHRcdClcblx0XHQpKSk7XG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcblx0XHRjb25zdCBhcmVhID0gKCQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlKSAqIChtYXhBcmVhIC8gbWF4KTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYnViYmxlIGRpbWVuc2lvbiBkYXRhXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkIGRhdGEgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB5IG9yIHpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0QnViYmxlWkRhdGEoZCwgdHlwZSkge1xuXHRcdHJldHVybiBpc09iamVjdChkKSA/IGRbdHlwZV0gOiBkW3R5cGUgPT09IFwieVwiID8gMCA6IDFdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYnViYmxlIGhhcyBkaW1lbnNpb24gZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdHxhcnJheX0gZCBkYXRhIHZhbHVlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpc0J1YmJsZVpUeXBlKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuaXNCdWJibGVUeXBlKGQpICYmIChcblx0XHRcdChpc09iamVjdChkLnZhbHVlKSAmJiAoXCJ6XCIgaW4gZC52YWx1ZSB8fCBcInlcIiBpbiBkLnZhbHVlKSkgfHxcblx0XHRcdChpc0FycmF5KGQudmFsdWUpICYmIGQudmFsdWUubGVuZ3RoID09PSAyKVxuXHRcdCk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0YXJlYSBhcyBkM0FyZWEsXG5cdGxpbmUgYXMgZDNMaW5lXG59IGZyb20gXCJkMy1zaGFwZVwiO1xuaW1wb3J0IHtcblx0bW91c2UgYXMgZDNNb3VzZSxcblx0c2VsZWN0IGFzIGQzU2VsZWN0XG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmQsIGdldFJhbmRvbSwgaXNBcnJheSwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1VuZGVmaW5lZCwgaXNWYWx1ZX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0TGluZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQ2lyY2xlcyA9ICQkLmNsYXNzQ2lyY2xlcy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcblxuXHRcdGNvbnN0IG1haW5MaW5lVXBkYXRlID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0TGluZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0TGluZX1gKVxuXHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0TGluZShkKSArIGNsYXNzRm9jdXMoZCkpO1xuXG5cdFx0Y29uc3QgbWFpbkxpbmVFbnRlciA9IG1haW5MaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cblx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGluZXMpO1xuXG5cdFx0Ly8gQXJlYXNcblx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmVhcyk7XG5cblx0XHRpZiAoY29uZmlnLnBvaW50X3Nob3cpIHtcblx0XHRcdC8vIENpcmNsZXMgZm9yIGVhY2ggZGF0YSBwb2ludCBvbiBsaW5lc1xuXHRcdFx0Y29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgbWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCkpO1xuXG5cdFx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpXG5cdFx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGRhdGUgZm9yIHNlbGVjdGVkIGNpcmNsZXNcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodC5pZCl9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxuXHRcdFx0XHQuZWFjaChkID0+IHtcblx0XHRcdFx0XHRkLnZhbHVlID0gdC52YWx1ZXNbZC5pbmRleF0udmFsdWU7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cblx0XHQvLyBtYWluTGluZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XG5cdH0sXG5cblx0dXBkYXRlTGluZShkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5tYWluTGluZSA9ICQkLm1haW5cblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG5cblx0XHQkJC5tYWluTGluZS5leGl0KCkudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW5MaW5lID0gJCQubWFpbkxpbmUuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHskJC5jbGFzc0xpbmUuYmluZCgkJCkoZCl9ICR7JCQuZXh0cmFMaW5lQ2xhc3NlcyhkKSB8fCBcIlwifWApXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHQubWVyZ2UoJCQubWFpbkxpbmUpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwic2hhcGUtcmVuZGVyaW5nXCIsIGQgPT4gKCQkLmlzU3RlcFR5cGUoZCkgPyBcImNyaXNwRWRnZXNcIiA6IFwiXCIpKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cdH0sXG5cblx0cmVkcmF3TGluZShkcmF3TGluZSwgd2l0aFRyYW5zaXRpb24pIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGhpcy5tYWluTGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IHRoaXMubWFpbkxpbmUpXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3TGluZSlcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIHRoaXMuY29sb3IpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXG5cdFx0XTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJ2ZSBpbnRlcnBvbGF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBkIERhdGEgb2JqZWN0XG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q3VydmUoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWRTdGVwVHlwZSA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgJCQuaXNTdGVwVHlwZShkKTtcblxuXHRcdC8vIHdoZW4gaXMgc3RlcCAmIHJvdGF0ZWQsIHNob3VsZCBiZSBjb21wdXRlZCBpbiBkaWZmZXJlbnQgd2F5XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNDcxXG5cdFx0cmV0dXJuIGlzUm90YXRlZFN0ZXBUeXBlID8gY29udGV4dCA9PiB7XG5cdFx0XHRjb25zdCBzdGVwID0gJCQuZ2V0SW50ZXJwb2xhdGUoZCkoY29udGV4dCk7XG5cblx0XHRcdC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGhvZFxuXHRcdFx0c3RlcC5vcmdQb2ludCA9IHN0ZXAucG9pbnQ7XG5cblx0XHRcdC8vIHRvIGdldCByb3RhdGVkIHBhdGggZGF0YVxuXHRcdFx0c3RlcC5wb2ludFJvdGF0ZWQgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0XHRcdHRoaXMuX3BvaW50ID09PSAxICYmICh0aGlzLl9wb2ludCA9IDIpO1xuXG5cdFx0XHRcdGNvbnN0IHkxID0gdGhpcy5feSAqICgxIC0gdGhpcy5fdCkgKyB5ICogdGhpcy5fdDtcblxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSk7XG5cdFx0XHRcdHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkxKTtcblxuXHRcdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR9O1xuXG5cdFx0XHRzdGVwLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMCA/IHRoaXMub3JnUG9pbnQoeCwgeSkgOiB0aGlzLnBvaW50Um90YXRlZCh4LCB5KTtcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBzdGVwO1xuXHRcdH0gOiAkJC5nZXRJbnRlcnBvbGF0ZShkKTtcblx0fSxcblxuXHRnZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBpc1N1Yikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IHlTY2FsZUdldHRlciA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuXG5cdFx0Y29uc3QgeFZhbHVlID0gZCA9PiAoaXNTdWIgPyAkJC5zdWJ4eCA6ICQkLnh4KS5jYWxsKCQkLCBkKTtcblx0XHRjb25zdCB5VmFsdWUgPSAoZCwgaSkgPT4gKCQkLmlzR3JvdXBlZChkLmlkKSA/XG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKCQkLmdldEJhc2VWYWx1ZShkKSlcblx0XHQpO1xuXG5cdFx0bGV0IGxpbmUgPSBkM0xpbmUoKTtcblxuXHRcdGxpbmUgPSBpc1JvdGF0ZWQgP1xuXHRcdFx0bGluZS54KHlWYWx1ZSkueSh4VmFsdWUpIDogbGluZS54KHhWYWx1ZSkueSh5VmFsdWUpO1xuXG5cdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcblx0XHRcdGxpbmUgPSBsaW5lLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHggPSBpc1N1YiA/ICQkLnN1YlggOiAkJC54O1xuXG5cdFx0cmV0dXJuIGQgPT4ge1xuXHRcdFx0Y29uc3QgeSA9IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKTtcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xuXHRcdFx0bGV0IHgwID0gMDtcblx0XHRcdGxldCB5MCA9IDA7XG5cdFx0XHRsZXQgcGF0aDtcblxuXHRcdFx0aWYgKCQkLmlzTGluZVR5cGUoZCkpIHtcblx0XHRcdFx0Y29uc3QgcmVnaW9ucyA9IGNvbmZpZy5kYXRhX3JlZ2lvbnNbZC5pZF07XG5cblx0XHRcdFx0aWYgKHJlZ2lvbnMpIHtcblx0XHRcdFx0XHRwYXRoID0gJCQubGluZVdpdGhSZWdpb25zKHZhbHVlcywgeCwgeSwgcmVnaW9ucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcblx0XHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwYXRoID0gbGluZS5jdXJ2ZSgkJC5nZXRDdXJ2ZShkKSkodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHgwID0geCh2YWx1ZXNbMF0ueCk7XG5cdFx0XHRcdFx0eTAgPSB5KHZhbHVlc1swXS52YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XG5cdFx0fTtcblx0fSxcblxuXHRnZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViVmFsdWUpIHsgLy8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgbGluZVRhcmdldHNOdW0gPSBsaW5lSW5kaWNlcy5fX21heF9fICsgMTtcblx0XHRjb25zdCBpc1N1YiA9ICEhaXNTdWJWYWx1ZTtcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGxpbmVUYXJnZXRzTnVtLCBsaW5lSW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoaXNTdWIpO1xuXHRcdGNvbnN0IGxpbmVPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0xpbmVUeXBlLCBsaW5lSW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgwKTtcblx0XHRcdGNvbnN0IG9mZnNldCA9IGxpbmVPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcblx0XHRcdGxldCBwb3NZID0geShkKTtcblxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXG5cdFx0XHQpKSB7XG5cdFx0XHRcdHBvc1kgPSB5MDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBsaW5lIHBvc2l0aW9uXG5cdFx0XHRjb25zdCBwb2ludCA9IFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV07XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludCwgLy8gZnJvbSBoZXJlIGFuZCBiZWxvdywgbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludFxuXHRcdFx0XTtcblx0XHR9O1xuXHR9LFxuXG5cdGxpbmVXaXRoUmVnaW9ucyhkLCB4LCB5LCBfcmVnaW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKTtcblx0XHRjb25zdCB4T2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMDtcblx0XHRjb25zdCByZWdpb25zID0gW107XG5cdFx0Y29uc3QgZGFzaGFycmF5ID0gXCIyIDJcIjsgLy8gZGVmYXVsdCB2YWx1ZVxuXG5cdFx0bGV0IHhwO1xuXHRcdGxldCB5cDtcblx0XHRsZXQgZGlmZjtcblx0XHRsZXQgZGlmZngyO1xuXG5cdFx0Ly8gY2hlY2sgd2VhdGhlciBkYXRhIGlzIHdpdGhpbiByZWdpb25cblx0XHRjb25zdCBpc1dpdGhpblJlZ2lvbnMgPSAod2l0aGluWCwgd2l0aGluUmVnaW9ucykgPT4ge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHJlZzsgKHJlZyA9IHdpdGhpblJlZ2lvbnNbaV0pOyBpKyspIHtcblx0XHRcdFx0aWYgKHJlZy5zdGFydCA8IHdpdGhpblggJiYgd2l0aGluWCA8PSByZWcuZW5kKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZy5zdHlsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIENoZWNrIHN0YXJ0L2VuZCBvZiByZWdpb25zXG5cdFx0aWYgKGlzRGVmaW5lZChfcmVnaW9ucykpIHtcblx0XHRcdGNvbnN0IGdldFZhbHVlID0gKHYsIGRlZikgPT4gKFxuXHRcdFx0XHRpc1VuZGVmaW5lZCh2KSA/IGRlZiA6IChpc1RpbWVTZXJpZXMgPyAkJC5wYXJzZURhdGUodikgOiB2KVxuXHRcdFx0KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHJlZzsgKHJlZyA9IF9yZWdpb25zW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ2V0VmFsdWUocmVnLnN0YXJ0LCBkWzBdLngpO1xuXHRcdFx0XHRjb25zdCBlbmQgPSBnZXRWYWx1ZShyZWcuZW5kLCBkW2QubGVuZ3RoIC0gMV0ueCk7XG5cdFx0XHRcdGNvbnN0IHN0eWxlID0gcmVnLnN0eWxlIHx8IHtkYXNoYXJyYXl9O1xuXG5cdFx0XHRcdHJlZ2lvbnNbaV0gPSB7c3RhcnQsIGVuZCwgc3R5bGV9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCBzY2FsZXNcblx0XHRjb25zdCB4VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB5KGR0LnZhbHVlKSA6IGR0ID0+IHgoZHQueCk7XG5cdFx0Y29uc3QgeVZhbHVlID0gaXNSb3RhdGVkID8gZHQgPT4geChkdC54KSA6IGR0ID0+IHkoZHQudmFsdWUpO1xuXG5cdFx0Ly8gRGVmaW5lIHN2ZyBnZW5lcmF0b3IgZnVuY3Rpb24gZm9yIHJlZ2lvblxuXHRcdGNvbnN0IGdlbmVyYXRlTSA9IHBvaW50cyA9PiBgTSR7cG9pbnRzWzBdWzBdfSwke3BvaW50c1swXVsxXX1MJHtwb2ludHNbMV1bMF19LCR7cG9pbnRzWzFdWzFdfWA7XG5cblx0XHRjb25zdCBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSA9PiB7XG5cdFx0XHRjb25zdCB4MCA9IGQwLnguZ2V0VGltZSgpO1xuXHRcdFx0Y29uc3QgeERpZmYgPSBkMS54IC0gZDAueDtcblx0XHRcdGNvbnN0IHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKTtcblx0XHRcdGNvbnN0IHh2MSA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiAoayArIHRpbWVzZXJpZXNEaWZmKSk7XG5cblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XG5cdFx0XHRcdFtbeSh5cChrKSksIHgoeHYwKV0sIFt5KHlwKGsgKyBkaWZmKSksIHgoeHYxKV1dIDpcblx0XHRcdFx0W1t4KHh2MCksIHkoeXAoaykpXSwgW3goeHYxKSwgeSh5cChrICsgZGlmZikpXV07XG5cblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcblx0XHR9IDogKGQwLCBkMSwgaywgb3RoZXJEaWZmKSA9PiB7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xuXHRcdFx0XHRbW3koeXAoayksIHRydWUpLCB4KHhwKGspKV0sIFt5KHlwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeCh4cChrICsgb3RoZXJEaWZmKSldXSA6XG5cdFx0XHRcdFtbeCh4cChrKSwgdHJ1ZSksIHkoeXAoaykpXSwgW3goeHAoayArIG90aGVyRGlmZiksIHRydWUpLCB5KHlwKGsgKyBvdGhlckRpZmYpKV1dO1xuXG5cdFx0XHRyZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XG5cdFx0fTtcblxuXHRcdC8vIEdlbmVyYXRlXG5cdFx0bGV0IHBhdGggPSBcIk1cIjtcblxuXHRcdGZvciAobGV0IGkgPSAwLCBkYXRhOyAoZGF0YSA9IGRbaV0pOyBpKyspIHtcblx0XHRcdGNvbnN0IHByZXZEYXRhID0gZFtpIC0gMV07XG5cdFx0XHRsZXQgc3R5bGUgPSBpc1dpdGhpblJlZ2lvbnMoZGF0YS54LCByZWdpb25zKTtcblxuXHRcdFx0Ly8gRHJhdyBhcyBub3JtYWxcblx0XHRcdGlmIChpc1VuZGVmaW5lZChyZWdpb25zKSB8fCAhc3R5bGUpIHtcblx0XHRcdFx0cGF0aCArPSBgJHtpID8gXCJMXCIgOiBcIlwifSR7eFZhbHVlKGRhdGEpfSwke3lWYWx1ZShkYXRhKX1gO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzdHlsZSA9IHN0eWxlLmRhc2hhcnJheS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRzdHlsZSA9IGRhc2hhcnJheS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHdpdGggcmVnaW9uIC8vIFRPRE86IEZpeCBmb3IgaG9yaXpvdGFsIGNoYXJ0c1xuXHRcdFx0XHR4cCA9ICQkLmdldFNjYWxlKHByZXZEYXRhLnggKyB4T2Zmc2V0LCBkYXRhLnggKyB4T2Zmc2V0LCBpc1RpbWVTZXJpZXMpO1xuXHRcdFx0XHR5cCA9ICQkLmdldFNjYWxlKHByZXZEYXRhLnZhbHVlLCBkYXRhLnZhbHVlKTtcblxuXHRcdFx0XHRjb25zdCBkeCA9IHgoZGF0YS54KSAtIHgocHJldkRhdGEueCk7XG5cdFx0XHRcdGNvbnN0IGR5ID0geShkYXRhLnZhbHVlKSAtIHkocHJldkRhdGEudmFsdWUpO1xuXHRcdFx0XHRjb25zdCBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuXG5cdFx0XHRcdGRpZmYgPSBzdHlsZVswXSAvIGRkO1xuXHRcdFx0XHRkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IGRpZmY7IGogPD0gMTsgaiArPSBkaWZmeDIpIHtcblx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCBqLCBkaWZmKTtcblxuXHRcdFx0XHRcdC8vIHRvIG1ha2Ugc3VyZSBjb3JyZWN0IGxpbmUgZHJhd2luZ1xuXHRcdFx0XHRcdGlmIChqICsgZGlmZngyID49IDEpIHtcblx0XHRcdFx0XHRcdHBhdGggKz0gc1dpdGhSZWdpb24ocHJldkRhdGEsIGRhdGEsIDEsIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdHVwZGF0ZUFyZWFHcmFkaWVudCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcblx0XHRcdGNvbnN0IGlkID0gYCR7JCQuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gO1xuXG5cdFx0XHRpZiAoJCQuaXNBcmVhVHlwZShkKSAmJiAkJC5kZWZzLnNlbGVjdChgIyR7aWR9YCkuZW1wdHkoKSkge1xuXHRcdFx0XHRjb25zdCBjb2xvciA9ICQkLmNvbG9yKGQpO1xuXHRcdFx0XHRjb25zdCB7XG5cdFx0XHRcdFx0eCA9IFswLCAwXSxcblx0XHRcdFx0XHR5ID0gWzAsIDFdLFxuXHRcdFx0XHRcdHN0b3BzID0gW1swLCBjb2xvciwgMV0sIFsxLCBjb2xvciwgMF1dXG5cdFx0XHRcdH0gPSAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudDtcblxuXHRcdFx0XHRjb25zdCBsaW5lYXJHcmFkaWVudCA9ICQkLmRlZnMuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIilcblx0XHRcdFx0XHQuYXR0cihcImlkXCIsIGAke2lkfWApXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4WzBdKVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgeFsxXSlcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHlbMF0pXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5WzFdKTtcblxuXHRcdFx0XHRzdG9wcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHN0b3BDb2xvciA9IGlzRnVuY3Rpb24odlsxXSkgPyB2WzFdKGQuaWQpIDogdlsxXTtcblxuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50LmFwcGVuZChcInN0b3BcIilcblx0XHRcdFx0XHRcdC5hdHRyKFwib2Zmc2V0XCIsIHZbMF0pXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3AtY29sb3JcIiwgc3RvcENvbG9yIHx8IGNvbG9yKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgdlsyXSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHVwZGF0ZUFyZWFDb2xvcihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ID9cblx0XHRcdGB1cmwoIyR7JCQuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XG5cdFx0XHQkJC5jb2xvcihkKTtcblx0fSxcblxuXHR1cGRhdGVBcmVhKGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xuXG5cdFx0JCQubWFpbkFyZWEgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWF9YClcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcblxuXHRcdCQkLm1haW5BcmVhLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpbkFyZWEgPSAkJC5tYWluQXJlYS5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkJC5vcmdBcmVhT3BhY2l0eSA9IGQzU2VsZWN0KHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiKTtcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xuXHRcdFx0fSlcblx0XHRcdC5tZXJnZSgkJC5tYWluQXJlYSk7XG5cblx0XHQkJC5tYWluQXJlYVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5vcmdBcmVhT3BhY2l0eSk7XG5cdH0sXG5cblx0cmVkcmF3QXJlYShkcmF3QXJlYSwgd2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQubWFpbkFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC5tYWluQXJlYSlcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZUFyZWFDb2xvci5iaW5kKCQkKSlcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyAkJC5vcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiAkJC5vcmdBcmVhT3BhY2l0eSkpXG5cdFx0XTtcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYXJlYSBwYXRoIGRhdGFcblx0ICogQHBhcmFtIGFyZWFJbmRpY2VzXG5cdCAqIEBwYXJhbSBpc1N1YlxuXHQgKiBAcmV0dXJuIHtmdW5jdGlvbigqPSk6ICgqfHN0cmluZyl9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZURyYXdBcmVhKGFyZWFJbmRpY2VzLCBpc1N1Yikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IHlTY2FsZUdldHRlciA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuXG5cdFx0Y29uc3QgeFZhbHVlID0gZCA9PiAoaXNTdWIgPyAkJC5zdWJ4eCA6ICQkLnh4KS5jYWxsKCQkLCBkKTtcblx0XHRjb25zdCB2YWx1ZTAgPSAoZCwgaSkgPT4gKCQkLmlzR3JvdXBlZChkLmlkKSA/XG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKFxuXHRcdFx0XHQkJC5pc0FyZWFSYW5nZVR5cGUoZCkgP1xuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogMFxuXHRcdFx0KSk7XG5cdFx0Y29uc3QgdmFsdWUxID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcblx0XHRcdHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKShcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxuXHRcdFx0KSk7XG5cblx0XHRyZXR1cm4gZCA9PiB7XG5cdFx0XHRsZXQgdmFsdWVzID0gbGluZUNvbm5lY3ROdWxsID8gJCQuZmlsdGVyUmVtb3ZlTnVsbChkLnZhbHVlcykgOiBkLnZhbHVlcztcblx0XHRcdGxldCB4MCA9IDA7XG5cdFx0XHRsZXQgeTAgPSAwO1xuXHRcdFx0bGV0IHBhdGg7XG5cblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XG5cdFx0XHRcdGxldCBhcmVhID0gZDNBcmVhKCk7XG5cblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XG5cdFx0XHRcdFx0YXJlYS55KHhWYWx1ZSlcblx0XHRcdFx0XHRcdC54MCh2YWx1ZTApXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XG5cdFx0XHRcdFx0YXJlYS54KHhWYWx1ZSlcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXG5cdFx0XHRcdFx0XHQueTEodmFsdWUxKTtcblxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xuXHRcdFx0XHRcdGFyZWEgPSBhcmVhLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXRoID0gYXJlYS5jdXJ2ZSgkJC5nZXRDdXJ2ZShkKSkodmFsdWVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHR4MCA9ICQkLngodmFsdWVzWzBdLngpO1xuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlKGQuaWQpKHZhbHVlc1swXS52YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XG5cdFx0fTtcblx0fSxcblxuXHRnZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViKSB7XG5cdFx0Ly8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXJlYVRhcmdldHNOdW0gPSBhcmVhSW5kaWNlcy5fX21heF9fICsgMTtcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFUYXJnZXRzTnVtLCBhcmVhSW5kaWNlcywgISFpc1N1Yik7XG5cdFx0Y29uc3QgeSA9ICQkLmdldFNoYXBlWSghIWlzU3ViKTtcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xuXHRcdGNvbnN0IHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKDApO1xuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYXJlYU9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGFyZWEgY2hhcnRcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xuXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcblx0XHRcdCkpIHtcblx0XHRcdFx0cG9zWSA9IHkwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGFyZWEgcG9zaXRpb25cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdLFxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLFxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLCAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0gLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG5cdFx0XHRdO1xuXHRcdH07XG5cdH0sXG5cblx0dXBkYXRlQ2lyY2xlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5tYWluQ2lyY2xlID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9YClcblx0XHRcdC5kYXRhKGQgPT4gISQkLmlzQmFyVHlwZShkKSAmJiAoXG5cdFx0XHRcdCEkJC5pc0xpbmVUeXBlKGQpIHx8ICQkLnNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpXG5cdFx0XHQpICYmICQkLmxhYmVsaXNoRGF0YShkKSk7XG5cblx0XHQkJC5tYWluQ2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcblxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJjcmVhdGVcIiwgdGhpcywgJCQucG9pbnRSLmJpbmQoJCQpLCAkJC5jb2xvcik7XG5cblx0XHQkJC5tYWluQ2lyY2xlID0gJCQubWFpbkNpcmNsZS5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKGZuKVxuXHRcdFx0Lm1lcmdlKCQkLm1haW5DaXJjbGUpXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpKTtcblx0fSxcblxuXHRyZWRyYXdDaXJjbGUoY3gsIGN5LCB3aXRoVHJhbnNpdGlvbiwgZmxvdykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzZWxlY3RlZENpcmNsZXMgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9YCk7XG5cblx0XHRpZiAoISQkLmNvbmZpZy5wb2ludF9zaG93KSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWFpbkNpcmNsZXMgPSBbXTtcblxuXHRcdCQkLm1haW5DaXJjbGUuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwidXBkYXRlXCIsICQkLCBjeCwgY3ksICQkLm9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCksICQkLmNvbG9yLCB3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKS5iaW5kKHRoaXMpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oZCk7XG5cblx0XHRcdG1haW5DaXJjbGVzLnB1c2gocmVzdWx0KTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IHBvc0F0dHIgPSAkJC5pc0NpcmNsZVBvaW50KCkgPyBcImNcIiA6IFwiXCI7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0bWFpbkNpcmNsZXMsXG5cdFx0XHRzZWxlY3RlZENpcmNsZXNcblx0XHRcdFx0LmF0dHIoYCR7cG9zQXR0cn14YCwgY3gpXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eWAsIGN5KVxuXHRcdF07XG5cdH0sXG5cblx0Y2lyY2xlWChkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGhhc1ZhbHVlID0gaXNWYWx1ZShkLngpO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuem9vbVNjYWxlID9cblx0XHRcdChoYXNWYWx1ZSA/ICQkLnpvb21TY2FsZShkLngpIDogbnVsbCkgOlxuXHRcdFx0KGhhc1ZhbHVlID8gJCQueChkLngpIDogbnVsbCk7XG5cdH0sXG5cblx0dXBkYXRlQ2lyY2xlWSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jaXJjbGVZID0gKGQsIGkpID0+IHtcblx0XHRcdGNvbnN0IGlkID0gZC5pZDtcblxuXHRcdFx0cmV0dXJuICQkLmlzR3JvdXBlZChpZCkgP1xuXHRcdFx0XHQkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMoJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpKShkLCBpKVswXVsxXSA6XG5cdFx0XHRcdCQkLmdldFlTY2FsZShpZCkoJCQuZ2V0QmFzZVZhbHVlKGQpKTtcblx0XHR9O1xuXHR9LFxuXG5cdGdldENpcmNsZXMoaSwgaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xuXG5cdFx0cmV0dXJuIChpZCA/ICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApIDogJCQubWFpbilcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZX0ke3N1ZmZpeH1gKTtcblx0fSxcblxuXHRleHBhbmRDaXJjbGVzKGksIGlkLCByZXNldCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCByID0gJCQucG9pbnRFeHBhbmRlZFIuYmluZCgkJCk7XG5cblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcblxuXHRcdGNvbnN0IGNpcmNsZXMgPSAkJC5nZXRDaXJjbGVzKGksIGlkKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcblx0XHRjb25zdCBzY2FsZSA9IHIoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcjtcblx0XHRjb25zdCByYXRpbyA9IDEgLSBzY2FsZTtcblxuXHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcblx0XHRcdGNpcmNsZXMuYXR0cihcInJcIiwgcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHRyYW5zZm9ybSBtdXN0IGJlIGFwcGxpZWQgdG8gZWFjaCBub2RlIGluZGl2aWR1YWxseVxuXHRcdFx0Y2lyY2xlcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnRhZ05hbWUgPT09IFwiY2lyY2xlXCIpIHtcblx0XHRcdFx0XHRwb2ludC5hdHRyKFwiclwiLCByKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmdldEJCb3goKTtcblx0XHRcdFx0XHRjb25zdCB4ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ4XCIpICsgd2lkdGggLyAyKTtcblx0XHRcdFx0XHRjb25zdCB5ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ5XCIpICsgaGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHRwb2ludC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt4fSAke3l9KSBzY2FsZSgke3NjYWxlfSlgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdHVuZXhwYW5kQ2lyY2xlcyhpKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFIuYmluZCgkJCk7XG5cblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQpO1xuXHRcdFx0fSlcblx0XHRcdC5jbGFzc2VkKENMQVNTLkVYUEFOREVELCBmYWxzZSk7XG5cblx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xuXG5cdFx0ISQkLmlzQ2lyY2xlUG9pbnQoKSAmJlxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3IoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcn0pYCk7XG5cdH0sXG5cblx0cG9pbnRSKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xuXHRcdGxldCByID0gcG9pbnRSO1xuXG5cdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcblx0XHRcdHIgPSAwO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVUeXBlKGQpKSB7XG5cdFx0XHRyID0gJCQuZ2V0QnViYmxlUihkKTtcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocG9pbnRSKSkge1xuXHRcdFx0ciA9IHBvaW50UihkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fSxcblxuXHRwb2ludEV4cGFuZGVkUihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBzY2FsZSA9ICQkLmlzQnViYmxlVHlwZShkKSA/IDEuMTUgOiAxLjc1O1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCA/XG5cdFx0XHQoY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yIHx8ICQkLnBvaW50UihkKSAqIHNjYWxlKSA6ICQkLnBvaW50UihkKTtcblx0fSxcblxuXHRwb2ludFNlbGVjdFIoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzZWxlY3RSID0gJCQuY29uZmlnLnBvaW50X3NlbGVjdF9yO1xuXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0UikgP1xuXHRcdFx0c2VsZWN0UihkKSA6IChzZWxlY3RSIHx8ICQkLnBvaW50UihkKSAqIDQpO1xuXHR9LFxuXG5cdGlzV2l0aGluQ2lyY2xlKG5vZGUsIHIpIHtcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2Uobm9kZSk7XG5cdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KG5vZGUpO1xuXHRcdGNvbnN0IHByZWZpeCA9IHRoaXMuaXNDaXJjbGVQb2ludCgpID8gXCJjXCIgOiBcIlwiO1xuXG5cdFx0bGV0IGN4ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eGApO1xuXHRcdGxldCBjeSA9ICtlbGVtZW50LmF0dHIoYCR7cHJlZml4fXlgKTtcblxuXHRcdC8vIGlmIG5vZGUgZG9uJ3QgaGF2ZSBjeC95IG9yIHgveSBhdHRyaWJ1dGUgdmFsdWVcblx0XHRpZiAoIShjeCB8fCBjeSkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0Y29uc3Qge3gsIHl9ID0gbm9kZS5nZXRCQm94ID8gbm9kZS5nZXRCQm94KCkgOiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHRjeCA9IHg7XG5cdFx0XHRjeSA9IHk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXMgPSBNYXRoLnNxcnQoXG5cdFx0XHRNYXRoLnBvdyhjeCAtIG1vdXNlWzBdLCAyKSArIE1hdGgucG93KGN5IC0gbW91c2VbMV0sIDIpXG5cdFx0KSA8IChyIHx8IHRoaXMuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KTtcblxuXHRcdHJldHVybiBpcztcblx0fSxcblxuXHRpc1dpdGhpblN0ZXAodGhhdCwgeSkge1xuXHRcdHJldHVybiBNYXRoLmFicyh5IC0gZDNNb3VzZSh0aGF0KVsxXSkgPCAzMDtcblx0fSxcblxuXHRzaG91bGREcmF3UG9pbnRzRm9yTGluZShkKSB7XG5cdFx0Y29uc3QgbGluZVBvaW50ID0gdGhpcy5jb25maWcubGluZV9wb2ludDtcblxuXHRcdHJldHVybiBsaW5lUG9pbnQgPT09IHRydWUgfHxcblx0XHRcdChpc0FycmF5KGxpbmVQb2ludCkgJiYgbGluZVBvaW50LmluZGV4T2YoZC5pZCkgIT09IC0xKTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXMsXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IHtnZXRSYW5kb20sIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc09iamVjdFR5cGUsIHRvQXJyYXksIGV4dGVuZCwgbm90RW1wdHl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aGFzVmFsaWRQb2ludFR5cGUodHlwZSkge1xuXHRcdHJldHVybiAvXihjaXJjbGV8cmVjdChhbmdsZSk/fHBvbHlnb258ZWxsaXBzZXx1c2UpJC9pLnRlc3QodHlwZSB8fCB0aGlzLmNvbmZpZy5wb2ludF90eXBlKTtcblx0fSxcblxuXHRoYXNWYWxpZFBvaW50RHJhd01ldGhvZHModHlwZSkge1xuXHRcdGNvbnN0IHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcblxuXHRcdHJldHVybiBpc09iamVjdFR5cGUocG9pbnRUeXBlKSAmJlxuXHRcdFx0aXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xuXHR9LFxuXG5cdGluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvcHlBdHRyID0gKGZyb20sIHRhcmdldCkgPT4ge1xuXHRcdFx0Y29uc3QgYXR0cmlicyA9IGZyb20uYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG5hbWU7IChuYW1lID0gYXR0cmlic1tpXSk7IGkrKykge1xuXHRcdFx0XHRuYW1lID0gbmFtZS5uYW1lO1xuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhwb2ludCwgXCJpbWFnZS9zdmcreG1sXCIpO1xuXHRcdGNvbnN0IG5vZGUgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG5cblx0XHRjbG9uZS5pZCA9IGlkO1xuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcblx0XHRjbG9uZS5zdHlsZS5zdHJva2UgPSBcImluaGVyaXRcIjtcblxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcblxuXHRcdGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xuXG5cdFx0XHRpZiAoXCJpbm5lckhUTUxcIiBpbiBjbG9uZSkge1xuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b0FycmF5KG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JCQuZGVmcy5ub2RlKCkuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXHR9LFxuXG5cdHBvaW50RnJvbURlZnMoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5kZWZzLnNlbGVjdChgIyR7aWR9YCk7XG5cdH0sXG5cblx0dXBkYXRlUG9pbnRDbGFzcyhkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBwb2ludENsYXNzID0gZmFsc2U7XG5cblx0XHRpZiAoaXNPYmplY3QoZCkgfHwgJCQubWFpbkNpcmNsZSkge1xuXHRcdFx0cG9pbnRDbGFzcyA9IGQgPT09IHRydWUgP1xuXHRcdFx0XHQkJC5tYWluQ2lyY2xlLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKSkgOlxuXHRcdFx0XHQkJC5jbGFzc0NpcmNsZShkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRDbGFzcztcblx0fSxcblxuXHRnZW5lcmF0ZVBvaW50KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaWRzID0gW107XG5cdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/IGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGNvbnN0IGlkID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xuXG5cdFx0XHRcdGxldCBwb2ludCA9IHBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgcGF0dGVybi5sZW5ndGhdO1xuXG5cdFx0XHRcdGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZShwb2ludCkpIHtcblx0XHRcdFx0XHRwb2ludCA9ICQkW3BvaW50XTtcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHBvaW50KSkge1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50SWQgPSBgJHskJC5kYXRldGltZUlkfS1wb2ludC0ke2lkfWA7XG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRGcm9tRGVmcyA9ICQkLnBvaW50RnJvbURlZnMocG9pbnRJZCk7XG5cblx0XHRcdFx0XHRpZiAocG9pbnRGcm9tRGVmcy5zaXplKCkgPCAxKSB7XG5cdFx0XHRcdFx0XHQkJC5pbnNlcnRQb2ludEluZm9EZWZzKHBvaW50LCBwb2ludElkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobWV0aG9kID09PSBcImNyZWF0ZVwiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLmNyZWF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIHBvaW50SWQsIC4uLmFyZ3MpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWV0aG9kID09PSBcInVwZGF0ZVwiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLnVwZGF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIC4uLmFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBwb2ludFttZXRob2RdLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0VHJhbnNpdGlvbk5hbWUoKSB7XG5cdFx0cmV0dXJuIGdldFJhbmRvbSgpO1xuXHR9LFxuXG5cdGN1c3RvbToge1xuXHRcdGNyZWF0ZShlbGVtZW50LCBpZCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwidXNlXCIpXG5cdFx0XHRcdC5hdHRyKFwieGxpbms6aHJlZlwiLCBgIyR7aWR9YClcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbilcblx0XHRcdFx0Lm5vZGUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XG5cblx0XHRcdGNvbnN0IHhQb3NGbjIgPSBkID0+IHhQb3NGbihkKSAtIHdpZHRoIC8gMjtcblx0XHRcdGNvbnN0IHlQb3NGbjIgPSBkID0+IHlQb3NGbihkKSAtIGhlaWdodCAvIDI7XG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcInhcIiwgeFBvc0ZuMik7XG5cblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xuXHRcdFx0XHQuYXR0cihcInhcIiwgeFBvc0ZuMilcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlQb3NGbjIpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eVN0eWxlRm4pXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xuXHRcdH1cblx0fSxcblxuXHQvLyAnY2lyY2xlJyBkYXRhIHBvaW50XG5cdGNpcmNsZToge1xuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJjaXJjbGVcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcblx0XHRcdFx0LmF0dHIoXCJyXCIsIHNpemVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbilcblx0XHRcdFx0Lm5vZGUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xuXG5cdFx0XHQvLyB3aGVuICcubG9hZCgpJyBjYWxsZWQsIGJ1YmJsZSBzaXplIHNob3VsZCBiZSB1cGRhdGVkXG5cdFx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xuXHRcdFx0XHRtYWluQ2lyY2xlcy5hdHRyKFwiclwiLCAkJC5wb2ludFIuYmluZCgkJCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcImN4XCIsIHhQb3NGbik7XG5cblx0XHRcdFx0aWYgKG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiKSkge1xuXHRcdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXG5cdFx0XHRcdC5hdHRyKFwiY3hcIiwgeFBvc0ZuKVxuXHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICdyZWN0YW5nbGUnIGRhdGEgcG9pbnRcblx0cmVjdGFuZ2xlOiB7XG5cdFx0Y3JlYXRlKGVsZW1lbnQsIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcblx0XHRcdGNvbnN0IHJlY3RTaXplRm4gPSBkID0+IHNpemVGbihkKSAqIDIuMDtcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHJlY3RTaXplRm4pXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHJlY3RTaXplRm4pXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXG5cdFx0XHRcdC5ub2RlKCk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdFx0Y29uc3QgciA9ICQkLmNvbmZpZy5wb2ludF9yO1xuXHRcdFx0Y29uc3QgcmVjdFhQb3NGbiA9IGQgPT4geFBvc0ZuKGQpIC0gcjtcblx0XHRcdGNvbnN0IHJlY3RZUG9zRm4gPSBkID0+IHlQb3NGbihkKSAtIHI7XG5cblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XG5cblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9ICQkLmdldFRyYW5zaXRpb25OYW1lKCk7XG5cblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKTtcblxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXG5cdFx0XHRcdC5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKVxuXHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0ZXZlbnQgYXMgZDNFdmVudFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRNaW5NYXgsIGdldFJhbmdlLCBpc0RlZmluZWQsIGlzRW1wdHksIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlLCB0b0FycmF5fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xvY2t3aXNlIElmIHRoZSBkaXJlY3Rpb24gaXMgY2xvY2t3aXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb29yZGluYXRlIHR5cGUgJ3gnIG9yICd5J1xuICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2UgTnVtYmVyIG9mIGVkZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgVGhlIGluZGV4ZWQgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZSwgdHlwZSwgZWRnZSwgcG9zLCByYW5nZSwgcmF0aW8pIHtcblx0Y29uc3QgaW5kZXggPSBpc0Nsb2Nrd2lzZSAmJiBwb3MgPiAwID8gZWRnZSAtIHBvcyA6IHBvcztcblx0Y29uc3QgciA9IDIgKiBNYXRoLlBJO1xuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xuXG5cdHJldHVybiByYW5nZSAqICgxIC0gcmF0aW8gKiBmdW5jKGluZGV4ICogciAvIGVkZ2UpKTtcbn1cblxuLy8gY2FjaGUga2V5XG5jb25zdCBjYWNoZUtleSA9IFwiJHJhZGFyUG9pbnRzXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UmFkYXIoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcblx0XHRcdCQkLnJhZGFycyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRSYWRhcnMpO1xuXG5cdFx0XHQvLyBsZXZlbFxuXHRcdFx0JCQucmFkYXJzLmxldmVscyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGV2ZWxzKTtcblxuXHRcdFx0Ly8gYXhpc1xuXHRcdFx0JCQucmFkYXJzLmF4ZXMgPSAkJC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXMpO1xuXG5cdFx0XHQvLyBzaGFwZXNcblx0XHRcdCQkLnJhZGFycy5zaGFwZXMgPSAkJC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnNoYXBlcyk7XG5cblx0XHRcdCQkLm1heFZhbHVlID0gY29uZmlnLnJhZGFyX2F4aXNfbWF4IHx8ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFJhZGFyU2l6ZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGggPCA0ID8gLTIwIDogMTA7XG5cdFx0Y29uc3Qgc2l6ZSA9IChNYXRoLm1pbigkJC5hcmNXaWR0aCwgJCQuYXJjSGVpZ2h0KSAtIHBhZGRpbmcpIC8gMjtcblxuXHRcdHJldHVybiBbc2l6ZSwgc2l6ZV07XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0c0ZvclJhZGFyKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzKSkge1xuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gZ2V0UmFuZ2UoMCwgZ2V0TWluTWF4KFwibWF4XCIsIHRhcmdldHMubWFwKHYgPT4gdi52YWx1ZXMubGVuZ3RoKSkpO1xuXHRcdH1cblxuXHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcblx0fSxcblxuXHRnZXRSYWRhclBvc2l0aW9uKHR5cGUsIGluZGV4LCByYW5nZSwgcmF0aW8pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XG5cblx0XHRjb25zdCBwb3MgPSB0b0FycmF5KHR5cGUpLm1hcCh2ID0+IGdldFBvc2l0aW9uKFxuXHRcdFx0aXNDbG9ja3dpc2UsXG5cdFx0XHR2LFxuXHRcdFx0ZWRnZSxcblx0XHRcdGluZGV4LFxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlKSA/IHJhbmdlIDogKHR5cGUgPT09IFwieFwiID8gd2lkdGggOiBoZWlnaHQpLFxuXHRcdFx0aXNOdW1iZXIocmF0aW8pID8gcmF0aW8gOiBjb25maWcucmFkYXJfc2l6ZV9yYXRpb1xuXHRcdCkpO1xuXG5cdFx0cmV0dXJuIHBvcy5sZW5ndGggPT09IDEgPyBwb3NbMF0gOiBwb3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xuXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpIHx8IHt9O1xuXHRcdGNvbnN0IHNpemUgPSBwb2ludHMuX3NpemU7XG5cblx0XHQvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvbmx5IHdoZW4gdGhlIHByZXZpb3VzIGRpbWVuc2lvbiBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0aWYgKCFzaXplIHx8IChzaXplLndpZHRoICE9PSB3aWR0aCAmJiBzaXplLmhlaWdodCAhPT0gaGVpZ2h0KSkge1xuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xuXHRcdFx0XHRwb2ludHNbZC5pZF0gPSBkLnZhbHVlcy5tYXAoKHYsIGkpID0+IChcblx0XHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCB1bmRlZmluZWQsICQkLmdldFJhdGlvKFwicmFkYXJcIiwgdikpXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCBwb2ludHMpO1xuXHRcdH1cblx0fSxcblxuXHRyZWRyYXdSYWRhcihkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9ICQkLmdldFRyYW5zbGF0ZShcInJhZGFyXCIpO1xuXG5cdFx0Ly8gQWRqdXN0IHJhZGFyLCBjaXJjbGVzIGFuZCB0ZXh0cycgcG9zaXRpb25cblx0XHRpZiAodHJhbnNsYXRlKSB7XG5cdFx0XHQkJC5yYWRhcnMuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXHRcdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXHRcdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXG5cdFx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XG5cdFx0XHQkJC51cGRhdGVSYWRhckxldmVsKCk7XG5cdFx0XHQkJC51cGRhdGVSYWRhckF4ZXMoKTtcblx0XHRcdCQkLnVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdlbmVyYXRlR2V0UmFkYXJQb2ludHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbZC5pZF1baV07XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50XG5cdFx0XHRdO1xuXHRcdH07XG5cdH0sXG5cblx0dXBkYXRlUmFkYXJMZXZlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGRlcHRoID0gY29uZmlnLnJhZGFyX2xldmVsX2RlcHRoO1xuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xuXHRcdGNvbnN0IHNob3dUZXh0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfc2hvdztcblxuXHRcdGNvbnN0IHJhZGFyTGV2ZWxzID0gJCQucmFkYXJzLmxldmVscztcblx0XHRjb25zdCBsZXZlbERhdGEgPSBnZXRSYW5nZSgwLCBkZXB0aCk7XG5cblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucmFkYXJfc2l6ZV9yYXRpbyAqIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuXHRcdGNvbnN0IGxldmVsUmF0aW8gPSBsZXZlbERhdGEubWFwKGwgPT4gcmFkaXVzICogKChsICsgMSkgLyBkZXB0aCkpO1xuXHRcdGNvbnN0IGxldmVsVGV4dEZvcm1hdCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdDtcblxuXHRcdC8vIEdlbmVyYXRlIHBvaW50c1xuXHRcdGNvbnN0IHBvaW50cyA9IGxldmVsRGF0YS5tYXAodiA9PiB7XG5cdFx0XHRjb25zdCByYW5nZSA9IGxldmVsUmF0aW9bdl07XG5cdFx0XHRjb25zdCBwb3MgPSBnZXRSYW5nZSgwLCBlZGdlKS5tYXAoaSA9PiAoXG5cdFx0XHRcdCQkLmdldFJhZGFyUG9zaXRpb24oW1wieFwiLCBcInlcIl0sIGksIHJhbmdlLCAxKSkuam9pbihcIixcIilcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiBwb3Muam9pbihcIiBcIik7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBsZXZlbCA9IHJhZGFyTGV2ZWxzXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZXZlbH1gKVxuXHRcdFx0LmRhdGEobGV2ZWxEYXRhKTtcblxuXHRcdGxldmVsLmV4aXQoKS5yZW1vdmUoKTtcblxuXHRcdGNvbnN0IGxldmVsRW50ZXIgPSBsZXZlbC5lbnRlcigpLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmxldmVsfSAke0NMQVNTLmxldmVsfS0ke2l9YCk7XG5cblx0XHRsZXZlbEVudGVyLmFwcGVuZChcInBvbHlnb25cIilcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIik7XG5cblx0XHRpZiAoc2hvd1RleHQpIHtcblx0XHRcdGlmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkpIHtcblx0XHRcdFx0cmFkYXJMZXZlbHNcblx0XHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItLjdlbVwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gbGV2ZWxUZXh0Rm9ybWF0KDApKTtcblx0XHRcdH1cblxuXHRcdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXHRcdFx0XHQudGV4dChkID0+IGxldmVsVGV4dEZvcm1hdChcblx0XHRcdFx0XHQkJC5tYXhWYWx1ZSAvIGxldmVsRGF0YS5sZW5ndGggKiAoZCArIDEpXG5cdFx0XHRcdCkpO1xuXHRcdH1cblxuXHRcdGxldmVsRW50ZXJcblx0XHRcdC5tZXJnZShsZXZlbClcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke3dpZHRoIC0gbGV2ZWxSYXRpb1tkXX0sICR7aGVpZ2h0IC0gbGV2ZWxSYXRpb1tkXX0pYClcblx0XHRcdC5zZWxlY3RBbGwoXCJwb2x5Z29uXCIpXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkXSk7XG5cblx0XHQvLyB1cGRhdGUgbGV2ZWwgdGV4dCBwb3NpdGlvblxuXHRcdGlmIChzaG93VGV4dCkge1xuXHRcdFx0cmFkYXJMZXZlbHMuc2VsZWN0QWxsKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcInhcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyB3aWR0aCA6IHBvaW50c1tkXS5zcGxpdChcIixcIilbMF0pKVxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyBoZWlnaHQgOiAwKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZVJhZGFyQXhlcygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGNhdGVnb3JpZXMgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XG5cblx0XHRsZXQgYXhpcyA9ICQkLnJhZGFycy5heGVzLnNlbGVjdEFsbChcImdcIilcblx0XHRcdC5kYXRhKGNhdGVnb3JpZXMpO1xuXG5cdFx0YXhpcy5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRjb25zdCBheGlzRW50ZXIgPSBheGlzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuYXhpc30tJHtpfWApO1xuXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xuXHRcdGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuXHRcdGF4aXMgPSBheGlzRW50ZXIubWVyZ2UoYXhpcyk7XG5cblx0XHQvLyBheGlzIGxpbmVcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93KSB7XG5cdFx0XHRheGlzLnNlbGVjdChcImxpbmVcIilcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB3aWR0aClcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBoZWlnaHQpXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGkpKVxuXHRcdFx0XHQuYXR0cihcInkyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpKSk7XG5cdFx0fVxuXG5cdFx0Ly8gYXhpcyB0ZXh0XG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdykge1xuXHRcdFx0Y29uc3Qge3ggPSAwLCB5ID0gMH0gPSBjb25maWcucmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uO1xuXG5cdFx0XHRheGlzLnNlbGVjdChcInRleHRcIilcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi41ZW1cIilcblx0XHRcdFx0LmNhbGwoc2VsZWN0aW9uID0+IHtcblx0XHRcdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0XHRzZXRUZXh0VmFsdWUoZDNTZWxlY3QodGhpcyksIFN0cmluZyhkKSwgWy0wLjYsIDEuMl0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZGF0dW0oKGQsIGkpID0+ICh7aW5kZXg6IGl9KSlcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh0aGlzLndpZHRoKSkge1xuXHRcdFx0XHRcdFx0Ly8gY2FjaGUgZXZhbHVhdGVkIGF4aXMgdGV4dCB3aWR0aFxuXHRcdFx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBwb3NYID0gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKTtcblx0XHRcdFx0XHRsZXQgcG9zWSA9IE1hdGgucm91bmQoJCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAocG9zWCA+IHdpZHRoKSB7XG5cdFx0XHRcdFx0XHRwb3NYICs9IHRoaXMud2lkdGggKyB4O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoTWF0aC5yb3VuZChwb3NYKSA8IHdpZHRoKSB7XG5cdFx0XHRcdFx0XHRwb3NYIC09IHRoaXMud2lkdGggKyB4O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChwb3NZID4gaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdmVydGljYWwgY2VudGVyZWQgZWRnZSBheGlzIHRleHQgZHkgcG9zaXRpb25cblx0XHRcdFx0XHRcdGlmIChwb3NZIC8gMiA9PT0gaGVpZ2h0ICYmIHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lID09PSBcInRzcGFuXCIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImR5XCIsIFwiMGVtXCIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwb3NZICs9IHk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3NZIDwgaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRwb3NZIC09IHk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHtwb3NYfSAke3Bvc1l9KWA7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkLmJpbmRFdmVudCgpO1xuXHR9LFxuXG5cdGJpbmRFdmVudCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkKSB7XG5cdFx0XHRjb25zdCBpc01vdXNlID0gJCQuaW5wdXRUeXBlID09PSBcIm1vdXNlXCI7XG5cdFx0XHRjb25zdCBnZXRJbmRleCA9ICgpID0+IHtcblx0XHRcdFx0bGV0IHRhcmdldCA9IGQzRXZlbnQudGFyZ2V0O1xuXG5cdFx0XHRcdC8vIGluIGNhc2Ugb2YgbXVsdGlsaW5lZCBheGlzIHRleHRcblx0XHRcdFx0aWYgKC90c3Bhbi9pLnRlc3QodGFyZ2V0LnRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkID0gZDNTZWxlY3QodGFyZ2V0KS5kYXR1bSgpO1xuXG5cdFx0XHRcdHJldHVybiBkICYmIE9iamVjdC5rZXlzKGQpLmxlbmd0aCA9PT0gMSA/IGQuaW5kZXggOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgaGlkZSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xuXHRcdFx0XHRjb25zdCBub0luZGV4ID0gaXNVbmRlZmluZWQoaW5kZXgpO1xuXG5cdFx0XHRcdGlmIChpc01vdXNlIHx8IG5vSW5kZXgpIHtcblx0XHRcdFx0XHR0aGlzLmhpZGVUb29sdGlwKCk7XG5cdFx0XHRcdFx0dGhpcy51bmV4cGFuZENpcmNsZXMoKTtcblxuXHRcdFx0XHRcdGlmIChpc01vdXNlKSB7XG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBpbmRleCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub0luZGV4KSB7XG5cdFx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQkJC5yYWRhcnMuc2VsZWN0KGAuJHtDTEFTUy5heGlzfWApXG5cdFx0XHRcdC5vbihpc01vdXNlID8gXCJtb3VzZW92ZXIgXCIgOiBcInRvdWNoc3RhcnRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGlmICgkJC50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcblxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoJCQuc3ZnLm5vZGUoKSwgbnVsbCwgaW5kZXgpO1xuXHRcdFx0XHRcdGlzTW91c2UgPyAkJC5zZXRPdmVyT3V0KHRydWUsIGluZGV4KSA6ICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBpc01vdXNlID8gaGlkZSA6IG51bGwpO1xuXG5cdFx0XHRpZiAoIWlzTW91c2UpIHtcblx0XHRcdFx0JCQuc3ZnLm9uKFwidG91Y2hzdGFydFwiLCBoaWRlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0Y29uc3QgYXJlYXMgPSAkJC5yYWRhcnMuc2hhcGVzXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxuXHRcdFx0LmRhdGEodGFyZ2V0cyk7XG5cblx0XHRjb25zdCBhcmVhc0VudGVyID0gYXJlYXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2hhcnRSYWRhci5iaW5kKCQkKSk7XG5cblx0XHRhcmVhcy5leGl0KCkudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0YXJlYXNFbnRlclxuXHRcdFx0LmFwcGVuZChcInBvbHlnb25cIilcblx0XHRcdC5tZXJnZShhcmVhcylcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiAkJC5jb2xvcihkKSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBkID0+ICQkLmNvbG9yKGQpKVxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZC5pZF0uam9pbihcIiBcIikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgZGF0YSBwb2ludCB4IGNvb3JkaW5hdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3Rcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmFkYXJDaXJjbGVYKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYWNoZShjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBkYXRhIHBvaW50IHkgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyYWRhckNpcmNsZVkoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldENhY2hlKGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVsxXTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2NhcGl0YWxpemUsIGV4dGVuZCwgZ2V0Qm91bmRpbmdSZWN0LCBnZXRSYW5kb20sIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFRleHQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRUZXh0cyk7XG5cblx0XHQkJC5tYWluVGV4dCA9IGQzU2VsZWN0QWxsKFtdKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGNoYXJ0VGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXG5cdCAqL1xuXHR1cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NUZXh0cyA9ICQkLmNsYXNzVGV4dHMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgbWFpblRleHRVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0VGV4dH1gKVxuXHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0VGV4dChkKSArIGNsYXNzRm9jdXMoZCkpO1xuXG5cdFx0Y29uc3QgbWFpblRleHRFbnRlciA9IG1haW5UZXh0VXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0VGV4dClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cblx0XHRtYWluVGV4dEVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHR1cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZGF0YUZuID0gJCQubGFiZWxpc2hEYXRhLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzVGV4dCA9ICQkLmNsYXNzVGV4dC5iaW5kKCQkKTtcblxuXHRcdCQkLm1haW5UZXh0ID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxuXHRcdFx0LmRhdGEoZCA9PiAodGhpcy5pc1JhZGFyVHlwZShkKSA/IGQudmFsdWVzIDogZGF0YUZuKGQpKSk7XG5cblx0XHQkJC5tYWluVGV4dC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluVGV4dCA9ICQkLm1haW5UZXh0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQubWVyZ2UoJCQubWFpblRleHQpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZCA9PiAoY29uZmlnLmF4aXNfcm90YXRlZCA/IChkLnZhbHVlIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpIDogXCJtaWRkbGVcIikpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZVRleHRDb2xvci5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC50ZXh0KChkLCBpLCBqKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKSh2YWx1ZSwgZC5pZCwgaSwgaik7XG5cdFx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVUZXh0Q29sb3IoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBsYWJlbENvbG9ycyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVsc19jb2xvcnM7XG5cdFx0bGV0IGNvbG9yO1xuXG5cdFx0aWYgKGlzU3RyaW5nKGxhYmVsQ29sb3JzKSkge1xuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9ycztcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KGxhYmVsQ29sb3JzKSkge1xuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9yc1tkLmlkXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3IgfHwgJCQuY29sb3IoZCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyBjaGFydFRleHRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geCBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB5IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB5XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yRmxvd1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVkcmF3VGV4dCh4LCB5LCBmb3JGbG93LCB3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0ID0gZ2V0UmFuZG9tKCk7XG5cdFx0Y29uc3Qgb3BhY2l0eUZvclRleHQgPSBmb3JGbG93ID8gMCA6ICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdHRoaXMubWFpblRleHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgdGV4dCA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdC8vIGRvIG5vdCBhcHBseSB0cmFuc2l0aW9uIGZvciBuZXdseSBhZGRlZCB0ZXh0IGVsZW1lbnRzXG5cdFx0XHRcdCh3aXRoVHJhbnNpdGlvbiAmJiB0ZXh0LmF0dHIoXCJ4XCIpID8gdGV4dC50cmFuc2l0aW9uKHQpIDogdGV4dClcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeSlcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZVRleHRDb2xvci5iaW5kKCQkKSlcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgb3BhY2l0eUZvclRleHQpO1xuXHRcdFx0fSlcblx0XHRdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdmFsdWUgb2YgdGhlIGVsZW1lbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdCAqL1xuXHRnZXRUZXh0UmVjdChlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGJhc2UgPSAoZWxlbWVudC5ub2RlID8gZWxlbWVudC5ub2RlKCkgOiBlbGVtZW50KTtcblxuXHRcdGlmICghL3RleHQvaS50ZXN0KGJhc2UudGFnTmFtZSkpIHtcblx0XHRcdGJhc2UgPSBiYXNlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRleHQgPSBiYXNlLnRleHRDb250ZW50O1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gYCQke3RleHQucmVwbGFjZSgvXFxXL2csIFwiX1wiKX1gO1xuXHRcdGxldCByZWN0ID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0aWYgKCFyZWN0KSB7XG5cdFx0XHQkJC5zdmcuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXG5cdFx0XHRcdC5zdHlsZShcImZvbnRcIiwgZDNTZWxlY3QoYmFzZSkuc3R5bGUoXCJmb250XCIpKVxuXHRcdFx0XHQuY2xhc3NlZChjbGFzc05hbWUsIHRydWUpXG5cdFx0XHRcdC50ZXh0KHRleHQpXG5cdFx0XHRcdC5jYWxsKHYgPT4ge1xuXHRcdFx0XHRcdHJlY3QgPSBnZXRCb3VuZGluZ1JlY3Qodi5ub2RlKCkpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCByZWN0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeCBvciB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyB2YWx1ZXNcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JYIHdoZXRoZXIgb3Igbm90IHRvIHhcblx0ICogQHJldHVybnMge051bWJlcn0gY29vcmRpbmF0ZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlWFlGb3JUZXh0KGluZGljZXMsIGZvclgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhpbmRpY2VzKTtcblx0XHRjb25zdCBwb2ludHMgPSB7fTtcblx0XHRjb25zdCBnZXR0ZXIgPSBmb3JYID8gJCQuZ2V0WEZvclRleHQgOiAkJC5nZXRZRm9yVGV4dDtcblxuXHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIik7XG5cblx0XHR0eXBlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0cG9pbnRzW3ZdID0gJCRbYGdlbmVyYXRlR2V0JHtjYXBpdGFsaXplKHYpfVBvaW50c2BdKGluZGljZXNbdl0sIGZhbHNlKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRjb25zdCB0eXBlID0gKCQkLmlzQXJlYVR5cGUoZCkgJiYgXCJhcmVhXCIpIHx8XG5cdFx0XHRcdCgkJC5pc0JhclR5cGUoZCkgJiYgXCJiYXJcIikgfHxcblx0XHRcdFx0KCQkLmlzUmFkYXJUeXBlKGQpICYmIFwicmFkYXJcIikgfHwgXCJsaW5lXCI7XG5cblx0XHRcdHJldHVybiBnZXR0ZXIuY2FsbCgkJCwgcG9pbnRzW3R5cGVdKGQsIGkpLCBkLCB0aGlzKTtcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgY2VudGVyaXplZCB0ZXh0IHBvc2l0aW9uIGZvciBiYXIgdHlwZSBkYXRhLmxhYmVsLnRleHRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3Rcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFBvc2l0aW9uIHZhbHVlXG5cdCAqL1xuXHRnZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGlmIChjb25maWcuZGF0YV9sYWJlbHMuY2VudGVyZWQgJiYgJCQuaXNCYXJUeXBlKGQpKSB7XG5cdFx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcblx0XHRcdGNvbnN0IGlzUG9zaXRpdmUgPSBkLnZhbHVlID49IDA7XG5cblx0XHRcdGlmIChpc1JvdGF0ZWQpIHtcblx0XHRcdFx0Y29uc3QgdyA9IChcblx0XHRcdFx0XHRpc1Bvc2l0aXZlID9cblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXSA6XG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV1cblx0XHRcdFx0KSAvIDIgKyAocmVjdC53aWR0aCAvIDIpO1xuXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gLXcgLSAzIDogdyArIDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBoID0gKFxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xuXHRcdFx0XHRcdFx0cG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdIDpcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXVxuXHRcdFx0XHQpIC8gMiArIChyZWN0LmhlaWdodCAvIDIpO1xuXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gaCA6IC1oIC0gMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGNvb3JkaW5hdGVcblx0ICovXG5cdGdldFhGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHhQb3M7XG5cdFx0bGV0IHBhZGRpbmc7XG5cblx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHRwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XG5cdFx0XHR4UG9zID0gcG9pbnRzWzJdWzFdICsgcGFkZGluZyAqIChkLnZhbHVlIDwgMCA/IC0xIDogMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhQb3MgPSAkJC5oYXNUeXBlKFwiYmFyXCIpID8gKHBvaW50c1syXVswXSArIHBvaW50c1swXVswXSkgLyAyIDogcG9pbnRzWzBdWzBdO1xuXHRcdH1cblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRpZiAoeFBvcyA+ICQkLndpZHRoKSB7XG5cdFx0XHRcdGNvbnN0IHt3aWR0aH0gPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xuXG5cdFx0XHRcdHhQb3MgPSAkJC53aWR0aCAtIHdpZHRoO1xuXHRcdFx0fSBlbHNlIGlmICh4UG9zIDwgMCkge1xuXHRcdFx0XHR4UG9zID0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHR4UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4geFBvcyArIChjb25maWcuZGF0YV9sYWJlbHNfcG9zaXRpb24ueCB8fCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGNvb3JkaW5hdGVcblx0ICovXG5cdGdldFlGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgciA9IGNvbmZpZy5wb2ludF9yO1xuXHRcdGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xuXHRcdGxldCBiYXNlWSA9IDM7XG5cdFx0bGV0IHlQb3M7XG5cblx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHR5UG9zID0gKHBvaW50c1swXVswXSArIHBvaW50c1syXVswXSArIHJlY3QuaGVpZ2h0ICogMC42KSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHlQb3MgPSBwb2ludHNbMl1bMV07XG5cblx0XHRcdGlmIChpc051bWJlcihyKSAmJiByID4gNSAmJiAoJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGQpKSkge1xuXHRcdFx0XHRiYXNlWSArPSBjb25maWcucG9pbnRfciAvIDIuMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGQudmFsdWUgPCAwIHx8IChkLnZhbHVlID09PSAwICYmICEkJC5oYXNQb3NpdGl2ZVZhbHVlICYmICQkLmhhc05lZ2F0aXZlVmFsdWUpKSB7XG5cdFx0XHRcdHlQb3MgKz0gcmVjdC5oZWlnaHQgKyAoJCQuaXNCYXJUeXBlKGQpID8gLWJhc2VZIDogYmFzZVkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGRpZmYgPSAtYmFzZVkgKiAyO1xuXG5cdFx0XHRcdGlmICgkJC5pc0JhclR5cGUoZCkpIHtcblx0XHRcdFx0XHRkaWZmID0gLWJhc2VZO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xuXHRcdFx0XHRcdGRpZmYgPSBiYXNlWTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlQb3MgKz0gZGlmZjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsICYmICFpc1JvdGF0ZWQpIHtcblx0XHRcdGNvbnN0IGJveEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoeVBvcyA8IGJveEhlaWdodCkge1xuXHRcdFx0XHR5UG9zID0gYm94SGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmICh5UG9zID4gdGhpcy5oZWlnaHQpIHtcblx0XHRcdFx0eVBvcyA9IHRoaXMuaGVpZ2h0IC0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWlzUm90YXRlZCkge1xuXHRcdFx0eVBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHlQb3MgKyAoY29uZmlnLmRhdGFfbGFiZWxzX3Bvc2l0aW9uLnkgfHwgMCk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8vIGRlZmluZWQgY2hhcnQgdHlwZXMgYXMgY2F0ZWdvcnlcbmNvbnN0IFRZUEVTID0ge1xuXHRBcmVhOiBbXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcImFyZWEtc3RlcFwiXSxcblx0QXJlYVJhbmdlOiBbXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiXSxcblx0QXJjOiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCIsIFwicmFkYXJcIl0sXG5cdExpbmU6IFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXG5cdFN0ZXA6IFtcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXG5cdFNwbGluZTogW1wic3BsaW5lXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiXVxufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdHNldFRhcmdldFR5cGUodGFyZ2V0SWRzLCB0eXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHQkJC53aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZXNbaWRdID0gdHlwZTtcblx0XHR9KTtcblxuXHRcdGlmICghdGFyZ2V0SWRzKSB7XG5cdFx0XHRjb25maWcuZGF0YV90eXBlID0gdHlwZTtcblx0XHR9XG5cdH0sXG5cblx0aGFzVHlwZSh0eXBlLCB0YXJnZXRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZXMgPSAkJC5jb25maWcuZGF0YV90eXBlcztcblx0XHRjb25zdCB0YXJnZXRzID0gdGFyZ2V0c1ZhbHVlIHx8ICQkLmRhdGEudGFyZ2V0cztcblx0XHRsZXQgaGFzID0gZmFsc2U7XG5cblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XG5cdFx0XHRcdGNvbnN0IHQgPSB0eXBlc1t0YXJnZXQuaWRdO1xuXG5cdFx0XHRcdGlmICgodCAmJiB0LmluZGV4T2YodHlwZSkgPj0gMCkgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xuXHRcdFx0XHRcdGhhcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoT2JqZWN0LmtleXModHlwZXMpLmxlbmd0aCkge1xuXHRcdFx0T2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhhcyA9ICQkLmNvbmZpZy5kYXRhX3R5cGUgPT09IHR5cGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhcztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcblx0ICogQHBhcm1hIHtTdHJpbmd9IHR5cGUgVHlwZSBrZXlcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFzVHlwZU9mKHR5cGUsIHRhcmdldHMsIGV4Y2x1ZGUgPSBbXSkge1xuXHRcdHJldHVybiAhVFlQRVNbdHlwZV1cblx0XHRcdC5maWx0ZXIodiA9PiBleGNsdWRlLmluZGV4T2YodikgPT09IC0xKVxuXHRcdFx0LmV2ZXJ5KHYgPT4gIXRoaXMuaGFzVHlwZSh2LCB0YXJnZXRzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGNoYXJ0IHR5cGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGlzVHlwZU9mKGQsIHR5cGUpIHtcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XG5cdFx0Y29uc3QgZGF0YVR5cGUgPSB0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcblxuXHRcdHJldHVybiBpc0FycmF5KHR5cGUpID9cblx0XHRcdHR5cGUuaW5kZXhPZihkYXRhVHlwZSkgPj0gMCA6IGRhdGFUeXBlID09PSB0eXBlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBjb250YWlucyBhcmMgdHlwZXMgY2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFzQXJjVHlwZSh0YXJnZXRzLCBleGNsdWRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZU9mKFwiQXJjXCIsIHRhcmdldHMsIGV4Y2x1ZGUpO1xuXHR9LFxuXG5cdGlzTGluZVR5cGUoZCkge1xuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcblxuXHRcdHJldHVybiAhdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0gfHxcblx0XHRcdHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVTLkxpbmUpO1xuXHR9LFxuXG5cdGlzU3RlcFR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlN0ZXApO1xuXHR9LFxuXG5cdGlzU3BsaW5lVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuU3BsaW5lKTtcblx0fSxcblxuXHRpc0FyZWFUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5BcmVhKTtcblx0fSxcblxuXHRpc0FyZWFSYW5nZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLkFyZWFSYW5nZSk7XG5cdH0sXG5cblx0aXNCYXJUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJhclwiKTtcblx0fSxcblxuXHRpc0J1YmJsZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYnViYmxlXCIpO1xuXHR9LFxuXG5cdGlzU2NhdHRlclR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcblx0fSxcblxuXHRpc1BpZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicGllXCIpO1xuXHR9LFxuXG5cdGlzR2F1Z2VUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImdhdWdlXCIpO1xuXHR9LFxuXG5cdGlzRG9udXRUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xuXHR9LFxuXG5cdGlzUmFkYXJUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInJhZGFyXCIpO1xuXHR9LFxuXG5cdGlzQXJjVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNQaWVUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzR2F1Z2VUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzUmFkYXJUeXBlKGQpO1xuXHR9LFxuXG5cdC8vIGRldGVybWluZSBpZiBpcyAnY2lyY2xlJyBkYXRhIHBvaW50XG5cdGlzQ2lyY2xlUG9pbnQoKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcGF0dGVybiA9IGNvbmZpZy5wb2ludF9wYXR0ZXJuO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXG5cdFx0XHQoIXBhdHRlcm4gfHwgKGlzQXJyYXkocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDApKTtcblx0fSxcblxuXHRsaW5lRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xuXHR9LFxuXG5cdGFyY0RhdGEoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gW2RdIDogW107XG5cdH0sXG5cblx0YmFyRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGRhdGEgYWRhcHQgZm9yIGRhdGEgbGFiZWwgc2hvd2luZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGxhYmVsaXNoRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcblx0XHRcdHRoaXMuaXNTY2F0dGVyVHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc0J1YmJsZVR5cGUoZCkgfHxcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuXHR9LFxuXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgfHwgdGhpcy5pc0xpbmVUeXBlKGQpIHx8IHRoaXMuaXNCdWJibGVUeXBlKGQpID9cblx0XHRcdGQudmFsdWVzIDogW107XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlI2N1cnZlc1xuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGUpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0XCJiYXNpc1wiLFxuXHRcdFx0XCJiYXNpcy1jbG9zZWRcIixcblx0XHRcdFwiYmFzaXMtb3BlblwiLFxuXHRcdFx0XCJidW5kbGVcIixcblx0XHRcdFwiY2FyZGluYWxcIixcblx0XHRcdFwiY2FyZGluYWwtY2xvc2VkXCIsXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcblx0XHRcdFwiY2F0bXVsbC1yb21cIixcblx0XHRcdFwiY2F0bXVsbC1yb20tY2xvc2VkXCIsXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcblx0XHRcdFwibGluZWFyXCIsXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIixcblx0XHRcdFwibW9ub3RvbmUteFwiLFxuXHRcdFx0XCJtb25vdG9uZS15XCIsXG5cdFx0XHRcIm5hdHVyYWxcIlxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0FycmF5LCBpc1ZhbHVlfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8vIEdyaWQgcG9zaXRpb24gYW5kIHRleHQgYW5jaG9yIGhlbHBlcnNcbmNvbnN0IGdldEdyaWRUZXh0QW5jaG9yID0gZCA9PiBpc1ZhbHVlKGQucG9zaXRpb24pIHx8IFwiZW5kXCI7XG5jb25zdCBnZXRHcmlkVGV4dER4ID0gZCA9PiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gNCA6IChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiID8gMCA6IC00KSk7XG5jb25zdCBnZXRHcmlkVGV4dFggPSAoaXNYLCB3aWR0aCwgaGVpZ2h0KSA9PiBkID0+IHtcblx0bGV0IHggPSBpc1ggPyAwIDogd2lkdGg7XG5cblx0aWYgKGQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuXHRcdHggPSBpc1ggPyAtaGVpZ2h0IDogMDtcblx0fSBlbHNlIGlmIChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiKSB7XG5cdFx0eCA9IChpc1ggPyAtaGVpZ2h0IDogd2lkdGgpIC8gMjtcblx0fVxuXG5cdHJldHVybiB4O1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRHcmlkKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnhncmlkID0gZDNTZWxlY3RBbGwoW10pO1xuXG5cdFx0JCQuaW5pdEdyaWRMaW5lcygpO1xuXHRcdCQkLmluaXRYWUZvY3VzR3JpZCgpO1xuXHR9LFxuXG5cdGluaXRHcmlkTGluZXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xuXHRcdFx0JCQuZ3JpZExpbmVzID0gJCQubWFpbi5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5jaGFydH0ke2NvbmZpZy5ncmlkX2xpbmVzX2Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWApXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoRm9yR3JpZClcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy5ncmlkfSAke0NMQVNTLmdyaWRMaW5lc31gKTtcblxuXHRcdFx0JCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkTGluZXMpO1xuXHRcdFx0JCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkTGluZXMpO1xuXG5cdFx0XHQkJC54Z3JpZExpbmVzID0gZDNTZWxlY3RBbGwoW10pO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHhncmlkRGF0YSA9ICQkLmdlbmVyYXRlR3JpZERhdGEoY29uZmlnLmdyaWRfeF90eXBlLCAkJC54KTtcblx0XHRjb25zdCB0aWNrT2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gJCQueEF4aXMudGlja09mZnNldCgpIDogMDtcblx0XHRjb25zdCBwb3MgPSBkID0+ICgoJCQuem9vbVNjYWxlIHx8ICQkLngpKGQpICsgdGlja09mZnNldCkgKiAoaXNSb3RhdGVkID8gLTEgOiAxKTtcblxuXHRcdCQkLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcblx0XHRcdFwieDFcIjogMCxcblx0XHRcdFwieDJcIjogJCQud2lkdGgsXG5cdFx0XHRcInkxXCI6IHBvcyxcblx0XHRcdFwieTJcIjogcG9zLFxuXHRcdH0gOiB7XG5cdFx0XHRcIngxXCI6IHBvcyxcblx0XHRcdFwieDJcIjogcG9zLFxuXHRcdFx0XCJ5MVwiOiAwLFxuXHRcdFx0XCJ5MlwiOiAkJC5oZWlnaHQsXG5cdFx0fTtcblxuXHRcdCQkLnhncmlkID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWR9YClcblx0XHRcdC5kYXRhKHhncmlkRGF0YSk7XG5cblx0XHQkJC54Z3JpZC5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHQkJC54Z3JpZCA9ICQkLnhncmlkLmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKVxuXHRcdFx0Lm1lcmdlKCQkLnhncmlkKTtcblxuXHRcdGlmICghd2l0aG91dFVwZGF0ZSkge1xuXHRcdFx0JCQueGdyaWQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgZ3JpZCA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdE9iamVjdC5rZXlzKCQkLnhncmlkQXR0cikuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRcdFx0Z3JpZC5hdHRyKGlkLCAkJC54Z3JpZEF0dHJbaWRdKVxuXHRcdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAoKSA9PiAoXG5cdFx0XHRcdFx0XHRcdGdyaWQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIpID09PSAoaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogMCkgP1xuXHRcdFx0XHRcdFx0XHRcdFwiMFwiIDogXCIxXCJcblx0XHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVZR3JpZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgZ3JpZFZhbHVlcyA9ICQkLnlBeGlzLnRpY2tWYWx1ZXMoKSB8fCAkJC55LnRpY2tzKGNvbmZpZy5ncmlkX3lfdGlja3MpO1xuXHRcdGNvbnN0IHBvcyA9IGQgPT4gTWF0aC5jZWlsKCQkLnkoZCkpO1xuXG5cdFx0JCQueWdyaWQgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy55Z3JpZH1gKVxuXHRcdFx0LmRhdGEoZ3JpZFZhbHVlcyk7XG5cblx0XHQkJC55Z3JpZC5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHQkJC55Z3JpZCA9ICQkLnlncmlkXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWQpXG5cdFx0XHQubWVyZ2UoJCQueWdyaWQpO1xuXG5cdFx0JCQueWdyaWQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IHBvcyA6IDApXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHBvcyA6ICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiBwb3MpO1xuXG5cdFx0JCQuc21vb3RoTGluZXMoJCQueWdyaWQsIFwiZ3JpZFwiKTtcblx0fSxcblxuXHR1cGRhdGVHcmlkKGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0ISQkLmdyaWRMaW5lcyAmJiAkJC5pbml0R3JpZExpbmVzKCk7XG5cblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXG5cdFx0JCQuZ3JpZC5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcblxuXHRcdCQkLm1haW4uc2VsZWN0KGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c31gKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblxuXHRcdCQkLnVwZGF0ZVhHcmlkTGluZXMoZHVyYXRpb24pO1xuXHRcdCQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJiAkJC51cGRhdGVYR3JpZCgpO1xuXG5cdFx0JCQueGdyaWRMaW5lcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZExpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy54Z3JpZExpbmV9YClcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xuXG5cdFx0Ly8gZXhpdFxuXHRcdCQkLnhncmlkTGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGVudGVyXG5cdFx0Y29uc3QgeGdyaWRMaW5lID0gJCQueGdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG5cblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJcIiA6IFwicm90YXRlKC05MClcIilcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcblxuXHRcdCQkLnhncmlkTGluZXMgPSB4Z3JpZExpbmUubWVyZ2UoJCQueGdyaWRMaW5lcyk7XG5cblx0XHQkJC54Z3JpZExpbmVzXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcblx0XHRcdC5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIFkgR3JpZCBsaW5lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiYgJCQudXBkYXRlWUdyaWQoKTtcblxuXHRcdCQkLnlncmlkTGluZXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRMaW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWRMaW5lfWApXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKTtcblxuXHRcdC8vIGV4aXRcblx0XHQkJC55Z3JpZExpbmVzLmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGVudGVyXG5cdFx0Y29uc3QgeWdyaWRMaW5lID0gJCQueWdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG5cblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJyb3RhdGUoLTkwKVwiIDogXCJcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xuXG5cdFx0JCQueWdyaWRMaW5lcyA9IHlncmlkTGluZS5tZXJnZSgkJC55Z3JpZExpbmVzKTtcblxuXHRcdC8vIHVwZGF0ZVxuXHRcdGNvbnN0IHl2ID0gJCQueXYuYmluZCgkJCk7XG5cblx0XHQkJC55Z3JpZExpbmVzXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueWdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcblx0XHRcdC5zZWxlY3QoXCJsaW5lXCIpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IHl2IDogMClcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gMCA6IHl2KVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiB5dilcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXG5cdFx0JCQueWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LmF0dHIoXCJkeVwiLCAtNSlcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCAkJC53aWR0aCwgJCQuaGVpZ2h0KSlcblx0XHRcdC5hdHRyKFwieVwiLCB5dilcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH0sXG5cblx0cmVkcmF3R3JpZCh3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHh2ID0gJCQueHYuYmluZCgkJCk7XG5cblx0XHRsZXQgbGluZXMgPSAkJC54Z3JpZExpbmVzLnNlbGVjdChcImxpbmVcIik7XG5cdFx0bGV0IHRleHRzID0gJCQueGdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpO1xuXG5cdFx0bGluZXMgPSAod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcylcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyAkJC53aWR0aCA6IHh2KVxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyB4diA6IDApXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHh2IDogJCQuaGVpZ2h0KTtcblxuXHRcdHRleHRzID0gKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKCFpc1JvdGF0ZWQsICQkLndpZHRoLCAkJC5oZWlnaHQpKVxuXHRcdFx0LmF0dHIoXCJ5XCIsIHh2KVxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLFxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRdO1xuXHR9LFxuXG5cdGluaXRYWUZvY3VzR3JpZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzRnJvbnQgPSBjb25maWcuZ3JpZF9mcm9udDtcblx0XHRjb25zdCBjbGFzc05hbWUgPSBgLiR7Q0xBU1NbaXNGcm9udCAmJiAkJC5ncmlkTGluZXMgPyBcImdyaWRMaW5lc1wiIDogXCJjaGFydFwiXX0ke2lzRnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YDtcblxuXHRcdCQkLmdyaWQgPSAkJC5tYWluLmluc2VydChcImdcIiwgY2xhc3NOYW1lKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGhGb3JHcmlkKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ncmlkKTtcblxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJlxuXHRcdFx0JCQuZ3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZHMpO1xuXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmXG5cdFx0XHQkJC5ncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkcyk7XG5cblx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfc2hvdykge1xuXHRcdFx0JCQuZ3JpZC5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cylcblx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZEZvY3VzKTtcblx0XHR9XG5cdH0sXG5cblx0c2hvd1hHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xuXHRcdGNvbnN0IGZvY3VzRWwgPSAkJC5tYWluLnNlbGVjdEFsbChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YCk7XG5cdFx0Y29uc3QgeHggPSAkJC54eC5iaW5kKCQkKTtcblxuXHRcdGlmICghY29uZmlnLnRvb2x0aXBfc2hvdykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xuXHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvY3VzRWxcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXG5cdFx0XHQuZGF0YShbZGF0YVRvU2hvd1swXV0pXG5cdFx0XHQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIsIHh4KVxuXHRcdFx0LmF0dHIoaXNSb3RhdGVkID8gXCJ5MlwiIDogXCJ4MlwiLCB4eCk7XG5cblx0XHQkJC5zbW9vdGhMaW5lcyhmb2N1c0VsLCBcImdyaWRcIik7XG5cdH0sXG5cblx0aGlkZVhHcmlkRm9jdXMoKSB7XG5cdFx0dGhpcy5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YCkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuXHR9LFxuXG5cdHVwZGF0ZVhncmlkRm9jdXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YClcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IC0xMClcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiAtMTApXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IC0xMCA6IDApXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IC0xMCA6ICQkLmhlaWdodCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVHcmlkRGF0YSh0eXBlLCBzY2FsZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0aWNrTnVtID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApXG5cdFx0XHQuc2VsZWN0QWxsKFwiLnRpY2tcIilcblx0XHRcdC5zaXplKCk7XG5cdFx0bGV0IGdyaWREYXRhID0gW107XG5cblx0XHRpZiAodHlwZSA9PT0gXCJ5ZWFyXCIpIHtcblx0XHRcdGNvbnN0IHhEb21haW4gPSAkJC5nZXRYRG9tYWluKCk7XG5cdFx0XHRjb25zdCBmaXJzdFllYXIgPSB4RG9tYWluWzBdLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRjb25zdCBsYXN0WWVhciA9IHhEb21haW5bMV0uZ2V0RnVsbFllYXIoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGZpcnN0WWVhcjsgaSA8PSBsYXN0WWVhcjsgaSsrKSB7XG5cdFx0XHRcdGdyaWREYXRhLnB1c2gobmV3IERhdGUoYCR7aX0tMDEtMDEgMDA6MDA6MDBgKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdyaWREYXRhID0gc2NhbGUudGlja3MoMTApO1xuXG5cdFx0XHRpZiAoZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSkgeyAvLyB1c2Ugb25seSBpbnRcblx0XHRcdFx0Z3JpZERhdGEgPSBncmlkRGF0YS5maWx0ZXIoZCA9PiBTdHJpbmcoZCkuaW5kZXhPZihcIi5cIikgPCAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JpZERhdGE7XG5cdH0sXG5cblx0Z2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcykge1xuXHRcdHJldHVybiBwYXJhbXMgPyBsaW5lID0+IHtcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHQoaXNBcnJheShwYXJhbXMpID8gcGFyYW1zLmNvbmNhdCgpIDogW3BhcmFtc10pLmZvckVhY2gocGFyYW0gPT4ge1xuXHRcdFx0XHRpZiAoKChcInZhbHVlXCIgaW4gcGFyYW0gJiYgbGluZS52YWx1ZSA9PT0gcGFyYW0udmFsdWUpIHx8IChcImNsYXNzXCIgaW4gcGFyYW0gJiYgbGluZS5jbGFzcyA9PT0gcGFyYW0uY2xhc3MpKSkge1xuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBmb3VuZDtcblx0XHR9IDogKCkgPT4gdHJ1ZTtcblx0fSxcblxuXHRyZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmb3JYKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0b1JlbW92ZSA9ICQkLmdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpO1xuXHRcdGNvbnN0IHRvU2hvdyA9IGxpbmUgPT4gIXRvUmVtb3ZlKGxpbmUpO1xuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lcyA6IENMQVNTLnlncmlkTGluZXM7XG5cdFx0Y29uc3QgY2xhc3NMaW5lID0gZm9yWCA/IENMQVNTLnhncmlkTGluZSA6IENMQVNTLnlncmlkTGluZTtcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtjbGFzc0xpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtjbGFzc0xpbmV9YClcblx0XHRcdC5maWx0ZXIodG9SZW1vdmUpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0Y29uc3QgZ3JpZExpbmVzID0gYGdyaWRfJHtmb3JYID8gXCJ4XCIgOiBcInlcIn1fbGluZXNgO1xuXG5cdFx0Y29uZmlnW2dyaWRMaW5lc10gPSBjb25maWdbZ3JpZExpbmVzXS5maWx0ZXIodG9TaG93KTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRtb3VzZSBhcyBkM01vdXNlXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc2FuaXRpc2UsIHRwbFByb2Nlc3MsIGlzVW5kZWZpbmVkfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRUb29sdGlwKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYmluZHRvID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZHRvO1xuXG5cdFx0JCQudG9vbHRpcCA9IGQzU2VsZWN0KGJpbmR0byk7XG5cblx0XHRpZiAoJCQudG9vbHRpcC5lbXB0eSgpKSB7XG5cdFx0XHQkJC50b29sdGlwID0gJCQuc2VsZWN0Q2hhcnRcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxuXHRcdFx0XHQuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudG9vbHRpcENvbnRhaW5lcilcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cdFx0fVxuXG5cdFx0Ly8gU2hvdyB0b29sdGlwIGlmIG5lZWRlZFxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiBpc1N0cmluZyhjb25maWcudG9vbHRpcF9pbml0X3gpKSB7XG5cdFx0XHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHNbMF07XG5cdFx0XHRcdGxldCBpO1xuXHRcdFx0XHRsZXQgdmFsO1xuXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9ICQkLnBhcnNlRGF0ZShjb25maWcudG9vbHRpcF9pbml0X3gpO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7ICh2YWwgPSB0YXJnZXRzLnZhbHVlc1tpXSk7IGkrKykge1xuXHRcdFx0XHRcdGlmICgodmFsLnggLSBjb25maWcudG9vbHRpcF9pbml0X3gpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSBpO1xuXHRcdFx0fVxuXG5cdFx0XHQkJC50b29sdGlwLmh0bWwoJCQuZ2V0VG9vbHRpcEhUTUwoXG5cdFx0XHRcdCQkLmRhdGEudGFyZ2V0cy5tYXAoZCA9PiAkJC5hZGROYW1lKGQudmFsdWVzW2NvbmZpZy50b29sdGlwX2luaXRfeF0pKSxcblx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcblx0XHRcdFx0JCQuZ2V0WUZvcm1hdCgkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKSksXG5cdFx0XHRcdCQkLmNvbG9yXG5cdFx0XHQpKTtcblxuXHRcdFx0aWYgKCFiaW5kdG8pIHtcblx0XHRcdFx0JCQudG9vbHRpcC5zdHlsZShcInRvcFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLnRvcClcblx0XHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24ubGVmdClcblx0XHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBzdHJpbmdcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRm9ybWF0dGVkIEhUTUwgc3RyaW5nXG5cdCAqL1xuXHRnZXRUb29sdGlwSFRNTCguLi5hcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XG5cdFx0XHRjb25maWcudG9vbHRpcF9jb250ZW50cy5jYWxsKCQkLCAuLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b29sdGlwIGNvbnRlbnQoSFRNTCBzdHJpbmcpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIGRhdGFcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRWYWx1ZUZvcm1hdCBEZWZhdWx0IGZvcm1hdCBmb3IgZWFjaCBkYXRhIHZhbHVlIGluIHRoZSB0b29sdGlwLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2xvciBDb2xvciBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBodG1sXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRpdGxlRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X3RpdGxlIHx8IGRlZmF1bHRUaXRsZUZvcm1hdDtcblx0XHRjb25zdCBuYW1lRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X25hbWUgfHwgKG5hbWUgPT4gbmFtZSk7XG5cdFx0Y29uc3QgdmFsdWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfdmFsdWUgfHwgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyAoKHYsIHJhdGlvKSA9PiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JWApIDogZGVmYXVsdFZhbHVlRm9ybWF0KTtcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xuXHRcdGNvbnN0IGdldFJvd1ZhbHVlID0gcm93ID0+ICgkJC5pc0J1YmJsZVpUeXBlKHJvdykgPyAkJC5nZXRCdWJibGVaRGF0YShyb3cudmFsdWUsIFwielwiKSA6ICQkLmdldEJhc2VWYWx1ZShyb3cpKTtcblx0XHRjb25zdCBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IHJvdyA9PiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSkgOiByb3cgPT4gY29sb3Iocm93KTtcblx0XHRjb25zdCBjb250ZW50cyA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzO1xuXHRcdGNvbnN0IHRwbFN0ciA9IGNvbnRlbnRzLnRlbXBsYXRlO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKCk7XG5cblx0XHRpZiAob3JkZXIgPT09IG51bGwgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCkge1xuXHRcdFx0Ly8gZm9yIHN0YWNrZWQgZGF0YSwgb3JkZXIgc2hvdWxkIGFsaWduZWQgd2l0aCB0aGUgdmlzdWFsbHkgZGlzcGxheWVkIGRhdGFcblx0XHRcdGNvbnN0IGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpXG5cdFx0XHRcdC5tYXAoaTIgPT4gaTIuaWQpXG5cdFx0XHRcdC5yZXZlcnNlKCk7XG5cblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRsZXQgdjEgPSBhID8gYS52YWx1ZSA6IG51bGw7XG5cdFx0XHRcdGxldCB2MiA9IGIgPyBiLnZhbHVlIDogbnVsbDtcblxuXHRcdFx0XHRpZiAodjEgPiAwICYmIHYyID4gMCkge1xuXHRcdFx0XHRcdHYxID0gYS5pZCA/IGlkcy5pbmRleE9mKGEuaWQpIDogbnVsbDtcblx0XHRcdFx0XHR2MiA9IGIuaWQgPyBpZHMuaW5kZXhPZihiLmlkKSA6IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdjEgLSB2Mjtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoL14oYXNjfGRlc2MpJC8udGVzdChvcmRlcikpIHtcblx0XHRcdGNvbnN0IGlzQXNjZW5kaW5nID0gb3JkZXIgPT09IFwiYXNjXCI7XG5cblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRjb25zdCB2MSA9IGEgPyBnZXRSb3dWYWx1ZShhKSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IHYyID0gYiA/IGdldFJvd1ZhbHVlKGIpIDogbnVsbDtcblxuXHRcdFx0XHRyZXR1cm4gaXNBc2NlbmRpbmcgPyB2MSAtIHYyIDogdjIgLSB2MTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcmRlcikpIHtcblx0XHRcdGQuc29ydChvcmRlcik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHBsID0gJCQuZ2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpO1xuXHRcdGNvbnN0IGxlbiA9IGQubGVuZ3RoO1xuXHRcdGxldCB0ZXh0O1xuXHRcdGxldCByb3c7XG5cdFx0bGV0IHBhcmFtO1xuXHRcdGxldCB2YWx1ZTtcblx0XHRsZXQgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cm93ID0gZFtpXTtcblxuXHRcdFx0aWYgKCFyb3cgfHwgIShnZXRSb3dWYWx1ZShyb3cpIHx8IGdldFJvd1ZhbHVlKHJvdykgPT09IDApKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQodGV4dCkpIHtcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSBzYW5pdGlzZSh0aXRsZUZvcm1hdCA/IHRpdGxlRm9ybWF0KHJvdy54KSA6IHJvdy54KTtcblxuXHRcdFx0XHR0ZXh0ID0gdHBsUHJvY2Vzcyh0cGxbMF0sIHtcblx0XHRcdFx0XHRDTEFTU19UT09MVElQOiBDTEFTUy50b29sdGlwLFxuXHRcdFx0XHRcdFRJVExFOiBpc1ZhbHVlKHRpdGxlKSA/IChcblx0XHRcdFx0XHRcdHRwbFN0ciA/IHRpdGxlIDogYDx0cj48dGggY29sc3Bhbj1cIjJcIj4ke3RpdGxlfTwvdGg+PC90cj5gXG5cdFx0XHRcdFx0KSA6IFwiXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHBhcmFtID0gW3Jvdy5yYXRpbywgcm93LmlkLCByb3cuaW5kZXgsIGRdO1xuXHRcdFx0dmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdChnZXRSb3dWYWx1ZShyb3cpLCAuLi5wYXJhbSkpO1xuXG5cdFx0XHRpZiAoJCQuaXNBcmVhUmFuZ2VUeXBlKHJvdykpIHtcblx0XHRcdFx0Y29uc3QgW2hpZ2gsIGxvd10gPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcCh2ID0+IHNhbml0aXNlKFxuXHRcdFx0XHRcdHZhbHVlRm9ybWF0KCQkLmdldEFyZWFSYW5nZURhdGEocm93LCB2KSwgLi4ucGFyYW0pXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdHZhbHVlID0gYDxiPk1pZDo8L2I+ICR7dmFsdWV9IDxiPkhpZ2g6PC9iPiAke2hpZ2h9IDxiPkxvdzo8L2I+ICR7bG93fWA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXG5cdFx0XHRcdGlmIChyb3cubmFtZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbmFtZSA9IHNhbml0aXNlKG5hbWVGb3JtYXQocm93Lm5hbWUsIC4uLnBhcmFtKSk7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gZ2V0QmdDb2xvcihyb3cpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUF9OQU1FOiBDTEFTUy50b29sdGlwTmFtZSArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHJvdy5pZCksXG5cdFx0XHRcdFx0Q09MT1I6ICh0cGxTdHIgfHwgISQkLnBhdHRlcm5zKSA/IGNvbG9yIDogYDxzdmc+PHJlY3Qgc3R5bGU9XCJmaWxsOiR7Y29sb3J9XCIgd2lkdGg9XCIxMFwiIGhlaWdodD1cIjEwXCI+PC9yZWN0Pjwvc3ZnPmAsXG5cdFx0XHRcdFx0TkFNRTogbmFtZSxcblx0XHRcdFx0XHRWQUxVRTogdmFsdWVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAodHBsU3RyICYmIGlzT2JqZWN0KGNvbnRlbnRzLnRleHQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSB0YXJnZXRJZHMuaW5kZXhPZihyb3cuaWQpO1xuXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoY29udGVudHMudGV4dCkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRcdFx0Y29udGVudFZhbHVlW2tleV0gPSBjb250ZW50cy50ZXh0W2tleV1baW5kZXhdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dCArPSB0cGxQcm9jZXNzKHRwbFsxXSwgY29udGVudFZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYCR7dGV4dH08L3RhYmxlPmA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY29udGVudCB0ZW1wbGF0ZSBzdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRwbFN0clxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRlbXBsYXRlIHN0cmluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpIHtcblx0XHRyZXR1cm4gKHRwbFN0ciB8fCBgPHRhYmxlIGNsYXNzPVwiez1DTEFTU19UT09MVElQfVwiPjx0Ym9keT5cblx0XHRcdFx0ez1USVRMRX1cblx0XHRcdFx0e3s8dHIgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj5cblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJuYW1lXCI+JHt0aGlzLnBhdHRlcm5zID8gYHs9Q09MT1J9YCA6IGA8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ez1DT0xPUn1cIj48L3NwYW4+YH17PU5BTUV9PC90ZD5cblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJ2YWx1ZVwiPns9VkFMVUV9PC90ZD5cblx0XHRcdFx0PC90cj59fVxuXHRcdFx0PC90Ym9keT48L3RhYmxlPmApXG5cdFx0XHQucmVwbGFjZSgvKFxccj9cXG58XFx0KS9nLCBcIlwiKVxuXHRcdFx0LnNwbGl0KC97eyguKil9fS8pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVRvU2hvdyBkYXRhXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0V2lkdGggV2lkdGggdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0SGVpZ2h0IEhlaWdodCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0b3AsIGxlZnQgdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRvb2x0aXBQb3NpdGlvbihkYXRhVG9TaG93LCB0V2lkdGgsIHRIZWlnaHQsIGVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBbbGVmdCwgdG9wXSA9IGQzTW91c2UoZWxlbWVudCk7XG5cblx0XHRjb25zdCBzdmdMZWZ0ID0gJCQuZ2V0U3ZnTGVmdCh0cnVlKTtcblx0XHRsZXQgY2hhcnRSaWdodCA9IHN2Z0xlZnQgKyAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCk7XG5cblx0XHR0b3AgKz0gMjA7XG5cblx0XHQvLyBEZXRlcm1pbmUgdG9vbHRpcCBwb3NpdGlvblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdGNvbnN0IHJhdyA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcblxuXHRcdFx0aWYgKCFyYXcpIHtcblx0XHRcdFx0dG9wICs9ICQkLmhlaWdodCAvIDI7XG5cdFx0XHRcdGxlZnQgKz0gKCQkLndpZHRoIC0gKCQkLmlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCkpIC8gMjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZGF0YVNjYWxlID0gJCQueChkYXRhVG9TaG93WzBdLngpO1xuXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0XHR0b3AgPSBkYXRhU2NhbGUgKyAyMDtcblx0XHRcdFx0bGVmdCArPSBzdmdMZWZ0ICsgMTAwO1xuXHRcdFx0XHRjaGFydFJpZ2h0IC09IHN2Z0xlZnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b3AgLT0gNTtcblx0XHRcdFx0bGVmdCA9IHN2Z0xlZnQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQodHJ1ZSkgKyAyMCArICgkJC56b29tU2NhbGUgPyBsZWZ0IDogZGF0YVNjYWxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByaWdodCA9IGxlZnQgKyB0V2lkdGg7XG5cblx0XHRpZiAocmlnaHQgPiBjaGFydFJpZ2h0KSB7XG5cdFx0XHQvLyAyMCBpcyBuZWVkZWQgZm9yIEZpcmVmb3ggdG8ga2VlcCB0b29sdGlwIHdpZHRoXG5cdFx0XHRsZWZ0IC09IHJpZ2h0IC0gY2hhcnRSaWdodCArIDIwO1xuXHRcdH1cblxuXHRcdGlmICh0b3AgKyB0SGVpZ2h0ID4gJCQuY3VycmVudEhlaWdodCkge1xuXHRcdFx0dG9wIC09IHRIZWlnaHQgKyAzMDtcblx0XHR9XG5cblx0XHRpZiAodG9wIDwgMCkge1xuXHRcdFx0dG9wID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3RvcCwgbGVmdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIHRvb2x0aXBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGVkRGF0YVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG5cdCAqL1xuXHRzaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGJpbmR0byA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmR0bztcblx0XHRjb25zdCBmb3JBcmMgPSAkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKTtcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcblx0XHRjb25zdCBwb3NpdGlvbkZ1bmN0aW9uID0gY29uZmlnLnRvb2x0aXBfcG9zaXRpb24gfHwgJCQudG9vbHRpcFBvc2l0aW9uO1xuXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZGF0dW0gPSAkJC50b29sdGlwLmRhdHVtKCk7XG5cdFx0Y29uc3QgZGF0YVN0ciA9IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRGF0YSk7XG5cdFx0bGV0IHdpZHRoID0gKGRhdHVtICYmIGRhdHVtLndpZHRoKSB8fCAwO1xuXHRcdGxldCBoZWlnaHQgPSAoZGF0dW0gJiYgZGF0dW0uaGVpZ2h0KSB8fCAwO1xuXG5cdFx0aWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHNlbGVjdGVkRGF0YS5jb25jYXQoKS5zb3J0KClbMF0uaW5kZXg7XG5cblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkKTtcblxuXHRcdFx0Ly8gc2V0IHRvb2x0aXAgY29udGVudFxuXHRcdFx0JCQudG9vbHRpcFxuXHRcdFx0XHQuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcblx0XHRcdFx0XHRzZWxlY3RlZERhdGEsXG5cdFx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcblx0XHRcdFx0XHQkJC5nZXRZRm9ybWF0KGZvckFyYyksXG5cdFx0XHRcdFx0JCQuY29sb3Jcblx0XHRcdFx0KSlcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcblx0XHRcdFx0LmRhdHVtKHtcblx0XHRcdFx0XHRpbmRleCxcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRXaWR0aFwiKSxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRIZWlnaHRcIilcblx0XHRcdFx0fSk7XG5cblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3duLCAkJCk7XG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcblx0XHR9XG5cblx0XHRpZiAoIWJpbmR0bykge1xuXHRcdFx0Ly8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbkZ1bmN0aW9uLmNhbGwodGhpcywgZGF0YVRvU2hvdywgd2lkdGgsIGhlaWdodCwgZWxlbWVudCk7XG5cblx0XHRcdC8vIFNldCB0b29sdGlwIHBvc2l0aW9uXG5cdFx0XHQkJC50b29sdGlwXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBgJHtwb3NpdGlvbi50b3B9cHhgKVxuXHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGAke3Bvc2l0aW9uLmxlZnR9cHhgKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSB0byBoaWRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoaWRlVG9vbHRpcChmb3JjZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2RvTm90SGlkZSB8fCBmb3JjZSkge1xuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZSwgJCQpO1xuXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXBcblx0XHRcdHRoaXMudG9vbHRpcFxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpIC8vIGZvciBJRTlcblx0XHRcdFx0LmRhdHVtKG51bGwpO1xuXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRkZW4sICQkKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBkaXNwbGF5IGZvciBsaW5rZWQgY2hhcnQgaW5zdGFuY2VzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdyB0cnVlOiBzaG93LCBmYWxzZTogaGlkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggeCBBeGlzIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaGFuZGxlTGlua2VkQ2hhcnRzKHNob3csIGluZGV4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy50b29sdGlwX2xpbmtlZCkge1xuXHRcdFx0Y29uc3QgbGlua2VkTmFtZSA9ICQkLmNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xuXG5cdFx0XHQoJCQuYXBpLmludGVybmFsLmNoYXJ0cyB8fCBbXSkuZm9yRWFjaChjID0+IHtcblx0XHRcdFx0aWYgKGMgIT09ICQkLmFwaSkge1xuXHRcdFx0XHRcdGNvbnN0IGNvbmZpZyA9IGMuaW50ZXJuYWwuY29uZmlnO1xuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcblx0XHRcdFx0XHRjb25zdCBpc0luRG9tID0gZG9jdW1lbnQuYm9keS5jb250YWlucyhjLmVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0aWYgKGlzTGlua2VkICYmIGxpbmtlZE5hbWUgPT09IG5hbWUgJiYgaXNJbkRvbSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGMuaW50ZXJuYWwudG9vbHRpcC5kYXRhKClbMF07XG5cdFx0XHRcdFx0XHRjb25zdCBpc05vdFNhbWVJbmRleCA9IGluZGV4ICE9PSAoZGF0YSAmJiBkYXRhLmluZGV4KTtcblxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCB0aHJvd2luZyBlcnJvciBmb3Igbm9uLXBhaXJlZCBsaW5rZWQgaW5kZXhlc1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuc2hvdyh7aW5kZXh9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghc2hvdykge1xuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRldmVudCBhcyBkM0V2ZW50LFxuXHRuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlc1xufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZuLCBpc0RlZmluZWQsIGdldE9wdGlvbiwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgbm90RW1wdHksIHRwbFByb2Nlc3N9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0TGVnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQkJC5sZWdlbmRJdGVtVGV4dEJveCA9IHt9O1xuXHRcdCQkLmxlZ2VuZEhhc1JlbmRlcmVkID0gZmFsc2U7XG5cdFx0JCQubGVnZW5kID0gJCQuc3ZnLmFwcGVuZChcImdcIik7XG5cblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93KSB7XG5cdFx0XHQkJC5sZWdlbmQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xuXG5cdFx0XHQvLyBNRU1POiBjYWxsIGhlcmUgdG8gdXBkYXRlIGxlZ2VuZCBib3ggYW5kIHRyYW5zbGF0ZSBmb3IgYWxsXG5cdFx0XHQvLyBNRU1POiB0cmFuc2xhdGUgd2lsbCBiZSB1cGRhdGVkIGJ5IHRoaXMsIHNvIHRyYW5zZm9ybSBub3QgbmVlZGVkIGluIHVwZGF0ZUxlZ2VuZCgpXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0XHRcdCQkLmhpZGRlbkxlZ2VuZElkcyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIGVsZW1lbnRcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25zIFJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGVnZW5kKHRhcmdldElkcywgb3B0aW9ucywgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG9wdGlvbnogPSBvcHRpb25zIHx8IHtcblx0XHRcdHdpdGhUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlXG5cdFx0fTtcblxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgdHJ1ZSk7XG5cblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8gJiYgY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSkge1xuXHRcdFx0JCQudXBkYXRlTGVnZW5kVGVtcGxhdGUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCQudXBkYXRlTGVnZW5kRWxlbWVudChcblx0XHRcdFx0dGFyZ2V0SWRzIHx8ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksXG5cdFx0XHRcdG9wdGlvbnosXG5cdFx0XHRcdHRyYW5zaXRpb25zXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcblx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcblxuXHRcdC8vIFVwZGF0ZSBzaXplIGFuZCBzY2FsZVxuXHRcdCQkLnVwZGF0ZVNjYWxlcyhmYWxzZSwgISQkLnpvb21TY2FsZSk7XG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xuXG5cdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXG5cdFx0JCQudHJhbnNmb3JtQWxsKG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKTtcblxuXHRcdCQkLmxlZ2VuZEhhc1JlbmRlcmVkID0gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGxlZ2VuZCB1c2luZyB0ZW1wbGF0ZSBvcHRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgd3JhcHBlciA9IGQzU2VsZWN0KGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvKTtcblx0XHRjb25zdCB0ZW1wbGF0ZSA9IGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGU7XG5cblx0XHRpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRjb25zdCBpZHMgPSBbXTtcblx0XHRcdGxldCBodG1sID0gXCJcIjtcblxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gaXNGdW5jdGlvbih0ZW1wbGF0ZSkgP1xuXHRcdFx0XHRcdHRlbXBsYXRlLmNhbGwoJCQsIHYsICQkLmNvbG9yKHYpLCAkJC5hcGkuZGF0YSh2KVswXS52YWx1ZXMpIDpcblx0XHRcdFx0XHR0cGxQcm9jZXNzKHRlbXBsYXRlLCB7XG5cdFx0XHRcdFx0XHRDT0xPUjogJCQuY29sb3IodiksXG5cdFx0XHRcdFx0XHRUSVRMRTogdlxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdFx0aWRzLnB1c2godik7XG5cdFx0XHRcdFx0aHRtbCArPSBjb250ZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzOyB9KVxuXHRcdFx0XHQuZGF0YShpZHMpO1xuXG5cdFx0XHQkJC5zZXRMZWdlbmRJdGVtKGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHQkJC5sZWdlbmQgPSB3cmFwcGVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBsZWdlbmQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNcblx0ICovXG5cdHVwZGF0ZVNpemVGb3JMZWdlbmQoc2l6ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcblxuXHRcdGNvbnN0IGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XG5cdFx0XHR0b3A6ICQkLmlzTGVnZW5kVG9wID9cblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSArIDUuNSA6XG5cdFx0XHRcdCQkLmN1cnJlbnRIZWlnaHQgLSBoZWlnaHQgLSAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF95LFxuXHRcdFx0bGVmdDogJCQuaXNMZWdlbmRMZWZ0ID9cblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAwLjUgOlxuXHRcdFx0XHQkJC5jdXJyZW50V2lkdGggLSB3aWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNVxuXHRcdH07XG5cblx0XHQkJC5tYXJnaW4zID0ge1xuXHRcdFx0dG9wOiAkJC5pc0xlZ2VuZFJpZ2h0ID9cblx0XHRcdFx0MCA6ICQkLmlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6ICQkLmN1cnJlbnRIZWlnaHQgLSBoZWlnaHQsXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogJCQuaXNMZWdlbmRSaWdodCA/XG5cdFx0XHRcdCQkLmN1cnJlbnRXaWR0aCAtIHdpZHRoIDogJCQuaXNMZWdlbmRJbnNldCA/IGluc2V0TGVnZW5kUG9zaXRpb24ubGVmdCA6IDBcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm0gTGVnZW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICovXG5cdHRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLmxlZ2VuZC50cmFuc2l0aW9uKCkgOiAkJC5sZWdlbmQpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZCBzdGVwXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRTdGVwKHN0ZXApIHtcblx0XHR0aGlzLmxlZ2VuZFN0ZXAgPSBzdGVwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gd2lkdGhcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRJdGVtV2lkdGgodykge1xuXHRcdHRoaXMubGVnZW5kSXRlbVdpZHRoID0gdztcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KGgpIHtcblx0XHR0aGlzLmxlZ2VuZEl0ZW1IZWlnaHQgPSBoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxuXHQgKi9cblx0Z2V0TGVnZW5kV2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcblx0XHRcdCQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/XG5cdFx0XHRcdCQkLmxlZ2VuZEl0ZW1XaWR0aCAqICgkJC5sZWdlbmRTdGVwICsgMSkgOiAkJC5jdXJyZW50V2lkdGhcblx0XHQpIDogMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGVnZW5kSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXG5cdFx0XHQkJC5pc0xlZ2VuZFJpZ2h0ID9cblx0XHRcdFx0JCQuY3VycmVudEhlaWdodCA6IE1hdGgubWF4KDIwLCAkJC5sZWdlbmRJdGVtSGVpZ2h0KSAqICgkJC5sZWdlbmRTdGVwICsgMSlcblx0XHQpIDogMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLlNlbGVjdFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBvcGFjaXR5XG5cdCAqL1xuXHRvcGFjaXR5Rm9yTGVnZW5kKGxlZ2VuZEl0ZW0pIHtcblx0XHRyZXR1cm4gbGVnZW5kSXRlbS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4pID8gbnVsbCA6IFwiMVwiO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZCB0aGF0IGlzIHVuZm9jdXNlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kSXRlbSwgZDMuU2VsZWN0XG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IG9wYWNpdHlcblx0ICovXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSkge1xuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIwLjNcIjtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgZm9jdXMgb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIGZvY3VzLlxuXHQgKi9cblx0dG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmb2N1cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRJZHogPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuXG5cdFx0JCQubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxuXHRcdFx0LmZpbHRlcihpZCA9PiB0YXJnZXRJZHouaW5kZXhPZihpZCkgPj0gMClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmb2N1cylcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKGZvY3VzID8gJCQub3BhY2l0eUZvckxlZ2VuZCA6ICQkLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQpXG5cdFx0XHRcdFx0LmNhbGwoJCQsIGQzU2VsZWN0KHRoaXMpKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXZlcnQgdGhlIGxlZ2VuZCB0byBpdHMgZGVmYXVsdCBzdGF0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmV2ZXJ0TGVnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2hvd3MgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKi9cblx0c2hvd0xlZ2VuZCh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCFjb25maWcubGVnZW5kX3Nob3cpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IHRydWU7XG5cdFx0XHQkJC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcblxuXHRcdFx0ISQkLmxlZ2VuZEhhc1JlbmRlcmVkICYmICQkLnVwZGF0ZUxlZ2VuZCgpO1xuXHRcdH1cblx0XHQkJC5yZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcblxuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKi9cblx0aGlkZUxlZ2VuZCh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdyAmJiBpc0VtcHR5KHRhcmdldElkcykpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuXHRcdFx0JCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0XHR9XG5cblx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcblx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENsZWFyIHRoZSBMZWdlbmRJdGVtVGV4dEJveCBjYWNoZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSgpIHtcblx0XHR0aGlzLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBsZWdlbmQgaXRlbSBzdHlsZSAmIGJpbmQgZXZlbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBpdGVtXG5cdCAqL1xuXHRzZXRMZWdlbmRJdGVtKGl0ZW0pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzVG91Y2ggPSAkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcblxuXHRcdGl0ZW1cblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gaXRlbUNsYXNzICsgJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5sZWdlbmRJdGVtLCBpZCk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBpZCA9PiAoJCQuaXNMZWdlbmRUb1Nob3coaWQpID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSlcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcblx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29uY2xpY2ssICQkLCBpZCkpIHtcblx0XHRcdFx0XHRpZiAoZDNFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdCQkLmFwaS5oaWRlKCk7XG5cdFx0XHRcdFx0XHQkJC5hcGkuc2hvdyhpZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCQkLmFwaS50b2dnbGUoaWQpO1xuXHRcdFx0XHRcdFx0IWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gJCQuYXBpLmZvY3VzKGlkKSA6ICQkLmFwaS5yZXZlcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpc1RvdWNoICYmICQkLmhpZGVUb29sdGlwKCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICghaXNUb3VjaCkge1xuXHRcdFx0aXRlbVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm91dCwgJCQsIGlkKSkge1xuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0JCQuYXBpLnJldmVydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3ZlciwgJCQsIGlkKSkge1xuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRcdGlmICghJCQudHJhbnNpdGluZyAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkpIHtcblx0XHRcdFx0XHRcdFx0JCQuYXBpLmZvY3VzKGlkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsZWdlbmRcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cbiBcdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcGFkZGluZ1RvcCA9IDQ7XG5cdFx0Y29uc3QgcGFkZGluZ1JpZ2h0ID0gMTA7XG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XG5cdFx0Y29uc3QgdGlsZVdpZHRoID0gY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGggKyA1O1xuXHRcdGxldCBtYXhXaWR0aCA9IDA7XG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XG5cdFx0bGV0IHhGb3JMZWdlbmQ7XG5cdFx0bGV0IHlGb3JMZWdlbmQ7XG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcblx0XHRjb25zdCBvZmZzZXRzID0ge307XG5cdFx0Y29uc3Qgd2lkdGhzID0ge307XG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xuXHRcdGNvbnN0IG1hcmdpbnMgPSBbMF07XG5cdFx0Y29uc3Qgc3RlcHMgPSB7fTtcblx0XHRsZXQgc3RlcCA9IDA7XG5cdFx0bGV0IGJhY2tncm91bmQ7XG5cdFx0Y29uc3QgaXNMZWdlbmRSaWdodE9ySW5zZXQgPSAkJC5pc0xlZ2VuZFJpZ2h0IHx8ICQkLmlzTGVnZW5kSW5zZXQ7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxuXHRcdGNvbnN0IHRhcmdldElkeiA9IHRhcmdldElkc1xuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcblxuXHRcdGNvbnN0IHdpdGhUcmFuc2l0aW9uID0gb3B0aW9ucy53aXRoVHJhbnNpdGlvbjtcblxuXHRcdGNvbnN0IGdldFRleHRCb3ggPSBmdW5jdGlvbih0ZXh0RWxlbWVudCwgaWQpIHtcblx0XHRcdGlmICghJCQubGVnZW5kSXRlbVRleHRCb3hbaWRdKSB7XG5cdFx0XHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSA9XG5cdFx0XHRcdFx0JCQuZ2V0VGV4dFJlY3QodGV4dEVsZW1lbnQsIENMQVNTLmxlZ2VuZEl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gJCQubGVnZW5kSXRlbVRleHRCb3hbaWRdO1xuXHRcdH07XG5cblx0XHRjb25zdCB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbih0ZXh0RWxlbWVudCwgaWQsIGluZGV4KSB7XG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xuXHRcdFx0Y29uc3QgaXNMYXN0ID0gaW5kZXggPT09IHRhcmdldElkei5sZW5ndGggLSAxO1xuXHRcdFx0Y29uc3QgYm94ID0gZ2V0VGV4dEJveCh0ZXh0RWxlbWVudCwgaWQpO1xuXHRcdFx0Y29uc3QgaXRlbVdpZHRoID0gYm94LndpZHRoICsgdGlsZVdpZHRoICtcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcblx0XHRcdGNvbnN0IGl0ZW1IZWlnaHQgPSBib3guaGVpZ2h0ICsgcGFkZGluZ1RvcDtcblx0XHRcdGNvbnN0IGl0ZW1MZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IGl0ZW1IZWlnaHQgOiBpdGVtV2lkdGg7XG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XG5cdFx0XHRsZXQgbWFyZ2luO1xuXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxuXHRcdFx0Y29uc3QgdXBkYXRlVmFsdWVzID0gZnVuY3Rpb24oaWQyLCB3aXRob3V0U3RlcCkge1xuXHRcdFx0XHRpZiAoIXdpdGhvdXRTdGVwKSB7XG5cdFx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSB0b3RhbExlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcblxuXHRcdFx0XHRcdGlmIChtYXJnaW4gPCBwb3NNaW4pIHtcblx0XHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gaXRlbUxlbmd0aCkgLyAyO1xuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0c3RlcCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0ZXBzW2lkMl0gPSBzdGVwO1xuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gJCQuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xuXHRcdFx0XHRvZmZzZXRzW2lkMl0gPSB0b3RhbExlbmd0aDtcblx0XHRcdFx0dG90YWxMZW5ndGggKz0gaXRlbUxlbmd0aDtcblx0XHRcdH07XG5cblx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cdFx0XHRcdHN0ZXAgPSAwO1xuXHRcdFx0XHRtYXhXaWR0aCA9IDA7XG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xuXHRcdFx0XHR3aWR0aHNbaWRdID0gMDtcblx0XHRcdFx0aGVpZ2h0c1tpZF0gPSAwO1xuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xuXHRcdFx0XHRvZmZzZXRzW2lkXSA9IDA7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xuXHRcdFx0aGVpZ2h0c1tpZF0gPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xuXHRcdFx0XHRtYXhXaWR0aCA9IGl0ZW1XaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFtYXhIZWlnaHQgfHwgaXRlbUhlaWdodCA+PSBtYXhIZWlnaHQpIHtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gaXRlbUhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWF4TGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBtYXhIZWlnaHQgOiBtYXhXaWR0aDtcblxuXHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRfZXF1YWxseSkge1xuXHRcdFx0XHRPYmplY3Qua2V5cyh3aWR0aHMpLmZvckVhY2goaWQyID0+ICh3aWR0aHNbaWQyXSA9IG1heFdpZHRoKSk7XG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcblx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSBtYXhMZW5ndGggKiB0YXJnZXRJZHoubGVuZ3RoKSAvIDI7XG5cblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xuXHRcdFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcblx0XHRcdFx0XHRzdGVwID0gMDtcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVwZGF0ZVZhbHVlcyhpZCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVwZGF0ZVZhbHVlcyhpZCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmICgkJC5pc0xlZ2VuZEluc2V0KSB7XG5cdFx0XHRzdGVwID0gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwID8gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwIDogdGFyZ2V0SWR6Lmxlbmd0aDtcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmlzTGVnZW5kUmlnaHQpIHtcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcblx0XHR9IGVsc2UgaWYgKCQkLmlzTGVnZW5kSW5zZXQpIHtcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWF4SGVpZ2h0ICogc3RlcHNbaWRdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHhGb3JMZWdlbmRUZXh0ID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSArIDQgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcblx0XHRjb25zdCB4Rm9yTGVnZW5kUmVjdCA9IChpZCwgaSkgPT4geEZvckxlZ2VuZChpZCwgaSk7XG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XG5cdFx0Y29uc3QgeDJGb3JMZWdlbmRUaWxlID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDIgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcblxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XG5cdFx0Y29uc3QgeUZvckxlZ2VuZFJlY3QgPSAoaWQsIGkpID0+IHlGb3JMZWdlbmQoaWQsIGkpIC0gNTtcblx0XHRjb25zdCB5Rm9yTGVnZW5kVGlsZSA9IChpZCwgaSkgPT4geUZvckxlZ2VuZChpZCwgaSkgKyA0O1xuXG5cdFx0Y29uc3QgcG9zID0gLTIwMDtcblxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxuXHRcdGNvbnN0IGwgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHQuZGF0YSh0YXJnZXRJZHopXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImdcIik7XG5cblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xuXG5cdFx0bC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpZCwgaSkge1xuXHRcdFx0XHR1cGRhdGVQb3NpdGlvbnModGhpcywgaWQsIGkpO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geEZvckxlZ2VuZFRleHQgOiBwb3MpXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XG5cblx0XHRsLmFwcGVuZChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geEZvckxlZ2VuZFJlY3QgOiBwb3MpXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XG5cblx0XHRjb25zdCB1c2VQb2ludCA9ICQkLmNvbmZpZy5sZWdlbmRfdXNlUG9pbnQ7XG5cblx0XHRpZiAodXNlUG9pbnQpIHtcblx0XHRcdGNvbnN0IGlkcyA9IFtdO1xuXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcblx0XHRcdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/XG5cdFx0XHRcdFx0Y29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xuXG5cdFx0XHRcdGlkcy5pbmRleE9mKGQpID09PSAtMSAmJiBpZHMucHVzaChkKTtcblxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xuXG5cdFx0XHRcdGlmIChwb2ludCA9PT0gXCJyZWN0YW5nbGVcIikge1xuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XG5cdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1Qb2ludClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcblx0XHRcdFx0LmF0dHIoXCJocmVmXCIsIChkYXRhLCBpZHgsIHNlbGVjdGlvbikgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHskJC5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1UaWxlKVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geDFGb3JMZWdlbmRUaWxlIDogcG9zKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8gcG9zIDogeUZvckxlZ2VuZFRpbGUpXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgYmFja2dyb3VuZCBmb3IgaW5zZXQgbGVnZW5kXG5cdFx0YmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcblxuXHRcdGlmICgkJC5pc0xlZ2VuZEluc2V0ICYmIG1heFdpZHRoID4gMCAmJiBiYWNrZ3JvdW5kLnNpemUoKSA9PT0gMCkge1xuXHRcdFx0YmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kQmFja2dyb3VuZClcblx0XHRcdFx0LmFwcGVuZChcInJlY3RcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dHMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKFwidGV4dFwiKVxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxuXHRcdFx0LnRleHQoaWQgPT4gKGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQpKSAvLyBNRU1POiBuZWVkZWQgZm9yIHVwZGF0ZVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oaWQsIGkpIHtcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcblx0XHRcdH0pO1xuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXG5cdFx0XHQuYXR0cihcInhcIiwgeEZvckxlZ2VuZFRleHQpXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFRleHQpO1xuXG5cdFx0Y29uc3QgcmVjdHMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGByZWN0LiR7Q0xBU1MubGVnZW5kSXRlbUV2ZW50fWApXG5cdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVjdHMudHJhbnNpdGlvbigpIDogcmVjdHMpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIGlkID0+IHdpZHRoc1tpZF0pXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kUmVjdClcblx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yTGVnZW5kUmVjdCk7XG5cblxuXHRcdGlmICh1c2VQb2ludCkge1xuXHRcdFx0Y29uc3QgdGlsZXMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcblxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9ICQkLmNvbmZpZy5wb2ludF9yO1xuXHRcdFx0XHRcdGxldCB4ID0gXCJ4XCI7XG5cdFx0XHRcdFx0bGV0IHkgPSBcInlcIjtcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XG5cdFx0XHRcdFx0bGV0IHlPZmZzZXQgPSAyLjU7XG5cdFx0XHRcdFx0bGV0IHJhZGl1cztcblx0XHRcdFx0XHRsZXQgd2lkdGg7XG5cdFx0XHRcdFx0bGV0IGhlaWdodDtcblxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHBvaW50UiAqIDAuMjtcblxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcblx0XHRcdFx0XHRcdHkgPSBcImN5XCI7XG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBwb2ludFIgKyBzaXplO1xuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gLXNpemU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJyZWN0XCIpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XG5cblx0XHRcdFx0XHRcdHdpZHRoID0gc2l6ZTtcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gMztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxuXHRcdFx0XHRcdFx0LmF0dHIoeCwgZCA9PiB4MUZvckxlZ2VuZFRpbGUoZCkgKyB4T2Zmc2V0KVxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXG5cdFx0XHRcdFx0XHQuYXR0cihcInJcIiwgcmFkaXVzKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB0aWxlcyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xuXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIHgxRm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4MkZvckxlZ2VuZFRpbGUpXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgeUZvckxlZ2VuZFRpbGUpO1xuXHRcdH1cblxuXHRcdGlmIChiYWNrZ3JvdW5kKSB7XG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldExlZ2VuZEhlaWdodCgpIC0gMTIpXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4V2lkdGggKiAoc3RlcCArIDEpICsgMTApO1xuXHRcdH1cblxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcblx0XHQvLyAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0Ly8gXHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcblxuXHRcdC8vIFVwZGF0ZSBhbGwgdG8gcmVmbGVjdCBjaGFuZ2Ugb2YgbGVnZW5kXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcblx0XHQkJC51cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KG1heEhlaWdodCk7XG5cdFx0JCQudXBkYXRlTGVnZW5kU3RlcChzdGVwKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgaXNOdW1iZXIsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuXG4vKipcbiAqIEdldCB0aGUgdGV4dCBwb3NpdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHBvcyByaWdodCwgbGVmdCBvciBjZW50ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBjaGFydCB3aWR0aFxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn0gdGV4dC1hbmNob3IgdmFsdWUgb3IgcG9zaXRpb24gaW4gcGl4ZWxcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldFRleHRQb3MgPSAocG9zID0gXCJsZWZ0XCIsIHdpZHRoKSA9PiB7XG5cdGxldCBwb3NpdGlvbjtcblx0Y29uc3QgaXNOdW0gPSBpc051bWJlcih3aWR0aCk7XG5cblx0aWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpID4gLTEpIHtcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggLyAyIDogXCJtaWRkbGVcIjtcblx0fSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpID4gLTEpIHtcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggOiBcImVuZFwiO1xuXHR9IGVsc2Uge1xuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyAwIDogXCJzdGFydFwiO1xuXHR9XG5cblx0cmV0dXJuIHBvc2l0aW9uO1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuY29uZmlnLnRpdGxlX3RleHQpIHtcblx0XHRcdCQkLnRpdGxlID0gJCQuc3ZnLmFwcGVuZChcImdcIik7XG5cblx0XHRcdGNvbnN0IHRleHQgPSAkJC50aXRsZVxuXHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBnZXRUZXh0UG9zKCQkLmNvbmZpZy50aXRsZV9wb3NpdGlvbikpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudGl0bGUpO1xuXG5cdFx0XHRzZXRUZXh0VmFsdWUodGV4dCwgJCQuY29uZmlnLnRpdGxlX3RleHQsIFswLjMsIDEuNV0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRpdGxlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZWRyYXdUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQudGl0bGUpIHtcblx0XHRcdGNvbnN0IHkgPSAkJC55Rm9yVGl0bGUuY2FsbCgkJCk7XG5cblx0XHRcdGlmICgvZy9pLnRlc3QoJCQudGl0bGUubm9kZSgpLnRhZ05hbWUpKSB7XG5cdFx0XHRcdCQkLnRpdGxlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2dldFRleHRQb3MoJCQuY29uZmlnLnRpdGxlX3Bvc2l0aW9uLCAkJC5jdXJyZW50V2lkdGgpfSwgJHt5fSlgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnRpdGxlLmF0dHIoXCJ4XCIsICQkLnhGb3JUaXRsZS5jYWxsKCQkKSkuYXR0cihcInlcIiwgeSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0geCBhdHRyaWJ1dGUgdmFsdWVcblx0ICovXG5cdHhGb3JUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8IFwibGVmdFwiO1xuXHRcdGxldCB4O1xuXG5cdFx0aWYgKC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikpIHtcblx0XHRcdHggPSAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRUZXh0UmVjdCgkJC50aXRsZSwgQ0xBU1MudGl0bGUpLndpZHRoO1xuXG5cdFx0XHRpZiAocG9zaXRpb24uaW5kZXhPZihcInJpZ2h0XCIpID49IDApIHtcblx0XHRcdFx0eCAtPSAoY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmluZGV4T2YoXCJjZW50ZXJcIikgPj0gMCkge1xuXHRcdFx0XHR4IC89IDI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbGVmdFxuXHRcdFx0eCA9IChjb25maWcudGl0bGVfcGFkZGluZy5sZWZ0IHx8IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiB4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB5IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0geSBhdHRyaWJ1dGUgdmFsdWVcblx0ICovXG5cdHlGb3JUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCB8fCAwKSArXG5cdFx0XHQkJC5nZXRUZXh0UmVjdCgkJC50aXRsZSwgQ0xBU1MudGl0bGUpLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRpdGxlIHBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0gcGFkZGluZyB2YWx1ZVxuXHQgKi9cblx0Z2V0VGl0bGVQYWRkaW5nKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC55Rm9yVGl0bGUoKSArICgkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b20gfHwgMCk7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aW5pdENsaXAoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxuXHRcdCQkLmNsaXBJZCA9IGAkeyQkLmRhdGV0aW1lSWR9LWNsaXBgO1xuXG5cdFx0JCQuY2xpcElkRm9yWEF4aXMgPSBgJHskJC5jbGlwSWR9LXhheGlzYDtcblx0XHQkJC5jbGlwSWRGb3JZQXhpcyA9IGAkeyQkLmNsaXBJZH0teWF4aXNgO1xuXHRcdCQkLmNsaXBJZEZvckdyaWQgPSBgJHskJC5jbGlwSWR9LWdyaWRgO1xuXG5cdFx0Ly8gRGVmaW5lICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHQkJC5jbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZCk7XG5cdFx0JCQuY2xpcFBhdGhGb3JYQXhpcyA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvclhBeGlzKTtcblx0XHQkJC5jbGlwUGF0aEZvcllBeGlzID0gJCQuZ2V0Q2xpcFBhdGgoJCQuY2xpcElkRm9yWUF4aXMpO1xuXHRcdCQkLmNsaXBQYXRoRm9yR3JpZCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvckdyaWQpO1xuXHR9LFxuXG5cdGdldENsaXBQYXRoKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcblx0XHRcdCghY29uZmlnLmF4aXNfeF9jbGlwUGF0aCAmJiAvLWNsaXAteGF4aXMkLy50ZXN0KGlkKSkgfHxcblx0XHRcdCghY29uZmlnLmF4aXNfeV9jbGlwUGF0aCAmJiAvLWNsaXAteWF4aXMkLy50ZXN0KGlkKSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XG5cdFx0XHR3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb25cblx0XHRcdFx0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1zaWUgOS5cIikgPj0gMCA6IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGB1cmwoJHsoaXNJRTkgPyBcIlwiIDogZG9jdW1lbnQuVVJMLnNwbGl0KFwiI1wiKVswXSl9IyR7aWR9KWA7XG5cdH0sXG5cblx0YXBwZW5kQ2xpcChwYXJlbnQsIGlkKSB7XG5cdFx0cmV0dXJuIHBhcmVudC5hcHBlbmQoXCJjbGlwUGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xuXHR9LFxuXG5cdGdldEF4aXNDbGlwWChmb3JIb3Jpem9udGFsKSB7XG5cdFx0Ly8gYXhpcyBsaW5lIHdpZHRoICsgcGFkZGluZyBmb3IgbGVmdFxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgdGhpcy5tYXJnaW4ubGVmdCk7XG5cblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0oMSArIGxlZnQpIDogLShsZWZ0IC0gMSk7XG5cdH0sXG5cblx0Z2V0QXhpc0NsaXBZKGZvckhvcml6b250YWwpIHtcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0yMCA6IC10aGlzLm1hcmdpbi50b3A7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwWCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fSxcblxuXHRnZXRYQXhpc0NsaXBZKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldFlBeGlzQ2xpcFgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xuXHRcdFx0LTEgOiAkJC5nZXRBeGlzQ2xpcFgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwWSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBZKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldEF4aXNDbGlwV2lkdGgoZm9ySG9yaXpvbnRhbCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMzAsICQkLm1hcmdpbi5sZWZ0KTtcblx0XHRjb25zdCByaWdodCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ucmlnaHQpO1xuXG5cdFx0Ly8gd2lkdGggKyBheGlzIGxpbmUgd2lkdGggKyBwYWRkaW5nIGZvciBsZWZ0L3JpZ2h0XG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgP1xuXHRcdFx0JCQud2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogJCQubWFyZ2luLmxlZnQgKyAyMDtcblx0fSxcblxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsKSB7XG5cdFx0Ly8gbGVzcyB0aGFuIDIwIGlzIG5vdCBlbm91Z2ggdG8gc2hvdyB0aGUgYXhpcyBsYWJlbCAnb3V0ZXInIHdpdGhvdXQgbGVnZW5kXG5cdFx0cmV0dXJuIChmb3JIb3Jpem9udGFsID8gdGhpcy5tYXJnaW4uYm90dG9tIDogKHRoaXMubWFyZ2luLnRvcCArIHRoaXMuaGVpZ2h0KSkgKyAyMDtcblx0fSxcblxuXHRnZXRYQXhpc0NsaXBXaWR0aCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwV2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkgKyAoJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IDIwIDogMCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiOyAvLyBzZWxlY3Rpb25cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7aXNWYWx1ZSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UmVnaW9uKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnJlZ2lvbiA9ICQkLm1haW4uYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGgpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnJlZ2lvbnMpO1xuXHR9LFxuXG5cdHVwZGF0ZVJlZ2lvbihkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXG5cdFx0JCQucmVnaW9uLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xuXG5cdFx0Ly8gc2VsZWN0IDxnPiBlbGVtZW50XG5cdFx0JCQubWFpblJlZ2lvbiA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5yZWdpb259YClcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcblxuXHRcdCQkLm1haW5SZWdpb24uZXhpdCgpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpblJlZ2lvbiA9ICQkLm1haW5SZWdpb24uZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5tZXJnZSgkJC5tYWluUmVnaW9uKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc1JlZ2lvbi5iaW5kKCQkKSk7XG5cblx0XHQkJC5tYWluUmVnaW9uXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcblx0fSxcblxuXHRyZWRyYXdSZWdpb24od2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC5tYWluUmVnaW9uLnNlbGVjdChcInJlY3RcIik7XG5cblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInlcIiwgJCQucmVnaW9uWS5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5yZWdpb25IZWlnaHQuYmluZCgkJCkpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucylcblx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIGQgPT4gKGlzVmFsdWUoZC5vcGFjaXR5KSA/IGQub3BhY2l0eSA6IFwiMC4xXCIpKVxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IHJlY3QgYWZ0ZXIgdHJhbnNpdGlvblxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMucGFyZW50Tm9kZSlcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cdFx0XHRcdH0pXG5cdFx0XTtcblx0fSxcblxuXHRnZXRSZWdpb25YWSh0eXBlLCBkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGlzWCA9IHR5cGUgPT09IFwieFwiO1xuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XG5cdFx0bGV0IHNjYWxlO1xuXHRcdGxldCBwb3MgPSAwO1xuXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcblx0XHRcdGlmICghaXNYKSB7XG5cdFx0XHRcdGtleSA9IFwiZW5kXCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoaXNYID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcblx0XHRcdFx0c2NhbGUgPSAkJFtkLmF4aXNdO1xuXHRcdFx0XHRwb3MgPSBzY2FsZShkW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoKGlzWCA/ICFpc1JvdGF0ZWQgOiBpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XG5cdFx0XHRzY2FsZSA9ICQkLnpvb21TY2FsZSB8fCAkJC54O1xuXHRcdFx0cG9zID0gc2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvcztcblx0fSxcblxuXHRyZWdpb25YKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25YWShcInhcIiwgZCk7XG5cdH0sXG5cblx0cmVnaW9uWShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ5XCIsIGQpO1xuXHR9LFxuXG5cdGdldFJlZ2lvblNpemUodHlwZSwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xuXHRcdGNvbnN0IHN0YXJ0ID0gJCRbaXNXaWR0aCA/IFwicmVnaW9uWFwiIDogXCJyZWdpb25ZXCJdKGQpO1xuXHRcdGxldCBzY2FsZTtcblx0XHRsZXQga2V5ID0gXCJlbmRcIjtcblx0XHRsZXQgZW5kID0gJCRbdHlwZV07XG5cblx0XHRpZiAoZC5heGlzID09PSBcInlcIiB8fCBkLmF4aXMgPT09IFwieTJcIikge1xuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XG5cdFx0XHRcdGtleSA9IFwic3RhcnRcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKChpc1dpZHRoID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcblx0XHRcdFx0c2NhbGUgPSAkJFtkLmF4aXNdO1xuXHRcdFx0XHRlbmQgPSBzY2FsZShkW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xuXHRcdFx0c2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblx0XHRcdGVuZCA9IHNjYWxlKCQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGRba2V5XSkgOiBkW2tleV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmQgPCBzdGFydCA/IDAgOiBlbmQgLSBzdGFydDtcblx0fSxcblxuXHRyZWdpb25XaWR0aChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xuXHR9LFxuXG5cdHJlZ2lvbkhlaWdodChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcImhlaWdodFwiLCBkKTtcblx0fSxcblxuXHRpc1JlZ2lvbk9uWChkKSB7XG5cdFx0cmV0dXJuICFkLmF4aXMgfHwgZC5heGlzID09PSBcInhcIjtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmQsIGdldFBhdGhCb3h9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGRyYWdnaW5nLlxuXHQgKiBEYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSBPYmplY3Rcblx0ICovXG5cdGRyYWcobW91c2UpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fFxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkIHx8IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcblx0XHRcdChjb25maWcuem9vbV9lbmFibGVkICYmICEkJC56b29tLmFsdERvbWFpbikgfHwgLy8gc2tpcCBpZiB6b29tYWJsZSBiZWNhdXNlIG9mIGNvbmZsaWN0IGRyYWcgYmVoYXZpb3Jcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUgLy8gc2tpcCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gYmVjYXVzZSBkcmFnIGlzIHVzZWQgZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IFtzeCwgc3ldID0gJCQuZHJhZ1N0YXJ0O1xuXHRcdGNvbnN0IFtteCwgbXldID0gbW91c2U7XG5cblx0XHRjb25zdCBtaW5YID0gTWF0aC5taW4oc3gsIG14KTtcblx0XHRjb25zdCBtYXhYID0gTWF0aC5tYXgoc3gsIG14KTtcblx0XHRjb25zdCBtaW5ZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyAkJC5tYXJnaW4udG9wIDogTWF0aC5taW4oc3ksIG15KTtcblx0XHRjb25zdCBtYXhZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyAkJC5oZWlnaHQgOiBNYXRoLm1heChzeSwgbXkpO1xuXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXG5cdFx0XHQuYXR0cihcInhcIiwgbWluWClcblx0XHRcdC5hdHRyKFwieVwiLCBtaW5ZKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBtYXhYIC0gbWluWClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG1heFkgLSBtaW5ZKTtcblxuXHRcdC8vIFRPRE86IGJpbmFyeSBzZWFyY2ggd2hlbiBtdWx0aXBsZSB4c1xuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZmlsdGVyKGQgPT4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXHRcdFx0XHRjb25zdCBpc0luY2x1ZGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCk7XG5cdFx0XHRcdGxldCB0b2dnbGU7XG5cdFx0XHRcdGxldCBpc1dpdGhpbiA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcblx0XHRcdFx0XHRjb25zdCB4ID0gc2hhcGUuYXR0cihcImN4XCIpICogMTtcblx0XHRcdFx0XHRjb25zdCB5ID0gc2hhcGUuYXR0cihcImN5XCIpICogMTtcblxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBvaW50O1xuXHRcdFx0XHRcdGlzV2l0aGluID0gbWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpKSB7XG5cdFx0XHRcdFx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gZ2V0UGF0aEJveCh0aGlzKTtcblxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBhdGg7XG5cdFx0XHRcdFx0aXNXaXRoaW4gPSAhKG1heFggPCB4IHx8IHggKyB3aWR0aCA8IG1pblgpICYmICEobWF4WSA8IHkgfHwgeSArIGhlaWdodCA8IG1pblkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XG5cdFx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgIWlzSW5jbHVkZWQpO1xuXHRcdFx0XHRcdC8vIFRPRE86IGluY2x1ZGVkL3VuaW5jbHVkZWQgY2FsbGJhY2sgaGVyZVxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcblx0XHRcdFx0XHR0b2dnbGUuY2FsbCgkJCwgIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIHN0YXJ0cy5cblx0ICogQWRkcyBhbmQgU2hvd3MgdGhlIGRyYWcgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIE9iamVjdFxuXHQgKi9cblx0ZHJhZ3N0YXJ0KG1vdXNlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQuZHJhZ1N0YXJ0ID0gbW91c2U7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmRyYWdhcmVhKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjAuMVwiKTtcblxuXHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIGZpbmlzaGVzLlxuXHQgKiBSZW1vdmVzIHRoZSBkcmFnIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmFnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkgeyAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsIGZhbHNlKTtcblxuXHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xuXHR9LFxuXG5cdHNldERyYWdTdGF0dXMoaXNEcmFnZ2luZykge1xuXHRcdHRoaXMuZHJhZ2dpbmcgPSBpc0RyYWdnaW5nO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3JnYiBhcyBkM1JnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZufSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogU2VsZWN0IGEgcG9pbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICovXG5cdHNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBjeCA9IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkuYmluZCgkJCk7XG5cdFx0Y29uc3QgY3kgPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpO1xuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcblxuXHRcdC8vIGFkZCBzZWxlY3RlZC1jaXJjbGUgb24gbG93IGxheWVyIGdcblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcblx0XHRcdC5kYXRhKFtkXSlcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwiY2lyY2xlXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICgpID0+ICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2VsZWN0ZWRDaXJjbGUsIGkpKVxuXHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcblx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpXG5cdFx0XHQuYXR0cihcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5hdHRyKFwiclwiLCBkMiA9PiAkJC5wb2ludFNlbGVjdFIoZDIpICogMS40KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKDEwMClcblx0XHRcdC5hdHRyKFwiclwiLCByKTtcblx0fSxcblxuXHQvKipcblx0ICogVW5lbGVjdCBhIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHR1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGNhbGxGbigkJC5jb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG5cblx0XHQvLyByZW1vdmUgc2VsZWN0ZWQtY2lyY2xlIGZyb20gbG93IGxheWVyIGdcblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuYXR0cihcInJcIiwgMClcblx0XHRcdC5yZW1vdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHBvaW50c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHNlbGVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICovXG5cdHRvZ2dsZVBvaW50KHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcblx0XHRjb25zdCBtZXRob2QgPSBgJHtzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCJ9c2VsZWN0UG9pbnRgO1xuXG5cdFx0dGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNlbGVjdCBhIHBhdGhcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqL1xuXHRzZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gZDNSZ2IoJCQuY29sb3IoZCkpLmJyaWdodGVyKDAuNzUpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVuZWxlY3QgYSBwYXRoXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcGF0aFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cblx0dW5zZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJCwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG5cblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiAkJC5jb2xvcihkKSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgbGluZXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHR0b2dnbGVQYXRoKHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcblx0XHR0aGlzW1xuXHRcdFx0YCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBhdGhgXG5cdFx0XSh0YXJnZXQsIGQsIGkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b2dnbGUgbWV0aG9kIG9mIHRoZSB0YXJnZXRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBzaGFwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRvZ2dsZSBtZXRob2Rcblx0ICovXG5cdGdldFRvZ2dsZSh0aGF0LCBkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiID9cblx0XHRcdCQkLnRvZ2dsZVBhdGggOiAoXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xuXHRcdFx0XHRcdCgpID0+IHt9IDogLy8gY2lyY2xlIGlzIGhpZGRlbiBpbiBzdGVwIGNoYXJ0LCBzbyB0cmVhdCBhcyB3aXRoaW4gdGhlIGNsaWNrIGFyZWFcblx0XHRcdFx0XHQkJC50b2dnbGVQb2ludFxuXHRcdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHNoYXBlc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKi9cblx0dG9nZ2xlU2hhcGUodGhhdCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcblx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoYXQsIGQpLmJpbmQoJCQpO1xuXHRcdGxldCB0b2dnbGVkU2hhcGU7XG5cblx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSkge1xuXHRcdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUpIHtcblx0XHRcdFx0bGV0IHNlbGVjdG9yID0gYC4ke0NMQVNTLnNoYXBlc31gO1xuXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkge1xuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JCQubWFpbi5zZWxlY3RBbGwoc2VsZWN0b3IpXG5cdFx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCkpIHtcblx0XHRcdFx0XHRcdFx0dG9nZ2xlZFNoYXBlID0gc2hhcGU7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0b2dnbGVkU2hhcGUgfHwgdG9nZ2xlZFNoYXBlLm5vZGUoKSAhPT0gc2hhcGUubm9kZSgpKSB7XG5cdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcblx0XHRcdFx0dG9nZ2xlKCFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdGV2ZW50IGFzIGQzRXZlbnRcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtcblx0YnJ1c2hYIGFzIGQzQnJ1c2hYLFxuXHRicnVzaFkgYXMgZDNCcnVzaFksXG5cdGJydXNoU2VsZWN0aW9uIGFzIGQzQnJ1c2hTZWxlY3Rpb25cbn0gZnJvbSBcImQzLWJydXNoXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBicnVzaEVtcHR5LCBjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBnZXRSYW5kb219IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGJydXNoLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdEJydXNoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIHNldCB0aGUgYnJ1c2hcblx0XHQkJC5icnVzaCA9IGlzUm90YXRlZCA/IGQzQnJ1c2hZKCkgOiBkM0JydXNoWCgpO1xuXG5cdFx0Ly8gc2V0IFwiYnJ1c2hcIiBldmVudFxuXHRcdGNvbnN0IGJydXNoSGFuZGxlciA9ICgpID0+IHtcblx0XHRcdCQkLnJlZHJhd0ZvckJydXNoKCk7XG5cdFx0fTtcblx0XHRjb25zdCBnZXRCcnVzaFNpemUgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBicnVzaCA9ICQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xuXHRcdFx0Y29uc3QgYnJ1c2hTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XG5cdFx0XHRcdGJydXNoU2l6ZS53aWR0aCA9ICticnVzaC5hdHRyKFwid2lkdGhcIik7XG5cdFx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJydXNoU2l6ZVtpc1JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcblx0XHR9O1xuXG5cdFx0bGV0IGxhc3REb21haW47XG5cdFx0bGV0IHRpbWVvdXQ7XG5cblx0XHQkJC5icnVzaFxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgKCkgPT4ge1xuXHRcdFx0XHQkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5oaWRlVG9vbHRpcCgpO1xuXHRcdFx0XHRicnVzaEhhbmRsZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJicnVzaFwiLCBicnVzaEhhbmRsZXIpXG5cdFx0XHQub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRsYXN0RG9tYWluID0gJCQueC5vcmdEb21haW4oKTtcblx0XHRcdH0pO1xuXG5cdFx0JCQuYnJ1c2gudXBkYXRlUmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRsYXN0RG9tYWluICYmIGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uLm5vZGUoKSkgJiZcblx0XHRcdFx0XHR0aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcCgkJC5zdWJYLm9yZ1NjYWxlKCkpKTtcblx0XHRcdH0sIDApO1xuXHRcdH07XG5cblx0XHQkJC5icnVzaC51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMuZXh0ZW50KCkoKTtcblxuXHRcdFx0aWYgKGV4dGVudFsxXS5maWx0ZXIodiA9PiBpc05hTih2KSkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdCQkLmNvbnRleHQgJiYgJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvLyBzZXQgdGhlIGJydXNoIGV4dGVudFxuXHRcdCQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRcdGNvbnN0IGggPSBjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgfHwgZ2V0QnJ1c2hTaXplKCk7XG5cdFx0XHRsZXQgZXh0ZW50ID0gJCQuZ2V0RXh0ZW50KCk7XG5cblx0XHRcdGlmICghZXh0ZW50ICYmIHNjYWxlLnJhbmdlKSB7XG5cdFx0XHRcdGV4dGVudCA9IFtbMCwgMF0sIFtzY2FsZS5yYW5nZSgpWzFdLCBoXV07XG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZXh0ZW50KSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKCh2LCBpKSA9PiBbdiwgaSA+IDAgPyBoIDogaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBbW3gwLCB5MF0sIFt4MSwgeTFdXSwgd2hlcmUgW3gwLCB5MF0gaXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBhbmQgW3gxLCB5MV0gaXMgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXJcblx0XHRcdGlzUm90YXRlZCAmJiBleHRlbnRbMV0ucmV2ZXJzZSgpO1xuXHRcdFx0dGhpcy5leHRlbnQoZXh0ZW50KTtcblxuXHRcdFx0Ly8gd2hlbiBleHRlbnQgdXBkYXRlcywgYnJ1c2ggc2VsZWN0aW9uIGFsc28gYmUgcmUtYXBwbGllZFxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cblx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24gPSAoKSA9PiAoXG5cdFx0XHQkJC5jb250ZXh0ID8gJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApIDogZDNTZWxlY3QoW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgc3ViY2hhcnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0U3ViY2hhcnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG5cdFx0Y29uc3QgY2xpcElkID0gYCR7JCQuY2xpcElkfS1zdWJjaGFydGA7XG5cdFx0Y29uc3QgY2xpcFBhdGggPSAkJC5nZXRDbGlwUGF0aChjbGlwSWQpO1xuXG5cdFx0JCQuY2xpcElkRm9yU3ViY2hhcnQgPSBjbGlwSWQ7XG5cdFx0JCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCBjbGlwSWQpO1xuXHRcdCQkLmluaXRCcnVzaCgpO1xuXG5cdFx0JCQuY29udGV4dCA9ICQkLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XG5cblx0XHRjb25zdCBjb250ZXh0ID0gJCQuY29udGV4dDtcblxuXHRcdGNvbnRleHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIHZpc2liaWxpdHkpO1xuXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcblx0XHRjb250ZXh0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydCk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgYmFyIGNoYXJ0IGFyZWFcblx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcblxuXHRcdC8vIERlZmluZSBnIGZvciBsaW5lIGNoYXJ0IGFyZWFcblx0XHRjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xuXG5cdFx0Ly8gQWRkIGV4dGVudCByZWN0IGZvciBCcnVzaFxuXHRcdGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmJydXNoKVxuXHRcdFx0LmNhbGwoJCQuYnJ1c2gpO1xuXG5cdFx0Ly8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXG5cdFx0Ly8gQWRkIEF4aXNcblx0XHQkJC5heGVzLnN1YnggPSBjb250ZXh0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpc1gpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJzdWJ4XCIpKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiAkJC5jbGlwUGF0aEZvclhBeGlzKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgPyB2aXNpYmlsaXR5IDogXCJoaWRkZW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9ICQkLmRhdGEudGFyZ2V0c1xuXHQgKi9cblx0dXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29udGV4dCA9ICQkLmNvbnRleHQ7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xuXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XG5cdFx0XHQvLyAtLSBCYXIgLS0vL1xuXHRcdFx0Y29uc3QgY29udGV4dEJhclVwZGF0ZSA9IGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKTtcblx0XHRcdGNvbnN0IGNvbnRleHRCYXJFbnRlciA9IGNvbnRleHRCYXJVcGRhdGUuZW50ZXIoKVxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXG5cdFx0XHRcdC5tZXJnZShjb250ZXh0QmFyVXBkYXRlKTtcblxuXHRcdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXG5cdFx0XHRjb250ZXh0QmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XG5cblx0XHRcdC8vIC0tIExpbmUgLS0vL1xuXHRcdFx0Y29uc3QgY29udGV4dExpbmVVcGRhdGUgPSBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSk7XG5cdFx0XHRjb25zdCBjb250ZXh0TGluZUVudGVyID0gY29udGV4dExpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXG5cdFx0XHRcdC5tZXJnZShjb250ZXh0TGluZVVwZGF0ZSk7XG5cblx0XHRcdC8vIExpbmVzIGZvciBlYWNoIGRhdGFcblx0XHRcdGNvbnRleHRMaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGluZXMpO1xuXG5cdFx0XHQvLyBBcmVhXG5cdFx0XHQkJC5oYXNUeXBlKFwiYXJlYVwiKSAmJiBjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcblxuXHRcdFx0Ly8gLS0gQnJ1c2ggLS0vL1xuXHRcdFx0Y29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcblx0XHRcdFx0LmF0dHIoY29uZmlnLmF4aXNfcm90YXRlZCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aDIgOiAkJC5oZWlnaHQyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uRm9yRXhpdFxuXHQgKi9cblx0dXBkYXRlQmFyRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY29udGV4dEJhciA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXG5cdFx0XHQuZGF0YSgkJC5iYXJEYXRhLmJpbmQoJCQpKTtcblxuXHRcdCQkLmNvbnRleHRCYXJcblx0XHRcdC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQuY29udGV4dEJhciA9ICQkLmNvbnRleHRCYXJcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0Jhci5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBcIm5vbmVcIilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXG5cdFx0XHQubWVyZ2UoJCQuY29udGV4dEJhcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgYmFyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHJlZHJhd0JhckZvclN1YmNoYXJ0KGRyYXdCYXJPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dEJhciA9IHdpdGhUcmFuc2l0aW9uID9cblx0XHRcdHRoaXMuY29udGV4dEJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxuXHRcdFx0dGhpcy5jb250ZXh0QmFyO1xuXG5cdFx0Y29udGV4dEJhci5hdHRyKFwiZFwiLCBkcmF3QmFyT25TdWIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsaW5lIG9mIHRoZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jb250ZXh0TGluZSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZX1gKVxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuXG5cdFx0JCQuY29udGV4dExpbmVcblx0XHRcdC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQuY29udGV4dExpbmUgPSAkJC5jb250ZXh0TGluZVxuXHRcdFx0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzTGluZS5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5tZXJnZSgkJC5jb250ZXh0TGluZSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGxpbmUgb2YgdGhlIHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXdMaW5lRm9yU3ViY2hhcnQoZHJhd0xpbmVPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dExpbmUgPSB3aXRoVHJhbnNpdGlvbiA/XG5cdFx0XHR0aGlzLmNvbnRleHRMaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6XG5cdFx0XHR0aGlzLmNvbnRleHRMaW5lO1xuXG5cdFx0Y29udGV4dExpbmUuYXR0cihcImRcIiwgZHJhd0xpbmVPblN1Yilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGFyZWEgb2YgdGhlIHN1YiBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxuXHQgKi9cblx0dXBkYXRlQXJlYUZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNvbnRleHRBcmVhID0gJCQuY29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWFzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG5cblx0XHQkJC5jb250ZXh0QXJlYVxuXHRcdFx0LmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHRBcmVhXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQkLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xuXHRcdFx0XHRyZXR1cm4gXCIwXCI7XG5cdFx0XHR9KVxuXHRcdFx0Lm1lcmdlKCQkLmNvbnRleHRBcmVhKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cdH0sXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGFyZWEgb2YgdGhlIHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXdBcmVhRm9yU3ViY2hhcnQoZHJhd0FyZWFPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dEFyZWEgPSB3aXRoVHJhbnNpdGlvbiA/XG5cdFx0XHR0aGlzLmNvbnRleHRBcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6XG5cdFx0XHR0aGlzLmNvbnRleHRBcmVhO1xuXG5cdFx0Y29udGV4dEFyZWEuYXR0cihcImRcIiwgZHJhd0FyZWFPblN1Yilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5vcmdBcmVhT3BhY2l0eSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyBzdWJjaGFydC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gZHVyYXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IHNoYXBlIFNoYXBlJ3MgaW5mb1xuXHQgKi9cblx0cmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0JCQuY29udGV4dC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xuXG5cdFx0Ly8gc3ViY2hhcnRcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcblx0XHRcdC8vIHJlZmxlY3QgbWFpbiBjaGFydCB0byBleHRlbnQgb24gc3ViY2hhcnQgaWYgem9vbWVkXG5cdFx0XHRpZiAoZDNFdmVudCAmJiBkM0V2ZW50LnR5cGUgPT09IFwiem9vbVwiKSB7XG5cdFx0XHRcdCQkLmJydXNoLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgc3ViY2hhcnQgZWxlbWVudHMgaWYgbmVlZGVkXG5cdFx0XHRpZiAod2l0aFN1YmNoYXJ0KSB7XG5cdFx0XHRcdC8vIGV4dGVudCByZWN0XG5cdFx0XHRcdCFicnVzaEVtcHR5KCQkKSAmJiAkJC5icnVzaC51cGRhdGUoKTtcblxuXHRcdFx0XHRPYmplY3Qua2V5cyhzaGFwZS50eXBlKS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjYXBpdGFsaXplKHYpO1xuXHRcdFx0XHRcdGNvbnN0IGRyYXcgPSAkJFtgZ2VuZXJhdGVEcmF3JHtuYW1lfWBdKHNoYXBlLmluZGljZXNbdl0sIHRydWUpO1xuXG5cdFx0XHRcdFx0JCRbYHVwZGF0ZSR7bmFtZX1Gb3JTdWJjaGFydGBdKGR1cmF0aW9uKTtcblx0XHRcdFx0XHQkJFtgcmVkcmF3JHtuYW1lfUZvclN1YmNoYXJ0YF0oZHJhdywgZHVyYXRpb24sIGR1cmF0aW9uKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGJydXNoLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVkcmF3Rm9yQnJ1c2goKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcdHdpdGhZOiAkJC5jb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLmNvbmZpZy5zdWJjaGFydF9vbmJydXNoLmNhbGwoJCQuYXBpLCAkJC54Lm9yZ0RvbWFpbigpKTtcblx0fSxcblxuXHQvKipcblx0ICogVHJhbnNmb3JtIGNvbnRleHRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmRpY2F0ZXMgdHJhbnNpdGlvbiBpcyBlbmFibGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zIG1ldGhvZCBvZiBBeGlzLlxuXHQgKi9cblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHN1YlhBeGlzO1xuXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNTdWJYKSB7XG5cdFx0XHRzdWJYQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNTdWJYO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdWJYQXhpcyA9ICQkLmNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKTtcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikgeyBzdWJYQXhpcyA9IHN1YlhBeGlzLnRyYW5zaXRpb24oKTsgfVxuXHRcdH1cblxuXHRcdCQkLmNvbnRleHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YnhcIikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgZXh0ZW50IHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZGVmYXVsdCBleHRlbnRcblx0ICovXG5cdGdldEV4dGVudCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGV4dGVudCA9ICQkLmNvbmZpZy5heGlzX3hfZXh0ZW50O1xuXG5cdFx0aWYgKGV4dGVudCkge1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oZXh0ZW50KSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpLCAkJC5zdWJYKTtcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gJCQuc3ViWCgkJC5wYXJzZURhdGUodikpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW50O1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdG1vdXNlIGFzIGQzTW91c2UsXG5cdGV2ZW50IGFzIGQzRXZlbnQsXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IHt6b29tIGFzIGQzWm9vbX0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZuLCBkaWZmRG9tYWluLCBnZXRNaW5NYXgsIGlzRGVmaW5lZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB6b29tLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFpvb20oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuem9vbVNjYWxlID0gbnVsbDtcblxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xuXHRcdCQkLmluaXRab29tQmVoYXZpb3VyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJpbmQgem9vbSBldmVudFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSAkJC5jb25maWcuem9vbV9lbmFibGVkO1xuXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XG5cblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XG5cblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xuXHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcblx0XHR9IGVsc2UgaWYgKGJpbmQgPT09IGZhbHNlKSB7XG5cdFx0XHQkJC5hcGkudW56b29tKCk7XG5cblx0XHRcdGV2ZW50UmVjdHNcblx0XHRcdFx0Lm9uKFwiLnpvb21cIiwgbnVsbClcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB6b29tXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVpvb20oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IHpvb20gPSBkM1pvb20oKS5kdXJhdGlvbigwKVxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXG5cdFx0XHQub24oXCJ6b29tXCIsICQkLm9uWm9vbS5iaW5kKCQkKSlcblx0XHRcdC5vbihcImVuZFwiLCAkJC5vblpvb21FbmQuYmluZCgkJCkpO1xuXG5cdFx0Ly8gZ2V0IHpvb20gZXh0ZW50XG5cdFx0em9vbS5vcmdTY2FsZUV4dGVudCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xuXG5cdFx0XHRyZXR1cm4gW2V4dGVudFswXSwgTWF0aC5tYXgoJCQuZ2V0TWF4RGF0YUNvdW50KCkgLyBleHRlbnRbMV0sIGV4dGVudFsxXSldO1xuXHRcdH07XG5cblx0XHR6b29tLnVwZGF0ZVNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLm9yZ1NjYWxlRXh0ZW50KCk7XG5cblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUgPSB0cmFuc2Zvcm0gPT4ge1xuXHRcdFx0Ly8gaW4gY2FzZSBvZiByZXNpemUsIHVwZGF0ZSByYW5nZSBvZiBvcmdYU2NhbGVcblx0XHRcdCQkLm9yZ1hTY2FsZSAmJiAkJC5vcmdYU2NhbGUucmFuZ2UoJCQueC5yYW5nZSgpKTtcblxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxuXHRcdFx0Y29uc3QgbmV3U2NhbGUgPSB0cmFuc2Zvcm1bXG5cdFx0XHRcdGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJlc2NhbGVZXCIgOiBcInJlc2NhbGVYXCJcblx0XHRcdF0oJCQub3JnWFNjYWxlIHx8ICQkLngpO1xuXG5cdFx0XHRjb25zdCBkb21haW4gPSAkJC50cmltWERvbWFpbihuZXdTY2FsZS5kb21haW4oKSk7XG5cdFx0XHRjb25zdCByZXNjYWxlID0gY29uZmlnLnpvb21fcmVzY2FsZTtcblxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKGRvbWFpbiwgJCQub3JnWERvbWFpbik7XG5cblx0XHRcdCQkLnpvb21TY2FsZSA9ICQkLmdldEN1c3RvbWl6ZWRTY2FsZShuZXdTY2FsZSk7XG5cdFx0XHQkJC54QXhpcy5zY2FsZSgkJC56b29tU2NhbGUpO1xuXG5cdFx0XHRpZiAocmVzY2FsZSkge1xuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxuXHRcdFx0XHQhJCQub3JnWFNjYWxlICYmICgkJC5vcmdYU2NhbGUgPSAkJC54LmNvcHkoKSk7XG5cdFx0XHRcdCQkLnguZG9tYWluKGRvbWFpbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdCQkLnpvb20gPSB6b29tO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiAnc3RhcnQnIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvblpvb21TdGFydCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50O1xuXG5cdFx0aWYgKCFldmVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLnpvb20uc3RhcnRFdmVudCA9IGV2ZW50O1xuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb21zdGFydCwgJCQuYXBpLCBldmVudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25ab29tKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xuXHRcdGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XG5cblx0XHRpZiAoXG5cdFx0XHQhY29uZmlnLnpvb21fZW5hYmxlZCB8fFxuXHRcdFx0IWV2ZW50LnNvdXJjZUV2ZW50IHx8XG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID09PSAwIHx8XG5cdFx0XHQoISQkLnpvb21TY2FsZSAmJiBzb3VyY2VFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xICYmIHNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzTW91c2Vtb3ZlID0gc291cmNlRXZlbnQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIjtcblx0XHRjb25zdCBpc1pvb21PdXQgPSBzb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMDtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XG5cblx0XHRpZiAoIWlzTW91c2Vtb3ZlICYmIGlzWm9vbU91dCAmJiAkJC54LmRvbWFpbigpLmV2ZXJ5KCh2LCBpKSA9PiB2ICE9PSAkJC5vcmdYRG9tYWluW2ldKSkge1xuXHRcdFx0JCQueC5kb21haW4oJCQub3JnWERvbWFpbik7XG5cdFx0fVxuXG5cdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSh0cmFuc2Zvcm0pO1xuXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiAkJC54Lm9yZ0RvbWFpbigpWzBdID09PSAkJC5vcmdYRG9tYWluWzBdKSB7XG5cdFx0XHQkJC54LmRvbWFpbihbJCQub3JnWERvbWFpblswXSAtIDFlLTEwLCAkJC54Lm9yZ0RvbWFpbigpWzFdXSk7XG5cdFx0fVxuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLmNhbmNlbENsaWNrID0gaXNNb3VzZW1vdmU7XG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgJCQuYXBpLCAkJC56b29tU2NhbGUuZG9tYWluKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiAnZW5kJyBldmVudCBsaXN0ZW5lclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25ab29tRW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgc3RhcnRFdmVudCA9ICQkLnpvb20uc3RhcnRFdmVudDtcblx0XHRsZXQgZXZlbnQgPSBkM0V2ZW50ICYmIGQzRXZlbnQuc291cmNlRXZlbnQ7XG5cblx0XHRpZiAoKHN0YXJ0RXZlbnQgJiYgc3RhcnRFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xKSkge1xuXHRcdFx0c3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0XHRldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdH1cblxuXHRcdC8vIGlmIGNsaWNrLCBkbyBub3RoaW5nLiBvdGhlcndpc2UsIGNsaWNrIGludGVyYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG5cdFx0aWYgKCFzdGFydEV2ZW50IHx8XG5cdFx0XHQoZXZlbnQgJiYgc3RhcnRFdmVudC5jbGllbnRYID09PSBldmVudC5jbGllbnRYICYmIHN0YXJ0RXZlbnQuY2xpZW50WSA9PT0gZXZlbnQuY2xpZW50WSlcblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5yZWRyYXdFdmVudFJlY3QoKTtcblx0XHQkJC51cGRhdGVab29tKCk7XG5cblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tZW5kLCAkJC5hcGksICQkWyQkLnpvb21TY2FsZSA/IFwiem9vbVNjYWxlXCIgOiBcInN1YlhcIl0uZG9tYWluKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgem9vbSBkb21haW5cblx0ICogQHJldHVybnMge0FycmF5fSB6b29tIGRvbWFpblxuIFx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFpvb21Eb21haW4oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRsZXQgW21pbiwgbWF4XSA9ICQkLm9yZ1hEb21haW47XG5cblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWluKSkge1xuXHRcdFx0bWluID0gZ2V0TWluTWF4KFwibWluXCIsIFttaW4sIGNvbmZpZy56b29tX3hfbWluXSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21heCkpIHtcblx0XHRcdG1heCA9IGdldE1pbk1heChcIm1heFwiLCBbbWF4LCBjb25maWcuem9vbV94X21heF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBbbWluLCBtYXhdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgem9vbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHVuem9vbVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlWm9vbShmb3JjZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICgkJC56b29tU2NhbGUpIHtcblx0XHRcdGNvbnN0IHpvb21Eb21haW4gPSAkJC56b29tU2NhbGUuZG9tYWluKCk7XG5cdFx0XHRjb25zdCB4RG9tYWluID0gJCQuc3ViWC5kb21haW4oKTtcblx0XHRcdGNvbnN0IGRlbHRhID0gMC4wMTU7IC8vIGFyYml0cmFyeSB2YWx1ZVxuXG5cdFx0XHRjb25zdCBpc2Z1bGx5U2hvd24gPSAoem9vbURvbWFpblswXSA8PSB4RG9tYWluWzBdIHx8ICh6b29tRG9tYWluWzBdIC0gZGVsdGEpIDw9IHhEb21haW5bMF0pICYmXG5cdFx0XHRcdCh4RG9tYWluWzFdIDw9IHpvb21Eb21haW5bMV0gfHwgeERvbWFpblsxXSA8PSAoem9vbURvbWFpblsxXSAtIGRlbHRhKSk7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSB6b29tZWQgY2hhcnQgaXMgZnVsbHkgc2hvd24sIHRoZW4gcmVzZXQgc2NhbGUgd2hlbiB6b29tIGlzIG91dCBhcyBpbml0aWFsXG5cdFx0XHRpZiAoZm9yY2UgfHwgaXNmdWxseVNob3duKSB7XG5cdFx0XHRcdCQkLnhBeGlzLnNjYWxlKCQkLnN1YlgpO1xuXHRcdFx0XHQkJC54LmRvbWFpbigkJC5zdWJYLm9yZ0RvbWFpbigpKTtcblx0XHRcdFx0JCQuem9vbVNjYWxlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB0eXBlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGJlaGF2aW91ciA9IHR5cGUgPT09IFwiZHJhZ1wiID8gJCQuem9vbUJlaGF2aW91ciA6ICQkLnpvb207XG5cblx0XHRldmVudFJlY3RzXG5cdFx0XHQuY2FsbChiZWhhdmlvdXIpXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBkcmFnIGJlaGF2aW91ciB1c2VkIGZvciB6b29taW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFpvb21CZWhhdmlvdXIoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCBzdGFydCA9IDA7XG5cdFx0bGV0IGVuZCA9IDA7XG5cdFx0bGV0IHpvb21SZWN0ID0gbnVsbDtcblxuXHRcdGNvbnN0IHByb3AgPSB7XG5cdFx0XHRheGlzOiBpc1JvdGF0ZWQgPyBcInlcIiA6IFwieFwiLFxuXHRcdFx0YXR0cjogaXNSb3RhdGVkID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIixcblx0XHRcdGluZGV4OiBpc1JvdGF0ZWQgPyAxIDogMFxuXHRcdH07XG5cblx0XHQkJC56b29tQmVoYXZpb3VyID0gZDNEcmFnKClcblx0XHRcdC5jbGlja0Rpc3RhbmNlKDQpXG5cdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCQuc2V0RHJhZ1N0YXR1cyh0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXpvb21SZWN0KSB7XG5cdFx0XHRcdFx0em9vbVJlY3QgPSAkJC5tYWluLmFwcGVuZChcInJlY3RcIilcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy56b29tQnJ1c2gpXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGlzUm90YXRlZCA/ICQkLndpZHRoIDogMClcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhcnQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xuXHRcdFx0XHRlbmQgPSBzdGFydDtcblxuXHRcdFx0XHR6b29tUmVjdFxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgc3RhcnQpXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCAwKTtcblxuXHRcdFx0XHQkJC5vblpvb21TdGFydCgpO1xuXHRcdFx0fSlcblx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGVuZCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XG5cblx0XHRcdFx0em9vbVJlY3Rcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIE1hdGgubWluKHN0YXJ0LCBlbmQpKVxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgTWF0aC5hYnMoZW5kIC0gc3RhcnQpKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnpvb21TY2FsZSB8fCAkJC54O1xuXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xuXG5cdFx0XHRcdHpvb21SZWN0XG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCAwKVxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XG5cblx0XHRcdFx0aWYgKHN0YXJ0ID4gZW5kKSB7XG5cdFx0XHRcdFx0W3N0YXJ0LCBlbmRdID0gW2VuZCwgc3RhcnRdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkge1xuXHRcdFx0XHRcdGVuZCArPSBNYXRoLmFicyhzdGFydCk7XG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdFx0XHQkJC5hcGkuem9vbShbc3RhcnQsIGVuZF0ubWFwKHYgPT4gc2NhbGUuaW52ZXJ0KHYpKSk7XG5cdFx0XHRcdFx0JCQub25ab29tRW5kKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudC5zb3VyY2VFdmVudCB8fCBkM0V2ZW50O1xuXHRcdFx0XHRcdFx0Y29uc3QgW3gsIHldID0gXCJjbGllbnRYXCIgaW4gZXZlbnQgPyBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0gOiBbZXZlbnQueCwgZXZlbnQueV07XG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuXG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGFyZ2V0KShkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCksICQkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdHNldFpvb21SZXNldEJ1dHRvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHJlc2V0QnV0dG9uID0gY29uZmlnLnpvb21fcmVzZXRCdXR0b247XG5cblx0XHRpZiAocmVzZXRCdXR0b24gJiYgY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIikge1xuXHRcdFx0aWYgKCEkJC56b29tLnJlc2V0QnRuKSB7XG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4gPSAkJC5zZWxlY3RDaGFydC5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5idXR0b24sIHRydWUpXG5cdFx0XHRcdFx0LmFwcGVuZChcInNwYW5cIilcblx0XHRcdFx0XHQub24oXCJjbGlja1wiLCAkJC5hcGkudW56b29tLmJpbmQoJCQpKVxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvblpvb21SZXNldCwgdHJ1ZSlcblx0XHRcdFx0XHQudGV4dChyZXNldEJ1dHRvbi50ZXh0IHx8IFwiUmVzZXQgWm9vbVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzY2FsZU9yZGluYWwgYXMgZDNTY2FsZU9yZGluYWx9IGZyb20gXCJkMy1zY2FsZVwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge25vdEVtcHR5LCBleHRlbmQsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4vdXRpbFwiO1xuXG4vKipcbiAqIFNldCBwYXR0ZXJuJ3MgYmFja2dyb3VuZCBjb2xvclxuICogKGl0IGFkZHMgYSA8cmVjdD4gZWxlbWVudCB0byBzaW11bGF0ZSBiZy1jb2xvcilcbiAqIEBwYXJhbSB7U1ZHUGF0dGVybkVsZW1lbnR9IHBhdHRlcm4gU1ZHIHBhdHRlcm4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IGlkIElEIHRvIGJlIHNldFxuICogQHJldHVybiB7e2lkOiBzdHJpbmcsIG5vZGU6IFNWR1BhdHRlcm5FbGVtZW50fX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNvbG9yaXplUGF0dGVybiA9IChwYXR0ZXJuLCBjb2xvciwgaWQpID0+IHtcblx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHBhdHRlcm4uY2xvbmVOb2RlKHRydWUpKTtcblxuXHRub2RlXG5cdFx0LmF0dHIoXCJpZFwiLCBpZClcblx0XHQuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKVxuXHRcdC5hdHRyKFwid2lkdGhcIiwgbm9kZS5hdHRyKFwid2lkdGhcIikpXG5cdFx0LmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5hdHRyKFwiaGVpZ2h0XCIpKVxuXHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xuXG5cdHJldHVybiB7XG5cdFx0aWQsXG5cdFx0bm9kZTogbm9kZS5ub2RlKClcblx0fTtcbn07XG5cbi8vIFJlcGxhY2VtZW50IG9mIGQzLnNjaGVtZUNhdGVnb3J5MTAuXG4vLyBDb250YWluZWQgZGlmZmVyZW50bHkgZGVwZW5kIG9uIGQzIHZlcnNpb246IHY0KGQzLXNjYWxlKSwgdjUoZDMtc2NhbGUtY2hyb21hdGljKVxuY29uc3Qgc2NoZW1lQ2F0ZWdvcnkxMCA9IFtcIiMxZjc3YjRcIiwgXCIjZmY3ZjBlXCIsIFwiIzJjYTAyY1wiLCBcIiNkNjI3MjhcIiwgXCIjOTQ2N2JkXCIsIFwiIzhjNTY0YlwiLCBcIiNlMzc3YzJcIiwgXCIjN2Y3ZjdmXCIsIFwiI2JjYmQyMlwiLCBcIiMxN2JlY2ZcIl07XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IGNvbG9yIHBhdHRlcm4gZnJvbSBDU1MgZmlsZVxuXHQgKiBDU1Mgc2hvdWxkIGJlIGRlZmluZWQgYXM6IGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiMwMGM3M2M7I2ZhNzE3MTsgLi4uXCIpO1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldENvbG9yRnJvbUNzcygpIHtcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiX19jb2xvclBhdHRlcm5fX1wiO1xuXHRcdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHRcdGxldCBwYXR0ZXJuID0gYm9keVtjYWNoZUtleV07XG5cblx0XHRpZiAoIXBhdHRlcm4pIHtcblx0XHRcdGNvbnN0IGRlbGltaXRlciA9IFwiO1wiO1xuXHRcdFx0Y29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG5cdFx0XHRzcGFuLmNsYXNzTmFtZSA9IENMQVNTLmNvbG9yUGF0dGVybjtcblx0XHRcdHNwYW4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChzcGFuKTtcblxuXHRcdFx0Y29uc3QgY29udGVudCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmJhY2tncm91bmRJbWFnZTtcblxuXHRcdFx0c3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xuXG5cdFx0XHRpZiAoY29udGVudC5pbmRleE9mKGRlbGltaXRlcikgPiAtMSkge1xuXHRcdFx0XHRwYXR0ZXJuID0gY29udGVudFxuXHRcdFx0XHRcdC5yZXBsYWNlKC91cmxbXiNdKnxbXCInKCldfChcXHN8JTIwKS9nLCBcIlwiKVxuXHRcdFx0XHRcdC5zcGxpdChkZWxpbWl0ZXIpXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHYudHJpbSgpLnJlcGxhY2UoL1tcXFwiJ1xcc10vZywgXCJcIikpXG5cdFx0XHRcdFx0LmZpbHRlcihCb29sZWFuKTtcblxuXHRcdFx0XHRib2R5W2NhY2hlS2V5XSA9IHBhdHRlcm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhdHRlcm47XG5cdH0sXG5cblx0Z2VuZXJhdGVDb2xvcigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycztcblx0XHRjb25zdCBjYWxsYmFjayA9IGNvbmZpZy5kYXRhX2NvbG9yO1xuXHRcdGNvbnN0IGlkcyA9IFtdO1xuXG5cdFx0bGV0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6XG5cdFx0XHRkM1NjYWxlT3JkaW5hbCgkJC5nZXRDb2xvckZyb21Dc3MoKSB8fCBzY2hlbWVDYXRlZ29yeTEwKS5yYW5nZSgpO1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxDb2xvclBhdHRlcm4gPSBwYXR0ZXJuO1xuXG5cdFx0aWYgKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSkge1xuXHRcdFx0Y29uc3QgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMoKTtcblxuXHRcdFx0Ly8gQWRkIGJhY2tncm91bmQgY29sb3IgdG8gcGF0dGVybnNcblx0XHRcdGNvbnN0IGNvbG9yaXplZFBhdHRlcm5zID0gcGF0dGVybi5tYXAoKHAsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gcC5yZXBsYWNlKC9bI1xcKFxcKVxccyxdL2csIFwiXCIpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGAkeyQkLmRhdGV0aW1lSWR9LXBhdHRlcm4tJHtjb2xvcn0tJHtpbmRleH1gO1xuXG5cdFx0XHRcdHJldHVybiBjb2xvcml6ZVBhdHRlcm4odGlsZXNbaW5kZXggJSB0aWxlcy5sZW5ndGhdLCBwLCBpZCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cGF0dGVybiA9IGNvbG9yaXplZFBhdHRlcm5zLm1hcChwID0+IGB1cmwoIyR7cC5pZH0pYCk7XG5cdFx0XHQkJC5wYXR0ZXJucyA9IGNvbG9yaXplZFBhdHRlcm5zO1xuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XG5cdFx0XHRjb25zdCBpZCA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XG5cdFx0XHRjb25zdCBpc0xpbmUgPSAkJC5pc1R5cGVPZihpZCwgW1wibGluZVwiLCBcInNwbGluZVwiLCBcInN0ZXBcIl0pIHx8ICEkJC5jb25maWcuZGF0YV90eXBlc1tpZF07XG5cdFx0XHRsZXQgY29sb3I7XG5cblx0XHRcdC8vIGlmIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihjb2xvcnNbaWRdKSkge1xuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF0oZCk7XG5cblx0XHRcdC8vIGlmIHNwZWNpZmllZCwgY2hvb3NlIHRoYXQgY29sb3Jcblx0XHRcdH0gZWxzZSBpZiAoY29sb3JzW2lkXSkge1xuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF07XG5cblx0XHRcdC8vIGlmIG5vdCBzcGVjaWZpZWQsIGNob29zZSBmcm9tIHBhdHRlcm5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XG5cdFx0XHRcdFx0aWRzLnB1c2goaWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29sb3IgPSBpc0xpbmUgPyBvcmlnaW5hbENvbG9yUGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBvcmlnaW5hbENvbG9yUGF0dGVybi5sZW5ndGhdIDpcblx0XHRcdFx0XHRwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcblxuXHRcdFx0XHRjb2xvcnNbaWRdID0gY29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSA/XG5cdFx0XHRcdGNhbGxiYWNrKGNvbG9yLCBkKSA6IGNvbG9yO1xuXHRcdH07XG5cdH0sXG5cblx0Z2VuZXJhdGVMZXZlbENvbG9yKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY29sb3JzID0gY29uZmlnLmNvbG9yX3BhdHRlcm47XG5cdFx0Y29uc3QgdGhyZXNob2xkID0gY29uZmlnLmNvbG9yX3RocmVzaG9sZDtcblx0XHRjb25zdCBhc1ZhbHVlID0gdGhyZXNob2xkLnVuaXQgPT09IFwidmFsdWVcIjtcblx0XHRjb25zdCBtYXggPSB0aHJlc2hvbGQubWF4IHx8IDEwMDtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aHJlc2hvbGQudmFsdWVzICYmXG5cdFx0XHR0aHJlc2hvbGQudmFsdWVzLmxlbmd0aCA/IHRocmVzaG9sZC52YWx1ZXMgOiBbXTtcblxuXHRcdHJldHVybiBub3RFbXB0eSh0aHJlc2hvbGQpID8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGNvbnN0IHYgPSBhc1ZhbHVlID8gdmFsdWUgOiAodmFsdWUgKiAxMDAgLyBtYXgpO1xuXHRcdFx0bGV0IGNvbG9yID0gY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICh2IDw9IHZhbHVlc1tpXSkge1xuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb2xvcjtcblx0XHR9IDogbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBkYXRhIG92ZXIgY29sb3IuXG5cdCAqIFdoZW4gaXMgb3V0LCB3aWxsIHJlc3RvcmUgaW4gaXRzIHByZXZpb3VzIGNvbG9yIHZhbHVlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyIHRydWU6IHNldCBvdmVyZWQgY29sb3IsIGZhbHNlOiByZXN0b3JlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRPdmVyQ29sb3IoaXNPdmVyLCBkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBvbm92ZXIgPSBjb25maWcuY29sb3Jfb25vdmVyO1xuXHRcdGxldCBjb2xvciA9IGlzT3ZlciA/IG9ub3ZlciA6ICQkLmNvbG9yO1xuXG5cdFx0aWYgKGlzT2JqZWN0KGNvbG9yKSkge1xuXHRcdFx0Y29sb3IgPSAoe2lkfSkgPT4gKGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCkpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3IpKSB7XG5cdFx0XHRjb2xvciA9ICgpID0+IG9ub3Zlcjtcblx0XHR9XG5cblx0XHQvLyB3aGVuIGlzIEFyYyB0eXBlXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfS0ke2QuaWR9YClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcihkKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xuXHRcdH1cblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmNvbnN0IGdldEZvcm1hdCA9ICgkJCwgdHlwZVZhbHVlLCB2KSA9PiB7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0Y29uc3QgdHlwZSA9IGBheGlzXyR7dHlwZVZhbHVlfV90aWNrX2Zvcm1hdGA7XG5cdGNvbnN0IGZvcm1hdCA9IGNvbmZpZ1t0eXBlXSA/XG5cdFx0Y29uZmlnW3R5cGVdIDogJCQuZGVmYXVsdFZhbHVlRm9ybWF0O1xuXG5cdHJldHVybiBmb3JtYXQodik7XG59O1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0WUZvcm1hdChmb3JBcmMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGZvcm1hdEZvclkgPSAkJC55Rm9ybWF0O1xuXHRcdGxldCBmb3JtYXRGb3JZMiA9ICQkLnkyRm9ybWF0O1xuXG5cdFx0aWYgKGZvckFyYyAmJiAhJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XG5cdFx0XHRmb3JtYXRGb3JZID0gJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0O1xuXHRcdFx0Zm9ybWF0Rm9yWTIgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHYsIHJhdGlvLCBpZCkge1xuXHRcdFx0Y29uc3QgZm9ybWF0ID0gJCQuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/XG5cdFx0XHRcdGZvcm1hdEZvclkyIDogZm9ybWF0Rm9yWTtcblxuXHRcdFx0cmV0dXJuIGZvcm1hdC5jYWxsKCQkLCB2LCByYXRpbyk7XG5cdFx0fTtcblx0fSxcblxuXHR5Rm9ybWF0KHYpIHtcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieVwiLCB2KTtcblx0fSxcblxuXHR5MkZvcm1hdCh2KSB7XG5cdFx0cmV0dXJuIGdldEZvcm1hdCh0aGlzLCBcInkyXCIsIHYpO1xuXHR9LFxuXG5cdGRlZmF1bHRWYWx1ZUZvcm1hdCh2KSB7XG5cdFx0cmV0dXJuIGlzVmFsdWUodikgPyArdiA6IFwiXCI7XG5cdH0sXG5cblx0ZGVmYXVsdEFyY1ZhbHVlRm9ybWF0KHYsIHJhdGlvKSB7XG5cdFx0cmV0dXJuIGAkeyhyYXRpbyAqIDEwMCkudG9GaXhlZCgxKX0lYDtcblx0fSxcblxuXHRkYXRhTGFiZWxGb3JtYXQodGFyZ2V0SWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVscztcblx0XHRjb25zdCBkZWZhdWx0Rm9ybWF0ID0gdiA9PiAoaXNWYWx1ZSh2KSA/ICt2IDogXCJcIik7XG5cdFx0bGV0IGZvcm1hdCA9IGRlZmF1bHRGb3JtYXQ7XG5cblx0XHQvLyBmaW5kIGZvcm1hdCBhY2NvcmRpbmcgdG8gYXhpcyBpZFxuXHRcdGlmIChpc0Z1bmN0aW9uKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xuXHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXQ7XG5cdFx0fSBlbHNlIGlmIChpc09iamVjdFR5cGUoZGF0YUxhYmVscy5mb3JtYXQpKSB7XG5cdFx0XHRpZiAoZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdKSB7XG5cdFx0XHRcdGZvcm1hdCA9IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSA9PT0gdHJ1ZSA/XG5cdFx0XHRcdFx0ZGVmYXVsdEZvcm1hdCA6IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvcm1hdCA9ICgpID0+IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcm1hdDtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge3RvQXJyYXksIGV4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEFkZCBjYWNoZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0RhdGFUeXBlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhZGRDYWNoZShrZXksIHZhbHVlLCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcblx0XHR0aGlzLmNhY2hlW2tleV0gPSBpc0RhdGFUeXBlID8gdGhpcy5jbG9uZVRhcmdldCh2YWx1ZSkgOiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGNhY2hlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBrZXlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlbW92ZUNhY2hlKGtleSkge1xuXHRcdHRvQXJyYXkoa2V5KS5mb3JFYWNoKHYgPT4gZGVsZXRlIHRoaXMuY2FjaGVbdl0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgY2FoY2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGF0YVR5cGVcblx0ICogQHJldHVybiB7Kn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldENhY2hlKGtleSwgaXNEYXRhVHlwZSA9IGZhbHNlKSB7XG5cdFx0aWYgKGlzRGF0YVR5cGUpIHtcblx0XHRcdGNvbnN0IHRhcmdldHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlkOyAoaWQgPSBrZXlbaV0pOyBpKyspIHtcblx0XHRcdFx0aWYgKGlkIGluIHRoaXMuY2FjaGUpIHtcblx0XHRcdFx0XHR0YXJnZXRzLnB1c2godGhpcy5jbG9uZVRhcmdldCh0aGlzLmNhY2hlW2lkXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXRzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZVtrZXldIHx8IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiByZXNldCBjYWNoZWQgZGF0YVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbCB0cnVlOiByZXNldCBhbGwgZGF0YSwgZmFsc2U6IHJlc2V0IG9ubHkgJyQnIHByZWZpeGVkIGtleSBkYXRhXG5cdCAqIEBwcml2YXRlXG4gXHQgKi9cblx0cmVzZXRDYWNoZShhbGwpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRmb3IgKGNvbnN0IHggaW4gJCQuY2FjaGUpIHtcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxuXHRcdFx0aWYgKGFsbCB8fCAvXlxcJC8udGVzdCh4KSkge1xuXHRcdFx0XHQkJC5jYWNoZVt4XSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZW5lcmF0ZUNsYXNzKHByZWZpeCwgdGFyZ2V0SWQpIHtcblx0XHRyZXR1cm4gYCAke3ByZWZpeH0gJHtwcmVmaXggKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gO1xuXHR9LFxuXG5cdGNsYXNzVGV4dChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0LCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc1RleHRzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHRzLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc1NoYXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlLCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc1NoYXBlcyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zaGFwZXMsIGQuaWQpO1xuXHR9LFxuXG5cdGdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNsYXNzZXMgPSAkJC5jb25maWcubGluZV9jbGFzc2VzIHx8IFtdO1xuXHRcdGNvbnN0IGlkcyA9IFtdO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IGlkID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcblxuXHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcblx0XHRcdFx0aWRzLnB1c2goaWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xhc3Nlc1tpZHMuaW5kZXhPZihpZCkgJSBjbGFzc2VzLmxlbmd0aF07XG5cdFx0fTtcblx0fSxcblxuXHRjbGFzc0xpbmUoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGluZSwgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NMaW5lcyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGluZXMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQ2lyY2xlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZSwgZC5pbmRleCk7XG5cdH0sXG5cblx0Y2xhc3NDaXJjbGVzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5jaXJjbGVzLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc0JhcihkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5iYXIsIGQuaW5kZXgpO1xuXHR9LFxuXG5cdGNsYXNzQmFycyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFycywgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NBcmMoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmMsIGQuZGF0YS5pZCk7XG5cdH0sXG5cblx0Y2xhc3NBcmNzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyY3MsIGQuZGF0YS5pZCk7XG5cdH0sXG5cblx0Y2xhc3NBcmVhKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWEsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQXJlYXMoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWFzLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc1JlZ2lvbihkLCBpKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5yZWdpb24sIGkpfSAke1wiY2xhc3NcIiBpbiBkID8gZC5jbGFzcyA6IFwiXCJ9YDtcblx0fSxcblxuXHRjbGFzc0V2ZW50KGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmV2ZW50UmVjdCwgZC5pbmRleCk7XG5cdH0sXG5cblx0Y2xhc3NUYXJnZXQoaWQpIHtcblx0XHRjb25zdCBhZGRpdGlvbmFsQ2xhc3NTdWZmaXggPSB0aGlzLmNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdO1xuXHRcdGxldCBhZGRpdGlvbmFsQ2xhc3MgPSBcIlwiO1xuXG5cdFx0aWYgKGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCkge1xuXHRcdFx0YWRkaXRpb25hbENsYXNzID0gYCAke0NMQVNTLnRhcmdldH0tJHthZGRpdGlvbmFsQ2xhc3NTdWZmaXh9YDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRhcmdldCwgaWQpICsgYWRkaXRpb25hbENsYXNzO1xuXHR9LFxuXG5cdGNsYXNzRm9jdXMoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzRm9jdXNlZChkKSArIHRoaXMuY2xhc3NEZWZvY3VzZWQoZCk7XG5cdH0sXG5cblx0Y2xhc3NGb2N1c2VkKGQpIHtcblx0XHRyZXR1cm4gYCAke3RoaXMuZm9jdXNlZFRhcmdldElkcy5pbmRleE9mKGQuaWQpID49IDAgPyBDTEFTUy5mb2N1c2VkIDogXCJcIn1gO1xuXHR9LFxuXG5cdGNsYXNzRGVmb2N1c2VkKGQpIHtcblx0XHRyZXR1cm4gYCAke3RoaXMuZGVmb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmRlZm9jdXNlZCA6IFwiXCJ9YDtcblx0fSxcblxuXHRjbGFzc0NoYXJ0VGV4dChkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydExpbmUoZCkge1xuXHRcdHJldHVybiBDTEFTUy5jaGFydExpbmUgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQ2hhcnRCYXIoZCkge1xuXHRcdHJldHVybiBDTEFTUy5jaGFydEJhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydEFyYyhkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QXJjICsgdGhpcy5jbGFzc1RhcmdldChkLmRhdGEuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQ2hhcnRSYWRhcihkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0UmFkYXIgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xuXHR9LFxuXG5cdGdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKSB7XG5cdFx0cmV0dXJuIHRhcmdldElkIHx8IHRhcmdldElkID09PSAwID9cblx0XHRcdGAtJHt0YXJnZXRJZH1gLnJlcGxhY2UoL1tcXHM/IUAjJCVeJiooKV89KywuPD4nXCI6O1xcW1xcXVxcL3x+YHt9XFxcXF0vZywgXCItXCIpIDogXCJcIjtcblx0fSxcblxuXHRzZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSB7XG5cdFx0cmV0dXJuIGAke3ByZWZpeCB8fCBcIlwifS4ke0NMQVNTLnRhcmdldCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XG5cdH0sXG5cblx0c2VsZWN0b3JUYXJnZXRzKGlkc1ZhbHVlLCBwcmVmaXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaWRzID0gaWRzVmFsdWUgfHwgW107XG5cblx0XHRyZXR1cm4gaWRzLmxlbmd0aCA/XG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkLCBwcmVmaXgpKSA6IG51bGw7XG5cdH0sXG5cblx0c2VsZWN0b3JMZWdlbmQoaWQpIHtcblx0XHRyZXR1cm4gYC4ke0NMQVNTLmxlZ2VuZEl0ZW0gKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gO1xuXHR9LFxuXG5cdHNlbGVjdG9yTGVnZW5kcyhpZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gaWRzICYmIGlkcy5sZW5ndGggP1xuXHRcdFx0aWRzLm1hcChpZCA9PiAkJC5zZWxlY3RvckxlZ2VuZChpZCkpIDogbnVsbDtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIFRoaXMgQVBJIGhpZ2hsaWdodHMgc3BlY2lmaWVkIHRhcmdldHMgYW5kIGZhZGUgb3V0IHRoZSBvdGhlcnMuPGJyPjxicj5cblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZC5cblx0ICogQG1ldGhvZCBmb2N1c1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWRzIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gZGF0YTEgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxuXHQgKiAgY2hhcnQuZm9jdXMoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcblx0ICogY2hhcnQuZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcblx0ICogY2hhcnQuZm9jdXMoKTtcblx0ICovXG5cdGZvY3VzKHRhcmdldElkc1ZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuc3ZnLnNlbGVjdEFsbChcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXG5cdFx0KTtcblxuXHRcdHRoaXMucmV2ZXJ0KCk7XG5cdFx0dGhpcy5kZWZvY3VzKCk7XG5cblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgdHJ1ZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIGZhbHNlKTtcblxuXHRcdCQkLmhhc0FyY1R5cGUoKSAmJiAkJC5leHBhbmRBcmModGFyZ2V0SWRzKTtcblx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIHRydWUpO1xuXG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcblx0XHQkJC5kZWZvY3VzZWRUYXJnZXRJZHMgPSAkJC5kZWZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIEFQSSBmYWRlcyBvdXQgc3BlY2lmaWVkIHRhcmdldHMgYW5kIHJldmVydHMgdGhlIG90aGVycy48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cblx0ICogQG1ldGhvZCBkZWZvY3VzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFRhcmdldCBpZHMgdG8gYmUgZmFkZWQgb3V0LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBkYXRhMSB3aWxsIGJlIGZhZGVkIG91dCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBjaGFydC5kZWZvY3VzKFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGZhZGVkIG91dCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBjaGFydC5kZWZvY3VzKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cblx0ICogY2hhcnQuZGVmb2N1cygpO1xuXHQgKi9cblx0ZGVmb2N1cyh0YXJnZXRJZHNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLnN2Zy5zZWxlY3RBbGwoXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxuXHRcdCk7XG5cblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCB0cnVlKTtcblx0XHQkJC5oYXNBcmNUeXBlKCkgJiYgJCQudW5leHBhbmRBcmModGFyZ2V0SWRzKTtcblx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZhbHNlKTtcblxuXHRcdCQkLmZvY3VzZWRUYXJnZXRJZHMgPSAkJC5mb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcblx0XHQkJC5kZWZvY3VzZWRUYXJnZXRJZHMgPSB0YXJnZXRJZHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgQVBJIHJldmVydHMgc3BlY2lmaWVkIHRhcmdldHMuPGJyPjxicj5cblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cblx0ICogQG1ldGhvZCByZXZlcnRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gVGFyZ2V0IGlkcyB0byBiZSByZXZlcnRlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBkYXRhMSB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBjaGFydC5yZXZlcnQoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LnJldmVydChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cblx0ICogY2hhcnQucmV2ZXJ0KCk7XG5cdCAqL1xuXHRyZXZlcnQodGFyZ2V0SWRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKTsgLy8gc2hvdWxkIGJlIGZvciBhbGwgdGFyZ2V0c1xuXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xuXHRcdCQkLmhhc0FyY1R5cGUoKSAmJiAkJC51bmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy5sZWdlbmRfc2hvdykge1xuXHRcdFx0JCQuc2hvd0xlZ2VuZCh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzTGVnZW5kVG9TaG93LmJpbmQoJCQpKSk7XG5cdFx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKVxuXHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKTtcblx0XHR9XG5cblx0XHQkJC5mb2N1c2VkVGFyZ2V0SWRzID0gW107XG5cdFx0JCQuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogU2hvdy9IaWRlIGRhdGEgc2VyaWVzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2hvd0hpZGUoc2hvdywgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xuXG5cdFx0JCRbYCR7c2hvdyA/IFwicmVtb3ZlXCIgOiBcImFkZFwifUhpZGRlblRhcmdldElkc2BdKHRhcmdldElkcyk7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSBzaG93ID8gXCIxXCIgOiBcIjBcIjtcblxuXHRcdHRhcmdldHMudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHksIFwiaW1wb3J0YW50XCIpXG5cdFx0XHQuY2FsbCgkJC5lbmRhbGwsICgpID0+IHtcblx0XHRcdFx0dGFyZ2V0cy5zdHlsZShcIm9wYWNpdHlcIiwgbnVsbCkuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xuXHRcdFx0fSk7XG5cblx0XHRvcHRpb25zLndpdGhMZWdlbmQgJiYgJCRbYCR7c2hvdyA/IFwic2hvd1wiIDogXCJoaWRlXCJ9TGVnZW5kYF0odGFyZ2V0SWRzKTtcblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IGRhdGEgc2VyaWVzIG9uIGNoYXJ0XG5cdCAqIEBtZXRob2Qgc2hvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBzaG93ICdkYXRhMSdcblx0ICogY2hhcnQuc2hvdyhcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBzaG93ICdkYXRhMScgYW5kICdkYXRhMydcblx0ICogY2hhcnQuc2hvdyhbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcblx0ICovXG5cdHNob3codGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuX3Nob3dIaWRlKHRydWUsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSBkYXRhIHNlcmllcyBmcm9tIGNoYXJ0XG5cdCAqIEBtZXRob2QgaGlkZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBoaWRlICdkYXRhMSdcblx0ICogY2hhcnQuaGlkZShcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBoaWRlICdkYXRhMScgYW5kICdkYXRhMydcblx0ICogY2hhcnQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcblx0ICovXG5cdGhpZGUodGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuX3Nob3dIaWRlKGZhbHNlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBkYXRhIHNlcmllcyBvbiBjaGFydC4gV2hlbiB0YXJnZXQgZGF0YSBpcyBoaWRkZW4sIGl0IHdpbGwgc2hvdy4gSWYgaXMgc2hvd24sIGl0IHdpbGwgaGlkZSBpbiB2aWNlIHZlcnNhLlxuXHQgKiBAbWV0aG9kIHRvZ2dsZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJ1xuXHQgKiBjaGFydC50b2dnbGUoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gdG9nZ2xlICdkYXRhMScgYW5kICdkYXRhMydcblx0ICogY2hhcnQudG9nZ2xlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xuXHQgKi9cblx0dG9nZ2xlKHRhcmdldElkcywgb3B0aW9ucyA9IHt9KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IHRhcmdldHMgPSB7c2hvdzogW10sIGhpZGU6IFtdfTtcblxuXHRcdC8vIHNvcnQgc2hvdyAmIGhpZGUgdGFyZ2V0IGlkc1xuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcylcblx0XHRcdC5mb3JFYWNoKGlkID0+IHRhcmdldHNbJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gXCJoaWRlXCIgOiBcInNob3dcIl0ucHVzaChpZCkpO1xuXG5cdFx0Ly8gcGVyZm9ybSBzaG93ICYgaGlkZSB0YXNrIHNlcGFyYXRlbHlcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NTRcblx0XHR0YXJnZXRzLnNob3cubGVuZ3RoICYmIHRoaXMuc2hvdyh0YXJnZXRzLnNob3csIG9wdGlvbnMpO1xuXHRcdHRhcmdldHMuaGlkZS5sZW5ndGggJiYgc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGUodGFyZ2V0cy5oaWRlLCBvcHRpb25zKSwgMCk7XG5cdH1cbn0pO1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3pvb21JZGVudGl0eSBhcyBkM1pvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSBhcyBkM1pvb21UcmFuc2Zvcm19IGZyb20gXCJkMy16b29tXCI7XG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtjYWxsRm4sIGV4dGVuZCwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2l0aGluUmFuZ2UgPSAoZG9tYWluLCByYW5nZSkgPT4ge1xuXHRjb25zdCBbbWluLCBtYXhdID0gcmFuZ2U7XG5cblx0cmV0dXJuIGRvbWFpbi5ldmVyeSgodiwgaSkgPT4gKFxuXHRcdGkgPT09IDAgPyAodiA+PSBtaW4pIDogKHYgPD0gbWF4KVxuXHQpKTtcbn07XG5cbi8qKlxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXG4gKiAtICoqTk9URToqKlxuICogIC0gRm9yIGB3aGVlbGAgdHlwZSB6b29tLCB0aGUgbWluaW11bSB6b29tIHJhbmdlIHdpbGwgYmUgc2V0IGFzIHRoZSBnaXZlbiBkb21haW4uIFRvIGdldCB0aGUgaW5pdGlhbCBzdGF0ZSwgWy51bnpvb20oKV0oI3Vuem9vbSkgc2hvdWxkIGJlIGNhbGxlZC5cbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cbiAqIEBtZXRob2Qgem9vbVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpblZhbHVlIElmIGRvbWFpbiBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgem9vbWVkIHRvIHRoZSBnaXZlbiBkb21haW4uIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gZG9tYWluIHZhbHVlIGluIGFycmF5XG4gKiBAZXhhbXBsZVxuICogIC8vIFpvb20gdG8gc3BlY2lmaWVkIGRvbWFpblxuICogIGNoYXJ0Lnpvb20oWzEwLCAyMF0pO1xuICpcbiAqICAvLyBHZXQgdGhlIGN1cnJlbnQgem9vbWVkIGRvbWFpblxuICogIGNoYXJ0Lnpvb20oKTtcbiAqL1xuY29uc3Qgem9vbSA9IGZ1bmN0aW9uKGRvbWFpblZhbHVlKSB7XG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xuXHRsZXQgcmVzdWx0RG9tYWluO1xuXG5cdGlmICgkJC5jb25maWcuem9vbV9lbmFibGVkICYmIGRvbWFpbiAmJiB3aXRoaW5SYW5nZShkb21haW4sICQkLmdldFpvb21Eb21haW4oKSkpIHtcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKTtcblxuXHRcdGlmIChpc1RpbWVTZXJpZXMpIHtcblx0XHRcdGRvbWFpbiA9IGRvbWFpbi5tYXAoeCA9PiAkJC5wYXJzZURhdGUoeCkpO1xuXHRcdH1cblxuXHRcdGlmICgkJC5jb25maWcuc3ViY2hhcnRfc2hvdykge1xuXHRcdFx0Y29uc3QgeFNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cblx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgW3hTY2FsZShkb21haW5bMF0pLCB4U2NhbGUoZG9tYWluWzFdKV0pO1xuXHRcdFx0cmVzdWx0RG9tYWluID0gZG9tYWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkJC54LmRvbWFpbihkb21haW4pO1xuXHRcdFx0JCQuem9vbVNjYWxlID0gJCQueDtcblx0XHRcdCQkLnhBeGlzLnNjYWxlKCQkLnpvb21TY2FsZSk7XG5cblx0XHRcdHJlc3VsdERvbWFpbiA9ICQkLnpvb21TY2FsZS5vcmdEb21haW4oKTtcblx0XHR9XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXG5cdFx0XHR3aXRoWTogJCQuY29uZmlnLnpvb21fcmVzY2FsZSxcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXG5cdFx0fSk7XG5cblx0XHQkJC5zZXRab29tUmVzZXRCdXR0b24oKTtcblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tLCByZXN1bHREb21haW4pO1xuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdERvbWFpbiA9ICQkLnpvb21TY2FsZSA/XG5cdFx0XHQkJC56b29tU2NhbGUuZG9tYWluKCkgOiAkJC54Lm9yZ0RvbWFpbigpO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcbn07XG5cbmV4dGVuZCh6b29tLCB7XG5cdC8qKlxuXHQgKiBFbmFibGUgYW5kIGRpc2FibGUgem9vbWluZy5cblx0ICogQG1ldGhvZCB6b29t4oCkZW5hYmxlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gZW5hYmxlZCBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzIGFyZSBcIndoZWVsXCIgb3IgXCJkcmFnXCIuIElmIGVuYWJsZWQgaXMgdHJ1ZSwgXCJ3aGVlbFwiIHdpbGwgYmUgdXNlZC4gSWYgZmFsc2UgaXMgZ2l2ZW4sIHpvb21pbmcgd2lsbCBiZSBkaXNhYmxlZC48YnI+V2hlbiBzZXQgdG8gZmFsc2UsIHRoZSBjdXJyZW50IHpvb21pbmcgc3RhdHVzIHdpbGwgYmUgcmVzZXQuXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBFbmFibGUgem9vbWluZyB1c2luZyB0aGUgbW91c2Ugd2hlZWxcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKHRydWUpO1xuXHQgKiAgLy8gT3Jcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwid2hlZWxcIik7XG5cdCAqXG5cdCAqICAvLyBFbmFibGUgem9vbWluZyBieSBkcmFnZ2luZ1xuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJkcmFnXCIpO1xuXHQgKlxuXHQgKiAgLy8gRGlzYWJsZSB6b29taW5nXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShmYWxzZSk7XG5cdCAqL1xuXHRlbmFibGU6IGZ1bmN0aW9uKGVuYWJsZWQgPSBcIndoZWVsXCIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBlbmFibGVUeXBlID0gZW5hYmxlZDtcblxuXHRcdGlmIChlbmFibGVkKSB7XG5cdFx0XHRlbmFibGVUeXBlID0gaXNTdHJpbmcoZW5hYmxlZCkgJiYgL14oZHJhZ3x3aGVlbCkkLy50ZXN0KGVuYWJsZWQpID9cblx0XHRcdFx0e3R5cGU6IGVuYWJsZWR9IDogZW5hYmxlZDtcblx0XHR9XG5cblx0XHRjb25maWcuem9vbV9lbmFibGVkID0gZW5hYmxlVHlwZTtcblxuXHRcdGlmICghJCQuem9vbSkge1xuXHRcdFx0JCQuaW5pdFpvb20oKTtcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcblx0XHR9IGVsc2UgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHQkJC5iaW5kWm9vbUV2ZW50KGZhbHNlKTtcblx0XHR9XG5cblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlIHZhbHVlXG5cdCAqIEBtZXRob2Qgem9vbeKApG1heFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4XSBtYXhpbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWF4IHZhbHVlXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBTZXQgbWF4aW11bSByYW5nZSB2YWx1ZVxuXHQgKiAgY2hhcnQuem9vbS5tYXgoMjApO1xuXHQgKi9cblx0bWF4OiBmdW5jdGlvbihtYXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKG1heCA9PT0gMCB8fCBtYXgpIHtcblx0XHRcdGNvbmZpZy56b29tX3hfbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFskJC5vcmdYRG9tYWluWzFdLCBtYXhdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9tYXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZSB2YWx1ZVxuXHQgKiBAbWV0aG9kIHpvb23igKRtaW5cblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pbl0gbWluaW11bSB2YWx1ZSB0byBzZXQgZm9yIHpvb21cblx0ICogQHJldHVybiB7TnVtYmVyfSB6b29tIG1pbiB2YWx1ZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gU2V0IG1pbmltdW0gcmFuZ2UgdmFsdWVcblx0ICogIGNoYXJ0Lnpvb20ubWluKC0xKTtcblx0ICovXG5cdG1pbjogZnVuY3Rpb24obWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmIChtaW4gPT09IDAgfHwgbWluKSB7XG5cdFx0XHRjb25maWcuem9vbV94X21pbiA9IGdldE1pbk1heChcIm1pblwiLCBbJCQub3JnWERvbWFpblswXSwgbWluXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbmZpZy56b29tX3hfbWluO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgem9vbSByYW5nZVxuXHQgKiBAbWV0aG9kIHpvb23igKRyYW5nZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcmFuZ2VdXG5cdCAqIEByZXR1cm4ge09iamVjdH0gem9vbSByYW5nZSB2YWx1ZVxuXHQgKiB7XG5cdCAqICAgbWluOiAwLFxuXHQgKiAgIG1heDogMTAwXG5cdCAqIH1cblx0ICogQGV4YW1wbGVcblx0ICogIGNoYXJ0Lnpvb20ucmFuZ2Uoe1xuXHQgKiAgICAgIG1pbjogMTAsXG5cdCAqICAgICAgbWF4OiAxMDBcblx0ICogIH0pO1xuXHQgKi9cblx0cmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0Y29uc3Qgem9vbSA9IHRoaXMuem9vbTtcblxuXHRcdGlmIChpc09iamVjdChyYW5nZSkpIHtcblx0XHRcdGNvbnN0IHttaW4sIG1heH0gPSByYW5nZTtcblxuXHRcdFx0aXNEZWZpbmVkKG1pbikgJiYgem9vbS5taW4obWluKTtcblx0XHRcdGlzRGVmaW5lZChtYXgpICYmIHpvb20ubWF4KG1heCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1pbjogem9vbS5taW4oKSxcblx0XHRcdG1heDogem9vbS5tYXgoKVxuXHRcdH07XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdHpvb20sXG5cblx0LyoqXG5cdCAqIFVuem9vbSB6b29tZWQgYXJlYVxuXHQgKiBAbWV0aG9kIHVuem9vbVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBleGFtcGxlXG5cdCAqICBjaGFydC51bnpvb20oKTtcblx0ICovXG5cdHVuem9vbSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCQkLnpvb21TY2FsZSkge1xuXHRcdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgP1xuXHRcdFx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24oKS5jYWxsKCQkLmJydXNoLm1vdmUsIG51bGwpIDpcblx0XHRcdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZShkM1pvb21JZGVudGl0eSk7XG5cblx0XHRcdCQkLnVwZGF0ZVpvb20odHJ1ZSk7XG5cdFx0XHQkJC56b29tLnJlc2V0QnRuICYmICQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblxuXHRcdFx0Ly8gcmVzZXQgdHJhbnNmb3JtXG5cdFx0XHRjb25zdCBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XG5cblx0XHRcdGlmIChkM1pvb21UcmFuc2Zvcm0oZXZlbnRSZWN0cy5ub2RlKCkpICE9PSBkM1pvb21JZGVudGl0eSkge1xuXHRcdFx0XHQkJC56b29tLnRyYW5zZm9ybShldmVudFJlY3RzLCBkM1pvb21JZGVudGl0eSk7XG5cdFx0XHR9XG5cblx0XHRcdCQkLnJlZHJhdyh7XG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc1N0cmluZywgaXNBcnJheX0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIExvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSB0b2dnbGVzLlxuXHQgKiAtIDxiPk5vdGU6PC9iPlxuXHQgKiAgIC0gdW5sb2FkIHNob3VsZCBiZSB1c2VkIGlmIHNvbWUgZGF0YSBuZWVkcyB0byBiZSB1bmxvYWRlZCBzaW11bHRhbmVvdXNseS5cblx0ICogICAgIElmIHlvdSBjYWxsIHVubG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgbG9hZCBpbnN0ZWFkIG9mIHVubG9hZCBwYXJhbSwgY2hhcnQgd2lsbCBub3QgYmUgcmVuZGVyZWQgcHJvcGVybHkgYmVjYXVzZSBvZiBjYW5jZWwgb2YgYW5pbWF0aW9uLjxicj5cblx0ICogICAtIGRvbmUgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuXG5cdCAqICAgICBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZ1xuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxuXHQgKlxuXHQgKiAgICB8IEtleSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IC0gdXJsPGJyPi0ganNvbjxicj4tIHJvd3M8YnI+LSBjb2x1bW5zIHwgVGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB1cGRhdGVkLiBPdGhlcndpc2UsIG5ldyB0YXJnZXQgd2lsbCBiZSBhZGRlZCB8XG5cdCAqICAgIHwgZGF0YSB8IERhdGEgb2JqZWN0cyB0byBiZSBsb2FkZWQuIENoZWNrb3V0IHRoZSBleGFtcGxlLiB8XG5cdCAqICAgIHwgbmFtZXMgfCBTYW1lIGFzIGRhdGEubmFtZXMoKSB8XG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XG5cdCAqICAgIHwgY2xhc3NlcyB8IFRoZSBjbGFzc2VzIHNwZWNpZmllZCBieSBkYXRhLmNsYXNzZXMgd2lsbCBiZSB1cGRhdGVkLiBjbGFzc2VzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XG5cdCAqICAgIHwgY2F0ZWdvcmllcyB8IFRoZSBjYXRlZ29yaWVzIHNwZWNpZmllZCBieSBheGlzLnguY2F0ZWdvcmllcyBvciBkYXRhLnggd2lsbCBiZSB1cGRhdGVkLiBjYXRlZ29yaWVzIG11c3QgYmUgQXJyYXkuIHxcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcblx0ICogICAgfCBjb2xvcnMgfCBUaGUgY29sb3JzIHNwZWNpZmllZCBieSBkYXRhLmNvbG9ycyB3aWxsIGJlIHVwZGF0ZWQuIGNvbG9ycyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxuXHQgKiAgICB8IGhlYWRlcnMgfCAgU2V0IHJlcXVlc3QgaGVhZGVyIGlmIGxvYWRpbmcgdmlhIGBkYXRhLnVybGAuPGJyPkBzZWUgW2RhdGHigKRoZWFkZXJzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRoZWFkZXJzKSB8XG5cdCAqICAgIHwga2V5cyB8ICBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3RzIGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuPGJyPioqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS48YnI+QHNlZSBbZGF0YeKApGtleXNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpIHxcblx0ICogICAgfCBtaW1lVHlwZSB8ICBTZXQgJ2pzb24nIGlmIGxvYWRpbmcgSlNPTiB2aWEgdXJsLjxicj5Ac2VlIFtkYXRh4oCkbWltZVR5cGVdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNG1pbWVUeXBlKSB8XG5cdCAqICAgIHwgLSB0eXBlPGJyPi0gdHlwZXMgfCBUaGUgdHlwZSBvZiB0YXJnZXRzIHdpbGwgYmUgdXBkYXRlZC4gdHlwZSBtdXN0IGJlIFN0cmluZyBhbmQgdHlwZXMgbXVzdCBiZSBPYmplY3QuIHxcblx0ICogICAgfCB1bmxvYWQgfCBTcGVjaWZ5IHRoZSBkYXRhIHdpbGwgYmUgdW5sb2FkZWQgYmVmb3JlIGxvYWRpbmcgbmV3IGRhdGEuIElmIHRydWUgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIElmIHRhcmdldCBpZHMgZ2l2ZW4gYXMgU3RyaW5nIG9yIEFycmF5LCBzcGVjaWZpZWQgdGFyZ2V0cyB3aWxsIGJlIHVubG9hZGVkLiBJZiBhYnNlbnQgb3IgZmFsc2UgZ2l2ZW4sIHVubG9hZCB3aWxsIG5vdCBvY2N1ci4gfFxuXHQgKiAgICB8IGRvbmUgfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLnxcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUZyb21VUkwpXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIExvYWQgZGF0YTEgYW5kIHVubG9hZCBkYXRhMiBhbmQgZGF0YTNcblx0ICogY2hhcnQubG9hZCh7XG5cdCAqICAgICBjb2x1bW5zOiBbXG5cdCAqICAgICAgICBbXCJkYXRhMVwiLCAxMDAsIDIwMCwgMTUwLCAuLi5dLFxuXHQgKiAgICAgICAgLi4uXG5cdCAqICAgIF0sXG5cdCAqICAgIHVubG9hZDogW1wiZGF0YTJcIiwgXCJkYXRhM1wiXSxcblx0ICogICAgdXJsOiBcIi4uLlwiLFxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHsgLi4uIH1cblx0ICogfSk7XG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIG15QVBJLmpzb25cblx0ICogLy8ge1xuXHQgKiAvLyAgIFwiZGF0YTFcIjogWzIyMCwgMjQwLCAyNzAsIDI1MCwgMjgwXSxcblx0ICogLy8gICBcImRhdGEyXCI6IFsxODAsIDE1MCwgMzAwLCA3MCwgMTIwXVxuXHQgKiAvLyB9XG5cdCAqXG5cdCAqIGNoYXJ0LmxvYWQoe1xuXHQgKiAgICAgdXJsOiAnLi9kYXRhL215QVBJLmpzb24nLFxuXHQgKiAgICAgbWltZVR5cGU6IFwianNvblwiLFxuXHQgKlxuXHQgKiAgICAgLy8gc2V0IHJlcXVlc3QgaGVhZGVyIGlmIGlzIG5lZWRlZFxuXHQgKiAgICAgaGVhZGVyczoge1xuXHQgKiAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvanNvblwiXG5cdCAqICAgICB9XG5cdCAqIH0pO1xuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5sb2FkKHtcblx0ICogICAgIGRhdGE6IFtcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1dXG5cdCAqICAgICAgIHtcImRhdGExXCI6IDMwfSwge1wiZGF0YTFcIjogMjAwfSwge1wiZGF0YTFcIjogMTAwfVxuXHQgKlxuXHQgKiAgICAgICAvLyBvclxuXHQgKiAgICAgICAvLyBlcXVpdmFsZW50IGFzOiBjb2x1bW5zOiBbW1wiZGF0YTFcIiwgMTAsIDIwXSwgW1wiZGF0YTJcIiwgMTMsIDMwXV1cblx0ICogICAgICAgLy8ge1wiZGF0YTFcIjogMTAsIFwiZGF0YTJcIjogMTN9LCB7XCJkYXRhMVwiOiAyMCwgXCJkYXRhMlwiOiAzMH19XG5cdCAqICAgICBdXG5cdCAqIH0pO1xuXHQgKi9cblx0bG9hZChhcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcblx0XHRhcmdzLnhzICYmICQkLmFkZFhzKGFyZ3MueHMpO1xuXG5cdFx0Ly8gdXBkYXRlIG5hbWVzIGlmIGV4aXN0c1xuXHRcdFwibmFtZXNcIiBpbiBhcmdzICYmIHRoaXMuZGF0YS5uYW1lcyhhcmdzLm5hbWVzKTtcblxuXHRcdC8vIHVwZGF0ZSBjbGFzc2VzIGlmIGV4aXN0c1xuXHRcdFwiY2xhc3Nlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5jbGFzc2VzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdID0gYXJncy5jbGFzc2VzW2lkXTtcblx0XHR9KTtcblxuXHRcdC8vIHVwZGF0ZSBjYXRlZ29yaWVzIGlmIGV4aXN0c1xuXHRcdGlmIChcImNhdGVnb3JpZXNcIiBpbiBhcmdzICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBheGVzIGlmIGV4aXN0c1xuXHRcdFwiYXhlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5heGVzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbmZpZy5kYXRhX2F4ZXNbaWRdID0gYXJncy5heGVzW2lkXTtcblx0XHR9KTtcblxuXHRcdC8vIHVwZGF0ZSBjb2xvcnMgaWYgZXhpc3RzXG5cdFx0XCJjb2xvcnNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY29sb3JzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbmZpZy5kYXRhX2NvbG9yc1tpZF0gPSBhcmdzLmNvbG9yc1tpZF07XG5cdFx0fSk7XG5cblx0XHQvLyB1bmxvYWQgaWYgbmVlZGVkXG5cdFx0aWYgKFwidW5sb2FkXCIgaW4gYXJncyAmJiBhcmdzLnVubG9hZCAhPT0gZmFsc2UpIHtcblx0XHRcdC8vIFRPRE86IGRvIG5vdCB1bmxvYWQgaWYgdGFyZ2V0IHdpbGwgbG9hZCAoaW5jbHVkZWQgaW4gdXJsL3Jvd3MvY29sdW1ucylcblx0XHRcdCQkLnVubG9hZCgkJC5tYXBUb1RhcmdldElkcyhhcmdzLnVubG9hZCA9PT0gdHJ1ZSA/IG51bGwgOiBhcmdzLnVubG9hZCksICgpID0+XG5cdFx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCQubG9hZEZyb21BcmdzKGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVW5sb2FkIGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgdG9nZ2xlcy5cblx0ICogLSA8Yj5Ob3RlOjwvYj5cblx0ICogSWYgeW91IGNhbGwgbG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgdW5sb2FkLCB1bmxvYWQgcGFyYW0gb2YgbG9hZCBzaG91bGQgYmUgdXNlZC4gT3RoZXJ3aXNlIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XG5cdCAqIGBkb25lYCB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy4gSXQncyBiZWNhdXNlIHJlbmRlcmluZyB3aWxsIGZpbmlzaCBhZnRlciBzb21lIHRyYW5zaXRpb24gYW5kIHRoZXJlIGlzIHNvbWUgdGltZSBsYWcgYmV0d2VlbiBsb2FkaW5nIGFuZCByZW5kZXJpbmcuXG5cdCAqIEBtZXRob2QgdW5sb2FkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3Ncblx0ICogIHwga2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogIHwgLS0tIHwgLS0tIHwgLS0tIHxcblx0ICogIHwgaWRzIHwgU3RyaW5nICZ2ZXJ0OyBBcnJheSB8IFRhcmdldCBpZCBkYXRhIHRvIGJlIHVubG9hZGVkLiBJZiBub3QgZ2l2ZW4sIGFsbCBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIHxcblx0ICogIHwgZG9uZSB8IEZ1Y3Rpb24gfCBDYWxsYmFjayBhZnRlciBkYXRhIGlzIHVubG9hZGVkLiB8XG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBVbmxvYWQgZGF0YTIgYW5kIGRhdGEzXG5cdCAqICBjaGFydC51bmxvYWQoe1xuXHQgKiAgICBpZHM6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXG5cdCAqICAgIGRvbmU6IGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHVubG9hZGVkXG5cdCAqICAgIH1cblx0ICogIH0pO1xuXHQgKi9cblx0dW5sb2FkKGFyZ3NWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgYXJncyA9IGFyZ3NWYWx1ZSB8fCB7fTtcblxuXHRcdGlmIChpc0FycmF5KGFyZ3MpKSB7XG5cdFx0XHRhcmdzID0ge2lkczogYXJnc307XG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcmdzKSkge1xuXHRcdFx0YXJncyA9IHtpZHM6IFthcmdzXX07XG5cdFx0fVxuXG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9UYXJnZXRJZHMoYXJncy5pZHMpO1xuXG5cdFx0JCQudW5sb2FkKGlkcywgKCkgPT4ge1xuXHRcdFx0JCQucmVkcmF3KHtcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXG5cdFx0XHR9KTtcblxuXHRcdFx0JCQucmVtb3ZlQ2FjaGUoaWRzKTtcblx0XHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUoKTtcblx0XHR9KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtlYXNlTGluZWFyIGFzIGQzRWFzZUxpbmVhcn0gZnJvbSBcImQzLWVhc2VcIjtcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2lzRGVmaW5lZCwgaXNWYWx1ZSwgZGlmZkRvbWFpbiwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogRmxvdyBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBhcHBlbmQgbmV3IGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBmbG93XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdCAqICAgIHwganNvbiB8IE9iamVjdCB8IERhdGEgYXMgSlNPTiBmb3JtYXQgKEBzZWUgW2RhdGHigKRqc29uXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxuXHQgKiAgICB8IHJvd3MgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgcm93IGZvcm1hdCAoQHNlZSBbZGF0YeKApHJvd3NdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGpzb24pKSB8XG5cdCAqICAgIHwgY29sdW1ucyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyBjb2x1bW4gZm9ybWF0IChAc2VlIFtkYXRh4oCkY29sdW1uc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sdW1ucykpIHxcblx0ICogICAgfCB0byB8IFN0cmluZyB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIHRvIHRoYXQgcG9pbnQuIElmIG5vdCBnaXZlbiwgdGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiBnaXZlbiBkYXRhIHBvaW50cyB8XG5cdCAqICAgIHwgbGVuZ3RoIHwgTnVtYmVyIHwgVGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiB0aGlzIGFyZ3VtZW50IHxcblx0ICogICAgfCBkdXJhdGlvbiB8IE51bWJlciB8IFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNwZWNpZmllZCB2YWx1ZS4gSWYgbm90IGdpdmVuLCB0cmFuc2l0aW9uLmR1cmF0aW9uIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHxcblx0ICogICAgfCBkb25lIHwgRnVuY3Rpb24gfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmxvdyBlbmRzIHxcblx0ICpcblx0ICogLSAqKk5PVEU6Kipcblx0ICogICAtIElmIGpzb24sIHJvd3MgYW5kIGNvbHVtbnMgZ2l2ZW4sIHRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLlxuXHQgKiAgIC0gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIGFwcGVuZGVkLlxuXHQgKiAgIC0gT3RoZXJ3aXNlLCBuZXcgdGFyZ2V0IHdpbGwgYmUgYWRkZWQuIE9uZSBvZiB0aGVzZSBpcyByZXF1aXJlZCB3aGVuIGNhbGxpbmcuXG5cdCAqICAgLSBJZiBqc29uIHNwZWNpZmllZCwga2V5cyBpcyByZXF1aXJlZCBhcyB3ZWxsIGFzIGRhdGEuanNvbi5cblx0ICogXHQgLSBJZiB0YWIgaXNuJ3QgdmlzaWJsZShieSBldmFsdWF0aW5nIGBkb2N1bWVudC5oaWRkZW5gKSwgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSB3b3JrLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyAyIGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwcmVuZGVkIHRvIHRoZSB0YWlsIGFuZCBwb3BwZWQgZnJvbSB0aGUgaGVhZC5cblx0ICogLy8gQWZ0ZXIgdGhhdCwgNCBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcGVuZGVkIGFuZCBubyBkYXRhIHBvaW50cyB3aWxsIGJlIHBvcHBvZWQuXG5cdCAqIGNoYXJ0LmZsb3coe1xuXHQgKiAgY29sdW1uczogW1xuXHQgKiAgICBbXCJ4XCIsIFwiMjAxOC0wMS0xMVwiLCBcIjIwMTgtMDEtMjFcIl0sXG5cdCAqICAgIFtcImRhdGExXCIsIDUwMCwgMjAwXSxcblx0ICogICAgW1wiZGF0YTJcIiwgMTAwLCAzMDBdLFxuXHQgKiAgICBbXCJkYXRhM1wiLCAyMDAsIDEyMF1cblx0ICogIF0sXG5cdCAqICB0bzogXCIyMDEzLTAxLTExXCIsXG5cdCAqICBkb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAqICAgIGNoYXJ0LmZsb3coe1xuXHQgKiAgICAgIGNvbHVtbnM6IFtcblx0ICogICAgICAgIFtcInhcIiwgXCIyMDE4LTAyLTExXCIsIFwiMjAxOC0wMi0xMlwiLCBcIjIwMTgtMDItMTNcIiwgXCIyMDE4LTAyLTE0XCJdLFxuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMjAwLCAzMDAsIDEwMCwgMjUwXSxcblx0ICogICAgICAgIFtcImRhdGEyXCIsIDEwMCwgOTAsIDQwLCAxMjBdLFxuXHQgKiAgICAgICAgW1wiZGF0YTNcIiwgMTAwLCAxMDAsIDMwMCwgNTAwXVxuXHQgKiAgICAgIF0sXG5cdCAqICAgICAgbGVuZ3RoOiAyLFxuICAgICAqICAgICAgZHVyYXRpb246IDE1MDBcblx0ICogICAgfSk7XG5cdCAqICB9XG5cdCAqIH0pO1xuXHQgKi9cblx0ZmxvdyhhcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGxldCBkYXRhO1xuXHRcdGxldCBkb21haW47XG5cdFx0bGV0IGxlbmd0aCA9IDA7XG5cdFx0bGV0IHRhaWwgPSAwO1xuXHRcdGxldCBkaWZmO1xuXHRcdGxldCB0bztcblxuXHRcdGlmIChhcmdzLmpzb24gfHwgYXJncy5yb3dzIHx8IGFyZ3MuY29sdW1ucykge1xuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnREYXRhKGFyZ3MpO1xuXHRcdH1cblxuXHRcdGlmICghZGF0YSB8fCAhJCQuaXNUYWJWaXNpYmxlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBub3Rmb3VuZElkcyA9IFtdO1xuXHRcdGNvbnN0IG9yZ0RhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCB0cnVlKTtcblxuXHRcdC8vIFVwZGF0ZS9BZGQgZGF0YVxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmICh0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXSkge1xuXHRcdFx0XHRcdFx0dGFpbCA9IHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdLmluZGV4ICsgMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZW5ndGggPSB0YXJnZXRzW2ldLnZhbHVlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRzW2ldLnZhbHVlc1tqXS5pbmRleCA9IHRhaWwgKyBqO1xuXG5cdFx0XHRcdFx0XHRpZiAoISQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLnggPSB0YWlsICsgajtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0LnZhbHVlcyA9IHQudmFsdWVzLmNvbmNhdCh0YXJnZXRzW2ldLnZhbHVlcyk7XG5cdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0IWZvdW5kICYmIG5vdGZvdW5kSWRzLnB1c2godC5pZCk7XG5cdFx0fSk7XG5cblx0XHQvLyBBcHBlbmQgbnVsbCBmb3Igbm90IGZvdW5kIHRhcmdldHNcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm90Zm91bmRJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHQuaWQgPT09IG5vdGZvdW5kSWRzW2ldKSB7XG5cdFx0XHRcdFx0dGFpbCA9IHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdLmluZGV4ICsgMTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHQudmFsdWVzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpZDogdC5pZCxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IHRhaWwgKyBqLFxuXHRcdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WCh0YWlsICsgaikgOiB0YWlsICsgaixcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gR2VuZXJhdGUgbnVsbCB2YWx1ZXMgZm9yIG5ldyB0YXJnZXRcblx0XHRpZiAoJCQuZGF0YS50YXJnZXRzLmxlbmd0aCkge1xuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0XHRjb25zdCBtaXNzaW5nID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9ICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXNbMF0uaW5kZXg7IGkgPCB0YWlsOyBpKyspIHtcblx0XHRcdFx0XHRtaXNzaW5nLnB1c2goe1xuXHRcdFx0XHRcdFx0aWQ6IHQuaWQsXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcblx0XHRcdFx0XHRcdHg6ICQkLmlzVGltZVNlcmllcygpID8gJCQuZ2V0T3RoZXJUYXJnZXRYKGkpIDogaSxcblx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdHYuaW5kZXggKz0gdGFpbDtcblxuXHRcdFx0XHRcdGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdFx0XHRcdHYueCArPSB0YWlsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dC52YWx1ZXMgPSBtaXNzaW5nLmNvbmNhdCh0LnZhbHVlcyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcblxuXHRcdC8vIGNoZWNrIGRhdGEgY291bnQgYmVjYXVzZSBiZWhhdmlvciBuZWVkcyB0byBjaGFuZ2Ugd2hlbiBpdFwicyBvbmx5IG9uZVxuXHRcdC8vIGNvbnN0IGRhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xuXHRcdGNvbnN0IGJhc2VUYXJnZXQgPSAkJC5kYXRhLnRhcmdldHNbMF07XG5cdFx0Y29uc3QgYmFzZVZhbHVlID0gYmFzZVRhcmdldC52YWx1ZXNbMF07XG5cblx0XHQvLyBVcGRhdGUgbGVuZ3RoIHRvIGZsb3cgaWYgbmVlZGVkXG5cdFx0aWYgKGlzRGVmaW5lZChhcmdzLnRvKSkge1xuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdHRvID0gJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoYXJncy50bykgOiBhcmdzLnRvO1xuXG5cdFx0XHRiYXNlVGFyZ2V0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHR2LnggPCB0byAmJiBsZW5ndGgrKztcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MubGVuZ3RoKSkge1xuXHRcdFx0bGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgb25seSBvbmUgZGF0YSwgdXBkYXRlIHRoZSBkb21haW4gdG8gZmxvdyBmcm9tIGxlZnQgZWRnZSBvZiB0aGUgY2hhcnRcblx0XHRpZiAoIW9yZ0RhdGFDb3VudCkge1xuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdGRpZmYgPSBiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggPiAxID9cblx0XHRcdFx0XHRiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLnggOlxuXHRcdFx0XHRcdGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlmZiA9IDE7XG5cdFx0XHR9XG5cblx0XHRcdGRvbWFpbiA9IFtiYXNlVmFsdWUueCAtIGRpZmYsIGJhc2VWYWx1ZS54XTtcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSAmJiAkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0ZGlmZiA9IChiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLngpIC8gMjtcblx0XHRcdGRvbWFpbiA9IFtuZXcgRGF0ZSgrYmFzZVZhbHVlLnggLSBkaWZmKSwgbmV3IERhdGUoK2Jhc2VWYWx1ZS54ICsgZGlmZildO1xuXHRcdH1cblxuXHRcdGRvbWFpbiAmJiAkJC51cGRhdGVYRG9tYWluKG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCBkb21haW4pO1xuXG5cdFx0Ly8gU2V0IHRhcmdldHNcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHRmbG93OiB7XG5cdFx0XHRcdGluZGV4OiBiYXNlVmFsdWUuaW5kZXgsXG5cdFx0XHRcdGxlbmd0aDogbGVuZ3RoLFxuXHRcdFx0XHRkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcblx0XHRcdFx0ZG9uZTogYXJncy5kb25lLFxuXHRcdFx0XHRvcmdEYXRhQ291bnQ6IG9yZ0RhdGFDb3VudCxcblx0XHRcdH0sXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb246IG9yZ0RhdGFDb3VudCA+IDEsXG5cdFx0XHR3aXRoVHJpbVhEb21haW46IGZhbHNlLFxuXHRcdFx0d2l0aFVwZGF0ZVhBeGlzOiB0cnVlXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEdlbmVyYXRlIGZsb3dcblx0ICogQG1lbWJlcm9mIENoYXJ0SW50ZXJuYWxcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3Ncblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqL1xuXHRnZW5lcmF0ZUZsb3coYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCB0YXJnZXRzID0gYXJncy50YXJnZXRzO1xuXHRcdFx0Y29uc3QgZmxvdyA9IGFyZ3MuZmxvdztcblxuXHRcdFx0Y29uc3Qge2JhcjogZHJhd0JhciwgbGluZTogZHJhd0xpbmUsIGFyZWE6IGRyYXdBcmVhfSA9IGFyZ3Muc2hhcGUudHlwZTtcblx0XHRcdGNvbnN0IHtjeCwgY3ksIHhGb3JUZXh0LCB5Rm9yVGV4dH0gPSBhcmdzLnNoYXBlLnBvcztcblx0XHRcdGNvbnN0IHh2ID0gYXJncy54djtcblx0XHRcdGNvbnN0IGR1cmF0aW9uID0gYXJncy5kdXJhdGlvbjtcblxuXHRcdFx0bGV0IHRyYW5zbGF0ZVg7XG5cdFx0XHRsZXQgc2NhbGVYID0gMTtcblx0XHRcdGNvbnN0IGZsb3dJbmRleCA9IGZsb3cuaW5kZXg7XG5cdFx0XHRjb25zdCBmbG93TGVuZ3RoID0gZmxvdy5sZW5ndGg7XG5cdFx0XHRsZXQgZmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsIGZsb3dJbmRleCk7XG5cdFx0XHRsZXQgZmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCBmbG93SW5kZXggKyBmbG93TGVuZ3RoKTtcblx0XHRcdGNvbnN0IG9yZ0RvbWFpbiA9ICQkLnguZG9tYWluKCk7XG5cdFx0XHRjb25zdCBkdXJhdGlvbkZvckZsb3cgPSBmbG93LmR1cmF0aW9uIHx8IGR1cmF0aW9uO1xuXHRcdFx0Y29uc3QgZG9uZSA9IGZsb3cuZG9uZSB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdFx0Y29uc3Qgd2FpdCA9ICQkLmdlbmVyYXRlV2FpdCgpO1xuXG5cdFx0XHRjb25zdCB4Z3JpZCA9ICQkLnhncmlkIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IHhncmlkTGluZXMgPSAkJC54Z3JpZExpbmVzIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5SZWdpb24gPSAkJC5tYWluUmVnaW9uIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5UZXh0ID0gJCQubWFpblRleHQgfHwgZDNTZWxlY3RBbGwoW10pO1xuXHRcdFx0Y29uc3QgbWFpbkJhciA9ICQkLm1haW5CYXIgfHwgZDNTZWxlY3RBbGwoW10pO1xuXHRcdFx0Y29uc3QgbWFpbkxpbmUgPSAkJC5tYWluTGluZSB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluQXJlYSA9ICQkLm1haW5BcmVhIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5DaXJjbGUgPSAkJC5tYWluQ2lyY2xlIHx8IGQzU2VsZWN0QWxsKFtdKTtcblxuXHRcdFx0Ly8gc2V0IGZsYWdcblx0XHRcdCQkLmZsb3dpbmcgPSB0cnVlO1xuXG5cdFx0XHQvLyByZW1vdmUgaGVhZCBkYXRhIGFmdGVyIHJlbmRlcmVkXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcblx0XHRcdFx0ZC52YWx1ZXMuc3BsaWNlKDAsIGZsb3dMZW5ndGgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHVwZGF0ZSB4IGRvbWFpbiB0byBnZW5lcmF0ZSBheGlzIGVsZW1lbnRzIGZvciBmbG93XG5cdFx0XHRjb25zdCBkb21haW4gPSAkJC51cGRhdGVYRG9tYWluKHRhcmdldHMsIHRydWUsIHRydWUpO1xuXG5cdFx0XHQvLyB1cGRhdGUgZWxlbWVudHMgcmVsYXRlZCB0byB4IHNjYWxlXG5cdFx0XHRpZiAoJCQudXBkYXRlWEdyaWQpIHsgJCQudXBkYXRlWEdyaWQodHJ1ZSk7IH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdHJhbnNmb3JtIHRvIGZsb3dcblx0XHRcdGlmICghZmxvdy5vcmdEYXRhQ291bnQpIHsgLy8gaWYgZW1wdHlcblx0XHRcdFx0aWYgKCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMubGVuZ3RoICE9PSAxKSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9ICQkLngob3JnRG9tYWluWzBdKSAtICQkLngoZG9tYWluWzBdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdFx0XHRcdGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCAwKTtcblx0XHRcdFx0XHRcdGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAkJC54KGZsb3dTdGFydC54KSAtICQkLngoZmxvd0VuZC54KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJhbnNsYXRlWCA9IGRpZmZEb21haW4oZG9tYWluKSAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGZsb3cub3JnRGF0YUNvdW50ID09PSAxIHx8IChmbG93U3RhcnQgJiYgZmxvd1N0YXJ0LngpID09PSAoZmxvd0VuZCAmJiBmbG93RW5kLngpKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZVggPSAkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0gKCQkLngob3JnRG9tYWluWzBdKSAtICQkLngoZG9tYWluWzBdKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9ICgkJC54KGZsb3dTdGFydC54KSAtICQkLngoZmxvd0VuZC54KSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c2NhbGVYID0gKGRpZmZEb21haW4ob3JnRG9tYWluKSAvIGRpZmZEb21haW4oZG9tYWluKSk7XG5cdFx0XHRjb25zdCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sMCkgc2NhbGUoJHtzY2FsZVh9LDEpYDtcblxuXHRcdFx0JCQuaGlkZVhHcmlkRm9jdXMoKTtcblxuXHRcdFx0Y29uc3QgZ3QgPSBkM1RyYW5zaXRpb24oKS5lYXNlKGQzRWFzZUxpbmVhcilcblx0XHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRmxvdyk7XG5cblx0XHRcdHdhaXQuYWRkKFtcblx0XHRcdFx0JCQuYXhlcy54XG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmNhbGwoZyA9PiAkJC54QXhpcy5zZXRUcmFuc2l0aW9uKGd0KS5jcmVhdGUoZykpLFxuXG5cdFx0XHRcdG1haW5CYXJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5MaW5lXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHRtYWluQXJlYVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXG5cblx0XHRcdFx0bWFpbkNpcmNsZVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXG5cblx0XHRcdFx0bWFpblRleHRcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5SZWdpb25cblx0XHRcdFx0XHQuZmlsdGVyKCQkLmlzUmVnaW9uT25YKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXG5cblx0XHRcdFx0eGdyaWRcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdHhncmlkTGluZXNcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXHRcdFx0XSk7XG5cblx0XHRcdGd0LmNhbGwod2FpdCwgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBmbG93ZWQgZWxlbWVudHNcblx0XHRcdFx0aWYgKGZsb3dMZW5ndGgpIHtcblx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSB7XG5cdFx0XHRcdFx0XHRzaGFwZXM6IFtdLFxuXHRcdFx0XHRcdFx0dGV4dHM6IFtdLFxuXHRcdFx0XHRcdFx0ZXZlbnRSZWN0czogW11cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRhcmdldC5zaGFwZXMucHVzaChgLiR7Q0xBU1Muc2hhcGV9LSR7aX1gKTtcblx0XHRcdFx0XHRcdHRhcmdldC50ZXh0cy5wdXNoKGAuJHtDTEFTUy50ZXh0fS0ke2l9YCk7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZXZlbnRSZWN0cy5wdXNoKGAuJHtDTEFTUy5ldmVudFJlY3R9LSR7aX1gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRbXCJzaGFwZXNcIiwgXCJ0ZXh0c1wiLCBcImV2ZW50UmVjdHNcIl0uZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTW3ZdfWApXG5cdFx0XHRcdFx0XHRcdC5zZWxlY3RBbGwodGFyZ2V0W3ZdKVxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQkJC5zdmcuc2VsZWN0KGAuJHtDTEFTUy54Z3JpZH1gKVxuXHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZHJhdyBhZ2FpbiBmb3IgcmVtb3ZpbmcgZmxvd2VkIGVsZW1lbnRzIGFuZCByZXZlcnRpbmcgYXR0clxuXHRcdFx0XHR4Z3JpZC5zaXplKCkgJiYgeGdyaWRcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxuXHRcdFx0XHRcdC5hdHRyKCQkLnhncmlkQXR0cik7XG5cblx0XHRcdFx0eGdyaWRMaW5lc1xuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xuXG5cdFx0XHRcdHhncmlkTGluZXMuc2VsZWN0KFwibGluZVwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiB4dik7XG5cblx0XHRcdFx0eGdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIGlzUm90YXRlZCA/ICQkLndpZHRoIDogMClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeHYpO1xuXG5cdFx0XHRcdG1haW5CYXJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QmFyKTtcblxuXHRcdFx0XHRtYWluTGluZVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lKTtcblxuXHRcdFx0XHRtYWluQXJlYVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhKTtcblxuXHRcdFx0XHRtYWluQ2lyY2xlXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cblx0XHRcdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xuXHRcdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCB4RnVuYyA9IGQgPT4gY3goZCkgLSBjb25maWcucG9pbnRfcjtcblx0XHRcdFx0XHRjb25zdCB5RnVuYyA9IGQgPT4gY3koZCkgLSBjb25maWcucG9pbnRfcjtcblxuXHRcdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHRcdC5hdHRyKFwieFwiLCB4RnVuYylcblx0XHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5RnVuYylcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpIC8vIHdoZW4gcGF0dGVybiBpcyB1c2VkLCBpdCBwb3NzaWJseSBjb250YWluICdjaXJjbGUnIGFsc28uXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1haW5UZXh0XG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeEZvclRleHQpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KVxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAkJC5vcGFjaXR5Rm9yVGV4dC5iaW5kKCQkKSk7XG5cblx0XHRcdFx0bWFpblJlZ2lvblxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xuXG5cdFx0XHRcdG1haW5SZWdpb24uc2VsZWN0KFwicmVjdFwiKS5maWx0ZXIoJCQuaXNSZWdpb25PblgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSk7XG5cblx0XHRcdFx0Y29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgJCQucmVkcmF3RXZlbnRSZWN0KCk7XG5cblx0XHRcdFx0Ly8gY2FsbGJhY2sgZm9yIGVuZCBvZiBmbG93XG5cdFx0XHRcdGRvbmUoKTtcblxuXHRcdFx0XHQkJC5mbG93aW5nID0gZmFsc2U7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtpc0RlZmluZWQsIGV4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEdldCBzZWxlY3RlZCBkYXRhIHBvaW50cy48YnI+PGJyPlxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBnZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMgaW5mb3JtYXRpb24uIFRvIHVzZSB0aGlzIEFQSSwgZGF0YS5zZWxlY3Rpb24uZW5hYmxlZCBuZWVkcyB0byBiZSBzZXQgdHJ1ZS5cblx0ICogQG1ldGhvZCBzZWxlY3RlZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGFyZ2V0SWRdIFlvdSBjYW4gZmlsdGVyIHRoZSByZXN1bHQgYnkgZ2l2aW5nIHRhcmdldCBpZCB0aGF0IHlvdSB3YW50IHRvIGdldC4gSWYgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSBwb2ludHMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7QXJyYXl9IGRhdGFQb2ludCBBcnJheSBvZiB0aGUgZGF0YSBwb2ludHMuPGJyPmV4LikgYFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLl1gXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBhbGwgc2VsZWN0ZWQgZGF0YSBwb2ludHMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogIGNoYXJ0LnNlbGVjdGVkKCk7XG5cdCAqICAvLyAtLT4gZXguKSBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi4gXVxuXHQgKlxuXHQgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIG9mIGRhdGExIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqICBjaGFydC5zZWxlY3RlZChcImRhdGExXCIpO1xuXHQgKi9cblx0c2VsZWN0ZWQodGFyZ2V0SWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgZGF0YVBvaW50ID0gW107XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGQgPT4gZGF0YVBvaW50LnB1c2goZCkpO1xuXG5cdFx0cmV0dXJuIGRhdGFQb2ludDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHNlbGVjdGVkLiAoYFtkYXRhLnNlbGVjdGlvbi5lbmFibGVkXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRzZWxlY3Rpb24lMjVFMiUyNTgwJTI1QTRlbmFibGVkKSBvcHRpb24gc2hvdWxkIGJlIHNldCB0cnVlIHRvIHVzZSB0aGlzIG1ldGhvZClgXG5cdCAqIEBtZXRob2Qgc2VsZWN0XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGdldCBzZWxlY3RlZC5cblx0ICogQHBhcmFtIHtBcnJheX0gW2luZGljZXNdIFRoZSBpbmRleCBhcnJheSBvZiBkYXRhIHBvaW50cy4gSWYgZmFsc3kgdmFsdWUgZ2l2ZW4sIHdpbGwgc2VsZWN0IGFsbCBkYXRhIHBvaW50cy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVzZXRPdGhlcl0gVW5zZWxlY3QgYWxyZWFkeSBzZWxlY3RlZC5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIHNlbGVjdCBhbGwgZGF0YSBwb2ludHNcblx0ICogIGNoYXJ0LnNlbGVjdCgpO1xuXHQgKlxuXHQgKiAgLy8gc2VsZWN0IGFsbCBmcm9tICdkYXRhMidcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGEyXCIpO1xuXHQgKlxuXHQgKiAgLy8gc2VsZWN0IGFsbCBmcm9tICdkYXRhMScgYW5kICdkYXRhMidcblx0ICogIGNoYXJ0LnNlbGVjdChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogIC8vIHNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMiBhbmQgdW5zZWxlY3Qgb3RoZXJzIHNlbGVjdGVkXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMl0sIHRydWUpO1xuXHQgKlxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAwLCAzIGFuZCA1XG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMCwgMywgNV0pO1xuXHQgKi9cblx0c2VsZWN0KGlkcywgaW5kaWNlcywgcmVzZXRPdGhlcikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0Y29uc3QgaWQgPSBkLmRhdGEgPyBkLmRhdGEuaWQgOiBkLmlkO1xuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAhaWRzIHx8IGlkcy5pbmRleE9mKGlkKSA+PSAwO1xuXHRcdFx0XHRjb25zdCBpc1RhcmdldEluZGV4ID0gIWluZGljZXMgfHwgaW5kaWNlcy5pbmRleE9mKGkpID49IDA7XG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcblxuXHRcdFx0XHQvLyBsaW5lL2FyZWEgc2VsZWN0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0XG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgJiYgIWlzU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdHRvZ2dsZSh0cnVlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCB0cnVlKSwgZCwgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyICYmIGlzU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgdW4tc2VsZWN0ZWQuXG5cdCAqIEBtZXRob2QgdW5zZWxlY3Rcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gYmUgdW5zZWxlY3RlZC5cblx0ICogQHBhcmFtIHtBcnJheX0gW2luZGljZXNdIFRoZSBpbmRleCBhcnJheSBvZiBkYXRhIHBvaW50cy4gSWYgZmFsc3kgdmFsdWUgZ2l2ZW4sIHdpbGwgc2VsZWN0IGFsbCBkYXRhIHBvaW50cy5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xuXHQgKiAgY2hhcnQudW5zZWxlY3QoKTtcblx0ICpcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBmcm9tICdkYXRhMSdcblx0ICogIGNoYXJ0LnVuc2VsZWN0KFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqICAvLyB1bnNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMlxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiLCBbMl0pO1xuXHQgKi9cblx0dW5zZWxlY3QoaWRzLCBpbmRpY2VzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XG5cdFx0XHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKTtcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MubGluZSkgfHwgc2hhcGUuY2xhc3NlZChDTEFTUy5hcmVhKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXggJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSAmJiBpc1NlbGVjdGVkKSB7XG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgdHlwZSBvZiB0aGUgY2hhcnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zRm9yUmVkcmF3XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvKHRhcmdldElkcywgdHlwZSwgb3B0aW9uc0ZvclJlZHJhdykge1xuXHRjb25zdCAkJCA9IHRoaXM7XG5cdGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zRm9yUmVkcmF3IHx8IHt3aXRoVHJhbnNpdGlvbkZvckF4aXM6ICEkJC5oYXNBcmNUeXBlKCl9O1xuXG5cdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBmYWxzZTtcblx0JCQudHJhbnNpdGluZyA9IGZhbHNlO1xuXG5cdCQkLnNldFRhcmdldFR5cGUodGFyZ2V0SWRzLCB0eXBlKTtcblx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpOyAvLyB0aGlzIGlzIG5lZWRlZCB3aGVuIHRyYW5zZm9ybWluZyB0byBhcmNcblx0JCQudXBkYXRlQW5kUmVkcmF3KG9wdGlvbnMpO1xufVxuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIHRyYW5zZm9ybVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFNwZWNpZnkgdGhlIHR5cGUgdG8gYmUgdHJhbnNmb3JtZWQuIFRoZSB0eXBlcyBsaXN0ZWQgaW4gZGF0YS50eXBlIGNhbiBiZSB1c2VkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIFNwZWNpZnkgdGFyZ2V0cyB0byBiZSB0cmFuc2Zvcm1lZC4gSWYgbm90IGdpdmVuLCBhbGwgdGFyZ2V0cyB3aWxsIGJlIHRoZSBjYW5kaWRhdGUuXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGJhciBjaGFydC5cblx0ICogIGNoYXJ0LnRyYW5zZm9ybShcImJhclwiKTtcblx0ICpcblx0ICogIC8vIG9ubHkgZGF0YTEgd2lsbCBiZSBiYXIgY2hhcnQuXG5cdCAqICBjaGFydC50cmFuc2Zvcm0oXCJiYXJcIiwgXCJkYXRhMVwiKTtcblx0ICpcblx0ICogIC8vIG9ubHkgZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgYmFyIGNoYXJ0LlxuXHQgKiAgY2hhcnQudHJhbnNmb3JtKFwiYmFyXCIsIFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKi9cblx0dHJhbnNmb3JtKHR5cGUsIHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBvcHRpb25zID0gW1wicGllXCIsIFwiZG9udXRcIl1cblx0XHRcdC5pbmRleE9mKHR5cGUpID49IDAgPyB7d2l0aFRyYW5zZm9ybTogdHJ1ZX0gOiBudWxsO1xuXG5cdFx0dHJhbnNmb3JtVG8uYmluZCgkJCkodGFyZ2V0SWRzLCB0eXBlLCBvcHRpb25zKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtpc1VuZGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogVXBkYXRlIGdyb3VwcyBmb3IgdGhlIHRhcmdldHMuXG5cdCAqIEBtZXRob2QgZ3JvdXBzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIFRoaXMgYXJndW1lbnQgbmVlZHMgdG8gYmUgYW4gQXJyYXkgdGhhdCBpbmNsdWRlcyBvbmUgb3IgbW9yZSBBcnJheSB0aGF0IGluY2x1ZGVzIHRhcmdldCBpZHMgdG8gYmUgZ3JvdXBlZC5cblx0ICogQHJldHVybiB7QXJyYXl9IEdyb3VwZWQgZGF0YSBuYW1lcyBhcnJheVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgYSBuZXcgZ3JvdXAuXG5cdCAqICBjaGFydC5ncm91cHMoW1xuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxuXHQgKiAgXSk7XG5cdCAqL1xuXHRncm91cHMoZ3JvdXBzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmIChpc1VuZGVmaW5lZChncm91cHMpKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLmRhdGFfZ3JvdXBzO1xuXHRcdH1cblxuXHRcdGNvbmZpZy5kYXRhX2dyb3VwcyA9IGdyb3Vwcztcblx0XHQkJC5yZWRyYXcoKTtcblxuXHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBVcGRhdGUgeCBncmlkIGxpbmVzLlxuICogQG1ldGhvZCB4Z3JpZHNcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIENoYXJ0XG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBYIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMuXG4gKiBAZXhhbXBsZVxuICogIC8vIFNob3cgMiB4IGdyaWQgbGluZXNcbiAqIGNoYXJ0LnhncmlkcyhbXG4gKiAgICB7dmFsdWU6IDEsIHRleHQ6IFwiTGFiZWwgMVwifSxcbiAqICAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XG4gKiBdKTtcbiAqL1xuY29uc3QgeGdyaWRzID0gZnVuY3Rpb24oZ3JpZHMpIHtcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0aWYgKCFncmlkcykge1xuXHRcdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xuXHR9XG5cblx0Y29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzO1xuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xuXG5cdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xufTtcblxuZXh0ZW5kKHhncmlkcywge1xuXHQvKipcblx0ICogQWRkIHggZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHggZ3JpZCBsaW5lcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHhncmlkcy5cblx0ICogQG1ldGhvZCB4Z3JpZHPigKRhZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZ3JpZHMgTmV3IHggZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxuXHQgKiBjaGFydC54Z3JpZHMuYWRkKFxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XG5cdCAqICk7XG5cdCAqXG5cdCAqIC8vIEFkZCBuZXcgeCBncmlkIGxpbmVzXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoW1xuXHQgKiAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCAyXCJ9LFxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XG5cdCAqIF0pO1xuXHQgKi9cblx0YWRkOiBmdW5jdGlvbihncmlkcykge1xuXHRcdHJldHVybiB0aGlzLnhncmlkcyhcblx0XHRcdHRoaXMuaW50ZXJuYWwuY29uZmlnLmdyaWRfeF9saW5lc1xuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSB4IGdyaWQgbGluZXMuPGJyPlxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cblx0ICogQG1ldGhvZCB4Z3JpZHPigKRyZW1vdmVcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeCB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeCBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHggZ3JpZCBsaW5lIG9uIHggPSAyIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHt2YWx1ZTogMn0pO1xuXHQgKlxuXHQgKiAvLyB4IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKHtcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxuXHQgKiB9KTtcblx0ICpcblx0ICogLy8gYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSgpO1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXMpIHsgLy8gVE9ETzogbXVsdGlwbGVcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIHRydWUpO1xuXHR9XG59KTtcblxuXG4vKipcbiAqIFVwZGF0ZSB5IGdyaWQgbGluZXMuXG4gKiBAbWV0aG9kIHlncmlkc1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueS5saW5lcy5cbiAqIEBleGFtcGxlXG4gKiAgLy8gU2hvdyAyIHkgZ3JpZCBsaW5lc1xuICogY2hhcnQueWdyaWRzKFtcbiAqICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXG4gKiAgICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XG4gKiBdKTtcbiAqL1xuY29uc3QgeWdyaWRzID0gZnVuY3Rpb24oZ3JpZHMpIHtcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0aWYgKCFncmlkcykge1xuXHRcdHJldHVybiBjb25maWcuZ3JpZF95X2xpbmVzO1xuXHR9XG5cblx0Y29uZmlnLmdyaWRfeV9saW5lcyA9IGdyaWRzO1xuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xuXG5cdHJldHVybiBjb25maWcuZ3JpZF95X2xpbmVzO1xufTtcblxuZXh0ZW5kKHlncmlkcywge1xuXHQvKipcblx0ICogQWRkIHkgZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHkgZ3JpZCBsaW5lcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHlncmlkcy5cblx0ICogQG1ldGhvZCB5Z3JpZHPigKRhZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZ3JpZHMgTmV3IHkgZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogKTtcblx0ICpcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcblx0ICogY2hhcnQueWdyaWRzLmFkZChbXG5cdCAqICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgMlwifSxcblx0ICogICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XG5cdCAqIF0pO1xuXHQgKi9cblx0YWRkOiBmdW5jdGlvbihncmlkcykge1xuXHRcdHJldHVybiB0aGlzLnlncmlkcyhcblx0XHRcdHRoaXMuaW50ZXJuYWwuY29uZmlnLmdyaWRfeV9saW5lc1xuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSB5IGdyaWQgbGluZXMuPGJyPlxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cblx0ICogQG1ldGhvZCB5Z3JpZHPigKRyZW1vdmVcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeSB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHkgZ3JpZCBsaW5lIG9uIHkgPSAyMDAgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoe3ZhbHVlOiAyMDB9KTtcblx0ICpcblx0ICogLy8geSBncmlkIGxpbmVzIHRoYXQgaGF2ZSAnZ3JpZC1BJyB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7XG5cdCAqICAgY2xhc3M6IFwiZ3JpZC1BXCJcblx0ICogfSk7XG5cdCAqXG5cdCAqIC8vIGFsbCBvZiB5IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoKTtcblx0ICovXG5cdHJlbW92ZTogZnVuY3Rpb24ocGFyYW1zKSB7IC8vIFRPRE86IG11bHRpcGxlXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmYWxzZSk7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdHhncmlkcyxcblx0eWdyaWRzXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2dldE9wdGlvbiwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBVcGRhdGUgcmVnaW9ucy5cbiAqIEBtZXRob2QgcmVnaW9uc1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZ2lvbnMgUmVnaW9ucyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIHJlZ2lvbnMuXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xuICogQGV4YW1wbGVcbiAqIC8vIFNob3cgMiByZWdpb25zXG4gKiBjaGFydC5yZWdpb25zKFtcbiAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXG4gKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cbiAqIF0pO1xuICovXG5jb25zdCByZWdpb25zID0gZnVuY3Rpb24ocmVnaW9ucykge1xuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRpZiAoIXJlZ2lvbnMpIHtcblx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XG5cdH1cblxuXHRjb25maWcucmVnaW9ucyA9IHJlZ2lvbnM7XG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0cmV0dXJuIHJlZ2lvbnM7XG59O1xuXG5leHRlbmQocmVnaW9ucywge1xuXHQvKipcblx0ICogQWRkIG5ldyByZWdpb24uPGJyPjxicj5cblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgcmVnaW9uIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgcmVnaW9ucy5cblx0ICogQG1ldGhvZCByZWdpb25z4oCkYWRkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHJlZ2lvbnMgTmV3IHJlZ2lvbiB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSByZWdpb24gd2lsbCBiZSBhZGRlZC5cblx0ICogQHJldHVybiB7QXJyYXl9IHJlZ2lvbnNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gQWRkIGEgbmV3IHJlZ2lvblxuXHQgKiBjaGFydC5yZWdpb25zLmFkZChcblx0ICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifVxuXHQgKiApO1xuXHQgKlxuXHQgKiAvLyBBZGQgbmV3IHJlZ2lvbnNcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoW1xuXHQgKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9LFxuXHQgKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cblx0ICpdKTtcblx0ICovXG5cdGFkZDogZnVuY3Rpb24ocmVnaW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIXJlZ2lvbnMpIHtcblx0XHRcdHJldHVybiBjb25maWcucmVnaW9ucztcblx0XHR9XG5cblx0XHRjb25maWcucmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zLmNvbmNhdChyZWdpb25zKTtcblx0XHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgcmVnaW9ucy48YnI+PGJyPlxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHJlZ2lvbnMuXG5cdCAqIEBtZXRob2QgcmVnaW9uc+KApHJlbW92ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZWdpb25zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgY2xhc3Nlcy4gSWYgY2xhc3NlcyBpcyBnaXZlbiwgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIG9uZSBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzZXMgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHJlZ2lvbnMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9ucyBSZW1vdmVkIHJlZ2lvbnNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gcmVnaW9ucyB0aGF0IGhhdmUgJ3JlZ2lvbi1BJyBvciAncmVnaW9uLUInIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogY2hhcnQucmVnaW9ucy5yZW1vdmUoe1xuXHQgKiAgIGNsYXNzZXM6IFtcblx0ICogICAgIFwicmVnaW9uLUFcIiwgXCJyZWdpb24tQlwiXG5cdCAqICAgXVxuXHQgKiB9KTtcblx0ICpcblx0ICogLy8gYWxsIG9mIHJlZ2lvbnMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSgpO1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbihvcHRpb25zVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNWYWx1ZSB8fCB7fTtcblx0XHRjb25zdCBkdXJhdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcImR1cmF0aW9uXCIsIGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKTtcblx0XHRjb25zdCBjbGFzc2VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2xhc3Nlc1wiLCBbQ0xBU1MucmVnaW9uXSk7XG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MucmVnaW9uc31gKVxuXHRcdFx0LnNlbGVjdEFsbChjbGFzc2VzLm1hcChjID0+IGAuJHtjfWApKTtcblxuXHRcdChkdXJhdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IHJlZ2lvbnMpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0cmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zO1xuXG5cdFx0aWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuXHRcdFx0cmVnaW9ucyA9IHJlZ2lvbnMuZmlsdGVyKHJlZ2lvbiA9PiB7XG5cdFx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICghcmVnaW9uLmNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZWdpb24uY2xhc3Muc3BsaXQoXCIgXCIpLmZvckVhY2goYyA9PiB7XG5cdFx0XHRcdFx0aWYgKGNsYXNzZXMuaW5kZXhPZihjKSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gIWZvdW5kO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVnaW9ucztcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtyZWdpb25zfSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmQsIGlzVW5kZWZpbmVkLCBpc0FycmF5fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBHZXQgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuICogQG1ldGhvZCBkYXRhXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSByZXR1cm5zIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGRhdGEuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xuICogQGV4YW1wbGVcbiAqIC8vIEdldCBvbmx5IGRhdGExIGRhdGFcbiAqIGNoYXJ0LmRhdGEoXCJkYXRhMVwiKTtcbiAqIC8vIC0tPiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IEFycmF5KDYpfSwgLi4uXVxuICpcbiAqIC8vIEdldCBkYXRhMSBhbmQgZGF0YTIgZGF0YVxuICogY2hhcnQuZGF0YShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcbiAqXG4gKiAvLyBHZXQgYWxsIGRhdGFcbiAqIGNoYXJ0LmRhdGEoKTtcbiAqL1xuY29uc3QgZGF0YSA9IGZ1bmN0aW9uKHRhcmdldElkcykge1xuXHRjb25zdCB0YXJnZXRzID0gdGhpcy5pbnRlcm5hbC5kYXRhLnRhcmdldHM7XG5cblx0aWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRJZHMpKSB7XG5cdFx0Y29uc3QgaWRzID0gaXNBcnJheSh0YXJnZXRJZHMpID8gdGFyZ2V0SWRzIDogW3RhcmdldElkc107XG5cblx0XHRyZXR1cm4gdGFyZ2V0cy5maWx0ZXIodCA9PiBpZHMuc29tZSh2ID0+IHYgPT09IHQuaWQpKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXRzO1xufTtcblxuZXh0ZW5kKGRhdGEsIHtcblx0LyoqXG5cdCAqIEdldCBkYXRhIHNob3duIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkc2hvd25cblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIGZpbHRlcnMgdGhlIGRhdGEgd2l0aCBzcGVjaWZpZWQgdGFyZ2V0IGlkcy4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBzaG93biBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IHNob3duIGRhdGEgYnkgZmlsdGVyaW5nIHRvIGluY2x1ZGUgb25seSBkYXRhMSBkYXRhXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oXCJkYXRhMVwiKTtcblx0ICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXG5cdCAqXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIGRhdGExIGFuZCBkYXRhMiBkYXRhXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIEdldCBhbGwgc2hvd24gZGF0YVxuXHQgKiBjaGFydC5kYXRhLnNob3duKCk7XG5cdCAqL1xuXHRzaG93bjogZnVuY3Rpb24odGFyZ2V0SWRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZmlsdGVyVGFyZ2V0c1RvU2hvdyh0aGlzLmRhdGEodGFyZ2V0SWRzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB2YWx1ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkdmFsdWVzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBUaGlzIEFQSSByZXR1cm5zIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHRhcmdldC4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIG51bGwgd2lsbCBiZSByZXRydW5lZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSB2YWx1ZXNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGRhdGExIHZhbHVlc1xuXHQgKiBjaGFydC5kYXRhLnZhbHVlcyhcImRhdGExXCIpO1xuXHQgKiAvLyAtLT4gWzEwLCAyMCwgMzAsIDQwXVxuXHQgKi9cblx0dmFsdWVzOiBmdW5jdGlvbih0YXJnZXRJZCwgZmxhdCA9IHRydWUpIHtcblx0XHRsZXQgdmFsdWVzID0gbnVsbDtcblxuXHRcdGlmICh0YXJnZXRJZCkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IHRoaXMuZGF0YSh0YXJnZXRJZCk7XG5cblx0XHRcdGlmICh0YXJnZXRzICYmIGlzQXJyYXkodGFyZ2V0cykpIHtcblx0XHRcdFx0dmFsdWVzID0gW107XG5cblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGFWYWx1ZSA9IHYudmFsdWVzLm1hcChkID0+IGQudmFsdWUpO1xuXG5cdFx0XHRcdFx0ZmxhdCA/ICh2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGRhdGFWYWx1ZSkpIDogdmFsdWVzLnB1c2goZGF0YVZhbHVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgbmFtZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkbmFtZXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbmFtZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG5hbWVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IG5hbWVzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgbmFtZXMgYWNjb3JkaW5nIGl0cyBrZXkgdmFsdWUsIGlmIHNwZWNpZmllZCBuYW1lcyB2YWx1ZXMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldCBjdXJyZW50IG5hbWVzXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoKTtcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ0ZXN0MVwiLCBkYXRhMjogXCJ0ZXN0MlwifVxuXHQgKlxuXHQgKiAvLyBVcGRhdGUgbmFtZXNcblx0ICogY2hhcnQuZGF0YS5uYW1lcyh7XG5cdCAqICBkYXRhMTogXCJOZXcgTmFtZSAxXCIsXG5cdCAqICBkYXRhMjogXCJOZXcgTmFtZSAyXCJcblx0ICp9KTtcblx0ICovXG5cdG5hbWVzOiBmdW5jdGlvbihuYW1lcykge1xuXHRcdHRoaXMuaW50ZXJuYWwuY2xlYXJMZWdlbmRJdGVtVGV4dEJveENhY2hlKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcIm5hbWVzXCIsIG5hbWVzKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgY29sb3JzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgZGF0YeKApGNvbG9yc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbG9ycyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBjb2xvcnMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIFtkYXRhLmNvbG9yc10oLi9PcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRjb2xvcnMpLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgZGF0YSBjb2xvciB2YWx1ZSBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZS5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgY29sb3JzXG5cdCAqIGNoYXJ0LmRhdGEuY29sb3JzKCk7XG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwiIzAwYzczY1wiLCBkYXRhMjogXCIjZmE3MTcxXCJ9XG5cdCAqXG5cdCAqIC8vIFVwZGF0ZSBjb2xvcnNcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoe1xuXHQgKiAgZGF0YTE6IFwiI0ZGRkZGRlwiLFxuXHQgKiAgZGF0YTI6IFwiIzAwMDAwMFwiXG5cdCAqIH0pO1xuXHQgKi9cblx0Y29sb3JzOiBmdW5jdGlvbihjb2xvcnMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcImNvbG9yc1wiLCBjb2xvcnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgZGF0YeKApGF4ZXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXhlcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgYXhlcyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBheGVzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgYXhlcyB2YWx1ZSBmb3IgZGF0YSwgaWYgc3BlY2lmaWVkIGF4ZXMgdmFsdWUuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldCBjdXJyZW50IGF4ZXNcblx0ICogY2hhcnQuZGF0YS5heGVzKCk7XG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwieVwifVxuXHQgKlxuXHQgKiAvLyBVcGRhdGUgYXhlc1xuXHQgKiBjaGFydC5kYXRhLmF4ZXMoe1xuXHQgKiAgZGF0YTE6IFwieVwiLFxuXHQgKiAgZGF0YTI6IFwieTJcIlxuXHQgKiB9KTtcblx0ICovXG5cdGF4ZXM6IGZ1bmN0aW9uKGF4ZXMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcImF4ZXNcIiwgYXhlcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbWluaW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxuXHQgKiBAbWV0aG9kIGRhdGHigKRtaW5cblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldCBjdXJyZW50IGF4ZXNcblx0ICogY2hhcnQuZGF0YS5taW4oKTtcblx0ICogLy8gLS0+IFt7eDogMCwgdmFsdWU6IDMwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMH0sIC4uLl1cblx0ICovXG5cdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1pbjtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBtYXhpbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XG5cdCAqIEBtZXRob2QgZGF0YeKApG1heFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuXHQgKiBjaGFydC5kYXRhLm1heCgpO1xuXHQgKiAvLyAtLT4gW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLl1cblx0ICovXG5cdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1heDtcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtkYXRhfSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBTZXQgc3BlY2lmaWVkIGNhdGVnb3J5IG5hbWUgb24gY2F0ZWdvcnkgYXhpcy5cblx0ICogQG1ldGhvZCBjYXRlZ29yeVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpIGluZGV4IG9mIGNhdGVnb3J5IHRvIGJlIGNoYW5nZWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5IHZhbHVlIHRvIGJlIGNoYW5nZWRcblx0ICogQGV4YW1wbGVcblx0ICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xuXHQgKi9cblx0Y2F0ZWdvcnkoaSwgY2F0ZWdvcnkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gPSBjYXRlZ29yeTtcblx0XHRcdCQkLnJlZHJhdygpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxuXHQgKiBAbWV0aG9kIGNhdGVnb3JpZXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjYXRlZ29yaWVzIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGNhdGVnb3J5IG5hbWVzIGluIHN0cmluZy4gSWYgY2F0ZWdvcnkgbmFtZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBkYXRlIGJ5IGRhdGEueCBvcHRpb24sIHRoaXMgaXMgbm90IHJlcXVpcmVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5jYXRlZ29yaWVzKFtcblx0ICogICAgICBcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLlxuXHQgKiBdKTtcblx0ICovXG5cdGNhdGVnb3JpZXMoY2F0ZWdvcmllcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcblx0XHQkJC5yZWRyYXcoKTtcblxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IHRoZSBjb2xvclxuXHQgKiBAbWV0aG9kIGNvbG9yXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIGlkIHRvIGdldCB0aGUgY29sb3Jcblx0ICogQGV4YW1wbGVcblx0ICogY2hhcnQuY29sb3IoXCJkYXRhMVwiKTtcblx0ICovXG5cdGNvbG9yKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIGV4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgeFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IHggSWYgeCBpcyBnaXZlbiwgeCB2YWx1ZXMgb2YgZXZlcnkgdGFyZ2V0IHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXG5cdCAqICBjaGFydC54KCk7XG5cdCAqXG5cdCAqICAvLyBVcGRhdGUgeCB2YWx1ZXMgZm9yIGFsbCB0YXJnZXRzXG5cdCAqICBjaGFydC54KFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl0pO1xuXHQgKi9cblx0eCh4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSAkJC5pc0N1c3RvbVgoKSAmJiAkJC5pc0NhdGVnb3JpemVkKCk7XG5cblx0XHRpZiAoaXNBcnJheSh4KSkge1xuXHRcdFx0aWYgKGlzQ2F0ZWdvcml6ZWQpIHtcblx0XHRcdFx0JCQuYXBpLmNhdGVnb3JpZXMoeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRYKCQkLmRhdGEudGFyZ2V0cywgeCk7XG5cblx0XHRcdFx0JCQucmVkcmF3KHtcblx0XHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaXNDYXRlZ29yaXplZCA/ICQkLmFwaS5jYXRlZ29yaWVzKCkgOiAkJC5kYXRhLnhzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCB4IHZhbHVlcyBmb3IgdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIHhzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtBcnJheX0geHMgSWYgeHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyB4IHZhbHVlcyB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHhzXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBHZXQgY3VycmVudCB4IHZhbHVlc1xuXHQgKiAgY2hhcnQueHMoKTtcblx0ICpcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcblx0ICogIGNoYXJ0LnhzKHtcblx0ICogICAgZGF0YTE6IFsxMCwgMjAsIDMwLCA0MCwgLi4uXSxcblx0ICogICAgZGF0YTI6IFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl1cblx0ICogIH0pO1xuXHQgKi9cblx0eHMoeHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHRpZiAoaXNPYmplY3QoeHMpKSB7XG5cdFx0XHQkJC51cGRhdGVUYXJnZXRYcygkJC5kYXRhLnRhcmdldHMsIHhzKTtcblxuXHRcdFx0JCQucmVkcmF3KHtcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJCQuZGF0YS54cztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtpc1ZhbHVlLCBpc0RlZmluZWQsIGlzT2JqZWN0VHlwZSwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzZXRNaW5NYXggPSAoJCQsIHR5cGUsIHZhbHVlKSA9PiB7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0Y29uc3QgYXhpc1ggPSBgYXhpc194XyR7dHlwZX1gO1xuXHRjb25zdCBheGlzWSA9IGBheGlzX3lfJHt0eXBlfWA7XG5cdGNvbnN0IGF4aXNZMiA9IGBheGlzX3kyXyR7dHlwZX1gO1xuXG5cdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG5cdFx0aWYgKGlzT2JqZWN0VHlwZSh2YWx1ZSkpIHtcblx0XHRcdGlzVmFsdWUodmFsdWUueCkgJiYgKGNvbmZpZ1theGlzWF0gPSB2YWx1ZS54KTtcblx0XHRcdGlzVmFsdWUodmFsdWUueSkgJiYgKGNvbmZpZ1theGlzWV0gPSB2YWx1ZS55KTtcblx0XHRcdGlzVmFsdWUodmFsdWUueTIpICYmIChjb25maWdbYXhpc1kyXSA9IHZhbHVlLnkyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uZmlnW2F4aXNZXSA9IHZhbHVlO1xuXHRcdFx0Y29uZmlnW2F4aXNZMl0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaW4vbWF4IHZhbHVlXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge3t4LCB5LCB5Mn19XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRNaW5NYXggPSAoJCQsIHR5cGUpID0+IHtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdHJldHVybiB7XG5cdFx0eDogY29uZmlnW2BheGlzX3hfJHt0eXBlfWBdLFxuXHRcdHk6IGNvbmZpZ1tgYXhpc195XyR7dHlwZX1gXSxcblx0XHR5MjogY29uZmlnW2BheGlzX3kyXyR7dHlwZX1gXVxuXHR9O1xufTtcblxuLyoqXG4gKiBEZWZpbmUgYXhpc1xuICogQGlnbm9yZVxuICovXG5jb25zdCBheGlzID0gZXh0ZW5kKCgpID0+IHt9LCB7XG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGlzIGxhYmVscy5cblx0ICogQG1ldGhvZCBheGlz4oCkbGFiZWxzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGxhYmVscyBzcGVjaWZpZWQgYXhpcycgbGFiZWwgdG8gYmUgdXBkYXRlZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXG5cdCAqIGNoYXJ0LmF4aXMubGFiZWxzKHtcblx0ICogICB4OiBcIk5ldyBYIEF4aXMgTGFiZWxcIixcblx0ICogICB5OiBcIk5ldyBZIEF4aXMgTGFiZWxcIlxuXHQgKiB9KTtcblx0ICovXG5cdGxhYmVsczogZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdE9iamVjdC5rZXlzKGxhYmVscykuZm9yRWFjaChheGlzSWQgPT4ge1xuXHRcdFx0XHQkJC5heGlzLnNldExhYmVsVGV4dChheGlzSWQsIGxhYmVsc1theGlzSWRdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkJC5heGlzLnVwZGF0ZUxhYmVscygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtaW4gdmFsdWUuXG5cdCAqIEBtZXRob2QgYXhpc+KApG1pblxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtaW4gSWYgbWluIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIHZhbHVlIHdpbGwgYmUgdXBkYXRlZC48YnI+XG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1pbiB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogICAgIElmIG5vdCBzZXQgYW55IG1pbiB2YWx1ZXMgb24gZ2VuZXJhdGlvbiwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBtaW5cblx0ICogY2hhcnQuYXhpcy5taW4oe1xuXHQgKiAgIHg6IC0xMCxcblx0ICogICB5OiAxMDAwLFxuXHQgKiAgIHkyOiAxMDBcblx0ICogfSk7XG5cdCAqL1xuXHRtaW46IGZ1bmN0aW9uKG1pbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cblx0XHRcdHNldE1pbk1heCgkJCwgXCJtaW5cIiwgbWluKSA6XG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWluXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1heCB2YWx1ZS5cblx0ICogQG1ldGhvZCBheGlz4oCkbWF4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG1heCBJZiBtYXggaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWF4IHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWF4IHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXG5cdCAqIGNoYXJ0LmF4aXMubWF4KHtcblx0ICogICAgeDogMTAwLFxuXHQgKiAgICB5OiAxMDAwLFxuXHQgKiAgICB5MjogMTAwMDBcblx0ICogfSk7XG5cdCAqL1xuXHRtYXg6IGZ1bmN0aW9uKG1heCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cblx0XHRcdHNldE1pbk1heCgkJCwgXCJtYXhcIiwgbWF4KSA6XG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWF4XCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiBhbmQgbWF4IHZhbHVlLlxuXHQgKiBAbWV0aG9kIGF4aXPigKRyYW5nZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYW5nZSBJZiByYW5nZSBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1pbiBhbmQgbWF4IHZhbHVlIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxuXHQgKiBjaGFydC5heGlzLnJhbmdlKHtcblx0ICogICBtaW46IHtcblx0ICogICAgIHg6IC0xMCxcblx0ICogICAgIHk6IC0xMDAwLFxuXHQgKiAgICAgeTI6IC0xMDAwMFxuXHQgKiAgIH0sXG5cdCAqICAgbWF4OiB7XG5cdCAqICAgICB4OiAxMDAsXG5cdCAqICAgICB5OiAxMDAwLFxuXHQgKiAgICAgeTI6IDEwMDAwXG5cdCAqICAgfSxcblx0ICogfSk7XG5cdCAqL1xuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRjb25zdCBheGlzID0gdGhpcy5heGlzO1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5tYXgpICYmIGF4aXMubWF4KHJhbmdlLm1heCk7XG5cdFx0XHRpc0RlZmluZWQocmFuZ2UubWluKSAmJiBheGlzLm1pbihyYW5nZS5taW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtYXg6IGF4aXMubWF4KCksXG5cdFx0XHRcdG1pbjogYXhpcy5taW4oKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge2F4aXN9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogRGVmaW5lIGxlZ2VuZFxuICogQGlnbm9yZVxuICovXG5jb25zdCBsZWdlbmQgPSBleHRlbmQoKCkgPT4ge30sIHtcblx0LyoqXG5cdCAqIFNob3cgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cblx0ICogQG1ldGhvZCBsZWdlbmTigKRzaG93XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIHNob3duLlxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cblx0ICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIHNob3duLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBTaG93IGxlZ2VuZCBmb3IgZGF0YTEuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAvLyBTaG93IGFsbCBsZWdlbmQuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5zaG93KCk7XG5cdCAqL1xuXHRzaG93OiBmdW5jdGlvbih0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHQkJC5zaG93TGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpO1xuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXG5cdCAqIEBtZXRob2QgbGVnZW5k4oCkaGlkZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBIaWRlIGxlZ2VuZCBmb3IgZGF0YTEuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAvLyBIaWRlIGFsbCBsZWdlbmQuXG5cdCAqIGNoYXJ0LmxlZ2VuZC5oaWRlKCk7XG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbih0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHQkJC5oaWRlTGVnZW5kKCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykpO1xuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge2xlZ2VuZH0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vaW50ZXJuYWxzL2Jyb3dzZXJcIjtcbmltcG9ydCB7bm90RW1wdHksIGlzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogUmVzaXplIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCByZXNpemVcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2l6ZSBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBSZXNpemUgdG8gNjQweDQ4MFxuXHQgKiBjaGFydC5yZXNpemUoe1xuXHQgKiAgICB3aWR0aDogNjQwLFxuXHQgKiAgICBoZWlnaHQ6IDQ4MFxuXHQgKiB9KTtcblx0ICovXG5cdHJlc2l6ZShzaXplKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5pbnRlcm5hbC5jb25maWc7XG5cblx0XHRjb25maWcuc2l6ZV93aWR0aCA9IHNpemUgPyBzaXplLndpZHRoIDogbnVsbDtcblx0XHRjb25maWcuc2l6ZV9oZWlnaHQgPSBzaXplID8gc2l6ZS5oZWlnaHQgOiBudWxsO1xuXG5cdFx0dGhpcy5mbHVzaChmYWxzZSwgdHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZvcmNlIHRvIHJlZHJhdy5cblx0ICogQG1ldGhvZCBmbHVzaFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvZnRdIEZvciBzb2Z0IHJlZHJhdy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaXNGcm9tUmVzaXplXSBGb3Igc29mdCByZWRyYXcuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmZsdXNoKCk7XG5cdCAqXG5cdCAqIC8vIGZvciBzb2Z0IHJlZHJhd1xuXHQgKiBjaGFydC5mbHVzaCh0cnVlKTtcblx0ICovXG5cdGZsdXNoKHNvZnQsIGlzRnJvbVJlc2l6ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXG5cdFx0aWYgKCQkLnJlbmRlcmVkKSB7XG5cdFx0XHQvLyByZXNldCBwb3NzaWJsZSB6b29tIHNjYWxlXG5cdFx0XHRpZiAoaXNGcm9tUmVzaXplKSB7XG5cdFx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcmUtdXBkYXRlIGNvbmZpZyBpbmZvXG5cdFx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcblx0XHRcdH1cblxuXHRcdFx0JCQuem9vbVNjYWxlID0gbnVsbDtcblxuXHRcdFx0c29mdCA/ICQkLnJlZHJhdyh7XG5cdFx0XHRcdHdpdGhUcmFuc2Zvcm06IHRydWUsXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxuXHRcdFx0fSkgOiAkJC51cGRhdGVBbmRSZWRyYXcoe1xuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxuXHRcdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgY2hhcnQgb2JqZWN0IGFuZCByZW1vdmUgZWxlbWVudCBhbmQgZXZlbnRzIGNvbXBsZXRlbHkuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmRlc3Ryb3koKTtcblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xuXHRcdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkd2lsbERlc3Ryb3lcIik7XG5cdFx0XHQkJC5jaGFydHMuc3BsaWNlKCQkLmNoYXJ0cy5pbmRleE9mKHRoaXMpLCAxKTtcblxuXHRcdFx0Ly8gY2xlYXIgdGltZXJzICYmIHBlbmRpbmcgdHJhbnNpdGlvblxuXHRcdFx0JCQuc3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCk7XG5cdFx0XHRpc0RlZmluZWQoJCQucmVzaXplVGltZW91dCkgJiYgd2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcblxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xuXHRcdFx0JCQuc2VsZWN0Q2hhcnQuY2xhc3NlZChcImJiXCIsIGZhbHNlKS5odG1sKFwiXCIpO1xuXG5cdFx0XHQvLyByZWxlYXNpbmcgcmVmZXJlbmNlc1xuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRrZXkgPT09IFwiaW50ZXJuYWxcIiAmJiBPYmplY3Qua2V5cygkJCkuZm9yRWFjaChrID0+IHtcblx0XHRcdFx0XHQkJFtrXSA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXNba2V5XSA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IG9yIHNldCBzaW5nbGUgY29uZmlnIG9wdGlvbiB2YWx1ZS5cblx0ICogQG1ldGhvZCBjb25maWdcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWRyYXddIFNldCB0byByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvbiBjaGFuZ2VzLlxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XG5cdCAqXG5cdCAqIC8vIFNldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcblx0ICpcblx0ICogLy8gU2V0dGVyICYgcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb25cblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XG5cdCAqL1xuXHRjb25maWcobmFtZSwgdmFsdWUsIHJlZHJhdykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcblx0XHRsZXQgcmVzO1xuXG5cdFx0aWYgKGtleSBpbiAkJC5jb25maWcpIHtcblx0XHRcdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRcdCQkLmNvbmZpZ1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xuXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMgPSAkJC5jb25maWdba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBEZWZpbmUgdG9vbHRpcFxuICogQGlnbm9yZVxuICovXG5jb25zdCB0b29sdGlwID0gZXh0ZW5kKCgpID0+IHt9LCB7XG5cdC8qKlxuXHQgKiBTaG93IHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcblx0ICogICAgfCB4IHwgTnVtYmVyICZ2ZXJ0OyBEYXRlIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IHggQXhpcyBpbmRleCB8XG5cdCAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkIHggQXhpcyBlbGVtZW50Ljxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge051bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge051bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7U3RyaW5nfTogQXhpcyBpZC4gJ3knIG9yICd5MicoZGVmYXVsdCAneScpPGJyPi0gdmFsdWUge051bWJlcn06IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciB0b29sdGlwLiB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBzaG93IHRoZSAybmQgeCBBeGlzIGNvb3JkaW5hdGUgdG9vbHRpcFxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcblx0ICogICAgaW5kZXg6IDFcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gc2hvdyB0b29sdGlwIGZvciB0aGUgM3JkIHggQXhpcyBpbiB4OjUwIGFuZCB5OjEwMCBjb29yZGluYXRlIHJlbGF0aXZlIHRoZSB4IEF4aXMgZWxlbWVudC5cblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHt4OiAyfSxcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xuXHQgKiAgICB4OiBuZXcgRGF0ZShcIjIwMTgtMDEtMDIgMDA6MDBcIilcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzIHVzZWRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIHg6IDMsICAvLyB4IEF4aXMgdmFsdWVcblx0ICogICAgICAgIGlkOiBcInlcIiwgIC8vIGF4aXMgaWQuICd5JyBvciAneTInIChkZWZhdWx0ICd5Jylcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcblx0ICogICAgfVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyB3aGVuIGRhdGEueHMgaXNuJ3QgdXNlZCwgYnV0IHRvb2x0aXAuZ3JvdXBlZD1mYWxzZSBpcyBzZXRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIGluZGV4OiAzLCAgLy8gb3IgJ3gnIGtleSB2YWx1ZVxuXHQgKiAgICAgICAgaWQ6IFwieVwiLCAgLy8gYXhpcyBpZC4gJ3knIG9yICd5MicgKGRlZmF1bHQgJ3knKVxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxuXHQgKiAgICB9XG5cdCAqICB9KTtcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MgPSB7fSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgaW5kZXg7XG5cdFx0bGV0IG1vdXNlO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIG1vdXNlIHBvc2l0aW9uIG9uIHRoZSBjaGFydFxuXHRcdGlmIChhcmdzLm1vdXNlKSB7XG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcblx0XHRpZiAoYXJncy5kYXRhKSB7XG5cdFx0XHRjb25zdCB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcblxuXHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdFx0Ly8gaWYgbXVsdGlwbGUgeHMsIHRhcmdldCBwb2ludCB3aWxsIGJlIGRldGVybWluZWQgYnkgbW91c2Vcblx0XHRcdFx0bW91c2UgPSBbJCQueChhcmdzLmRhdGEueCksIHldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkJC5jb25maWcudG9vbHRpcF9ncm91cGVkKSB7XG5cdFx0XHRcdFx0bW91c2UgPSBbMCwgeV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCA9IGlzVmFsdWUoYXJncy5kYXRhLmluZGV4KSA/IGFyZ3MuZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGFyZ3MuZGF0YS54KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XG5cdFx0XHRpbmRleCA9ICQkLmdldEluZGV4QnlYKGFyZ3MueCk7XG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5pbmRleCkpIHtcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcblx0XHR9XG5cblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XG5cdFx0KCQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiID9cblx0XHRcdFtcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiXSA6IFtcInRvdWNoc3RhcnRcIl1cblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcblx0XHRcdCQkLmRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBpbmRleCwgbW91c2UpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkaGlkZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHQkJC5oaWRlVG9vbHRpcCh0cnVlKTtcblx0XHQkJC5oaWRlWEdyaWRGb2N1cygpO1xuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge3Rvb2x0aXB9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vaW50ZXJuYWxzL2Jyb3dzZXJcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCB0b0FycmF5LCBnZXRDc3NSdWxlc30gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogRW5jb2RlIHRvIGJhc2U2NFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXG4gKi9cbmNvbnN0IGI2NEVuY29kZVVuaWNvZGUgPSBzdHIgPT4gYnRvYShcblx0ZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcblx0XHQucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGAweCR7cH1gKSlcbik7XG5cbi8qKlxuICogQ29udmVydCBzdmcgbm9kZSB0byBkYXRhIHVybFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9kZVRvU3ZnRGF0YVVybCA9IChub2RlLCBzaXplKSA9PiB7XG5cdGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuXHRjb25zdCBjc3NUZXh0ID0gZ2V0Q3NzUnVsZXModG9BcnJheShkb2N1bWVudC5zdHlsZVNoZWV0cykpXG5cdFx0LmZpbHRlcihyID0+IHIuY3NzVGV4dClcblx0XHQubWFwKHIgPT4gci5jc3NUZXh0KTtcblxuXHRjbG9uZS5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBkM05hbWVzcGFjZXMueGh0bWwpO1xuXG5cdGNvbnN0IG5vZGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKGNsb25lKTtcblxuXHQvLyBlc2NhcGUgY3NzIGZvciBYTUxcblx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dC5qb2luKFwiXFxuXCIpKSk7XG5cblx0Y29uc3Qgc3R5bGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN0eWxlKTtcblxuXHQvLyBmb3JlaWduT2JqZWN0IG5vdCBzdXBwb3J0ZWQgaW4gSUUxMSBhbmQgYmVsb3dcblx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XG5cdGNvbnN0IGRhdGFTdHIgPSBgPHN2ZyB4bWxucz1cIiR7ZDNOYW1lc3BhY2VzLnN2Z31cIiB3aWR0aD1cIiR7c2l6ZS53aWR0aH1cIiBoZWlnaHQ9XCIke3NpemUuaGVpZ2h0fVwiPlxuXHRcdFx0PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPlxuXHRcdFx0XHQke3N0eWxlWG1sfVxuXHRcdFx0XHQke25vZGVYbWwucmVwbGFjZSgvKHVybFxcKClbXiNdKy9nLCBcIiQxXCIpfVxuXHRcdFx0PC9mb3JlaWduT2JqZWN0Pjwvc3ZnPmBcblx0XHQucmVwbGFjZShcIi9cXG4vZ1wiLCBcIiUwQVwiKTtcblxuXHRyZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtiNjRFbmNvZGVVbmljb2RlKGRhdGFTdHIpfWA7XG59O1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBFeHBvcnQgY2hhcnQgYXMgYW4gaW1hZ2UuXG5cdCAqIC0gKipOT1RFOioqXG5cdCAqICAgLSBJRTExIGFuZCBiZWxvdyBub3Qgd29yayBwcm9wZXJseSBkdWUgdG8gdGhlIGxhY2sgb2YgdGhlIGZlYXR1cmUoPGEgaHJlZj1cImh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFwiPmZvcmVpZ25PYmplY3Q8L2E+KSBzdXBwb3J0XG5cdCAqICAgLSBUaGUgYmFzaWMgQ1NTIGZpbGUoZXguIGJpbGxib2FyZC5jc3MpIHNob3VsZCBiZSBhdCBzYW1lIGRvbWFpbiBhcyBBUEkgY2FsbCBjb250ZXh0IHRvIGdldCBjb3JyZWN0IHN0eWxlZCBleHBvcnQgaW1hZ2UuXG5cdCAqIEBtZXRob2QgZXhwb3J0XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttaW1lVHlwZT1pbWFnZS9wbmddIFRoZSBkZXNpcmVkIG91dHB1dCBpbWFnZSBmb3JtYXQuIChleC4gJ2ltYWdlL3BuZycgZm9yIHBuZywgJ2ltYWdlL2pwZWcnIGZvciBqcGVnIGZvcm1hdClcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGV4cG9ydCBpcyByZWFkeS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBkYXRhVVJJXG5cdCAqIEBleGFtcGxlXG5cdCAqICBjaGFydC5leHBvcnQoKTtcblx0ICogIC8vIC0tPiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOLi4uXCJcblx0ICpcblx0ICogIC8vIEluaXRpYWxpemUgdGhlIGRvd25sb2FkIGF1dG9tYXRpY2FsbHlcblx0ICogIGNoYXJ0LmV4cG9ydChcImltYWdlL3BuZ1wiLCBkYXRhVXJsID0+IHtcblx0ICogICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0ICpcblx0ICogICAgIGxpbmsuZG93bmxvYWQgPSBgJHtEYXRlLm5vdygpfS5wbmdgO1xuXHQgKiAgICAgbGluay5ocmVmID0gZGF0YVVybDtcblx0ICogICAgIGxpbmsuaW5uZXJIVE1MID0gXCJEb3dubG9hZCBjaGFydCBhcyBpbWFnZVwiO1xuXHQgKlxuXHQgKiAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblx0ICogIH0pO1xuXHQgKi9cblx0ZXhwb3J0KG1pbWVUeXBlLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBzaXplID0ge3dpZHRoOiAkJC5jdXJyZW50V2lkdGgsIGhlaWdodDogJCQuY3VycmVudEhlaWdodH07XG5cdFx0Y29uc3Qgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwodGhpcy5lbGVtZW50LCBzaXplKTtcblxuXHRcdGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdGltZy5jcm9zc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuXHRcdFx0aW1nLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRcdFx0XHRjYW52YXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblxuXHRcdFx0XHRjYWxsYmFjayhjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlKSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcuc3JjID0gc3ZnRGF0YVVybDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3ZnRGF0YVVybDtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZCBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4vYXhpcy9BeGlzXCI7XG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZU9ian0gZnJvbSBcIi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuaW1wb3J0IFwiLi9jb25maWcvY29uZmlnXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9zY2FsZVwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XG5pbXBvcnQgXCIuL2RhdGEvZGF0YVwiO1xuaW1wb3J0IFwiLi9kYXRhL2RhdGEuY29udmVydFwiO1xuaW1wb3J0IFwiLi9kYXRhL2RhdGEubG9hZFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY2F0ZWdvcnlcIjtcbmltcG9ydCBcIi4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9zaXplXCI7XG5pbXBvcnQgXCIuL3NoYXBlL3NoYXBlXCI7XG5pbXBvcnQgXCIuL3NoYXBlL2FyY1wiO1xuaW1wb3J0IFwiLi9zaGFwZS9iYXJcIjtcbmltcG9ydCBcIi4vc2hhcGUvYnViYmxlXCI7XG5pbXBvcnQgXCIuL3NoYXBlL2xpbmVcIjtcbmltcG9ydCBcIi4vc2hhcGUvcG9pbnRcIjtcbmltcG9ydCBcIi4vc2hhcGUvcmFkYXJcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3RleHRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3R5cGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2dyaWRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3Rvb2x0aXBcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2xlZ2VuZFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvdGl0bGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NsaXBcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3JlZ2lvblwiO1xuaW1wb3J0IFwiLi9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvc2VsZWN0aW9uXCI7XG5pbXBvcnQgXCIuL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xuaW1wb3J0IFwiLi9pbnRlcmFjdGlvbnMvem9vbVwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY2FjaGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZm9jdXNcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5zaG93XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuem9vbVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmxvYWRcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5mbG93XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuc2VsZWN0aW9uXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkudHJhbnNmb3JtXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZ3JvdXBcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5ncmlkXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkucmVnaW9uXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZGF0YVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmNhdGVnb3J5XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuY29sb3JcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS54XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuYXhpc1wiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmxlZ2VuZFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmNoYXJ0XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkudG9vbHRpcFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmV4cG9ydFwiO1xuXG5sZXQgZGVmYXVsdHMgPSB7fTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGJiXG4gKiBAdmVyc2lvbiAxLjEwLjJcbiAqL1xuY29uc3QgYmIgPSB7XG5cdC8qKlxuXHQgKiBWZXJzaW9uIGluZm9ybWF0aW9uXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2ZXJzaW9uIHZlcnNpb25cblx0ICogQGV4YW1wbGVcblx0ICogICAgYmIudmVyc2lvbjsgIC8vIFwiMS4wLjBcIlxuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICovXG5cdHZlcnNpb246IFwiMS4xMC4yXCIsXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKiBAcmV0dXJuIHtDaGFydH1cblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc30gZm9yIGRpZmZlcmVudCBnZW5lcmF0aW9uIG9wdGlvbnNcblx0ICogQHNlZSB7QGxpbmsgQ2hhcnR9IGZvciBkaWZmZXJlbnQgbWV0aG9kcyBBUElcblx0ICogQGV4YW1wbGVcblx0ICogIDwhLS0gY2hhcnQgaG9sZGVyIC0tPlxuXHQgKiA8ZGl2IGlkPVwiTGluZUNoYXJ0XCI+PC9kaXY+XG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gZ2VuZXJhdGUgY2hhcnQgd2l0aCBvcHRpb25zXG5cdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XG5cdCAqICAgICAgXCJiaW5kdG9cIjogXCIjTGluZUNoYXJ0XCJcblx0ICogICAgICBcImRhdGFcIjoge1xuXHQgKiAgICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwLCA0MDAsIDE1MCwgMjUwXSxcblx0ICogICAgICAgICAgICAgIFtcImRhdGEyXCIsIDUwLCAyMCwgMTAsIDQwLCAxNSwgMjVdXG5cdCAqICAgICAgICAgICBdXG5cdCAqICAgICAgfVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBjYWxsIHNvbWUgQVBJXG5cdCAqICAvLyBleCkgZ2V0IHRoZSBkYXRhIG9mICdkYXRhMSdcblx0ICogIGNoYXJ0LmRhdGEoXCJkYXRhMVwiKTtcblx0ICovXG5cdGdlbmVyYXRlKGNvbmZpZykge1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9iaih7fSwgZGVmYXVsdHMsIGNvbmZpZyk7XG5cdFx0Y29uc3QgaW5zdCA9IG5ldyBDaGFydChvcHRpb25zKTtcblxuXHRcdGluc3QuaW50ZXJuYWwuY2hhcnRzID0gdGhpcy5pbnN0YW5jZTtcblx0XHR0aGlzLmluc3RhbmNlLnB1c2goaW5zdCk7XG5cblx0XHRyZXR1cm4gaW5zdDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IG9yIGdldCBnbG9iYWwgZGVmYXVsdCBvcHRpb25zLlxuXHQgKiAtICoqTk9URToqKlxuXHQgKiAgIC0gVGhlIG9wdGlvbnMgdmFsdWVzIHNldHRpbmdzIGFyZSB2YWxpZCB3aXRoaW4gcGFnZSBjb250ZXh0IG9ubHkuXG5cdCAqICAgLSBJZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHdpbGwgb3ZlcnJpZGUgdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKiBAcmV0dXJuIHtPcHRpb25zfVxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBTZXQgc2FtZSBvcHRpb24gdmFsdWUgYXMgZm9yIGAuZ2VuZXJhdGUoKWBcblx0ICogYmIuZGVmYXVsdHMoe1xuXHQgKiAgIGRhdGE6IHtcblx0ICogICAgIHR5cGU6IFwiYmFyXCJcblx0ICogICB9XG5cdCAqIH0pO1xuXHQgKlxuXHQgKiBiYi5kZWZhdWx0cygpOyAgLy8ge2RhdGE6e3R5cGU6IFwiYmFyXCJ9fVxuXHQgKlxuXHQgKiAvLyBkYXRhLnR5cGUgZGVmYXVsdHMgdG8gJ2Jhcidcblx0ICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XG5cdCAqL1xuXHRkZWZhdWx0cyhvcHRpb25zKSB7XG5cdFx0aWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0XHRkZWZhdWx0cyA9IG9wdGlvbnM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmF1bHRzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBjb250YWluaW5nIGluc3RhbmNlIGNyZWF0ZWRcblx0ICogQHByb3BlcnR5IHtBcnJheX0gaW5zdGFuY2UgaW5zdGFuY2UgYXJyYXlcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIGdlbmVyYXRlIGNoYXJ0c1xuXHQgKiAgdmFyIGNoYXJ0MSA9IGJiLmdlbmVyYXRlKC4uLik7XG5cdCAqICB2YXIgY2hhcnQyID0gYmIuZ2VuZXJhdGUoLi4uKTtcblx0ICpcblx0ICogIGJiLmluc3RhbmNlOyAgLy8gWyBjaGFydDEsIGNoYXJ0MiwgLi4uIF1cblx0ICogQG1lbWJlcm9mIGJiXG5cdCAqL1xuXHRpbnN0YW5jZTogW10sXG5cblx0LyoqXG5cdCAqIE5hbWVzcGFjZSBmb3IgcGx1Z2luc1xuXHQgKiBAcHJvcGVydHkge09iamVjdH0gcGx1Z2luIHBsdWdpbiBuYW1lc3BhY2Vcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIFN0YW5mb3JkIGRpYWdyYW0gcGx1Z2luXG5cdCAqICBiYi5wbHVnaW4uc3RhbmZvcmQ7XG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKi9cblx0cGx1Z2luOiB7fSxcblxuXHQvKipcblx0ICogSW50ZXJuYWwgY2hhcnQgb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjaGFydDoge1xuXHRcdGZuOiBDaGFydC5wcm90b3R5cGUsXG5cdFx0aW50ZXJuYWw6IHtcblx0XHRcdGZuOiBDaGFydEludGVybmFsLnByb3RvdHlwZSxcblx0XHRcdGF4aXM6IHtcblx0XHRcdFx0Zm46IEF4aXMucHJvdG90eXBlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5leHBvcnQge2JifTtcbmV4cG9ydCBkZWZhdWx0IGJiO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==