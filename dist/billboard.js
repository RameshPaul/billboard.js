(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-axis", "d3-brush", "d3-scale", "d3-dsv", "d3-drag", "d3-shape", "d3-interpolate", "d3-color", "d3-zoom", "d3-ease"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-brush"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__53__, __WEBPACK_EXTERNAL_MODULE__55__, __WEBPACK_EXTERNAL_MODULE__56__, __WEBPACK_EXTERNAL_MODULE__57__, __WEBPACK_EXTERNAL_MODULE__58__, __WEBPACK_EXTERNAL_MODULE__59__, __WEBPACK_EXTERNAL_MODULE__60__, __WEBPACK_EXTERNAL_MODULE__61__, __WEBPACK_EXTERNAL_MODULE__62__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(33);
module.exports = __webpack_require__(63);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(10);

var _require = __webpack_require__(16),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(18);

var reloadApp = __webpack_require__(19);

var createSocketUrl = __webpack_require__(22);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(31);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(9);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);
    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.3.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(11);

var _require = __webpack_require__(12),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(13),
  Html4Entities: __webpack_require__(14),
  Html5Entities: __webpack_require__(15),
  AllHtmlEntities: __webpack_require__(15)
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(17).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(16),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...'); // eslint-disable-next-line global-require

    var hotEmitter = __webpack_require__(20);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(21);
module.exports = new EventEmitter();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(23);

var querystring = __webpack_require__(27);

var getCurrentScriptSource = __webpack_require__(30);

function createSocketUrl(resourceQuery) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    urlParts = url.parse(resourceQuery.substr(1));
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape

    scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
    urlParts = url.parse(scriptHost || '/', false, true);
  }

  if (!urlParts.port || urlParts.port === '0') {
    urlParts.port = self.location.port;
  }

  var _urlParts = urlParts,
      auth = _urlParts.auth,
      path = _urlParts.path;
  var _urlParts2 = urlParts,
      hostname = _urlParts2.hostname,
      protocol = _urlParts2.protocol; // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  if ((hostname === '0.0.0.0' || hostname === '::') && self.location.hostname && // eslint-disable-next-line no-bitwise
  !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = self.location.protocol;
  } // default values of the sock url if they are not provided


  var sockHost = hostname;
  var sockPath = '/sockjs-node';
  var sockPort = urlParts.port; // eslint-disable-next-line no-undefined

  if (path !== null && path !== undefined && path !== '/') {
    var parsedQuery = querystring.parse(path); // all of these sock url params are optionally passed in through
    // resourceQuery, so we need to fall back to the default if
    // they are not provided

    sockHost = parsedQuery.sockHost || sockHost;
    sockPath = parsedQuery.sockPath || sockPath;
    sockPort = parsedQuery.sockPort || sockPort;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(24);
var util = __webpack_require__(26);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(27);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(25)(module), __webpack_require__(8)))

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(28);
exports.encode = exports.stringify = __webpack_require__(29);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 32
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 31;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(34);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(36)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(35)(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px GothamPro;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  fill: #5D5C71; }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px GothamPro; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: none; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n\nh2#title {\n  font-size: 16px;\n  text-transform: \"uppercase\"; }\n", ""]);


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(37);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 37 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(40);

var iterableToArrayLimit = __webpack_require__(41);

var nonIterableRest = __webpack_require__(42);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(49);

var iterableToArray = __webpack_require__(50);

var nonIterableSpread = __webpack_require__(51);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 51 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__53__;

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return doc; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */
var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    doc = win && win.document;
/* eslint-enable no-new-func, no-undef */



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__55__;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__56__;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__57__;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__58__;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__59__;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__60__;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__61__;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__62__;

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(38);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(39);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(43);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(44);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(45);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(46);

// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/config/classes.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_"
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(48);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(52);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(53);

// EXTERNAL MODULE: ./src/internals/browser.js
var browser = __webpack_require__(54);

// CONCATENATED MODULE: ./src/internals/util.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */





var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof_default()(v) === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return arr && arr.constructor === Array;
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
},
    getOption = function (options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
},
    util_hasValue = function (dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
},
    callFn = function (fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
},
    sanitise = function (str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
},
    setTextValue = function (node, text) {
  var dy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-1, 1];
  if (node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"); // reset possible text

      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", "".concat(i === 0 ? dy[0] : dy[1], "em")).text(v);
      });
    }
  }
},
    getRectSegList = function (path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height // seg3

  }];
},
    getPathBox = function (path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
},
    getBrushSelection = function (ctx) {
  var selection = null,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = ctx.context || ctx.main;
  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select(".".concat(config_classes.brush)).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
},
    getRandom = function () {
  var asStr = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
  return Math.random() + (asStr ? "" : 0);
},
    brushEmpty = function (ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
},
    extend = function () {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      source = arguments.length > 1 ? arguments[1] : undefined;

  for (var p in source) target[p] = source[p];

  return target;
},
    capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
},
    getCssRules = function (styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from ".concat(sheet.href, ": ").concat(e.toString()));
    }
  }), rules;
},
    getUnique = function (data) {
  return data.filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
},
    mergeArray = function (arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
},
    mergeObj = function (_mergeObj) {
  function mergeObj() {
    return _mergeObj.apply(this, arguments);
  }

  return mergeObj.toString = function () {
    return _mergeObj.toString();
  }, mergeObj;
}(function (target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}),
    sortValue = function (data) {
  var fn,
      isAsc = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && data.every(Number) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
},
    getMinMax = function (type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, toConsumableArray_default()(res)) : res[0] instanceof Date && (res = sortValue(res, type === "min")[0]) : res = undefined, res;
},
    getRange = function (start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams();
        el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams(),
            mouseEvent = browser["document"].createEvent("MouseEvent");
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, browser["window"], 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(Object.assign({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
},
    tplProcess = function (tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=".concat(x, "}"), "g"), data[x]);

  return res;
};


// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(55);

// CONCATENATED MODULE: ./src/axis/AxisRendererHelper.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(config, params) {
    classCallCheck_default()(this, AxisRendererHelper);

    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])();
    this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = scale.rangeExtent ? scale.rangeExtent() : this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  return createClass_default()(AxisRendererHelper, [{
    key: "axisX",
    value: function axisX(selection, x) {
      var _this = this;

      selection.attr("transform", function (d) {
        return "translate(".concat(Math.ceil(x(d) + _this.config.tickOffset), ",0)");
      });
    }
  }, {
    key: "axisY",
    value: function axisY(selection, y) {
      selection.attr("transform", function (d) {
        return "translate(0,".concat(Math.ceil(y(d)), ")");
      });
    }
  }, {
    key: "scaleExtent",
    value: function scaleExtent(domain) {
      var start = domain[0],
          stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
    }
  }, {
    key: "generateTicks",
    value: function generateTicks(scale) {
      var ticks = [];
      if (scale.ticks) return scale.ticks.apply(scale, toConsumableArray_default()(this.config.tickArguments || [])).map(function (v) {
        return (// round the tick value if is number
          isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
        );
      });

      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      return ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0])), ticks;
    }
  }, {
    key: "copyScale",
    value: function copyScale() {
      var newScale = this.scale.copy();
      return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
    }
  }, {
    key: "textFormatted",
    value: function textFormatted(v) {
      var tickFormat = this.config.tickFormat,
          value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
          formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
      // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
      // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

      return isDefined(formatted) ? formatted : "";
    }
  }, {
    key: "transitionise",
    value: function transitionise(selection) {
      var config = this.config;
      return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
    }
  }], [{
    key: "getSizeFor1Char",
    value: function getSizeFor1Char(node) {
      // default size for one character
      var size = {
        w: 5.5,
        h: 11.5
      };
      return node.empty() || node.select("text").text("0").call(function (el) {
        try {
          var _el$node$getBBox = el.node().getBBox(),
              width = _el$node$getBBox.width,
              height = _el$node$getBBox.height;

          width && height && (size.w = width, size.h = height), el.text("");
        } catch (e) {}
      }), this.getSizeFor1Char = function () {
        return size;
      }, size;
    }
  }]), AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/axis/AxisRenderer.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AxisRenderer);

    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.helper = new AxisRendererHelper_AxisRendererHelper(config, params), this.config = config, this.params = params;
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  return createClass_default()(AxisRenderer, [{
    key: "create",
    value: function create(g) {
      var ctx = this,
          config = this.config,
          params = this.params,
          helperInst = this.helper,
          scale = helperInst.scale,
          orient = config.orient,
          splitTickText = this.splitTickText.bind(this),
          isLeftRight = /^(left|right)$/.test(orient),
          isTopBottom = /^(top|bottom)$/.test(orient),
          tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
          axisPx = tickTransform === helperInst.axisX ? "y" : "x",
          sign = /^(top|left)$/.test(orient) ? -1 : 1,
          rotate = params.tickTextRotate;
      this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
      var _config = config,
          innerTickSize = _config.innerTickSize,
          tickLength = _config.tickLength,
          range = _config.range,
          name = params.name,
          tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_".concat(name, "_tick_text_position")] : {
        x: 0,
        y: 0
      },
          prefix = name === "subX" ? "subchart_axis_x" : "axis_".concat(name),
          axisShow = params.config["".concat(prefix, "_show")],
          tickShow = {
        tick: !!axisShow && params.config["".concat(prefix, "_tick_show")],
        text: !!axisShow && params.config["".concat(prefix, "_tick_text_show")]
      },
          $g = null; // // get the axis' tick position configuration

      g.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            scale0 = this.__chart__ || scale,
            scale1 = helperInst.copyScale();
        $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
        // update selection - data join
        var path = g.selectAll(".domain").data([0]); // enter + update selection

        if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
          var outerTickSized = config.outerTickSize * sign;
          return isTopBottom ? "M".concat(range[0], ",").concat(outerTickSized, "V0H").concat(range[1], "V").concat(outerTickSized) : "M".concat(outerTickSized, ",").concat(range[0], "H0V").concat(range[1], "H").concat(outerTickSized);
        }), tickShow.tick || tickShow.text) {
          // count of tick data in array
          var ticks = config.tickValues || helperInst.generateTicks(scale1),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
              tickExit = tick.exit().remove(); // update selection

          tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
          var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
              counts = [],
              tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
            var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
            return counts[index] = split.length, split.map(function (splitted) {
              return {
                index: index,
                splitted: splitted
              };
            });
          });
          tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
            return d.splitted;
          }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
            var dx = 0;
            return orient === "bottom" && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180))), dx + (tickTextPos.x || 0);
          }()).attr("dy", function (d, i) {
            var dy = 0;
            return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
          });
          var lineUpdate = tick.select("line"),
              textUpdate = tick.select("text");

          if (tickEnter.select("line").attr("".concat(axisPx, "2"), innerTickSize * sign), tickEnter.select("text").attr("".concat(axisPx), tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
            Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
          }), scale1.bandwidth) {
            var x = scale1,
                dx = x.bandwidth() / 2;
            scale0 = function (d) {
              return x(d) + dx;
            }, scale1 = scale0;
          } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

          tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
        }
      }), this.g = $g;
    }
    /**
     * Get tick x/y coordinate
     * @return {{x: number, y: number}}
     * @private
     */

  }, {
    key: "getTickXY",
    value: function getTickXY() {
      var config = this.config,
          pos = {
        x: 0,
        y: 0
      };
      return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
    }
    /**
     * Get tick size
     * @param d
     * @return {number}
     * @private
     */

  }, {
    key: "getTickSize",
    value: function getTickSize(d) {
      var scale = this.helper.scale,
          config = this.config,
          innerTickSize = config.innerTickSize,
          range = config.range,
          tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
      return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
    }
    /**
     * Set tick's line & text position
     * @param lineUpdate
     * @param textUpdate
     * @param scale
     * @private
     */

  }, {
    key: "setTickLineTextPosition",
    value: function setTickLineTextPosition(lineUpdate, textUpdate) {
      var tickPos = this.getTickXY(),
          _this$config = this.config,
          innerTickSize = _this$config.innerTickSize,
          orient = _this$config.orient,
          tickLength = _this$config.tickLength,
          tickOffset = _this$config.tickOffset,
          rotate = this.params.tickTextRotate;
      orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", function yForText(r) {
        return r ? 11.5 - 2.5 * (r / 15) * (r > 0 ? 1 : -1) : tickLength;
      }(rotate)).style("text-anchor", function textAnchorForText(r) {
        return r ? r > 0 ? "start" : "end" : "middle";
      }(rotate)).attr("transform", function textTransform(r) {
        return r ? "rotate(".concat(r, ")") : null;
      }(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -tickLength * 2).style("text-anchor", "middle")) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
    } // this should be called only when category axis

  }, {
    key: "splitTickText",
    value: function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
      function split(splitted, text) {
        for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
        if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

        return splitted.concat(text);
      }

      var params = this.params,
          tickText = this.helper.textFormatted(d),
          splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
      if (splitted.length) return splitted;
      if (isArray(tickText)) return tickText;
      var tickWidth = params.tickWidth;
      return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
    }
  }, {
    key: "scale",
    value: function scale(x) {
      return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
    }
  }, {
    key: "orient",
    value: function orient(x) {
      return arguments.length ? (this.config.orient = x in {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      } ? x + "" : "bottom", this) : this.config.orient;
    }
  }, {
    key: "tickFormat",
    value: function tickFormat(format) {
      return arguments.length ? (this.config.tickFormat = format, this) : this.config.tickFormat;
    }
  }, {
    key: "tickCentered",
    value: function tickCentered(isCentered) {
      var config = this.config;
      return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
    }
    /**
     * Return tick's offset value.
     * The value will be set for 'category' axis type.
     * @return {number}
     * @private
     */

  }, {
    key: "tickOffset",
    value: function tickOffset() {
      return this.config.tickOffset;
    }
    /**
     * Get tick interval count
     * @private
     * @param {Number} size Total data size
     * @return {number}
     */

  }, {
    key: "tickInterval",
    value: function tickInterval(size) {
      var interval;
      if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
        var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
        interval = length / (size || this.g.selectAll("line").size());
      }
      return interval === Infinity ? 0 : interval;
    }
  }, {
    key: "ticks",
    value: function ticks() {
      for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
    }
  }, {
    key: "tickCulling",
    value: function tickCulling(culling) {
      var config = this.config;
      return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
    }
  }, {
    key: "tickValues",
    value: function tickValues(x) {
      var _this = this,
          config = this.config;

      if (isFunction(x)) config.tickValues = function () {
        return x(_this.helper.scale.domain());
      };else {
        if (!arguments.length) return config.tickValues;
        config.tickValues = x;
      }
      return this;
    }
  }, {
    key: "setTransition",
    value: function setTransition(t) {
      return this.config.transition = t, this;
    }
  }]), AxisRenderer;
}();


// CONCATENATED MODULE: ./src/axis/Axis.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var isHorizontal = function ($$, forHorizontal) {
  var isRotated = $$.config.axis_rotated;
  return forHorizontal ? isRotated : !isRotated;
},
    getAxisClassName = function (id) {
  return "".concat(config_classes.axis, " ").concat(config_classes["axis".concat(capitalize(id))]);
};

var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    classCallCheck_default()(this, Axis), this.owner = owner, this.setOrient();
  }

  return createClass_default()(Axis, [{
    key: "init",
    value: function init() {
      var _this = this,
          $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          main = $$.main,
          target = ["x", "y"];

      config.axis_y2_show && target.push("y2"), $$.axesList = {}, target.forEach(function (v) {
        var classAxis = getAxisClassName(v),
            classLabel = config_classes["axis".concat(capitalize(v), "Label")];
        $$.axes[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
          var res = null;
          return v === "x" ? res = $$.clipPathForXAxis : v === "y" && config.axis_y_inner && (res = $$.clipPathForYAxis), res;
        }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_".concat(v, "_show")] ? "visible" : "hidden"), $$.axes[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this.textAnchorForXAxisLabel.bind(_this)), _this.generateAxes(v);
      });
    }
    /**
     * Set axis orient according option value
     * @private
     */

  }, {
    key: "setOrient",
    value: function setOrient() {
      var $$ = this.owner,
          config = $$.config,
          isRotated = config.axis_rotated,
          yInner = config.axis_y_inner,
          y2Inner = config.axis_y2_inner;
      $$.xOrient = isRotated ? "left" : "bottom", $$.yOrient = isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left", $$.y2Orient = isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right", $$.subXOrient = isRotated ? "left" : "bottom";
    }
    /**
     * Generate axes
     * It's used when axis' axes option is set
     * @param {String} id Axis id
     * @private
     */

  }, {
    key: "generateAxes",
    value: function generateAxes(id) {
      var d3Axis,
          $$ = this.owner,
          config = $$.config,
          axes = [],
          axesConfig = config["axis_".concat(id, "_axes")],
          isRotated = config.axis_rotated;
      id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
        var tick = v.tick;
        axes.push(d3Axis($$[id]).ticks(tick.count).tickFormat(tick.format || function (x) {
          return x;
        }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
      }), $$.axesList[id] = axes;
    }
    /**
     * Update axes nodes
     * @private
     */

  }, {
    key: "updateAxes",
    value: function updateAxes() {
      var $$ = this.owner,
          config = $$.config;
      Object.keys($$.axesList).forEach(function (id) {
        var range = $$[id].range();
        $$.axesList[id].forEach(function (v, i) {
          var axisRange = v.scale().range(); // adjust range value with the current
          // https://github.com/naver/billboard.js/issues/859

          range.every(function (v, i) {
            return v === axisRange[i];
          }) || v.scale().range(range);
          var className = "".concat(getAxisClassName(id), "-").concat(i + 1),
              g = $$.main.select(".".concat(className.replace(/\s/, ".")));
          g.empty() ? g = $$.main.append("g").attr("class", className).style("visibility", config["axis_".concat(id, "_show")] ? "visible" : "hidden").call(v) : $$.xAxis.helper.transitionise(g).call(v.scale($$[id])), g.attr("transform", $$.getTranslate(id, i + 1));
        });
      });
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getXAxis",
    value: function getXAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          isCategory = $$.isCategorized(),
          orient = $$["".concat(name, "Orient")],
          tickFormat = $$.xAxisTickFormat,
          tickValues = $$.xAxisTickValues,
          axisParams = {
        isCategory: isCategory,
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickMultiline: config.axis_x_tick_multiline,
        tickWidth: config.axis_x_tick_width,
        tickTextRotate: noTickTextRotate ? 0 : config.axis_x_tick_rotate,
        tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
        orgXScale: $$.x
      },
          axis = new AxisRenderer_AxisRenderer(axisParams).scale($$.zoomScale || scale).orient(orient),
          newTickValues = tickValues;
      return $$.isTimeSeries() && tickValues && !isFunction(tickValues) && (newTickValues = tickValues.map(function (v) {
        return $$.parseDate(v);
      })), axis.tickFormat(tickFormat).tickValues(newTickValues), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config.axis_x_tick_count && axis.ticks(config.axis_x_tick_count), axis;
    } // called from : updateScales() & getMaxTickWidth()

  }, {
    key: "getYAxis",
    value: function getYAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
      var $$ = this.owner,
          config = $$.config,
          orient = $$["".concat(name, "Orient")],
          tickFormat = config["axis_".concat(name, "_tick_format")],
          tickValues = $$["".concat(name, "AxisTickValues")],
          axisParams = {
        outerTick: outerTick,
        noTransition: noTransition,
        config: config,
        name: name,
        tickTextRotate: noTickTextRotate ? 0 : config.axis_y_tick_rotate
      },
          axis = new AxisRenderer_AxisRenderer(axisParams).scale(scale).orient(orient).tickFormat(tickFormat || $$.isStackNormalized() && function (x) {
        return "".concat(x, "%");
      });
      return $$.isTimeSeriesY() ? // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
      axis.ticks(config.axis_y_tick_time_value) : axis.tickValues(tickValues), axis;
    }
  }, {
    key: "updateXAxisTickValues",
    value: function updateXAxisTickValues(targets, axis) {
      var values,
          $$ = this.owner,
          config = $$.config,
          fit = config.axis_x_tick_fit,
          count = config.axis_x_tick_count;
      return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.xAxis && ($$.xAxis.tickValues(values), $$.subXAxis.tickValues(values)), values;
    }
  }, {
    key: "getId",
    value: function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : "y";
    }
  }, {
    key: "getXAxisTickFormat",
    value: function getXAxisTickFormat() {
      var format,
          $$ = this.owner,
          config = $$.config,
          tickFormat = config.axis_x_tick_format,
          isTimeSeries = $$.isTimeSeries(),
          isCategorized = $$.isCategorized();
      return tickFormat ? isFunction(tickFormat) ? format = tickFormat : isTimeSeries && (format = function (date) {
        return date ? $$.axisTimeFormat(tickFormat)(date) : "";
      }) : format = isTimeSeries ? $$.defaultAxisTimeFormat : isCategorized ? $$.categoryName : function (v) {
        return v < 0 ? v.toFixed(0) : v;
      }, isFunction(format) ? function (v) {
        return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
      } : format;
    }
  }, {
    key: "getTickValues",
    value: function getTickValues(id) {
      var $$ = this.owner,
          tickValues = $$.config["axis_".concat(id, "_tick_values")],
          axis = $$["".concat(id, "Axis")];
      return tickValues || (axis ? axis.tickValues() : undefined);
    }
  }, {
    key: "getXAxisTickValues",
    value: function getXAxisTickValues() {
      return this.getTickValues("x");
    }
  }, {
    key: "getYAxisTickValues",
    value: function getYAxisTickValues() {
      return this.getTickValues("y");
    }
  }, {
    key: "getY2AxisTickValues",
    value: function getY2AxisTickValues() {
      return this.getTickValues("y2");
    }
  }, {
    key: "getLabelOptionByAxisId",
    value: function getLabelOptionByAxisId(id) {
      return this.owner.config["axis_".concat(id, "_label")];
    }
  }, {
    key: "getLabelText",
    value: function getLabelText(id) {
      var option = this.getLabelOptionByAxisId(id);
      return isString(option) ? option : option ? option.text : null;
    }
  }, {
    key: "setLabelText",
    value: function setLabelText(id, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(id);
      isString(option) ? config["axis_".concat(id, "_label")] = text : option && (option.text = text);
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(id, defaultPosition) {
      var isRotated = this.owner.config.axis_rotated,
          option = this.getLabelOptionByAxisId(id),
          position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
          has = function (v) {
        return !!~position.indexOf(v);
      };

      return {
        isInner: has("inner"),
        isOuter: has("outer"),
        isLeft: has("left"),
        isCenter: has("center"),
        isRight: has("right"),
        isTop: has("top"),
        isMiddle: has("middle"),
        isBottom: has("bottom")
      };
    }
  }, {
    key: "getXAxisLabelPosition",
    value: function getXAxisLabelPosition() {
      return this.getLabelPosition("x", ["inner-top", "inner-right"]);
    }
  }, {
    key: "getYAxisLabelPosition",
    value: function getYAxisLabelPosition() {
      return this.getLabelPosition("y", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getY2AxisLabelPosition",
    value: function getY2AxisLabelPosition() {
      return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
    }
  }, {
    key: "getLabelPositionById",
    value: function getLabelPositionById(id) {
      return this["get".concat(id.toUpperCase(), "AxisLabelPosition")]();
    }
  }, {
    key: "textForXAxisLabel",
    value: function textForXAxisLabel() {
      return this.getLabelText("x");
    }
  }, {
    key: "textForYAxisLabel",
    value: function textForYAxisLabel() {
      return this.getLabelText("y");
    }
  }, {
    key: "textForY2AxisLabel",
    value: function textForY2AxisLabel() {
      return this.getLabelText("y2");
    }
  }, {
    key: "xForAxisLabel",
    value: function xForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          x = position.isMiddle ? -$$.height / 2 : 0;
      return isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom && (x = -$$.height), x;
    }
  }, {
    key: "dxForAxisLabel",
    value: function dxForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          dx = position.isBottom ? "0.5em" : "0";
      return isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
    }
  }, {
    key: "textAnchorForAxisLabel",
    value: function textAnchorForAxisLabel(position) {
      var forHorizontal = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
          $$ = this.owner,
          anchor = position.isMiddle ? "middle" : "end";
      return isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
    }
  }, {
    key: "xForXAxisLabel",
    value: function xForXAxisLabel() {
      return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "xForYAxisLabel",
    value: function xForYAxisLabel() {
      return this.xForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "xForY2AxisLabel",
    value: function xForY2AxisLabel() {
      return this.xForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dxForXAxisLabel",
    value: function dxForXAxisLabel() {
      return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "dxForYAxisLabel",
    value: function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "dxForY2AxisLabel",
    value: function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "dyForXAxisLabel",
    value: function dyForXAxisLabel() {
      var $$ = this.owner,
          config = $$.config,
          isInner = this.getXAxisLabelPosition().isInner,
          xHeight = config.axis_x_height;
      return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
    }
  }, {
    key: "dyForYAxisLabel",
    value: function dyForYAxisLabel() {
      var $$ = this.owner,
          isInner = this.getYAxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
    }
  }, {
    key: "dyForY2AxisLabel",
    value: function dyForY2AxisLabel() {
      var $$ = this.owner,
          isInner = this.getY2AxisLabelPosition().isInner;
      return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
    }
  }, {
    key: "textAnchorForXAxisLabel",
    value: function textAnchorForXAxisLabel() {
      return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
    }
  }, {
    key: "textAnchorForYAxisLabel",
    value: function textAnchorForYAxisLabel() {
      return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
    }
  }, {
    key: "textAnchorForY2AxisLabel",
    value: function textAnchorForY2AxisLabel() {
      return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
    }
  }, {
    key: "getMaxTickWidth",
    value: function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          currentTickMax = $$.currentMaxTickWidths[id],
          maxWidth = 0;
      if (withoutRecompute || !config["axis_".concat(id, "_show")]) return currentTickMax.size;

      if ($$.svg) {
        var isYAxis = /^y2?$/.test(id),
            targetsToShow = $$.filterTargetsToShow($$.data.targets),
            getFrom = isYAxis ? "getY" : "getX",
            scale = $$[id].copy().domain($$["".concat(getFrom, "Domain")](targetsToShow, id)),
            domain = scale.domain();
        // do not compute if domain is same
        if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
          return v === domain[i];
        })) return currentTickMax.size;
        currentTickMax.domain = domain;
        var axis = this["".concat(getFrom, "Axis")](id, scale, !1, !1, !0),
            tickCount = config["axis_".concat(id, "_tick_count")];
        tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
        var dummy = $$.selectChart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
        axis.create(dummy), dummy.selectAll("text").each(function () {
          maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
        }), dummy.remove();
      }

      return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
    }
  }, {
    key: "updateLabels",
    value: function updateLabels(withTransition) {
      var _this2 = this,
          $$ = this.owner,
          labels = {
        X: $$.main.select(".".concat(config_classes.axisX, " .").concat(config_classes.axisXLabel)),
        Y: $$.main.select(".".concat(config_classes.axisY, " .").concat(config_classes.axisYLabel)),
        Y2: $$.main.select(".".concat(config_classes.axisY2, " .").concat(config_classes.axisY2Label))
      };

      Object.keys(labels).filter(function (id) {
        return !labels[id].empty();
      }).forEach(function (v) {
        var node = labels[v],
            axisLabel = "".concat(v, "AxisLabel");
        (withTransition ? node.transition() : node).attr("x", _this2["xFor".concat(axisLabel)].bind(_this2)).attr("dx", _this2["dxFor".concat(axisLabel)].bind(_this2)).attr("dy", _this2["dyFor".concat(axisLabel)].bind(_this2)).text(_this2["textFor".concat(axisLabel)].bind(_this2));
      });
    }
  }, {
    key: "getPadding",
    value: function getPadding(padding, key, defaultValue, domainLength) {
      var p = isNumber(padding) ? padding : padding[key];
      return isValue(p) ? padding.unit === "ratio" ? padding[key] * domainLength : this.convertPixelsToAxisPadding(p, domainLength) : defaultValue; // assume padding is pixels if unit is not specified
    }
  }, {
    key: "convertPixelsToAxisPadding",
    value: function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    }
  }, {
    key: "generateTickValues",
    value: function generateTickValues(values, tickCount, forTimeSeries) {
      var start,
          end,
          count,
          interval,
          i,
          tickValue,
          tickValues = values;

      if (tickCount) {
        var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

        if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
          for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);

          tickValues.push(end);
        }
      }

      return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
        return a - b;
      })), tickValues;
    }
  }, {
    key: "generateTransitions",
    value: function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes,
          _map = ["x", "y", "y2", "subx"].map(function (v) {
        var axis = axes[v];
        return axis && duration && (axis = axis.transition().duration(duration)), axis;
      }),
          _map2 = slicedToArray_default()(_map, 4),
          axisX = _map2[0],
          axisY = _map2[1],
          axisY2 = _map2[2],
          axisSubX = _map2[3];

      return {
        axisX: axisX,
        axisY: axisY,
        axisY2: axisY2,
        axisSubX: axisSubX
      };
    }
  }, {
    key: "redraw",
    value: function redraw(transitions, isHidden, isInit) {
      var $$ = this.owner,
          opacity = isHidden ? "0" : "1";
      ["x", "y", "y2", "subX"].forEach(function (id) {
        var axis = $$["".concat(id, "Axis")];
        axis && (!isInit && (axis.config.withoutTransition = !$$.config.transition_duration), $$.axes[id.toLowerCase()].style("opacity", opacity), axis.create(transitions["axis".concat(capitalize(id))]));
      }), this.updateAxes();
    }
  }]), Axis;
}();


// CONCATENATED MODULE: ./src/internals/ChartInternal.js




/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */







/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  function ChartInternal(api) {
    classCallCheck_default()(this, ChartInternal);

    var $$ = this;
    $$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {};
  }

  return createClass_default()(ChartInternal, [{
    key: "beforeInit",
    value: function beforeInit() {
      var $$ = this;
      $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$);
    }
  }, {
    key: "afterInit",
    value: function afterInit() {
      var $$ = this;
      $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$);
    }
  }, {
    key: "init",
    value: function init() {
      var $$ = this;
      $$.initParams();
      var convertedData = $$.convertData($$.config, $$.initWithData);
      convertedData && $$.initWithData(convertedData);
    }
  }, {
    key: "initParams",
    value: function initParams() {
      var _this = this,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated;

      $$.datetimeId = "bb-".concat(+new Date()), $$.initClip(), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], $$.axisTimeFormat = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
      $$.defaultAxisTimeFormat = function (d) {
        var isZoomed = isDragZoom ? _this.zoomScale : _this.zoomScale && $$.x.orgDomain().toString() !== _this.zoomScale.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return $$.axisTimeFormat(specifier)(d);
      }, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
        x: {
          size: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      }, $$.rotated_padding_left = 30, $$.rotated_padding_right = isRotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.inputType = $$.convertInputType(), $$.axes.subx = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
    }
  }, {
    key: "initWithData",
    value: function initWithData(data) {
      var $$ = this,
          config = $$.config;
      $$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom();
      var bindto = {
        element: config.bindto,
        classname: "bb"
      };

      if (isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $$.selectChart.empty() && ($$.selectChart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].body.appendChild(browser["document"].createElement("div")))), $$.selectChart.html("").classed(bindto.classname, !0), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.hasType("gauge") && (config.legend_show = !1), $$.updateSizes(), $$.updateScales(!0), $$.x && ($$.x.domain(sortValue($$.getXDomain($$.data.targets))), $$.subX.domain($$.x.domain()), $$.orgXDomain = $$.x.domain()), $$.y && ($$.y.domain($$.getYDomain($$.data.targets, "y")), $$.subY.domain($$.y.domain())), $$.y2 && ($$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subY2 && $$.subY2.domain($$.y2.domain())), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
        var isTouch = $$.inputType === "touch";
        $$.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
          return callFn(config.onover, $$);
        }).on(isTouch ? "touchend" : "mouseleave", function () {
          return callFn(config.onout, $$);
        });
      }

      config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
        return $$.defs.append(function () {
          return p.node;
        });
      }), $$.updateSvgSize();
      // Define regions
      var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

      // data.onmin/max callback
      if ($$.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", "".concat(config_classes.text, " ").concat(config_classes.empty)).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
      .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", $$.clipPath), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g.".concat(config_classes.regions)).attr("class", config_classes.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), config.oninit.call($$), $$.redraw({
        withTransition: !1,
        withTransform: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withTransitionForAxis: !1,
        initializing: !0
      }), config.data_onmin || config.data_onmax) {
        var minMax = $$.getMinMaxData();
        callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
      } // Bind resize event


      $$.bindResize(), $$.api.element = $$.selectChart.node();
    }
  }, {
    key: "initChartElements",
    value: function initChartElements() {
      var $$ = this;
      ["Bar", "Radar", "Line", "Bubble", "Arc", "Gauge", "Pie"].forEach(function (v) {
        $$["init".concat(v)]();
      }), notEmpty($$.config.data_labels) && $$.initText();
    }
  }, {
    key: "getChartElements",
    value: function getChartElements() {
      var $$ = this;
      return {
        chart: $$.selectChart,
        svg: $$.svg,
        defs: $$.defs,
        main: $$.main,
        tooltip: $$.tooltip,
        legend: $$.legend,
        title: $$.title,
        grid: $$.grid,
        arc: $$.arcs,
        bar: {
          bars: $$.mainBar
        },
        line: {
          lines: $$.mainLine,
          areas: $$.mainArea,
          circles: $$.mainCircle
        },
        text: {
          texts: $$.mainText
        }
      };
    }
  }, {
    key: "smoothLines",
    value: function smoothLines(el, type) {
      type === "grid" && el.each(function () {
        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            _map = ["x1", "x2", "y1", "y2"].map(function (v) {
          return Math.ceil(g.attr(v));
        }),
            _map2 = slicedToArray_default()(_map, 4),
            x1 = _map2[0],
            x2 = _map2[1],
            y1 = _map2[2],
            y2 = _map2[3];

        g.attr({
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        });
      });
    }
    /**
     * Update size values
     * @param {Boolean} isInit If is called at initialization
     * @private
     */

  }, {
    key: "updateSizes",
    value: function updateSizes(isInit) {
      var $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          hasArc = $$.hasArcType(),
          legend = {
        width: $$.legend ? $$.getLegendWidth() : 0,
        height: $$.legend ? $$.getLegendHeight() : 0
      },
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legend.height,
          xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
          subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
          subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
      isInit || $$.setContainerSize(), $$.margin = isRotated ? {
        top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        // for top tick text
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      }, $$.margin2 = isRotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: subchartXAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      }, $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      }, $$.updateSizeForLegend && $$.updateSizeForLegend(legend), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = isRotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = isRotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legend.width + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1);
    }
    /**
     * Update targeted element with given data
     * @param {Object} targets Data object formatted as 'target'
     * @private
     */

  }, {
    key: "updateTargets",
    value: function updateTargets(targets) {
      var $$ = this; // Text

      $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
    }
    /**
     * Display targeted elements
     * @private
     */

  }, {
    key: "showTargets",
    value: function showTargets() {
      var $$ = this;
      $$.svg.selectAll(".".concat(config_classes.target)).filter(function (d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", "1");
    }
  }, {
    key: "getWithOption",
    value: function getWithOption(options) {
      var withOptions = {
        Y: !0,
        Subchart: !0,
        Transition: !0,
        EventRect: !0,
        Dimension: !0,
        TrimXDomain: !0,
        Transform: !1,
        UpdateXDomain: !1,
        UpdateOrgXDomain: !1,
        Legend: !1,
        UpdateXAxis: "UpdateXDomain",
        TransitionForExit: "Transition",
        TransitionForAxis: "Transition"
      };
      return Object.keys(withOptions).forEach(function (key) {
        var defVal = withOptions[key];
        isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with".concat(key), defVal);
      }), withOptions;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          transitionsValue = arguments.length > 1 ? arguments[1] : undefined,
          $$ = this,
          main = $$.main,
          config = $$.config,
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          initializing = options.initializing,
          flow = options.flow,
          wth = $$.getWithOption(options),
          duration = wth.Transition ? config.transition_duration : 0,
          durationForExit = wth.TransitionForExit ? duration : 0,
          durationForAxis = wth.TransitionForAxis ? duration : 0,
          transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
      initializing && config.tooltip_init_show || $$.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), $$.updateXgridFocus(), config.data_empty_label_text && main.select("text.".concat(config_classes.text, ".").concat(config_classes.empty)).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(duration, durationForExit), $$.mainText && main.selectAll(".".concat(config_classes.selectedCircles)).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && ($$.redrawEventRect(), $$.bindZoomEvent()), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
    }
    /**
     * Redraw axis
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} wth
     * @param {Ojbect} transitions
     * @param {Object} flow
     * @private
     */

  }, {
    key: "redrawAxis",
    value: function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
      var tickValues,
          intervalForCulling,
          xDomainForZoom,
          $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          hasZoom = !!$$.zoomScale;
      // show/hide if manual culling needed
      if (!hasZoom && $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), $$.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && (tickValues = $$.axis.updateXAxisTickValues(targetsToShow))) : $$.xAxis && ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = $$.x.orgDomain()), ["y", "y2"].forEach(function (key) {
        var axis = $$[key];

        if (axis) {
          var tickValues = config["axis_".concat(key, "_tick_values")],
              tickCount = config["axis_".concat(key, "_tick_count")];

          if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
            var domain = axis.domain();
            $$["".concat(key, "Axis")].tickValues($$.axis.generateTickValues(domain, domain.every(function (v) {
              return v === 0;
            }) ? 1 : tickCount, $$.isTimeSeriesY()));
          }
        }
      }), $$.axis.redraw(transitions, hasArcType, isInit), $$.axis.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis) && targetsToShow.length) if (config.axis_x_tick_culling && tickValues) {
        for (var i = 1; i < tickValues.length; i++) if (tickValues.length / i < config.axis_x_tick_culling_max) {
          intervalForCulling = i;
          break;
        }

        $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).each(function (d) {
          var index = tickValues.indexOf(d);
          index >= 0 && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("display", index % intervalForCulling ? "none" : "block");
        });
      } else $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).style("display", "block"); // Update sub domain

      wth.Y && ($$.subY && $$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2 && $$.subY2.domain($$.getYDomain(targetsToShow, "y2")));
    }
    /**
     * Generate redraw list
     * @param {Object} targetsToShow targets data to be shown
     * @param {Object} flow
     * @param {Object} duration
     * @param {Boolean} withSubchart whether or not to show subchart
     * @private
     */

  }, {
    key: "generateRedrawList",
    value: function generateRedrawList(targetsToShow, flow, duration, withSubchart) {
      var $$ = this,
          config = $$.config,
          shape = $$.getDrawShape();
      config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
      // generate flow
      var flowFn = flow && $$.generateFlow({
        targets: targetsToShow,
        flow: flow,
        duration: flow.duration,
        shape: shape,
        xv: $$.xv.bind($$)
      }),
          isTransition = (duration || flowFn) && $$.isTabVisible(),
          redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
          afterRedraw = flow || config.onrendered ? function () {
        flowFn && flowFn(), callFn(config.onrendered, $$);
      } : null;
      if (afterRedraw) // Only use transition when current tab is visible.
        if (isTransition) {
          // Wait for end of transitions for callback
          var waitForDraw = $$.generateWait(); // transition should be derived from one transition

          Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
            redrawList.reduce(function (acc, t1) {
              return acc.concat(t1);
            }, []).forEach(function (t) {
              return waitForDraw.add(t);
            });
          }).call(waitForDraw, afterRedraw);
        } else afterRedraw(); // update fadein condition

      $$.mapToIds($$.data.targets).forEach(function (id) {
        $$.withoutFadeIn[id] = !0;
      });
    }
    /**
     * Get the shape draw function
     * @return {Object}
     * @private
     */

  }, {
    key: "getDrawShape",
    value: function getDrawShape() {
      var $$ = this,
          isRotated = $$.config.axis_rotated,
          hasRadar = $$.hasType("radar"),
          shape = {
        type: {},
        indices: {}
      };

      // setup drawer - MEMO: these must be called after axis updated
      if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
        var indices = $$.getShapeIndices($$.isLineType);

        if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
          var _indices = $$.getShapeIndices($$.isAreaType);

          shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
        }
      }

      if ($$.hasType("bar")) {
        var _indices2 = $$.getShapeIndices($$.isBarType);

        shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
      }

      return shape.pos = {
        xForText: $$.generateXYForText(shape.indices, !0),
        yForText: $$.generateXYForText(shape.indices, !1),
        // generate circle x/y functions depending on updated params
        cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
        cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
      }, shape;
    }
  }, {
    key: "getRedrawList",
    value: function getRedrawList(shape, flow, flowFn, isTransition) {
      var $$ = this,
          config = $$.config,
          hasArcType = $$.hasArcType(),
          _shape$pos = shape.pos,
          cx = _shape$pos.cx,
          cy = _shape$pos.cy,
          xForText = _shape$pos.xForText,
          yForText = _shape$pos.yForText,
          list = [];

      if (!hasArcType) {
        var _shape$type = shape.type,
            area = _shape$type.area,
            bar = _shape$type.bar,
            line = _shape$type.line;
        (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition));
      }

      return (!hasArcType || $$.hasType("radar")) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
    }
  }, {
    key: "updateAndRedraw",
    value: function updateAndRedraw() {
      var transitions,
          options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          $$ = this,
          config = $$.config;
      options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
    }
  }, {
    key: "redrawWithoutRescale",
    value: function redrawWithoutRescale() {
      this.redraw({
        withY: !1,
        withSubchart: !1,
        withEventRect: !1,
        withTransitionForAxis: !1
      });
    }
  }, {
    key: "isTimeSeries",
    value: function isTimeSeries() {
      return this.config.axis_x_type === "timeseries";
    }
  }, {
    key: "isCategorized",
    value: function isCategorized() {
      return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
    }
  }, {
    key: "isCustomX",
    value: function isCustomX() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    }
  }, {
    key: "isTimeSeriesY",
    value: function isTimeSeriesY() {
      return this.config.axis_y_type === "timeseries";
    }
  }, {
    key: "getTranslate",
    value: function getTranslate(target) {
      var x,
          y,
          index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0,
          $$ = this,
          config = $$.config,
          isRotated = config.axis_rotated,
          padding = 0;
      if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel($$.margin.left), y = asHalfPixel($$.margin.top);else if (target === "context") x = asHalfPixel($$.margin2.left), y = asHalfPixel($$.margin2.top);else if (target === "legend") x = $$.margin3.left, y = $$.margin3.top;else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : $$.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? $$.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : $$.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subx") x = 0, y = isRotated ? 0 : $$.height2;else if (target === "arc") x = $$.arcWidth / 2, y = $$.arcHeight / 2;else if (target === "radar") {
        var _$$$getRadarSize = $$.getRadarSize(),
            _$$$getRadarSize2 = slicedToArray_default()(_$$$getRadarSize, 1),
            width = _$$$getRadarSize2[0];

        x = $$.width / 2 - width, y = asHalfPixel($$.margin.top);
      }
      return "translate(".concat(x, ", ").concat(y, ")");
    }
  }, {
    key: "initialOpacity",
    value: function initialOpacity(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? "1" : "0";
    }
  }, {
    key: "initialOpacityForCircle",
    value: function initialOpacityForCircle(d) {
      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
    }
  }, {
    key: "opacityForCircle",
    value: function opacityForCircle(d) {
      var opacity = this.config.point_show ? "1" : "0";
      return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
    }
  }, {
    key: "opacityForText",
    value: function opacityForText() {
      return this.hasDataLabel() ? "1" : "0";
    }
  }, {
    key: "xx",
    value: function xx(d) {
      var fn = this.config.zoom_enabled && this.zoomScale ? this.zoomScale : this.x;
      return d ? fn(d.x) : null;
    }
  }, {
    key: "xv",
    value: function xv(d) {
      var $$ = this,
          value = $$.getBaseValue(d);
      return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = $$.config.axis_x_categories.indexOf(value)), Math.ceil($$.x(value));
    }
  }, {
    key: "yv",
    value: function yv(d) {
      var $$ = this,
          yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;
      return Math.ceil(yScale($$.getBaseValue(d)));
    }
  }, {
    key: "subxx",
    value: function subxx(d) {
      return d ? this.subX(d.x) : null;
    }
  }, {
    key: "transformMain",
    value: function transformMain(withTransition, transitions) {
      var xAxis,
          yAxis,
          y2Axis,
          $$ = this;
      transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select(".".concat(config_classes.axisX)), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select(".".concat(config_classes.axisY)), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select(".".concat(config_classes.axisY2)), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select(".".concat(config_classes.chartArcs)).attr("transform", $$.getTranslate("arc"));
    }
  }, {
    key: "transformAll",
    value: function transformAll(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
    }
  }, {
    key: "updateSvgSize",
    value: function updateSvgSize() {
      var $$ = this,
          brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), $$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#".concat($$.clipId), "#".concat($$.clipIdForGrid)]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#".concat($$.clipIdForXAxis)).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForYAxis)).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForSubchart)).select("rect").attr("width", $$.width).attr("height", brushSize.height), $$.svg.select(".".concat(config_classes.zoomRect)).attr("width", $$.width).attr("height", $$.height);
    }
  }, {
    key: "updateDimension",
    value: function updateDimension(withoutAxis) {
      var $$ = this;
      withoutAxis || ($$.xAxis && $$.config.axis_rotated ? ($$.xAxis.create($$.axes.x), $$.subXAxis.create($$.axes.subx)) : ($$.yAxis && $$.yAxis.create($$.axes.y), $$.y2Axis && $$.y2Axis.create($$.axes.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
    }
  }, {
    key: "bindResize",
    value: function bindResize() {
      var $$ = this,
          config = $$.config;
      $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(config.onresize.bind($$)), config.resize_auto && $$.resizeFunction.add(function () {
        $$.resizeTimeout && (browser["window"].clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = browser["window"].setTimeout(function () {
          $$.api.flush(!1, !0);
        }, 200);
      }), $$.resizeFunction.add(config.onresized.bind($$)), browser["window"].addEventListener("resize", $$.resizeFunction);
    }
  }, {
    key: "generateResize",
    value: function generateResize() {
      function callResizeFunctions() {
        resizeFunctions.forEach(function (f) {
          return f();
        });
      }

      var resizeFunctions = [];
      return callResizeFunctions.add = function (f) {
        return resizeFunctions.push(f);
      }, callResizeFunctions.remove = function (f) {
        return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
      }, callResizeFunctions;
    }
  }, {
    key: "endall",
    value: function endall(transition, callback) {
      var n = 0;
      transition.each(function () {
        return ++n;
      }).on("end", function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

        --n || callback.apply.apply(callback, [this].concat(args));
      });
    }
  }, {
    key: "generateWait",
    value: function generateWait() {
      var transitionsToWait = [],
          f = function (transition, callback) {
        function loop() {
          var done = 0;
          transitionsToWait.forEach(function (t) {
            if (t.empty()) return void done++;

            try {
              t.transition();
            } catch (e) {
              done++;
            }
          }), timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
        }

        var timer;
        loop();
      };

      return f.add = function (transition) {
        isArray(transition) ? transitionsToWait = transitionsToWait.concat(transition) : transitionsToWait.push(transition);
      }, f;
    }
  }, {
    key: "parseDate",
    value: function parseDate(date) {
      var parsedDate,
          $$ = this;
      return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '".concat(date, "' to Date object")), parsedDate;
    }
  }, {
    key: "isTabVisible",
    value: function isTabVisible() {
      return !browser["document"].hidden;
    }
  }, {
    key: "convertInputType",
    value: function convertInputType() {
      var $$ = this,
          config = $$.config,
          isMobile = browser["window"].navigator && "maxTouchPoints" in browser["window"].navigator && browser["window"].navigator.maxTouchPoints > 0 || !1,
          hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in browser["window"],
          hasTouch = !1;
      return config.interaction_inputType_touch && (hasTouch = "ontouchmove" in browser["window"] || browser["window"].DocumentTouch && browser["document"] instanceof browser["window"].DocumentTouch), hasMouse && "mouse" || hasTouch && "touch" || null;
    }
    /**
     * Call plugin hook
     * @param {String} phase The lifecycle phase
     * @private
     */

  }, {
    key: "callPluginHook",
    value: function callPluginHook(phase) {
      for (var _this2 = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

      this.config.plugins.forEach(function (v) {
        phase === "$beforeInit" && (v.$$ = _this2, _this2.api.plugins.push(v)), v[phase].apply(v, args);
      });
    }
  }]), ChartInternal;
}();


// CONCATENATED MODULE: ./src/internals/Chart.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access primary node elements
 * @name Chart#$
 * @type {Object}
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @instance
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart = function Chart(config) {
  classCallCheck_default()(this, Chart);

  var $$ = new ChartInternal_ChartInternal(this);
  /**
   * Plugin instance array
   * @name Chart#plugins
   * @type {Array}
   * @instance
   * @memberof Chart
   * @example
   *  var chart = bb.generate({
   *     ...
   *     plugins: [
   *        new bb.plugin.stanford({ ... }),
   *        new PluginA()
   *     ]
   *  });
   *
   *  chart.plugins; // [Stanford, PluginA] - instance array
   */

  // bind "this" to nested API
  this.plugins = [], this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), this.$ = $$.getChartElements(), $$.afterInit(config), function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this);
};


// CONCATENATED MODULE: ./src/config/Options.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */
var Options_Options = function Options() {
  return classCallCheck_default()(this, Options), {
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set zoom options
     * @name zoom
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [zoom.enabled=false] Enable zooming.
     * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
     *  - **Available types:**
     *    - wheel
     *    - drag
     * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
     *  If true set, y domain will be updated according to the zoomed region.
     * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
     * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
     * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
     * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
     *  Specified function receives the zoom event.
     * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
     *  Specified function receives the zoomed domain.
     * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
     *  Specified function receives the zoomed domain.
     * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
     * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
     * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
     * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
     * @example
     *  zoom: {
     *      enabled: {
              *          type: "drag"
              *      },
     *      rescale: true,
     *      extent: [1, 100]  // enable more zooming
     *      x: {
     *          min: -1,  // set min range
     *          max: 10  // set max range
     *      },
     *      onzoomstart: function(event) { ... },
     *      onzoom: function(domain) { ... },
     *      onzoomend: function(domain) { ... },
     *
     *      // show reset button when is zoomed-in
     *      resetButton: true,
     *
     *      // customized text value for reset zoom button
     *      resetButton: {
     *          text: "Unzoom"
     *      }
     *  }
     */
    zoom_enabled: undefined,
    zoom_extent: undefined,
    zoom_privileged: !1,
    zoom_rescale: !1,
    zoom_onzoom: undefined,
    zoom_onzoomstart: undefined,
    zoom_onzoomend: undefined,
    zoom_resetButton: !0,
    zoom_x_min: undefined,
    zoom_x_max: undefined,

    /**
     * Interaction options
     * @name interaction
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
     *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
     * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
     * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
     * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
     * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
     * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
     * @example
     * interaction: {
              *    enabled: false,
              *    brighten: false,
              *    inputType: {
              *        mouse: true,
              *        touch: false
              *
              *        // or declare preventDefault explicitly.
              *        // In this case touch inputType is enabled by default
              *        touch: {
              *            preventDefault: true
              *
              *            // or threshold pixel value (pixel moved from touchstart to touchmove)
              *            preventDefault: 5
              *        }
              *    }
     * }
     */
    interaction_enabled: !0,
    interaction_brighten: !0,
    interaction_inputType_mouse: !0,
    interaction_inputType_touch: {},

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onover: function() {
     *   ...
     * }
     */
    onover: function onover() {},

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onout: function() {
     *   ...
     * }
     */
    onout: function onout() {},

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onresize: function() {
     *   ...
     * }
     */
    onresize: function onresize() {},

    /**
     * SSet a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onresized: function() {
     *   ...
     * }
     */
    onresized: function onresized() {},

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onbeforeinit: function() {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * oninit: function() {
     *   ...
     * }
     */
    oninit: function oninit() {},

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default function(){}
     * @example
     * onafterinit: function() {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * onrendered: function() {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Specify the key of x values in the data.<br><br>
     * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
     * @name datax
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
              *   x: "date"
     * }
     */
    data_x: undefined,

    /**
     * Specify the keys of the x values for each data.<br><br>
     * This option can be used if we want to show the data that has different x values.
     * @name dataxs
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   xs: {
              *      data1: "x1",
              *      data2: "x2"
              *   }
     * }
     */
    data_xs: {},

    /**
     * Set a format specifier to parse string specifed as x.
     * @name dataxFormat
     * @memberof Options
     * @type {String}
     * @default %Y-%m-%d
     * @example
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "01012019", "02012019", "03012019"],
     *        ["data1", 30, 200, 100]
     *    ],
     *    // Format specifier to parse as datetime for given 'x' string value
     *    xFormat: "%m%d%Y"
     * },
     * axis: {
     *    x: {
     *        type: "timeseries"
     *    }
     * }
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     */
    data_xFormat: "%Y-%m-%d",

    /**
     * Set localtime format to parse x axis.
     * @name dataxLocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xLocaltime: false
     * }
     */
    data_xLocaltime: !0,

    /**
     * Sort on x axis.
     * @name dataxSort
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
              *   xSort: false
     * }
     */
    data_xSort: !0,

    /**
     * Converts data id value
     * @name dataidConverter
     * @memberof Options
     * @type {Function}
     * @default function(id) { return id; }
     * @example
     * data: {
              *    idConverter: function(id) {
              *       // when id is 'data1', converts to be 'data2'
              *       // 'data2' should be given as the initial data value
              *       if (id === "data1") {
              *          return "data2";
              *       } else {
              *          return id;
              *       }
              *    }
     * }
     */
    data_idConverter: function data_idConverter(id) {
      return id;
    },

    /**
     * Set custom data name.
     * @name datanames
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
     * @example
     * data: {
              *   names: {
              *     data1: "Data Name 1",
              *     data2: "Data Name 2"
              *   }
     * }
     */
    data_names: {},

    /**
     * Set custom data class.<br><br>
     * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
     * @name dataclasses
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
              *   classes: {
              *     data1: "additional-data1-class",
              *     data2: "additional-data2-class"
              *   }
     * }
     */
    data_classes: {},

    /**
     * Set groups for the data for stacking.
     * @name datagroups
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * data: {
              *   groups: [
              *     ["data1", "data2"],
              *     ["data3"]
              *   ]
     * }
     */
    data_groups: [],

    /**
     * Set y axis the data related to. y and y2 can be used.
     * @name dataaxes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   axes: {
     *     data1: "y",
     *     data2: "y2"
     *   }
     * }
     */
    data_axes: {},

    /**
     * Set chart type at once.<br><br>
     * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
     * **Available Values:**
     * - area
     * - area-line-range
     * - area-spline
     * - area-spline-range
     * - area-step
     * - bar
     * - bubble
     * - donut
     * - gauge
     * - line
     * - pie
     * - radar
     * - scatter
     * - spline
     * - step
     * @name datatype
     * @memberof Options
     * @type {String}
     * @default line
     * @example
     * data: {
     *    type: "bar"
     * }
     */
    data_type: undefined,

    /**
     * Set chart type for each data.<br>
     * This setting overwrites data.type setting.
     * - **NOTE:** `radar` type can't be combined with other types.
     * @name datatypes
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   types: {
     *     data1: "bar",
     *     data2: "spline"
     *   }
     * }
     */
    data_types: {},

    /**
     * Set labels options
     * @name datalabels
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [data.labels=false] Show or hide labels on each data points
     * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
     * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
     * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
     *  - `v` is the value of the data point where the label is shown.
     *  - `id` is the id of the data where the label is shown.
     *  - `i` is the index of the data point where the label is shown.
     *  - `j` is the sub index of the data point where the label is shown.<br><br>
     * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
    	 * @property {String|Object} [data.labels.colors] Set label text colors.
     * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
     * @property {NUmber} [data.labels.position.y=0] y coordinate position, relative the original.
     * @memberof Options
     * @type {Object}
     * @default {}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
     * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
     * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
     * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
     * @example
     * data: {
     *   labels: true,
     *
     *   // or set specific options
     *   labels: {
     *     format: function(v, id, i, j) { ... },
     *
     *     // it's possible to set for each data
     *     format: {
     *         data1: function(v, id, i, j) { ... },
     *         ...
     *     },
     *
     *     // align text to center of the 'bar' shape (works only for 'bar' type)
     *     centered: true,
     *
     *     // apply for all label texts
     *     colors: "red",
     *
     *     // or set different colors per dataset
     *     // for not specified dataset, will have the default color value
     *     colors: {
     *        data1: "yellow",
     *        data3: "green"
     *     },
     *
     *     // set x, y coordinate position
     *     position: {
     *        x: -10,
     *        y: 10
     *     }
     *   }
     * }
     */
    data_labels: {},
    data_labels_colors: undefined,
    data_labels_position: {},

    /**
     *  This option changes the order of stacking data and pieces of pie/donut.
     *  - If `null` specified, it will be the order the data loaded.
     *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
     *
     *  **Available Values:**
     *  - `desc`: In descending order
     *  - `asc`: In ascending order
     *  - `null`: It keeps the data load order
     *  - `function(data1, data2) { ... }`: Array.sort compareFunction
     * @name dataorder
     * @memberof Options
     * @type {String|Function|null}
     * @default desc
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
     * @example
     * data: {
     *   // in descending order (default)
     *   order: "desc"
     *
     *   // in ascending order
     *   order: "asc"
     *
     *   // keeps data input order
     *   order: null
     *
     *   // specifying sort function
     *   order: function(a, b) {
     *       // param data passed format
     *       {
     *          id: "data1", id_org: "data1", values: [
     *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
     *              ...
     *          ]
     *       }
     *   }
     * }
     */
    data_order: "desc",

    /**
     * Define regions for each data.<br>
     * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
     * - The object type should be as:
     *   - start {Number}: Start data point number. If not set, the start will be the first data point.
     *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
     *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
     * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
     * @name dataregions
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   regions: {
     *     data1: [{
     *         start: 1,
     *         end: 2,
     *         style: {
     *             dasharray: "5 2"
     *         }
     *     }, {
     *         start: 3
     *     }],
     *     ...
     *   }
     * }
     */
    data_regions: {},

    /**
     * Set color converter function.<br><br>
     * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
     * @name datacolor
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
     * @example
     * data: {
     *   color: function(color, d) { ... }
     * }
     */
    data_color: undefined,

    /**
     * Set color for each data.
     * @name datacolors
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * data: {
     *   colors: {
     *     data1: "#ff0000",
     *     data2: function(d) {
     *        return "#000";
     *     }
     *     ...
     *   }
     * }
     */
    data_colors: {},

    /**
     * Hide each data when the chart appears.<br><br>
     * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
     * @name datahide
     * @memberof Options
     * @type {Boolean|Array}
     * @default false
     * @example
     * data: {
     *   // all of data will be hidden
     *   hide: true
     *
     *   // specified data will be hidden
     *   hide: ["data1", ...]
     * }
     */
    data_hide: !1,

    /**
     * Filter values to be shown
     * The data value is the same as the returned by `.data()`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     * @name datafilter
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * data: {
     *   // filter for id value
     *   filter: function(v) {
     *      // v: [{id: "data1", id_org: "data1", values: [
     *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
     *      //    }, ...]
     *      return v.id !== "data1";
     *   }
     */
    data_filter: undefined,

    /**
     * Set the stacking to be normalized
     * - **NOTE:**
     *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
     *   - y Axis will be set in percentage value (0 ~ 100%)
     *   - Must have postive values
     * @name datastacknormalize
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
     * @example
     * data: {
        *   stack: {
        *      normalize: true
        *   }
        * }
     */
    data_stack_normalize: !1,

    /**
     * Set data selection enabled<br><br>
     * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
     * @name dataselectionenabled
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
     * @example
     * data: {
     *    selection: {
     *       enabled: true
     *    }
     * }
     */
    data_selection_enabled: !1,

    /**
     * Set grouped selection enabled.<br><br>
     * If this option set true, multiple data points that have same x value will be selected by one selection.
     * @name dataselectiongrouped
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       grouped: true
     *    }
     * }
     */
    data_selection_grouped: !1,

    /**
     * Set a callback for each data point to determine if it's selectable or not.<br><br>
     * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
     * @name dataselectionisselectable
     * @memberof Options
     * @type {Function}
     * @default function() { return true; }
     * @example
     * data: {
     *    selection: {
     *       isselectable: function(d) { ... }
     *    }
     * }
     */
    data_selection_isselectable: function data_selection_isselectable() {
      return !0;
    },

    /**
     * Set multiple data points selection enabled.<br><br>
     * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
     * @name dataselectionmultiple
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * data: {
     *    selection: {
     *       multiple: false
     *    }
     * }
     */
    data_selection_multiple: !0,

    /**
     * Enable to select data points by dragging.
     * If this option set true, data points can be selected by dragging.
     * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
     * @name dataselectiondraggable
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * data: {
     *    selection: {
     *       draggable: true
     *   }
     * }
     */
    data_selection_draggable: !1,

    /**
     * Set a callback for click event on each data point.<br><br>
     * This callback will be called when each data point clicked and will receive d and element as the arguments. d is the data clicked and element is the element clicked. In this callback, this will be the Chart object.
     * @name dataonclick
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onclick: function(d, element) { ... }
     * }
     */
    data_onclick: function data_onclick() {},

    /**
     * Set a callback for mouse/touch over event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves onto each data point and will receive d as the argument. d is the data where mouse cursor moves onto. In this callback, this will be the Chart object.
     * @name dataonover
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onover: function(d) { ... }
     * }
     */
    data_onover: function data_onover() {},

    /**
     * Set a callback for mouse/touch out event on each data point.<br><br>
     * This callback will be called when mouse cursor or via touch moves out each data point and will receive d as the argument. d is the data where mouse cursor moves out. In this callback, this will be the Chart object.
     * @name dataonout
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onout: function(d) { ... }
     * }
     */
    data_onout: function data_onout() {},

    /**
     * Set a callback for on data selection.
     * @name dataonselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onselected: function data_onselected() {},

    /**
     * Set a callback for on data un-selection.
     * @name dataonunselected
     * @memberof Options
     * @type {Function}
     * @default function() {}
     * @example
     * data: {
     *     onunselected: function(d, element) {
     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
     *        // element - <circle>
     *        ...
     *    }
     * }
     */
    data_onunselected: function data_onunselected() {},

    /**
     * Set a callback for minimum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmin
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmin: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmin: undefined,

    /**
     * Set a callback for maximum data
     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
     * @name dataonmax
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
     * @example
     *  onmax: function(data) {
     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
        *    ...
     *  }
     */
    data_onmax: undefined,

    /**
     * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
     * @name dataurl
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
     * @example
     * data: {
     *     url: "/data/test.csv"
     * }
     */
    data_url: undefined,

    /**
     * XHR header value
     * - **NOTE:** Should be used with `data.url` option
     * @name dataheaders
     * @memberof Options
     * @type {String}
     * @default undefined
     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
     * @example
     * data: {
     *     url: "/data/test.csv",
     *     headers: {
     *        "Content-Type": "text/xml",
     *        ...
     *     }
     * }
     */
    data_headers: undefined,

    /**
     * Parse a JSON object for data. See also data.keys.
     * @name datajson
     * @memberof Options
     * @type {Object}
     * @default undefined
     * @see [datakeys](#.data%25E2%2580%25A4keys)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_json: undefined,

    /**
     * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
     * @name datarows
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
     * @example
     * data: {
     *   rows: [
     *     ["A", "B", "C"],
     *     [90, 120, 300],
     *     [40, 160, 240],
     *     [50, 200, 290],
     *     [120, 160, 230],
     *     [80, 130, 300],
     *     [90, 220, 320]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   rows: [
     *      ["data1", "data2"],
     *      [
     *        // or {high:150, mid: 140, low: 110}, 120
     *        [150, 140, 110], 120
     *      ],
     *      [[155, 130, 115], 55],
     *      [[160, 135, 120], 60]
     *   ],
     *   types: {
     *       data1: "area-line-range",
     *       data2: "line"
     *   }
     * }
     */
    data_rows: undefined,

    /**
     * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
     * @name datacolumns
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
     * @example
     * data: {
     *   columns: [
     *      ["data1", 30, 20, 50, 40, 60, 50],
     *      ["data2", 200, 130, 90, 240, 130, 220],
     *      ["data3", 300, 200, 160, 400, 250, 250]
     *   ]
     * }
     *
     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
     * // - an array of [high, mid, low] data following the order
     * // - or an object with 'high', 'mid' and 'low' key value
     * data: {
     *   columns: [
     *      ["data1",
     *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
     *          [150, 140, 110],
     *          [150, 140, 110]
     *      ]
     *   ],
     *   type: "area-line-range"
     * }
     */
    data_columns: undefined,

    /**
     * Used if loading JSON via data.url.
     * @name datamimeType
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     mimeType: "json"
     * }
     */
    data_mimeType: undefined,

    /**
     * Choose which JSON object keys correspond to desired data.
     * - **NOTE:** Only for JSON object given as array.
     * @name datakeys
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * data: {
     *     json: [
     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
     *     ],
     *     keys: {
     *       // x: "name", // it's possible to specify 'x' when category axis
     *       value: ["upload", "download"]
     *     }
     * }
     */
    data_keys: undefined,

    /**
     * Set text label to be displayed when there's no data to show.
     * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
     * @name dataemptylabeltext
     * @memberof Options
     * @type {String}
     * @default ""
     * @example
     * data: {
     *   empty: {
     *     label: {
     *       text: "No Data"
     *     }
     *   }
     * }
     */
    data_empty_label_text: "",

    /**
     * Set subchart options
     * @name subchart
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
     * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
     * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
     * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
     * @property {Number} [subchart.size.height] Change the height of the subchart.
     * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
     *  Specified function receives the current zoomed x domain.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
     * @example
     *  subchart: {
     * 		axis: {
     * 			x: {
     * 				show: true,
     * 				tick: {
     * 					show: true,
     * 					text: {
     * 						show: false
     * 					}
     * 				}
     * 			}
     * 		},
     *      show: true,
     *      size: {
     *          height: 20
     *      },
     *      onbrush: function(domain) { ... }
     *  }
     */
    subchart_show: !1,
    subchart_size_height: 60,
    subchart_axis_x_show: !0,
    subchart_axis_x_tick_show: !0,
    subchart_axis_x_tick_text_show: !0,
    subchart_onbrush: function subchart_onbrush() {},

    /**
     * Set color of the data values
     * @name color
     * @memberof Options
     * @type {Object}
     * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
     * @property {Array} [color.pattern] custom color pattern
     * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
     *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
     *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
     *    - `bb-colorize-pattern-red`
     *    - `bb-colorize-pattern-fff`
     * @property {Object} [color.threshold] color threshold for gauge and tooltip color
     * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
     * @property {Array} [color.threshold.values] Threshold values for each steps
     * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
     * @example
     *  color: {
     *      pattern: ["#1f77b4", "#aec7e8", ...],
     *
     *      // Set colors' patterns
     *      // it should return an array of SVGPatternElement
     *      tiles: function() {
     *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
     *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
     *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
     *
     *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
     *         pattern.setAttribute("width", "32");
     *         pattern.setAttribute("height", "32");
     *
     *         g.style.fill = "#000";
     *         g.style.opacity = "0.2";
              *
     *         circle1.setAttribute("cx", "3");
     *         circle1.setAttribute("cy", "3");
     *         circle1.setAttribute("r", "3");
              *
     *         g.appendChild(circle1);
     *         pattern.appendChild(g);
     *
     *         return [pattern];
     *      },
     *
     *      // for threshold usage, pattern values should be set for each steps
     *      pattern: ["grey", "green", "yellow", "orange", "red"],
     *      threshold: {
     *          unit: "value",
     *
     *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
     *          values: [10, 20, 30, 40, 50],
     *
     *          // the equation for max:
     *          // - unit == 'value': max => 30
     *          // - unit != 'value': max => value*100/30
     *          max: 30
     *      },
     *
     *      // set all data to 'red'
     *      onover: "red",
     *
     *      // set different color for data
     *      onover: {
     *          data1: "red",
     *          data2: "yellow"
     *      },
     *
     *      // will pass data object to the callback
     *      onover: function(d) {
     *          return d.id === "data1" ? "red" : "green";
     *      }
     *  }
     */
    color_pattern: [],
    color_tiles: undefined,
    color_threshold: {},
    color_onover: undefined,

    /**
     * Legend options
     * @name legend
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [legend.show=true] Show or hide legend.
     * @property {Boolean} [legend.hide=false] Hide legend
     *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
     * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
     * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
     *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
     *    - {=COLOR}: data color value
     *    - {=TITLE}: data title value
     *  - If set `function` value, will pass following arguments to the given function:
     *   - title {String}: data's id value
     *   - color {String}: color string
     *   - data {Array}: data array
     * @property {String} [legend.position=bottom] Change the position of legend.<br>
     *  Available values are: `bottom`, `right` and `inset` are supported.
     * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
     *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
     *  - **anchor** decides the position of the legend:
     *   - top-left
     *   - top-right
     *   - bottom-left
     *   - bottom-right
     *  - **x** and **y**:
     *   - set the position of the legend based on the anchor.
     *  - **step**:
     *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
     * @property {Boolean} [legend.equally=false] Set to all items have same width size.
     * @property {Boolean} [legend.padding=0] Set padding value
     * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
     * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
     * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
     * @property {Number} [legend.item.tile.width=10] Set width of item tile element
     * @property {Number} [legend.item.tile.height=10] Set height of item tile element
     * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
     * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
     * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
     * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
     * @example
     *  legend: {
     *      show: true,
     *      hide: true,
     *      //or hide: "data1"
              *      //or hide: ["data1", "data2"]
     *      contents: {
     *          bindto: "#legend",   // <ul id='legend'></ul>
     *
     *          // will be as: <li style='background-color:#1f77b4'>data1</li>
     *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
     *
     *          // or using function
     *          template: function(id, color, data) {
     *               // if you want omit some legend, return falsy value
     *               if (title !== "data1") {
     *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
     *               }
     *          }
     *      },
              *      position: "bottom",  // bottom, right, inset
     *      inset: {
     *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
     *          x: 20,
     *          y: 10,
     *          step: 2
     *      },
              *      equally: false,
              *      padding: 10,
              *      item: {
     *          onclick: function(id) { ... },
     *          onover: function(id) { ... },
     *          onout: function(id) { ... },
     *
     *          // set tile's size
     *          tile: {
     *              width: 20,
     *              height: 15
     *          }
     *      },
     *      usePoint: true
     *  }
     */
    legend_show: !0,
    legend_hide: !1,
    legend_contents_bindto: undefined,
    legend_contents_template: undefined,
    legend_position: "bottom",
    legend_inset_anchor: "top-left",
    legend_inset_x: 10,
    legend_inset_y: 10,
    legend_inset_step: undefined,
    legend_item_onclick: undefined,
    legend_item_onover: undefined,
    legend_item_onout: undefined,
    legend_equally: !1,
    legend_padding: 0,
    legend_item_tile_width: 10,
    legend_item_tile_height: 10,
    legend_usePoint: !1,

    /**
     * Switch x and y axis position.
     * @name axisrotated
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   rotated: true
     * }
     */
    axis_rotated: !1,

    /**
     * Set clip-path attribute for x axis element
     * @name axisxclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo]()
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_x_clipPath: !0,

    /**
     * Show or hide x axis.
     * @name axisxshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     show: false
     *   }
     * }
     */
    axis_x_show: !0,

    /**
     * Set type of x axis.<br><br>
     * **Available Values:**
     * - timeseries
     * - category
     * - indexed
     * @name axisxtype
     * @memberof Options
     * @type {String}
     * @default indexed
     * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
     * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
     * @example
     * axis: {
     *   x: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_x_type: "indexed",

    /**
     * Set how to treat the timezone of x values.<br>
     * If true, treat x value as localtime. If false, convert to UTC internally.
     * @name axisxlocaltime
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     localtime: false
     *   }
     * }
     */
    axis_x_localtime: !0,

    /**
     * Set category names on category axis.
     * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
     * @name axisxcategories
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     * axis: {
     *   x: {
     *     categories: ["Category 1", "Category 2", ...]
     *   }
     * }
     */
    axis_x_categories: [],

    /**
     * centerize ticks on category axis.
     * @name axisxtickcentered
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       centered: true
     *     }
     *   }
     * }
     */
    axis_x_tick_centered: !1,

    /**
     * A function to format tick value. Format string is also available for timeseries data.
     * @name axisxtickformat
     * @memberof Options
     * @type {Function|String}
     * @default undefined
     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *        // for timeseries, a 'datetime' object is given as parameter
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *
     *       // for category, index(Number) and categoryName(String) are given as parameter
     *       format: function(index, categoryName) {
     *           return categoryName.substr(0, 10);
     *       },
     *
     *        // for timeseries format specifier
     *        format: "%Y-%m-%d %H:%M:%S"
     *     }
     *   }
     * }
     */
    axis_x_tick_format: undefined,

    /**
     * Setting for culling ticks.<br><br>
     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
     * We can change the number of ticks to be shown by axis.x.tick.culling.max.
     * @name axisxtickculling
     * @memberof Options
     * @type {Boolean}
     * @default
     * - true for indexed axis and timeseries axis
     * - false for category axis
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: false
     *     }
     *   }
     * }
     */
    axis_x_tick_culling: {},

    /**
     * The number of tick texts will be adjusted to less than this value.
     * @name axisxtickcullingmax
     * @memberof Options
     * @type {Number}
     * @default 10
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       culling: {
     *           max: 5
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_culling_max: 10,

    /**
     * The number of x axis ticks to show.<br><br>
     * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
     * @name axisxtickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_x_tick_count: undefined,

    /**
     * Show or hide x axis tick line.
     * @name axisxtickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_x_tick_show: !0,

    /**
     * Show or hide x axis tick text.
     * @name axisxticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_show: !0,

    /**
     * Set the x Axis tick text's position relatively its original position
     * @name axisxticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_x_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Fit x axis ticks.
     * - **true**: ticks will be positioned nicely to have same intervals.
     * - **false**: ticks will be positioned according to x value of the data points.
     * @name axisxtickfit
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
     * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       fit: false
     *     }
     *   }
     * }
     */
    axis_x_tick_fit: !0,

    /**
     * Set the x values of ticks manually.<br><br>
     * If this option is provided, the position of the ticks will be determined based on those values. This option works with timeseries data and the x values will be parsed accoding to the type of the value and data.xFormat option.
     * @name axisxtickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       values: [1, 2, 4, 8, 16, 32, ...]
     *     }
     *   }
     * }
     */
    axis_x_tick_values: null,

    /**
     * Rotate x axis tick text.<br>
     * If you set negative value, it will rotate to opposite direction.
     * @name axisxtickrotate
     * @memberof Options
     * @type {Number}
     * @default 0
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       rotate: 60
     *     }
     *   }
     * }
     */
    axis_x_tick_rotate: 0,

    /**
     * Show x axis outer tick.
     * @name axisxtickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_x_tick_outer: !0,

    /**
     * Set tick text to be multiline
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
     * @name axisxtickmultiline
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       multiline: false
     *     }
     *   }
     * }
     * @example
     * // example of line break with '\n'
     * // In this case, 'axis.x.tick.width' is ignored
     * data: {
     *    x: "x",
     *    columns: [
     *        ["x", "long\ntext", "Another\nLong\nText"],
     *        ...
     *    ],
     * }
     */
    axis_x_tick_multiline: !0,

    /**
     * Set tick width
     * - **NOTE:**
     *  > When x tick text contains `\n`, this option is ignored.
     * @name axisxtickwidth
     * @memberof Options
     * @type {Number}
     * @default null
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       width: 50
     *     }
     *   }
     * }
     */
    axis_x_tick_width: null,

    /**
     * Set to display system tooltip(via 'title' attribute) for tick text
     * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
     * @name axisxticktooltip
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   x: {
     *     tick: {
     *       tooltip: true
     *     }
     *   }
     * }
     */
    axis_x_tick_tooltip: !1,

    /**
     * Set max value of x axis range.
     * @name axisxmax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     max: 100
     *   }
     * }
     */
    axis_x_max: undefined,

    /**
     * Set min value of x axis range.
     * @name axisxmin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     min: -100
     *   }
     * }
     */
    axis_x_min: undefined,

    /**
     * Set padding for x axis.<br><br>
     * If this option is set, the range of x axis will increase/decrease according to the values.
     * If no padding is needed in the rage of x axis, 0 should be set.
     * - **NOTE:**
     *   The padding values aren't based on pixels. It differs according axis types<br>
     *   - **category:** The unit of tick value
     *     ex. the given value `1`, is same as the width of 1 tick width
     *   - **timeseries:** Numeric time value
     *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
     * @name axisxpadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   x: {
     *     padding: {
     *       // when axis type is 'category'
     *       left: 1,  // set left padding width of equivalent value of a tick's width
     *       right: 0.5  // set right padding width as half of equivalent value of tick's width
     *
     *       // when axis type is 'timeseries'
     *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
     *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
     *     }
     *   }
     * }
     */
    axis_x_padding: {},

    /**
     * Set height of x axis.<br><br>
     * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
     * @name axisxheight
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     height: 20
     *   }
     * }
     */
    axis_x_height: undefined,

    /**
     * Set default extent for subchart and zoom. This can be an array or function that returns an array.
     * @name axisxextent
     * @memberof Options
     * @type {Array|Function}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     // extent range as a pixel value
     *     extent: [0, 200],
     *
     *     // when axis is 'timeseries', parsable datetime string
     *     extent: ["2019-03-01", "2019-03-05"],
     *
     *     // return extent value
     *     extent: function(domain, scale) {
     *    	 var extent = domain.map(function(v) {
     *     	    return scale(v);
     *     	 });
     *
     *   	 // it should return a format of array
     *   	 // ex) [0, 584]
     *     	 return extent;
     *     }
     *   }
     * }
     */
    axis_x_extent: undefined,

    /**
     * Set label on x axis.<br><br>
     *  You can set x axis label and change its position by this option. string and object can be passed and we can change the poisiton by passing object that has position key. Available position differs according to the axis direction (vertical or horizontal). If string set, the position will be the default.
     *  - **If it's horizontal axis:**
     *    - inner-right [default]
     *    - inner-center
     *    - inner-left
     *    - outer-right
     *    - outer-center
     *    - outer-left
     *  - **If it's vertical axis:**
     *    - inner-top [default]
     *    - inner-middle
     *    - inner-bottom
     *    - outer-top
     *    - outer-middle
     *    - outer-bottom
     * @name axisxlabel
     * @memberof Options
     * @type {String|Object}
     * @default undefined
     * @example
     * axis: {
     *   x: {
     *     label: "Your X Axis"
     *   }
     * }
     *
     * axis: {
     *   x: {
     *     label: {
     *        text: "Your X Axis",
     *        position: "outer-center"
     *     }
     *   }
     * }
     */
    axis_x_label: {},

    /**
     * Set additional axes for x Axis.
     * - **NOTE:** Axis' scale is based on x Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisxaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * x: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_x_axes: [],

    /**
     * Set clip-path attribute for y axis element
     * @name axisyclipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    axis_y_clipPath: !0,

    /**
     * Show or hide y axis.
     * @name axisyshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     show: false
     *   }
     * }
     */
    axis_y_show: !0,

    /**
     * Set type of y axis.<br><br>
     * **Available Values:**
     *   - timeseries
     *   - category
     *   - indexed
     * @name axisytype
     * @memberof Options
     * @type {String}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     type: "timeseries"
     *   }
     * }
     */
    axis_y_type: undefined,

    /**
     * Set max value of y axis.
     * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymax
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     max: 1000
     *   }
     * }
     */
    axis_y_max: undefined,

    /**
     * Set min value of y axis.
     * - **NOTE:**
     *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
     * @name axisymin
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     min: 1000
     *   }
     * }
     */
    axis_y_min: undefined,

    /**
     * Change the direction of y axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisyinverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inverted: true
     *   }
     * }
     */
    axis_y_inverted: !1,

    /**
     * Set center value of y axis.
     * @name axisycenter
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     center: 0
     *   }
     * }
     */
    axis_y_center: undefined,

    /**
     * Show y axis inside of the chart.
     * @name axisyinner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y: {
     *     inner: true
     *   }
     * }
     */
    axis_y_inner: !1,

    /**
     * Set label on y axis.<br><br>
     * You can set y axis label and change its position by this option. This option works in the same way as axis.x.label.
     * @name axisylabel
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     label: "Your Y Axis"
     *   }
     * }
     *
     * axis: {
     *   y: {
     *     label: {
     *        text: "Your Y Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y_label: {},

    /**
     * Set formatter for y axis tick text.<br><br>
     * This option accepts d3.format object as well as a function you define.
     * @name axisytickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       format: function(x) {
     *           return x.getFullYear();
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_format: undefined,

    /**
     * Show y axis outer tick.
     * @name axisytickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y_tick_outer: !0,

    /**
     * Set y axis tick values manually.
     * @name axisytickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y_tick_values: null,
    axis_y_tick_rotate: 0,

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisytickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y_tick_count: undefined,

    /**
     * Show or hide y axis tick line.
     * @name axisytickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y_tick_show: !0,

    /**
    * Show or hide y axis tick text.
    * @name axisyticktextshow
    * @memberof Options
    * @type {Boolean}
    * @default true
    * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
    * @example
    * axis: {
    *   y: {
    *     tick: {
    *       text: {
    *           show: false
    *       }
    *     }
    *   }
    * }
    */
    axis_y_tick_text_show: !0,

    /**
     * Set the y Axis tick text's position relatively its original position
     * @name axisyticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y axis ticks.<br><br>
     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
     * @name axisyticktime
     * @memberof Options
     * @private
     * @type {Object}
     * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
     * @example
     * axis: {
     *   y: {
     *     tick: {
     *       time: {
     *          // ticks at 15-minute intervals
     *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
     *          value: d3.timeMinute.every(15)
     *       }
     *     }
     *   }
     * }
     */
    // @TODO: not fully implemented yet
    axis_y_tick_time_value: undefined,

    /**
     * Set padding for y axis.<br><br>
     * You can set padding for y axis to create more space on the edge of the axis.
     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
     *
     * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
     * @name axisypadding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y: {
     *     padding: {
     *       top: 0,
     *       bottom: 0
     *     }
     *   }
     * }
     */
    axis_y_padding: {},

    /**
     * Set default range of y axis.<br><br>
     * This option set the default value for y axis when there is no data on init.
     * @name axisydefault
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y_default: undefined,

    /**
     * Set additional axes for y Axis.
     * - **NOTE:** Axis' scale is based on y Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisyaxes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y_axes: [],

    /**
     * Show or hide y2 axis.
     * @name axisy2show
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     show: true
     *   }
     * }
     */
    axis_y2_show: !1,

    /**
     * Set max value of y2 axis.
     * @name axisy2max
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     max: 1000
     *   }
     * }
     */
    axis_y2_max: undefined,

    /**
     * Set min value of y2 axis.
     * @name axisy2min
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     min: -1000
     *   }
     * }
     */
    axis_y2_min: undefined,

    /**
     * Change the direction of y2 axis.<br><br>
     * If true set, the direction will be from the top to the bottom.
     * @name axisy2inverted
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inverted: true
     *   }
     * }
     */
    axis_y2_inverted: !1,

    /**
     * Set center value of y2 axis.
     * @name axisy2center
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     center: 0
     *   }
     * }
     */
    axis_y2_center: undefined,

    /**
     * Show y2 axis inside of the chart.
     * @name axisy2inner
     * @memberof Options
     * @type {Boolean}
     * @default false
     * @example
     * axis: {
     *   y2: {
     *     inner: true
     *   }
     * }
     */
    axis_y2_inner: !1,

    /**
     * Set label on y2 axis.<br><br>
     * You can set y2 axis label and change its position by this option. This option works in the same way as axis.x.label.
     * @name axisy2label
     * @memberof Options
     * @type {String|Object}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     label: "Your Y2 Axis"
     *   }
     * }
     *
     * axis: {
     *   y2: {
     *     label: {
     *        text: "Your Y2 Axis",
     *        position: "outer-middle"
     *     }
     *   }
     * }
     */
    axis_y2_label: {},

    /**
     * Set formatter for y2 axis tick text.<br><br>
     * This option works in the same way as axis.y.format.
     * @name axisy2tickformat
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       format: d3.format("$,")
     *       //or format: function(d) { return "$" + d; }
     *     }
     *   }
     * }
     */
    axis_y2_tick_format: undefined,

    /**
     * Show or hide y2 axis outer tick.
     * @name axisy2tickouter
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       outer: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_outer: !0,

    /**
     * Set y2 axis tick values manually.
     * @name axisy2tickvalues
     * @memberof Options
     * @type {Array}
     * @default null
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       values: [100, 1000, 10000]
     *     }
     *   }
     * }
     */
    axis_y2_tick_values: null,

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2tickcount
     * @memberof Options
     * @type {Number}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       count: 5
     *     }
     *   }
     * }
     */
    axis_y2_tick_count: undefined,

    /**
     * Show or hide y2 axis tick line.
     * @name axisy2tickshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       show: false
     *     }
     *   }
     * }
     */
    axis_y2_tick_show: !0,

    /**
     * Show or hide y2 axis tick text.
     * @name axisy2ticktextshow
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *           show: false
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_show: !0,

    /**
     * Set the y2 Axis tick text's position relatively its original position
     * @name axisy2ticktextposition
     * @memberof Options
     * @type {Object}
     * @default {x: 0, y:0}
     * @example
     * axis: {
     *   y2: {
     *     tick: {
     *       text: {
     *         position: {
     *           x: 10,
     *           y: 10
     *         }
     *       }
     *     }
     *   }
     * }
     */
    axis_y2_tick_text_position: {
      x: 0,
      y: 0
    },

    /**
     * Set the number of y2 axis ticks.
     * - **NOTE:** This works in the same way as axis.y.tick.count.
     * @name axisy2padding
     * @memberof Options
     * @type {Object}
     * @default {}
     * @example
     * axis: {
     *   y2: {
     *     padding: {
     *       top: 100,
     *       bottom: 100
     *     }
     *   }
     * }
     */
    axis_y2_padding: {},

    /**
     * Set default range of y2 axis.<br><br>
     * This option set the default value for y2 axis when there is no data on init.
     * @name axisy2default
     * @memberof Options
     * @type {Array}
     * @default undefined
     * @example
     * axis: {
     *   y2: {
     *     default: [0, 1000]
     *   }
     * }
     */
    axis_y2_default: undefined,

    /**
     * Set additional axes for y2 Axis.
     * - **NOTE:** Axis' scale is based on y2 Axis value
     *
     * Each axis object should consist with following options:
     *
     * | Name | Type | Default | Description |
     * | --- | --- | --- | --- |
     * | tick.outer | Boolean | true | Show outer tick |
     * | tick.format | Function | - | Set formatter for tick text |
     * | tick.count | Number | - | Set the number of y axis ticks |
     * | tick.values | Array | - | Set tick values manually |
     * @name axisy2axes
     * @memberof Options
     * @type {Array}
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
     * @example
     * y2: {
     *    axes: [
     *      {
     *        tick: {
     *          outer: false,
     *          format: function(x) {
     *             return x + "%";
     *          },
     *          count: 2,
     *          values: [10, 20, 30]
     *        }
     *      },
     *      ...
     *    ]
     * }
     */
    axis_y2_axes: [],

    /**
     * Set related options
     * @name grid
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
     * @property {Boolean} [x.show=false] Show grids along x axis.
     * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
     *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
     *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
     * @property {Boolean} [y.show=false] Show grids along x axis.
     * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
     *  This option accepts array including object that has value, text, position and class.
     * @property {Number} [y.ticks=10] Number of y grids to be shown.
     * @property {Boolean} [focus.show=true] Show grids when focus.
     * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
     * @default undefined
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
     * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
     * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
     * @example
     * grid: {
     *   x: {
     *     show: true,
     *     lines: [
     *       {value: 2, text: "Label on 2"},
     *       {value: 5, text: "Label on 5", class: "label-5"},
     *       {value: 6, text: "Label on 6", position: "start"}
     *     ]
     *   },
     *   y: {
     *     show: true,
     *     lines: [
     *       {value: 100, text: "Label on 100"},
     *       {value: 200, text: "Label on 200", class: "label-200"},
     *       {value: 300, text: "Label on 300", position: 'middle'}
     *     ],
     *     ticks: 5
     *   },
     *   front: true,
     *   focus: {
     *      show: false
     *   },
     *   lines: {
     *      front: false
     *   }
     * }
     */
    grid_x_show: !1,
    grid_x_type: "tick",
    grid_x_lines: [],
    grid_y_show: !1,
    grid_y_lines: [],
    grid_y_ticks: 10,
    grid_focus_show: !0,
    grid_front: !1,
    grid_lines_front: !0,

    /**
     * Set point options
     * @name point
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [point.show=true] Whether to show each point in line.
     * @property {Number|Function} [point.r=2.5] The radius size of each point.
     *  - **NOTE:** Disabled for 'bubble' type
     * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
     * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
     *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
     * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
     * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
     * @property {String} [point.type="circle"] The type of point to be drawn
     * - **NOTE:**
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
     * - **NOTE:**
     *  - This is an `experimental` feature and can have some unexpected behaviors.
     *  - If chart has 'bubble' type, only circle can be used.
     *  - For IE, non circle point expansions are not supported due to lack of transform support.
     * - **Available Values:**
     *  - circle
     *  - rectangle
     *  - svg shape tag interpreted as string<br>
     *    (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
     * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
     * @example
     *  point: {
     *      show: false,
     *      r: 5,
     *
     *      // or customize the radius
     *      r: function(d) {
     *          ...
     *          return r;
     *      },
     *
     *      focus: {
     *          expand: {
     *              enabled: true,
     *              r: 1
     *          }
     *      },
     *      select: {
     *          r: 3
     *      },
     *
     *      // having lower value, means how closer to be for interaction
     *      sensitivity: 3,
     *
     *      // valid values are "circle" or "rectangle"
     *      type: "rectangle",
     *
     *      // or indicate as pattern
    	 *      pattern: [
    	 *        "circle",
    	 *        "rectangle",
    	 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
    	 *     ],
     *  }
     */
    point_show: !0,
    point_r: 2.5,
    point_sensitivity: 10,
    point_focus_expand_enabled: !0,
    point_focus_expand_r: undefined,
    point_pattern: [],
    point_select_r: undefined,
    point_type: "circle",

    /**
     * Set line options
     * @name line
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
     *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
     * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
     * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
     * **Available values:**
     * - step
     * - step-before
     * - step-after
     * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
     * @example
     *  line: {
     *      connectNull: true,
     *      classes: [
     *          "line-class1",
     *          "line-class2"
     *      ],
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ]
     *  }
     */
    line_connectNull: !1,
    line_step_type: "step",
    line_classes: undefined,
    line_point: !0,

    /**
     * Set bar options
     * @name bar
     * @memberof Options
     * @type {Object}
     * @property {Number} [bar.padding=0] The padding pixel value between each bar.
     * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
     * - **NOTE:** Works only for non-stacked bar
     * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
    	 * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
     * @property {Number} [bar.width] Change the width of bar chart.
     * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.max] The maximum width value for ratio.
     * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
     * - **NOTE:**
     *   - Works only for non-stacked bar
     *   - Bars are centered accoding its total width value
     * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
     * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
     * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
     * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
     * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
     * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
     * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
     * @example
     *  bar: {
     *      padding: 1,
     *
     *      // the 'radius' option can be used only for non-stacking bars
     *      radius: 10,
     *      // or
     *      radius: {
     *          ratio: 0.5
     *      }
     *
     *      // will not have offset between each bar elements for interaction
     *      sensitivity: 0,
     *
     *      width: 10,
     *
     *      // or
     *      width: {
     *          ratio: 0.2,
     *          max: 20
     *      },
     *
     *      // or specify width per dataset
     *      width: {
     *          data1: 20,
     *          data2: {
     *              ratio: 0.2,
     *              max: 20
     *          }
     *      },
     *
     *      zerobased: false
     *  }
     */
    bar_padding: 0,
    bar_radius: undefined,
    bar_radius_ratio: undefined,
    bar_sensitivity: 2,
    bar_width: undefined,
    bar_width_ratio: .6,
    bar_width_max: undefined,
    bar_zerobased: !0,

    /**
     * Set bubble options
     * @name bubble
     * @memberof Options
     * @type {Object}
     * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
     * @example
     *  bubble: {
     *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
     *      // And the lesser will have radius relatively from tha max value.
     *      maxR: 50,
     *
     *      // or set radius callback
     *      maxR: function(d) {
     *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
     *          ...
     *          return Math.sqrt(d.value * 2);
     *      }
     *  }
     */
    bubble_maxR: 35,

    /**
     * Set area options
     * @name area
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
     * @property {Boolean} [area.above=false] Set background area above the data chart line.
     * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
     * Or customize by giving below object value:
     *  - x {Array}: `x1`, `x2` value
     *  - y {Array}: `y1`, `y2` value
     *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
     * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
     * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
     * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
     * @example
     *  area: {
     *      zerobased: false,
     *      above: true,
     *
     *      // will generate follwing linearGradient:
     *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
     *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
     *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
     *      // </linearGradient>
     *      linearGradient: true,
     *
     *      // Or customized gradient
     *      linearGradient: {
     *      	x: [0, 0],  // x1, x2 attributes
     *      	y: [0, 0],  // y1, y2 attributes
     *      	stops: [
     *      		// offset, stop-color, stop-opacity
     *      		[0, "#7cb5ec", 1],
     *
     *      		// setting 'null' for stop-color, will set its original data color
     *      		[0.5, null, 0],
     *
     *      		// setting 'function' for stop-color, will pass data id as argument.
     *      		// It should return color string or null value
     *      		[1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
     *      	]
     *      }
     *  }
     */
    area_zerobased: !0,
    area_above: !1,
    area_linearGradient: !1,

    /**
     * Set pie options
     * @name pie
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
     * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
     * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
     * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
     * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
     * @property {Number} [pie.padAngle=0] Set padding between data.
     * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
     * @example
     *  pie: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *              ...
     *              return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *
     *      // disable expand transition for interaction
     *      expand: false,
     *
     *      // set duration of expand transition to 500ms.
     *      expand: {
     *          duration: 500
     *      },
     *
     *      innerRadius: 0,
     *
     *      // set different innerRadius for each data
     *      innerRadius: {
     *      	data1: 10,
     *      	data2: 0
     *      }
     *
     *      padAngle: 0.1,
     *      padding: 0
     *  }
     */
    pie_label_show: !0,
    pie_label_format: undefined,
    pie_label_threshold: .05,
    pie_label_ratio: undefined,
    pie_expand: {},
    pie_expand_duration: 50,
    pie_innerRadius: 0,
    pie_padAngle: 0,
    pie_padding: 0,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Set gauge options
     * @name gauge
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
     * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
     * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
     * @property {Function} [gauge.label.extents] Set customized min/max label text.
     * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
     * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
     * @property {Number} [gauge.min=0] Set min value of the gauge.
     * @property {Number} [gauge.max=100] Set max value of the gauge.
     * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2]
     * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
     * @property {String} [gauge.units] Set units of the gauge.
     * @property {Number} [gauge.width] Set width of gauge chart.
     * @example
     *  gauge: {
     *      fullCircle: false,
     *      label: {
     *          show: false,
     *          format: function(value, ratio) {
     *              return value;
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          extents: function(value, isMax) {
    	 *              return (isMax ? "Max:" : "Min:") + value;
     *          }
     *      },
     *      expand: false,
     *
     *      // or set duration
     *      expand: {
     *          duration: 20
     *      },
     *      min: -100,
     *      max: 200,
     *      title: "Title Text",
     *      units: "%",
     *      width: 10
     *  }
     */
    gauge_fullCircle: !1,
    gauge_label_show: !0,
    gauge_label_format: undefined,
    gauge_min: 0,
    gauge_max: 100,
    gauge_startingAngle: -1 * Math.PI / 2,
    gauge_label_extents: undefined,
    gauge_title: "",
    gauge_units: undefined,
    gauge_width: undefined,
    gauge_expand: {},
    gauge_expand_duration: 50,

    /**
     * Set donut options
     * @name donut
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
     * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
     * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
     * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
     * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
     * @property {Number} [donut.width] Set width of donut chart.
     * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
     * @property {Number} [donut.padAngle=0] Set padding between data.
     * @example
     *  donut: {
     *      label: {
     *          show: false,
     *          format: function(value, ratio, id) {
     *              return d3.format("$")(value);
     *
     *              // to multiline, return with '\n' character
     *              // return value +"%\nLine1\n2Line2";
     *          },
     *          threshold: 0.1,
     *
     *          // set ratio callback. Should return ratio value
     *          ratio: function(d, radius, h) {
     *          	...
     *          	return ratio;
     *          },
     *          // or set ratio number
     *          ratio: 0.5
     *      },
     *      expand: false,
     *      width: 10,
     *      padAngle: 0.2,
     *      title: "Donut Title"
     *
     *      // title with line break
     *      title: "Title1\nTitle2"
     *  }
     */
    donut_label_show: !0,
    donut_label_format: undefined,
    donut_label_threshold: .05,
    donut_label_ratio: undefined,
    donut_width: undefined,
    donut_title: "",
    donut_expand: {},
    donut_expand_duration: 50,
    donut_padAngle: 0,

    /**
     * Set spline options
     * - **Available interpolation type values:**
     *  - basis (d3.curveBasis)
     *  - basis-closed (d3.curveBasisClosed)
     *  - basis-open (d3.curveBasisOpen)
     *  - bundle (d3.curveBundle)
     *  - cardinal (d3.curveCardinal)
     *  - cardinal-closed (d3.curveCardinalClosed)
     *  - cardinal-open (d3.curveCardinalOpen)
     *  - catmull-rom (d3.curveCatmullRom)
     *  - catmull-rom-closed (d3.curveCatmullRomClosed)
     *  - catmull-rom-open (d3.curveCatmullRomOpen)
     *  - monotone-x (d3.curveMonotoneX)
     *  - monotone-y (d3.curveMonotoneY)
     *  - natural (d3.curveNatural)
     *  - linear-closed (d3.curveLinearClosed)
     *  - linear (d3.curveLinear)
     *  - step (d3.curveStep)
     *  - step-after (d3.curveStepAfter)
     *  - step-before (d3.curveStepBefore)
     * @name spline
     * @memberof Options
     * @type {Object}
     * @property {String} [spline.interpolation.type="cardinal"]
     * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
     * @example
     *  spline: {
     *      interpolation: {
     *          type: "cardinal"
     *      }
     *  }
     */
    spline_interpolation_type: "cardinal",

    /**
     * Set radar options
     * - **NOTE:**
     *  > When x tick text contains `\n`, it's used as line break.
     * @name radar
     * @memberof Options
     * @type {Object}
     * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
     * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
     * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
     * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
     * @property {Number} [radar.level.depth=3] Set the level depth.
     * @property {Boolean} [radar.level.show=true] Show or hide level.
     * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
     * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
     * @property {Number} [radar.size.ratio=0.87] Set size ratio.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
     * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
     * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
     * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
     * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
     * @example
     *  radar: {
     *      axis: {
     *          max: 50,
     *          line: {
     *              show: false
     *          },
     *          text: {
     *              show: false
     *          }
     *      },
     *      direction: {
     *          clockwise: true
     *      },
     *      level: {
     *          show: false,
     *          text: {
     *              format: function(x) {
     *                  return x + "%";
     *              },
     *              show: true
     *          }
     *      },
     *      size: {
     *          ratio: 0.7
     *      }
     *  }
     */
    radar_axis_max: undefined,
    radar_axis_line_show: !0,
    radar_axis_text_show: !0,
    radar_level_depth: 3,
    radar_level_show: !0,
    radar_level_text_format: function radar_level_text_format(x) {
      return x % 1 === 0 ? x : x.toFixed(2);
    },
    radar_level_text_show: !0,
    radar_size_ratio: .87,
    radar_direction_clockwise: !1,

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class. The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end. If not specified, the edge values will be used. If timeseries x axis, date string, Date object and unixtime integer can be used. If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: [],

    /**
     * Tooltip options
     * @name tooltip
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
     * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
     * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
     *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
     * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
     * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
     * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
     *  Specified function receives x of the data point to show.
     * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
     *  If undefined returned, the row of that value will be skipped.
     * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
     *  This option can be used to modify the tooltip position by returning object that has top and left.
     * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
     *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
     * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
     * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.
     *  - **NOTE:** When is specified, will not be updating tooltip's position.
     *  - Within template, below syntax will be replaced using template-like syntax string:
     *    - {{ ... }}: the doubly curly brackets indicate loop block for data rows
     *    - {=CLASS_TOOLTIP}: default tooltip class name `bb-tooltip`.
     *    - {=CLASS_TOOLTIP_NAME}: default tooltip data class name (ex. `bb-tooltip-name-data1`)
     *    - {=TITLE}: title value
     *    - {=COLOR}: data color
     *    - {=VALUE}: data value
     * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
     *  - **NOTE:** It should contain `{ key: Array, ... }` value
     *    - 'key' name is used as substitution within template as '{=KEY}'
     *    - The value array length should match with the data length
     * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
     * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
     * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
     * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
     * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
     * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
     * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
     * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
     *  **Available Values:**
     *  - `desc`: In descending data value order
     *  - `asc`: In ascending data value order
     *  - `null`: It keeps the data display order<br>
     *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
     *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
     *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
     * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
     * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
     * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
     * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
     * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
     * @example
     *  tooltip: {
     *      show: true,
     *      doNotHide: true,
     *      grouped: false,
     *      format: {
     *          title: function(x) { return "Data " + x; },
     *          name: function(name, ratio, id, index) { return name; },
     *          value: function(value, ratio, id, index) { return ratio; }
     *      },
     *      position: function(data, width, height, element) {
     *          return {top: 0, left: 0}
    		 *      },
     *
    		 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
    		 *          return ... // formatted html as you want
     		 *      },
     *
     *       // specify tooltip contents using template
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
     *      		'}}</ul>'
     *      }
     *
     *       // with additional text value
     *       // - example of HTML returned:
     *       // <ul class="bb-tooltip">
     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
     *       // </ul>
     *       contents: {
     *      	bindto: "#tooltip",
     *      	text: {
     *      		// a) 'key' name is used as substitution within template as '{=KEY}'
     *      		// b) the length should match with the data length
     *      		VAR1: ["text1", "text2"],
     *      		VAR2: ["comment1", "comment2"],
     *      	},
     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
     *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
     *      		'}}</ul>'
     *      }
     		 *
     		 *      // sort tooltip data value display in ascending order
     		 *      order: "asc",
     		 *
     *      // specifying sort function
     *      order: function(a, b) {
     *         // param data passed format
     *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
     *           ...
     *      },
     *
     *      // show at the initialization
     *      init: {
     *          show: true,
     *          x: 2,
     *          position: {
     *              top: "150px",
     *              left: "250px"
     *          }
     *      },
     *
     *      // fires prior tooltip is shown
     *      onshow: function() { ...},
     *      // fires prior tooltip is hidden
     *      onhide: function() { ... },
     *      // fires after tooltip is shown
     *      onshown: function() { ... },
     *      // fires after tooltip is hidden
     *      onhidden: function() { ... },
     *
     *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
     *      // Useful for timeseries correlation
     *      linked: true,
     *
     *      // Specify name to interact those with the same name only.
     *      linked: {
     *          name: "some-group"
     *      }
     *  }
     */
    tooltip_show: !0,
    tooltip_doNotHide: !1,
    tooltip_grouped: !0,
    tooltip_format_title: undefined,
    tooltip_format_name: undefined,
    tooltip_format_value: undefined,
    tooltip_position: undefined,
    tooltip_contents: {},
    tooltip_init_show: !1,
    tooltip_init_x: 0,
    tooltip_init_position: {
      top: "0px",
      left: "50px"
    },
    tooltip_linked: !1,
    tooltip_linked_name: "",
    tooltip_onshow: function tooltip_onshow() {},
    tooltip_onhide: function tooltip_onhide() {},
    tooltip_onshown: function tooltip_onshown() {},
    tooltip_onhidden: function tooltip_onhidden() {},
    tooltip_order: null,

    /**
     * Set title options
     * @name title
     * @memberof Options
     * @type {Object}
     * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
     * @property {Number} [title.padding.top=0] Top padding value.
     * @property {Number} [title.padding.right=0] Right padding value.
     * @property {Number} [title.padding.bottom=0] Bottom padding value.
     * @property {Number} [title.padding.left=0] Left padding value.
     * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
     * @example
     *  title: {
     *      text: "Title Text",
     *
     *      // or Multiline title text
     *      text: "Main title text\nSub title text",
     *
     *      padding: {
     *          top: 10,
     *          right: 10,
     *          bottom: 10,
     *          left: 10
     *      },
     *      position: "center"
     *  }
     */
    title_text: undefined,
    title_padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    title_position: "center"
  };
};


// CONCATENATED MODULE: ./src/config/config.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getOptions: function getOptions() {
    return new Options_Options();
  },

  /**
   * Load configuration option
   * @param {Object} config User's generation config value
   * @private
   */
  loadConfig: function loadConfig(config) {
    var target,
        keys,
        read,
        thisConfig = this.config,
        find = function () {
      var key = keys.shift();
      return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
    };

    Object.keys(thisConfig).forEach(function (key) {
      target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/scale.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.zoomScale || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.xAxis.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    return this.axis.getId(id) === "y2" ? this.y2 : this.y;
  },
  getSubYScale: function getSubYScale(id) {
    return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit) {
    var updateXDomain = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.xMin = isRotated ? 1 : 0, $$.xMax = isRotated ? $$.height : $$.width, $$.yMin = isRotated ? 0 : $$.height, $$.yMax = isRotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = isRotated ? 0 : $$.height2, $$.subYMax = isRotated ? $$.width2 : 1;
    // update scales
    // x Axis
    var xDomain = updateXDomain && $$.x && $$.x.orgDomain(),
        xSubDomain = updateXDomain && $$.orgXDomain;
    // y Axis
    // update for arc
    $$.x = $$.getX($$.xMin, $$.xMax, xDomain, function () {
      return $$.xAxis.tickOffset();
    }), $$.subX = $$.getX($$.xMin, $$.xMax, xSubDomain, function (d) {
      return d % 1 ? 0 : $$.subXAxis.tickOffset();
    }), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getXAxisTickValues(), $$.xAxis = $$.axis.getXAxis("x", $$.x, config.axis_x_tick_outer, isInit), $$.subXAxis = $$.axis.getXAxis("subX", $$.subX, config.axis_x_tick_outer, isInit), $$.y = $$.getY($$.yMin, $$.yMax, $$.y ? $$.y.domain() : config.axis_y_default), $$.subY = $$.getY($$.subYMin, $$.subYMax, $$.subY ? $$.subY.domain() : config.axis_y_default), $$.yAxisTickValues = $$.axis.getYAxisTickValues(), $$.yAxis = $$.axis.getYAxis("y", $$.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && ($$.y2 = $$.getY($$.yMin, $$.yMax, $$.y2 ? $$.y2.domain() : config.axis_y2_default), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, $$.subY2 ? $$.subY2.domain() : config.axis_y2_default), $$.y2AxisTickValues = $$.axis.getY2AxisTickValues(), $$.y2Axis = $$.axis.getYAxis("y2", $$.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/internals/domain.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has".concat(isMin ? "Negative" : "Positive", "ValueInTargets")](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
        yMin = config["axis_".concat(axisId, "_min")],
        yMax = config["axis_".concat(axisId, "_max")],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_".concat(axisId, "_center")],
        isZeroBased = $$.hasType("bar", yTargets) && config.bar_zerobased || $$.hasType("area", yTargets) && config.area_zerobased,
        isInverted = config["axis_".concat(axisId, "_inverted")],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    if (yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, yTargets.length === 0) // use current domain if target of axisId is none
      return $$[axisId].domain();
    isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain($$.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_".concat(axisId, "_padding")];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_".concat(type)];
    return isDefined(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        firstX = xDomain[0],
        lastX = xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && ($$.x.domain(domain || sortValue($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? $$.orgXDomain : getBrushSelection($$).map($$.subX.invert);
      $$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        _zoomDomain = slicedToArray_default()(zoomDomain, 2),
        min = _zoomDomain[0],
        max = _zoomDomain[1];

    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/data/data.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return config.data_stack_normalize && config.data_groups.length;
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this;
    Object.keys(xs).forEach(function (id) {
      $$.config.data_xs[id] = xs[id];
    });
  },
  hasMultipleX: function hasMultipleX(xs) {
    return Object.keys(xs).map(function (id) {
      return xs[id];
    }).length > 1;
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this;
    return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  cloneTarget: function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  },
  updateXs: function updateXs() {
    var $$ = this,
        targets = $$.data.targets;
    targets.length && ($$.xs = [], targets[0].values.forEach(function (v) {
      $$.xs[v.index] = v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && $$.isAreaRangeType(data) && (value = $$.getAreaRangeData(data, "mid")), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(toConsumableArray_default()(value))), max = Math.max.apply(Math, [i ? max : -Infinity].concat(toConsumableArray_default()(value)));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.getCache(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.addCache(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.getCache("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.getCache(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.addCache(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, toConsumableArray_default()(this.data.targets.map(function (t) {
      return t.values.length;
    })));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget(targets) {
    var maxTarget,
        length = targets.length,
        max = 0;
    return length > 1 ? targets.forEach(function (t) {
      t.values.length > max && (maxTarget = t, max = t.values.length);
    }) : maxTarget = length ? targets[0] : null, maxTarget;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, toConsumableArray_default()(value)) : isObject(value) && "high" in value ? data.push.apply(data, toConsumableArray_default()(Object.values(value))) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = toConsumableArray_default()(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();

    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        minDist = $$.config.point_sensitivity;
    return values.filter(function (v) {
      return v && $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = $$.main.select(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(v.id), " .").concat(config_classes.bar, "-").concat(v.index)).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), values.filter(function (v) {
      return v && !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = ($$.zoomScale || $$.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_".concat(name)];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown.call(api).length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            $$.hiddenTargetIds.length && (total -= dataValues($$.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if ($$.hiddenTargetIds.length) {
          var hiddenSum = dataValues($$.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0)) / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(56);

// CONCATENATED MODULE: ./src/data/data.convert.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data,
        $$ = this;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_".concat(v);
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) $$.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = $$.convertJsonToData(data.json, data.keys);else if (data.rows) data = $$.convertRowsToData(data.rows);else if (data.columns) data = $$.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return data;
  },
  convertUrlToData: function convertUrlToData(url) {
    var _this = this,
        mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
        headers = arguments.length > 2 ? arguments[2] : undefined,
        keys = arguments.length > 3 ? arguments[3] : undefined,
        done = arguments.length > 4 ? arguments[4] : undefined,
        req = new XMLHttpRequest();

    headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.open("GET", url), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert".concat(capitalize(mimeType), "ToData")](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error("".concat(url, ": Something went wrong loading!"));
    }, req.send();
  },
  _convertCsvTsvToData: function _convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this._convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];

    for (var i = 1, len1 = rows.length; i < len1; i++) {
      var newRow = {};

      for (var j = 0, len2 = rows[i].length; j < len2; j++) {
        if (isUndefined(rows[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRow[keys[j]] = rows[i][j];
      }

      newRows.push(newRow);
    }

    return newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];

    for (var i = 0, len1 = columns.length; i < len1; i++) {
      var key = columns[i][0];

      for (var j = 1, len2 = columns[i].length; j < len2; j++) {
        if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(columns[i][j])) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
        newRows[j - 1][key] = columns[i][j];
      }
    }

    return newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || _this3.isTimeSeries() ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!xsData) throw new Error("x is not defined for id = \"".concat(id, "\"."));
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) ? isArray(value) || isObject(value) && value.high ? value : null : +d[id], isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(d[id]) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.addCache(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/data/data.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.resetCache();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      $$.load(data ? $$.convertDataToTargets(data) : null, args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.resetCache(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      $$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll(".".concat(config_classes.legendItem).concat($$.getTargetSelectorSuffix(id))).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// CONCATENATED MODULE: ./src/internals/category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var config = this.config;
    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(57);

// CONCATENATED MODULE: ./src/interactions/interaction.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.main.select(".".concat(config_classes.eventRects)).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll(".".concat(config_classes.eventRect)).remove(), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), isMultipleX) eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $$.eventRect
      var maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
      eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), eventRectUpdate = $$.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $$.updateEventRect(eventRectUpdate), $$.inputType !== "touch" || $$.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(".concat(config_classes.eventRect, "-?|s)"), "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client".concat(config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect();

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        if ($$.dragging || $$.flowing || $$.hasArcType()) return;
        preventEvent(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"]), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) && $$.cancelClick && ($$.cancelClick = !1);
    });
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        xScale = $$.zoomScale || $$.x,
        eventRectData = eventRectUpdate || $$.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = $$.width, h = $$.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        $$.updateXs();

        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? $$.height : $$.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = $$.data.xs[d.id][d.index];
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? $$.width : rectW, h = isRotated ? rectW : $$.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showXGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideXGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showXGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showXGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select(".".concat(config_classes.eventRect)).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.svg.select(".".concat(config_classes.eventRect)).style("cursor", null), $$.hideXGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      config.color_onover && $$.setOverColor(isOver, d, isArc), isArc ? callback(d) : (isOver && $$.expandCirclesBars(d, null, !0), !$$.isMultipleX() && $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(callback));
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover", function (d) {
      $$.dragging || $$.flowing || $$.hasArcType() || $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!($$.dragging || $$.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.svg.select(".".concat(config_classes.eventRect, "-").concat(index));
        $$.isStepType(d) && $$.config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index);
      }
    }).on("mouseout", function (d) {
      !$$.config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config;
    if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));
    var index = d.index;
    $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return $$.inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll(".".concat(config_classes.shapes).concat($$.getTargetSelectorSuffix(closest.id))).selectAll(".".concat(config_classes.shape, "-").concat(closest.index)).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = ".".concat(isMultipleX ? config_classes.eventRect : "".concat(config_classes.eventRect, "-").concat(index)),
        eventRect = $$.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/internals/size.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this;
    $$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_".concat(axisId, "_axes")].length,
        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? 10 + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset".concat(capitalize(key)), parent = this.selectChart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser["document"].body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.selectChart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $$.main.select(".".concat(leftAxisClass)).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $$.selectChart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this,
        position = $$.axis.getLabelPositionById(id);
    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        h = 30;
    return id !== "x" || config.axis_x_show ? id === "x" && config.axis_x_height ? config.axis_x_height : id !== "y" || config.axis_y_show ? id !== "y2" || config.axis_y2_show ? ((id === "x" && !isRotated && config.axis_x_tick_rotate || id === "y" && isRotated && config.axis_y_tick_rotate) && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - config["axis_".concat(id, "_tick_rotate")]) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10)) : $$.rotated_padding_top : !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10 : 8; // Calculate x/y axis height when tick rotated
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.xAxis.tickInterval());
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(58);

// CONCATENATED MODULE: ./src/shape/shape.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        indices = {},
        i = 0;
    return $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in indices) {
        indices[d.id] = indices[_row4];
        break;
      }

      isUndefined(indices[d.id]) && (indices[d.id] = i++);
    }), indices.__max__ = i - 1, indices;
  },
  getShapeX: function getShapeX(offset, targetsNum, indices, isSub) {
    var $$ = this,
        scale = isSub ? $$.subX : $$.zoomScale || $$.x,
        barPadding = $$.config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var index = d.id in indices ? indices[d.id] : 0,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = scale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(isStackNormalized ? $$.getRatio("index", d, !0) : d.value);
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        targetIds = targets.map(function (t) {
      return t.id;
    });
    return function (d, idx) {
      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          offset = y0,
          i = idx;
      return targets.forEach(function (t) {
        var rowValues = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values,
            values = rowValues.map(function (v) {
          return $$.isStackNormalized() ? $$.getRatio("index", v, !0) : v.value;
        });
        t.id === d.id || indices[t.id] !== indices[d.id] || targetIds.indexOf(t.id) < targetIds.indexOf(d.id) && ((isUndefined(rowValues[i]) || +rowValues[i].x !== +d.x) && (i = -1, rowValues.forEach(function (v, j) {
          var x1 = v.x.constructor === Date ? +v.x : v.x,
              x2 = d.x.constructor === Date ? +d.x : d.x;
          x1 === x2 && (i = j);
        })), i in rowValues && rowValues[i].value * d.value >= 0 && (offset += scale(values[i]) - y0));
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        type = $$.config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(59);

// CONCATENATED MODULE: ./src/shape/arc.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        padding = config.pie_padding,
        padAngle = $$.hasType("pie") && padding ? padding * .01 : config["".concat(config.data_type, "_padAngle")] ? config["".concat(config.data_type, "_padAngle")] : 0;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().padAngle(padAngle).sortValues($$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width;
    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2, $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6;
    var innerRadius = radius || (padding ? padding * ($$.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    $$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        radius = $$.innerRadius;
    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded(), $$.svgArcExpandedSub = $$.getSvgArcExpanded(.98);
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
          gStart = config.gauge_startingAngle,
          gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = $$.pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    return pie($$.filterTargetsToShow()).forEach(function (t) {
      found || t.data.id !== d.data.id || (found = !0, d = t);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        ir = $$.getInnerRadius(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radius).innerRadius(isNumber(ir) ? ir : 0),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius($$.radiusExpanded * (rate || 1));
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? arc.innerRadius($$.getInnerRadius(d))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        updated = $$.updateAngle(d),
        translate = "";

    if (updated && (!$$.hasType("gauge") || $$.hasMultiTargets())) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, $$.radius, h) : ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(".concat(x * ratio, ",").concat(y * ratio, ")");
    }

    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : null,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          isUnderThreshold = $$.hasType("gauge") || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this; // MEMO: avoid to cancel transition

    if ($$.transiting) {
      var interval = setInterval(function () {
        $$.transiting || (clearInterval(interval), $$.legend.selectAll(".".concat(config_classes.legendItemFocused)).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).each(function (d) {
      if ($$.shouldExpand(d.data.id) && d.value !== 0) {
        var expandDuration = $$.expandDuration(d.data.id);
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", $$.svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this;

    if (!$$.transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).selectAll("path").transition().duration(function (d) {
        return $$.expandDuration(d.data.id);
      }).attr("d", $$.svgArc), $$.svg.selectAll("".concat(config_classes.arc)).style("opacity", "1");
    }
  },
  expandDuration: function expandDuration(id) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config["".concat(type, "_expand_duration")] : 50;
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config["".concat(v, "_label_show")];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config["".concat(type, "_title")] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select(".".concat(config_classes.chartArcs)).selectAll(".".concat(config_classes.chartArc)).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this;
    $$.arcs = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-1.3, 1.3]);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arc)).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && (config.data_selection_isselectable(d) ? "pointer" : null);
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      $$.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      $$.transiting = !1;
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        isTouch = $$.inputType === "touch",
        isMouse = $$.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!$$.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser["document"].elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!$$.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var $$ = this,
        config = $$.config,
        main = $$.main,
        hasGauge = $$.hasType("gauge"),
        text = main.selectAll(".".concat(config_classes.chartArc)).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && !$$.hasMultiTargets() ? "".concat(Math.round($$.radius / 5), "px") : "";
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    });

    if (main.select(".".concat(config_classes.chartArcsTitle)).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          endAngle = (isFullCircle ? -4 : -1) * config.gauge_startingAngle;
      isFullCircle && text.attr("dy", "".concat(Math.round($$.radius / 14))), $$.arcs.select(".".concat(config_classes.chartArcsBackground)).attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: config.gauge_startingAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      }), $$.arcs.select(".".concat(config_classes.chartArcsGaugeUnit)).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select(".".concat(config_classes.chartArcsGaugeMin)).attr("dx", "".concat(-1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)), "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && $$.arcs.select(".".concat(config_classes.chartArcsGaugeMax)).attr("dx", "".concat($$.innerRadius + ($$.radius - $$.innerRadius) / 2, "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append("path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/shape/bar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  initBar: function initBar() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.main.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $$.mainBar = $$.main.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($$.mainBar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    return [(withTransition ? this.mainBar.transition(getRandom()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        tickInterval = axis.tickInterval($$.getMaxDataCount()),
        isGrouped = config.data_groups.length,
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.bar).concat(suffix));
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a".concat(radius, ",").concat(radius, " ").concat(isNegative ? "1 0 0" : "0 0 1", " ");
        pathRadius[+!isRotated] = "".concat(arc).concat(radius, ",").concat(radius), pathRadius[+isRotated] = "".concat(arc).concat([-radius, radius][isRotated ? "sort" : "reverse"]()), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H".concat(points[1][indexX] - radius, " ").concat(pathRadius[0], "V").concat(points[2][indexY] - radius, " ").concat(pathRadius[1], "H").concat(points[3][indexX]) : "V".concat(points[1][indexY] + (isNegative ? -radius : radius), " ").concat(pathRadius[0], "H").concat(points[2][indexX] - radius, " ").concat(pathRadius[1], "V").concat(points[3][indexY]);
      return "M".concat(points[0][indexX], ",").concat(points[0][indexY]).concat(path, "z");
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        axis = isSub ? $$.subXAxis : $$.xAxis,
        barTargetsNum = barIndices.__max__ + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list2 = slicedToArray_default()(list, 2),
        seg0 = _list2[0],
        seg1 = _list2[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/shape/bubble.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        cacheKey = "$baseLength",
        baseLength = $$.getCache(cacheKey);
    return baseLength || $$.addCache(cacheKey, baseLength = getMinMax("min", [$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = d.value * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  }
});
// CONCATENATED MODULE: ./src/shape/line.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  initLine: function initLine() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = $$.main.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      $$.main.selectAll(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(t.id))).selectAll("".concat(config_classes.selectedCircle)).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this;
    $$.mainLine = $$.main.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function (d) {
      return "".concat($$.classLine.bind($$)(d), " ").concat($$.extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    return [(withTransition ? this.mainLine.transition(getRandom()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? $$.subX : $$.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        lineTargetsNum = lineIndices.__max__ + 1,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineTargetsNum, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M".concat(points[0][0], ",").concat(points[0][1], "L").concat(points[1][0], ",").concat(points[1][1]);
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "M";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          style = isWithinRegions(data.x, regions);
      // Draw as normal
      if (isUndefined(regions) || !style) path += "".concat(_i ? "L" : "").concat(xValue(data), ",").concat(yValue(data));else {
        try {
          style = style.dasharray.split(" ");
        } catch (e) {
          style = dasharray.split(" ");
        } // Draw with region // TODO: Fix for horizotal charts


        xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
        var dx = x(data.x) - x(prevData.x),
            dy = y(data.value) - y(prevData.value),
            dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        diff = style[0] / dd, diffx2 = diff * style[1];

        for (var j = diff; j <= 1; j += diffx2) path += sWithRegion(prevData, data, j, diff), j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
      }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this;
    $$.data.targets.forEach(function (d) {
      var id = "".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id));

      if ($$.isAreaType(d) && $$.defs.select("#".concat(id)).empty()) {
        var color = $$.color(d),
            _$$$config$area_linea = $$.config.area_linearGradient,
            _$$$config$area_linea2 = _$$$config$area_linea.x,
            x = _$$$config$area_linea2 === void 0 ? [0, 0] : _$$$config$area_linea2,
            _$$$config$area_linea3 = _$$$config$area_linea.y,
            y = _$$$config$area_linea3 === void 0 ? [0, 1] : _$$$config$area_linea3,
            _$$$config$area_linea4 = _$$$config$area_linea.stops,
            stops = _$$$config$area_linea4 === void 0 ? [[0, color, 1], [1, color, 0]] : _$$$config$area_linea4,
            linearGradient = $$.defs.append("linearGradient").attr("id", "".concat(id)).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id), ")") : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this;
    $$.config.area_linearGradient && $$.updateAreaGradient(), $$.mainArea = $$.main.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this;
    return [(withTransition ? $$.mainArea.transition(getRandom()) : $$.mainArea).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return $$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity;
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        areaTargetsNum = areaIndices.__max__ + 1,
        x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  updateCircle: function updateCircle() {
    var $$ = this;
    $$.config.point_show && ($$.mainCircle = $$.main.selectAll(".".concat(config_classes.circles)).selectAll(".".concat(config_classes.circle)).data(function (d) {
      return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
    }), $$.mainCircle.exit().remove(), $$.mainCircle = $$.mainCircle.enter().append($$.point("create", this, $$.classCircle.bind($$), $$.pointR.bind($$), $$.color)).merge($$.mainCircle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$)));
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.main.selectAll(".".concat(config_classes.selectedCircle));
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.mainCircle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr("".concat(posAttr, "x"), cx).attr("".concat(posAttr, "y"), cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this;

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? $$.generateGetLinePoints($$.getShapeIndices($$.isLineType))(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-".concat(i) : "";
    return (id ? $$.main.selectAll(".".concat(config_classes.circles).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.circle).concat(suffix));
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(".concat(x, " ").concat(y, ") scale(").concat(scale, ")"));
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(".concat(r(circles) / $$.config.point_r, ")"));
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr("".concat(prefix, "x")),
        cy = +element.attr("".concat(prefix, "y"));

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    var is = Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
    return is;
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/shape/point.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser["document"].createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.defs.select("#".concat(id));
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var point,
            id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        if (ids.indexOf(id) < 0 && ids.push(id), point = pattern[ids.indexOf(id) % pattern.length], $$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = "".concat($$.datetimeId, "-point-").concat(id),
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, cssClassFn, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#".concat(id)).attr("class", cssClassFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          yPosFn2 = function (d) {
        return yPosFn(d) - height / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = element.attr("x", xPosFn2)), mainCircles = element.transition(transitionName).attr("x", xPosFn2).attr("y", yPosFn2).transition(transitionName), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = element.attr("x", xPosFn2).attr("y", yPosFn2);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", cssClassFn).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && (mainCircles = mainCircles.attr("r", $$.pointR.bind($$))), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = mainCircles.attr("cx", xPosFn)), mainCircles = element.attr("cx") ? mainCircles.transition(transitionName).attr("cx", xPosFn).attr("cy", yPosFn).transition(transitionName) : mainCircles.attr("cx", xPosFn).attr("cy", yPosFn), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = mainCircles.attr("cx", xPosFn).attr("cy", yPosFn);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", cssClassFn).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          rectYPosFn = function (d) {
        return yPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && (mainCircles = mainCircles.attr("x", rectXPosFn)), mainCircles = mainCircles.transition(transitionName).attr("x", rectXPosFn).attr("y", rectYPosFn).transition(transitionName), selectedCircles.transition($$.getTransitionName());
      } else mainCircles = mainCircles.attr("x", rectXPosFn).attr("y", rectYPosFn);

      return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/shape/radar.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
extend(ChartInternal_ChartInternal.prototype, {
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min($$.arcWidth, $$.arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        _$$$getRadarSize2 = slicedToArray_default()(_$$$getRadarSize, 2),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize3 = $$.getRadarSize(),
        _$$$getRadarSize4 = slicedToArray_default()(_$$$getRadarSize3, 2),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        points = $$.getCache(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.addCache(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(duration, durationForExit) {
    var $$ = this,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), $$.main.selectAll(".".concat(config_classes.circles)).attr("transform", translate), $$.main.select(".".concat(config_classes.chartTexts)).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(duration, durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var $$ = this,
        points = $$.getCache(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize5 = $$.getRadarSize(),
        _$$$getRadarSize6 = slicedToArray_default()(_$$$getRadarSize5, 2),
        width = _$$$getRadarSize6[0],
        height = _$$$getRadarSize6[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll(".".concat(config_classes.level)).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.level, " ").concat(config_classes.level, "-").concat(i);
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(".concat(width - levelRatio[d], ", ").concat(height - levelRatio[d], ")");
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize7 = $$.getRadarSize(),
        _$$$getRadarSize8 = slicedToArray_default()(_$$$getRadarSize7, 2),
        width = _$$$getRadarSize8[0],
        height = _$$$getRadarSize8[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return "".concat(config_classes.axis, "-").concat(i);
    });
    config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show && axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
      selection.each(function (d) {
        setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d, [-1.2, 1.2]);
      });
    }).datum(function (d, i) {
      return {
        index: i
      };
    }).attr("transform", function (d, i) {
      return "translate(".concat($$.getRadarPosition("x", i, undefined, 1), " ").concat($$.getRadarPosition("y", i, undefined, 1), ")");
    }), $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config;

    if (config.interaction_enabled) {
      var isMouse = $$.inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select(".".concat(config_classes.axis)).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!$$.transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle($$.svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || $$.svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(duration, durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.getCache(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).transition().duration(duration).style("fill", function (d) {
      return $$.color(d);
    }).style("stroke", function (d) {
      return $$.color(d);
    }).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.getCache(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/internals/text.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $$ = this;
    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartTexts), $$.mainText = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.main.select(".".concat(config_classes.chartTexts)).selectAll(".".concat(config_classes.chartText)).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $$.mainText = $$.main.selectAll(".".concat(config_classes.texts)).selectAll(".".concat(config_classes.text)).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").merge($$.mainText).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [this.mainText.each(function () {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x).attr("y", y).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$".concat(text.replace(/\W/g, "_")),
        rect = $$.getCache(cacheKey);
    return rect || ($$.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = v.node().getBoundingClientRect();
    }).remove(), $$.addCache(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet".concat(capitalize(v), "Points")](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = textElement.getBoundingClientRect(),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null && (xPos > $$.width ? xPos = $$.width - textElement.getBoundingClientRect().width : xPos < 0 && (xPos = 4)), isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + (config.data_labels_position.x || 0);
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = textElement.getBoundingClientRect(),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !$$.hasPositiveValue) yPos += rect.height, $$.isBarType(d) ? yPos -= baseY : !$$.isBarType(d) && (yPos += baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + (config.data_labels_position.y || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/type.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // defined chart types as category

var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
extend(ChartInternal_ChartInternal.prototype, {
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      $$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        types = $$.config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = $$.config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets) {
    var _this = this,
        exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    return !TYPES[type].filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/internals/grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

extend(ChartInternal_ChartInternal.prototype, {
  initGrid: function initGrid() {
    var $$ = this;
    $$.xgrid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]), $$.initGridLines(), $$.initXYFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.main.insert("g", ".".concat(config_classes.chart).concat(config.grid_lines_front ? " + *" : "")).attr("clip-path", $$.clipPathForGrid).attr("class", "".concat(config_classes.grid, " ").concat(config_classes.gridLines)), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), $$.xgridLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, $$.x),
        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0,
        pos = function (d) {
      return (($$.zoomScale || $$.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    $$.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": $$.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": $$.height
    }, $$.xgrid = $$.main.select(".".concat(config_classes.xgrids)).selectAll(".".concat(config_classes.xgrid)).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", config_classes.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys($$.xgridAttr).forEach(function (id) {
        grid.attr(id, $$.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? $$.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.y(d));
    };

    $$.ygrid = $$.main.select(".".concat(config_classes.ygrids)).selectAll(".".concat(config_classes.ygrid)).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", config_classes.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : $$.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? $$.height : pos), $$.smoothLines($$.ygrid, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this;
    // hide if arc type
    $$.gridLines || $$.initGridLines(), $$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden"), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select(".".concat(config_classes.xgridLines)).selectAll(".".concat(config_classes.xgridLine)).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = $$.xgridLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), $$.xgridLines.attr("class", function (d) {
      return "".concat(config_classes.xgridLine, " ").concat(d["class"] || "").trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        main = $$.main,
        config = $$.config,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select(".".concat(config_classes.ygridLines)).selectAll(".".concat(config_classes.ygridLine)).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = $$.ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);
    // update
    var yv = $$.yv.bind($$);
    $$.ygridLines.attr("class", function (d) {
      return "".concat(config_classes.ygridLine, " ").concat(d["class"] || "").trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : $$.width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, $$.width, $$.height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1");
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        xv = $$.xv.bind($$),
        lines = $$.xgridLines.select("line"),
        texts = $$.xgridLines.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, $$.width, $$.height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initXYFocusGrid: function initXYFocusGrid() {
    var $$ = this,
        config = $$.config,
        isFront = config.grid_front,
        className = ".".concat(config_classes[isFront && $$.gridLines ? "gridLines" : "chart"]).concat(isFront ? " + *" : "");
    $$.grid = $$.main.insert("g", className).attr("clip-path", $$.clipPathForGrid).attr("class", config_classes.grid), config.grid_x_show && $$.grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && $$.grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus);
  },
  showXGridFocus: function showXGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        focusEl = $$.main.selectAll("line.".concat(config_classes.xgridFocus)),
        xx = $$.xx.bind($$);
    !config.tooltip_show || $$.hasType("bubble") || $$.hasType("scatter") || $$.hasArcType() || (focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(isRotated ? "y1" : "x1", xx).attr(isRotated ? "y2" : "x2", xx), $$.smoothLines(focusEl, "grid")); // Hide when bubble/scatter/stanford plot exists
  },
  hideXGridFocus: function hideXGridFocus() {
    this.main.select("line.".concat(config_classes.xgridFocus)).style("visibility", "hidden");
  },
  updateXgridFocus: function updateXgridFocus() {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    $$.main.select("line.".concat(config_classes.xgridFocus)).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? $$.width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : $$.height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.main.select(".".concat(config_classes.axisX)).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date("".concat(i, "-01-01 00:00:00")));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line["class"] === param["class"]) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.main.select(".".concat(classLines)).selectAll(".".concat(classLine)).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_".concat(forX ? "x" : "y", "_lines");
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/internals/tooltip.js



/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($$.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $$.tooltip.empty() && ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $$.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$ = $$).getTooltipContent.apply(_$$, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return "".concat((ratio * 100).toFixed(2), "%");
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template;

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr);

    for (i = 0; row = d[i]; i++) if (getRowValue(row) || getRowValue(row) === 0) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">".concat(title, "</th></tr>") : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(toConsumableArray_default()(param)))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(toConsumableArray_default()(param))));
        }),
            _map2 = slicedToArray_default()(_map, 2),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> ".concat(value, " <b>High:</b> ").concat(high, " <b>Low:</b> ").concat(low);
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(toConsumableArray_default()(param)))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:".concat(color, "\" width=\"10\" height=\"10\"></rect></svg>"),
            NAME: name,
            VALUE: value
          };
          tplStr && isObject(contents.text) && Object.keys(contents.text).forEach(function (key) {
            contentValue[key] = contents.text[key][i];
          }), text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return "".concat(text, "</table>");
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">".concat(this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>", "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>")).replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        _d3Mouse2 = slicedToArray_default()(_d3Mouse, 2),
        left = _d3Mouse2[0],
        top = _d3Mouse2[1],
        svgLeft = $$.getSvgLeft(!0),
        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = $$.inputType === "touch" || $$.hasType("radar");
      raw || (top += $$.height / 2, left += ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = $$.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + ($$.zoomScale ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > $$.currentHeight && (top -= tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        positionFunction = config.tooltip_position || $$.tooltipPosition;

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = $$.tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          width = datum && datum.width || 0,
          height = datum && datum.height || 0;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$), $$.tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = $$.tooltip.property("offsetWidth"),
          height: height = $$.tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        // Get tooltip dimensions
        var position = positionFunction.call(this, dataToShow, width, height, element); // Set tooltip position

        $$.tooltip.style("top", "".concat(position.top, "px")).style("left", "".concat(position.left, "px"));
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config;
    (!config.tooltip_doNotHide || force) && (callFn(config.tooltip_onhide, $$), this.tooltip.style("display", "none").style("visibility", "hidden") // for IE9
    .datum(null), callFn(config.tooltip_onhidden, $$));
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this;

    if ($$.config.tooltip_linked) {
      var linkedName = $$.config.tooltip_linked_name;
      ($$.api.internal.charts || []).forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser["document"].body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/internals/legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config;
    $$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !$$.zoomScale), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $$.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.margin3 = {
      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - height,
      right: NaN,
      bottom: 0,
      left: $$.isLegendRight ? $$.currentWidth - width : $$.isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this;
    (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.legendItemHeight = h;
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this;
    return $$.config.legend_show ? $$.isLegendRight ? $$.currentHeight : Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.legend.selectAll(".".concat(config_classes.legendItem)).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Clear the LegendItemTextBox cache.
   * @private
   */
  clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
    this.legendItemTextBox = {};
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        isTouch = $$.inputType === "touch";
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        getTextBox = function (textElement, id) {
      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
    },
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = getTextBox(textElement, id),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    $$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : $$.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = $$.legend.selectAll(".".concat(config_classes.legendItem)).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = $$.config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser["document"].createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#".concat($$.datetimeId, "-point-").concat(data) : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = $$.legend.select(".".concat(config_classes.legendBackground, " rect")), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", ".".concat(config_classes.legendItem)).attr("class", config_classes.legendBackground).append("rect"));
    var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = $$.legend.selectAll("rect.".concat(config_classes.legendItemEvent)).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = $$.legend.selectAll(".".concat(config_classes.legendItemPoint)).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = $$.config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = $$.legend.selectAll("line.".concat(config_classes.legendItemTile)).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/internals/title.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

var getTextPos = function () {
  var position,
      pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "left",
      width = arguments.length > 1 ? arguments[1] : undefined,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
};

extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this;

    if ($$.config.title_text) {
      $$.title = $$.svg.append("g");
      var text = $$.title.append("text").style("text-anchor", getTextPos($$.config.title_position)).attr("class", config_classes.title);
      setTextValue(text, $$.config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this;

    if ($$.title) {
      var y = $$.yForTitle.call($$);
      /g/i.test($$.title.node().tagName) ? $$.title.attr("transform", "translate(".concat(getTextPos($$.config.title_position, $$.currentWidth), ", ").concat(y, ")")) : $$.title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        position = config.title_position || "left";
    return /(right|center)/.test(position) ? (x = $$.currentWidth - $$.getTextRect($$.title, config_classes.title).width, position.indexOf("right") >= 0 ? x -= config.title_padding.right || 0 : position.indexOf("center") >= 0 && (x /= 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/internals/clip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  initClip: function initClip() {
    var $$ = this; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist

    // Define 'clip-path' attribute values
    $$.clipId = "".concat($$.datetimeId, "-clip"), $$.clipIdForXAxis = "".concat($$.clipId, "-xaxis"), $$.clipIdForYAxis = "".concat($$.clipId, "-yaxis"), $$.clipIdForGrid = "".concat($$.clipId, "-grid"), $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!browser["window"].navigator && browser["window"].navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(".concat(isIE9 ? "" : browser["document"].URL.split("#")[0], "#").concat(id, ")");
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    // axis line width + padding for left
    var left = Math.max(30, this.margin.left);
    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    return forHorizontal ? -20 : -this.margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        left = Math.max(30, $$.margin.left),
        right = Math.max(30, $$.margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    // less than 20 is not enough to show the axis label 'outer' without legend
    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/internals/region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection




extend(ChartInternal_ChartInternal.prototype, {
  initRegion: function initRegion() {
    var $$ = this;
    $$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config;
    // hide if arc type
    // select <g> element
    $$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select(".".concat(config_classes.regions)).selectAll(".".concat(config_classes.region)).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.mainRegion.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], pos = scale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, pos = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var scale,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = $$[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], end = scale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, end = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// CONCATENATED MODULE: ./src/interactions/drag.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        main = $$.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _$$$dragStart = slicedToArray_default()($$.dragStart, 2),
            sx = _$$$dragStart[0],
            sy = _$$$dragStart[1],
            _mouse = slicedToArray_default()(mouse, 2),
            mx = _mouse[0],
            my = _mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

        main.select(".".concat(config_classes.dragarea)).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = shape.attr("cx") * 1,
                y = shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return;

          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select(".".concat(config_classes.chart)).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config;
    $$.hasArcType() || !config.data_selection_enabled || ($$.main.select(".".concat(config_classes.dragarea)).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll(".".concat(config_classes.shape)).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(60);

// CONCATENATED MODULE: ./src/internals/selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this;
    // remove selected-circle from low layer g
    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = "".concat(selected ? "" : "un", "selectPoint");
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this["".concat(selected ? "" : "un", "selectPath")](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = ".".concat(config_classes.shapes);
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll(selector).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/interactions/subchart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = $$.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map($$.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && $$.context && $$.context.select(".".concat(config_classes.brush)).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return $$.context ? $$.context.select(".".concat(config_classes.brush)) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([]);
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = "".concat($$.clipId, "-subchart"),
        clipPath = $$.getClipPath(clipId);
    $$.clipIdForSubchart = clipId, $$.appendClip($$.defs, clipId), $$.initBrush(), $$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));
    var context = $$.context;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars), context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        context = $$.context,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var contextBarUpdate = context.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", classChartBar),
          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
      contextBarEnter.append("g").attr("class", classBars);
      // -- Line --//
      var contextLineUpdate = context.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", classChartLine),
          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll(".".concat(config_classes.brush, " rect")).attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this;
    $$.contextBar = $$.context.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this;
    $$.contextLine = $$.context.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this;
    $$.contextArea = $$.context.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.contextArea).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config;
    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw".concat(name)](shape.indices[v], !0);
      $$["update".concat(name, "ForSubchart")](duration), $$["redraw".concat(name, "ForSubchart")](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this;
    $$.redraw({
      withTransition: !1,
      withY: $$.config.zoom_rescale,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), $$.config.subchart_onbrush.call($$.api, $$.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select(".".concat(config_classes.axisX)), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        extent = $$.config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), $$.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return $$.subX($$.parseDate(v));
    }))), extent;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(61);

// CONCATENATED MODULE: ./src/interactions/zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.zoomScale = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent() {
    var bind = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0],
        $$ = this,
        zoomEnabled = $$.config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = $$.main.select(".".concat(config_classes.eventRects));
    zoomEnabled && bind ? $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      $$.orgXScale && $$.orgXScale.range($$.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"]($$.orgXScale || $$.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, $$.orgXDomain), $$.zoomScale = $$.getCustomizedScale(newScale), $$.xAxis.scale($$.zoomScale), rescale && (!$$.orgXScale && ($$.orgXScale = $$.x.copy()), $$.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0) {
      var isMousemove = event.sourceEvent.type === "mousemove",
          isZoomOut = event.sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && $$.x.domain().every(function (v, i) {
        return v !== $$.orgXDomain[i];
      }) && $$.x.domain($$.orgXDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && $$.x.orgDomain()[0] === $$.orgXDomain[0] && $$.x.domain([$$.orgXDomain[0] - 1e-10, $$.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, $$.zoomScale.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        startEvent = $$.zoom.startEvent;
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn($$.config.zoom_onzoomend, $$.api, $$[$$.zoomScale ? "zoomScale" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        _$$$orgXDomain = slicedToArray_default()($$.orgXDomain, 2),
        min = _$$$orgXDomain[0],
        max = _$$$orgXDomain[1];

    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this;

    if ($$.zoomScale) {
      var zoomDomain = $$.zoomScale.domain(),
          xDomain = $$.subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.xAxis.scale($$.subX), $$.x.domain($$.subX.orgDomain()), $$.zoomScale = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        zoomRect = null,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.main.append("rect").attr("clip-path", $$.clipPath).attr("class", config_classes.zoomBrush).attr("width", isRotated ? $$.width : 0).attr("height", isRotated ? 0 : $$.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.zoomScale || $$.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
            _ref3 = slicedToArray_default()(_ref2, 2),
            x = _ref3[0],
            y = _ref3[1],
            target = browser["document"].elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.selectChart.append("div").classed(config_classes.button, !0).append("span").on("click", $$.api.unzoom.bind($$)).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/internals/color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser["document"].body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser["document"].createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = browser["window"].getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = "".concat($$.datetimeId, "-pattern-").concat(color, "-").concat(index);
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#".concat(p.id, ")");
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restore in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (d) {
      var id = d.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? $$.main.selectAll(".".concat(config_classes.arc, "-").concat(d.id)).style("fill", color(d)) : $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(function (d) {
      var val = color(d);
      this.style.stroke = val, this.style.fill = val;
    });
  }
});
// CONCATENATED MODULE: ./src/internals/format.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



var getFormat = function ($$, typeValue, v) {
  var config = $$.config,
      type = "axis_".concat(typeValue, "_tick_format"),
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
};

extend(ChartInternal_ChartInternal.prototype, {
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        formatForY = $$.yFormat,
        formatForY2 = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return "".concat((ratio * 100).toFixed(1), "%");
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/internals/cache.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  addCache: function addCache(key, value) {
    var isDataType = !!(arguments.length > 2 && arguments[2] !== undefined) && arguments[2];
    this.cache[key] = isDataType ? this.cloneTarget(value) : value;
  },

  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  removeCache: function removeCache(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  },

  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  getCache: function getCache(key) {
    var isDataType = !!(arguments.length > 1 && arguments[1] !== undefined) && arguments[1];

    if (isDataType) {
      var targets = [];

      for (var id, i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  },

  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  resetCache: function resetCache(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
});
// CONCATENATED MODULE: ./src/internals/class.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(ChartInternal_ChartInternal.prototype, {
  generateClass: function generateClass(prefix, targetId) {
    return " ".concat(prefix, " ").concat(prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return "".concat(this.generateClass(config_classes.region, i), " ").concat("class" in d ? d["class"] : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " ".concat(config_classes.target, "-").concat(additionalClassSuffix)), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " ".concat(this.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " ".concat(this.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? "-".concat(targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return "".concat(prefix || "", ".").concat(config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return ".".concat(config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/api/api.focus.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && $$.expandArc(targetIds), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && $$.unexpandArc(targetIds), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), $$.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/api/api.show.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Show/Hide data series
   * @private
   */
  _showHide: function _showHide(show, targetIdsValue, options) {
    var $$ = this.internal,
        targetIds = $$.mapToTargetIds(targetIdsValue);
    $$["".concat(show ? "remove" : "add", "HiddenTargetIds")](targetIds);
    var targets = $$.svg.selectAll($$.selectorTargets(targetIds)),
        opacity = show ? "1" : "0";
    targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
      targets.style("opacity", null).style("opacity", opacity);
    }), options.withLegend && $$["".concat(show ? "show" : "hide", "Legend")](targetIds), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    });
  },

  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this._showHide(!1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds) {
    var _this = this,
        options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };

    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/api/api.zoom.js


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

var withinRange = function (domain, range) {
  var _range = slicedToArray_default()(range, 2),
      min = _range[0],
      max = _range[1];

  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
},
    api_zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      domain = domainValue;

  if ($$.config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), $$.config.subchart_show) {
      var xScale = $$.zoomScale || $$.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else $$.x.domain(domain), $$.zoomScale = $$.x, $$.xAxis.scale($$.zoomScale), resultDomain = $$.zoomScale.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: $$.config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn($$.config.zoom_onzoom, resultDomain);
  } else resultDomain = $$.zoomScale ? $$.zoomScale.domain() : $$.x.orgDomain();

  return resultDomain;
};
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


extend(api_zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoomenable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "wheel",
        $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoommax
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [$$.orgXDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoommin
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [$$.orgXDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoomrange
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range2) {
    var zoom = this.zoom;

    if (isObject(_range2)) {
      var min = _range2.min,
          max = _range2.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
}), extend(Chart_Chart.prototype, {
  zoom: api_zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.zoomScale) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.main.select(".".concat(config_classes.eventRects));
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/api/api.load.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set 'json' if loading JSON via data.url.<br>@see [dataheaders](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [datakeys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [datamimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json"
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.removeCache(ids), args.done && args.done();
    });
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(62);

// CONCATENATED MODULE: ./src/api/api.flow.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */







extend(Chart_Chart.prototype, {
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [datajson](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [datarows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [datacolumns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
}), extend(ChartInternal_ChartInternal.prototype, {
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $$.xgrid || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          xgridLines = $$.xgridLines || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainRegion = $$.mainRegion || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainText = $$.mainText || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainBar = $$.mainBar || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainLine = $$.mainLine || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainArea = $$.mainArea || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
          mainCircle = $$.mainCircle || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);

      $$.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(".concat(translateX, ",0) scale(").concat(scaleX, ",1)");
      $$.hideXGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.axes.x.transition(gt).call(function (g) {
        return $$.xAxis.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var shapes = [],
            texts = [],
            eventRects = [];

        // remove flowed elements
        if (flowLength) {
          for (var index, i = 0; i < flowLength; i++) index = flowIndex + i, shapes.push(".".concat(config_classes.shape, "-").concat(index)), texts.push(".".concat(config_classes.text, "-").concat(index)), eventRects.push(".".concat(config_classes.eventRect, "-").concat(index));

          $$.svg.selectAll(".".concat(config_classes.shapes)).selectAll(shapes).remove(), $$.svg.selectAll(".".concat(config_classes.texts)).selectAll(texts).remove(), $$.svg.selectAll(".".concat(config_classes.eventRects)).selectAll(eventRects).remove(), $$.svg.select(".".concat(config_classes.xgrid)).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv), xgridLines.select("text").attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
      });
    };
  }
});
// CONCATENATED MODULE: ./src/api/api.selection.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




extend(Chart_Chart.prototype, {
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.main.selectAll(".".concat(config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll(".".concat(config_classes.shape)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/api/api.transform.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Change the type of the chart.
 * @private
 * @param {String|Array} targetIds
 * @param {String} type
 * @param {Object} optionsForRedraw
 */

function transformTo(targetIds, type, optionsForRedraw) {
  var $$ = this,
      options = optionsForRedraw || {
    withTransitionForAxis: !$$.hasArcType()
  };
  // this is needed when transforming to arc
  options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
}

extend(Chart_Chart.prototype, {
  /**
   * Change the type of the chart.
   * @method transform
   * @instance
   * @memberof Chart
   * @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
   * @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
   * @example
   *  // all targets will be bar chart.
   *  chart.transform("bar");
   *
   *  // only data1 will be bar chart.
   *  chart.transform("bar", "data1");
   *
   *  // only data1 and data2 will be bar chart.
   *  chart.transform("bar", ["data1", "data2"]);
   */
  transform: function transform(type, targetIds) {
    var $$ = this.internal,
        options = ["pie", "donut"].indexOf(type) >= 0 ? {
      withTransform: !0
    } : null;
    transformTo.bind($$)(targetIds, type, options);
  }
});
// CONCATENATED MODULE: ./src/api/api.group.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/api/api.grid.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

var xgrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
};

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */
var ygrids = function (grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
};

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygridsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygridsremove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
}), extend(Chart_Chart.prototype, {
  xgrids: xgrids,
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/api/api.region.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

var api_region_regions = function (_regions) {
  var $$ = this.internal,
      config = $$.config;
  return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), _regions) : config.regions;
};

extend(api_region_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regionsadd
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regionsremove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.main.select(".".concat(config_classes.regions)).selectAll(classes.map(function (c) {
      return ".".concat(c);
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region["class"] || (region["class"].split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
}), extend(Chart_Chart.prototype, {
  regions: api_region_regions
});
// CONCATENATED MODULE: ./src/api/api.data.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

var api_data_data = function (targetIds) {
  var targets = this.internal.data.targets;
  return isUndefined(targetIds) ? targets : targets.filter(function (t) {
    return targetIds.indexOf(t.id) >= 0;
  });
};

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method datashown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method datavalues
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId) {
    var flat = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
        values = null;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method datanames
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method datacolors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * @method dataaxes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method datamin
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method datamax
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
}), extend(Chart_Chart.prototype, {
  data: api_data_data
});
// CONCATENATED MODULE: ./src/api/api.category.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/api/api.color.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/api/api.x.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


extend(Chart_Chart.prototype, {
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? $$.api.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? $$.api.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// CONCATENATED MODULE: ./src/api/api.axis.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

var setMinMax = function ($$, type, value) {
  var config = $$.config,
      axisX = "axis_x_".concat(type),
      axisY = "axis_y_".concat(type),
      axisY2 = "axis_y2_".concat(type);
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config[axisX] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
},
    api_axis_getMinMax = function ($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_".concat(type)],
    y: config["axis_y_".concat(type)],
    y2: config["axis_y2_".concat(type)]
  };
},
    api_axis_axis = extend(function () {}, {
  /**
   * Get and set axis labels.
   * @method axislabels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axismin
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "min", _min) : api_axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axismax
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : api_axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axisrange
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
});
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


extend(Chart_Chart.prototype, {
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/api/api.legend.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define legend
 * @ignore
 */

var legend = extend(function () {}, {
  /**
   * Show legend for each target.
   * @method legendshow
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legendhide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
});
extend(Chart_Chart.prototype, {
  legend: legend
});
// CONCATENATED MODULE: ./src/api/api.chart.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



extend(Chart_Chart.prototype, {
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @param {Boolean} [isFromResize] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, isFromResize) {
    var $$ = this.internal; // reset possible zoom scale

    isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.zoomScale = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    });
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $$.svg.select("*").interrupt(), isDefined($$.resizeTimeout) && browser["window"].clearTimeout($$.resizeTimeout), browser["window"].removeEventListener("resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function config(name, value, redraw) {
    var res,
        $$ = this.internal,
        key = name && name.replace(/\./g, "_");
    return key in $$.config && (isDefined(value) ? ($$.config[key] = value, res = value, redraw && this.flush()) : res = $$.config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/api/api.tooltip.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Define tooltip
 * @ignore
 */

var tooltip = extend(function () {}, {
  /**
   * Show tooltip
   * @method tooltipshow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted x Axis element.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: Axis id. 'y' or 'y2'(default 'y')<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate relative the x Axis element.
   *  chart.tooltip.show({
   *    data: {x: 2},
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "y",  // axis id. 'y' or 'y2' (default 'y')
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show() {
    var index,
        mouse,
        args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        $$ = this.internal;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.x(args.data.x), y] : (!$$.config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    ($$.inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltiphide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideXGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
});
extend(Chart_Chart.prototype, {
  tooltip: tooltip
});
// CONCATENATED MODULE: ./src/api/api.export.js
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode("0x".concat(p));
  }));
},
    nodeToSvgDataUrl = function (node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser["document"].styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser["document"].createElement("style"); // escape css for XML

  style.appendChild(browser["document"].createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = "<svg xmlns=\"".concat(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, "\" width=\"").concat(size.width, "\" height=\"").concat(size.height, "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t").concat(styleXml, "\n\t\t\t\t").concat(nodeXml.replace(/(url\()[^#]+/g, "$1"), "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64,".concat(b64EncodeUnicode(dataStr));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @return {String}
 * @private
 */


extend(Chart_Chart.prototype, {
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  "export": function _export(mimeType, callback) {
    var $$ = this.internal,
        size = {
      width: $$.currentWidth,
      height: $$.currentHeight
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (isFunction(callback)) {
      var img = new Image();
      img.crosssOrigin = "Anonymous", img.onload = function () {
        var canvas = browser["document"].createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/core.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */























































var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "1.9.5",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {},

  /**
   * Internal chart object
   * @private
   */
  chart: {
    fn: Chart_Chart.prototype,
    internal: {
      fn: ChartInternal_ChartInternal.prototype,
      axis: {
        fn: Axis_Axis.prototype
      }
    }
  }
};
/**
 * @namespace bb
 * @version 1.9.5
 */


/* harmony default export */ var core = __webpack_exports__["default"] = (bb);

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1NvY2tKU0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9CYXNlQ2xpZW50LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz8yZmZlIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2JpbGxib2FyZC5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy10aW1lLWZvcm1hdFwiLFwiY29tbW9uanMyXCI6XCJkMy10aW1lLWZvcm1hdFwiLFwiYW1kXCI6XCJkMy10aW1lLWZvcm1hdFwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1zZWxlY3Rpb25cIixcImNvbW1vbmpzMlwiOlwiZDMtc2VsZWN0aW9uXCIsXCJhbWRcIjpcImQzLXNlbGVjdGlvblwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXRyYW5zaXRpb25cIixcImFtZFwiOlwiZDMtdHJhbnNpdGlvblwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1heGlzXCIsXCJjb21tb25qczJcIjpcImQzLWF4aXNcIixcImFtZFwiOlwiZDMtYXhpc1wiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWJydXNoXCIsXCJjb21tb25qczJcIjpcImQzLWJydXNoXCIsXCJhbWRcIjpcImQzLWJydXNoXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1zY2FsZVwiLFwiY29tbW9uanMyXCI6XCJkMy1zY2FsZVwiLFwiYW1kXCI6XCJkMy1zY2FsZVwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1kc3ZcIixcImNvbW1vbmpzMlwiOlwiZDMtZHN2XCIsXCJhbWRcIjpcImQzLWRzdlwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1kcmFnXCIsXCJjb21tb25qczJcIjpcImQzLWRyYWdcIixcImFtZFwiOlwiZDMtZHJhZ1wiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1zaGFwZVwiLFwiY29tbW9uanMyXCI6XCJkMy1zaGFwZVwiLFwiYW1kXCI6XCJkMy1zaGFwZVwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwiY29tbW9uanMyXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwiYW1kXCI6XCJkMy1pbnRlcnBvbGF0ZVwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1jb2xvclwiLFwiY29tbW9uanMyXCI6XCJkMy1jb2xvclwiLFwiYW1kXCI6XCJkMy1jb2xvclwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy16b29tXCIsXCJjb21tb25qczJcIjpcImQzLXpvb21cIixcImFtZFwiOlwiZDMtem9vbVwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJkMy1lYXNlXCIsXCJjb21tb25qczJcIjpcImQzLWVhc2VcIixcImFtZFwiOlwiZDMtZWFzZVwiLFwicm9vdFwiOlwiZDNcIn0iLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jbGFzc2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXhpcy9BeGlzUmVuZGVyZXJIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F4aXMvQXhpc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9heGlzL0F4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9DaGFydEludGVybmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9kb21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmNvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZGF0YS5sb2FkLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2F0ZWdvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL3NoYXBlLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlL2Jhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvYnViYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9saW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFwZS9wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcGUvcmFkYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy90ZXh0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy90b29sdGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvbGVnZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9jbGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvcmVnaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmFjdGlvbnMvZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJhY3Rpb25zL3N1YmNoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmFjdGlvbnMvem9vbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJuYWxzL2NvbG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvZm9ybWF0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcm5hbHMvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludGVybmFscy9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5zaG93LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkubG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5mbG93LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5yZWdpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5jYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS5jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2FwaS54LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmF4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkubGVnZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLmNoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYXBpLnRvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9hcGkuZXhwb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlLmpzIl0sIm5hbWVzIjpbIndpbiIsImRlZiIsIm8iLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIiwiZG9jIiwiZG9jdW1lbnQiLCJhcmMiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRMaW5lIiwieWdyaWRMaW5lcyIsInlncmlkcyIsInpvb21CcnVzaCIsInpvb21SZWN0IiwiRVhQQU5ERUQiLCJTRUxFQ1RFRCIsIklOQ0xVREVEIiwiaXNWYWx1ZSIsInYiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNCb29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiT2JqZWN0Iiwia2V5cyIsImlzTmFOIiwibm90RW1wdHkiLCJpc0FycmF5IiwiYXJyIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImlzT2JqZWN0Iiwib2JqIiwibm9kZVR5cGUiLCJnZXRPcHRpb24iLCJvcHRpb25zIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaGFzVmFsdWUiLCJkaWN0IiwidmFsdWUiLCJmb3VuZCIsImZvckVhY2giLCJjYWxsRm4iLCJmbiIsImlzRm4iLCJhcmdzIiwiY2FsbCIsInNhbml0aXNlIiwic3RyIiwicmVwbGFjZSIsInNldFRleHRWYWx1ZSIsIm5vZGUiLCJkeSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsInBhdGgiLCJnZXRCQm94IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsImdldFBhdGhCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpdGVtcyIsIm1pbiIsImdldEJydXNoU2VsZWN0aW9uIiwiY3R4Iiwic2VsZWN0aW9uIiwiZXZlbnQiLCJkM0V2ZW50IiwibWFpbiIsImNvbnRleHQiLCJuYW1lIiwic2VsZWN0IiwiQ0xBU1MiLCJkM0JydXNoU2VsZWN0aW9uIiwiZ2V0UmFuZG9tIiwiYXNTdHIiLCJyYW5kb20iLCJicnVzaEVtcHR5IiwiZXh0ZW5kIiwic291cmNlIiwicCIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwidG9BcnJheSIsImdldENzc1J1bGVzIiwic3R5bGVTaGVldHMiLCJydWxlcyIsInNoZWV0IiwiY3NzUnVsZXMiLCJjb25jYXQiLCJlIiwiY29uc29sZSIsImVycm9yIiwiaHJlZiIsInRvU3RyaW5nIiwiZ2V0VW5pcXVlIiwiZGF0YSIsImZpbHRlciIsIm1lcmdlQXJyYXkiLCJyZWR1Y2UiLCJjIiwibWVyZ2VPYmoiLCJvYmplY3ROIiwic2hpZnQiLCJzb3J0VmFsdWUiLCJpc0FzYyIsImEiLCJiIiwiZXZlcnkiLCJOdW1iZXIiLCJzb3J0IiwiZ2V0TWluTWF4IiwidHlwZSIsInJlcyIsInVuZGVmaW5lZCIsImdldFJhbmdlIiwic3RhcnQiLCJlbmQiLCJwdXNoIiwiZW11bGF0ZUV2ZW50IiwibW91c2UiLCJnZXRQYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZUV2ZW50IiwiZWwiLCJldmVudFR5cGUiLCJwYXJhbXMiLCJkaXNwYXRjaEV2ZW50IiwibW91c2VFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ0b3VjaCIsInRvdWNoT2JqIiwiVG91Y2giLCJhc3NpZ24iLCJpZGVudGlmaWVyIiwibm93IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbkFuZ2xlIiwiZm9yY2UiLCJUb3VjaEV2ZW50Iiwic2hpZnRLZXkiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidHBsUHJvY2VzcyIsInRwbCIsIlJlZ0V4cCIsIkF4aXNSZW5kZXJlckhlbHBlciIsImNvbmZpZyIsInNjYWxlIiwiZDNTY2FsZUxpbmVhciIsIm5vVHJhbnNpdGlvbiIsInRyYW5zaXRpb25fZHVyYXRpb24iLCJ3aXRob3V0VHJhbnNpdGlvbiIsInJhbmdlIiwicmFuZ2VFeHRlbnQiLCJzY2FsZUV4dGVudCIsIm9yZ1hTY2FsZSIsInRpY2tPZmZzZXQiLCJkb21haW4iLCJzdG9wIiwidGlja3MiLCJ0aWNrQXJndW1lbnRzIiwicm91bmQiLCJ1bnNoaWZ0IiwibmV3U2NhbGUiLCJjb3B5IiwidGlja0Zvcm1hdCIsInRlc3QiLCJmb3JtYXR0ZWQiLCJpbnRlcnJ1cHQiLCJ0cmFuc2l0aW9uIiwic2l6ZSIsInciLCJoIiwiZ2V0U2l6ZUZvcjFDaGFyIiwiQXhpc1JlbmRlcmVyIiwiaW5uZXJUaWNrU2l6ZSIsIm91dGVyVGlja1NpemUiLCJvdXRlclRpY2siLCJvcmllbnQiLCJ0aWNrQ2VudGVyZWQiLCJ0aWNrQ3VsbGluZyIsInRpY2tMZW5ndGgiLCJ0aWNrUGFkZGluZyIsInRpY2tWYWx1ZXMiLCJtYXgiLCJoZWxwZXIiLCJIZWxwZXIiLCJnIiwiaGVscGVySW5zdCIsInNwbGl0VGlja1RleHQiLCJiaW5kIiwiaXNMZWZ0UmlnaHQiLCJpc1RvcEJvdHRvbSIsInRpY2tUcmFuc2Zvcm0iLCJheGlzUHgiLCJzaWduIiwicm90YXRlIiwidGlja1RleHRSb3RhdGUiLCJ0aWNrVGV4dFBvcyIsInByZWZpeCIsImF4aXNTaG93IiwidGlja1Nob3ciLCJ0aWNrIiwiJGciLCJlYWNoIiwiZDNTZWxlY3QiLCJzY2FsZTAiLCJfX2NoYXJ0X18iLCJzY2FsZTEiLCJjb3B5U2NhbGUiLCJpc0NhdGVnb3J5Iiwic2VsZWN0QWxsIiwiZW50ZXIiLCJtZXJnZSIsInRyYW5zaXRpb25pc2UiLCJvdXRlclRpY2tTaXplZCIsImdlbmVyYXRlVGlja3MiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJzdHlsZSIsInRpY2tFeGl0IiwiZXhpdCIsInJlbW92ZSIsInNpemVGb3IxQ2hhciIsImNvdW50cyIsInRzcGFuIiwiaW5kZXgiLCJ0aWNrTXVsdGlsaW5lIiwidGV4dEZvcm1hdHRlZCIsInNwbGl0dGVkIiwiZHgiLCJzaW4iLCJQSSIsImxpbmVVcGRhdGUiLCJ0ZXh0VXBkYXRlIiwic2V0VGlja0xpbmVUZXh0UG9zaXRpb24iLCJ0aWNrVGl0bGUiLCJiYW5kd2lkdGgiLCJwb3MiLCJ0aWNrUG9zaXRpb24iLCJ0aWNrUG9zIiwiZ2V0VGlja1hZIiwiZ2V0VGlja1NpemUiLCJyIiwiY2hhcldpZHRoIiwic3VidGV4dCIsInNwYWNlSW5kZXgiLCJ0ZXh0V2lkdGgiLCJzdWJzdHIiLCJ0aWNrV2lkdGgiLCJ0aWNrVGV4dCIsImFyZ3VtZW50cyIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsImZvcm1hdCIsImlzQ2VudGVyZWQiLCJpbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwiSW5maW5pdHkiLCJjdWxsaW5nIiwidCIsImlzSG9yaXpvbnRhbCIsIiQkIiwiZm9ySG9yaXpvbnRhbCIsImlzUm90YXRlZCIsImF4aXNfcm90YXRlZCIsImdldEF4aXNDbGFzc05hbWUiLCJpZCIsIkF4aXMiLCJvd25lciIsInNldE9yaWVudCIsImF4aXNfeTJfc2hvdyIsImF4ZXNMaXN0IiwiY2xhc3NBeGlzIiwiY2xhc3NMYWJlbCIsImF4ZXMiLCJjbGlwUGF0aEZvclhBeGlzIiwiYXhpc195X2lubmVyIiwiY2xpcFBhdGhGb3JZQXhpcyIsImdldFRyYW5zbGF0ZSIsInRleHRBbmNob3JGb3JYQXhpc0xhYmVsIiwiZ2VuZXJhdGVBeGVzIiwieUlubmVyIiwieTJJbm5lciIsImF4aXNfeTJfaW5uZXIiLCJ4T3JpZW50IiwieU9yaWVudCIsInkyT3JpZW50Iiwic3ViWE9yaWVudCIsImQzQXhpcyIsImF4ZXNDb25maWciLCJkM0F4aXNMZWZ0IiwiZDNBeGlzQm90dG9tIiwiZDNBeGlzVG9wIiwiZDNBeGlzUmlnaHQiLCJjb3VudCIsInZhbHVlcyIsInRpY2tTaXplT3V0ZXIiLCJvdXRlciIsImF4aXNSYW5nZSIsImNsYXNzTmFtZSIsInhBeGlzIiwibm9UaWNrVGV4dFJvdGF0ZSIsImlzQ2F0ZWdvcml6ZWQiLCJ4QXhpc1RpY2tGb3JtYXQiLCJ4QXhpc1RpY2tWYWx1ZXMiLCJheGlzUGFyYW1zIiwiYXhpc194X3RpY2tfbXVsdGlsaW5lIiwiYXhpc194X3RpY2tfd2lkdGgiLCJheGlzX3hfdGlja19yb3RhdGUiLCJheGlzX3hfdGlja190b29sdGlwIiwiYXBpIiwiY2F0ZWdvcmllcyIsInpvb21TY2FsZSIsIm5ld1RpY2tWYWx1ZXMiLCJpc1RpbWVTZXJpZXMiLCJwYXJzZURhdGUiLCJheGlzX3hfdGlja19jZW50ZXJlZCIsImF4aXNfeF90aWNrX2N1bGxpbmciLCJheGlzX3hfdGlja19jb3VudCIsImF4aXNfeV90aWNrX3JvdGF0ZSIsImlzU3RhY2tOb3JtYWxpemVkIiwiaXNUaW1lU2VyaWVzWSIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJ0YXJnZXRzIiwiZml0IiwiYXhpc194X3RpY2tfZml0IiwiZ2VuZXJhdGVUaWNrVmFsdWVzIiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJzdWJYQXhpcyIsImRhdGFfYXhlcyIsImF4aXNfeF90aWNrX2Zvcm1hdCIsImRhdGUiLCJheGlzVGltZUZvcm1hdCIsImRlZmF1bHRBeGlzVGltZUZvcm1hdCIsImNhdGVnb3J5TmFtZSIsInRvRml4ZWQiLCJhcHBseSIsImdldFRpY2tWYWx1ZXMiLCJvcHRpb24iLCJnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldExhYmVsUG9zaXRpb24iLCJnZXRMYWJlbFRleHQiLCJhbmNob3IiLCJ4Rm9yQXhpc0xhYmVsIiwiZ2V0WEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WUF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbiIsImR4Rm9yQXhpc0xhYmVsIiwieEhlaWdodCIsImF4aXNfeF9oZWlnaHQiLCJnZXRNYXhUaWNrV2lkdGgiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwid2l0aG91dFJlY29tcHV0ZSIsImN1cnJlbnRUaWNrTWF4IiwiY3VycmVudE1heFRpY2tXaWR0aHMiLCJtYXhXaWR0aCIsInN2ZyIsImlzWUF4aXMiLCJ0YXJnZXRzVG9TaG93IiwiZmlsdGVyVGFyZ2V0c1RvU2hvdyIsImdldEZyb20iLCJ0aWNrQ291bnQiLCJ1cGRhdGVYQXhpc1RpY2tWYWx1ZXMiLCJkdW1teSIsInNlbGVjdENoYXJ0IiwiY3JlYXRlIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJYIiwiWSIsIlkyIiwiYXhpc0xhYmVsIiwicGFkZGluZyIsImRvbWFpbkxlbmd0aCIsInVuaXQiLCJjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyIsInBpeGVscyIsImZvclRpbWVTZXJpZXMiLCJ0aWNrVmFsdWUiLCJ0YXJnZXRDb3VudCIsImR1cmF0aW9uIiwiYXhpc1N1YlgiLCJ0cmFuc2l0aW9ucyIsImlzSGlkZGVuIiwiaXNJbml0Iiwib3BhY2l0eSIsInRvTG93ZXJDYXNlIiwidXBkYXRlQXhlcyIsIkNoYXJ0SW50ZXJuYWwiLCJnZXRPcHRpb25zIiwiY2FjaGUiLCJjYWxsUGx1Z2luSG9vayIsIm9uYmVmb3JlaW5pdCIsIm9uYWZ0ZXJpbml0IiwiaW5pdFBhcmFtcyIsImNvbnZlcnRlZERhdGEiLCJjb252ZXJ0RGF0YSIsImluaXRXaXRoRGF0YSIsImRhdGV0aW1lSWQiLCJpbml0Q2xpcCIsImRyYWdTdGFydCIsImRyYWdnaW5nIiwiZmxvd2luZyIsImNhbmNlbENsaWNrIiwibW91c2VvdmVyIiwidHJhbnNpdGluZyIsImNvbG9yIiwiZ2VuZXJhdGVDb2xvciIsImxldmVsQ29sb3IiLCJnZW5lcmF0ZUxldmVsQ29sb3IiLCJwb2ludCIsImdlbmVyYXRlUG9pbnQiLCJleHRyYUxpbmVDbGFzc2VzIiwiZ2VuZXJhdGVFeHRyYUxpbmVDbGFzcyIsImRhdGFUaW1lRm9ybWF0IiwiZGF0YV94TG9jYWx0aW1lIiwiZDNUaW1lUGFyc2UiLCJkM1V0Y1BhcnNlIiwiYXhpc194X2xvY2FsdGltZSIsImQzVGltZUZvcm1hdCIsImQzVXRjRm9ybWF0IiwiaXNEcmFnWm9vbSIsInpvb21fZW5hYmxlZCIsImlzWm9vbWVkIiwib3JnRG9tYWluIiwic3BlY2lmaWVyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldERhdGUiLCJnZXRNb250aCIsImhpZGRlblRhcmdldElkcyIsImhpZGRlbkxlZ2VuZElkcyIsImZvY3VzZWRUYXJnZXRJZHMiLCJkZWZvY3VzZWRUYXJnZXRJZHMiLCJpc0xlZ2VuZFJpZ2h0IiwibGVnZW5kX3Bvc2l0aW9uIiwiaXNMZWdlbmRJbnNldCIsImlzTGVnZW5kVG9wIiwibGVnZW5kX2luc2V0X2FuY2hvciIsImlzTGVnZW5kTGVmdCIsImxlZ2VuZFN0ZXAiLCJsZWdlbmRJdGVtV2lkdGgiLCJsZWdlbmRJdGVtSGVpZ2h0IiwieTIiLCJyb3RhdGVkX3BhZGRpbmdfbGVmdCIsInJvdGF0ZWRfcGFkZGluZ19yaWdodCIsImF4aXNfeF9zaG93Iiwicm90YXRlZF9wYWRkaW5nX3RvcCIsIndpdGhvdXRGYWRlSW4iLCJpbnB1dFR5cGUiLCJjb252ZXJ0SW5wdXRUeXBlIiwic3VieCIsImQzU2VsZWN0QWxsIiwiaW5pdFpvb20iLCJiaW5kdG8iLCJlbGVtZW50IiwiY2xhc3NuYW1lIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzZWQiLCJ4cyIsImNvbnZlcnREYXRhVG9UYXJnZXRzIiwiZGF0YV9maWx0ZXIiLCJkYXRhX2hpZGUiLCJhZGRIaWRkZW5UYXJnZXRJZHMiLCJtYXBUb0lkcyIsImxlZ2VuZF9oaWRlIiwiYWRkSGlkZGVuTGVnZW5kSWRzIiwiaGFzVHlwZSIsImxlZ2VuZF9zaG93IiwidXBkYXRlU2l6ZXMiLCJ1cGRhdGVTY2FsZXMiLCJnZXRYRG9tYWluIiwic3ViWCIsIm9yZ1hEb21haW4iLCJnZXRZRG9tYWluIiwic3ViWSIsInN1YlkyIiwiaW50ZXJhY3Rpb25fZW5hYmxlZCIsImlzVG91Y2giLCJvbiIsIm9ub3ZlciIsIm9ub3V0Iiwic3ZnX2NsYXNzbmFtZSIsImRlZnMiLCJjbGlwQ2hhcnQiLCJhcHBlbmRDbGlwIiwiY2xpcElkIiwiY2xpcFhBeGlzIiwiY2xpcElkRm9yWEF4aXMiLCJjbGlwWUF4aXMiLCJjbGlwSWRGb3JZQXhpcyIsImNsaXBHcmlkIiwiY2xpcElkRm9yR3JpZCIsImNvbG9yX3RpbGVzIiwicGF0dGVybnMiLCJ1cGRhdGVTdmdTaXplIiwic3ViY2hhcnRfc2hvdyIsImluaXRTdWJjaGFydCIsImluaXRUb29sdGlwIiwiaW5pdExlZ2VuZCIsImluaXRUaXRsZSIsImRhdGFfZW1wdHlfbGFiZWxfdGV4dCIsImluaXRSZWdpb24iLCJjbGlwUGF0aCIsImluaXQiLCJpbml0RXZlbnRSZWN0IiwiaW5pdENoYXJ0RWxlbWVudHMiLCJpbml0R3JpZCIsInpvb21fcHJpdmlsZWdlZCIsInVwZGF0ZVRhcmdldHMiLCJ1cGRhdGVEaW1lbnNpb24iLCJvbmluaXQiLCJyZWRyYXciLCJ3aXRoVHJhbnNmb3JtIiwid2l0aFVwZGF0ZVhEb21haW4iLCJ3aXRoVXBkYXRlT3JnWERvbWFpbiIsIndpdGhUcmFuc2l0aW9uRm9yQXhpcyIsImluaXRpYWxpemluZyIsImRhdGFfb25taW4iLCJkYXRhX29ubWF4IiwibWluTWF4IiwiZ2V0TWluTWF4RGF0YSIsImJpbmRSZXNpemUiLCJkYXRhX2xhYmVscyIsImluaXRUZXh0IiwibGVnZW5kIiwibWFpbkJhciIsIm1haW5MaW5lIiwibWFpbkFyZWEiLCJtYWluQ2lyY2xlIiwibWFpblRleHQiLCJ4MSIsIngyIiwieTEiLCJoYXNBcmMiLCJoYXNBcmNUeXBlIiwiZ2V0TGVnZW5kV2lkdGgiLCJnZXRMZWdlbmRIZWlnaHQiLCJsZWdlbmRIZWlnaHRGb3JCb3R0b20iLCJ4QXhpc0hlaWdodCIsImdldEhvcml6b250YWxBeGlzSGVpZ2h0Iiwic3ViY2hhcnRYQXhpc0hlaWdodCIsInN1YmNoYXJ0X2F4aXNfeF9zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93Iiwic3ViY2hhcnRIZWlnaHQiLCJzdWJjaGFydF9zaXplX2hlaWdodCIsInNldENvbnRhaW5lclNpemUiLCJtYXJnaW4iLCJnZXRDdXJyZW50UGFkZGluZ1RvcCIsImdldEN1cnJlbnRQYWRkaW5nUmlnaHQiLCJnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSIsImdldEN1cnJlbnRQYWRkaW5nTGVmdCIsIm1hcmdpbjIiLCJOYU4iLCJjdXJyZW50SGVpZ2h0IiwibWFyZ2luMyIsInVwZGF0ZVNpemVGb3JMZWdlbmQiLCJjdXJyZW50V2lkdGgiLCJ3aWR0aDIiLCJoZWlnaHQyIiwiYXJjV2lkdGgiLCJhcmNIZWlnaHQiLCJnYXVnZV9mdWxsQ2lyY2xlIiwiZ2V0R2F1Z2VMYWJlbEhlaWdodCIsInVwZGF0ZVJhZGl1cyIsInJhZGl1c0V4cGFuZGVkIiwidXBkYXRlVGFyZ2V0c0ZvclRleHQiLCJ1cGRhdGVUYXJnZXRzRm9yQmFyIiwidXBkYXRlVGFyZ2V0c0ZvckxpbmUiLCJ1cGRhdGVUYXJnZXRzRm9yUmFkYXIiLCJ1cGRhdGVUYXJnZXRzRm9yQXJjIiwidXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0Iiwic2hvd1RhcmdldHMiLCJpc1RhcmdldFRvU2hvdyIsIndpdGhPcHRpb25zIiwiU3ViY2hhcnQiLCJUcmFuc2l0aW9uIiwiRXZlbnRSZWN0IiwiRGltZW5zaW9uIiwiVHJpbVhEb21haW4iLCJUcmFuc2Zvcm0iLCJVcGRhdGVYRG9tYWluIiwiVXBkYXRlT3JnWERvbWFpbiIsIkxlZ2VuZCIsIlVwZGF0ZVhBeGlzIiwiVHJhbnNpdGlvbkZvckV4aXQiLCJUcmFuc2l0aW9uRm9yQXhpcyIsImRlZlZhbCIsInRyYW5zaXRpb25zVmFsdWUiLCJmbG93Iiwid3RoIiwiZ2V0V2l0aE9wdGlvbiIsImR1cmF0aW9uRm9yRXhpdCIsImR1cmF0aW9uRm9yQXhpcyIsImdlbmVyYXRlVHJhbnNpdGlvbnMiLCJ0b29sdGlwX2luaXRfc2hvdyIsImhpZGVUb29sdGlwIiwidXBkYXRlTGVnZW5kIiwicmVkcmF3QXhpcyIsInVwZGF0ZUNpcmNsZVkiLCJ1cGRhdGVYZ3JpZEZvY3VzIiwidXBkYXRlR3JpZCIsInVwZGF0ZVJlZ2lvbiIsInVwZGF0ZUJhciIsInVwZGF0ZUxpbmUiLCJ1cGRhdGVBcmVhIiwidXBkYXRlQ2lyY2xlIiwiaGFzRGF0YUxhYmVsIiwidXBkYXRlVGV4dCIsInJlZHJhd1RpdGxlIiwicmVkcmF3QXJjIiwicmFkYXJzIiwicmVkcmF3UmFkYXIiLCJpc0JhclR5cGUiLCJyZWRyYXdFdmVudFJlY3QiLCJiaW5kWm9vbUV2ZW50IiwiZ2VuZXJhdGVSZWRyYXdMaXN0IiwiaW50ZXJ2YWxGb3JDdWxsaW5nIiwieERvbWFpbkZvclpvb20iLCJoYXNab29tIiwidXBkYXRlWERvbWFpbiIsImF4aXNfeF90aWNrX3ZhbHVlcyIsInpvb21fcmVzY2FsZSIsInVwZGF0ZUxhYmVscyIsImF4aXNfeF90aWNrX2N1bGxpbmdfbWF4Iiwid2l0aFN1YmNoYXJ0IiwiZ2V0RHJhd1NoYXBlIiwicmVkcmF3U3ViY2hhcnQiLCJmbG93Rm4iLCJnZW5lcmF0ZUZsb3ciLCJ4diIsImlzVHJhbnNpdGlvbiIsImlzVGFiVmlzaWJsZSIsInJlZHJhd0xpc3QiLCJnZXRSZWRyYXdMaXN0IiwiYWZ0ZXJSZWRyYXciLCJvbnJlbmRlcmVkIiwid2FpdEZvckRyYXciLCJnZW5lcmF0ZVdhaXQiLCJkM1RyYW5zaXRpb24iLCJhY2MiLCJ0MSIsImFkZCIsImhhc1JhZGFyIiwiaW5kaWNlcyIsImhhc1R5cGVPZiIsImdldFNoYXBlSW5kaWNlcyIsImlzTGluZVR5cGUiLCJnZW5lcmF0ZURyYXdMaW5lIiwiaXNBcmVhVHlwZSIsImdlbmVyYXRlRHJhd0FyZWEiLCJnZW5lcmF0ZURyYXdCYXIiLCJ4Rm9yVGV4dCIsImdlbmVyYXRlWFlGb3JUZXh0IiwieUZvclRleHQiLCJjeCIsInJhZGFyQ2lyY2xlWCIsImNpcmNsZVkiLCJjaXJjbGVYIiwiY3kiLCJyYWRhckNpcmNsZVkiLCJsaXN0IiwiZ3JpZF94X2xpbmVzIiwiZ3JpZF95X2xpbmVzIiwicmVkcmF3R3JpZCIsInJlZHJhd1JlZ2lvbiIsInJlZHJhd0xpbmUiLCJyZWRyYXdBcmVhIiwicmVkcmF3QmFyIiwicmVkcmF3VGV4dCIsInJlZHJhd0NpcmNsZSIsIndpdGhMZWdlbmQiLCJ3aXRoVHJhbnNpdGlvbkZvckV4aXQiLCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSIsInRyYW5zZm9ybUFsbCIsIndpdGhZIiwid2l0aEV2ZW50UmVjdCIsImF4aXNfeF90eXBlIiwiZGF0YV94IiwiZGF0YV94cyIsImF4aXNfeV90eXBlIiwiZ2V0QXhpc1NpemUiLCJnZXRSYWRhclNpemUiLCJnZXRCYXNlVmFsdWUiLCJvcGFjaXR5Rm9yQ2lyY2xlIiwicG9pbnRfc2hvdyIsImlzQnViYmxlVHlwZSIsImlzU2NhdHRlclR5cGUiLCJheGlzX3hfY2F0ZWdvcmllcyIsInlTY2FsZSIsInlBeGlzIiwieTJBeGlzIiwidHJhbnNmb3JtTWFpbiIsInRyYW5zZm9ybUNvbnRleHQiLCJ0cmFuc2Zvcm1MZWdlbmQiLCJicnVzaFNpemUiLCJnZXRYQXhpc0NsaXBYIiwiZ2V0WEF4aXNDbGlwWSIsImdldFhBeGlzQ2xpcFdpZHRoIiwiZ2V0WEF4aXNDbGlwSGVpZ2h0IiwiZ2V0WUF4aXNDbGlwWCIsImdldFlBeGlzQ2xpcFkiLCJnZXRZQXhpc0NsaXBXaWR0aCIsImdldFlBeGlzQ2xpcEhlaWdodCIsImNsaXBJZEZvclN1YmNoYXJ0Iiwid2l0aG91dEF4aXMiLCJyZXNpemVGdW5jdGlvbiIsImdlbmVyYXRlUmVzaXplIiwib25yZXNpemUiLCJyZXNpemVfYXV0byIsInJlc2l6ZVRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZmx1c2giLCJvbnJlc2l6ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbFJlc2l6ZUZ1bmN0aW9ucyIsInJlc2l6ZUZ1bmN0aW9ucyIsImYiLCJzcGxpY2UiLCJjYWxsYmFjayIsInRyYW5zaXRpb25zVG9XYWl0IiwibG9vcCIsImRvbmUiLCJ0aW1lciIsInBhcnNlZERhdGUiLCJkYXRhX3hGb3JtYXQiLCJoaWRkZW4iLCJpc01vYmlsZSIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiaGFzTW91c2UiLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2UiLCJoYXNUb3VjaCIsImludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCIsIkRvY3VtZW50VG91Y2giLCJwaGFzZSIsInBsdWdpbnMiLCJDaGFydCIsImludGVybmFsIiwibG9hZENvbmZpZyIsImJlZm9yZUluaXQiLCIkIiwiZ2V0Q2hhcnRFbGVtZW50cyIsImFmdGVySW5pdCIsImJpbmRUaGlzIiwiYXJnVGhpcyIsInByb3RvdHlwZSIsIk9wdGlvbnMiLCJzaXplX3dpZHRoIiwic2l6ZV9oZWlnaHQiLCJwYWRkaW5nX2xlZnQiLCJwYWRkaW5nX3JpZ2h0IiwicGFkZGluZ190b3AiLCJwYWRkaW5nX2JvdHRvbSIsInpvb21fZXh0ZW50Iiwiem9vbV9vbnpvb20iLCJ6b29tX29uem9vbXN0YXJ0Iiwiem9vbV9vbnpvb21lbmQiLCJ6b29tX3Jlc2V0QnV0dG9uIiwiem9vbV94X21pbiIsInpvb21feF9tYXgiLCJpbnRlcmFjdGlvbl9icmlnaHRlbiIsImRhdGFfeFNvcnQiLCJkYXRhX2lkQ29udmVydGVyIiwiZGF0YV9uYW1lcyIsImRhdGFfY2xhc3NlcyIsImRhdGFfZ3JvdXBzIiwiZGF0YV90eXBlIiwiZGF0YV90eXBlcyIsImRhdGFfbGFiZWxzX2NvbG9ycyIsImRhdGFfbGFiZWxzX3Bvc2l0aW9uIiwiZGF0YV9vcmRlciIsImRhdGFfcmVnaW9ucyIsImRhdGFfY29sb3IiLCJkYXRhX2NvbG9ycyIsImRhdGFfc3RhY2tfbm9ybWFsaXplIiwiZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCIsImRhdGFfc2VsZWN0aW9uX2dyb3VwZWQiLCJkYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUiLCJkYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSIsImRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSIsImRhdGFfb25jbGljayIsImRhdGFfb25vdmVyIiwiZGF0YV9vbm91dCIsImRhdGFfb25zZWxlY3RlZCIsImRhdGFfb251bnNlbGVjdGVkIiwiZGF0YV91cmwiLCJkYXRhX2hlYWRlcnMiLCJkYXRhX2pzb24iLCJkYXRhX3Jvd3MiLCJkYXRhX2NvbHVtbnMiLCJkYXRhX21pbWVUeXBlIiwiZGF0YV9rZXlzIiwic3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdyIsInN1YmNoYXJ0X29uYnJ1c2giLCJjb2xvcl9wYXR0ZXJuIiwiY29sb3JfdGhyZXNob2xkIiwiY29sb3Jfb25vdmVyIiwibGVnZW5kX2NvbnRlbnRzX2JpbmR0byIsImxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSIsImxlZ2VuZF9pbnNldF94IiwibGVnZW5kX2luc2V0X3kiLCJsZWdlbmRfaW5zZXRfc3RlcCIsImxlZ2VuZF9pdGVtX29uY2xpY2siLCJsZWdlbmRfaXRlbV9vbm92ZXIiLCJsZWdlbmRfaXRlbV9vbm91dCIsImxlZ2VuZF9lcXVhbGx5IiwibGVnZW5kX3BhZGRpbmciLCJsZWdlbmRfaXRlbV90aWxlX3dpZHRoIiwibGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQiLCJsZWdlbmRfdXNlUG9pbnQiLCJheGlzX3hfY2xpcFBhdGgiLCJheGlzX3hfdGlja19zaG93IiwiYXhpc194X3RpY2tfdGV4dF9zaG93IiwiYXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeF90aWNrX291dGVyIiwiYXhpc194X21heCIsImF4aXNfeF9taW4iLCJheGlzX3hfcGFkZGluZyIsImF4aXNfeF9leHRlbnQiLCJheGlzX3hfbGFiZWwiLCJheGlzX3hfYXhlcyIsImF4aXNfeV9jbGlwUGF0aCIsImF4aXNfeV9zaG93IiwiYXhpc195X21heCIsImF4aXNfeV9taW4iLCJheGlzX3lfaW52ZXJ0ZWQiLCJheGlzX3lfY2VudGVyIiwiYXhpc195X2xhYmVsIiwiYXhpc195X3RpY2tfZm9ybWF0IiwiYXhpc195X3RpY2tfb3V0ZXIiLCJheGlzX3lfdGlja192YWx1ZXMiLCJheGlzX3lfdGlja19jb3VudCIsImF4aXNfeV90aWNrX3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195X3BhZGRpbmciLCJheGlzX3lfZGVmYXVsdCIsImF4aXNfeV9heGVzIiwiYXhpc195Ml9tYXgiLCJheGlzX3kyX21pbiIsImF4aXNfeTJfaW52ZXJ0ZWQiLCJheGlzX3kyX2NlbnRlciIsImF4aXNfeTJfbGFiZWwiLCJheGlzX3kyX3RpY2tfZm9ybWF0IiwiYXhpc195Ml90aWNrX291dGVyIiwiYXhpc195Ml90aWNrX3ZhbHVlcyIsImF4aXNfeTJfdGlja19jb3VudCIsImF4aXNfeTJfdGlja19zaG93IiwiYXhpc195Ml90aWNrX3RleHRfc2hvdyIsImF4aXNfeTJfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195Ml9wYWRkaW5nIiwiYXhpc195Ml9kZWZhdWx0IiwiYXhpc195Ml9heGVzIiwiZ3JpZF94X3Nob3ciLCJncmlkX3hfdHlwZSIsImdyaWRfeV9zaG93IiwiZ3JpZF95X3RpY2tzIiwiZ3JpZF9mb2N1c19zaG93IiwiZ3JpZF9mcm9udCIsImdyaWRfbGluZXNfZnJvbnQiLCJwb2ludF9yIiwicG9pbnRfc2Vuc2l0aXZpdHkiLCJwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCIsInBvaW50X2ZvY3VzX2V4cGFuZF9yIiwicG9pbnRfcGF0dGVybiIsInBvaW50X3NlbGVjdF9yIiwicG9pbnRfdHlwZSIsImxpbmVfY29ubmVjdE51bGwiLCJsaW5lX3N0ZXBfdHlwZSIsImxpbmVfY2xhc3NlcyIsImxpbmVfcG9pbnQiLCJiYXJfcGFkZGluZyIsImJhcl9yYWRpdXMiLCJiYXJfcmFkaXVzX3JhdGlvIiwiYmFyX3NlbnNpdGl2aXR5IiwiYmFyX3dpZHRoIiwiYmFyX3dpZHRoX3JhdGlvIiwiYmFyX3dpZHRoX21heCIsImJhcl96ZXJvYmFzZWQiLCJidWJibGVfbWF4UiIsImFyZWFfemVyb2Jhc2VkIiwiYXJlYV9hYm92ZSIsImFyZWFfbGluZWFyR3JhZGllbnQiLCJwaWVfbGFiZWxfc2hvdyIsInBpZV9sYWJlbF9mb3JtYXQiLCJwaWVfbGFiZWxfdGhyZXNob2xkIiwicGllX2xhYmVsX3JhdGlvIiwicGllX2V4cGFuZCIsInBpZV9leHBhbmRfZHVyYXRpb24iLCJwaWVfaW5uZXJSYWRpdXMiLCJwaWVfcGFkQW5nbGUiLCJwaWVfcGFkZGluZyIsImdhdWdlX2xhYmVsX3Nob3ciLCJnYXVnZV9sYWJlbF9mb3JtYXQiLCJnYXVnZV9taW4iLCJnYXVnZV9tYXgiLCJnYXVnZV9zdGFydGluZ0FuZ2xlIiwiZ2F1Z2VfbGFiZWxfZXh0ZW50cyIsImdhdWdlX3RpdGxlIiwiZ2F1Z2VfdW5pdHMiLCJnYXVnZV93aWR0aCIsImdhdWdlX2V4cGFuZCIsImdhdWdlX2V4cGFuZF9kdXJhdGlvbiIsImRvbnV0X2xhYmVsX3Nob3ciLCJkb251dF9sYWJlbF9mb3JtYXQiLCJkb251dF9sYWJlbF90aHJlc2hvbGQiLCJkb251dF9sYWJlbF9yYXRpbyIsImRvbnV0X3dpZHRoIiwiZG9udXRfdGl0bGUiLCJkb251dF9leHBhbmQiLCJkb251dF9leHBhbmRfZHVyYXRpb24iLCJkb251dF9wYWRBbmdsZSIsInNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGUiLCJyYWRhcl9heGlzX21heCIsInJhZGFyX2F4aXNfbGluZV9zaG93IiwicmFkYXJfYXhpc190ZXh0X3Nob3ciLCJyYWRhcl9sZXZlbF9kZXB0aCIsInJhZGFyX2xldmVsX3Nob3ciLCJyYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCIsInJhZGFyX2xldmVsX3RleHRfc2hvdyIsInJhZGFyX3NpemVfcmF0aW8iLCJyYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlIiwidG9vbHRpcF9zaG93IiwidG9vbHRpcF9kb05vdEhpZGUiLCJ0b29sdGlwX2dyb3VwZWQiLCJ0b29sdGlwX2Zvcm1hdF90aXRsZSIsInRvb2x0aXBfZm9ybWF0X25hbWUiLCJ0b29sdGlwX2Zvcm1hdF92YWx1ZSIsInRvb2x0aXBfcG9zaXRpb24iLCJ0b29sdGlwX2NvbnRlbnRzIiwidG9vbHRpcF9pbml0X3giLCJ0b29sdGlwX2luaXRfcG9zaXRpb24iLCJ0b29sdGlwX2xpbmtlZCIsInRvb2x0aXBfbGlua2VkX25hbWUiLCJ0b29sdGlwX29uc2hvdyIsInRvb2x0aXBfb25oaWRlIiwidG9vbHRpcF9vbnNob3duIiwidG9vbHRpcF9vbmhpZGRlbiIsInRvb2x0aXBfb3JkZXIiLCJ0aXRsZV90ZXh0IiwidGl0bGVfcGFkZGluZyIsInRpdGxlX3Bvc2l0aW9uIiwicmVhZCIsInRoaXNDb25maWciLCJmaW5kIiwiZ2V0U2NhbGUiLCJmb3JUaW1lc2VyaWVzIiwiZDNTY2FsZVRpbWUiLCJnZXRYIiwib2Zmc2V0IiwiZ2V0Q3VzdG9taXplZFNjYWxlIiwiZ2V0WSIsInNjYWxlVmFsdWUiLCJvZmZzZXRWYWx1ZSIsInJhdyIsIm9yZ1NjYWxlIiwiZG9tYWluVmFsdWUiLCJnZXRZU2NhbGUiLCJnZXRJZCIsImdldFN1YllTY2FsZSIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJzdWJYTWluIiwic3ViWE1heCIsInN1YllNaW4iLCJzdWJZTWF4IiwieERvbWFpbiIsInhTdWJEb21haW4iLCJnZXRYQXhpc1RpY2tGb3JtYXQiLCJnZXRYQXhpc1RpY2tWYWx1ZXMiLCJnZXRYQXhpcyIsInlBeGlzVGlja1ZhbHVlcyIsImdldFlBeGlzVGlja1ZhbHVlcyIsImdldFlBeGlzIiwieTJBeGlzVGlja1ZhbHVlcyIsImdldFkyQXhpc1RpY2tWYWx1ZXMiLCJ1cGRhdGVBcmMiLCJnZXRZRG9tYWluTWluTWF4IiwiaXNNaW4iLCJkYXRhR3JvdXBzIiwiaWRzIiwieXMiLCJnZXRWYWx1ZXNBc0lkS2V5ZWQiLCJpZHNJbkdyb3VwIiwiaiIsImJhc2VJZCIsImJhc2VBeGlzSWQiLCJrIiwiYXhpc0lkIiwidmFsIiwibWVldENvbmRpdGlvbiIsImdldFlEb21haW5NaW4iLCJnZXRZRG9tYWluTWF4IiwidGFyZ2V0c0J5QXhpc0lkIiwieVRhcmdldHMiLCJmaWx0ZXJCeVhEb21haW4iLCJ5RG9tYWluTWluIiwieURvbWFpbk1heCIsImNlbnRlciIsImlzWmVyb0Jhc2VkIiwiaXNJbnZlcnRlZCIsInNob3dIb3Jpem9udGFsRGF0YUxhYmVsIiwic2hvd1ZlcnRpY2FsRGF0YUxhYmVsIiwiaXNBbGxQb3NpdGl2ZSIsImlzQWxsTmVnYXRpdmUiLCJhYnMiLCJ5RG9tYWluQWJzIiwicmF0aW8iLCJnZXREYXRhTGFiZWxMZW5ndGgiLCJsZW5ndGhzIiwiZ2V0UGFkZGluZyIsInJldmVyc2UiLCJnZXRYRG9tYWluTWluTWF4IiwiZ2V0WERvbWFpbk1pbiIsImdldFhEb21haW5NYXgiLCJnZXRYRG9tYWluUGFkZGluZyIsIm1heERhdGFDb3VudCIsInhQYWRkaW5nIiwiZ2V0TWF4RGF0YUNvdW50IiwiZmlyc3RYIiwibGFzdFgiLCJnZXRUaW1lIiwid2l0aFRyaW0iLCJ6b29tRW5hYmxlZCIsInpvb20iLCJ1cGRhdGVTY2FsZUV4dGVudCIsImludmVydCIsInRyaW1YRG9tYWluIiwiem9vbURvbWFpbiIsImdldFpvb21Eb21haW4iLCJpc1giLCJkYXRhS2V5IiwiZXhpc3RWYWx1ZSIsImlzTm90WCIsImlzR3JvdXBlZCIsImdldFhLZXkiLCJnZXRYVmFsdWVzT2ZYS2V5IiwieFZhbHVlcyIsImdldEluZGV4QnlYIiwiYmFzZWRYIiwiZmlsdGVyQnlYIiwiZ2V0WFZhbHVlIiwiZ2V0T3RoZXJUYXJnZXRYcyIsImlkc0ZvclgiLCJnZXRPdGhlclRhcmdldFgiLCJhZGRYcyIsImhhc011bHRpcGxlWCIsImlzTXVsdGlwbGVYIiwiYWRkTmFtZSIsImdldEFsbFZhbHVlc09uSW5kZXgiLCJnZXRWYWx1ZU9uSW5kZXgiLCJ2YWx1ZU9uSW5kZXgiLCJ1cGRhdGVUYXJnZXRYIiwiZ2VuZXJhdGVUYXJnZXRYIiwidXBkYXRlVGFyZ2V0WHMiLCJyYXdYIiwiaXNDdXN0b21YIiwiY2xvbmVUYXJnZXQiLCJpZF9vcmciLCJ1cGRhdGVYcyIsImdldFByZXZYIiwiZ2V0TmV4dFgiLCJpc0FyZWFSYW5nZVR5cGUiLCJnZXRBcmVhUmFuZ2VEYXRhIiwiZ2V0TWluTWF4VmFsdWUiLCJjYWNoZUtleSIsIm1pbk1heERhdGEiLCJnZXRDYWNoZSIsIm1pbkRhdGEiLCJnZXRGaWx0ZXJlZERhdGFCeVZhbHVlIiwibWF4RGF0YSIsImFkZENhY2hlIiwiZ2V0VG90YWxQZXJJbmRleCIsInN1bSIsInJvdyIsImdldFRvdGFsRGF0YVN1bSIsInRvdGFsRGF0YVN1bSIsInRvdGFsIiwiZ2V0TWF4RGF0YUNvdW50VGFyZ2V0IiwibWF4VGFyZ2V0IiwibWFwVG9UYXJnZXRJZHMiLCJoYXNUYXJnZXQiLCJ0YXJnZXRJZCIsImlzTGVnZW5kVG9TaG93IiwidGFyZ2V0SWRzIiwicmVtb3ZlSGlkZGVuVGFyZ2V0SWRzIiwicmVtb3ZlSGlkZGVuTGVnZW5kSWRzIiwiY2hlY2tWYWx1ZUluVGFyZ2V0cyIsImNoZWNrZXIiLCJoYXNNdWx0aVRhcmdldHMiLCJoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzIiwiaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyIsIl9jaGVja09yZGVyIiwib3JkZXIiLCJpc09yZGVyRGVzYyIsImlzT3JkZXJBc2MiLCJvcmRlclRhcmdldHMiLCJ0YXJnZXRzVmFsdWUiLCJvcmRlckFzYyIsIm9yZGVyRGVzYyIsInQyIiwicmVkdWNlciIsInQxU3VtIiwidDJTdW0iLCJmaWx0ZXJSZW1vdmVOdWxsIiwiZGF0YUxhYmVscyIsImRhdGFMYWJlbEZvcm1hdCIsImlzTm9uZUFyYyIsImlzQXJjIiwiZmluZFNhbWVYT2ZWYWx1ZXMiLCJ0YXJnZXRYIiwic2FtZXMiLCJmaW5kQ2xvc2VzdEZyb21UYXJnZXRzIiwiY2FuZGlkYXRlcyIsImZpbmRDbG9zZXN0IiwiY2xvc2VzdCIsIm1pbkRpc3QiLCJnZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCIsImlzV2l0aGluQmFyIiwiZGlzdCIsInhJbmRleCIsInlJbmRleCIsInNxcnQiLCJwb3ciLCJjb252ZXJ0VmFsdWVzVG9TdGVwIiwic3RlcFR5cGUiLCJjb252ZXJ0ZWQiLCJjb252ZXJ0VmFsdWVzVG9SYW5nZSIsInJhbmdlcyIsInVwZGF0ZURhdGFBdHRyaWJ1dGVzIiwiYXR0cnMiLCJjdXJyZW50IiwiZ2V0UmF0aW8iLCJhc1BlcmNlbnQiLCJzaG93biIsImRhdGFWYWx1ZXMiLCJwaWUiLCJwYWRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRBbmdsZSIsImhpZGRlblN1bSIsImN1cnIiLCJwYXJzZUZsb2F0IiwibWF4VmFsdWUiLCJ1cmwiLCJjb252ZXJ0VXJsVG9EYXRhIiwibWltZVR5cGUiLCJoZWFkZXJzIiwianNvbiIsImNvbnZlcnRKc29uVG9EYXRhIiwicm93cyIsImNvbnZlcnRSb3dzVG9EYXRhIiwiY29sdW1ucyIsImNvbnZlcnRDb2x1bW5zVG9EYXRhIiwiRXJyb3IiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJvcGVuIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwiSlNPTiIsInBhcnNlIiwic2VuZCIsIl9jb252ZXJ0Q3N2VHN2VG9EYXRhIiwicGFyc2VyIiwieHN2IiwiY29udmVydENzdlRvRGF0YSIsImQzQ3N2UGFyc2VSb3dzIiwiZDNDc3ZQYXJzZSIsImNvbnZlcnRUc3ZUb0RhdGEiLCJ0c3YiLCJkM1RzdlBhcnNlUm93cyIsImQzVHN2UGFyc2UiLCJrZXlzUGFyYW0iLCJ0YXJnZXRLZXlzIiwibmV3Um93cyIsIm5ld1JvdyIsImZpbmRWYWx1ZUluSnNvbiIsInRtcCIsIm9iamVjdCIsImNvbnZlcnRlZFBhdGgiLCJwYXRoQXJyYXkiLCJzb21lIiwibGVuMSIsImxlbjIiLCJhcHBlbmRYcyIsInhzRGF0YSIsImRhdGFLZXlzIiwieEtleSIsImNvbnZlcnRlZElkIiwiaGFzQ2F0ZWdvcnkiLCJoaWdoIiwidjEiLCJ2MiIsImhhc05lZ2F0aXZlVmFsdWUiLCJoYXNQb3NpdGl2ZVZhbHVlIiwic2V0VGFyZ2V0VHlwZSIsImxvYWQiLCJyYXdUYXJnZXRzIiwidHlwZXMiLCJsb2FkRnJvbUFyZ3MiLCJyZXNldENhY2hlIiwidW5sb2FkIiwicmF3VGFyZ2V0SWRzIiwiY3VzdG9tRG9uZUNiIiwic2VsZWN0b3JUYXJnZXQiLCJlbmRhbGwiLCJldmVudFJlY3RVcGRhdGUiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzIiwibWF4RGF0YUNvdW50VGFyZ2V0IiwiZGF0dW0iLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYIiwidXBkYXRlRXZlbnRSZWN0IiwiYmluZFRvdWNoT25FdmVudFJlY3QiLCJzdGFydFB4IiwiZ2V0RXZlbnRSZWN0IiwiZWxlbWVudEZyb21Qb2ludCIsImdldEluZGV4Iiwic2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzIiwiY2FsbE92ZXJPdXRGb3JUb3VjaCIsInVuc2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JTaW5nbGUiLCJwcmV2ZW50RGVmYXVsdCIsImlzUHJldmVudGVkIiwicHJldmVudFRocmVzaG9sZCIsInByZXZlbnRFdmVudCIsImN1cnJlbnRYWSIsInRvZ2dsZVNoYXBlIiwieFNjYWxlIiwiZXZlbnRSZWN0RGF0YSIsInJlY3RXIiwicmVjdFgiLCJnZXRFdmVudFJlY3RXaWR0aCIsImdldFByZXZOZXh0WCIsInByZXYiLCJuZXh0IiwidGhpc1giLCJjbGFzc0V2ZW50IiwiaXNTZWxlY3Rpb25FbmFibGVkIiwiaXNTZWxlY3Rpb25Hcm91cGVkIiwiaXNUb29sdGlwR3JvdXBlZCIsInNlbGVjdGVkRGF0YSIsInNob3dUb29sdGlwIiwic2hvd1hHcmlkRm9jdXMiLCJoaWRlWEdyaWRGb2N1cyIsImV4cGFuZENpcmNsZXNCYXJzIiwiaXNXaXRoaW5TaGFwZSIsInNlbGVjdGVkIiwidW5leHBhbmRDaXJjbGVzIiwicmVzZXQiLCJleHBhbmRDaXJjbGVzIiwiZXhwYW5kQmFycyIsImQzTW91c2UiLCJzYW1lWERhdGEiLCJfaGFuZGxlTGlua2VkQ2hhcnRzIiwidW5leHBhbmRCYXJzIiwic2V0T3Zlck91dCIsImlzT3ZlciIsInNldE92ZXJDb2xvciIsImNhbGxlZSIsImxhc3QiLCJnZXREcmFnZ2FibGVTZWxlY3Rpb24iLCJkcmFnIiwiZDNEcmFnIiwiZHJhZ3N0YXJ0IiwiZHJhZ2VuZCIsImV2ZW50UmVjdEVudGVyIiwicmVjdCIsImNsaWNrSGFuZGxlckZvclNpbmdsZVgiLCJpc1N0ZXBUeXBlIiwiZDIiLCJjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTIiwic2VsZWN0b3IiLCJnZXRDdXJyZW50V2lkdGgiLCJnZXRDdXJyZW50SGVpZ2h0IiwiZ2V0UGFyZW50V2lkdGgiLCJnZXRQYXJlbnRIZWlnaHQiLCJnZXRBeGlzV2lkdGhCeUF4aXNJZCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJsZWdlbmRXaWR0aE9uUmlnaHQiLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsInBhcmVudE5vZGUiLCJib2R5V2lkdGgiLCJvZmZzZXRXaWR0aCIsInBhcnNlSW50IiwiZ2V0U3ZnTGVmdCIsImhhc0xlZnRBeGlzUmVjdCIsImxlZnRBeGlzQ2xhc3MiLCJsZWZ0QXhpcyIsInN2Z1JlY3QiLCJjaGFydFJlY3QiLCJzdmdMZWZ0IiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJjb3MiLCJ0aWNrSW50ZXJ2YWwiLCJ0eXBlRmlsdGVyIiwiZ3JvdXBzIiwiX19tYXhfXyIsImdldFNoYXBlWCIsInRhcmdldHNOdW0iLCJpc1N1YiIsImJhclBhZGRpbmciLCJoYWxmV2lkdGgiLCJ4UG9zIiwiZ2V0U2hhcGVZIiwiZ2V0U2hhcGVPZmZzZXQiLCJpZHgiLCJ5MCIsInJvd1ZhbHVlcyIsInRoYXQiLCJpc1dpdGhpbiIsImhhc1ZhbGlkUG9pbnRUeXBlIiwibm9kZU5hbWUiLCJpc1dpdGhpblN0ZXAiLCJpc1dpdGhpbkNpcmNsZSIsInBvaW50U2VsZWN0UiIsImdldEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGlvbiIsImdldEludGVycG9sYXRlVHlwZSIsImQzQ3VydmVCYXNpcyIsImQzQ3VydmVCYXNpc0Nsb3NlZCIsImQzQ3VydmVCYXNpc09wZW4iLCJkM0N1cnZlQnVuZGxlIiwiZDNDdXJ2ZUNhcmRpbmFsIiwiZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkIiwiZDNDdXJ2ZUNhcmRpbmFsT3BlbiIsImQzQ3VydmVDYXRtdWxsUm9tIiwiZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQiLCJkM0N1cnZlQ2F0bXVsbFJvbU9wZW4iLCJkM0N1cnZlTW9ub3RvbmVYIiwiZDNDdXJ2ZU1vbm90b25lWSIsImQzQ3VydmVOYXR1cmFsIiwiZDNDdXJ2ZUxpbmVhckNsb3NlZCIsImQzQ3VydmVMaW5lYXIiLCJkM0N1cnZlU3RlcCIsImQzQ3VydmVTdGVwQWZ0ZXIiLCJkM0N1cnZlU3RlcEJlZm9yZSIsImlzSW50ZXJwb2xhdGlvblR5cGUiLCJpc1NwbGluZVR5cGUiLCJpbml0UGllIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwicmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImlubmVyUmFkaXVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwic3ZnQXJjRXhwYW5kZWRTdWIiLCJ1cGRhdGVBbmdsZSIsImRWYWx1ZSIsImlzR2F1Z2VUeXBlIiwidG90YWxTdW0iLCJnU3RhcnQiLCJnRW5kIiwiaXIiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwid2l0aG91dFVwZGF0ZSIsInVwZGF0ZWQiLCJjZW50cm9pZCIsInJhdGUiLCJnZXRBcmMiLCJpc0FyY1R5cGUiLCJ0cmFuc2Zvcm1Gb3JBcmNMYWJlbCIsInRyYW5zbGF0ZSIsImNvbnZlcnRUb0FyY0RhdGEiLCJ0ZXh0Rm9yQXJjTGFiZWwiLCJzaG91bGRTaG93QXJjTGFiZWwiLCJpc1VuZGVyVGhyZXNob2xkIiwibWVldHNBcmNMYWJlbFRocmVzaG9sZCIsImdldEFyY0xhYmVsRm9ybWF0IiwiZGVmYXVsdEFyY1ZhbHVlRm9ybWF0IiwidGV4dEZvckdhdWdlTWluTWF4IiwiaXNNYXgiLCJnZXRHYXVnZUxhYmVsRXh0ZW50cyIsImV4cGFuZEFyYyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm5ld1RhcmdldElkcyIsInNlbGVjdG9yVGFyZ2V0cyIsInNob3VsZEV4cGFuZCIsImV4cGFuZER1cmF0aW9uIiwidW5leHBhbmRBcmMiLCJpc0RvbnV0VHlwZSIsImlzUGllVHlwZSIsInRocmVzaG9sZCIsImdldEFyY1RpdGxlIiwiaGFzR2F1Z2UiLCJjbGFzc0NoYXJ0QXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NGb2N1cyIsIm1haW5QaWVVcGRhdGUiLCJtYWluUGllRW50ZXIiLCJpbml0QXJjIiwic2V0QXJjVGl0bGUiLCJoYXNJbnRlcmFjdGlvbiIsIm1haW5BcmMiLCJhcmNEYXRhIiwiY2xhc3NBcmMiLCJfY3VycmVudCIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJzZWxlY3RBcmMiLCJfdGhpcyIsImZvY3VzIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJ1bnNlbGVjdEFyYyIsInJldmVydCIsInJldmVydExlZ2VuZCIsImlzTW91c2UiLCJnZXRFdmVudEFyYyIsImV2ZW50QXJjIiwiaGFuZGxlciIsImlzRnVsbENpcmNsZSIsImluaXRHYXVnZSIsImFwcGVuZFRleHQiLCJpbml0QmFyIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQmFycyIsIm1haW5CYXJVcGRhdGUiLCJtYWluQmFyRW50ZXIiLCJiYXJEYXRhIiwiY2xhc3NCYXIiLCJpbml0aWFsT3BhY2l0eSIsImRyYXdCYXIiLCJnZXRCYXJXIiwiYmFyVGFyZ2V0c051bSIsInJlc3VsdCIsImdldFdpZHRoIiwiZ2V0QmFycyIsInN1ZmZpeCIsImJhckluZGljZXMiLCJnZXRQb2ludHMiLCJnZW5lcmF0ZUdldEJhclBvaW50cyIsImJhclJhZGl1cyIsImJhclJhZGl1c1JhdGlvIiwiZ2V0UmFkaXVzIiwicG9pbnRzIiwiaW5kZXhYIiwiaW5kZXhZIiwiaXNOZWdhdGl2ZSIsInBhdGhSYWRpdXMiLCJiYXJXIiwiYmFyWCIsImJhclkiLCJiYXJPZmZzZXQiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJjbGFzc0NoYXJ0TGluZSIsImNsYXNzTGluZXMiLCJjbGFzc0FyZWFzIiwiY2xhc3NDaXJjbGVzIiwibWFpbkxpbmVVcGRhdGUiLCJtYWluTGluZUVudGVyIiwiZ2VuZXJhdGVDbGFzcyIsImxpbmVEYXRhIiwiY2xhc3NMaW5lIiwiZHJhd0xpbmUiLCJnZXRDdXJ2ZSIsImlzUm90YXRlZFN0ZXBUeXBlIiwic3RlcCIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJsaW5lSW5kaWNlcyIsImxpbmVDb25uZWN0TnVsbCIsImdlbmVyYXRlR2V0TGluZVBvaW50cyIsInlTY2FsZUdldHRlciIsInhWYWx1ZSIsInN1Ynh4IiwieHgiLCJ5VmFsdWUiLCJkM0xpbmUiLCJkZWZpbmVkIiwieDAiLCJsaW5lV2l0aFJlZ2lvbnMiLCJjdXJ2ZSIsImlzU3ViVmFsdWUiLCJsaW5lVGFyZ2V0c051bSIsImxpbmVPZmZzZXQiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJ4T2Zmc2V0IiwiZGFzaGFycmF5IiwiaXNXaXRoaW5SZWdpb25zIiwid2l0aGluWCIsIndpdGhpblJlZ2lvbnMiLCJyZWciLCJnZXRWYWx1ZSIsImR0IiwiZ2VuZXJhdGVNIiwic1dpdGhSZWdpb24iLCJkMCIsImQxIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiZGQiLCJ1cGRhdGVBcmVhR3JhZGllbnQiLCJzdG9wcyIsImxpbmVhckdyYWRpZW50Iiwic3RvcENvbG9yIiwidXBkYXRlQXJlYUNvbG9yIiwiY2xhc3NBcmVhIiwib3JnQXJlYU9wYWNpdHkiLCJkcmF3QXJlYSIsImFyZWFJbmRpY2VzIiwiZ2VuZXJhdGVHZXRBcmVhUG9pbnRzIiwidmFsdWUwIiwidmFsdWUxIiwiZDNBcmVhIiwiYXJlYVRhcmdldHNOdW0iLCJhcmVhT2Zmc2V0Iiwic2hvdWxkRHJhd1BvaW50c0ZvckxpbmUiLCJsYWJlbGlzaERhdGEiLCJjbGFzc0NpcmNsZSIsInBvaW50UiIsImluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlIiwibWFpbkNpcmNsZXMiLCJwb3NBdHRyIiwiaXNDaXJjbGVQb2ludCIsImdldENpcmNsZXMiLCJwb2ludEV4cGFuZGVkUiIsInNlbGVjdFIiLCJpcyIsImxpbmVQb2ludCIsImhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyIsInBvaW50VHlwZSIsInVwZGF0ZSIsImluc2VydFBvaW50SW5mb0RlZnMiLCJjb3B5QXR0ciIsImZyb20iLCJhdHRyaWJzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNsb25lIiwiY3JlYXRlRWxlbWVudE5TIiwiZDNOYW1lc3BhY2VzIiwiZmlsbCIsInN0cm9rZSIsImNoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJwb2ludEZyb21EZWZzIiwicGF0dGVybiIsIm1ldGhvZCIsInBvaW50SWQiLCJjdXN0b20iLCJnZXRUcmFuc2l0aW9uTmFtZSIsImNzc0NsYXNzRm4iLCJzaXplRm4iLCJmaWxsU3R5bGVGbiIsInhQb3NGbiIsInlQb3NGbiIsIm9wYWNpdHlTdHlsZUZuIiwieFBvc0ZuMiIsInlQb3NGbjIiLCJ0cmFuc2l0aW9uTmFtZSIsInJlY3RhbmdsZSIsInJlY3RTaXplRm4iLCJyZWN0WFBvc0ZuIiwicmVjdFlQb3NGbiIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibCIsImxldmVsVGV4dEZvcm1hdCIsImpvaW4iLCJsZXZlbEVudGVyIiwiYXhpc0VudGVyIiwiYmluZEV2ZW50IiwiaGlkZSIsIm5vSW5kZXgiLCJhcmVhc0VudGVyIiwiY2xhc3NDaGFydFJhZGFyIiwiY2xhc3NDaGFydFRleHQiLCJjbGFzc1RleHRzIiwibWFpblRleHRVcGRhdGUiLCJtYWluVGV4dEVudGVyIiwiZGF0YUZuIiwiY2xhc3NUZXh0IiwiaXNSYWRhclR5cGUiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsImZvckZsb3ciLCJvcGFjaXR5Rm9yVGV4dCIsImdldFRleHRSZWN0IiwiYmFzZSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImZvclgiLCJnZXR0ZXIiLCJnZXRYRm9yVGV4dCIsImdldFlGb3JUZXh0IiwiZ2V0Q2VudGVyZWRUZXh0UG9zIiwidGV4dEVsZW1lbnQiLCJjZW50ZXJlZCIsImlzUG9zaXRpdmUiLCJ5UG9zIiwiYmFzZVkiLCJib3hIZWlnaHQiLCJUWVBFUyIsIkFyZWEiLCJBcmVhUmFuZ2UiLCJBcmMiLCJMaW5lIiwiU3RlcCIsIlNwbGluZSIsImV4Y2x1ZGUiLCJpc1R5cGVPZiIsImRhdGFUeXBlIiwiYmFyTGluZUJ1YmJsZURhdGEiLCJnZXRHcmlkVGV4dEFuY2hvciIsImdldEdyaWRUZXh0RHgiLCJnZXRHcmlkVGV4dFgiLCJpbml0R3JpZExpbmVzIiwiaW5pdFhZRm9jdXNHcmlkIiwiY2xpcFBhdGhGb3JHcmlkIiwidXBkYXRlWEdyaWQiLCJ4Z3JpZERhdGEiLCJnZW5lcmF0ZUdyaWREYXRhIiwieGdyaWRBdHRyIiwidXBkYXRlWUdyaWQiLCJncmlkVmFsdWVzIiwic21vb3RoTGluZXMiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInRyaW0iLCJ5diIsImlzRnJvbnQiLCJkYXRhVG9TaG93IiwiZm9jdXNFbCIsInRpY2tOdW0iLCJncmlkRGF0YSIsImZpcnN0WWVhciIsImdldEZ1bGxZZWFyIiwibGFzdFllYXIiLCJnZXRHcmlkRmlsdGVyVG9SZW1vdmUiLCJwYXJhbSIsInJlbW92ZUdyaWRMaW5lcyIsInRvUmVtb3ZlIiwiZ2V0VG9vbHRpcEhUTUwiLCJnZXRZRm9ybWF0IiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJkZWZhdWx0VGl0bGVGb3JtYXQiLCJkZWZhdWx0VmFsdWVGb3JtYXQiLCJ0aXRsZUZvcm1hdCIsIm5hbWVGb3JtYXQiLCJ2YWx1ZUZvcm1hdCIsImdldFJvd1ZhbHVlIiwiZ2V0QmdDb2xvciIsImNvbnRlbnRzIiwidHBsU3RyIiwidGVtcGxhdGUiLCJpMiIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiVElUTEUiLCJsb3ciLCJjb250ZW50VmFsdWUiLCJDTEFTU19UT09MVElQX05BTUUiLCJDT0xPUiIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsInRXaWR0aCIsInRIZWlnaHQiLCJjaGFydFJpZ2h0IiwiZGF0YVNjYWxlIiwiZm9yQXJjIiwicG9zaXRpb25GdW5jdGlvbiIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsInNob3ciLCJsaW5rZWROYW1lIiwiY2hhcnRzIiwiaXNMaW5rZWQiLCJpc0luRG9tIiwiY29udGFpbnMiLCJpc05vdFNhbWVJbmRleCIsImxlZ2VuZEl0ZW1UZXh0Qm94IiwibGVnZW5kSGFzUmVuZGVyZWQiLCJvcHRpb256IiwidXBkYXRlTGVnZW5kVGVtcGxhdGUiLCJ1cGRhdGVMZWdlbmRFbGVtZW50Iiwid3JhcHBlciIsImNvbnRlbnQiLCJzZXRMZWdlbmRJdGVtIiwiaW5zZXRMZWdlbmRQb3NpdGlvbiIsInVwZGF0ZUxlZ2VuZFN0ZXAiLCJ1cGRhdGVMZWdlbmRJdGVtV2lkdGgiLCJ1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0Iiwib3BhY2l0eUZvckxlZ2VuZCIsIm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQiLCJ0YXJnZXRJZHoiLCJzaG93TGVnZW5kIiwic2VsZWN0b3JMZWdlbmRzIiwiaGlkZUxlZ2VuZCIsImNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSIsIml0ZW0iLCJpdGVtQ2xhc3MiLCJhbHRLZXkiLCJ0b2dnbGUiLCJ4Rm9yTGVnZW5kIiwieUZvckxlZ2VuZCIsImJhY2tncm91bmQiLCJwb3NNaW4iLCJ0aWxlV2lkdGgiLCJtYXhIZWlnaHQiLCJ0b3RhbExlbmd0aCIsIm9mZnNldHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwibWFyZ2lucyIsInN0ZXBzIiwiaXNMZWdlbmRSaWdodE9ySW5zZXQiLCJnZXRUZXh0Qm94IiwidXBkYXRlUG9zaXRpb25zIiwiaXNMYXN0IiwiYm94IiwiaXRlbVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1MZW5ndGgiLCJhcmVhTGVuZ3RoIiwidXBkYXRlVmFsdWVzIiwiaWQyIiwid2l0aG91dFN0ZXAiLCJtYXhMZW5ndGgiLCJ4Rm9yTGVnZW5kVGV4dCIsInhGb3JMZWdlbmRSZWN0IiwieDFGb3JMZWdlbmRUaWxlIiwieDJGb3JMZWdlbmRUaWxlIiwieUZvckxlZ2VuZFRleHQiLCJ5Rm9yTGVnZW5kUmVjdCIsInlGb3JMZWdlbmRUaWxlIiwidXNlUG9pbnQiLCJyZWN0cyIsInRpbGVzIiwieU9mZnNldCIsImdldFRleHRQb3MiLCJpc051bSIsInlGb3JUaXRsZSIsInhGb3JUaXRsZSIsImdldENsaXBQYXRoIiwiaXNJRTkiLCJhcHBWZXJzaW9uIiwiVVJMIiwiZ2V0QXhpc0NsaXBYIiwiZ2V0QXhpc0NsaXBZIiwiZ2V0QXhpc0NsaXBXaWR0aCIsImdldEF4aXNDbGlwSGVpZ2h0IiwibWFpblJlZ2lvbiIsImNsYXNzUmVnaW9uIiwicmVnaW9uWCIsInJlZ2lvblkiLCJyZWdpb25XaWR0aCIsInJlZ2lvbkhlaWdodCIsImdldFJlZ2lvblhZIiwiZ2V0UmVnaW9uU2l6ZSIsImlzV2lkdGgiLCJpc1JlZ2lvbk9uWCIsImFsdERvbWFpbiIsInN4Iiwic3kiLCJteCIsIm15IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsImlzU2VsZWN0ZWQiLCJpc0luY2x1ZGVkIiwidG9nZ2xlUG9pbnQiLCJ0b2dnbGVQYXRoIiwic2V0RHJhZ1N0YXR1cyIsImlzRHJhZ2dpbmciLCJzZWxlY3RQb2ludCIsInVuc2VsZWN0UG9pbnQiLCJzZWxlY3RQYXRoIiwiZDNSZ2IiLCJicmlnaHRlciIsInVuc2VsZWN0UGF0aCIsImdldFRvZ2dsZSIsInRvZ2dsZWRTaGFwZSIsImluaXRCcnVzaCIsImQzQnJ1c2hZIiwiZDNCcnVzaFgiLCJsYXN0RG9tYWluIiwidGltZW91dCIsImJydXNoSGFuZGxlciIsInJlZHJhd0ZvckJydXNoIiwiZ2V0QnJ1c2hTaXplIiwidXBkYXRlUmVzaXplIiwiZ2V0U2VsZWN0aW9uIiwibW92ZSIsImV4dGVudCIsImdldEV4dGVudCIsInZpc2liaWxpdHkiLCJjb250ZXh0QmFyVXBkYXRlIiwiY29udGV4dEJhckVudGVyIiwiY29udGV4dExpbmVVcGRhdGUiLCJjb250ZXh0TGluZUVudGVyIiwidXBkYXRlQmFyRm9yU3ViY2hhcnQiLCJjb250ZXh0QmFyIiwicmVkcmF3QmFyRm9yU3ViY2hhcnQiLCJkcmF3QmFyT25TdWIiLCJ1cGRhdGVMaW5lRm9yU3ViY2hhcnQiLCJjb250ZXh0TGluZSIsInJlZHJhd0xpbmVGb3JTdWJjaGFydCIsImRyYXdMaW5lT25TdWIiLCJ1cGRhdGVBcmVhRm9yU3ViY2hhcnQiLCJjb250ZXh0QXJlYSIsInJlZHJhd0FyZWFGb3JTdWJjaGFydCIsImRyYXdBcmVhT25TdWIiLCJkcmF3Iiwid2l0aERpbWVuc2lvbiIsImdlbmVyYXRlWm9vbSIsImluaXRab29tQmVoYXZpb3VyIiwiYmluZFpvb21PbkV2ZW50UmVjdCIsInVuem9vbSIsImQzWm9vbSIsIm9uWm9vbVN0YXJ0Iiwib25ab29tIiwib25ab29tRW5kIiwib3JnU2NhbGVFeHRlbnQiLCJ1cGRhdGVUcmFuc2Zvcm1TY2FsZSIsInRyYW5zZm9ybSIsInJlc2NhbGUiLCJzb3VyY2VFdmVudCIsInN0YXJ0RXZlbnQiLCJpc01vdXNlbW92ZSIsImlzWm9vbU91dCIsIndoZWVsRGVsdGEiLCJ1cGRhdGVab29tIiwiZGVsdGEiLCJpc2Z1bGx5U2hvd24iLCJiZWhhdmlvdXIiLCJ6b29tQmVoYXZpb3VyIiwicHJvcCIsImNsaWNrRGlzdGFuY2UiLCJzZXRab29tUmVzZXRCdXR0b24iLCJyZXNldEJ1dHRvbiIsInJlc2V0QnRuIiwiY29sb3JpemVQYXR0ZXJuIiwiY2xvbmVOb2RlIiwic2NoZW1lQ2F0ZWdvcnkxMCIsImdldENvbG9yRnJvbUNzcyIsInNwYW4iLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJhY2tncm91bmRJbWFnZSIsInJlbW92ZUNoaWxkIiwiQm9vbGVhbiIsImNvbG9ycyIsImQzU2NhbGVPcmRpbmFsIiwib3JpZ2luYWxDb2xvclBhdHRlcm4iLCJjb2xvcml6ZWRQYXR0ZXJucyIsImlzTGluZSIsImFzVmFsdWUiLCJnZXRGb3JtYXQiLCJ0eXBlVmFsdWUiLCJmb3JtYXRGb3JZIiwieUZvcm1hdCIsImZvcm1hdEZvclkyIiwieTJGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaXNEYXRhVHlwZSIsInJlbW92ZUNhY2hlIiwiYWxsIiwiY2xhc3NTaGFwZSIsImNsYXNzU2hhcGVzIiwiY2xhc3NlcyIsImNsYXNzVGFyZ2V0IiwiYWRkaXRpb25hbENsYXNzU3VmZml4IiwiYWRkaXRpb25hbENsYXNzIiwiY2xhc3NGb2N1c2VkIiwiY2xhc3NEZWZvY3VzZWQiLCJpZHNWYWx1ZSIsInNlbGVjdG9yTGVnZW5kIiwidGFyZ2V0SWRzVmFsdWUiLCJkZWZvY3VzIiwiX3Nob3dIaWRlIiwid2l0aGluUmFuZ2UiLCJyZXN1bHREb21haW4iLCJlbmFibGUiLCJlbmFibGVkIiwiZW5hYmxlVHlwZSIsInVwZGF0ZUFuZFJlZHJhdyIsImQzWm9vbUlkZW50aXR5IiwiZDNab29tVHJhbnNmb3JtIiwibmFtZXMiLCJhcmdzVmFsdWUiLCJ0byIsInRhaWwiLCJub3Rmb3VuZElkcyIsIm9yZ0RhdGFDb3VudCIsIm1pc3NpbmciLCJiYXNlVGFyZ2V0IiwiYmFzZVZhbHVlIiwid2l0aFRyaW1YRG9tYWluIiwid2l0aFVwZGF0ZVhBeGlzIiwidHJhbnNsYXRlWCIsInNjYWxlWCIsImZsb3dJbmRleCIsImZsb3dMZW5ndGgiLCJmbG93U3RhcnQiLCJmbG93RW5kIiwiZHVyYXRpb25Gb3JGbG93Iiwid2FpdCIsImd0IiwiZWFzZSIsImQzRWFzZUxpbmVhciIsInNldFRyYW5zaXRpb24iLCJ4RnVuYyIsInlGdW5jIiwiZGF0YVBvaW50IiwicmVzZXRPdGhlciIsImlzVGFyZ2V0SWQiLCJpc1RhcmdldEluZGV4IiwidW5zZWxlY3QiLCJ0cmFuc2Zvcm1UbyIsIm9wdGlvbnNGb3JSZWRyYXciLCJncmlkcyIsInJlZHJhd1dpdGhvdXRSZXNjYWxlIiwib3B0aW9uc1ZhbHVlIiwiZmxhdCIsImRhdGFWYWx1ZSIsImNhdGVnb3J5Iiwic2V0TWluTWF4Iiwic2V0TGFiZWxUZXh0IiwicmVzaXplIiwic29mdCIsImlzRnJvbVJlc2l6ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiYjY0RW5jb2RlVW5pY29kZSIsImJ0b2EiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5vZGVUb1N2Z0RhdGFVcmwiLCJzZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsImNzc1RleHQiLCJ4aHRtbCIsIm5vZGVYbWwiLCJzZXJpYWxpemVUb1N0cmluZyIsImNyZWF0ZVRleHROb2RlIiwic3R5bGVYbWwiLCJzdmdEYXRhVXJsIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc3NPcmlnaW4iLCJvbmxvYWQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwic3JjIiwiZGVmYXVsdHMiLCJiYiIsInZlcnNpb24iLCJnZW5lcmF0ZSIsImluc3QiLCJpbnN0YW5jZSIsInBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsd05BQXdOO0FBQzNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsOFhBQThYO0FBQ2pZO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHNDQUFzQyxFQUFFOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1COzs7QUFHNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0NBQWdDO0FBQzlFLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsMFFBQTBRO0FBQzdRO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxnRkFBZ0Y7QUFDbkY7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSx3R0FBd0c7QUFDM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHFGQUFxRjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsK0lBQStJO0FBQ2xKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLG1GQUFtRjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGOztBQUV6Rjs7QUFFQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9DQUFvQztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0ZBQW9GO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQkFBMEIscURBQXFELG1CQUFtQixXQUFXO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxrSUFBa0k7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9DQUFvQztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx3REFBd0Q7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFdBQVc7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsY0FBYztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUs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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7OztBQ3pQWTtBQUNiO0FBQ0E7O0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBLEtBQUssS0FBd0MsRUFBRSxFQUU3Qzs7QUFFRixRQUFRLHNCQUFpQjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QkFvRUQxK0QsT0FwRUMsRUFvRVE7QUFLakIsV0FKSUosUUFBUSxDQUFDSSxPQUFELENBSVosS0FIQzArRCxTQUFRLEdBQUcxK0QsT0FHWixHQUFPMCtELFNBQVA7QUFDQSxHQTFFUzs7QUE0RVY7Ozs7Ozs7Ozs7O0FBV0FLLFVBQVEsRUFBRSxFQXZGQTs7QUF5RlY7Ozs7Ozs7O0FBUUFDLFFBQU0sRUFBRSxFQWpHRTs7QUFtR1Y7Ozs7QUFJQTFsRSxPQUFLLEVBQUU7QUFDTm1ILE1BQUUsRUFBRTh0QixXQUFLLENBQUNTLFNBREo7QUFFTlIsWUFBUSxFQUFFO0FBQ1QvdEIsUUFBRSxFQUFFNFgsMkJBQWEsQ0FBQzJXLFNBRFQ7QUFFVHQyQixVQUFJLEVBQUU7QUFDTCtILFVBQUUsRUFBRXdQLFNBQUksQ0FBQytlO0FBREo7QUFGRztBQUZKO0FBdkdHLEM7QUFKWDs7Ozs7QUFzSEE7QUFDZTJ2Qyw0RUFBZixFIiwiZmlsZSI6ImJpbGxib2FyZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImQzLXRpbWUtZm9ybWF0XCIsIFwiZDMtc2VsZWN0aW9uXCIsIFwiZDMtdHJhbnNpdGlvblwiLCBcImQzLWF4aXNcIiwgXCJkMy1icnVzaFwiLCBcImQzLXNjYWxlXCIsIFwiZDMtZHN2XCIsIFwiZDMtZHJhZ1wiLCBcImQzLXNoYXBlXCIsIFwiZDMtaW50ZXJwb2xhdGVcIiwgXCJkMy1jb2xvclwiLCBcImQzLXpvb21cIiwgXCJkMy1lYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181M19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181OF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181OV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182Ml9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gKi9cblxuLyogZXNsaW50LWRpc2FibGVcbiAgY2FtZWxjYXNlXG4qL1xuLy8gdGhpcyBTb2NrSlNDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgaW5saW5lIG1vZGVcbi8vIGlzIG9mZiBvciB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZC4gVGhpcyB3aWxsIGJlIHN3aXRjaGVkIHRvXG4vLyBXZWJzb2NrZXRDbGllbnQgd2hlbiBpdCBiZWNvbWVzIHRoZSBkZWZhdWx0XG4vLyBpbXBvcnRhbnQ6IHRoZSBwYXRoIHRvIFNvY2tKU0NsaWVudCBoZXJlIGlzIG1hZGUgdG8gd29yayBpbiB0aGUgJ2NsaWVudCdcbi8vIGRpcmVjdG9yeSwgYnV0IGlzIHVwZGF0ZWQgdmlhIHRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIHdoZW4gY29tcGlsZWQgZnJvbVxuLy8gdGhlICdjbGllbnQtc3JjJyBkaXJlY3RvcnlcblxudmFyIENsaWVudCA9IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlQ2xpZW50KSB7XG4gIF9pbmhlcml0cyhTb2NrSlNDbGllbnQsIF9CYXNlQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTb2NrSlNDbGllbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tKU0NsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLnNvY2sub25vcGVuID0gZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tKU0NsaWVudDtcbn0oQmFzZUNsaWVudCk7IiwiLyogc29ja2pzLWNsaWVudCB2MS4zLjAgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS4zLjAnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIGlmIChrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsICYmIGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQ2xpZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ2xpZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbmVlZHMgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNsaWVudDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxuXG52YXIgYW5zaUhUTUwgPSByZXF1aXJlKCdhbnNpLWh0bWwnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLFxuICAgIEFsbEh0bWxFbnRpdGllcyA9IF9yZXF1aXJlLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEFsbEh0bWxFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcbnZhciBvdmVybGF5RGl2ID0gbnVsbDtcbnZhciBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuXG5mdW5jdGlvbiBhZGRPdmVybGF5RGl2VG8oaWZyYW1lKSB7XG4gIHZhciBkaXYgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gIGRpdi5zdHlsZS5yaWdodCA9IDA7XG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJyNFOEU4RTgnO1xuICBkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZSc7XG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJyZW0nO1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9ICcxLjInO1xuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIGRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGluZyBhbiBpZnJhbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBzbyB3ZSdsbCBzY2hlZHVsZSB0aGUgY2FsbGJhY2suXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cblxuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuXG4gIGlmIChvdmVybGF5SWZyYW1lKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBjcmVhdGVkIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcbiAgb3ZlcmxheURpdiA9IG51bGw7XG4gIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuXG5mdW5jdGlvbiBzaG93TWVzc2FnZShtZXNzYWdlcykge1xuICBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjXCIuY29uY2F0KGNvbG9ycy5yZWQsIFwiXFxcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj5cIikuY29uY2F0KGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtZXNzYWdlc1swXSkpKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhcjogY2xlYXIsXG4gIHNob3dNZXNzYWdlOiBzaG93TWVzc2FnZVxufTsiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcbiIsInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcbiIsInZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG5cbnZhciBpID0gMDtcbnZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbndoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcbiIsInZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIGNoYXJJbmRleCA9IHt9O1xuXG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYWxwaGFJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciBpID0gRU5USVRJRVMubGVuZ3RoO1xuICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGUgPSBFTlRJVElFU1tpXTtcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcbiAgICAgICAgdmFyIGNoYXJzID0gZVsxXTtcbiAgICAgICAgdmFyIGNociA9IGNoYXJzWzBdO1xuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcbiAgICAgICAgdmFyIGNoYXJJbmZvO1xuICAgICAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyc1sxXSkge1xuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDVFbnRpdGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgREVCVUcgPSAnZGVidWcnO1xudmFyIFRSQUNFID0gJ3RyYWNlJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JzsgLy8gZGVwcmVjYXRlZFxuLy8gVE9ETzogcmVtb3ZlIHRoZXNlIGF0IG1ham9yIHJlbGVhc2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8xODI1XG5cbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIE5PTkUgPSAnbm9uZSc7IC8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcblxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgSU5GTzpcbiAgICBjYXNlIFdBUk46XG4gICAgY2FzZSBFUlJPUjpcbiAgICBjYXNlIERFQlVHOlxuICAgIGNhc2UgVFJBQ0U6XG4gICAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBXQVJOSU5HOlxuICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgTk9ORTpcbiAgICBjYXNlIFNJTEVOVDpcbiAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBzZXRMb2dMZXZlbDogc2V0TG9nTGV2ZWxcbn07IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRNc2c7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2c7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBfcmVmMikge1xuICB2YXIgaG90UmVsb2FkID0gX3JlZi5ob3RSZWxvYWQsXG4gICAgICBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIHZhciBpc1VubG9hZGluZyA9IF9yZWYyLmlzVW5sb2FkaW5nLFxuICAgICAgY3VycmVudEhhc2ggPSBfcmVmMi5jdXJyZW50SGFzaDtcblxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlXG5cbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcblxuICAgIGhvdEVtaXR0ZXIuZW1pdCgnd2VicGFja0hvdFVwZGF0ZScsIGN1cnJlbnRIYXNoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChjdXJyZW50SGFzaCksICcqJyk7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQpIHtcbiAgICAgIHZhciByb290V2luZG93ID0gc2VsZjsgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG5cbiAgICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcblxuICAgICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVsb2FkQXBwOyIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBzZWxmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxudmFyIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgPSByZXF1aXJlKCcuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UnKTtcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VXJsKHJlc291cmNlUXVlcnkpIHtcbiAgdmFyIHVybFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2VRdWVyeSA9PT0gJ3N0cmluZycgJiYgcmVzb3VyY2VRdWVyeSAhPT0gJycpIHtcbiAgICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gICAgc2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnJyk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcbiAgICB1cmxQYXJ0cy5wb3J0ID0gc2VsZi5sb2NhdGlvbi5wb3J0O1xuICB9XG5cbiAgdmFyIF91cmxQYXJ0cyA9IHVybFBhcnRzLFxuICAgICAgYXV0aCA9IF91cmxQYXJ0cy5hdXRoLFxuICAgICAgcGF0aCA9IF91cmxQYXJ0cy5wYXRoO1xuICB2YXIgX3VybFBhcnRzMiA9IHVybFBhcnRzLFxuICAgICAgaG9zdG5hbWUgPSBfdXJsUGFydHMyLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2wgPSBfdXJsUGFydHMyLnByb3RvY29sOyAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cbiAgaWYgKChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9IC8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbiAgLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4gIC8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2Vic29ja2V0cyBhcmUgYWx3YXlzIG5lY2Vzc2FyeVxuICAvLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cblxuXG4gIGlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgICBwcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG4gIH0gLy8gZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHNvY2sgdXJsIGlmIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuXG5cbiAgdmFyIHNvY2tIb3N0ID0gaG9zdG5hbWU7XG4gIHZhciBzb2NrUGF0aCA9ICcvc29ja2pzLW5vZGUnO1xuICB2YXIgc29ja1BvcnQgPSB1cmxQYXJ0cy5wb3J0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG5cbiAgaWYgKHBhdGggIT09IG51bGwgJiYgcGF0aCAhPT0gdW5kZWZpbmVkICYmIHBhdGggIT09ICcvJykge1xuICAgIHZhciBwYXJzZWRRdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHBhdGgpOyAvLyBhbGwgb2YgdGhlc2Ugc29jayB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoXG4gICAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgICAvLyB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuICAgIHNvY2tIb3N0ID0gcGFyc2VkUXVlcnkuc29ja0hvc3QgfHwgc29ja0hvc3Q7XG4gICAgc29ja1BhdGggPSBwYXJzZWRRdWVyeS5zb2NrUGF0aCB8fCBzb2NrUGF0aDtcbiAgICBzb2NrUG9ydCA9IHBhcnNlZFF1ZXJ5LnNvY2tQb3J0IHx8IHNvY2tQb3J0O1xuICB9XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBhdXRoOiBhdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrSG9zdCxcbiAgICBwb3J0OiBzb2NrUG9ydCxcbiAgICAvLyBJZiBzb2NrUGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgICAvLyBxdWVyeSBwYXJhbSBzbyBpdCBoYXMgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcXVlcnlzdHJpbmcgaW4gb3JkZXIgZm9yIHRoZVxuICAgIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgcGF0aG5hbWU6IHNvY2tQYXRoXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNvY2tldFVybDsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDMyXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzE7IiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYmlsbGJvYXJkLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYmlsbGJvYXJkLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2JpbGxib2FyZC5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKi0tIENoYXJ0IC0tKi9cXG4uYmIgc3ZnIHtcXG4gIGZvbnQ6IDEwcHggR290aGFtUHJvO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgZmlsbDogIzVENUM3MTsgfVxcblxcbi5iYiBwYXRoLCAuYmIgbGluZSB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMDAwOyB9XFxuXFxuLmJiIHRleHQsIC5iYiAuYmItYnV0dG9uIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0tdGlsZSxcXG4uYmIteGdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLFxcbi5iYi1ldmVudC1yZWN0LFxcbi5iYi1iYXJzIHBhdGgge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyBwYXRoIHtcXG4gIHN0cm9rZTogI2ZmZjsgfVxcblxcbi5iYi1jaGFydC1hcmMgdGV4dCB7XFxuICBmaWxsOiAjZmZmO1xcbiAgZm9udC1zaXplOiAxM3B4OyB9XFxuXFxuLyotLSBBeGlzIC0tKi9cXG4uYmItYXhpcyB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4vKi0tIEdyaWQgLS0qL1xcbi5iYi1ncmlkIGxpbmUge1xcbiAgc3Ryb2tlOiAjYWFhOyB9XFxuXFxuLmJiLWdyaWQgdGV4dCB7XFxuICBmaWxsOiAjYWFhOyB9XFxuXFxuLmJiLXhncmlkLCAuYmIteWdyaWQge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogMyAzOyB9XFxuXFxuLyotLSBUZXh0IG9uIENoYXJ0IC0tKi9cXG4uYmItdGV4dC5iYi1lbXB0eSB7XFxuICBmaWxsOiAjODA4MDgwO1xcbiAgZm9udC1zaXplOiAyZW07IH1cXG5cXG4vKi0tIExpbmUgLS0qL1xcbi5iYi1saW5lIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBQb2ludCAtLSovXFxuLmJiLWNpcmNsZS5fZXhwYW5kZWRfIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4O1xcbiAgc3Ryb2tlOiB3aGl0ZTsgfVxcblxcbi5iYi1zZWxlY3RlZC1jaXJjbGUge1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2Utd2lkdGg6IDJweDsgfVxcblxcbi8qLS0gQmFyIC0tKi9cXG4uYmItYmFyIHtcXG4gIHN0cm9rZS13aWR0aDogMDsgfVxcbiAgLmJiLWJhci5fZXhwYW5kZWRfIHtcXG4gICAgZmlsbC1vcGFjaXR5OiAwLjc1OyB9XFxuXFxuLyotLSBGb2N1cyAtLSovXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkIHtcXG4gIG9wYWNpdHk6IDE7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1saW5lLCAuYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1zdGVwIHtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMC4zICFpbXBvcnRhbnQ7IH1cXG5cXG4vKi0tIFJlZ2lvbiAtLSovXFxuLmJiLXJlZ2lvbiB7XFxuICBmaWxsOiBzdGVlbGJsdWU7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBab29tIHJlZ2lvbiAtLSovXFxuLmJiLXpvb20tYnJ1c2gge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gQnJ1c2ggLS0qL1xcbi5iYi1icnVzaCAuZXh0ZW50IHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFNlbGVjdCAtIERyYWcgLS0qL1xcbi8qLS0gTGVnZW5kIC0tKi9cXG4uYmItbGVnZW5kLWl0ZW0ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0taGlkZGVuIHtcXG4gIG9wYWNpdHk6IDAuMTU7IH1cXG5cXG4uYmItbGVnZW5kLWJhY2tncm91bmQge1xcbiAgb3BhY2l0eTogMC43NTtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlOiBsaWdodGdyYXk7XFxuICBzdHJva2Utd2lkdGg6IDE7IH1cXG5cXG4vKi0tIFRpdGxlIC0tKi9cXG4uYmItdGl0bGUge1xcbiAgZm9udDogMTRweCBHb3RoYW1Qcm87IH1cXG5cXG4vKi0tIFRvb2x0aXAgLS0qL1xcbi5iYi10b29sdGlwLWNvbnRhaW5lciB7XFxuICB6LWluZGV4OiAxMDsgfVxcblxcbi5iYi10b29sdGlwIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBlbXB0eS1jZWxsczogc2hvdztcXG4gIG9wYWNpdHk6IDAuOTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIC1tb3otYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIGJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7IH1cXG4gIC5iYi10b29sdGlwIHRyIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0NDQzsgfVxcbiAgLmJiLXRvb2x0aXAgdGgge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIHBhZGRpbmc6IDJweCA1cHg7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGNvbG9yOiAjRkZGOyB9XFxuICAuYmItdG9vbHRpcCB0ZCB7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgcGFkZGluZzogM3B4IDZweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkb3R0ZWQgIzk5OTsgfVxcbiAgICAuYmItdG9vbHRpcCB0ZCA+IHNwYW4sIC5iYi10b29sdGlwIHRkID4gc3ZnIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgaGVpZ2h0OiAxMHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogNnB4OyB9XFxuICAuYmItdG9vbHRpcC52YWx1ZSB7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuXFxuLyotLSBBcmVhIC0tKi9cXG4uYmItYXJlYSB7XFxuICBzdHJva2Utd2lkdGg6IDA7XFxuICBvcGFjaXR5OiAwLjI7IH1cXG5cXG4vKi0tIEFyYyAtLSovXFxuLmJiLWNoYXJ0LWFyY3MtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMS4zZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcy1nYXVnZS10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAyLjdlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWJhY2tncm91bmQge1xcbiAgZmlsbDogI2UwZTBlMDtcXG4gIHN0cm9rZTogbm9uZTsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLXVuaXQge1xcbiAgZmlsbDogIzAwMDtcXG4gIGZvbnQtc2l6ZTogMTZweDsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1heCB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluIHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4uYmItY2hhcnQtYXJjIC5iYi1nYXVnZS12YWx1ZSB7XFxuICBmaWxsOiAjMDAwOyB9XFxuXFxuLyotLSBSYWRhciAtLSovXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHBvbHlnb24ge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyB0ZXh0IHtcXG4gIGZpbGw6ICM4NDgyODI7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIGxpbmUge1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyB0ZXh0IHtcXG4gIGZvbnQtc2l6ZTogMS4xNWVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItc2hhcGVzIHBvbHlnb24ge1xcbiAgZmlsbC1vcGFjaXR5OiAuMjtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBCdXR0b24gLS0qL1xcbi5iYi1idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxMHB4O1xcbiAgcmlnaHQ6IDEwcHg7IH1cXG4gIC5iYi1idXR0b24gLmJiLXpvb20tcmVzZXQge1xcbiAgICBmb250LXNpemU6IDExcHg7XFxuICAgIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cXG5oMiN0aXRsZSB7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICB0ZXh0LXRyYW5zZm9ybTogXFxcInVwcGVyY2FzZVxcXCI7IH1cXG5cIiwgXCJcIl0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCJ7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbX2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIihcIi5jb25jYXQoaXRlbVsyXSwgXCIpIGFuZCAoXCIpLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCkuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X187IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsImZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mMihvYmopOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZjIoU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTNfXzsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKipcbiAqIFdpbmRvdyBvYmplY3RcbiAqIEBtb2R1bGVcbiAqIEBpZ25vcmVcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLXVuZGVmICovXG5jb25zdCB3aW4gPSAoKCkgPT4ge1xuXHRjb25zdCBkZWYgPSBvID0+IHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XG5cblx0cmV0dXJuIGRlZihzZWxmKSB8fCBkZWYod2luZG93KSB8fCBkZWYoZ2xvYmFsKSB8fCBkZWYoZ2xvYmFsVGhpcykgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSkoKTtcbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMsIG5vLXVuZGVmICovXG5cbmNvbnN0IGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XG5cbmV4cG9ydCB7XG5cdHdpbiBhcyB3aW5kb3csXG5cdGRvYyBhcyBkb2N1bWVudFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181N19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNThfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182MF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjFfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzYyX187IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDU1MgY2xhc3MgbmFtZXMgZGVmaW5pdGlvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXHRhcmM6IFwiYmItYXJjXCIsXG5cdGFyY3M6IFwiYmItYXJjc1wiLFxuXHRhcmVhOiBcImJiLWFyZWFcIixcblx0YXJlYXM6IFwiYmItYXJlYXNcIixcblx0YXhpczogXCJiYi1heGlzXCIsXG5cdGF4aXNYOiBcImJiLWF4aXMteFwiLFxuXHRheGlzWExhYmVsOiBcImJiLWF4aXMteC1sYWJlbFwiLFxuXHRheGlzWTogXCJiYi1heGlzLXlcIixcblx0YXhpc1kyOiBcImJiLWF4aXMteTJcIixcblx0YXhpc1kyTGFiZWw6IFwiYmItYXhpcy15Mi1sYWJlbFwiLFxuXHRheGlzWUxhYmVsOiBcImJiLWF4aXMteS1sYWJlbFwiLFxuXHRiYXI6IFwiYmItYmFyXCIsXG5cdGJhcnM6IFwiYmItYmFyc1wiLFxuXHRicnVzaDogXCJiYi1icnVzaFwiLFxuXHRidXR0b246IFwiYmItYnV0dG9uXCIsXG5cdGJ1dHRvblpvb21SZXNldDogXCJiYi16b29tLXJlc2V0XCIsXG5cdGNoYXJ0OiBcImJiLWNoYXJ0XCIsXG5cdGNoYXJ0QXJjOiBcImJiLWNoYXJ0LWFyY1wiLFxuXHRjaGFydEFyY3M6IFwiYmItY2hhcnQtYXJjc1wiLFxuXHRjaGFydEFyY3NCYWNrZ3JvdW5kOiBcImJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZFwiLFxuXHRjaGFydEFyY3NHYXVnZU1heDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1heFwiLFxuXHRjaGFydEFyY3NHYXVnZU1pbjogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1pblwiLFxuXHRjaGFydEFyY3NHYXVnZVVuaXQ6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS11bml0XCIsXG5cdGNoYXJ0QXJjc1RpdGxlOiBcImJiLWNoYXJ0LWFyY3MtdGl0bGVcIixcblx0Y2hhcnRBcmNzR2F1Z2VUaXRsZTogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlXCIsXG5cdGNoYXJ0QmFyOiBcImJiLWNoYXJ0LWJhclwiLFxuXHRjaGFydEJhcnM6IFwiYmItY2hhcnQtYmFyc1wiLFxuXHRjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxuXHRjaGFydExpbmVzOiBcImJiLWNoYXJ0LWxpbmVzXCIsXG5cdGNoYXJ0UmFkYXI6IFwiYmItY2hhcnQtcmFkYXJcIixcblx0Y2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXG5cdGNoYXJ0VGV4dDogXCJiYi1jaGFydC10ZXh0XCIsXG5cdGNoYXJ0VGV4dHM6IFwiYmItY2hhcnQtdGV4dHNcIixcblx0Y2lyY2xlOiBcImJiLWNpcmNsZVwiLFxuXHRjaXJjbGVzOiBcImJiLWNpcmNsZXNcIixcblx0Y29sb3JQYXR0ZXJuOiBcImJiLWNvbG9yLXBhdHRlcm5cIixcblx0Y29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXG5cdGRlZm9jdXNlZDogXCJiYi1kZWZvY3VzZWRcIixcblx0ZHJhZ2FyZWE6IFwiYmItZHJhZ2FyZWFcIixcblx0ZW1wdHk6IFwiYmItZW1wdHlcIixcblx0ZXZlbnRSZWN0OiBcImJiLWV2ZW50LXJlY3RcIixcblx0ZXZlbnRSZWN0czogXCJiYi1ldmVudC1yZWN0c1wiLFxuXHRldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcblx0ZXZlbnRSZWN0c1NpbmdsZTogXCJiYi1ldmVudC1yZWN0cy1zaW5nbGVcIixcblx0Zm9jdXNlZDogXCJiYi1mb2N1c2VkXCIsXG5cdGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcblx0Z3JpZDogXCJiYi1ncmlkXCIsXG5cdGdyaWRMaW5lczogXCJiYi1ncmlkLWxpbmVzXCIsXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcblx0bGVnZW5kSXRlbTogXCJiYi1sZWdlbmQtaXRlbVwiLFxuXHRsZWdlbmRJdGVtRXZlbnQ6IFwiYmItbGVnZW5kLWl0ZW0tZXZlbnRcIixcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxuXHRsZWdlbmRJdGVtSGlkZGVuOiBcImJiLWxlZ2VuZC1pdGVtLWhpZGRlblwiLFxuXHRsZWdlbmRJdGVtUG9pbnQ6IFwiYmItbGVnZW5kLWl0ZW0tcG9pbnRcIixcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxuXHRsZXZlbDogXCJiYi1sZXZlbFwiLFxuXHRsZXZlbHM6IFwiYmItbGV2ZWxzXCIsXG5cdGxpbmU6IFwiYmItbGluZVwiLFxuXHRsaW5lczogXCJiYi1saW5lc1wiLFxuXHRyZWdpb246IFwiYmItcmVnaW9uXCIsXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxuXHRzZWxlY3RlZENpcmNsZTogXCJiYi1zZWxlY3RlZC1jaXJjbGVcIixcblx0c2VsZWN0ZWRDaXJjbGVzOiBcImJiLXNlbGVjdGVkLWNpcmNsZXNcIixcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcblx0c2hhcGVzOiBcImJiLXNoYXBlc1wiLFxuXHRzdGFuZm9yZEVsZW1lbnRzOiBcImJiLXN0YW5mb3JkLWVsZW1lbnRzXCIsXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXG5cdHN0YW5mb3JkTGluZXM6IFwiYmItc3RhbmZvcmQtbGluZXNcIixcblx0c3RhbmZvcmRSZWdpb246IFwiYmItc3RhbmZvcmQtcmVnaW9uXCIsXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXG5cdHRhcmdldDogXCJiYi10YXJnZXRcIixcblx0dGV4dDogXCJiYi10ZXh0XCIsXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXG5cdHRpdGxlOiBcImJiLXRpdGxlXCIsXG5cdHRvb2x0aXA6IFwiYmItdG9vbHRpcFwiLFxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXG5cdHRvb2x0aXBOYW1lOiBcImJiLXRvb2x0aXAtbmFtZVwiLFxuXHR4Z3JpZDogXCJiYi14Z3JpZFwiLFxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXG5cdHhncmlkTGluZTogXCJiYi14Z3JpZC1saW5lXCIsXG5cdHhncmlkTGluZXM6IFwiYmIteGdyaWQtbGluZXNcIixcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxuXHR5Z3JpZDogXCJiYi15Z3JpZFwiLFxuXHR5Z3JpZExpbmU6IFwiYmIteWdyaWQtbGluZVwiLFxuXHR5Z3JpZExpbmVzOiBcImJiLXlncmlkLWxpbmVzXCIsXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcblx0em9vbUJydXNoOiBcImJiLXpvb20tYnJ1c2hcIixcblx0em9vbVJlY3Q6IFwiYmItem9vbS1yZWN0XCIsXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcblx0U0VMRUNURUQ6IFwiX3NlbGVjdGVkX1wiLFxuXHRJTkNMVURFRDogXCJfaW5jbHVkZWRfXCJcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQGlnbm9yZVxuICovXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7YnJ1c2hTZWxlY3Rpb24gYXMgZDNCcnVzaFNlbGVjdGlvbn0gZnJvbSBcImQzLWJydXNoXCI7XG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcblxuY29uc3QgaXNWYWx1ZSA9IHYgPT4gdiB8fCB2ID09PSAwO1xuY29uc3QgaXNGdW5jdGlvbiA9IHYgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzTnVtYmVyID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcbmNvbnN0IGlzVW5kZWZpbmVkID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzRGVmaW5lZCA9IHYgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBpc0Jvb2xlYW4gPSB2ID0+IHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIjtcbmNvbnN0IGNlaWwxMCA9IHYgPT4gTWF0aC5jZWlsKHYgLyAxMCkgKiAxMDtcbmNvbnN0IGFzSGFsZlBpeGVsID0gbiA9PiBNYXRoLmNlaWwobikgKyAwLjU7XG5jb25zdCBkaWZmRG9tYWluID0gZCA9PiBkWzFdIC0gZFswXTtcbmNvbnN0IGlzT2JqZWN0VHlwZSA9IHYgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc0VtcHR5ID0gbyA9PiAoXG5cdGlzVW5kZWZpbmVkKG8pIHx8IG8gPT09IG51bGwgfHxcblx0KGlzU3RyaW5nKG8pICYmIG8ubGVuZ3RoID09PSAwKSB8fFxuXHQoaXNPYmplY3RUeXBlKG8pICYmICEobyBpbnN0YW5jZW9mIERhdGUpICYmIE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gMCkgfHxcblx0KGlzTnVtYmVyKG8pICYmIGlzTmFOKG8pKVxuKTtcbmNvbnN0IG5vdEVtcHR5ID0gbyA9PiAhaXNFbXB0eShvKTtcblxuLyoqXG4gKiBDaGVjayBpZiBpcyBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlzQXJyYXkgPSBhcnIgPT4gYXJyICYmIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG5cbi8qKlxuICogQ2hlY2sgaWYgaXMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gb2JqID0+IG9iaiAmJiAhb2JqLm5vZGVUeXBlICYmIGlzT2JqZWN0VHlwZShvYmopICYmICFpc0FycmF5KG9iaik7XG5cbmNvbnN0IGdldE9wdGlvbiA9IChvcHRpb25zLCBrZXksIGRlZmF1bHRWYWx1ZSkgPT4gKFxuXHRpc0RlZmluZWQob3B0aW9uc1trZXldKSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRWYWx1ZVxuKTtcblxuY29uc3QgaGFzVmFsdWUgPSAoZGljdCwgdmFsdWUpID0+IHtcblx0bGV0IGZvdW5kID0gZmFsc2U7XG5cblx0T2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrZXkgPT4gKGRpY3Rba2V5XSA9PT0gdmFsdWUpICYmIChmb3VuZCA9IHRydWUpKTtcblxuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIENhbGwgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHsqfSBhcmdzIEFyZ3VtZW50c1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZTogZm4gaXMgZnVuY3Rpb24sIGZhbHNlOiBmbiBpcyBub3QgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhbGxGbiA9IChmbiwgLi4uYXJncykgPT4ge1xuXHRjb25zdCBpc0ZuID0gaXNGdW5jdGlvbihmbik7XG5cblx0aXNGbiAmJiBmbi5jYWxsKC4uLmFyZ3MpO1xuXHRyZXR1cm4gaXNGbjtcbn07XG5cbi8qKlxuICogUmVwbGFjZSB0YWcgc2lnbiB0byBodG1sIGVudGl0eVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc2FuaXRpc2UgPSBzdHIgPT4gKGlzU3RyaW5nKHN0cikgPyBzdHIucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgOiBzdHIpO1xuXG4vKipcbiAqIFNldCB0ZXh0IHZhbHVlLiBJZiB0aGVyZSdzIG11bHRpbGluZSBhZGQgbm9kZXMuXG4gKiBAcGFyYW0ge2QzU2VsZWN0aW9ufSBub2RlIFRleHQgbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCB2YWx1ZSBzdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGR5IGR5IHZhbHVlIGZvciBtdWx0aWxpbmVkIHRleHRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNldFRleHRWYWx1ZSA9IChub2RlLCB0ZXh0LCBkeSA9IFstMSwgMV0pID0+IHtcblx0aWYgKCFub2RlIHx8ICFpc1N0cmluZyh0ZXh0KSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICh0ZXh0LmluZGV4T2YoXCJcXG5cIikgPT09IC0xKSB7XG5cdFx0bm9kZS50ZXh0KHRleHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGRpZmYgPSBbbm9kZS50ZXh0KCksIHRleHRdLm1hcCh2ID0+IHYucmVwbGFjZSgvW1xcc1xcbl0vZywgXCJcIikpO1xuXG5cdFx0aWYgKGRpZmZbMF0gIT09IGRpZmZbMV0pIHtcblx0XHRcdGNvbnN0IG11bHRpbGluZSA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG5cblx0XHRcdC8vIHJlc2V0IHBvc3NpYmxlIHRleHRcblx0XHRcdG5vZGUuaHRtbChcIlwiKTtcblxuXHRcdFx0bXVsdGlsaW5lLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0bm9kZS5hcHBlbmQoXCJ0c3BhblwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgYCR7aSA9PT0gMCA/IGR5WzBdIDogZHlbMV19ZW1gKVxuXHRcdFx0XHRcdC50ZXh0KHYpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBzdWJzdGl0dXRpb24gb2YgU1ZHUGF0aFNlZyBBUEkgcG9seWZpbGxcbmNvbnN0IGdldFJlY3RTZWdMaXN0ID0gcGF0aCA9PiB7XG5cdC8qXG5cdCAqIHNlZzEgLS0tLS0tLS0tLSBzZWcyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcblx0ICogICB8ICAgICAgICAgICAgICAgfFxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XG5cdCAqIHNlZzAgLS0tLS0tLS0tLSBzZWczXG5cdCAqICovXG5cdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0QkJveCgpO1xuXG5cdHJldHVybiBbXG5cdFx0e3gsIHk6IHkgKyBoZWlnaHR9LCAvLyBzZWcwXG5cdFx0e3gsIHl9LCAvLyBzZWcxXG5cdFx0e3g6IHggKyB3aWR0aCwgeX0sIC8vIHNlZzJcblx0XHR7eDogeCArIHdpZHRoLCB5OiB5ICsgaGVpZ2h0fSAvLyBzZWczXG5cdF07XG59O1xuXG5jb25zdCBnZXRQYXRoQm94ID0gcGF0aCA9PiB7XG5cdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGNvbnN0IGl0ZW1zID0gZ2V0UmVjdFNlZ0xpc3QocGF0aCk7XG5cdGNvbnN0IHggPSBpdGVtc1swXS54O1xuXHRjb25zdCB5ID0gTWF0aC5taW4oaXRlbXNbMF0ueSwgaXRlbXNbMV0ueSk7XG5cblx0cmV0dXJuIHtcblx0XHR4LCB5LCB3aWR0aCwgaGVpZ2h0XG5cdH07XG59O1xuXG4vLyByZXR1cm4gYnJ1c2ggc2VsZWN0aW9uIGFycmF5XG5jb25zdCBnZXRCcnVzaFNlbGVjdGlvbiA9IGN0eCA9PiB7XG5cdGxldCBzZWxlY3Rpb24gPSBudWxsO1xuXHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XG5cdGNvbnN0IG1haW4gPSBjdHguY29udGV4dCB8fCBjdHgubWFpbjtcblxuXHQvLyBjaGVjayBmcm9tIGV2ZW50XG5cdGlmIChldmVudCAmJiBldmVudC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkJydXNoRXZlbnRcIikge1xuXHRcdHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbjtcblx0Ly8gY2hlY2sgZnJvbSBicnVzaCBhcmVhIHNlbGVjdGlvblxuXHR9IGVsc2UgaWYgKG1haW4gJiYgKHNlbGVjdGlvbiA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5ub2RlKCkpKSB7XG5cdFx0c2VsZWN0aW9uID0gZDNCcnVzaFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXHR9XG5cblx0cmV0dXJuIHNlbGVjdGlvbjtcbn07XG5cbi8vIHJldHJ1biByYW5kb20gbnVtYmVyXG5jb25zdCBnZXRSYW5kb20gPSAoYXNTdHIgPSB0cnVlKSA9PiBNYXRoLnJhbmRvbSgpICsgKGFzU3RyID8gXCJcIiA6IDApO1xuXG5jb25zdCBicnVzaEVtcHR5ID0gY3R4ID0+IHtcblx0Y29uc3Qgc2VsZWN0aW9uID0gZ2V0QnJ1c2hTZWxlY3Rpb24oY3R4KTtcblxuXHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0Ly8gYnJ1c2ggc2VsZWN0ZWQgYXJlYVxuXHRcdC8vIHR3by1kaW1lbnNpb25hbDogW1t4MCwgeTBdLCBbeDEsIHkxXV1cblx0XHQvLyBvbmUtZGltZW5zaW9uYWw6IFt4MCwgeDFdIG9yIFt5MCwgeTFdXG5cdFx0cmV0dXJuIHNlbGVjdGlvblswXSA9PT0gc2VsZWN0aW9uWzFdO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBleHRlbmQgPSAodGFyZ2V0ID0ge30sIHNvdXJjZSkgPT4ge1xuXHRmb3IgKGNvbnN0IHAgaW4gc291cmNlKSB7XG5cdFx0dGFyZ2V0W3BdID0gc291cmNlW3BdO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpcnN0IGxldHRlciBjYXBpdGFsaXplZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfSBjYXBpdGFsaXplZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0FycmF5ID0gdiA9PiBbXS5zbGljZS5jYWxsKHYpO1xuXG4vKipcbiAqIEdldCBjc3MgcnVsZXMgZm9yIHNwZWNpZmllZCBzdHlsZXNoZWV0c1xuICogQHBhcmFtIHtBcnJheX0gc3R5bGVTaGVldHMgVGhlIHN0eWxlc2hlZXRzIHRvIGdldCB0aGUgcnVsZXMgZnJvbVxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0Q3NzUnVsZXMgPSBzdHlsZVNoZWV0cyA9PiB7XG5cdGxldCBydWxlcyA9IFtdO1xuXG5cdHN0eWxlU2hlZXRzLmZvckVhY2goc2hlZXQgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoc2hlZXQuY3NzUnVsZXMgJiYgc2hlZXQuY3NzUnVsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHJ1bGVzID0gcnVsZXMuY29uY2F0KHRvQXJyYXkoc2hlZXQuY3NzUnVsZXMpKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSByZWFkaW5nIHJ1bGVzIGZyb20gJHtzaGVldC5ocmVmfTogJHtlLnRvU3RyaW5nKCl9YCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcnVsZXM7XG59O1xuXG4vKipcbiAqIEdldCB1bmlxdWUgdmFsdWUgZnJvbSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICogQHJldHVybiB7QXJyYXl9IFVuaXF1ZSBhcnJheSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0VW5pcXVlID0gZGF0YSA9PiBkYXRhLmZpbHRlcigodiwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpKTtcblxuLyoqXG4gKiBNZXJnZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG1lcmdlQXJyYXkgPSBhcnIgPT4gKGFyciAmJiBhcnIubGVuZ3RoID8gYXJyLnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYykpIDogW10pO1xuXG4vKipcbiAqIE1lcmdlIG9iamVjdCByZXR1cm5pbmcgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdE5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG1lcmdlZCB0YXJnZXQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtZXJnZU9iaiA9ICh0YXJnZXQsIC4uLm9iamVjdE4pID0+IHtcblx0aWYgKCFvYmplY3ROLmxlbmd0aCB8fCAob2JqZWN0Ti5sZW5ndGggPT09IDEgJiYgIW9iamVjdE5bMF0pKSB7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdGNvbnN0IHNvdXJjZSA9IG9iamVjdE4uc2hpZnQoKTtcblxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG5cdFx0T2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRcdCF0YXJnZXRba2V5XSAmJiAodGFyZ2V0W2tleV0gPSB7fSk7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gaXNBcnJheSh2YWx1ZSkgP1xuXHRcdFx0XHRcdHZhbHVlLmNvbmNhdCgpIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VPYmoodGFyZ2V0LCAuLi5vYmplY3ROKTtcbn07XG5cbi8qKlxuICogU29ydCB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSB2YWx1ZSB0byBiZSBzb3J0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBc2MgdHJ1ZTogYXNjLCBmYWxzZTogZGVzY1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ3xEYXRlfSBzb3J0ZWQgZGF0ZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc29ydFZhbHVlID0gKGRhdGEsIGlzQXNjID0gdHJ1ZSkgPT4ge1xuXHRsZXQgZm47XG5cblx0aWYgKGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0Zm4gPSBpc0FzYyA/IChhLCBiKSA9PiBhIC0gYiA6IChhLCBiKSA9PiBiIC0gYTtcblx0fSBlbHNlIHtcblx0XHRpZiAoaXNBc2MgJiYgZGF0YS5ldmVyeShOdW1iZXIpKSB7XG5cdFx0XHRmbiA9IChhLCBiKSA9PiBhIC0gYjtcblx0XHR9IGVsc2UgaWYgKCFpc0FzYykge1xuXHRcdFx0Zm4gPSAoYSwgYikgPT4gKGEgPiBiICYmIC0xKSB8fCAoYSA8IGIgJiYgMSkgfHwgKGEgPT09IGIgJiYgMCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGEuY29uY2F0KCkuc29ydChmbik7XG59O1xuXG4vKipcbiAqIEdldCBtaW4vbWF4IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAnbWluJyBvciAnbWF4J1xuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBkYXRhIHZhbHVlXG4gKiBAcmV0dW4ge051bWJlcnxEYXRlfHVuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldE1pbk1heCA9ICh0eXBlLCBkYXRhKSA9PiB7XG5cdGxldCByZXMgPSBkYXRhLmZpbHRlcih2ID0+IG5vdEVtcHR5KHYpKTtcblxuXHRpZiAocmVzLmxlbmd0aCkge1xuXHRcdGlmIChpc051bWJlcihyZXNbMF0pKSB7XG5cdFx0XHRyZXMgPSBNYXRoW3R5cGVdKC4uLnJlcyk7XG5cdFx0fSBlbHNlIGlmIChyZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRyZXMgPSBzb3J0VmFsdWUocmVzLCB0eXBlID09PSBcIm1pblwiKVswXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0cmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogR2V0IHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgbnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBudW1iZXJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0UmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuXHRjb25zdCByZXMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdHJlcy5wdXNoKGkpO1xuXHR9XG5cblx0cmV0dXJuIHJlcztcbn07XG5cbi8vIGVtdWxhdGUgZXZlbnRcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcblx0bW91c2U6ICgoKSA9PiB7XG5cdFx0Y29uc3QgZ2V0UGFyYW1zID0gKCkgPT4gKHtcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxuXHRcdH0pO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblx0XHRcdG5ldyBNb3VzZUV2ZW50KFwidFwiKTtcblxuXHRcdFx0cmV0dXJuIChlbCwgZXZlbnRUeXBlLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zKSk7XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIFBvbHlmaWxscyBET000IE1vdXNlRXZlbnRcblx0XHRcdHJldHVybiAoZWwsIGV2ZW50VHlwZSwgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcblx0XHRcdFx0Y29uc3QgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcblxuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9pbml0TW91c2VFdmVudFxuXHRcdFx0XHRtb3VzZUV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0XHRwYXJhbXMuYnViYmxlcyxcblx0XHRcdFx0XHRwYXJhbXMuY2FuY2VsYWJsZSxcblx0XHRcdFx0XHR3aW5kb3csXG5cdFx0XHRcdFx0MCwgLy8gdGhlIGV2ZW50J3MgbW91c2UgY2xpY2sgY291bnRcblx0XHRcdFx0XHRwYXJhbXMuc2NyZWVuWCwgcGFyYW1zLnNjcmVlblksXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChtb3VzZUV2ZW50KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9KSgpLFxuXHR0b3VjaDogKGVsLCBldmVudFR5cGUsIHBhcmFtcykgPT4ge1xuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0aWRlbnRpZmllcjogRGF0ZS5ub3coKSxcblx0XHRcdHRhcmdldDogZWwsXG5cdFx0XHRyYWRpdXNYOiAyLjUsXG5cdFx0XHRyYWRpdXNZOiAyLjUsXG5cdFx0XHRyb3RhdGlvbkFuZ2xlOiAxMCxcblx0XHRcdGZvcmNlOiAwLjVcblx0XHR9LCBwYXJhbXMpKTtcblxuXHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IFRvdWNoRXZlbnQoZXZlbnRUeXBlLCB7XG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRcdFx0YnViYmxlczogdHJ1ZSxcblx0XHRcdHNoaWZ0S2V5OiB0cnVlLFxuXHRcdFx0dG91Y2hlczogW3RvdWNoT2JqXSxcblx0XHRcdHRhcmdldFRvdWNoZXM6IFtdLFxuXHRcdFx0Y2hhbmdlZFRvdWNoZXM6IFt0b3VjaE9ial1cblx0XHR9KSk7XG5cdH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgICYgcmV0dXJuIGJvdW5kIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHRwbCBUZW1wbGF0ZSBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgdmFsdWUgdG8gYmUgcmVwbGFjZWRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRwbFByb2Nlc3MgPSAodHBsLCBkYXRhKSA9PiB7XG5cdGxldCByZXMgPSB0cGw7XG5cblx0Zm9yIChjb25zdCB4IGluIGRhdGEpIHtcblx0XHRyZXMgPSByZXMucmVwbGFjZShuZXcgUmVnRXhwKGB7PSR7eH19YCwgXCJnXCIpLCBkYXRhW3hdKTtcblx0fVxuXG5cdHJldHVybiByZXM7XG59O1xuXG5leHBvcnQge1xuXHRhc0hhbGZQaXhlbCxcblx0YnJ1c2hFbXB0eSxcblx0Y2FsbEZuLFxuXHRjYXBpdGFsaXplLFxuXHRjZWlsMTAsXG5cdGRpZmZEb21haW4sXG5cdGVtdWxhdGVFdmVudCxcblx0ZXh0ZW5kLFxuXHRnZXRCcnVzaFNlbGVjdGlvbixcblx0Z2V0Q3NzUnVsZXMsXG5cdGdldE1pbk1heCxcblx0Z2V0T3B0aW9uLFxuXHRnZXRQYXRoQm94LFxuXHRnZXRSYW5kb20sXG5cdGdldFJhbmdlLFxuXHRnZXRSZWN0U2VnTGlzdCxcblx0Z2V0VW5pcXVlLFxuXHRoYXNWYWx1ZSxcblx0aXNBcnJheSxcblx0aXNCb29sZWFuLFxuXHRpc0RlZmluZWQsXG5cdGlzRW1wdHksXG5cdGlzRnVuY3Rpb24sXG5cdGlzTnVtYmVyLFxuXHRpc09iamVjdCxcblx0aXNPYmplY3RUeXBlLFxuXHRpc1N0cmluZyxcblx0aXNVbmRlZmluZWQsXG5cdGlzVmFsdWUsXG5cdG1lcmdlQXJyYXksXG5cdG1lcmdlT2JqLFxuXHRub3RFbXB0eSxcblx0c2FuaXRpc2UsXG5cdHNldFRleHRWYWx1ZSxcblx0c29ydFZhbHVlLFxuXHR0b0FycmF5LFxuXHR0cGxQcm9jZXNzXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIEBpZ25vcmVcbiAqL1xuaW1wb3J0IHtzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyfSBmcm9tIFwiZDMtc2NhbGVcIjtcbmltcG9ydCB7aXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmd9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXJIZWxwZXIge1xuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBhcmFtcykge1xuXHRcdGNvbnN0IHNjYWxlID0gZDNTY2FsZUxpbmVhcigpO1xuXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XG5cdFx0dGhpcy5zY2FsZSA9IHNjYWxlO1xuXG5cdFx0aWYgKGNvbmZpZy5ub1RyYW5zaXRpb24gfHwgIXBhcmFtcy5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbikge1xuXHRcdFx0Y29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBzZXQgcmFuZ2Vcblx0XHRjb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGUgYSBjaGFyYWN0ZXIgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBub2RlXG5cdCAqIEByZXR1cm4ge3t3OiBudW1iZXIsIGg6IG51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgZ2V0U2l6ZUZvcjFDaGFyKG5vZGUpIHtcblx0XHQvLyBkZWZhdWx0IHNpemUgZm9yIG9uZSBjaGFyYWN0ZXJcblx0XHRjb25zdCBzaXplID0ge1xuXHRcdFx0dzogNS41LFxuXHRcdFx0aDogMTEuNVxuXHRcdH07XG5cblx0XHQhbm9kZS5lbXB0eSgpICYmIG5vZGUuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0LnRleHQoXCIwXCIpXG5cdFx0XHQuY2FsbChlbCA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcblxuXHRcdFx0XHRcdGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xuXHRcdFx0XHRcdFx0c2l6ZS5oID0gaGVpZ2h0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsLnRleHQoXCJcIik7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuZ2V0U2l6ZUZvcjFDaGFyID0gKCkgPT4gc2l6ZTtcblxuXHRcdHJldHVybiBzaXplO1xuXHR9XG5cblx0YXhpc1goc2VsZWN0aW9uLCB4KSB7XG5cdFx0c2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7TWF0aC5jZWlsKHgoZCkgKyB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0KX0sMClgKTtcblx0fVxuXG5cdGF4aXNZKHNlbGVjdGlvbiwgeSkge1xuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgwLCR7TWF0aC5jZWlsKHkoZCkpfSlgKTtcblx0fVxuXG5cdHNjYWxlRXh0ZW50KGRvbWFpbikge1xuXHRcdGNvbnN0IHN0YXJ0ID0gZG9tYWluWzBdO1xuXHRcdGNvbnN0IHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG5cdFx0cmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFtzdGFydCwgc3RvcF0gOiBbc3RvcCwgc3RhcnRdO1xuXHR9XG5cblx0Z2VuZXJhdGVUaWNrcyhzY2FsZSkge1xuXHRcdGNvbnN0IHRpY2tzID0gW107XG5cblx0XHRpZiAoc2NhbGUudGlja3MpIHtcblx0XHRcdHJldHVybiBzY2FsZS50aWNrcyhcblx0XHRcdFx0Li4uKHRoaXMuY29uZmlnLnRpY2tBcmd1bWVudHMgfHwgW10pXG5cdFx0XHQpLm1hcCh2ID0+IChcblx0XHRcdFx0Ly8gcm91bmQgdGhlIHRpY2sgdmFsdWUgaWYgaXMgbnVtYmVyXG5cdFx0XHRcdChpc1N0cmluZyh2KSAmJiBpc051bWJlcih2KSAmJiAhaXNOYU4odikgJiZcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMFxuXHRcdFx0XHQpIHx8IHZcblx0XHRcdCkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbChkb21haW5bMF0pOyBpIDwgZG9tYWluWzFdOyBpKyspIHtcblx0XHRcdHRpY2tzLnB1c2goaSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA+IDAgJiYgdGlja3NbMF0gPiAwKSB7XG5cdFx0XHR0aWNrcy51bnNoaWZ0KHRpY2tzWzBdIC0gKHRpY2tzWzFdIC0gdGlja3NbMF0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGlja3M7XG5cdH1cblxuXHRjb3B5U2NhbGUoKSB7XG5cdFx0Y29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlLmNvcHkoKTtcblxuXHRcdGlmICghbmV3U2NhbGUuZG9tYWluKCkubGVuZ3RoKSB7XG5cdFx0XHRuZXdTY2FsZS5kb21haW4odGhpcy5zY2FsZS5kb21haW4oKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1NjYWxlO1xuXHR9XG5cblx0dGV4dEZvcm1hdHRlZCh2KSB7XG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XG5cblx0XHQvLyB0byByb3VuZCBmbG9hdCBudW1iZXJzIGZyb20gJ2JpbmFyeSBmbG9hdGluZyBwb2ludCdcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxuXHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODQ5MTAxL2xheW1hbnMtZXhwbGFuYXRpb24tZm9yLXdoeS1qYXZhc2NyaXB0LWhhcy13ZWlyZC1mbG9hdGluZy1tYXRoLWllZWUtNzU0LXN0YW5kXG5cdFx0Y29uc3QgdmFsdWUgPSAvXFxkK1xcLlxcZCswezUsfVxcZCQvLnRlc3QodikgPyArU3RyaW5nKHYpLnJlcGxhY2UoLzArXFxkJC8sIFwiXCIpIDogdjtcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcblxuXHRcdHJldHVybiBpc0RlZmluZWQoZm9ybWF0dGVkKSA/IGZvcm1hdHRlZCA6IFwiXCI7XG5cdH1cblxuXHR0cmFuc2l0aW9uaXNlKHNlbGVjdGlvbikge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA/XG5cdFx0XHRzZWxlY3Rpb24uaW50ZXJydXB0KCkgOiBzZWxlY3Rpb24udHJhbnNpdGlvbihjb25maWcudHJhbnNpdGlvbik7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBAaWdub3JlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgSGVscGVyIGZyb20gXCIuL0F4aXNSZW5kZXJlckhlbHBlclwiO1xuaW1wb3J0IHtpc0FycmF5LCB0b0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXJ9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXIge1xuXHRjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHtcblx0XHRcdGlubmVyVGlja1NpemU6IDYsXG5cdFx0XHRvdXRlclRpY2tTaXplOiBwYXJhbXMub3V0ZXJUaWNrID8gNiA6IDAsXG5cdFx0XHRvcmllbnQ6IFwiYm90dG9tXCIsXG5cdFx0XHRyYW5nZTogW10sXG5cdFx0XHR0aWNrQXJndW1lbnRzOiBudWxsLFxuXHRcdFx0dGlja0NlbnRlcmVkOiBudWxsLFxuXHRcdFx0dGlja0N1bGxpbmc6IHRydWUsXG5cdFx0XHR0aWNrRm9ybWF0OiBudWxsLFxuXHRcdFx0dGlja0xlbmd0aDogOSxcblx0XHRcdHRpY2tPZmZzZXQ6IDAsXG5cdFx0XHR0aWNrUGFkZGluZzogMyxcblx0XHRcdHRpY2tWYWx1ZXM6IG51bGwsXG5cdFx0XHR0cmFuc2l0aW9uOiBudWxsLFxuXHRcdFx0bm9UcmFuc2l0aW9uOiBwYXJhbXMubm9UcmFuc2l0aW9uXG5cdFx0fTtcblxuXHRcdGNvbmZpZy50aWNrTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLmlubmVyVGlja1NpemUsIDApICsgY29uZmlnLnRpY2tQYWRkaW5nO1xuXG5cdFx0dGhpcy5oZWxwZXIgPSBuZXcgSGVscGVyKGNvbmZpZywgcGFyYW1zKTtcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYXhpcyBlbGVtZW50XG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjcmVhdGUoZykge1xuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cdFx0Y29uc3QgaGVscGVySW5zdCA9IHRoaXMuaGVscGVyO1xuXHRcdGNvbnN0IHNjYWxlID0gaGVscGVySW5zdC5zY2FsZTtcblx0XHRjb25zdCBvcmllbnQgPSBjb25maWcub3JpZW50O1xuXHRcdGNvbnN0IHNwbGl0VGlja1RleHQgPSB0aGlzLnNwbGl0VGlja1RleHQuYmluZCh0aGlzKTtcblxuXHRcdGNvbnN0IGlzTGVmdFJpZ2h0ID0gL14obGVmdHxyaWdodCkkLy50ZXN0KG9yaWVudCk7XG5cdFx0Y29uc3QgaXNUb3BCb3R0b20gPSAvXih0b3B8Ym90dG9tKSQvLnRlc3Qob3JpZW50KTtcblxuXHRcdC8vIGxpbmUvdGV4dCBlbnRlciBhbmQgcGF0aCB1cGRhdGVcblx0XHRjb25zdCB0aWNrVHJhbnNmb3JtID0gaGVscGVySW5zdFtpc1RvcEJvdHRvbSA/IFwiYXhpc1hcIiA6IFwiYXhpc1lcIl07XG5cdFx0Y29uc3QgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVySW5zdC5heGlzWCA/IFwieVwiIDogXCJ4XCI7XG5cdFx0Y29uc3Qgc2lnbiA9IC9eKHRvcHxsZWZ0KSQvLnRlc3Qob3JpZW50KSA/IC0xIDogMTtcblxuXHRcdC8vIHRpY2sgdGV4dCBoZWxwZXJzXG5cdFx0Y29uc3Qgcm90YXRlID0gcGFyYW1zLnRpY2tUZXh0Um90YXRlO1xuXG5cdFx0dGhpcy5jb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcblx0XHRcdGhlbHBlckluc3Quc2NhbGVFeHRlbnQoKHBhcmFtcy5vcmdYU2NhbGUgfHwgc2NhbGUpLnJhbmdlKCkpO1xuXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHRpY2tMZW5ndGgsIHJhbmdlfSA9IGNvbmZpZztcblxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXG5cdFx0Y29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuXHRcdGNvbnN0IHRpY2tUZXh0UG9zID0gbmFtZSAmJiAvXih4fHl8eTIpJC8udGVzdChuYW1lKSA/XG5cdFx0XHRwYXJhbXMuY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja190ZXh0X3Bvc2l0aW9uYF0gOiB7eDogMCwgeTogMH07XG5cblx0XHQvLyB0aWNrIHZpc2libGl0eVxuXHRcdGNvbnN0IHByZWZpeCA9IG5hbWUgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke25hbWV9YDtcblx0XHRjb25zdCBheGlzU2hvdyA9IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV9zaG93YF07XG5cdFx0Y29uc3QgdGlja1Nob3cgPSB7XG5cdFx0XHR0aWNrOiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3Nob3dgXSA6IGZhbHNlLFxuXHRcdFx0dGV4dDogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja190ZXh0X3Nob3dgXSA6IGZhbHNlXG5cdFx0fTtcblxuXHRcdGxldCAkZyA9IG51bGw7XG5cblx0XHRnLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRsZXQgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGU7XG5cdFx0XHRsZXQgc2NhbGUxID0gaGVscGVySW5zdC5jb3B5U2NhbGUoKTtcblxuXHRcdFx0JGcgPSBnO1xuXHRcdFx0dGhpcy5fX2NoYXJ0X18gPSBzY2FsZTE7XG5cblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xuXHRcdFx0XHRNYXRoLmNlaWwoKHNjYWxlMSgxKSAtIHNjYWxlMSgwKSkgLyAyKSA6IDA7XG5cblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cblx0XHRcdGNvbnN0IHBhdGggPSBnLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbMF0pO1xuXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cblx0XHRcdHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcblx0XHRcdFx0Lm1lcmdlKGhlbHBlckluc3QudHJhbnNpdGlvbmlzZShwYXRoKSlcblx0XHRcdFx0LmF0dHIoXCJkXCIsICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcblxuXHRcdFx0XHRcdHJldHVybiBpc1RvcEJvdHRvbSA/XG5cdFx0XHRcdFx0XHRgTSR7cmFuZ2VbMF19LCR7b3V0ZXJUaWNrU2l6ZWR9VjBIJHtyYW5nZVsxXX1WJHtvdXRlclRpY2tTaXplZH1gIDpcblx0XHRcdFx0XHRcdGBNJHtvdXRlclRpY2tTaXplZH0sJHtyYW5nZVswXX1IMFYke3JhbmdlWzFdfUgke291dGVyVGlja1NpemVkfWA7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGlja1Nob3cudGljayB8fCB0aWNrU2hvdy50ZXh0KSB7XG5cdFx0XHRcdC8vIGNvdW50IG9mIHRpY2sgZGF0YSBpbiBhcnJheVxuXHRcdFx0XHRjb25zdCB0aWNrcyA9IGNvbmZpZy50aWNrVmFsdWVzIHx8IGhlbHBlckluc3QuZ2VuZXJhdGVUaWNrcyhzY2FsZTEpO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb25cblx0XHRcdFx0bGV0IHRpY2sgPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpXG5cdFx0XHRcdFx0LmRhdGEodGlja3MsIHNjYWxlMSk7XG5cblx0XHRcdFx0Ly8gZW50ZXIgc2VsZWN0aW9uXG5cdFx0XHRcdGNvbnN0IHRpY2tFbnRlciA9IHRpY2tcblx0XHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHRcdC5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpXG5cdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cblx0XHRcdFx0Ly8gTUVNTzogTm8gZXhpdCB0cmFuc2l0aW9uLiBUaGUgcmVhc29uIGlzIHRoaXMgdHJhbnNpdGlvbiBhZmZlY3RzIG1heCB0aWNrIHdpZHRoIGNhbGN1bGF0aW9uIGJlY2F1c2Ugb2xkIHRpY2sgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgdGlja3MuXG5cdFx0XHRcdGNvbnN0IHRpY2tFeGl0ID0gdGljay5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0Ly8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXG5cdFx0XHRcdHRpY2sgPSB0aWNrRW50ZXIubWVyZ2UodGljayk7XG5cblx0XHRcdFx0dGlja1Nob3cudGljayAmJiB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcblx0XHRcdFx0dGlja1Nob3cudGV4dCAmJiB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuXHRcdFx0XHRjb25zdCBzaXplRm9yMUNoYXIgPSBIZWxwZXIuZ2V0U2l6ZUZvcjFDaGFyKHRpY2spO1xuXHRcdFx0XHRjb25zdCBjb3VudHMgPSBbXTtcblxuXHRcdFx0XHRsZXQgdHNwYW4gPSB0aWNrLnNlbGVjdChcInRleHRcIilcblx0XHRcdFx0XHQuc2VsZWN0QWxsKFwidHNwYW5cIilcblx0XHRcdFx0XHQuZGF0YSgoZCwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0ID0gcGFyYW1zLnRpY2tNdWx0aWxpbmUgP1xuXHRcdFx0XHRcdFx0XHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlMSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBzaXplRm9yMUNoYXIudykgOiAoXG5cdFx0XHRcdFx0XHRcdFx0aXNBcnJheShoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCkpID9cblx0XHRcdFx0XHRcdFx0XHRcdGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKS5jb25jYXQoKSA6IFtoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCldXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGNvdW50c1tpbmRleF0gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzcGxpdC5tYXAoc3BsaXR0ZWQgPT4gKHtpbmRleCwgc3BsaXR0ZWR9KSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dHNwYW4uZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0XHRcdHRzcGFuID0gdHNwYW5cblx0XHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0c3BhblwiKVxuXHRcdFx0XHRcdC5tZXJnZSh0c3Bhbilcblx0XHRcdFx0XHQudGV4dChkID0+IGQuc3BsaXR0ZWQpO1xuXG5cdFx0XHRcdC8vIHNldCA8dHNwYW4+J3MgcG9zaXRpb25cblx0XHRcdFx0dHNwYW5cblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNUb3BCb3R0b20gPyAwIDogdGlja0xlbmd0aCAqIHNpZ24pXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGR4ID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiAmJiByb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0ZHggPSA4ICogTWF0aC5zaW4oTWF0aC5QSSAqIChyb3RhdGUgLyAxODApKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGR4ICsgKHRpY2tUZXh0UG9zLnggfHwgMCk7XG5cdFx0XHRcdFx0fSkoKSlcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIChkLCBpKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWZWYWx1ZSA9IFwiLjcxZW1cIjtcblx0XHRcdFx0XHRcdGxldCBkeSA9IDA7XG5cblx0XHRcdFx0XHRcdGlmIChvcmllbnQgIT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0ZHkgPSBzaXplRm9yMUNoYXIuaDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGR5ID0gaXNMZWZ0UmlnaHQgPyAtKChjb3VudHNbZC5pbmRleF0gLSAxKSAqIChzaXplRm9yMUNoYXIuaCAvIDIpIC0gMykgOlxuXHRcdFx0XHRcdFx0XHRcdFx0KHRpY2tUZXh0UG9zLnkgPT09IDAgPyBkZWZWYWx1ZSA6IDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBpc051bWJlcihkeSkgJiYgdGlja1RleHRQb3MueSA/XG5cdFx0XHRcdFx0XHRcdGR5ICsgdGlja1RleHRQb3MueSA6IGR5IHx8IGRlZlZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbnN0IGxpbmVVcGRhdGUgPSB0aWNrLnNlbGVjdChcImxpbmVcIik7XG5cdFx0XHRcdGNvbnN0IHRleHRVcGRhdGUgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcImxpbmVcIikuYXR0cihgJHtheGlzUHh9MmAsIGlubmVyVGlja1NpemUgKiBzaWduKTtcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcInRleHRcIikuYXR0cihgJHtheGlzUHh9YCwgdGlja0xlbmd0aCAqIHNpZ24pO1xuXG5cdFx0XHRcdGN0eC5zZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKTtcblxuXHRcdFx0XHQvLyBBcHBlbmQgPHRpdGxlPiBmb3IgdG9vbHRpcCBkaXNwbGF5XG5cdFx0XHRcdHBhcmFtcy50aWNrVGl0bGUgJiYgdGV4dFVwZGF0ZS5hcHBlbmQgJiYgdGV4dFVwZGF0ZS5hcHBlbmQoXCJ0aXRsZVwiKVxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS50ZXh0KHBhcmFtcy50aWNrVGl0bGVbaW5kZXhdKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBzY2FsZTE7XG5cdFx0XHRcdFx0Y29uc3QgZHggPSB4LmJhbmR3aWR0aCgpIC8gMjtcblxuXHRcdFx0XHRcdHNjYWxlMCA9IGQgPT4geChkKSArIGR4O1xuXHRcdFx0XHRcdHNjYWxlMSA9IHNjYWxlMDtcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XG5cdFx0XHRcdFx0c2NhbGUwID0gc2NhbGUxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRXhpdCwgc2NhbGUxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRW50ZXIsIHNjYWxlMCk7XG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCBoZWxwZXJJbnN0LnRyYW5zaXRpb25pc2UodGljaykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSwgc2NhbGUxKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuZyA9ICRnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aWNrIHgveSBjb29yZGluYXRlXG5cdCAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUaWNrWFkoKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgcG9zID0ge3g6IDAsIHk6IDB9O1xuXG5cdFx0aWYgKHRoaXMucGFyYW1zLmlzQ2F0ZWdvcnkpIHtcblx0XHRcdHBvcy54ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldDtcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aWNrIHNpemVcblx0ICogQHBhcmFtIGRcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VGlja1NpemUoZCkge1xuXHRcdGNvbnN0IHNjYWxlID0gdGhpcy5oZWxwZXIuc2NhbGU7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0Y29uc3QgaW5uZXJUaWNrU2l6ZSA9IGNvbmZpZy5pbm5lclRpY2tTaXplO1xuXHRcdGNvbnN0IHJhbmdlID0gY29uZmlnLnJhbmdlO1xuXG5cdFx0Y29uc3QgdGlja1Bvc2l0aW9uID0gc2NhbGUoZCkgK1xuXHRcdFx0KGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQpO1xuXG5cdFx0cmV0dXJuIHJhbmdlWzBdIDwgdGlja1Bvc2l0aW9uICYmIHRpY2tQb3NpdGlvbiA8IHJhbmdlWzFdID8gaW5uZXJUaWNrU2l6ZSA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRpY2sncyBsaW5lICYgdGV4dCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gbGluZVVwZGF0ZVxuXHQgKiBAcGFyYW0gdGV4dFVwZGF0ZVxuXHQgKiBAcGFyYW0gc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpIHtcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgb3JpZW50LCB0aWNrTGVuZ3RoLCB0aWNrT2Zmc2V0fSA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IHJvdGF0ZSA9IHRoaXMucGFyYW1zLnRpY2tUZXh0Um90YXRlO1xuXG5cdFx0Y29uc3QgdGV4dEFuY2hvckZvclRleHQgPSByID0+ICghciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyBcInN0YXJ0XCIgOiBcImVuZFwiKSk7XG5cdFx0Y29uc3QgdGV4dFRyYW5zZm9ybSA9IHIgPT4gKHIgPyBgcm90YXRlKCR7cn0pYCA6IG51bGwpO1xuXHRcdGNvbnN0IHlGb3JUZXh0ID0gciA9PiAociA/IDExLjUgLSAyLjUgKiAociAvIDE1KSAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoKTtcblxuXHRcdHN3aXRjaCAob3JpZW50KSB7XG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIHRpY2tQb3MueClcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHRoaXMuZ2V0VGlja1NpemUuYmluZCh0aGlzKSk7XG5cblx0XHRcdFx0dGV4dFVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yVGV4dChyb3RhdGUpKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zZm9ybShyb3RhdGUpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidG9wXCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIDApXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XG5cblx0XHRcdFx0dGV4dFVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCAtdGlja0xlbmd0aCAqIDIpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRcdFx0bGluZVVwZGF0ZVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB0aWNrUG9zLnkpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB0aWNrUG9zLnkpO1xuXG5cdFx0XHRcdHRleHRVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgLXRpY2tMZW5ndGgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0XHRcdGxpbmVVcGRhdGVcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlubmVyVGlja1NpemUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcblxuXHRcdFx0XHR0ZXh0VXBkYXRlXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIDApXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcblx0c3BsaXRUaWNrVGV4dChkLCBzY2FsZSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBjaGFyV2lkdGgpIHtcblx0XHRjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcblx0XHRjb25zdCB0aWNrVGV4dCA9IHRoaXMuaGVscGVyLnRleHRGb3JtYXR0ZWQoZCk7XG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cblx0XHRcdHRpY2tUZXh0LnNwbGl0KFwiXFxuXCIpIDogW107XG5cblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJyYXkodGlja1RleHQpKSB7XG5cdFx0XHRyZXR1cm4gdGlja1RleHQ7XG5cdFx0fVxuXG5cdFx0bGV0IHRpY2tXaWR0aCA9IHBhcmFtcy50aWNrV2lkdGg7XG5cblx0XHRpZiAoIXRpY2tXaWR0aCB8fCB0aWNrV2lkdGggPD0gMCkge1xuXHRcdFx0dGlja1dpZHRoID0gaXNMZWZ0UmlnaHQgPyA5NSA6IChcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xuXHRcdFx0XHRcdChNYXRoLmNlaWwoc2NhbGUodGlja3NbMV0pIC0gc2NhbGUodGlja3NbMF0pKSAtIDEyKSA6IDExMFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzcGxpdChzcGxpdHRlZCwgdGV4dCkge1xuXHRcdFx0bGV0IHN1YnRleHQ7XG5cdFx0XHRsZXQgc3BhY2VJbmRleDtcblx0XHRcdGxldCB0ZXh0V2lkdGg7XG5cblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiIFwiKSB7XG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xuXHRcdFx0XHR0ZXh0V2lkdGggPSBjaGFyV2lkdGggKiBzdWJ0ZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XG5cdFx0XHRcdGlmICh0aWNrV2lkdGggPCB0ZXh0V2lkdGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3BsaXQoXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXG5cdFx0XHRcdFx0XHR0ZXh0LnNsaWNlKHNwYWNlSW5kZXggPyBzcGFjZUluZGV4ICsgMSA6IGkpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XG5cdH1cblxuXHRzY2FsZSh4KSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXIuc2NhbGU7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXIuc2NhbGUgPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRvcmllbnQoeCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9yaWVudDtcblx0XHR9XG5cblx0XHR0aGlzLmNvbmZpZy5vcmllbnQgPSB4IGluIHtcblx0XHRcdHRvcDogMSxcblx0XHRcdHJpZ2h0OiAxLFxuXHRcdFx0Ym90dG9tOiAxLFxuXHRcdFx0bGVmdDogMVxuXHRcdH0gPyBTdHJpbmcoeCkgOiBcImJvdHRvbVwiO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrRm9ybWF0KGZvcm1hdCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dGlja0NlbnRlcmVkKGlzQ2VudGVyZWQpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ2VudGVyZWQ7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tDZW50ZXJlZCA9IGlzQ2VudGVyZWQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cblx0ICogVGhlIHZhbHVlIHdpbGwgYmUgc2V0IGZvciAnY2F0ZWdvcnknIGF4aXMgdHlwZS5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja09mZnNldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja09mZnNldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGljayBpbnRlcnZhbCBjb3VudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0dGlja0ludGVydmFsKHNpemUpIHtcblx0XHRsZXQgaW50ZXJ2YWw7XG5cblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xuXHRcdFx0aW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0ICogMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5nLnNlbGVjdChcInBhdGguZG9tYWluXCIpXG5cdFx0XHRcdC5ub2RlKClcblx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCkgLSB0aGlzLmNvbmZpZy5vdXRlclRpY2tTaXplICogMjtcblxuXHRcdFx0aW50ZXJ2YWwgPSBsZW5ndGggLyAoc2l6ZSB8fCB0aGlzLmcuc2VsZWN0QWxsKFwibGluZVwiKS5zaXplKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XG5cdH1cblxuXHR0aWNrcyguLi5hcmdzKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoIWFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0aWNrQ3VsbGluZyhjdWxsaW5nKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBjb25maWcudGlja0N1bGxpbmc7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLnRpY2tDdWxsaW5nID0gY3VsbGluZztcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dGlja1ZhbHVlcyh4KSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRpZiAoaXNGdW5jdGlvbih4KSkge1xuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSAoKSA9PiB4KHRoaXMuaGVscGVyLnNjYWxlLmRvbWFpbigpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBjb25maWcudGlja1ZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSB4O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c2V0VHJhbnNpdGlvbih0KSB7XG5cdFx0dGhpcy5jb25maWcudHJhbnNpdGlvbiA9IHQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXG5cdGF4aXNCb3R0b20gYXMgZDNBeGlzQm90dG9tLFxuXHRheGlzTGVmdCBhcyBkM0F4aXNMZWZ0LFxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcbn0gZnJvbSBcImQzLWF4aXNcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuaW1wb3J0IEF4aXNSZW5kZXJlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJcIjtcblxuY29uc3QgaXNIb3Jpem9udGFsID0gKCQkLCBmb3JIb3Jpem9udGFsKSA9PiB7XG5cdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0cmV0dXJuIGZvckhvcml6b250YWwgPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkO1xufTtcblxuY29uc3QgZ2V0QXhpc0NsYXNzTmFtZSA9IGlkID0+IGAke0NMQVNTLmF4aXN9ICR7Q0xBU1NbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdfWA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXMge1xuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcblx0XHR0aGlzLnNldE9yaWVudCgpO1xuXHR9XG5cblx0aW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XG5cblx0XHRjb25maWcuYXhpc195Ml9zaG93ICYmIHRhcmdldC5wdXNoKFwieTJcIik7XG5cblx0XHQkJC5heGVzTGlzdCA9IHt9O1xuXG5cdFx0dGFyZ2V0LmZvckVhY2godiA9PiB7XG5cdFx0XHRjb25zdCBjbGFzc0F4aXMgPSBnZXRBeGlzQ2xhc3NOYW1lKHYpO1xuXHRcdFx0Y29uc3QgY2xhc3NMYWJlbCA9IENMQVNTW2BheGlzJHtjYXBpdGFsaXplKHYpfUxhYmVsYF07XG5cblx0XHRcdCQkLmF4ZXNbdl0gPSBtYWluLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0F4aXMpXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICgpID0+IHtcblx0XHRcdFx0XHRsZXQgcmVzID0gbnVsbDtcblxuXHRcdFx0XHRcdGlmICh2ID09PSBcInhcIikge1xuXHRcdFx0XHRcdFx0cmVzID0gJCQuY2xpcFBhdGhGb3JYQXhpcztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwieVwiICYmIGNvbmZpZy5heGlzX3lfaW5uZXIpIHtcblx0XHRcdFx0XHRcdHJlcyA9ICQkLmNsaXBQYXRoRm9yWUF4aXM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKHYpKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke3Z9X3Nob3dgXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIik7XG5cblx0XHRcdCQkLmF4ZXNbdl0uYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGFiZWwpXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFtcInJvdGF0ZSgtOTApXCIsIG51bGxdW1xuXHRcdFx0XHRcdHYgPT09IFwieFwiID8gKyFpc1JvdGF0ZWQgOiAraXNSb3RhdGVkXG5cdFx0XHRcdF0pXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRoaXMudGV4dEFuY2hvckZvclhBeGlzTGFiZWwuYmluZCh0aGlzKSk7XG5cblx0XHRcdHRoaXMuZ2VuZXJhdGVBeGVzKHYpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBheGlzIG9yaWVudCBhY2NvcmRpbmcgb3B0aW9uIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRPcmllbnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHlJbm5lciA9IGNvbmZpZy5heGlzX3lfaW5uZXI7XG5cdFx0Y29uc3QgeTJJbm5lciA9IGNvbmZpZy5heGlzX3kyX2lubmVyO1xuXG5cdFx0JCQueE9yaWVudCA9IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIjtcblx0XHQkJC55T3JpZW50ID0gaXNSb3RhdGVkID8gKHlJbm5lciA/IFwidG9wXCIgOiBcImJvdHRvbVwiKSA6ICh5SW5uZXIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG5cdFx0JCQueTJPcmllbnQgPSBpc1JvdGF0ZWQgPyAoeTJJbm5lciA/IFwiYm90dG9tXCIgOiBcInRvcFwiKSA6ICh5MklubmVyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xuXHRcdCQkLnN1YlhPcmllbnQgPSBpc1JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCI7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgYXhlc1xuXHQgKiBJdCdzIHVzZWQgd2hlbiBheGlzJyBheGVzIG9wdGlvbiBpcyBzZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIEF4aXMgaWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlQXhlcyhpZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXhlcyA9IFtdO1xuXHRcdGNvbnN0IGF4ZXNDb25maWcgPSBjb25maWdbYGF4aXNfJHtpZH1fYXhlc2BdO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IGQzQXhpcztcblxuXHRcdGlmIChpZCA9PT0gXCJ4XCIpIHtcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0xlZnQgOiBkM0F4aXNCb3R0b207XG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5XCIpIHtcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0JvdHRvbSA6IGQzQXhpc0xlZnQ7XG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5MlwiKSB7XG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNUb3AgOiBkM0F4aXNSaWdodDtcblx0XHR9XG5cblx0XHRpZiAoYXhlc0NvbmZpZy5sZW5ndGgpIHtcblx0XHRcdGF4ZXNDb25maWcuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3QgdGljayA9IHYudGljaztcblxuXHRcdFx0XHRheGVzLnB1c2goXG5cdFx0XHRcdFx0ZDNBeGlzKCQkW2lkXSlcblx0XHRcdFx0XHRcdC50aWNrcyh0aWNrLmNvdW50KVxuXHRcdFx0XHRcdFx0LnRpY2tGb3JtYXQodGljay5mb3JtYXQgfHwgKHggPT4geCkpXG5cdFx0XHRcdFx0XHQudGlja1ZhbHVlcyh0aWNrLnZhbHVlcylcblx0XHRcdFx0XHRcdC50aWNrU2l6ZU91dGVyKHRpY2sub3V0ZXIgPT09IGZhbHNlID8gMCA6IDYpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJC5heGVzTGlzdFtpZF0gPSBheGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBheGVzIG5vZGVzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVBeGVzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRPYmplY3Qua2V5cygkJC5heGVzTGlzdCkuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25zdCByYW5nZSA9ICQkW2lkXS5yYW5nZSgpO1xuXG5cdFx0XHQkJC5heGVzTGlzdFtpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRjb25zdCBheGlzUmFuZ2UgPSB2LnNjYWxlKCkucmFuZ2UoKTtcblxuXHRcdFx0XHQvLyBhZGp1c3QgcmFuZ2UgdmFsdWUgd2l0aCB0aGUgY3VycmVudFxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy84NTlcblx0XHRcdFx0aWYgKCFyYW5nZS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYXhpc1JhbmdlW2ldKSkge1xuXHRcdFx0XHRcdHYuc2NhbGUoKS5yYW5nZShyYW5nZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPSBgJHtnZXRBeGlzQ2xhc3NOYW1lKGlkKX0tJHtpICsgMX1gO1xuXHRcdFx0XHRsZXQgZyA9ICQkLm1haW4uc2VsZWN0KGAuJHtjbGFzc05hbWUucmVwbGFjZSgvXFxzLywgXCIuXCIpfWApO1xuXG5cdFx0XHRcdGlmIChnLmVtcHR5KCkpIHtcblx0XHRcdFx0XHRnID0gJCQubWFpbi5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcblx0XHRcdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIilcblx0XHRcdFx0XHRcdC5jYWxsKHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQkLnhBeGlzLmhlbHBlci50cmFuc2l0aW9uaXNlKGcpXG5cdFx0XHRcdFx0XHQuY2FsbCh2LnNjYWxlKCQkW2lkXSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShpZCwgaSArIDEpKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gY2FsbGVkIGZyb20gOiB1cGRhdGVTY2FsZXMoKSAmIGdldE1heFRpY2tXaWR0aCgpXG5cdGdldFhBeGlzKG5hbWUsIHNjYWxlLCBvdXRlclRpY2ssIG5vVHJhbnNpdGlvbiwgbm9UaWNrVGV4dFJvdGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNDYXRlZ29yeSA9ICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblx0XHRjb25zdCBvcmllbnQgPSAkJFtgJHtuYW1lfU9yaWVudGBdO1xuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSAkJC54QXhpc1RpY2tGb3JtYXQ7XG5cdFx0Y29uc3QgdGlja1ZhbHVlcyA9ICQkLnhBeGlzVGlja1ZhbHVlcztcblxuXHRcdGNvbnN0IGF4aXNQYXJhbXMgPSB7XG5cdFx0XHRpc0NhdGVnb3J5LFxuXHRcdFx0b3V0ZXJUaWNrLFxuXHRcdFx0bm9UcmFuc2l0aW9uLFxuXHRcdFx0Y29uZmlnLFxuXHRcdFx0bmFtZSxcblx0XHRcdHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXG5cdFx0XHR0aWNrV2lkdGg6IGNvbmZpZy5heGlzX3hfdGlja193aWR0aCxcblx0XHRcdHRpY2tUZXh0Um90YXRlOiBub1RpY2tUZXh0Um90YXRlID8gMCA6IGNvbmZpZy5heGlzX3hfdGlja19yb3RhdGUsXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcblx0XHRcdG9yZ1hTY2FsZTogJCQueFxuXHRcdH07XG5cblx0XHRjb25zdCBheGlzID0gbmV3IEF4aXNSZW5kZXJlcihheGlzUGFyYW1zKVxuXHRcdFx0LnNjYWxlKCQkLnpvb21TY2FsZSB8fCBzY2FsZSlcblx0XHRcdC5vcmllbnQob3JpZW50KTtcblxuXHRcdGxldCBuZXdUaWNrVmFsdWVzID0gdGlja1ZhbHVlcztcblxuXHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiB0aWNrVmFsdWVzICYmICFpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpKSB7XG5cdFx0XHRuZXdUaWNrVmFsdWVzID0gdGlja1ZhbHVlcy5tYXAodiA9PiAkJC5wYXJzZURhdGUodikpO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aWNrXG5cdFx0YXhpcy50aWNrRm9ybWF0KHRpY2tGb3JtYXQpLnRpY2tWYWx1ZXMobmV3VGlja1ZhbHVlcyk7XG5cblx0XHRpZiAoaXNDYXRlZ29yeSkge1xuXHRcdFx0YXhpcy50aWNrQ2VudGVyZWQoY29uZmlnLmF4aXNfeF90aWNrX2NlbnRlcmVkKTtcblxuXHRcdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpKSB7XG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmF4aXNfeF90aWNrX2NvdW50ICYmIGF4aXMudGlja3MoY29uZmlnLmF4aXNfeF90aWNrX2NvdW50KTtcblxuXHRcdHJldHVybiBheGlzO1xuXHR9XG5cblx0Ly8gY2FsbGVkIGZyb20gOiB1cGRhdGVTY2FsZXMoKSAmIGdldE1heFRpY2tXaWR0aCgpXG5cdGdldFlBeGlzKG5hbWUsIHNjYWxlLCBvdXRlclRpY2ssIG5vVHJhbnNpdGlvbiwgbm9UaWNrVGV4dFJvdGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgb3JpZW50ID0gJCRbYCR7bmFtZX1PcmllbnRgXTtcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja19mb3JtYXRgXTtcblx0XHRjb25zdCB0aWNrVmFsdWVzID0gJCRbYCR7bmFtZX1BeGlzVGlja1ZhbHVlc2BdO1xuXG5cdFx0Y29uc3QgYXhpc1BhcmFtcyA9IHtcblx0XHRcdG91dGVyVGljayxcblx0XHRcdG5vVHJhbnNpdGlvbixcblx0XHRcdGNvbmZpZyxcblx0XHRcdG5hbWUsXG5cdFx0XHR0aWNrVGV4dFJvdGF0ZTogbm9UaWNrVGV4dFJvdGF0ZSA/IDAgOiBjb25maWcuYXhpc195X3RpY2tfcm90YXRlXG5cdFx0fTtcblxuXHRcdGNvbnN0IGF4aXMgPSBuZXcgQXhpc1JlbmRlcmVyKGF4aXNQYXJhbXMpXG5cdFx0XHQuc2NhbGUoc2NhbGUpXG5cdFx0XHQub3JpZW50KG9yaWVudClcblx0XHRcdC50aWNrRm9ybWF0KFxuXHRcdFx0XHR0aWNrRm9ybWF0IHx8ICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpICYmICh4ID0+IGAke3h9JWApKVxuXHRcdFx0KTtcblxuXHRcdCQkLmlzVGltZVNlcmllc1koKSA/XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi9tYXN0ZXIvQ0hBTkdFUy5tZCN0aW1lLWludGVydmFscy1kMy10aW1lXG5cdFx0XHRheGlzLnRpY2tzKGNvbmZpZy5heGlzX3lfdGlja190aW1lX3ZhbHVlKSA6XG5cdFx0XHRheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XG5cblx0XHRyZXR1cm4gYXhpcztcblx0fVxuXG5cdHVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzLCBheGlzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBmaXQgPSBjb25maWcuYXhpc194X3RpY2tfZml0O1xuXHRcdGNvbnN0IGNvdW50ID0gY29uZmlnLmF4aXNfeF90aWNrX2NvdW50O1xuXHRcdGxldCB2YWx1ZXM7XG5cblx0XHRpZiAoZml0IHx8IChjb3VudCAmJiBmaXQpKSB7XG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcblx0XHRcdFx0JCQubWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cyksXG5cdFx0XHRcdGNvdW50LFxuXHRcdFx0XHQkJC5pc1RpbWVTZXJpZXMoKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoYXhpcykge1xuXHRcdFx0YXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XG5cdFx0fSBlbHNlIGlmICgkJC54QXhpcykge1xuXHRcdFx0JCQueEF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpO1xuXHRcdFx0JCQuc3ViWEF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cblxuXHRnZXRJZChpZCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMub3duZXIuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGlkIGluIGNvbmZpZy5kYXRhX2F4ZXMgPyBjb25maWcuZGF0YV9heGVzW2lkXSA6IFwieVwiO1xuXHR9XG5cblx0Z2V0WEF4aXNUaWNrRm9ybWF0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IGNvbmZpZy5heGlzX3hfdGlja19mb3JtYXQ7XG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblx0XHRsZXQgZm9ybWF0O1xuXG5cdFx0aWYgKHRpY2tGb3JtYXQpIHtcblx0XHRcdGlmIChpc0Z1bmN0aW9uKHRpY2tGb3JtYXQpKSB7XG5cdFx0XHRcdGZvcm1hdCA9IHRpY2tGb3JtYXQ7XG5cdFx0XHR9IGVsc2UgaWYgKGlzVGltZVNlcmllcykge1xuXHRcdFx0XHRmb3JtYXQgPSBkYXRlID0+IChkYXRlID8gJCQuYXhpc1RpbWVGb3JtYXQodGlja0Zvcm1hdCkoZGF0ZSkgOiBcIlwiKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gJCQuZGVmYXVsdEF4aXNUaW1lRm9ybWF0IDogKFxuXHRcdFx0XHRpc0NhdGVnb3JpemVkID9cblx0XHRcdFx0XHQkJC5jYXRlZ29yeU5hbWUgOiB2ID0+ICh2IDwgMCA/IHYudG9GaXhlZCgwKSA6IHYpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyB2ID0+XG5cdFx0XHRmb3JtYXQuYXBwbHkoJCQsIGlzQ2F0ZWdvcml6ZWQgP1xuXHRcdFx0XHRbdiwgJCQuY2F0ZWdvcnlOYW1lKHYpXSA6IFt2XVxuXHRcdFx0KSA6IGZvcm1hdDtcblx0fVxuXG5cdGdldFRpY2tWYWx1ZXMoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgdGlja1ZhbHVlcyA9ICQkLmNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3ZhbHVlc2BdO1xuXHRcdGNvbnN0IGF4aXMgPSAkJFtgJHtpZH1BeGlzYF07XG5cblx0XHRyZXR1cm4gdGlja1ZhbHVlcyB8fCAoYXhpcyA/IGF4aXMudGlja1ZhbHVlcygpIDogdW5kZWZpbmVkKTtcblx0fVxuXG5cdGdldFhBeGlzVGlja1ZhbHVlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUaWNrVmFsdWVzKFwieFwiKTtcblx0fVxuXG5cdGdldFlBeGlzVGlja1ZhbHVlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUaWNrVmFsdWVzKFwieVwiKTtcblx0fVxuXG5cdGdldFkyQXhpc1RpY2tWYWx1ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGlja1ZhbHVlcyhcInkyXCIpO1xuXHR9XG5cblx0Z2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCkge1xuXHRcdHJldHVybiB0aGlzLm93bmVyLmNvbmZpZ1tgYXhpc18ke2lkfV9sYWJlbGBdO1xuXHR9XG5cblx0Z2V0TGFiZWxUZXh0KGlkKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblxuXHRcdHJldHVybiBpc1N0cmluZyhvcHRpb24pID8gb3B0aW9uIDogKFxuXHRcdFx0b3B0aW9uID8gb3B0aW9uLnRleHQgOiBudWxsXG5cdFx0KTtcblx0fVxuXG5cdHNldExhYmVsVGV4dChpZCwgdGV4dCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblxuXHRcdGlmIChpc1N0cmluZyhvcHRpb24pKSB7XG5cdFx0XHRjb25maWdbYGF4aXNfJHtpZH1fbGFiZWxgXSA9IHRleHQ7XG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcblx0XHRcdG9wdGlvbi50ZXh0ID0gdGV4dDtcblx0XHR9XG5cdH1cblxuXHRnZXRMYWJlbFBvc2l0aW9uKGlkLCBkZWZhdWx0UG9zaXRpb24pIHtcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IChpc09iamVjdFR5cGUob3B0aW9uKSAmJiBvcHRpb24ucG9zaXRpb24pID9cblx0XHRcdG9wdGlvbi5wb3NpdGlvbiA6IGRlZmF1bHRQb3NpdGlvblsrIWlzUm90YXRlZF07XG5cblx0XHRjb25zdCBoYXMgPSB2ID0+ICEhfnBvc2l0aW9uLmluZGV4T2Yodik7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aXNJbm5lcjogaGFzKFwiaW5uZXJcIiksXG5cdFx0XHRpc091dGVyOiBoYXMoXCJvdXRlclwiKSxcblx0XHRcdGlzTGVmdDogaGFzKFwibGVmdFwiKSxcblx0XHRcdGlzQ2VudGVyOiBoYXMoXCJjZW50ZXJcIiksXG5cdFx0XHRpc1JpZ2h0OiBoYXMoXCJyaWdodFwiKSxcblx0XHRcdGlzVG9wOiBoYXMoXCJ0b3BcIiksXG5cdFx0XHRpc01pZGRsZTogaGFzKFwibWlkZGxlXCIpLFxuXHRcdFx0aXNCb3R0b206IGhhcyhcImJvdHRvbVwiKVxuXHRcdH07XG5cdH1cblxuXHRnZXRYQXhpc0xhYmVsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInhcIiwgW1wiaW5uZXItdG9wXCIsIFwiaW5uZXItcmlnaHRcIl0pO1xuXHR9XG5cblx0Z2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ5XCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcblx0fVxuXG5cdGdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihcInkyXCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcblx0fVxuXG5cdGdldExhYmVsUG9zaXRpb25CeUlkKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXNbYGdldCR7aWQudG9VcHBlckNhc2UoKX1BeGlzTGFiZWxQb3NpdGlvbmBdKCk7XG5cdH1cblxuXHR0ZXh0Rm9yWEF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ4XCIpO1xuXHR9XG5cblx0dGV4dEZvcllBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieVwiKTtcblx0fVxuXG5cdHRleHRGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ5MlwiKTtcblx0fVxuXG5cdHhGb3JBeGlzTGFiZWwocG9zaXRpb24sIGZvckhvcml6b250YWwgPSB0cnVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGxldCB4ID0gcG9zaXRpb24uaXNNaWRkbGUgPyAtJCQuaGVpZ2h0IC8gMiA6IDA7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xuXHRcdFx0eCA9IHBvc2l0aW9uLmlzTGVmdCA/IDAgOiAoXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gJCQud2lkdGggLyAyIDogJCQud2lkdGhcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xuXHRcdFx0eCA9IC0kJC5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRkeEZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcblxuXHRcdGlmIChpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XG5cdFx0XHRkeCA9IHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IChcblx0XHRcdFx0cG9zaXRpb24uaXNSaWdodCA/IFwiLTAuNWVtXCIgOiBcIjBcIlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzVG9wKSB7XG5cdFx0XHRkeCA9IFwiLTAuNWVtXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGR4O1xuXHR9XG5cblx0dGV4dEFuY2hvckZvckF4aXNMYWJlbChwb3NpdGlvbiwgZm9ySG9yaXpvbnRhbCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0bGV0IGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKCQkLCBmb3JIb3Jpem9udGFsKSkge1xuXHRcdFx0YW5jaG9yID0gcG9zaXRpb24uaXNMZWZ0ID8gXCJzdGFydFwiIDogKFxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYW5jaG9yO1xuXHR9XG5cblx0eEZvclhBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLCBmYWxzZSk7XG5cdH1cblxuXHR4Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0eEZvclkyQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0ZHhGb3JYQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcblx0fVxuXG5cdGR4Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5keEZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdGR4Rm9yWTJBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuXHR9XG5cblx0ZHlGb3JYQXhpc0xhYmVsKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcblx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XG5cblx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSB0aGlzLmdldE1heFRpY2tXaWR0aChcInhcIik7XG5cdFx0fSBlbHNlIGlmIChpc0lubmVyKSB7XG5cdFx0XHRyZXR1cm4gXCItMC41ZW1cIjtcblx0XHR9IGVsc2UgaWYgKHhIZWlnaHQpIHtcblx0XHRcdHJldHVybiB4SGVpZ2h0IC0gMTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcIjNlbVwiO1xuXHRcdH1cblx0fVxuXG5cdGR5Rm9yWUF4aXNMYWJlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcblxuXHRcdGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiBcIjNlbVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiMS4yZW1cIiA6IC0xMCAtICgkJC5jb25maWcuYXhpc195X2lubmVyID8gMCA6ICh0aGlzLmdldE1heFRpY2tXaWR0aChcInlcIikgKyAxMCkpO1xuXHRcdH1cblx0fVxuXG5cdGR5Rm9yWTJBeGlzTGFiZWwoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKS5pc0lubmVyO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdHJldHVybiBpc0lubmVyID8gXCIxLjJlbVwiIDogXCItMi4yZW1cIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIi0wLjVlbVwiIDogMTUgKyAoJCQuY29uZmlnLmF4aXNfeTJfaW5uZXIgPyAwIDogKHRoaXMuZ2V0TWF4VGlja1dpZHRoKFwieTJcIikgKyAxNSkpO1xuXHRcdH1cblx0fVxuXG5cdHRleHRBbmNob3JGb3JYQXhpc0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xuXHR9XG5cblx0dGV4dEFuY2hvckZvcllBeGlzTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdHRleHRBbmNob3JGb3JZMkF4aXNMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcblx0fVxuXG5cdGdldE1heFRpY2tXaWR0aChpZCwgd2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY3VycmVudFRpY2tNYXggPSAkJC5jdXJyZW50TWF4VGlja1dpZHRoc1tpZF07XG5cdFx0bGV0IG1heFdpZHRoID0gMDtcblxuXHRcdGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcblx0XHR9XG5cblx0XHRpZiAoJCQuc3ZnKSB7XG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcblx0XHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRjb25zdCBnZXRGcm9tID0gaXNZQXhpcyA/IFwiZ2V0WVwiIDogXCJnZXRYXCI7XG5cblx0XHRcdGNvbnN0IHNjYWxlID0gJCRbaWRdLmNvcHkoKS5kb21haW4oJCRbYCR7Z2V0RnJvbX1Eb21haW5gXSh0YXJnZXRzVG9TaG93LCBpZCkpO1xuXHRcdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG5cblx0XHRcdC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXG5cdFx0XHRpZiAoaXNBcnJheShjdXJyZW50VGlja01heC5kb21haW4pICYmIGN1cnJlbnRUaWNrTWF4LmRvbWFpbi5ldmVyeSgodiwgaSkgPT4gdiA9PT0gZG9tYWluW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRUaWNrTWF4LmRvbWFpbiA9IGRvbWFpbjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYXhpcyA9IHRoaXNbYCR7Z2V0RnJvbX1BeGlzYF0oaWQsIHNjYWxlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuXHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY291bnRgXTtcblxuXHRcdFx0Ly8gTWFrZSB0byBnZW5lcmF0ZSB0aGUgZmluYWwgdGljayB0ZXh0IHRvIGJlIHJlbmRlcmVkXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy85MjBcblx0XHRcdGlmICh0aWNrQ291bnQpIHtcblx0XHRcdFx0YXhpcy50aWNrVmFsdWVzKFxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxuXHRcdFx0XHRcdFx0ZG9tYWluLFxuXHRcdFx0XHRcdFx0dGlja0NvdW50LFxuXHRcdFx0XHRcdFx0aXNZQXhpcyA/ICQkLmlzVGltZVNlcmllc1koKSA6ICQkLmlzVGltZVNlcmllcygpXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHR9XG5cblx0XHRcdCFpc1lBeGlzICYmIHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3csIGF4aXMpO1xuXG5cdFx0XHRjb25zdCBkdW1teSA9ICQkLnNlbGVjdENoYXJ0LmFwcGVuZChcInN2Z1wiKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXG5cdFx0XHRcdC5zdHlsZShcInBvc2l0aW9uXCIsIFwiZml4ZWRcIilcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsIFwiMHB4XCIpXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgXCIwcHhcIik7XG5cblx0XHRcdGF4aXMuY3JlYXRlKGR1bW15KTtcblxuXHRcdFx0ZHVtbXkuc2VsZWN0QWxsKFwidGV4dFwiKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdGR1bW15LnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChtYXhXaWR0aCA+IDApIHtcblx0XHRcdGN1cnJlbnRUaWNrTWF4LnNpemUgPSBtYXhXaWR0aDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcblx0fVxuXG5cdHVwZGF0ZUxhYmVscyh3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBsYWJlbHMgPSB7XG5cdFx0XHRYOiAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9IC4ke0NMQVNTLmF4aXNYTGFiZWx9YCksXG5cdFx0XHRZOiAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1l9IC4ke0NMQVNTLmF4aXNZTGFiZWx9YCksXG5cdFx0XHRZMjogJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZMn0gLiR7Q0xBU1MuYXhpc1kyTGFiZWx9YClcblx0XHR9O1xuXG5cdFx0T2JqZWN0LmtleXMobGFiZWxzKS5maWx0ZXIoaWQgPT4gIWxhYmVsc1tpZF0uZW1wdHkoKSlcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBub2RlID0gbGFiZWxzW3ZdO1xuXHRcdFx0XHRjb25zdCBheGlzTGFiZWwgPSBgJHt2fUF4aXNMYWJlbGA7XG5cblx0XHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbm9kZS50cmFuc2l0aW9uKCkgOiBub2RlKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB0aGlzW2B4Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIHRoaXNbYGR4Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIHRoaXNbYGR5Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcblx0XHRcdFx0XHQudGV4dCh0aGlzW2B0ZXh0Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGdldFBhZGRpbmcocGFkZGluZywga2V5LCBkZWZhdWx0VmFsdWUsIGRvbWFpbkxlbmd0aCkge1xuXHRcdGNvbnN0IHAgPSBpc051bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiBwYWRkaW5nW2tleV07XG5cblx0XHRpZiAoIWlzVmFsdWUocCkpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKHBhZGRpbmcudW5pdCA9PT0gXCJyYXRpb1wiKSB7XG5cdFx0XHRyZXR1cm4gcGFkZGluZ1trZXldICogZG9tYWluTGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIGFzc3VtZSBwYWRkaW5nIGlzIHBpeGVscyBpZiB1bml0IGlzIG5vdCBzcGVjaWZpZWRcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwLCBkb21haW5MZW5ndGgpO1xuXHR9XG5cblx0Y29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocGl4ZWxzLCBkb21haW5MZW5ndGgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgbGVuZ3RoID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogJCQuaGVpZ2h0O1xuXG5cdFx0cmV0dXJuIGRvbWFpbkxlbmd0aCAqIChwaXhlbHMgLyBsZW5ndGgpO1xuXHR9XG5cblx0Z2VuZXJhdGVUaWNrVmFsdWVzKHZhbHVlcywgdGlja0NvdW50LCBmb3JUaW1lU2VyaWVzKSB7XG5cdFx0bGV0IHRpY2tWYWx1ZXMgPSB2YWx1ZXM7XG5cdFx0bGV0IHN0YXJ0O1xuXHRcdGxldCBlbmQ7XG5cdFx0bGV0IGNvdW50O1xuXHRcdGxldCBpbnRlcnZhbDtcblx0XHRsZXQgaTtcblx0XHRsZXQgdGlja1ZhbHVlO1xuXG5cdFx0aWYgKHRpY2tDb3VudCkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0Q291bnQgPSBpc0Z1bmN0aW9uKHRpY2tDb3VudCkgPyB0aWNrQ291bnQoKSA6IHRpY2tDb3VudDtcblxuXHRcdFx0Ly8gY29tcHV0ZSB0aWNrcyBhY2NvcmRpbmcgdG8gdGlja0NvdW50XG5cdFx0XHRpZiAodGFyZ2V0Q291bnQgPT09IDEpIHtcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXRDb3VudCA9PT0gMikge1xuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3ZhbHVlc1swXSwgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXV07XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xuXHRcdFx0XHRjb3VudCA9IHRhcmdldENvdW50IC0gMjtcblx0XHRcdFx0c3RhcnQgPSB2YWx1ZXNbMF07XG5cdFx0XHRcdGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGludGVydmFsID0gKGVuZCAtIHN0YXJ0KSAvIChjb3VudCArIDEpO1xuXG5cdFx0XHRcdC8vIHJlLWNvbnN0cnVjdCB1bmlxdWUgdmFsdWVzXG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbc3RhcnRdO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0dGlja1ZhbHVlID0gK3N0YXJ0ICsgaW50ZXJ2YWwgKiAoaSArIDEpO1xuXHRcdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChmb3JUaW1lU2VyaWVzID8gbmV3IERhdGUodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aWNrVmFsdWVzLnB1c2goZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWZvclRpbWVTZXJpZXMpIHtcblx0XHRcdHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGlja1ZhbHVlcztcblx0fVxuXG5cdGdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XG5cdFx0Y29uc3QgYXhlcyA9ICQkLmF4ZXM7XG5cblx0XHRjb25zdCBbYXhpc1gsIGF4aXNZLCBheGlzWTIsIGF4aXNTdWJYXSA9IFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJ4XCJdXG5cdFx0XHQubWFwKHYgPT4ge1xuXHRcdFx0XHRsZXQgYXhpcyA9IGF4ZXNbdl07XG5cblx0XHRcdFx0aWYgKGF4aXMgJiYgZHVyYXRpb24pIHtcblx0XHRcdFx0XHRheGlzID0gYXhpcy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGF4aXM7XG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiB7YXhpc1gsIGF4aXNZLCBheGlzWTIsIGF4aXNTdWJYfTtcblx0fVxuXG5cdHJlZHJhdyh0cmFuc2l0aW9ucywgaXNIaWRkZW4sIGlzSW5pdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcblx0XHRjb25zdCBvcGFjaXR5ID0gaXNIaWRkZW4gPyBcIjBcIiA6IFwiMVwiO1xuXG5cdFx0W1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl0uZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25zdCBheGlzID0gJCRbYCR7aWR9QXhpc2BdO1xuXG5cdFx0XHRpZiAoYXhpcykge1xuXHRcdFx0XHRpZiAoIWlzSW5pdCkge1xuXHRcdFx0XHRcdGF4aXMuY29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID0gISQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JCQuYXhlc1tpZC50b0xvd2VyQ2FzZSgpXS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XG5cdFx0XHRcdGF4aXMuY3JlYXRlKHRyYW5zaXRpb25zW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLnVwZGF0ZUF4ZXMoKTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIEBpZ25vcmVcbiAqL1xuaW1wb3J0IHtcblx0dGltZVBhcnNlIGFzIGQzVGltZVBhcnNlLFxuXHR0aW1lRm9ybWF0IGFzIGQzVGltZUZvcm1hdCxcblx0dXRjUGFyc2UgYXMgZDNVdGNQYXJzZSxcblx0dXRjRm9ybWF0IGFzIGQzVXRjRm9ybWF0XG59IGZyb20gXCJkMy10aW1lLWZvcm1hdFwiO1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGxcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0cmFuc2l0aW9uIGFzIGQzVHJhbnNpdGlvbn0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuLi9heGlzL0F4aXNcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQge25vdEVtcHR5LCBhc0hhbGZQaXhlbCwgZ2V0T3B0aW9uLCBpc1ZhbHVlLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzT2JqZWN0LCBjYWxsRm4sIHNvcnRWYWx1ZX0gZnJvbSBcIi4vdXRpbFwiO1xuXG4vKipcbiAqIEludGVybmFsIGNoYXJ0IGNsYXNzLlxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cbiAqIEBjbGFzcyBDaGFydEludGVybmFsXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydEludGVybmFsIHtcblx0Y29uc3RydWN0b3IoYXBpKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuYXBpID0gYXBpO1xuXHRcdCQkLmNvbmZpZyA9ICQkLmdldE9wdGlvbnMoKTtcblx0XHQkJC5kYXRhID0ge307XG5cdFx0JCQuY2FjaGUgPSB7fTtcblx0XHQkJC5heGVzID0ge307XG5cdH1cblxuXHRiZWZvcmVJbml0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XG5cblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkKTtcblx0fVxuXG5cdGFmdGVySW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRhZnRlckluaXRcIik7XG5cblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmFmdGVyaW5pdCwgJCQpO1xuXHR9XG5cblx0aW5pdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5pbml0UGFyYW1zKCk7XG5cblx0XHRjb25zdCBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoJCQuY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xuXG5cdFx0Y29udmVydGVkRGF0YSAmJiAkJC5pbml0V2l0aERhdGEoY29udmVydGVkRGF0YSk7XG5cdH1cblxuXHRpbml0UGFyYW1zKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIGRhdGV0aW1lIHRvIGJlIHVzZWQgZm9yIHVuaXF1ZW5lc3Ncblx0XHQkJC5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcblx0XHQkJC5pbml0Q2xpcCgpO1xuXG5cdFx0JCQuZHJhZ1N0YXJ0ID0gbnVsbDtcblx0XHQkJC5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdCQkLmZsb3dpbmcgPSBmYWxzZTtcblx0XHQkJC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdCQkLm1vdXNlb3ZlciA9IGZhbHNlO1xuXHRcdCQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcblxuXHRcdCQkLmNvbG9yID0gJCQuZ2VuZXJhdGVDb2xvcigpO1xuXHRcdCQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcblx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcblxuXHRcdCQkLmV4dHJhTGluZUNsYXNzZXMgPSAkJC5nZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk7XG5cblx0XHQkJC5kYXRhVGltZUZvcm1hdCA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XG5cdFx0JCQuYXhpc1RpbWVGb3JtYXQgPSBjb25maWcuYXhpc194X2xvY2FsdGltZSA/IGQzVGltZUZvcm1hdCA6IGQzVXRjRm9ybWF0O1xuXG5cdFx0Y29uc3QgaXNEcmFnWm9vbSA9ICQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIjtcblxuXHRcdCQkLmRlZmF1bHRBeGlzVGltZUZvcm1hdCA9IGQgPT4ge1xuXHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gdGhpcy56b29tU2NhbGUgOlxuXHRcdFx0XHR0aGlzLnpvb21TY2FsZSAmJiAkJC54Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHRoaXMuem9vbVNjYWxlLmRvbWFpbigpLnRvU3RyaW5nKCk7XG5cblx0XHRcdGNvbnN0IHNwZWNpZmllciA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XG5cdFx0XHRcdChkLmdldFNlY29uZHMoKSAmJiBcIi46JVNcIikgfHxcblx0XHRcdFx0KGQuZ2V0TWludXRlcygpICYmIFwiJUk6JU1cIikgfHxcblx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XG5cdFx0XHRcdChkLmdldERhdGUoKSAhPT0gMSAmJiBcIiViICVkXCIpIHx8XG5cdFx0XHRcdChpc1pvb21lZCAmJiBkLmdldERhdGUoKSA9PT0gMSAmJiBcIiViXFwnJXlcIikgfHxcblx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xuXG5cdFx0XHRyZXR1cm4gJCQuYXhpc1RpbWVGb3JtYXQoc3BlY2lmaWVyKShkKTtcblx0XHR9O1xuXG5cdFx0JCQuaGlkZGVuVGFyZ2V0SWRzID0gW107XG5cdFx0JCQuaGlkZGVuTGVnZW5kSWRzID0gW107XG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuXG5cdFx0JCQuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiO1xuXG5cdFx0JCQuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtcmlnaHRcIjtcblx0XHQkJC5pc0xlZ2VuZExlZnQgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJib3R0b20tbGVmdFwiO1xuXG5cdFx0JCQubGVnZW5kU3RlcCA9IDA7XG5cdFx0JCQubGVnZW5kSXRlbVdpZHRoID0gMDtcblx0XHQkJC5sZWdlbmRJdGVtSGVpZ2h0ID0gMDtcblxuXHRcdCQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzID0ge1xuXHRcdFx0eDoge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXG5cdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcblx0XHRcdHkyOiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifVxuXHRcdH07XG5cblx0XHQkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCA9IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ19yaWdodCA9IGlzUm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeF9zaG93ID8gMCA6IDMwO1xuXHRcdCQkLnJvdGF0ZWRfcGFkZGluZ190b3AgPSA1O1xuXG5cdFx0JCQud2l0aG91dEZhZGVJbiA9IHt9O1xuXHRcdCQkLmlucHV0VHlwZSA9ICQkLmNvbnZlcnRJbnB1dFR5cGUoKTtcblxuXHRcdCQkLmF4ZXMuc3VieCA9IGQzU2VsZWN0QWxsKFtdKTsgLy8gbmVlZHMgd2hlbiBleGNsdWRpbmcgc3ViY2hhcnQuanNcblx0fVxuXG5cdGluaXRXaXRoRGF0YShkYXRhKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXG5cdFx0Ly8gJCQuaGFzQXJjVHlwZSgpICYmIFtcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChpZCA9PiAoY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA9IGZhbHNlKSk7XG5cblx0XHQkJC5heGlzID0gbmV3IEF4aXMoJCQpO1xuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcblxuXHRcdGNvbnN0IGJpbmR0byA9IHtcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXG5cdFx0XHRjbGFzc25hbWU6IFwiYmJcIlxuXHRcdH07XG5cblx0XHRpZiAoaXNPYmplY3QoY29uZmlnLmJpbmR0bykpIHtcblx0XHRcdGJpbmR0by5lbGVtZW50ID0gY29uZmlnLmJpbmR0by5lbGVtZW50IHx8IFwiI2NoYXJ0XCI7XG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XG5cdFx0JCQuc2VsZWN0Q2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cblx0XHRcdGNvbmZpZy5iaW5kdG8uZWxlbWVudCA6IGQzU2VsZWN0KGJpbmR0by5lbGVtZW50IHx8IFtdKTtcblxuXHRcdGlmICgkJC5zZWxlY3RDaGFydC5lbXB0eSgpKSB7XG5cdFx0XHQkJC5zZWxlY3RDaGFydCA9IGQzU2VsZWN0KGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpO1xuXHRcdH1cblxuXHRcdCQkLnNlbGVjdENoYXJ0Lmh0bWwoXCJcIikuY2xhc3NlZChiaW5kdG8uY2xhc3NuYW1lLCB0cnVlKTtcblxuXHRcdC8vIEluaXQgZGF0YSBhcyB0YXJnZXRzXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xuXHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpO1xuXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcihjb25maWcuZGF0YV9maWx0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0YXJnZXRzIHRvIGhpZGUgaWYgbmVlZGVkXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlblRhcmdldElkcyhcblx0XHRcdFx0Y29uZmlnLmRhdGFfaGlkZSA9PT0gdHJ1ZSA/XG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5kYXRhX2hpZGVcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGlmIChjb25maWcubGVnZW5kX2hpZGUpIHtcblx0XHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyhcblx0XHRcdFx0Y29uZmlnLmxlZ2VuZF9oaWRlID09PSB0cnVlID9cblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmxlZ2VuZF9oaWRlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gZ2F1Z2UsIGhpZGUgbGVnZW5kIC8vIFRPRE86IGZpeFxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgc2l6ZXMgYW5kIHNjYWxlc1xuXHRcdCQkLnVwZGF0ZVNpemVzKCk7XG5cdFx0JCQudXBkYXRlU2NhbGVzKHRydWUpO1xuXG5cdFx0Ly8gU2V0IGRvbWFpbnMgZm9yIGVhY2ggc2NhbGVcblx0XHRpZiAoJCQueCkge1xuXHRcdFx0JCQueC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xuXHRcdFx0JCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG5cblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXG5cdFx0XHQkJC5vcmdYRG9tYWluID0gJCQueC5kb21haW4oKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueSkge1xuXHRcdFx0JCQueS5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZLmRvbWFpbigkJC55LmRvbWFpbigpKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueTIpIHtcblx0XHRcdCQkLnkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQueTIuZG9tYWluKCkpO1xuXHRcdH1cblxuXHRcdC8vIC0tIEJhc2ljIEVsZW1lbnRzIC0tXG5cdFx0JCQuc3ZnID0gJCQuc2VsZWN0Q2hhcnQuYXBwZW5kKFwic3ZnXCIpXG5cdFx0XHQuc3R5bGUoXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKVxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLmlucHV0VHlwZSkge1xuXHRcdFx0Y29uc3QgaXNUb3VjaCA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xuXG5cdFx0XHQkJC5zdmdcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2VlbnRlclwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3ZlciwgJCQpKVxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2VsZWF2ZVwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3V0LCAkJCkpO1xuXHRcdH1cblxuXHRcdGNvbmZpZy5zdmdfY2xhc3NuYW1lICYmICQkLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xuXG5cdFx0Ly8gRGVmaW5lIGRlZnNcblx0XHQkJC5kZWZzID0gJCQuc3ZnLmFwcGVuZChcImRlZnNcIik7XG5cblx0XHQkJC5jbGlwQ2hhcnQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZCk7XG5cdFx0JCQuY2xpcFhBeGlzID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWRGb3JYQXhpcyk7XG5cdFx0JCQuY2xpcFlBeGlzID0gJCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCAkJC5jbGlwSWRGb3JZQXhpcyk7XG5cdFx0JCQuY2xpcEdyaWQgPSAkJC5hcHBlbmRDbGlwKCQkLmRlZnMsICQkLmNsaXBJZEZvckdyaWQpO1xuXG5cdFx0Ly8gc2V0IGNvbG9yIHBhdHRlcm5zXG5cdFx0aWYgKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucykge1xuXHRcdFx0JCQucGF0dGVybnMuZm9yRWFjaChwID0+ICQkLmRlZnMuYXBwZW5kKCgpID0+IHAubm9kZSkpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcblxuXHRcdC8vIERlZmluZSByZWdpb25zXG5cdFx0Y29uc3QgbWFpbiA9ICQkLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XG5cblx0XHQkJC5tYWluID0gbWFpbjtcblxuXHRcdC8vIGluaXRpYWxpemUgc3ViY2hhcnQgd2hlbiBzdWJjaGFydCBzaG93IG9wdGlvbiBpcyBzZXRcblx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5pbml0U3ViY2hhcnQoKTtcblxuXHRcdCQkLmluaXRUb29sdGlwICYmICQkLmluaXRUb29sdGlwKCk7XG5cdFx0JCQuaW5pdExlZ2VuZCAmJiAkJC5pbml0TGVnZW5kKCk7XG5cdFx0JCQuaW5pdFRpdGxlICYmICQkLmluaXRUaXRsZSgpO1xuXG5cdFx0Ly8gLS0gTWFpbiBSZWdpb24gLS1cblxuXHRcdC8vIHRleHQgd2hlbiBlbXB0eVxuXHRcdGlmIChjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0KSB7XG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy50ZXh0fSAke0NMQVNTLmVtcHR5fWApXG5cdFx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgLy8gaG9yaXpvbnRhbCBjZW50ZXJpbmcgb2YgdGV4dCBhdCB4IHBvc2l0aW9uIGluIGFsbCBicm93c2Vycy5cblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cblx0XHR9XG5cblx0XHQvLyBSZWdpb25zXG5cdFx0JCQuaW5pdFJlZ2lvbigpO1xuXG5cdFx0Ly8gQWRkIEF4aXMgaGVyZSwgd2hlbiBjbGlwUGF0aCBpcyAnZmFsc2UnXG5cdFx0IWNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcblxuXHRcdC8vIERlZmluZSBnIGZvciBjaGFydCBhcmVhXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydClcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKTtcblxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGluaXRcIik7XG5cblx0XHQvLyBDb3ZlciB3aG9sZSB3aXRoIHJlY3RzIGZvciBldmVudHNcblx0XHQkJC5pbml0RXZlbnRSZWN0KCk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnRcblx0XHQkJC5pbml0Q2hhcnRFbGVtZW50cygpO1xuXG5cdFx0Ly8gR3JpZHNcblx0XHQkJC5pbml0R3JpZCgpO1xuXG5cdFx0Ly8gaWYgem9vbSBwcml2aWxlZ2VkLCBpbnNlcnQgcmVjdCB0byBmb3JlZnJvbnRcblx0XHQvLyBUT0RPOiBpcyB0aGlzIG5lZWRlZD9cblx0XHRtYWluLmluc2VydChcInJlY3RcIiwgY29uZmlnLnpvb21fcHJpdmlsZWdlZCA/IG51bGwgOiBgZy4ke0NMQVNTLnJlZ2lvbnN9YClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbVJlY3QpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuaGVpZ2h0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XG5cblx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xuXHRcdGNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcblxuXHRcdC8vIFNldCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcblx0XHQkJC51cGRhdGVEaW1lbnNpb24oKTtcblxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xuXHRcdGNvbmZpZy5vbmluaXQuY2FsbCgkJCk7XG5cblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlLFxuXHRcdFx0aW5pdGlhbGl6aW5nOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyBkYXRhLm9ubWluL21heCBjYWxsYmFja1xuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4RGF0YSgpO1xuXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKTtcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1heCwgJCQsIG1pbk1heC5tYXgpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgcmVzaXplIGV2ZW50XG5cdFx0JCQuYmluZFJlc2l6ZSgpO1xuXG5cdFx0Ly8gZXhwb3J0IGVsZW1lbnQgb2YgdGhlIGNoYXJ0XG5cdFx0JCQuYXBpLmVsZW1lbnQgPSAkJC5zZWxlY3RDaGFydC5ub2RlKCk7XG5cdH1cblxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRbXCJCYXJcIiwgXCJSYWRhclwiLCBcIkxpbmVcIiwgXCJCdWJibGVcIiwgXCJBcmNcIiwgXCJHYXVnZVwiLCBcIlBpZVwiXS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0JCRbYGluaXQke3Z9YF0oKTtcblx0XHR9KTtcblxuXHRcdG5vdEVtcHR5KCQkLmNvbmZpZy5kYXRhX2xhYmVscykgJiYgJCQuaW5pdFRleHQoKTtcblx0fVxuXG5cdGdldENoYXJ0RWxlbWVudHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGNoYXJ0OiAkJC5zZWxlY3RDaGFydCxcblx0XHRcdHN2ZzogJCQuc3ZnLFxuXHRcdFx0ZGVmczogJCQuZGVmcyxcblx0XHRcdG1haW46ICQkLm1haW4sXG5cdFx0XHR0b29sdGlwOiAkJC50b29sdGlwLFxuXHRcdFx0bGVnZW5kOiAkJC5sZWdlbmQsXG5cdFx0XHR0aXRsZTogJCQudGl0bGUsXG5cdFx0XHRncmlkOiAkJC5ncmlkLFxuXHRcdFx0YXJjOiAkJC5hcmNzLFxuXHRcdFx0YmFyOiB7XG5cdFx0XHRcdGJhcnM6ICQkLm1haW5CYXJcblx0XHRcdH0sXG5cdFx0XHRsaW5lOiB7XG5cdFx0XHRcdGxpbmVzOiAkJC5tYWluTGluZSxcblx0XHRcdFx0YXJlYXM6ICQkLm1haW5BcmVhLFxuXHRcdFx0XHRjaXJjbGVzOiAkJC5tYWluQ2lyY2xlXG5cdFx0XHR9LFxuXHRcdFx0dGV4dDoge1xuXHRcdFx0XHR0ZXh0czogJCQubWFpblRleHRcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0c21vb3RoTGluZXMoZWwsIHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PT0gXCJncmlkXCIpIHtcblx0XHRcdGVsLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0Y29uc3QgW3gxLCB4MiwgeTEsIHkyXSA9IFtcIngxXCIsIFwieDJcIiwgXCJ5MVwiLCBcInkyXCJdXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IE1hdGguY2VpbChnLmF0dHIodikpKTtcblxuXHRcdFx0XHRnLmF0dHIoe3gxLCB4MiwgeTEsIHkyfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0IElmIGlzIGNhbGxlZCBhdCBpbml0aWFsaXphdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlU2l6ZXMoaXNJbml0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcblxuXHRcdGNvbnN0IGxlZ2VuZCA9IHtcblx0XHRcdHdpZHRoOiAkJC5sZWdlbmQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogJCQubGVnZW5kID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAwXG5cdFx0fTtcblxuXHRcdGNvbnN0IGxlZ2VuZEhlaWdodEZvckJvdHRvbSA9ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IDAgOiBsZWdlbmQuaGVpZ2h0O1xuXHRcdGNvbnN0IHhBeGlzSGVpZ2h0ID0gaXNSb3RhdGVkIHx8IGhhc0FyYyA/IDAgOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XG5cblx0XHRjb25zdCBzdWJjaGFydFhBeGlzSGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ICYmIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3cgP1xuXHRcdFx0eEF4aXNIZWlnaHQgOiAzMDtcblx0XHRjb25zdCBzdWJjaGFydEhlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICFoYXNBcmMgP1xuXHRcdFx0KGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCArIHN1YmNoYXJ0WEF4aXNIZWlnaHQpIDogMDtcblxuXHRcdCFpc0luaXQgJiYgJCQuc2V0Q29udGFpbmVyU2l6ZSgpO1xuXG5cdFx0Ly8gZm9yIG1haW5cblx0XHQkJC5tYXJnaW4gPSBpc1JvdGF0ZWQgPyB7XG5cdFx0XHR0b3A6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLFxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXG5cdFx0XHRib3R0b206ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieVwiKSArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXG5cdFx0XHRsZWZ0OiBzdWJjaGFydEhlaWdodCArIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkpXG5cdFx0fSA6IHtcblx0XHRcdHRvcDogNCArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksIC8vIGZvciB0b3AgdGljayB0ZXh0XG5cdFx0XHRyaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcblx0XHRcdGJvdHRvbTogeEF4aXNIZWlnaHQgKyBzdWJjaGFydEhlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXG5cdFx0XHRsZWZ0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KClcblx0XHR9O1xuXG5cdFx0Ly8gZm9yIHN1YmNoYXJ0XG5cdFx0JCQubWFyZ2luMiA9IGlzUm90YXRlZCA/IHtcblx0XHRcdHRvcDogJCQubWFyZ2luLnRvcCxcblx0XHRcdHJpZ2h0OiBOYU4sXG5cdFx0XHRib3R0b206IDIwICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuXHRcdFx0bGVmdDogJCQucm90YXRlZF9wYWRkaW5nX2xlZnRcblx0XHR9IDoge1xuXHRcdFx0dG9wOiAkJC5jdXJyZW50SGVpZ2h0IC0gc3ViY2hhcnRIZWlnaHQgLSBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxuXHRcdFx0bGVmdDogJCQubWFyZ2luLmxlZnRcblx0XHR9O1xuXG5cdFx0Ly8gZm9yIGxlZ2VuZFxuXHRcdCQkLm1hcmdpbjMgPSB7XG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogMFxuXHRcdH07XG5cblx0XHQkJC51cGRhdGVTaXplRm9yTGVnZW5kICYmICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQobGVnZW5kKTtcblxuXHRcdCQkLndpZHRoID0gJCQuY3VycmVudFdpZHRoIC0gJCQubWFyZ2luLmxlZnQgLSAkJC5tYXJnaW4ucmlnaHQ7XG5cdFx0JCQuaGVpZ2h0ID0gJCQuY3VycmVudEhlaWdodCAtICQkLm1hcmdpbi50b3AgLSAkJC5tYXJnaW4uYm90dG9tO1xuXG5cdFx0aWYgKCQkLndpZHRoIDwgMCkge1xuXHRcdFx0JCQud2lkdGggPSAwO1xuXHRcdH1cblxuXHRcdGlmICgkJC5oZWlnaHQgPCAwKSB7XG5cdFx0XHQkJC5oZWlnaHQgPSAwO1xuXHRcdH1cblxuXHRcdCQkLndpZHRoMiA9IGlzUm90YXRlZCA/XG5cdFx0XHQkJC5tYXJnaW4ubGVmdCAtICQkLnJvdGF0ZWRfcGFkZGluZ19sZWZ0IC0gJCQucm90YXRlZF9wYWRkaW5nX3JpZ2h0IDogJCQud2lkdGg7XG5cblx0XHQkJC5oZWlnaHQyID0gaXNSb3RhdGVkID9cblx0XHRcdCQkLmhlaWdodCA6ICQkLmN1cnJlbnRIZWlnaHQgLSAkJC5tYXJnaW4yLnRvcCAtICQkLm1hcmdpbjIuYm90dG9tO1xuXG5cdFx0aWYgKCQkLndpZHRoMiA8IDApIHtcblx0XHRcdCQkLndpZHRoMiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmhlaWdodDIgPCAwKSB7XG5cdFx0XHQkJC5oZWlnaHQyID0gMDtcblx0XHR9XG5cblx0XHQvLyBmb3IgYXJjXG5cdFx0JCQuYXJjV2lkdGggPSAkJC53aWR0aCAtICgkJC5pc0xlZ2VuZFJpZ2h0ID8gbGVnZW5kLndpZHRoICsgMTAgOiAwKTtcblx0XHQkJC5hcmNIZWlnaHQgPSAkJC5oZWlnaHQgLSAoJCQuaXNMZWdlbmRSaWdodCA/IDAgOiAxMCk7XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSkge1xuXHRcdFx0JCQuYXJjSGVpZ2h0ICs9ICQkLmhlaWdodCAtICQkLmdldEdhdWdlTGFiZWxIZWlnaHQoKTtcblx0XHR9XG5cblx0XHQkJC51cGRhdGVSYWRpdXMgJiYgJCQudXBkYXRlUmFkaXVzKCk7XG5cblx0XHRpZiAoJCQuaXNMZWdlbmRSaWdodCAmJiBoYXNBcmMpIHtcblx0XHRcdCQkLm1hcmdpbjMubGVmdCA9ICQkLmFyY1dpZHRoIC8gMiArICQkLnJhZGl1c0V4cGFuZGVkICogMS4xO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGFyZ2V0ZWQgZWxlbWVudCB3aXRoIGdpdmVuIGRhdGFcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHMgRGF0YSBvYmplY3QgZm9ybWF0dGVkIGFzICd0YXJnZXQnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVUYXJnZXRzKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQvLyBUZXh0XG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XG5cblx0XHQvLyBCYXJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpO1xuXG5cdFx0Ly8gTGluZVxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpO1xuXG5cdFx0Ly8gQXJjICYgUmFkYXJcblx0XHQkJC5oYXNBcmNUeXBlKHRhcmdldHMpICYmIChcblx0XHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSA/XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cylcblx0XHQpO1xuXG5cdFx0Ly8gU3ViIENoYXJ0XG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0ICYmXG5cdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQodGFyZ2V0cyk7XG5cblx0XHQvLyBGYWRlLWluIGVhY2ggY2hhcnRcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3BsYXkgdGFyZ2V0ZWQgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNob3dUYXJnZXRzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxuXHRcdFx0LmZpbHRlcihkID0+ICQkLmlzVGFyZ2V0VG9TaG93KGQuaWQpKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKCQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH1cblxuXHRnZXRXaXRoT3B0aW9uKG9wdGlvbnMpIHtcblx0XHRjb25zdCB3aXRoT3B0aW9ucyA9IHtcblx0XHRcdFk6IHRydWUsXG5cdFx0XHRTdWJjaGFydDogdHJ1ZSxcblx0XHRcdFRyYW5zaXRpb246IHRydWUsXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXG5cdFx0XHREaW1lbnNpb246IHRydWUsXG5cdFx0XHRUcmltWERvbWFpbjogdHJ1ZSxcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHRVcGRhdGVYRG9tYWluOiBmYWxzZSxcblx0XHRcdFVwZGF0ZU9yZ1hEb21haW46IGZhbHNlLFxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcblx0XHRcdFVwZGF0ZVhBeGlzOiBcIlVwZGF0ZVhEb21haW5cIixcblx0XHRcdFRyYW5zaXRpb25Gb3JFeGl0OiBcIlRyYW5zaXRpb25cIixcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxuXHRcdH07XG5cblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0bGV0IGRlZlZhbCA9IHdpdGhPcHRpb25zW2tleV07XG5cblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XG5cdFx0XHRcdGRlZlZhbCA9IHdpdGhPcHRpb25zW2RlZlZhbF07XG5cdFx0XHR9XG5cblx0XHRcdHdpdGhPcHRpb25zW2tleV0gPSBnZXRPcHRpb24ob3B0aW9ucywgYHdpdGgke2tleX1gLCBkZWZWYWwpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHdpdGhPcHRpb25zO1xuXHR9XG5cblx0cmVkcmF3KG9wdGlvbnMgPSB7fSwgdHJhbnNpdGlvbnNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xuXHRcdGNvbnN0IGZsb3cgPSBvcHRpb25zLmZsb3c7XG5cdFx0Y29uc3Qgd3RoID0gJCQuZ2V0V2l0aE9wdGlvbihvcHRpb25zKTtcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xuXHRcdGNvbnN0IGR1cmF0aW9uRm9yRXhpdCA9IHd0aC5UcmFuc2l0aW9uRm9yRXhpdCA/IGR1cmF0aW9uIDogMDtcblx0XHRjb25zdCBkdXJhdGlvbkZvckF4aXMgPSB3dGguVHJhbnNpdGlvbkZvckF4aXMgPyBkdXJhdGlvbiA6IDA7XG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpO1xuXG5cdFx0IShpbml0aWFsaXppbmcgJiYgY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSAmJlxuXHRcdFx0JCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcblxuXHRcdCQkLnVwZGF0ZVNpemVzKGluaXRpYWxpemluZyk7XG5cblx0XHQvLyB1cGRhdGUgbGVnZW5kIGFuZCB0cmFuc2Zvcm0gZWFjaCBnXG5cblx0XHRpZiAod3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpIHtcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZCgkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCBvcHRpb25zLCB0cmFuc2l0aW9ucyk7XG5cdFx0fSBlbHNlIGlmICh3dGguRGltZW5zaW9uKSB7XG5cdFx0XHQvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxuXHRcdFx0Ly8gbm8gbmVlZCB0byB1cGRhdGUgYXhpcyBpbiBpdCBiZWNhdXNlIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGluIHJlZHJhdygpXG5cdFx0XHQkJC51cGRhdGVEaW1lbnNpb24odHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGF4aXNcblx0XHQvLyBAVE9ETzogTWFrZSAnaW5pdCcgc3RhdGUgdG8gYmUgYWNjZXNzaWJsZSBldmVyeXdoZXJlIG5vdCBwYXNzaW5nIGFzIGFyZ3VtZW50LlxuXHRcdCQkLnJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaW5pdGlhbGl6aW5nKTtcblxuXHRcdC8vIHVwZGF0ZSBjaXJjbGVZIGJhc2VkIG9uIHVwZGF0ZWQgcGFyYW1ldGVyc1xuXHRcdCQkLnVwZGF0ZUNpcmNsZVkoKTtcblxuXHRcdC8vIHhncmlkIGZvY3VzXG5cdFx0JCQudXBkYXRlWGdyaWRGb2N1cygpO1xuXG5cdFx0Ly8gRGF0YSBlbXB0eSBsYWJlbCBwb3NpdGlvbmluZyBhbmQgdGV4dC5cblx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLndpZHRoIC8gMilcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5oZWlnaHQgLyAyKVxuXHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyBcIm5vbmVcIiA6IG51bGwpO1xuXG5cdFx0Ly8gZ3JpZFxuXHRcdCQkLnVwZGF0ZUdyaWQoZHVyYXRpb24pO1xuXG5cdFx0Ly8gcmVjdCBmb3IgcmVnaW9uc1xuXHRcdCQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XG5cblx0XHQvLyBiYXJzXG5cdFx0JCQudXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcblx0XHQkJC51cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk7XG5cdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xuXHRcdCQkLnVwZGF0ZUNpcmNsZSgpO1xuXG5cdFx0Ly8gdGV4dFxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcblxuXHRcdC8vIHRpdGxlXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcblxuXHRcdC8vIGFyY1xuXHRcdCQkLmFyY3MgJiYgJCQucmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHd0aC5UcmFuc2Zvcm0pO1xuXG5cdFx0Ly8gcmFkYXJcblx0XHQkJC5yYWRhcnMgJiYgJCQucmVkcmF3UmFkYXIoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XG5cblx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3Rcblx0XHQkJC5tYWluVGV4dCAmJiBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfWApXG5cdFx0XHQuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSlcblx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdC8vIGV2ZW50IHJlY3RzIHdpbGwgcmVkcmF3biB3aGVuIGZsb3cgY2FsbGVkXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICFmbG93ICYmIHd0aC5FdmVudFJlY3QpIHtcblx0XHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xuXHRcdH1cblxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRyZWRyYXdcIiwgb3B0aW9ucywgZHVyYXRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZHJhdyBheGlzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzVG9TaG93IHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxuXHQgKiBAcGFyYW0ge09iamVjdH0gd3RoXG5cdCAqIEBwYXJhbSB7T2piZWN0fSB0cmFuc2l0aW9uc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZmxvd1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpc0luaXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGhhc0FyY1R5cGUgPSAkJC5oYXNBcmNUeXBlKCk7XG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhJCQuem9vbVNjYWxlO1xuXHRcdGxldCB0aWNrVmFsdWVzO1xuXHRcdGxldCBpbnRlcnZhbEZvckN1bGxpbmc7XG5cdFx0bGV0IHhEb21haW5Gb3Jab29tO1xuXG5cdFx0aWYgKCFoYXNab29tICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0JCQueC5kb21haW4oWzAsICQkLmF4ZXMueC5zZWxlY3RBbGwoXCIudGlja1wiKS5zaXplKCldKTtcblx0XHR9XG5cblx0XHRpZiAoJCQueCAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xuXHRcdFx0IWhhc1pvb20gJiZcblx0XHRcdFx0JCQudXBkYXRlWERvbWFpbih0YXJnZXRzVG9TaG93LCB3dGguVXBkYXRlWERvbWFpbiwgd3RoLlVwZGF0ZU9yZ1hEb21haW4sIHd0aC5UcmltWERvbWFpbik7XG5cblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xuXHRcdFx0XHR0aWNrVmFsdWVzID0gJCQuYXhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICgkJC54QXhpcykge1xuXHRcdFx0JCQueEF4aXMudGlja1ZhbHVlcyhbXSk7XG5cdFx0XHQkJC5zdWJYQXhpcy50aWNrVmFsdWVzKFtdKTtcblx0XHR9XG5cblx0XHRpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhZmxvdykge1xuXHRcdFx0eERvbWFpbkZvclpvb20gPSAkJC54Lm9yZ0RvbWFpbigpO1xuXHRcdH1cblxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRjb25zdCBheGlzID0gJCRba2V5XTtcblxuXHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcblx0XHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX2NvdW50YF07XG5cblx0XHRcdFx0YXhpcy5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBrZXksIHhEb21haW5Gb3Jab29tKSk7XG5cblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXMuZG9tYWluKCk7XG5cblx0XHRcdFx0XHQkJFtgJHtrZXl9QXhpc2BdLnRpY2tWYWx1ZXMoXG5cdFx0XHRcdFx0XHQkJC5heGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcblx0XHRcdFx0XHRcdFx0ZG9tYWluLFxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXG5cdFx0XHRcdFx0XHRcdCQkLmlzVGltZVNlcmllc1koKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGF4ZXNcblx0XHQkJC5heGlzLnJlZHJhdyh0cmFuc2l0aW9ucywgaGFzQXJjVHlwZSwgaXNJbml0KTtcblxuXHRcdC8vIFVwZGF0ZSBheGlzIGxhYmVsXG5cdFx0JCQuYXhpcy51cGRhdGVMYWJlbHMod3RoLlRyYW5zaXRpb24pO1xuXG5cdFx0Ly8gc2hvdy9oaWRlIGlmIG1hbnVhbCBjdWxsaW5nIG5lZWRlZFxuXHRcdGlmICgod3RoLlVwZGF0ZVhEb21haW4gfHwgd3RoLlVwZGF0ZVhBeGlzKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmIHRpY2tWYWx1ZXMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRpY2tWYWx1ZXMubGVuZ3RoIC8gaSA8IGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nX21heCkge1xuXHRcdFx0XHRcdFx0aW50ZXJ2YWxGb3JDdWxsaW5nID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLmF4aXNYfSAudGljayB0ZXh0YCkuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSB0aWNrVmFsdWVzLmluZGV4T2YoZCk7XG5cblx0XHRcdFx0XHRpbmRleCA+PSAwICYmXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zdHlsZShcImRpc3BsYXlcIiwgaW5kZXggJSBpbnRlcnZhbEZvckN1bGxpbmcgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQuc3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXhpc1h9IC50aWNrIHRleHRgKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgc3ViIGRvbWFpblxuXHRcdGlmICh3dGguWSkge1xuXHRcdFx0JCQuc3ViWSAmJiAkJC5zdWJZLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieVwiKSk7XG5cdFx0XHQkJC5zdWJZMiAmJiAkJC5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInkyXCIpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgcmVkcmF3IGxpc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNUb1Nob3cgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmbG93XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkdXJhdGlvblxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0c1RvU2hvdywgZmxvdywgZHVyYXRpb24sIHdpdGhTdWJjaGFydCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcblxuXHRcdC8vIHN1YmNoYXJ0XG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQucmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZmxvd1xuXHRcdGNvbnN0IGZsb3dGbiA9IGZsb3cgJiYgJCQuZ2VuZXJhdGVGbG93KHtcblx0XHRcdHRhcmdldHM6IHRhcmdldHNUb1Nob3csXG5cdFx0XHRmbG93OiBmbG93LFxuXHRcdFx0ZHVyYXRpb246IGZsb3cuZHVyYXRpb24sXG5cdFx0XHRzaGFwZSxcblx0XHRcdHh2OiAkJC54di5iaW5kKCQkKVxuXHRcdH0pO1xuXHRcdGNvbnN0IGlzVHJhbnNpdGlvbiA9IChkdXJhdGlvbiB8fCBmbG93Rm4pICYmICQkLmlzVGFiVmlzaWJsZSgpO1xuXG5cdFx0Ly8gcmVkcmF3IGxpc3Rcblx0XHRjb25zdCByZWRyYXdMaXN0ID0gJCQuZ2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pO1xuXG5cdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gYWZ0ZXIgcmVkcmF3IGVuZHNcblx0XHRjb25zdCBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyAoKSA9PiB7XG5cdFx0XHRmbG93Rm4gJiYgZmxvd0ZuKCk7XG5cdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkKTtcblx0XHR9IDogbnVsbDtcblxuXHRcdGlmIChhZnRlclJlZHJhdykge1xuXHRcdFx0Ly8gT25seSB1c2UgdHJhbnNpdGlvbiB3aGVuIGN1cnJlbnQgdGFiIGlzIHZpc2libGUuXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdC8vIFdhaXQgZm9yIGVuZCBvZiB0cmFuc2l0aW9ucyBmb3IgY2FsbGJhY2tcblx0XHRcdFx0Y29uc3Qgd2FpdEZvckRyYXcgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcblxuXHRcdFx0XHQvLyB0cmFuc2l0aW9uIHNob3VsZCBiZSBkZXJpdmVkIGZyb20gb25lIHRyYW5zaXRpb25cblx0XHRcdFx0ZDNUcmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0cmVkcmF3TGlzdFxuXHRcdFx0XHRcdFx0XHQucmVkdWNlKChhY2MsIHQxKSA9PiBhY2MuY29uY2F0KHQxKSwgW10pXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5jYWxsKHdhaXRGb3JEcmF3LCBhZnRlclJlZHJhdyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZnRlclJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXG5cdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdCQkLndpdGhvdXRGYWRlSW5baWRdID0gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNoYXBlIGRyYXcgZnVuY3Rpb25cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0RHJhd1NoYXBlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGhhc1JhZGFyID0gJCQuaGFzVHlwZShcInJhZGFyXCIpO1xuXHRcdGNvbnN0IHNoYXBlID0ge3R5cGU6IHt9LCBpbmRpY2VzOiB7fX07XG5cblx0XHQvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcblx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSB8fCAkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpKSB7XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpO1xuXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmxpbmUgPSBpbmRpY2VzO1xuXHRcdFx0c2hhcGUudHlwZS5saW5lID0gJCQuZ2VuZXJhdGVEcmF3TGluZSA/ICQkLmdlbmVyYXRlRHJhd0xpbmUoaW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQXJlYVR5cGUpO1xuXG5cdFx0XHRcdHNoYXBlLmluZGljZXMuYXJlYSA9IGluZGljZXM7XG5cdFx0XHRcdHNoYXBlLnR5cGUuYXJlYSA9ICQkLmdlbmVyYXRlRHJhd0FyZWEgPyAkJC5nZW5lcmF0ZURyYXdBcmVhKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0JhclR5cGUpO1xuXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmJhciA9IGluZGljZXM7XG5cdFx0XHRzaGFwZS50eXBlLmJhciA9ICQkLmdlbmVyYXRlRHJhd0JhciA/ICQkLmdlbmVyYXRlRHJhd0JhcihpbmRpY2VzKSA6IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRzaGFwZS5wb3MgPSB7XG5cdFx0XHR4Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgdHJ1ZSksXG5cdFx0XHR5Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgZmFsc2UpLFxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBjaXJjbGUgeC95IGZ1bmN0aW9ucyBkZXBlbmRpbmcgb24gdXBkYXRlZCBwYXJhbXNcblx0XHRcdGN4OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVggOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpKS5iaW5kKCQkKSxcblx0XHRcdGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpKS5iaW5kKCQkKVxuXHRcdH07XG5cblx0XHRyZXR1cm4gc2hhcGU7XG5cdH1cblxuXHRnZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaGFzQXJjVHlwZSA9ICQkLmhhc0FyY1R5cGUoKTtcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xuXHRcdGNvbnN0IGxpc3QgPSBbXTtcblxuXHRcdGlmICghaGFzQXJjVHlwZSkge1xuXHRcdFx0Y29uc3Qge2FyZWEsIGJhciwgbGluZX0gPSBzaGFwZS50eXBlO1xuXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0dyaWQoaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25maWcucmVnaW9ucy5sZW5ndGgpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1JlZ2lvbihpc1RyYW5zaXRpb24pKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikpIHtcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0JhcihiYXIsIGlzVHJhbnNpdGlvbikpO1xuXG5cdFx0XHRub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpICYmXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdUZXh0KHhGb3JUZXh0LCB5Rm9yVGV4dCwgZmxvdywgaXNUcmFuc2l0aW9uKSk7XG5cdFx0fVxuXG5cdFx0KCFoYXNBcmNUeXBlIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKSkgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0NpcmNsZShjeCwgY3ksIGlzVHJhbnNpdGlvbiwgZmxvd0ZuKSk7XG5cblx0XHRyZXR1cm4gbGlzdDtcblx0fVxuXG5cdHVwZGF0ZUFuZFJlZHJhdyhvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCB0cmFuc2l0aW9ucztcblxuXHRcdC8vIHNhbWUgd2l0aCByZWRyYXdcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XG5cdFx0b3B0aW9ucy53aXRoVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zZm9ybVwiLCBmYWxzZSk7XG5cdFx0b3B0aW9ucy53aXRoTGVnZW5kID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aExlZ2VuZFwiLCBmYWxzZSk7XG5cblx0XHQvLyBOT1Qgc2FtZSB3aXRoIHJlZHJhd1xuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZVhEb21haW4gPSB0cnVlO1xuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZU9yZ1hEb21haW4gPSB0cnVlO1xuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JFeGl0ID0gZmFsc2U7XG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIG9wdGlvbnMud2l0aFRyYW5zaXRpb24pO1xuXG5cdFx0Ly8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxuXHRcdGlmICghKG9wdGlvbnMud2l0aExlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpKSB7XG5cdFx0XHR0cmFuc2l0aW9ucyA9ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhcblx0XHRcdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvckF4aXMgPyBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiA6IDBcblx0XHRcdCk7XG5cblx0XHRcdC8vIFVwZGF0ZSBzY2FsZXNcblx0XHRcdCQkLnVwZGF0ZVNjYWxlcygpO1xuXHRcdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcblx0XHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xuXHRcdCQkLnJlZHJhdyhvcHRpb25zLCB0cmFuc2l0aW9ucyk7XG5cdH1cblxuXHRyZWRyYXdXaXRob3V0UmVzY2FsZSgpIHtcblx0XHR0aGlzLnJlZHJhdyh7XG5cdFx0XHR3aXRoWTogZmFsc2UsXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRpc1RpbWVTZXJpZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlID09PSBcInRpbWVzZXJpZXNcIjtcblx0fVxuXG5cdGlzQ2F0ZWdvcml6ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlLmluZGV4T2YoXCJjYXRlZ29yeVwiKSA+PSAwIHx8IHRoaXMuaGFzVHlwZShcInJhZGFyXCIpO1xuXHR9XG5cblx0aXNDdXN0b21YKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gISQkLmlzVGltZVNlcmllcygpICYmIChjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSk7XG5cdH1cblxuXHRpc1RpbWVTZXJpZXNZKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3lfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XG5cdH1cblxuXHRnZXRUcmFuc2xhdGUodGFyZ2V0LCBpbmRleCA9IDApIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHBhZGRpbmcgPSAwO1xuXHRcdGxldCB4O1xuXHRcdGxldCB5O1xuXG5cdFx0aWYgKGluZGV4ICYmIC9eKHh8eTI/KSQvLnRlc3QodGFyZ2V0KSkge1xuXHRcdFx0cGFkZGluZyA9ICQkLmdldEF4aXNTaXplKHRhcmdldCkgKiBpbmRleDtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ID09PSBcIm1haW5cIikge1xuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbi5sZWZ0KTtcblx0XHRcdHkgPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4udG9wKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJjb250ZXh0XCIpIHtcblx0XHRcdHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4yLmxlZnQpO1xuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbjIudG9wKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJsZWdlbmRcIikge1xuXHRcdFx0eCA9ICQkLm1hcmdpbjMubGVmdDtcblx0XHRcdHkgPSAkJC5tYXJnaW4zLnRvcDtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ4XCIpIHtcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAtcGFkZGluZyA6IDA7XG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodCArIHBhZGRpbmc7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieVwiKSB7XG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IC1wYWRkaW5nO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/ICQkLmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInkyXCIpIHtcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogJCQud2lkdGggKyBwYWRkaW5nO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJzdWJ4XCIpIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcImFyY1wiKSB7XG5cdFx0XHR4ID0gJCQuYXJjV2lkdGggLyAyO1xuXHRcdFx0eSA9ICQkLmFyY0hlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwicmFkYXJcIikge1xuXHRcdFx0Y29uc3QgW3dpZHRoXSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXG5cdFx0XHR4ID0gJCQud2lkdGggLyAyIC0gd2lkdGg7XG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoJCQubWFyZ2luLnRvcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgO1xuXHR9XG5cblx0aW5pdGlhbE9wYWNpdHkoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCAmJlxuXHRcdFx0dGhpcy53aXRob3V0RmFkZUluW2QuaWRdID8gXCIxXCIgOiBcIjBcIjtcblx0fVxuXG5cdGluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcblx0XHRcdHRoaXMud2l0aG91dEZhZGVJbltkLmlkXSA/IHRoaXMub3BhY2l0eUZvckNpcmNsZShkKSA6IFwiMFwiO1xuXHR9XG5cblx0b3BhY2l0eUZvckNpcmNsZShkKSB7XG5cdFx0Y29uc3Qgb3BhY2l0eSA9IHRoaXMuY29uZmlnLnBvaW50X3Nob3cgPyBcIjFcIiA6IFwiMFwiO1xuXG5cdFx0cmV0dXJuIGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpID9cblx0XHRcdCh0aGlzLmlzQnViYmxlVHlwZShkKSB8fCB0aGlzLmlzU2NhdHRlclR5cGUoZCkgP1xuXHRcdFx0XHRcIjAuNVwiIDogb3BhY2l0eSkgOiBcIjBcIjtcblx0fVxuXG5cdG9wYWNpdHlGb3JUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLmhhc0RhdGFMYWJlbCgpID8gXCIxXCIgOiBcIjBcIjtcblx0fVxuXG5cdHh4KGQpIHtcblx0XHRjb25zdCBmbiA9IHRoaXMuY29uZmlnLnpvb21fZW5hYmxlZCAmJiB0aGlzLnpvb21TY2FsZSA/XG5cdFx0XHR0aGlzLnpvb21TY2FsZSA6IHRoaXMueDtcblxuXHRcdHJldHVybiBkID8gZm4oZC54KSA6IG51bGw7XG5cdH1cblxuXHR4dihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCB2YWx1ZSA9ICQkLmdldEJhc2VWYWx1ZShkKTtcblxuXHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0dmFsdWUgPSAkJC5wYXJzZURhdGUodmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNDYXRlZ29yaXplZCgpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSAkJC5jb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGguY2VpbCgkJC54KHZhbHVlKSk7XG5cdH1cblxuXHR5dihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHlTY2FsZSA9IGQuYXhpcyAmJiBkLmF4aXMgPT09IFwieTJcIiA/ICQkLnkyIDogJCQueTtcblxuXHRcdHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xuXHR9XG5cblx0c3VieHgoZCkge1xuXHRcdHJldHVybiBkID8gdGhpcy5zdWJYKGQueCkgOiBudWxsO1xuXHR9XG5cblx0dHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHhBeGlzO1xuXHRcdGxldCB5QXhpcztcblx0XHRsZXQgeTJBeGlzO1xuXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNYKSB7XG5cdFx0XHR4QXhpcyA9IHRyYW5zaXRpb25zLmF4aXNYO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4QXhpcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKTtcblxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHhBeGlzID0geEF4aXMudHJhbnNpdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWSkge1xuXHRcdFx0eUF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eUF4aXMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1l9YCk7XG5cblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xuXHRcdFx0XHR5QXhpcyA9IHlBeGlzLnRyYW5zaXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyKSB7XG5cdFx0XHR5MkF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHkyQXhpcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9YCk7XG5cblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xuXHRcdFx0XHR5MkF4aXMgPSB5MkF4aXMudHJhbnNpdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLm1haW4udHJhbnNpdGlvbigpIDogJCQubWFpbilcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcIm1haW5cIikpO1xuXG5cdFx0eEF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ4XCIpKTtcblx0XHR5QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInlcIikpO1xuXHRcdHkyQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInkyXCIpKTtcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3N9YClcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XG5cdH1cblxuXHR0cmFuc2Zvcm1BbGwod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQudHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xuXG5cdFx0JCQuY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiZcblx0XHRcdCQkLnRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcblxuXHRcdCQkLmxlZ2VuZCAmJiAkJC50cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pO1xuXHR9XG5cblx0dXBkYXRlU3ZnU2l6ZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYnJ1c2ggPSAkJC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH0gLm92ZXJsYXlgKTtcblx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG5cblx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XG5cdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xuXHRcdFx0YnJ1c2hTaXplLmhlaWdodCA9ICticnVzaC5hdHRyKFwiaGVpZ2h0XCIpO1xuXHRcdH1cblxuXHRcdCQkLnN2Z1xuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5jdXJyZW50V2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5jdXJyZW50SGVpZ2h0KTtcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoW2AjJHskJC5jbGlwSWR9YCwgYCMkeyQkLmNsaXBJZEZvckdyaWR9YF0pXG5cdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodCk7XG5cblx0XHQkJC5zdmcuc2VsZWN0KGAjJHskJC5jbGlwSWRGb3JYQXhpc31gKVxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwieFwiLCAkJC5nZXRYQXhpc0NsaXBYLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFhBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0WEF4aXNDbGlwSGVpZ2h0LmJpbmQoJCQpKTtcblxuXHRcdCQkLnN2Zy5zZWxlY3QoYCMkeyQkLmNsaXBJZEZvcllBeGlzfWApXG5cdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFlBeGlzQ2xpcFguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQuZ2V0WUF4aXNDbGlwV2lkdGguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRZQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgIyR7JCQuY2xpcElkRm9yU3ViY2hhcnR9YClcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgYnJ1c2hTaXplLmhlaWdodCk7XG5cblx0XHQkJC5zdmcuc2VsZWN0KGAuJHtDTEFTUy56b29tUmVjdH1gKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmhlaWdodCk7XG5cdH1cblxuXHR1cGRhdGVEaW1lbnNpb24od2l0aG91dEF4aXMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoIXdpdGhvdXRBeGlzKSB7XG5cdFx0XHRpZiAoJCQueEF4aXMgJiYgJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0XHQkJC54QXhpcy5jcmVhdGUoJCQuYXhlcy54KTtcblx0XHRcdFx0JCQuc3ViWEF4aXMuY3JlYXRlKCQkLmF4ZXMuc3VieCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkJC55QXhpcyAmJiAkJC55QXhpcy5jcmVhdGUoJCQuYXhlcy55KTtcblx0XHRcdFx0JCQueTJBeGlzICYmICQkLnkyQXhpcy5jcmVhdGUoJCQuYXhlcy55Mik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFzcyAnd2l0aG91dEF4aXMnIHBhcmFtIHRvIG5vdCBhbmltYXRlIGF0IHRoZSBpbml0IHJlbmRlcmluZ1xuXHRcdCQkLnVwZGF0ZVNjYWxlcyh3aXRob3V0QXhpcyk7XG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xuXHRcdCQkLnRyYW5zZm9ybUFsbChmYWxzZSk7XG5cdH1cblxuXHRiaW5kUmVzaXplKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQkJC5yZXNpemVGdW5jdGlvbiA9ICQkLmdlbmVyYXRlUmVzaXplKCk7XG5cdFx0JCQucmVzaXplRnVuY3Rpb24uYWRkKGNvbmZpZy5vbnJlc2l6ZS5iaW5kKCQkKSk7XG5cblx0XHRpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4ge1xuXHRcdFx0XHRpZiAoJCQucmVzaXplVGltZW91dCkge1xuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XG5cdFx0XHRcdFx0JCQucmVzaXplVGltZW91dCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdCQkLmFwaS5mbHVzaChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH0sIDIwMCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJC5yZXNpemVGdW5jdGlvbi5hZGQoY29uZmlnLm9ucmVzaXplZC5iaW5kKCQkKSk7XG5cblx0XHQvLyBhdHRhY2ggcmVzaXplIGV2ZW50XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xuXHR9XG5cblx0Z2VuZXJhdGVSZXNpemUoKSB7XG5cdFx0Y29uc3QgcmVzaXplRnVuY3Rpb25zID0gW107XG5cblx0XHRmdW5jdGlvbiBjYWxsUmVzaXplRnVuY3Rpb25zKCkge1xuXHRcdFx0cmVzaXplRnVuY3Rpb25zLmZvckVhY2goZiA9PiBmKCkpO1xuXHRcdH1cblxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMuYWRkID0gZiA9PiByZXNpemVGdW5jdGlvbnMucHVzaChmKTtcblx0XHRjYWxsUmVzaXplRnVuY3Rpb25zLnJlbW92ZSA9IGYgPT4gcmVzaXplRnVuY3Rpb25zLnNwbGljZShyZXNpemVGdW5jdGlvbnMuaW5kZXhPZihmKSwgMSk7XG5cblx0XHRyZXR1cm4gY2FsbFJlc2l6ZUZ1bmN0aW9ucztcblx0fVxuXG5cdGVuZGFsbCh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuXHRcdGxldCBuID0gMDtcblxuXHRcdHRyYW5zaXRpb25cblx0XHRcdC5lYWNoKCgpID0+ICsrbilcblx0XHRcdC5vbihcImVuZFwiLCBmdW5jdGlvbiguLi5hcmdzKSB7XG5cdFx0XHRcdCEtLW4gJiYgY2FsbGJhY2suYXBwbHkodGhpcywgLi4uYXJncyk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGdlbmVyYXRlV2FpdCgpIHtcblx0XHRsZXQgdHJhbnNpdGlvbnNUb1dhaXQgPSBbXTtcblx0XHRjb25zdCBmID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcblx0XHRcdGxldCB0aW1lcjtcblxuXHRcdFx0ZnVuY3Rpb24gbG9vcCgpIHtcblx0XHRcdFx0bGV0IGRvbmUgPSAwO1xuXG5cdFx0XHRcdHRyYW5zaXRpb25zVG9XYWl0LmZvckVhY2godCA9PiB7XG5cdFx0XHRcdFx0aWYgKHQuZW1wdHkoKSkge1xuXHRcdFx0XHRcdFx0ZG9uZSsrO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR0LnRyYW5zaXRpb24oKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRkb25lKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdFx0XHRcdGlmIChkb25lID09PSB0cmFuc2l0aW9uc1RvV2FpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChsb29wLCA1MCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bG9vcCgpO1xuXHRcdH07XG5cblx0XHRmLmFkZCA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcblx0XHRcdGlzQXJyYXkodHJhbnNpdGlvbikgP1xuXHRcdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodHJhbnNpdGlvbikpIDpcblx0XHRcdFx0dHJhbnNpdGlvbnNUb1dhaXQucHVzaCh0cmFuc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGY7XG5cdH1cblxuXHRwYXJzZURhdGUoZGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgcGFyc2VkRGF0ZTtcblxuXHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0cGFyc2VkRGF0ZSA9IGRhdGU7XG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhkYXRlKSkge1xuXHRcdFx0cGFyc2VkRGF0ZSA9ICQkLmRhdGFUaW1lRm9ybWF0KCQkLmNvbmZpZy5kYXRhX3hGb3JtYXQpKGRhdGUpO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoZGF0ZSkgJiYgIWlzTmFOKGRhdGUpKSB7XG5cdFx0XHRwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuXHRcdH1cblxuXHRcdGlmICghcGFyc2VkRGF0ZSB8fCBpc05hTigrcGFyc2VkRGF0ZSkpIHtcblx0XHRcdGNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcGFyc2UgeCAnJHtkYXRlfScgdG8gRGF0ZSBvYmplY3RgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VkRGF0ZTtcblx0fVxuXG5cdGlzVGFiVmlzaWJsZSgpIHtcblx0XHRyZXR1cm4gIWRvY3VtZW50LmhpZGRlbjtcblx0fVxuXG5cdGNvbnZlcnRJbnB1dFR5cGUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc01vYmlsZSA9IChcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IgJiYgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDBcblx0XHQpIHx8IGZhbHNlO1xuXG5cdFx0Y29uc3QgaGFzTW91c2UgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xuXHRcdGxldCBoYXNUb3VjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2gpIHtcblx0XHRcdC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzXG5cdFx0XHQvLyBPbiBJRTExIHdpdGggSUU5IGVtdWxhdGlvbiBtb2RlLCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSBpcyByZXR1cm5pbmcgdHJ1ZVxuXHRcdFx0aGFzVG91Y2ggPSAoXCJvbnRvdWNobW92ZVwiIGluIHdpbmRvdykgfHwgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoaGFzTW91c2UgJiYgXCJtb3VzZVwiKSB8fCAoaGFzVG91Y2ggJiYgXCJ0b3VjaFwiKSB8fCBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGwgcGx1Z2luIGhvb2tcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBoYXNlIFRoZSBsaWZlY3ljbGUgcGhhc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGxQbHVnaW5Ib29rKHBoYXNlLCAuLi5hcmdzKSB7XG5cdFx0dGhpcy5jb25maWcucGx1Z2lucy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0aWYgKHBoYXNlID09PSBcIiRiZWZvcmVJbml0XCIpIHtcblx0XHRcdFx0di4kJCA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuYXBpLnBsdWdpbnMucHVzaCh2KTtcblx0XHRcdH1cblxuXHRcdFx0dltwaGFzZV0oLi4uYXJncyk7XG5cdFx0fSk7XG5cdH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcblxuLyoqXG4gKiBNYWluIGNoYXJ0IGNsYXNzLlxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgdmlhIGBiYi5nZW5lcmF0ZSgpYC5cbiAqIEBjbGFzcyBDaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcbiAqICBkYXRhOiB7XG4gKiAgICBjb2x1bW5zOiBbXG4gKlx0ICAgIFtcInhcIiwgXCIyMDE1LTExLTAyXCIsIFwiMjAxNS0xMi0wMVwiLCBcIjIwMTYtMDEtMDFcIiwgXCIyMDE2LTAyLTAxXCIsIFwiMjAxNi0wMy0wMVwiXSxcbiAqIFx0ICAgIFtcImNvdW50MVwiLCAxMSwgOCwgNywgNiwgNSBdLFxuICpcdCAgICBbXCJjb3VudDJcIiwgOSwgMywgNiwgMiwgOCBdXG4gKiAgIF19XG4gKiB9XG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cbiovXG4vKipcbiAqIEFjY2VzcyBwcmltYXJ5IG5vZGUgZWxlbWVudHNcbiAqIEBuYW1lIENoYXJ0IyRcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09iamVjdH0gJFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuY2hhcnQgV3JhcHBlciBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5zdmcgTWFpbiBzdmcgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuZGVmcyBEZWZpbml0aW9uIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLm1haW4gTWFpbiBncm91cGluZyBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50b29sdGlwIFRvb2x0aXAgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGVnZW5kIExlZ2VuZCBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50aXRsZSBUaXRsZSBlbGVtZW50XG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5ncmlkIEdyaWQgZWxlbWVudFxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYXJjIEFyYyBlbGVtZW50XG4gKiBAcHJvcGVydHkge09iamVjdH0gJC5iYXJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmJhci5iYXJzIEJhciBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9ICQubGluZVxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5saW5lcyBMaW5lIGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmFyZWFzIEFyZWFzIGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmNpcmNsZXMgRGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLnRleHRcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRleHQudGV4dHMgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRzXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuICpcbiAqIGNoYXJ0LiQuY2hhcnQ7IC8vIHdyYXBwZXIgZWxlbWVudFxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xuXHRjb25zdHJ1Y3Rvcihjb25maWcpIHtcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogUGx1Z2luIGluc3RhbmNlIGFycmF5XG5cdFx0ICogQG5hbWUgQ2hhcnQjcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XG5cdFx0ICogICAgIC4uLlxuXHRcdCAqICAgICBwbHVnaW5zOiBbXG5cdFx0ICogICAgICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXG5cdFx0ICogICAgICAgIG5ldyBQbHVnaW5BKClcblx0XHQgKiAgICAgXVxuXHRcdCAqICB9KTtcblx0XHQgKlxuXHRcdCAqICBjaGFydC5wbHVnaW5zOyAvLyBbU3RhbmZvcmQsIFBsdWdpbkFdIC0gaW5zdGFuY2UgYXJyYXlcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBbXTtcblxuXHRcdHRoaXMuaW50ZXJuYWwgPSAkJDtcblxuXHRcdCQkLmxvYWRDb25maWcoY29uZmlnKTtcblx0XHQkJC5iZWZvcmVJbml0KGNvbmZpZyk7XG5cdFx0JCQuaW5pdCgpO1xuXG5cdFx0dGhpcy4kID0gJCQuZ2V0Q2hhcnRFbGVtZW50cygpO1xuXG5cdFx0JCQuYWZ0ZXJJbml0KGNvbmZpZyk7XG5cblx0XHQvLyBiaW5kIFwidGhpc1wiIHRvIG5lc3RlZCBBUElcblx0XHQoZnVuY3Rpb24gYmluZFRoaXMoZm4sIHRhcmdldCwgYXJnVGhpcykge1xuXHRcdFx0T2JqZWN0LmtleXMoZm4pLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBmbltrZXldLmJpbmQoYXJnVGhpcyk7XG5cblx0XHRcdFx0T2JqZWN0LmtleXMoZm5ba2V5XSkubGVuZ3RoICYmXG5cdFx0XHRcdFx0YmluZFRoaXMoZm5ba2V5XSwgdGFyZ2V0W2tleV0sIGFyZ1RoaXMpO1xuXHRcdFx0fSk7XG5cdFx0fSkoQ2hhcnQucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDbGFzcyB0byBzZXQgb3B0aW9ucyBvbiBnZW5lcmF0aW5nIGNoYXJ0LlxuICogLSBJdCdzIGluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxuICogQGNsYXNzIE9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGJiLmdlbmVyYXRlfSB0byB1c2UgdGhlc2Ugb3B0aW9ucyBvbiBnZW5lcmF0aW5nIHRoZSBjaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmeSB0aGUgQ1NTIHNlbGVjdG9yIG9yIHRoZSBlbGVtZW50IHdoaWNoIHRoZSBjaGFydCB3aWxsIGJlIHNldCB0by4gRDMgc2VsZWN0aW9uIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIGFsc28uPGJyPlxuXHRcdFx0ICogSWYgb3RoZXIgY2hhcnQgaXMgc2V0IGFscmVhZHksIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZSAob25seSBvbmUgY2hhcnQgY2FuIGJlIHNldCBpbiBvbmUgZWxlbWVudCkuXG5cdFx0XHQgKiAtICoqTk9URToqKiBJbiBjYXNlIG9mIGVsZW1lbnQgZG9lc24ndCBleGlzdCBvciBub3Qgc3BlY2lmaWVkLCB3aWxsIGFkZCBhIGA8ZGl2PmAgZWxlbWVudCB0byB0aGUgYm9keS5cblx0XHRcdCAqIEBuYW1lIGJpbmR0b1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gYmluZHRvPSNjaGFydCBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGJpbmR0by5lbGVtZW50PSNjaGFydCBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2JpbmR0by5jbGFzc25hbWU9YmJdIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgb2YgYmluZCBlbGVtZW50Ljxicj5cblx0XHRcdCAqICAgICAqKk5PVEU6KiogV2hlbiBjbGFzcyBuYW1lIGlzbid0IGBiYmAsIHRoZW4geW91IGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIGRlZmF1bHQgQ1NTIHRvIGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cblx0XHRcdCAqIEBkZWZhdWx0ICNjaGFydFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGJpbmR0bzogXCIjbXlDb250YWluZXJcIlxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIG9yIEhUTUxFbGVtZW50XG5cdFx0XHQgKiBiaW5kdG86IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDb250YWluZXJcIilcblx0XHRcdCAqXG5cdFx0XHQgKiAvLyBvciBEMyBzZWxlY3Rpb24gb2JqZWN0XG5cdFx0XHQgKiBiaW5kdG86IGQzLnNlbGVjdChcIiNteUNvbnRhaW5lclwiKVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIG9yIHRvIGNoYW5nZSBkZWZhdWx0IGNsYXNzbmFtZVxuXHRcdFx0ICogYmluZHRvOiB7XG5cdFx0XHQgKiAgICBlbGVtZW50OiBcIiNjaGFydFwiLFxuXHRcdFx0ICogICAgY2xhc3NuYW1lOiBcImJpbGwtYm9hcmRcIiAgLy8gZXgpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0nYmlsbC1ib2FyZCc+XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGJpbmR0bzogXCIjY2hhcnRcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIGZvciBjaGFydCBlbGVtZW50XG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogID4gV2hlbiBpcyBmYWxzZSwgY2hhcnQgbm9kZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGF4aXMgbm9kZSBpbiBET00gdHJlZSBoaWVyYXJjaHkuXG5cdFx0XHQgKiAgPiBJcyB0byBtYWtlIGNoYXJ0IGVsZW1lbnQgcG9zaXRpb25lZCBvdmVyIGF4aXMgZWxlbWVudC5cblx0XHRcdCAqIEBuYW1lIGNsaXBQYXRoXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLmNsaXBQYXRoKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcblx0XHRcdCAqIGNsaXBQYXRoOiBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRjbGlwUGF0aDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgc3ZnIGVsZW1lbnQncyBjbGFzcyBuYW1lXG5cdFx0XHQgKiBAbmFtZSBzdmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdmcuY2xhc3NuYW1lXSBjbGFzcyBuYW1lIGZvciBzdmcgZWxlbWVudFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHN2Zzoge1xuICAgICAgICAgICAgICogICBjbGFzc25hbWU6IFwidGVzdF9jbGFzc1wiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdHN2Z19jbGFzc25hbWU6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBjaGFydCBlbGVtZW50LlxuXHRcdFx0ICogSWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZCwgdGhlIHdpZHRoIG9mIHRoZSBjaGFydCB3aWxsIGJlIGNhbGN1bGF0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIHBhcmVudCBlbGVtZW50IGl0J3MgYXBwZW5kZWQgdG8uXG5cdFx0XHQgKiBAbmFtZSBzaXplXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS53aWR0aF0gd2lkdGggb2YgdGhlIGNoYXJ0IGVsZW1lbnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS5oZWlnaHRdIGhlaWdodCBvZiB0aGUgY2hhcnQgZWxlbWVudFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5DaGFydFNpemUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogc2l6ZToge1xuICAgICAgICAgICAgICogICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgICogICBoZWlnaHQ6IDQ4MFxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRzaXplX3dpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRzaXplX2hlaWdodDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBwYWRkaW5nIG9mIHRoZSBjaGFydCBlbGVtZW50LlxuXHRcdFx0ICogQG5hbWUgcGFkZGluZ1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcudG9wXSBwYWRkaW5nIG9uIHRoZSB0b3Agb2YgY2hhcnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5yaWdodF0gcGFkZGluZyBvbiB0aGUgcmlnaHQgb2YgY2hhcnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5ib3R0b21dIHBhZGRpbmcgb24gdGhlIGJvdHRvbSBvZiBjaGFydFxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLmxlZnRdIHBhZGRpbmcgb24gdGhlIGxlZnQgb2YgY2hhcnRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgKiAgIHRvcDogMjAsXG4gICAgICAgICAgICAgKiAgIHJpZ2h0OiAyMCxcbiAgICAgICAgICAgICAqICAgYm90dG9tOiAyMCxcbiAgICAgICAgICAgICAqICAgbGVmdDogMjBcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0cGFkZGluZ19sZWZ0OiB1bmRlZmluZWQsXG5cdFx0XHRwYWRkaW5nX3JpZ2h0OiB1bmRlZmluZWQsXG5cdFx0XHRwYWRkaW5nX3RvcDogdW5kZWZpbmVkLFxuXHRcdFx0cGFkZGluZ19ib3R0b206IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2hhcnQgcmVzaXplIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIHJlc2l6ZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXNpemUuYXV0bz10cnVlXSBTZXQgY2hhcnQgcmVzaXplIGF1dG9tYXRpY2FsbHkgb24gdmlld3BvcnQgY2hhbmdlcy5cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgcmVzaXplOiB7XG5cdFx0XHQgKiAgICAgIGF1dG86IGZhbHNlXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRyZXNpemVfYXV0bzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgem9vbSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSB6b29tXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3pvb20uZW5hYmxlZD1mYWxzZV0gRW5hYmxlIHpvb21pbmcuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3pvb20uZW5hYmxlZC50eXBlPSd3aGVlbCddIFNldCB6b29tIGludGVyYWN0aW9uIHR5cGUuXG5cdFx0XHQgKiAgLSAqKkF2YWlsYWJsZSB0eXBlczoqKlxuXHRcdFx0ICogICAgLSB3aGVlbFxuXHRcdFx0ICogICAgLSBkcmFnXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt6b29tLnJlc2NhbGU9ZmFsc2VdIEVuYWJsZSB0byByZXNjYWxlIGFmdGVyIHpvb21pbmcuPGJyPlxuXHRcdFx0ICogIElmIHRydWUgc2V0LCB5IGRvbWFpbiB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSB6b29tZWQgcmVnaW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtBcnJheX0gW3pvb20uZXh0ZW50PVsxLCAxMF1dIENoYW5nZSB6b29tIGV4dGVudC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfERhdGV9IFt6b29tLngubWluXSBTZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RGF0ZX0gW3pvb20ueC5tYXhdIFNldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb21zdGFydD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgc3RhcnRzLjxicj5cblx0XHRcdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb20gZXZlbnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb209dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2hhcnQgaXMgem9vbWluZy48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tZW5kPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gem9vbWluZyBlbmRzLjxicj5cblx0XHRcdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb21lZCBkb21haW4uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbem9vbS5yZXNldEJ1dHRvbj10cnVlXSBTZXQgdG8gZGlzcGxheSB6b29tIHJlc2V0IGJ1dHRvbiBmb3IgJ2RyYWcnIHR5cGUgem9vbVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt6b29tLnJlc2V0QnV0dG9uLnRleHQ9J1Jlc2V0IFpvb20nXSBUZXh0IHZhbHVlIGZvciB6b29tIHJlc2V0IGJ1dHRvbi5cblx0XHRcdCAqIEBzZWUgW0RlbW86em9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlpvb20pXG5cdFx0XHQgKiBAc2VlIFtEZW1vOmRyYWcgem9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLkRyYWdab29tKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICB6b29tOiB7XG5cdFx0XHQgKiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgICAqICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiXG4gICAgICAgICAgICAgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHJlc2NhbGU6IHRydWUsXG5cdFx0XHQgKiAgICAgIGV4dGVudDogWzEsIDEwMF0gIC8vIGVuYWJsZSBtb3JlIHpvb21pbmdcblx0XHRcdCAqICAgICAgeDoge1xuXHRcdFx0ICogICAgICAgICAgbWluOiAtMSwgIC8vIHNldCBtaW4gcmFuZ2Vcblx0XHRcdCAqICAgICAgICAgIG1heDogMTAgIC8vIHNldCBtYXggcmFuZ2Vcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgb256b29tc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICBvbnpvb206IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgb256b29tZW5kOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzaG93IHJlc2V0IGJ1dHRvbiB3aGVuIGlzIHpvb21lZC1pblxuXHRcdFx0ICogICAgICByZXNldEJ1dHRvbjogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGN1c3RvbWl6ZWQgdGV4dCB2YWx1ZSBmb3IgcmVzZXQgem9vbSBidXR0b25cblx0XHRcdCAqICAgICAgcmVzZXRCdXR0b246IHtcblx0XHRcdCAqICAgICAgICAgIHRleHQ6IFwiVW56b29tXCJcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0em9vbV9lbmFibGVkOiB1bmRlZmluZWQsXG5cdFx0XHR6b29tX2V4dGVudDogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV9wcml2aWxlZ2VkOiBmYWxzZSxcblx0XHRcdHpvb21fcmVzY2FsZTogZmFsc2UsXG5cdFx0XHR6b29tX29uem9vbTogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV9vbnpvb21zdGFydDogdW5kZWZpbmVkLFxuXHRcdFx0em9vbV9vbnpvb21lbmQ6IHVuZGVmaW5lZCxcblx0XHRcdHpvb21fcmVzZXRCdXR0b246IHRydWUsXG5cdFx0XHR6b29tX3hfbWluOiB1bmRlZmluZWQsXG5cdFx0XHR6b29tX3hfbWF4OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSW50ZXJhY3Rpb24gb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgaW50ZXJhY3Rpb25cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uZW5hYmxlZD10cnVlXSBJbmRpY2F0ZSBpZiB0aGUgY2hhcnQgc2hvdWxkIGhhdmUgaW50ZXJhY3Rpb25zLjxicj5cblx0XHRcdCAqICAgICBJZiBgZmFsc2VgIGlzIHNldCwgYWxsIG9mIGludGVyYWN0aW9ucyAoc2hvd2luZy9oaWRpbmcgdG9vbHRpcCwgc2VsZWN0aW9uLCBtb3VzZSBldmVudHMsIGV0Yykgd2lsbCBiZSBkaXNhYmxlZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmJyaWdodGVuPXRydWVdIE1ha2UgYnJpZ2h0ZXIgZm9yIHRoZSBzZWxlY3RlZCBhcmVhIChleC4gJ3BpZScgdHlwZSBkYXRhIHNlbGVjdGVkIGFyZWEpXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUubW91c2U9dHJ1ZV0gZW5hYmxlIG9yIGRpc2FibGUgbW91c2UgaW50ZXJhY3Rpb25cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaD10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSAgdG91Y2ggaW50ZXJhY3Rpb25cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQ9ZmFsc2VdIGVuYWJsZSBvciBkaXNhYmxlIHRvIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQgb24gdG91Y2hzdGFydCAmIHRvdWNobW92ZSBldmVudC4gSXQncyB1c3VhbGx5IHVzZWQgdG8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmcuXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiB0b3VjaC5wcmV2ZW50RGVmYXVsdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlByZXZlbnRTY3JvbGxPblRvdWNoKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGludGVyYWN0aW9uOiB7XG4gICAgICAgICAgICAgKiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAqICAgIGJyaWdodGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAqICAgIGlucHV0VHlwZToge1xuICAgICAgICAgICAgICogICAgICAgIG1vdXNlOiB0cnVlLFxuICAgICAgICAgICAgICogICAgICAgIHRvdWNoOiBmYWxzZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICAvLyBvciBkZWNsYXJlIHByZXZlbnREZWZhdWx0IGV4cGxpY2l0bHkuXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRvdWNoIGlucHV0VHlwZSBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAqICAgICAgICB0b3VjaDoge1xuICAgICAgICAgICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICAgICAgLy8gb3IgdGhyZXNob2xkIHBpeGVsIHZhbHVlIChwaXhlbCBtb3ZlZCBmcm9tIHRvdWNoc3RhcnQgdG8gdG91Y2htb3ZlKVxuICAgICAgICAgICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogNVxuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0aW50ZXJhY3Rpb25fZW5hYmxlZDogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uX2JyaWdodGVuOiB0cnVlLFxuXHRcdFx0aW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlOiB0cnVlLFxuXHRcdFx0aW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggZW50ZXJzIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIG9ub3ZlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCl7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIG9ub3ZlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbm92ZXI6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBtb3VzZS90b3VjaCBsZWF2ZXMgdGhlIGNoYXJ0LlxuXHRcdFx0ICogQG5hbWUgb25vdXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbm91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbm91dDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHVzZXIgcmVzaXplcyB0aGUgc2NyZWVuLlxuXHRcdFx0ICogQG5hbWUgb25yZXNpemVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbnJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbnJlc2l6ZTogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU1NldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBzY3JlZW4gcmVzaXplIGZpbmlzaGVkLlxuXHRcdFx0ICogQG5hbWUgb25yZXNpemVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKXt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogb25yZXNpemVkOiBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgLi4uXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdG9ucmVzaXplZDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXG5cdFx0XHQgKiBAbmFtZSBvbmJlZm9yZWluaXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpe31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAuLi5cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0b25iZWZvcmVpbml0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cblx0XHRcdCAqIEBuYW1lIG9uaW5pdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCl7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIG9uaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbmluaXQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXG5cdFx0XHQgKiBAbmFtZSBvbmFmdGVyaW5pdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCl7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIG9uYWZ0ZXJpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgLi4uXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdG9uYWZ0ZXJpbml0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhcnQgaXMgcmVuZGVyZWQuIEJhc2ljYWxseSwgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpbiBlYWNoIHRpbWUgd2hlbiB0aGUgY2hhcnQgaXMgcmVkcmF3ZWQuXG5cdFx0XHQgKiBAbmFtZSBvbnJlbmRlcmVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogb25yZW5kZXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgIC4uLlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRvbnJlbmRlcmVkOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGR1cmF0aW9uIG9mIHRyYW5zaXRpb24gKGluIG1pbGxpc2Vjb25kcykgZm9yIGNoYXJ0IGFuaW1hdGlvbi48YnI+PGJyPlxuXHRcdFx0ICogLSAqKk5PVEU6KiogSWYgYDAgYG9yIGBudWxsYCBzZXQsIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkLiBTbywgdGhpcyBtYWtlcyBpbml0aWFsIHJlbmRlcmluZyBmYXN0ZXIgZXNwZWNpYWxseSBpbiBjYXNlIHlvdSBoYXZlIGEgbG90IG9mIGRhdGEuXG5cdFx0XHQgKiBAbmFtZSB0cmFuc2l0aW9uXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdHJhbnNpdGlvbi5kdXJhdGlvbj0zNTBdIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHRyYW5zaXRpb246IHtcblx0XHRcdCAqICAgIGR1cmF0aW9uOiA1MDBcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0dHJhbnNpdGlvbl9kdXJhdGlvbjogMzUwLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZnkgdGhlIGtleSBvZiB4IHZhbHVlcyBpbiB0aGUgZGF0YS48YnI+PGJyPlxuXHRcdFx0ICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKR4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgeDogXCJkYXRlXCJcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV94OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmeSB0aGUga2V5cyBvZiB0aGUgeCB2YWx1ZXMgZm9yIGVhY2ggZGF0YS48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgaWYgd2Ugd2FudCB0byBzaG93IHRoZSBkYXRhIHRoYXQgaGFzIGRpZmZlcmVudCB4IHZhbHVlcy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKR4c1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgeHM6IHtcbiAgICAgICAgICAgICAqICAgICAgZGF0YTE6IFwieDFcIixcbiAgICAgICAgICAgICAqICAgICAgZGF0YTI6IFwieDJcIlxuICAgICAgICAgICAgICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfeHM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2Ugc3RyaW5nIHNwZWNpZmVkIGFzIHguXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeEZvcm1hdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCAlWS0lbS0lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgIHg6IFwieFwiLFxuXHRcdFx0ICogICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICAgIFtcInhcIiwgXCIwMTAxMjAxOVwiLCBcIjAyMDEyMDE5XCIsIFwiMDMwMTIwMTlcIl0sXG5cdFx0XHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwXVxuXHRcdFx0ICogICAgXSxcblx0XHRcdCAqICAgIC8vIEZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2UgYXMgZGF0ZXRpbWUgZm9yIGdpdmVuICd4JyBzdHJpbmcgdmFsdWVcblx0XHRcdCAqICAgIHhGb3JtYXQ6IFwiJW0lZCVZXCJcblx0XHRcdCAqIH0sXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgICB4OiB7XG5cdFx0XHQgKiAgICAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3hGb3JtYXQ6IFwiJVktJW0tJWRcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbG9jYWx0aW1lIGZvcm1hdCB0byBwYXJzZSB4IGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkeExvY2FsdGltZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcbiAgICAgICAgICAgICAqICAgeExvY2FsdGltZTogZmFsc2Vcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV94TG9jYWx0aW1lOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNvcnQgb24geCBheGlzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHhTb3J0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICB4U29ydDogZmFsc2Vcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV94U29ydDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDb252ZXJ0cyBkYXRhIGlkIHZhbHVlXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkaWRDb252ZXJ0ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQ7IH1cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG4gICAgICAgICAgICAgKiAgICBpZENvbnZlcnRlcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAqICAgICAgIC8vIHdoZW4gaWQgaXMgJ2RhdGExJywgY29udmVydHMgdG8gYmUgJ2RhdGEyJ1xuICAgICAgICAgICAgICogICAgICAgLy8gJ2RhdGEyJyBzaG91bGQgYmUgZ2l2ZW4gYXMgdGhlIGluaXRpYWwgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICogICAgICAgaWYgKGlkID09PSBcImRhdGExXCIpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBcImRhdGEyXCI7XG4gICAgICAgICAgICAgKiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICogICAgICAgfVxuICAgICAgICAgICAgICogICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2lkQ29udmVydGVyOiBpZCA9PiBpZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY3VzdG9tIGRhdGEgbmFtZS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRuYW1lc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU5hbWUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICBuYW1lczoge1xuICAgICAgICAgICAgICogICAgIGRhdGExOiBcIkRhdGEgTmFtZSAxXCIsXG4gICAgICAgICAgICAgKiAgICAgZGF0YTI6IFwiRGF0YSBOYW1lIDJcIlxuICAgICAgICAgICAgICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfbmFtZXM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjdXN0b20gZGF0YSBjbGFzcy48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgZWxlbWVudCBnIGZvciB0aGUgZGF0YSBoYXMgYW4gYWRkaXRpb25hbCBjbGFzcyB0aGF0IGhhcyB0aGUgcHJlZml4ICdiYi10YXJnZXQtJyAoZWcuIGJiLXRhcmdldC1hZGRpdGlvbmFsLWRhdGExLWNsYXNzKS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRjbGFzc2VzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgKiAgICAgZGF0YTE6IFwiYWRkaXRpb25hbC1kYXRhMS1jbGFzc1wiLFxuICAgICAgICAgICAgICogICAgIGRhdGEyOiBcImFkZGl0aW9uYWwtZGF0YTItY2xhc3NcIlxuICAgICAgICAgICAgICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfY2xhc3Nlczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGdyb3VwcyBmb3IgdGhlIGRhdGEgZm9yIHN0YWNraW5nLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGdyb3Vwc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IFtdXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuICAgICAgICAgICAgICogICBncm91cHM6IFtcbiAgICAgICAgICAgICAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxuICAgICAgICAgICAgICogICAgIFtcImRhdGEzXCJdXG4gICAgICAgICAgICAgKiAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9ncm91cHM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB5IGF4aXMgdGhlIGRhdGEgcmVsYXRlZCB0by4geSBhbmQgeTIgY2FuIGJlIHVzZWQuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkYXhlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgYXhlczoge1xuXHRcdFx0ICogICAgIGRhdGExOiBcInlcIixcblx0XHRcdCAqICAgICBkYXRhMjogXCJ5MlwiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9heGVzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2hhcnQgdHlwZSBhdCBvbmNlLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSB0eXBlIHdpbGwgYmUgYXBwbGllZCB0byBldmVyeSBkYXRhLiBUaGlzIHNldHRpbmcgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEudHlwZXMuPGJyPjxicj5cblx0XHRcdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxuXHRcdFx0ICogLSBhcmVhXG5cdFx0XHQgKiAtIGFyZWEtbGluZS1yYW5nZVxuXHRcdFx0ICogLSBhcmVhLXNwbGluZVxuXHRcdFx0ICogLSBhcmVhLXNwbGluZS1yYW5nZVxuXHRcdFx0ICogLSBhcmVhLXN0ZXBcblx0XHRcdCAqIC0gYmFyXG5cdFx0XHQgKiAtIGJ1YmJsZVxuXHRcdFx0ICogLSBkb251dFxuXHRcdFx0ICogLSBnYXVnZVxuXHRcdFx0ICogLSBsaW5lXG5cdFx0XHQgKiAtIHBpZVxuXHRcdFx0ICogLSByYWRhclxuXHRcdFx0ICogLSBzY2F0dGVyXG5cdFx0XHQgKiAtIHNwbGluZVxuXHRcdFx0ICogLSBzdGVwXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkdHlwZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCBsaW5lXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgdHlwZTogXCJiYXJcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3R5cGU6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY2hhcnQgdHlwZSBmb3IgZWFjaCBkYXRhLjxicj5cblx0XHRcdCAqIFRoaXMgc2V0dGluZyBvdmVyd3JpdGVzIGRhdGEudHlwZSBzZXR0aW5nLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogYHJhZGFyYCB0eXBlIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdHlwZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkdHlwZXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHR5cGVzOiB7XG5cdFx0XHQgKiAgICAgZGF0YTE6IFwiYmFyXCIsXG5cdFx0XHQgKiAgICAgZGF0YTI6IFwic3BsaW5lXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3R5cGVzOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbGFiZWxzIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGRhdGHigKRsYWJlbHNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZGF0YS5sYWJlbHM9ZmFsc2VdIFNob3cgb3IgaGlkZSBsYWJlbHMgb24gZWFjaCBkYXRhIHBvaW50c1xuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZGF0YS5sYWJlbHMuY2VudGVyZWQ9ZmFsc2VdIENlbnRlcml6ZSBsYWJlbHMgb24gYGJhcmAgc2hhcGUuICgqKk5PVEU6Kiogd29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkYXRhLmxhYmVscy5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIGRhdGEgbGFiZWxzLjxicj5cblx0XHRcdCAqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24gcmVjZWl2ZXMgNCBhcmd1bWVudHMgc3VjaCBhcyB2LCBpZCwgaSwgaiBhbmQgaXQgbXVzdCByZXR1cm4gYSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNob3duIGFzIHRoZSBsYWJlbC4gVGhlIGFyZ3VtZW50cyBhcmU6PGJyPlxuXHRcdFx0ICogIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG5cdFx0XHQgKiAgLSBgaWRgIGlzIHRoZSBpZCBvZiB0aGUgZGF0YSB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXG5cdFx0XHQgKiAgLSBgaWAgaXMgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi5cblx0XHRcdCAqICAtIGBqYCBpcyB0aGUgc3ViIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi48YnI+PGJyPlxuXHRcdFx0ICogRm9ybWF0dGVyIGZ1bmN0aW9uIGNhbiBiZSBkZWZpbmVkIGZvciBlYWNoIGRhdGEgYnkgc3BlY2lmeWluZyBhcyBhbiBvYmplY3QgYW5kIEQzIGZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgc2V0IChleC4gZDMuZm9ybWF0KCckJykpXG4gXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBbZGF0YS5sYWJlbHMuY29sb3JzXSBTZXQgbGFiZWwgdGV4dCBjb2xvcnMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXG5cdFx0XHQgKiBAcHJvcGVydHkge05VbWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWwpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBsYWJlbCBjb2xvcnNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbENvbG9ycylcblx0XHRcdCAqIEBzZWUgW0RlbW86IGxhYmVsIGZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsRm9ybWF0KVxuXHRcdFx0ICogQHNlZSBbRGVtbzogbGFiZWwgcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbFBvc2l0aW9uKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgbGFiZWxzOiB0cnVlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8gb3Igc2V0IHNwZWNpZmljIG9wdGlvbnNcblx0XHRcdCAqICAgbGFiZWxzOiB7XG5cdFx0XHQgKiAgICAgZm9ybWF0OiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBzZXQgZm9yIGVhY2ggZGF0YVxuXHRcdFx0ICogICAgIGZvcm1hdDoge1xuXHRcdFx0ICogICAgICAgICBkYXRhMTogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIGFsaWduIHRleHQgdG8gY2VudGVyIG9mIHRoZSAnYmFyJyBzaGFwZSAod29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcblx0XHRcdCAqICAgICBjZW50ZXJlZDogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gYXBwbHkgZm9yIGFsbCBsYWJlbCB0ZXh0c1xuXHRcdFx0ICogICAgIGNvbG9yczogXCJyZWRcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gb3Igc2V0IGRpZmZlcmVudCBjb2xvcnMgcGVyIGRhdGFzZXRcblx0XHRcdCAqICAgICAvLyBmb3Igbm90IHNwZWNpZmllZCBkYXRhc2V0LCB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgY29sb3IgdmFsdWVcblx0XHRcdCAqICAgICBjb2xvcnM6IHtcblx0XHRcdCAqICAgICAgICBkYXRhMTogXCJ5ZWxsb3dcIixcblx0XHRcdCAqICAgICAgICBkYXRhMzogXCJncmVlblwiXG5cdFx0XHQgKiAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgLy8gc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxuXHRcdFx0ICogICAgIHBvc2l0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgeDogLTEwLFxuXHRcdFx0ICogICAgICAgIHk6IDEwXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfbGFiZWxzOiB7fSxcblx0XHRcdGRhdGFfbGFiZWxzX2NvbG9yczogdW5kZWZpbmVkLFxuXHRcdFx0ZGF0YV9sYWJlbHNfcG9zaXRpb246IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqICBUaGlzIG9wdGlvbiBjaGFuZ2VzIHRoZSBvcmRlciBvZiBzdGFja2luZyBkYXRhIGFuZCBwaWVjZXMgb2YgcGllL2RvbnV0LlxuXHRcdFx0ICogIC0gSWYgYG51bGxgIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB0aGUgb3JkZXIgdGhlIGRhdGEgbG9hZGVkLlxuXHRcdFx0ICogIC0gSWYgZnVuY3Rpb24gc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpPGJyPjxicj5cblx0XHRcdCAqXG5cdFx0XHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXG5cdFx0XHQgKiAgLSBgZGVzY2A6IEluIGRlc2NlbmRpbmcgb3JkZXJcblx0XHRcdCAqICAtIGBhc2NgOiBJbiBhc2NlbmRpbmcgb3JkZXJcblx0XHRcdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgbG9hZCBvcmRlclxuXHRcdFx0ICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IEFycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb3JkZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG5cdFx0XHQgKiBAZGVmYXVsdCBkZXNjXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhT3JkZXIpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAvLyBpbiBkZXNjZW5kaW5nIG9yZGVyIChkZWZhdWx0KVxuXHRcdFx0ICogICBvcmRlcjogXCJkZXNjXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIGluIGFzY2VuZGluZyBvcmRlclxuXHRcdFx0ICogICBvcmRlcjogXCJhc2NcIlxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8ga2VlcHMgZGF0YSBpbnB1dCBvcmRlclxuXHRcdFx0ICogICBvcmRlcjogbnVsbFxuXHRcdFx0ICpcblx0XHRcdCAqICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXG5cdFx0XHQgKiAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHQgKiAgICAgICAvLyBwYXJhbSBkYXRhIHBhc3NlZCBmb3JtYXRcblx0XHRcdCAqICAgICAgIHtcblx0XHRcdCAqICAgICAgICAgIGlkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcblx0XHRcdCAqICAgICAgICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn0sXG5cdFx0XHQgKiAgICAgICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICBdXG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vcmRlcjogXCJkZXNjXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRGVmaW5lIHJlZ2lvbnMgZm9yIGVhY2ggZGF0YS48YnI+XG5cdFx0XHQgKiBUaGUgdmFsdWVzIG11c3QgYmUgYW4gYXJyYXkgZm9yIGVhY2ggZGF0YSBhbmQgaXQgc2hvdWxkIGluY2x1ZGUgYW4gb2JqZWN0IHRoYXQgaGFzIGBzdGFydGAsIGBlbmRgIGFuZCBgc3R5bGVgLlxuXHRcdFx0ICogLSBUaGUgb2JqZWN0IHR5cGUgc2hvdWxkIGJlIGFzOlxuXHRcdFx0ICogICAtIHN0YXJ0IHtOdW1iZXJ9OiBTdGFydCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIHN0YXJ0IHdpbGwgYmUgdGhlIGZpcnN0IGRhdGEgcG9pbnQuXG5cdFx0XHQgKiAgIC0gW2VuZF0ge051bWJlcn06IEVuZCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIGVuZCB3aWxsIGJlIHRoZSBsYXN0IGRhdGEgcG9pbnQuXG5cdFx0XHQgKiAgIC0gW3N0eWxlLmRhc2hhcnJheT1cIjIgMlwiXSB7T2JqZWN0fTogVGhlIGZpcnN0IG51bWJlciBzcGVjaWZpZXMgYSBkaXN0YW5jZSBmb3IgdGhlIGZpbGxlZCBhcmVhLCBhbmQgdGhlIHNlY29uZCBhIGRpc3RhbmNlIGZvciB0aGUgdW5maWxsZWQgYXJlYS5cblx0XHRcdCAqIC0gKipOT1RFOioqIEN1cnJlbnRseSB0aGlzIG9wdGlvbiBzdXBwb3J0cyBvbmx5IGxpbmUgY2hhcnQgYW5kIGRhc2hlZCBzdHlsZS4gSWYgdGhpcyBvcHRpb24gc3BlY2lmaWVkLCB0aGUgbGluZSB3aWxsIGJlIGRhc2hlZCBvbmx5IGluIHRoZSByZWdpb25zLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHJlZ2lvbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIHJlZ2lvbnM6IHtcblx0XHRcdCAqICAgICBkYXRhMTogW3tcblx0XHRcdCAqICAgICAgICAgc3RhcnQ6IDEsXG5cdFx0XHQgKiAgICAgICAgIGVuZDogMixcblx0XHRcdCAqICAgICAgICAgc3R5bGU6IHtcblx0XHRcdCAqICAgICAgICAgICAgIGRhc2hhcnJheTogXCI1IDJcIlxuXHRcdFx0ICogICAgICAgICB9XG5cdFx0XHQgKiAgICAgfSwge1xuXHRcdFx0ICogICAgICAgICBzdGFydDogM1xuXHRcdFx0ICogICAgIH1dLFxuXHRcdFx0ICogICAgIC4uLlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfcmVnaW9uczoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNvbG9yIGNvbnZlcnRlciBmdW5jdGlvbi48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBvcHRpb24gc2hvdWxkIGEgZnVuY3Rpb24gYW5kIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgY29sb3IgKGUuZy4gJyNmZjAwMDAnKSBhbmQgZCB0aGF0IGhhcyBkYXRhIHBhcmFtZXRlcnMgbGlrZSBpZCwgdmFsdWUsIGluZGV4LCBldGMuIEFuZCBpdCBtdXN0IHJldHVybiBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgY29sb3IgKGUuZy4gJyMwMGZmMDAnKS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRjb2xvclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUNvbG9yKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sb3I6IGZ1bmN0aW9uKGNvbG9yLCBkKSB7IC4uLiB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfY29sb3I6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgY29sb3IgZm9yIGVhY2ggZGF0YS5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRjb2xvcnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIGNvbG9yczoge1xuXHRcdFx0ICogICAgIGRhdGExOiBcIiNmZjAwMDBcIixcblx0XHRcdCAqICAgICBkYXRhMjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgIHJldHVybiBcIiMwMDBcIjtcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgICAgLi4uXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9jb2xvcnM6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpZGUgZWFjaCBkYXRhIHdoZW4gdGhlIGNoYXJ0IGFwcGVhcnMuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkaGlkZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXG5cdFx0XHQgKiAgIGhpZGU6IHRydWVcblx0XHRcdCAqXG5cdFx0XHQgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXG5cdFx0XHQgKiAgIGhpZGU6IFtcImRhdGExXCIsIC4uLl1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9oaWRlOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWx0ZXIgdmFsdWVzIHRvIGJlIHNob3duXG5cdFx0XHQgKiBUaGUgZGF0YSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuZWQgYnkgYC5kYXRhKClgLlxuXHRcdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcblx0XHRcdCAqIEBuYW1lIGRhdGHigKRmaWx0ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgIC8vIGZpbHRlciBmb3IgaWQgdmFsdWVcblx0XHRcdCAqICAgZmlsdGVyOiBmdW5jdGlvbih2KSB7XG5cdFx0XHQgKiAgICAgIC8vIHY6IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xuXHRcdFx0ICogICAgICAvLyAgICAgIHt4OiAwLCB2YWx1ZTogMTMwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogMH0sIC4uLl1cblx0XHRcdCAqICAgICAgLy8gICAgfSwgLi4uXVxuXHRcdFx0ICogICAgICByZXR1cm4gdi5pZCAhPT0gXCJkYXRhMVwiO1xuXHRcdFx0ICogICB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfZmlsdGVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSBzdGFja2luZyB0byBiZSBub3JtYWxpemVkXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogICAtIEZvciBzdGFja2luZywgJ1tkYXRhLmdyb3Vwc10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0Z3JvdXBzKScgb3B0aW9uIHNob3VsZCBiZSBzZXRcblx0XHRcdCAqICAgLSB5IEF4aXMgd2lsbCBiZSBzZXQgaW4gcGVyY2VudGFnZSB2YWx1ZSAoMCB+IDEwMCUpXG5cdFx0XHQgKiAgIC0gTXVzdCBoYXZlIHBvc3RpdmUgdmFsdWVzXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc3RhY2vigKRub3JtYWxpemVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU3RhY2tOb3JtYWxpemVkKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHQgICAgICogICBzdGFjazoge1xuXHRcdCAgICAgKiAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxuXHRcdCAgICAgKiAgIH1cblx0XHQgICAgICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3N0YWNrX25vcm1hbGl6ZTogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkYXRhIHNlbGVjdGlvbiBlbmFibGVkPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0cnVlLCB3ZSBjYW4gc2VsZWN0IHRoZSBkYXRhIHBvaW50cyBhbmQgZ2V0L3NldCBpdHMgc3RhdGUgb2Ygc2VsZWN0aW9uIGJ5IEFQSSAoZS5nLiBzZWxlY3QsIHVuc2VsZWN0LCBzZWxlY3RlZCkuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZW5hYmxlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTZWxlY3Rpb24pXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBlbmFibGVkOiB0cnVlXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBncm91cGVkIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgbXVsdGlwbGUgZGF0YSBwb2ludHMgdGhhdCBoYXZlIHNhbWUgeCB2YWx1ZSB3aWxsIGJlIHNlbGVjdGVkIGJ5IG9uZSBzZWxlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZ3JvdXBlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICBzZWxlY3Rpb246IHtcblx0XHRcdCAqICAgICAgIGdyb3VwZWQ6IHRydWVcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBkIGFzIGFuIGFyZ3VtZW50IGFuZCBpdCBoYXMgc29tZSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleC4gVGhpcyBjYWxsYmFjayBzaG91bGQgcmV0dXJuIGJvb2xlYW4uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtdWx0aXBsZSBkYXRhIHBvaW50cyBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxuXHRcdFx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApG11bHRpcGxlXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgc2VsZWN0aW9uOiB7XG5cdFx0XHQgKiAgICAgICBtdWx0aXBsZTogZmFsc2Vcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRW5hYmxlIHRvIHNlbGVjdCBkYXRhIHBvaW50cyBieSBkcmFnZ2luZy5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBkYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQgYnkgZHJhZ2dpbmcuXG5cdFx0XHQgKiAtICoqTk9URToqKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgc2Nyb2xsaW5nIG9uIHRoZSBjaGFydCB3aWxsIGJlIGRpc2FibGVkIGJlY2F1c2UgZHJhZ2dpbmcgZXZlbnQgd2lsbCBoYW5kbGUgdGhlIGV2ZW50LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGRyYWdnYWJsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICBzZWxlY3Rpb246IHtcblx0XHRcdCAqICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZTogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGNsaWNrIGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIGVhY2ggZGF0YSBwb2ludCBjbGlja2VkIGFuZCB3aWxsIHJlY2VpdmUgZCBhbmQgZWxlbWVudCBhcyB0aGUgYXJndW1lbnRzLiBkIGlzIHRoZSBkYXRhIGNsaWNrZWQgYW5kIGVsZW1lbnQgaXMgdGhlIGVsZW1lbnQgY2xpY2tlZC4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25jbGlja1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgb25jbGljazogZnVuY3Rpb24oZCwgZWxlbWVudCkgeyAuLi4gfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdmVyIGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxuXHRcdFx0ICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIG1vdXNlIGN1cnNvciBvciB2aWEgdG91Y2ggbW92ZXMgb250byBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBkIGFzIHRoZSBhcmd1bWVudC4gZCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb250by4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25vdmVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbm92ZXI6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdXQgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgZCBhcyB0aGUgYXJndW1lbnQuIGQgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG91dC4gSW4gdGhpcyBjYWxsYmFjaywgdGhpcyB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25vdXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIG9ub3V0OiBmdW5jdGlvbihkKSB7IC4uLiB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25vdXQ6ICgpID0+IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHNlbGVjdGlvbi5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRvbnNlbGVjdGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XG5cdFx0XHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cblx0XHRcdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cblx0XHRcdCAqICAgICAgICAuLi5cblx0XHRcdCAqICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbnNlbGVjdGVkOiAoKSA9PiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSB1bi1zZWxlY3Rpb24uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb251bnNlbGVjdGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBvbnVuc2VsZWN0ZWQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcblx0XHRcdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxuXHRcdFx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxuXHRcdFx0ICogICAgICAgIC4uLlxuXHRcdFx0ICogICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX29udW5zZWxlY3RlZDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxuXHRcdFx0ICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkb25taW5cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIG9ubWluOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxuXHRcdCAgICAgKiAgICAuLi5cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfb25taW46IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXG5cdFx0XHQgKiAtICoqTk9URToqKiBGb3IgJ2FyZWEtbGluZS1yYW5nZScgYW5kICdhcmVhLXNwbGluZS1yYW5nZScsIGBtaWRgIGRhdGEgd2lsbCBiZSB0YWtlbiBmb3IgdGhlIGNvbXBhcmlzb25cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRvbm1heFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdCAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXG5cdFx0ICAgICAqICAgIC4uLlxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9vbm1heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApHVybFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkxvYWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIlxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3VybDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFhIUiBoZWFkZXIgdmFsdWVcblx0XHRcdCAqIC0gKipOT1RFOioqIFNob3VsZCBiZSB1c2VkIHdpdGggYGRhdGEudXJsYCBvcHRpb25cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRoZWFkZXJzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvc2V0UmVxdWVzdEhlYWRlclxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIixcblx0XHRcdCAqICAgICBoZWFkZXJzOiB7XG5cdFx0XHQgKiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3htbFwiLFxuXHRcdFx0ICogICAgICAgIC4uLlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9oZWFkZXJzOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUGFyc2UgYSBKU09OIG9iamVjdCBmb3IgZGF0YS4gU2VlIGFsc28gZGF0YS5rZXlzLlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGpzb25cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtkYXRh4oCka2V5c10oIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cylcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgICBqc29uOiBbXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxuXHRcdFx0ICogICAgIF0sXG5cdFx0XHQgKiAgICAga2V5czoge1xuXHRcdFx0ICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXG5cdFx0XHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfanNvbjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluaW5nIHRoZSBkYXRhIG5hbWVzLCB0aGUgZm9sbG93aW5nIGNvbnRhaW5pbmcgcmVsYXRlZCBkYXRhIGluIHRoYXQgb3JkZXIuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkcm93c1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuUm93T3JpZW50ZWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgcm93czogW1xuXHRcdFx0ICogICAgIFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcblx0XHRcdCAqICAgICBbOTAsIDEyMCwgMzAwXSxcblx0XHRcdCAqICAgICBbNDAsIDE2MCwgMjQwXSxcblx0XHRcdCAqICAgICBbNTAsIDIwMCwgMjkwXSxcblx0XHRcdCAqICAgICBbMTIwLCAxNjAsIDIzMF0sXG5cdFx0XHQgKiAgICAgWzgwLCAxMzAsIDMwMF0sXG5cdFx0XHQgKiAgICAgWzkwLCAyMjAsIDMyMF1cblx0XHRcdCAqICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxuXHRcdFx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuXHRcdFx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgcm93czogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxuXHRcdFx0ICogICAgICBbXG5cdFx0XHQgKiAgICAgICAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9LCAxMjBcblx0XHRcdCAqICAgICAgICBbMTUwLCAxNDAsIDExMF0sIDEyMFxuXHRcdFx0ICogICAgICBdLFxuXHRcdFx0ICogICAgICBbWzE1NSwgMTMwLCAxMTVdLCA1NV0sXG5cdFx0XHQgKiAgICAgIFtbMTYwLCAxMzUsIDEyMF0sIDYwXVxuXHRcdFx0ICogICBdLFxuXHRcdFx0ICogICB0eXBlczoge1xuXHRcdFx0ICogICAgICAgZGF0YTE6IFwiYXJlYS1saW5lLXJhbmdlXCIsXG5cdFx0XHQgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX3Jvd3M6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggZWFjaCBlbGVtZW50IGNvbnRhaW5pbmcgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBhIGRhdHVtIG5hbWUgYW5kIGFzc29jaWF0ZWQgZGF0YSB2YWx1ZXMuXG5cdFx0XHQgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ29sdW1uT3JpZW50ZWREYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLCAzMCwgMjAsIDUwLCA0MCwgNjAsIDUwXSxcblx0XHRcdCAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcblx0XHRcdCAqICAgICAgW1wiZGF0YTNcIiwgMzAwLCAyMDAsIDE2MCwgNDAwLCAyNTAsIDI1MF1cblx0XHRcdCAqICAgXVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxuXHRcdFx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxuXHRcdFx0ICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcblx0XHRcdCAqIGRhdGE6IHtcblx0XHRcdCAqICAgY29sdW1uczogW1xuXHRcdFx0ICogICAgICBbXCJkYXRhMVwiLFxuXHRcdFx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9XG5cdFx0XHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXG5cdFx0XHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF1cblx0XHRcdCAqICAgICAgXVxuXHRcdFx0ICogICBdLFxuXHRcdFx0ICogICB0eXBlOiBcImFyZWEtbGluZS1yYW5nZVwiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfY29sdW1uczogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFVzZWQgaWYgbG9hZGluZyBKU09OIHZpYSBkYXRhLnVybC5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRtaW1lVHlwZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBkYXRhOiB7XG5cdFx0XHQgKiAgICAgbWltZVR5cGU6IFwianNvblwiXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGRhdGFfbWltZVR5cGU6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3Qga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS5cblx0XHRcdCAqIC0gKipOT1RFOioqIE9ubHkgZm9yIEpTT04gb2JqZWN0IGdpdmVuIGFzIGFycmF5LlxuXHRcdFx0ICogQG5hbWUgZGF0YeKApGtleXNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgIGpzb246IFtcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxuXHRcdFx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUyLmNvbVwiLCB1cGxvYWQ6IDEwMCwgZG93bmxvYWQ6IDMwMCwgdG90YWw6IDQwMH0sXG5cdFx0XHQgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTMuY29tXCIsIHVwbG9hZDogMzAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNTAwfSxcblx0XHRcdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XG5cdFx0XHQgKiAgICAgXSxcblx0XHRcdCAqICAgICBrZXlzOiB7XG5cdFx0XHQgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcblx0XHRcdCAqICAgICAgIHZhbHVlOiBbXCJ1cGxvYWRcIiwgXCJkb3dubG9hZFwiXVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0ZGF0YV9rZXlzOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRleHQgbGFiZWwgdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlcmUncyBubyBkYXRhIHRvIHNob3cuXG5cdFx0XHQgKiAtIGV4LiBUb2dnbGluZyBhbGwgdmlzaWJsZSBkYXRhIHRvIG5vdCBiZSBzaG93biwgdW5sb2FkaW5nIGFsbCBjdXJyZW50IGRhdGEsIGV0Yy5cblx0XHRcdCAqIEBuYW1lIGRhdGHigKRlbXB0eeKApGxhYmVs4oCkdGV4dFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICBlbXB0eToge1xuXHRcdFx0ICogICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICB0ZXh0OiBcIk5vIERhdGFcIlxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRkYXRhX2VtcHR5X2xhYmVsX3RleHQ6IFwiXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHN1YmNoYXJ0IG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIHN1YmNoYXJ0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LnNob3c9ZmFsc2VdIFNob3cgc3ViIGNoYXJ0IG9uIHRoZSBib3R0b20gb2YgdGhlIGNoYXJ0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3N1YmNoYXJ0LnNpemUuaGVpZ2h0XSBDaGFuZ2UgdGhlIGhlaWdodCBvZiB0aGUgc3ViY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbc3ViY2hhcnQub25icnVzaF0gU2V0IGNhbGxiYWNrIGZvciBicnVzaCBldmVudC48YnI+XG5cdFx0XHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IHpvb21lZCB4IGRvbWFpbi5cblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5TdWJDaGFydClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgc3ViY2hhcnQ6IHtcblx0XHRcdCAqIFx0XHRheGlzOiB7XG5cdFx0XHQgKiBcdFx0XHR4OiB7XG5cdFx0XHQgKiBcdFx0XHRcdHNob3c6IHRydWUsXG5cdFx0XHQgKiBcdFx0XHRcdHRpY2s6IHtcblx0XHRcdCAqIFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0ICogXHRcdFx0XHRcdHRleHQ6IHtcblx0XHRcdCAqIFx0XHRcdFx0XHRcdHNob3c6IGZhbHNlXG5cdFx0XHQgKiBcdFx0XHRcdFx0fVxuXHRcdFx0ICogXHRcdFx0XHR9XG5cdFx0XHQgKiBcdFx0XHR9XG5cdFx0XHQgKiBcdFx0fSxcblx0XHRcdCAqICAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICAgc2l6ZToge1xuXHRcdFx0ICogICAgICAgICAgaGVpZ2h0OiAyMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBvbmJydXNoOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH1cblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdHN1YmNoYXJ0X3Nob3c6IGZhbHNlLFxuXHRcdFx0c3ViY2hhcnRfc2l6ZV9oZWlnaHQ6IDYwLFxuXHRcdFx0c3ViY2hhcnRfYXhpc194X3Nob3c6IHRydWUsXG5cdFx0XHRzdWJjaGFydF9heGlzX3hfdGlja19zaG93OiB0cnVlLFxuXHRcdFx0c3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxuXHRcdFx0c3ViY2hhcnRfb25icnVzaDogKCkgPT4ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNvbG9yIG9mIHRoZSBkYXRhIHZhbHVlc1xuXHRcdFx0ICogQG5hbWUgY29sb3Jcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBbY29sb3Iub25vdmVyXSBTZXQgdGhlIGNvbG9yIHZhbHVlIGZvciBlYWNoIGRhdGEgcG9pbnQgd2hlbiBtb3VzZS90b3VjaCBvbm92ZXIgZXZlbnQgb2NjdXJzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtBcnJheX0gW2NvbG9yLnBhdHRlcm5dIGN1c3RvbSBjb2xvciBwYXR0ZXJuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY29sb3IudGlsZXNdIGlmIGRlZmluZWQsIGFsbG93cyB1c2Ugc3ZnJ3MgcGF0dGVybnMgdG8gZmlsbCBkYXRhIGFyZWEuIEl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgW1NWR1BhdHRlcm5FbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHUGF0dGVybkVsZW1lbnQpLlxuXHRcdFx0ICogIC0gKipOT1RFOioqIFRoZSBwYXR0ZXJuIGVsZW1lbnQncyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgYGJiLWNvbG9yaXplLXBhdHRlcm4tJENPTE9SLVZBTFVFYC48YnI+XG5cdFx0XHQgKiAgICBleC4gV2hlbiBjb2xvciBwYXR0ZXJuIHZhbHVlIGlzIGBbJ3JlZCcsICcjZmZmJ11gIGFuZCBkZWZpbmVkIDIgcGF0dGVybnMsdGhlbiBpZHMgZm9yIHBhdHRlcm4gZWxlbWVudHMgYXJlOjxicj5cblx0XHRcdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tcmVkYFxuXHRcdFx0ICogICAgLSBgYmItY29sb3JpemUtcGF0dGVybi1mZmZgXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW2NvbG9yLnRocmVzaG9sZF0gY29sb3IgdGhyZXNob2xkIGZvciBnYXVnZSBhbmQgdG9vbHRpcCBjb2xvclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb2xvci50aHJlc2hvbGQudW5pdF0gSWYgc2V0IHRvIGB2YWx1ZWAsIHRoZSB0aHJlc2hvbGQgd2lsbCBiZSBiYXNlZCBvbiB0aGUgZGF0YSB2YWx1ZS4gT3RoZXJ3aXNlIGl0J2xsIGJlIGJhc2VkIG9uIGVxdWF0aW9uIG9mIHRoZSBgdGhyZXNob2xkLm1heGAgb3B0aW9uIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtBcnJheX0gW2NvbG9yLnRocmVzaG9sZC52YWx1ZXNdIFRocmVzaG9sZCB2YWx1ZXMgZm9yIGVhY2ggc3RlcHNcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29sb3IudGhyZXNob2xkLm1heD0xMDBdIFRoZSBiYXNlIHZhbHVlIHRvIGRldGVybWluZSB0aHJlc2hvbGQgc3RlcCB2YWx1ZSBjb25kaXRpb24uIFdoZW4gdGhlIGdpdmVuIHZhbHVlIGlzIDE1IGFuZCBtYXggMTAsIHRoZW4gdGhlIHZhbHVlIGZvciB0aHJlc2hvbGQgaXMgYDE1KjEwMC8xMGAuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGNvbG9yOiB7XG5cdFx0XHQgKiAgICAgIHBhdHRlcm46IFtcIiMxZjc3YjRcIiwgXCIjYWVjN2U4XCIsIC4uLl0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBTZXQgY29sb3JzJyBwYXR0ZXJuc1xuXHRcdFx0ICogICAgICAvLyBpdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFNWR1BhdHRlcm5FbGVtZW50XG5cdFx0XHQgKiAgICAgIHRpbGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgICAgdmFyIHBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdHRlcm5cIik7XG5cdFx0XHQgKiAgICAgICAgIHZhciBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuXHRcdFx0ICogICAgICAgICB2YXIgY2lyY2xlMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcblx0XHRcdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjMyXCIpO1xuXHRcdFx0ICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjMyXCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgZy5zdHlsZS5maWxsID0gXCIjMDAwXCI7XG5cdFx0XHQgKiAgICAgICAgIGcuc3R5bGUub3BhY2l0eSA9IFwiMC4yXCI7XG4gICAgICAgICAgICAgKlxuXHRcdFx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN4XCIsIFwiM1wiKTtcblx0XHRcdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBcIjNcIik7XG5cdFx0XHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiclwiLCBcIjNcIik7XG4gICAgICAgICAgICAgKlxuXHRcdFx0ICogICAgICAgICBnLmFwcGVuZENoaWxkKGNpcmNsZTEpO1xuXHRcdFx0ICogICAgICAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGcpO1xuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuXTtcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGZvciB0aHJlc2hvbGQgdXNhZ2UsIHBhdHRlcm4gdmFsdWVzIHNob3VsZCBiZSBzZXQgZm9yIGVhY2ggc3RlcHNcblx0XHRcdCAqICAgICAgcGF0dGVybjogW1wiZ3JleVwiLCBcImdyZWVuXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxuXHRcdFx0ICogICAgICB0aHJlc2hvbGQ6IHtcblx0XHRcdCAqICAgICAgICAgIHVuaXQ6IFwidmFsdWVcIixcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyB3aGVuIHZhbHVlIGlzIDIwID0+ICdncmVlbicsIHZhbHVlIGlzIDQwID0+ICdvcmFuZ2UnIHdpbGwgYmUgc2V0LlxuXHRcdFx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMCwgNDAsIDUwXSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAvLyB0aGUgZXF1YXRpb24gZm9yIG1heDpcblx0XHRcdCAqICAgICAgICAgIC8vIC0gdW5pdCA9PSAndmFsdWUnOiBtYXggPT4gMzBcblx0XHRcdCAqICAgICAgICAgIC8vIC0gdW5pdCAhPSAndmFsdWUnOiBtYXggPT4gdmFsdWUqMTAwLzMwXG5cdFx0XHQgKiAgICAgICAgICBtYXg6IDMwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgYWxsIGRhdGEgdG8gJ3JlZCdcblx0XHRcdCAqICAgICAgb25vdmVyOiBcInJlZFwiLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc2V0IGRpZmZlcmVudCBjb2xvciBmb3IgZGF0YVxuXHRcdFx0ICogICAgICBvbm92ZXI6IHtcblx0XHRcdCAqICAgICAgICAgIGRhdGExOiBcInJlZFwiLFxuXHRcdFx0ICogICAgICAgICAgZGF0YTI6IFwieWVsbG93XCJcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHdpbGwgcGFzcyBkYXRhIG9iamVjdCB0byB0aGUgY2FsbGJhY2tcblx0XHRcdCAqICAgICAgb25vdmVyOiBmdW5jdGlvbihkKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gXCJkYXRhMVwiID8gXCJyZWRcIiA6IFwiZ3JlZW5cIjtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0Y29sb3JfcGF0dGVybjogW10sXG5cdFx0XHRjb2xvcl90aWxlczogdW5kZWZpbmVkLFxuXHRcdFx0Y29sb3JfdGhyZXNob2xkOiB7fSxcblx0XHRcdGNvbG9yX29ub3ZlcjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExlZ2VuZCBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBsZWdlbmRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxlZ2VuZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5oaWRlPWZhbHNlXSBIaWRlIGxlZ2VuZFxuXHRcdFx0ICogIElmIHRydWUgZ2l2ZW4sIGFsbCBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uIElmIHN0cmluZyBvciBhcnJheSBnaXZlbiwgb25seSB0aGUgbGVnZW5kIHRoYXQgaGFzIHRoZSBpZCB3aWxsIGJlIGhpZGRlbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fSBbbGVnZW5kLmNvbnRlbnRzLmJpbmR0bz11bmRlZmluZWRdIFNldCBDU1Mgc2VsZWN0b3Igb3IgZWxlbWVudCByZWZlcmVuY2UgdG8gYmluZCBsZWdlbmQgaXRlbXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbn0gW2xlZ2VuZC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCBpdGVtJ3MgdGVtcGxhdGUuPGJyPlxuXHRcdFx0ICogIC0gSWYgc2V0IGBzdHJpbmdgIHZhbHVlLCB3aXRoaW4gdGVtcGxhdGUgdGhlICdjb2xvcicgYW5kICd0aXRsZScgY2FuIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcblx0XHRcdCAqICAgIC0gez1DT0xPUn06IGRhdGEgY29sb3IgdmFsdWVcblx0XHRcdCAqICAgIC0gez1USVRMRX06IGRhdGEgdGl0bGUgdmFsdWVcblx0XHRcdCAqICAtIElmIHNldCBgZnVuY3Rpb25gIHZhbHVlLCB3aWxsIHBhc3MgZm9sbG93aW5nIGFyZ3VtZW50cyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb246XG5cdFx0XHQgKiAgIC0gdGl0bGUge1N0cmluZ306IGRhdGEncyBpZCB2YWx1ZVxuXHRcdFx0ICogICAtIGNvbG9yIHtTdHJpbmd9OiBjb2xvciBzdHJpbmdcblx0XHRcdCAqICAgLSBkYXRhIHtBcnJheX06IGRhdGEgYXJyYXlcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbGVnZW5kLnBvc2l0aW9uPWJvdHRvbV0gQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiBsZWdlbmQuPGJyPlxuXHRcdFx0ICogIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiBgYm90dG9tYCwgYHJpZ2h0YCBhbmQgYGluc2V0YCBhcmUgc3VwcG9ydGVkLlxuXHRcdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IFtsZWdlbmQuaW5zZXQ9e2FuY2hvcjogJ3RvcC1sZWZ0Jyx4OiAxMCx5OiAwLHN0ZXA6IHVuZGVmaW5lZH1dIENoYW5nZSBpbnNldCBsZWdlbmQgYXR0cmlidXRlcy48YnI+XG5cdFx0XHQgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgdGhhdCBoYXMgdGhlIGtleXMgYGFuY2hvcmAsIGB4YCwgYHlgIGFuZCBgc3RlcGAuXG5cdFx0XHQgKiAgLSAqKmFuY2hvcioqIGRlY2lkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQ6XG5cdFx0XHQgKiAgIC0gdG9wLWxlZnRcblx0XHRcdCAqICAgLSB0b3AtcmlnaHRcblx0XHRcdCAqICAgLSBib3R0b20tbGVmdFxuXHRcdFx0ICogICAtIGJvdHRvbS1yaWdodFxuXHRcdFx0ICogIC0gKip4KiogYW5kICoqeSoqOlxuXHRcdFx0ICogICAtIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBiYXNlZCBvbiB0aGUgYW5jaG9yLlxuXHRcdFx0ICogIC0gKipzdGVwKio6XG5cdFx0XHQgKiAgIC0gZGVmaW5lcyB0aGUgbWF4IHN0ZXAgdGhlIGxlZ2VuZCBoYXMgKGUuZy4gSWYgMiBzZXQgYW5kIGxlZ2VuZCBoYXMgMyBsZWdlbmQgaXRlbSwgdGhlIGxlZ2VuZCAyIGNvbHVtbnMpLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLmVxdWFsbHk9ZmFsc2VdIFNldCB0byBhbGwgaXRlbXMgaGF2ZSBzYW1lIHdpZHRoIHNpemUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQucGFkZGluZz0wXSBTZXQgcGFkZGluZyB2YWx1ZVxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9uY2xpY2s9dW5kZWZpbmVkXSBTZXQgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdmVyPXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdXQ9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3V0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLndpZHRoPTEwXSBTZXQgd2lkdGggb2YgaXRlbSB0aWxlIGVsZW1lbnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS5oZWlnaHQ9MTBdIFNldCBoZWlnaHQgb2YgaXRlbSB0aWxlIGVsZW1lbnRcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC51c2VQb2ludD1mYWxzZV0gV2hldGhlciB0byB1c2UgY3VzdG9tIHBvaW50cyBpbiBsZWdlbmQuXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBwb3NpdGlvbl0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC5MZWdlbmRQb3NpdGlvbilcblx0XHRcdCAqIEBzZWUgW0RlbW86IGNvbnRlbnRzLnRlbXBsYXRlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFRlbXBsYXRlMSlcblx0XHRcdCAqIEBzZWUgW0RlbW86IHVzZVBvaW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLnVzZVBvaW50KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBsZWdlbmQ6IHtcblx0XHRcdCAqICAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICAgaGlkZTogdHJ1ZSxcblx0XHRcdCAqICAgICAgLy9vciBoaWRlOiBcImRhdGExXCJcbiAgICAgICAgICAgICAqICAgICAgLy9vciBoaWRlOiBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXG5cdFx0XHQgKiAgICAgIGNvbnRlbnRzOiB7XG5cdFx0XHQgKiAgICAgICAgICBiaW5kdG86IFwiI2xlZ2VuZFwiLCAgIC8vIDx1bCBpZD0nbGVnZW5kJz48L3VsPlxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgIC8vIHdpbGwgYmUgYXM6IDxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjojMWY3N2I0Jz5kYXRhMTwvbGk+XG5cdFx0XHQgKiAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6ez1DT0xPUn0nPns9VElUTEV9PC9saT5cIlxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgICAgIC8vIG9yIHVzaW5nIGZ1bmN0aW9uXG5cdFx0XHQgKiAgICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oaWQsIGNvbG9yLCBkYXRhKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgIC8vIGlmIHlvdSB3YW50IG9taXQgc29tZSBsZWdlbmQsIHJldHVybiBmYWxzeSB2YWx1ZVxuXHRcdFx0ICogICAgICAgICAgICAgICBpZiAodGl0bGUgIT09IFwiZGF0YTFcIikge1xuXHRcdFx0ICogICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpcIisgY29sb3IgK1wiPlwiKyB0aXRsZSArXCI8L2xpPlwiO1xuXHRcdFx0ICogICAgICAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG4gICAgICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLCAgLy8gYm90dG9tLCByaWdodCwgaW5zZXRcblx0XHRcdCAqICAgICAgaW5zZXQ6IHtcblx0XHRcdCAqICAgICAgICAgIGFuY2hvcjogXCJ0b3AtcmlnaHRcIiAgLy8gdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodFxuXHRcdFx0ICogICAgICAgICAgeDogMjAsXG5cdFx0XHQgKiAgICAgICAgICB5OiAxMCxcblx0XHRcdCAqICAgICAgICAgIHN0ZXA6IDJcblx0XHRcdCAqICAgICAgfSxcbiAgICAgICAgICAgICAqICAgICAgZXF1YWxseTogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgICogICAgICBpdGVtOiB7XG5cdFx0XHQgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcblx0XHRcdCAqICAgICAgICAgIG9ub3ZlcjogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgICAgICBvbm91dDogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gc2V0IHRpbGUncyBzaXplXG5cdFx0XHQgKiAgICAgICAgICB0aWxlOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgd2lkdGg6IDIwLFxuXHRcdFx0ICogICAgICAgICAgICAgIGhlaWdodDogMTVcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgdXNlUG9pbnQ6IHRydWVcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGxlZ2VuZF9zaG93OiB0cnVlLFxuXHRcdFx0bGVnZW5kX2hpZGU6IGZhbHNlLFxuXHRcdFx0bGVnZW5kX2NvbnRlbnRzX2JpbmR0bzogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlOiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfcG9zaXRpb246IFwiYm90dG9tXCIsXG5cdFx0XHRsZWdlbmRfaW5zZXRfYW5jaG9yOiBcInRvcC1sZWZ0XCIsXG5cdFx0XHRsZWdlbmRfaW5zZXRfeDogMTAsXG5cdFx0XHRsZWdlbmRfaW5zZXRfeTogMTAsXG5cdFx0XHRsZWdlbmRfaW5zZXRfc3RlcDogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX2l0ZW1fb25jbGljazogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX2l0ZW1fb25vdmVyOiB1bmRlZmluZWQsXG5cdFx0XHRsZWdlbmRfaXRlbV9vbm91dDogdW5kZWZpbmVkLFxuXHRcdFx0bGVnZW5kX2VxdWFsbHk6IGZhbHNlLFxuXHRcdFx0bGVnZW5kX3BhZGRpbmc6IDAsXG5cdFx0XHRsZWdlbmRfaXRlbV90aWxlX3dpZHRoOiAxMCxcblx0XHRcdGxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0OiAxMCxcblx0XHRcdGxlZ2VuZF91c2VQb2ludDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3dpdGNoIHggYW5kIHkgYXhpcyBwb3NpdGlvbi5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKRyb3RhdGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgcm90YXRlZDogdHJ1ZVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3JvdGF0ZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB4IGF4aXMgZWxlbWVudFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRjbGlwUGF0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcblx0XHRcdCAqIGNsaXBQYXRoOiBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfY2xpcFBhdGg6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHggYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHR5cGUgb2YgeCBheGlzLjxicj48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqIC0gdGltZXNlcmllc1xuXHRcdFx0ICogLSBjYXRlZ29yeVxuXHRcdFx0ICogLSBpbmRleGVkXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgaW5kZXhlZFxuXHRcdFx0ICogQHNlZSBbRGVtbzogaW5kZXhlZF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcblx0XHRcdCAqIEBzZWUgW0RlbW86IHRpbWVzZXJpZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5UaW1lc2VyaWVzQ2hhcnQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3R5cGU6IFwiaW5kZXhlZFwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBob3cgdG8gdHJlYXQgdGhlIHRpbWV6b25lIG9mIHggdmFsdWVzLjxicj5cblx0XHRcdCAqIElmIHRydWUsIHRyZWF0IHggdmFsdWUgYXMgbG9jYWx0aW1lLiBJZiBmYWxzZSwgY29udmVydCB0byBVVEMgaW50ZXJuYWxseS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkbG9jYWx0aW1lXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgbG9jYWx0aW1lOiBmYWxzZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9sb2NhbHRpbWU6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXG5cdFx0XHQgKiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkY2F0ZWdvcmllc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IFtdXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgY2F0ZWdvcmllczogW1wiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9jYXRlZ29yaWVzOiBbXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBjZW50ZXJpemUgdGlja3Mgb24gY2F0ZWdvcnkgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNlbnRlcmVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNlbnRlcmVkOiB0cnVlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2NlbnRlcmVkOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aWNrIHZhbHVlLiBGb3JtYXQgc3RyaW5nIGlzIGFsc28gYXZhaWxhYmxlIGZvciB0aW1lc2VyaWVzIGRhdGEuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRmb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICAgLy8gZm9yIHRpbWVzZXJpZXMsIGEgJ2RhdGV0aW1lJyBvYmplY3QgaXMgZ2l2ZW4gYXMgcGFyYW1ldGVyXG5cdFx0XHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgIC8vIGZvciBjYXRlZ29yeSwgaW5kZXgoTnVtYmVyKSBhbmQgY2F0ZWdvcnlOYW1lKFN0cmluZykgYXJlIGdpdmVuIGFzIHBhcmFtZXRlclxuXHRcdFx0ICogICAgICAgZm9ybWF0OiBmdW5jdGlvbihpbmRleCwgY2F0ZWdvcnlOYW1lKSB7XG5cdFx0XHQgKiAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5TmFtZS5zdWJzdHIoMCwgMTApO1xuXHRcdFx0ICogICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gZm9yIHRpbWVzZXJpZXMgZm9ybWF0IHNwZWNpZmllclxuXHRcdFx0ICogICAgICAgIGZvcm1hdDogXCIlWS0lbS0lZCAlSDolTTolU1wiXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2Zvcm1hdDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cblx0XHRcdCAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxuXHRcdFx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueC50aWNrLmN1bGxpbmcubWF4LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY3VsbGluZ1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHRcblx0XHRcdCAqIC0gdHJ1ZSBmb3IgaW5kZXhlZCBheGlzIGFuZCB0aW1lc2VyaWVzIGF4aXNcblx0XHRcdCAqIC0gZmFsc2UgZm9yIGNhdGVnb3J5IGF4aXNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19jdWxsaW5nOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmfigKRtYXhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgMTBcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjdWxsaW5nOiB7XG5cdFx0XHQgKiAgICAgICAgICAgbWF4OiA1XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2N1bGxpbmdfbWF4OiAxMCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgbnVtYmVyIG9mIHggYXhpcyB0aWNrcyB0byBzaG93Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBoaWRlcyB0aWNrIGxpbmVzIHRvZ2V0aGVyIHdpdGggdGljayB0ZXh0LiBJZiB0aGlzIG9wdGlvbiBpcyB1c2VkIG9uIHRpbWVzZXJpZXMgYXhpcywgdGhlIHRpY2tzIHBvc2l0aW9uIHdpbGwgYmUgZGV0ZXJtaW5lZCBwcmVjaXNlbHkgYW5kIG5vdCBuaWNlbHkgcG9zaXRpb25lZCAoZS5nLiBpdCB3aWxsIGhhdmUgcm91Z2ggc2Vjb25kIHZhbHVlKS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNvdW50XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNvdW50OiA1XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2NvdW50OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0ZXh04oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgICAgIH1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgeCBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0ZXh04oCkcG9zaXRpb25cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge3g6IDAsIHk6MH1cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgIHBvc2l0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICAgeDogMTAsXG5cdFx0XHQgKiAgICAgICAgICAgeTogMTBcblx0XHRcdCAqICAgICAgICAgfVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja190ZXh0X3Bvc2l0aW9uOiB7eDogMCwgeTogMH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRml0IHggYXhpcyB0aWNrcy5cblx0XHRcdCAqIC0gKip0cnVlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBuaWNlbHkgdG8gaGF2ZSBzYW1lIGludGVydmFscy5cblx0XHRcdCAqIC0gKipmYWxzZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgYWNjb3JkaW5nIHRvIHggdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZml0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tGaXR0aW5nKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogZm9yIHRpbWVzZXJpZXMgem9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrVGltZXNlcmllcylcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBmaXQ6IGZhbHNlXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF90aWNrX2ZpdDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIHggdmFsdWVzIG9mIHRpY2tzIG1hbnVhbGx5Ljxicj48YnI+XG5cdFx0XHQgKiBJZiB0aGlzIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGRldGVybWluZWQgYmFzZWQgb24gdGhvc2UgdmFsdWVzLiBUaGlzIG9wdGlvbiB3b3JrcyB3aXRoIHRpbWVzZXJpZXMgZGF0YSBhbmQgdGhlIHggdmFsdWVzIHdpbGwgYmUgcGFyc2VkIGFjY29kaW5nIHRvIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBhbmQgZGF0YS54Rm9ybWF0IG9wdGlvbi5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHZhbHVlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB2YWx1ZXM6IFsxLCAyLCA0LCA4LCAxNiwgMzIsIC4uLl1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfdmFsdWVzOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0Ljxicj5cblx0XHRcdCAqIElmIHlvdSBzZXQgbmVnYXRpdmUgdmFsdWUsIGl0IHdpbGwgcm90YXRlIHRvIG9wcG9zaXRlIGRpcmVjdGlvbi5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHJvdGF0ZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5Sb3RhdGVYQXhpc1RpY2tUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHJvdGF0ZTogNjBcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfcm90YXRlOiAwLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgeCBheGlzIG91dGVyIHRpY2suXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRvdXRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIG91dGVyOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja19vdXRlcjogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGljayB0ZXh0IHRvIGJlIG11bHRpbGluZVxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFuZCAnYXhpcy54LnRpY2sud2lkdGgnIG9wdGlvbiBpcyBpZ25vcmVkLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkbXVsdGlsaW5lXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tNdWx0aWxpbmUpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgbXVsdGlsaW5lOiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIGV4YW1wbGUgb2YgbGluZSBicmVhayB3aXRoICdcXG4nXG5cdFx0XHQgKiAvLyBJbiB0aGlzIGNhc2UsICdheGlzLngudGljay53aWR0aCcgaXMgaWdub3JlZFxuXHRcdFx0ICogZGF0YToge1xuXHRcdFx0ICogICAgeDogXCJ4XCIsXG5cdFx0XHQgKiAgICBjb2x1bW5zOiBbXG5cdFx0XHQgKiAgICAgICAgW1wieFwiLCBcImxvbmdcXG50ZXh0XCIsIFwiQW5vdGhlclxcbkxvbmdcXG5UZXh0XCJdLFxuXHRcdFx0ICogICAgICAgIC4uLlxuXHRcdFx0ICogICAgXSxcblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X3RpY2tfbXVsdGlsaW5lOiB0cnVlLFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRpY2sgd2lkdGhcblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkd2lkdGhcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHdpZHRoOiA1MFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja193aWR0aDogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdG8gZGlzcGxheSBzeXN0ZW0gdG9vbHRpcCh2aWEgJ3RpdGxlJyBhdHRyaWJ1dGUpIGZvciB0aWNrIHRleHRcblx0XHRcdCAqIC0gKipOT1RFOioqIE9ubHkgYXZhaWxhYmxlIGZvciBjYXRlZ29yeSBheGlzIHR5cGUgKGBheGlzLngudHlwZT0nY2F0ZWdvcnknYClcblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRvb2x0aXBcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdG9vbHRpcDogdHJ1ZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfdGlja190b29sdGlwOiBmYWxzZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWF4IHZhbHVlIG9mIHggYXhpcyByYW5nZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIG1heDogMTAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X21heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtaW4gdmFsdWUgb2YgeCBheGlzIHJhbmdlLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRtaW5cblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB4OiB7XG5cdFx0XHQgKiAgICAgbWluOiAtMTAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X21pbjogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwYWRkaW5nIGZvciB4IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHJhbmdlIG9mIHggYXhpcyB3aWxsIGluY3JlYXNlL2RlY3JlYXNlIGFjY29yZGluZyB0byB0aGUgdmFsdWVzLlxuXHRcdFx0ICogSWYgbm8gcGFkZGluZyBpcyBuZWVkZWQgaW4gdGhlIHJhZ2Ugb2YgeCBheGlzLCAwIHNob3VsZCBiZSBzZXQuXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogICBUaGUgcGFkZGluZyB2YWx1ZXMgYXJlbid0IGJhc2VkIG9uIHBpeGVscy4gSXQgZGlmZmVycyBhY2NvcmRpbmcgYXhpcyB0eXBlczxicj5cblx0XHRcdCAqICAgLSAqKmNhdGVnb3J5OioqIFRoZSB1bml0IG9mIHRpY2sgdmFsdWVcblx0XHRcdCAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxYCwgaXMgc2FtZSBhcyB0aGUgd2lkdGggb2YgMSB0aWNrIHdpZHRoXG5cdFx0XHQgKiAgIC0gKip0aW1lc2VyaWVzOioqIE51bWVyaWMgdGltZSB2YWx1ZVxuXHRcdFx0ICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDEwMDAqNjAqNjAqMjRgLCB3aGljaCBpcyBudW1lcmljIHRpbWUgZXF1aXZhbGVudCBvZiBhIGRheSwgaXMgc2FtZSBhcyB0aGUgd2lkdGggb2YgMSB0aWNrIHdpZHRoXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeOKApHBhZGRpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICBwYWRkaW5nOiB7XG5cdFx0XHQgKiAgICAgICAvLyB3aGVuIGF4aXMgdHlwZSBpcyAnY2F0ZWdvcnknXG5cdFx0XHQgKiAgICAgICBsZWZ0OiAxLCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgdGljaydzIHdpZHRoXG5cdFx0XHQgKiAgICAgICByaWdodDogMC41ICAvLyBzZXQgcmlnaHQgcGFkZGluZyB3aWR0aCBhcyBoYWxmIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgdGljaydzIHdpZHRoXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ3RpbWVzZXJpZXMnXG5cdFx0XHQgKiAgICAgICBsZWZ0OiAxMDAwKjYwKjYwKjI0LCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgZGF5IHRpY2sncyB3aWR0aFxuXHRcdFx0ICogICAgICAgcmlnaHQ6IDEwMDAqNjAqNjAqMTIgICAvLyBzZXQgcmlnaHQgcGFkZGluZyB3aWR0aCBhcyBoYWxmIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9wYWRkaW5nOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgaGVpZ2h0IG9mIHggYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogVGhlIGhlaWdodCBvZiB4IGF4aXMgY2FuIGJlIHNldCBtYW51YWxseSBieSB0aGlzIG9wdGlvbi4gSWYgeW91IG5lZWQgbW9yZSBzcGFjZSBmb3IgeCBheGlzLCBwbGVhc2UgdXNlIHRoaXMgb3B0aW9uIGZvciB0aGF0LiBUaGUgdW5pdCBpcyBwaXhlbC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkaGVpZ2h0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGhlaWdodDogMjBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3hfaGVpZ2h0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGRlZmF1bHQgZXh0ZW50IGZvciBzdWJjaGFydCBhbmQgem9vbS4gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRleHRlbnRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHg6IHtcblx0XHRcdCAqICAgICAvLyBleHRlbnQgcmFuZ2UgYXMgYSBwaXhlbCB2YWx1ZVxuXHRcdFx0ICogICAgIGV4dGVudDogWzAsIDIwMF0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIHdoZW4gYXhpcyBpcyAndGltZXNlcmllcycsIHBhcnNhYmxlIGRhdGV0aW1lIHN0cmluZ1xuXHRcdFx0ICogICAgIGV4dGVudDogW1wiMjAxOS0wMy0wMVwiLCBcIjIwMTktMDMtMDVcIl0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgIC8vIHJldHVybiBleHRlbnQgdmFsdWVcblx0XHRcdCAqICAgICBleHRlbnQ6IGZ1bmN0aW9uKGRvbWFpbiwgc2NhbGUpIHtcblx0XHRcdCAqICAgIFx0IHZhciBleHRlbnQgPSBkb21haW4ubWFwKGZ1bmN0aW9uKHYpIHtcblx0XHRcdCAqICAgICBcdCAgICByZXR1cm4gc2NhbGUodik7XG5cdFx0XHQgKiAgICAgXHQgfSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogICBcdCAvLyBpdCBzaG91bGQgcmV0dXJuIGEgZm9ybWF0IG9mIGFycmF5XG5cdFx0XHQgKiAgIFx0IC8vIGV4KSBbMCwgNTg0XVxuXHRcdFx0ICogICAgIFx0IHJldHVybiBleHRlbnQ7XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9leHRlbnQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbGFiZWwgb24geCBheGlzLjxicj48YnI+XG5cdFx0XHQgKiAgWW91IGNhbiBzZXQgeCBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBzdHJpbmcgYW5kIG9iamVjdCBjYW4gYmUgcGFzc2VkIGFuZCB3ZSBjYW4gY2hhbmdlIHRoZSBwb2lzaXRvbiBieSBwYXNzaW5nIG9iamVjdCB0aGF0IGhhcyBwb3NpdGlvbiBrZXkuIEF2YWlsYWJsZSBwb3NpdGlvbiBkaWZmZXJzIGFjY29yZGluZyB0byB0aGUgYXhpcyBkaXJlY3Rpb24gKHZlcnRpY2FsIG9yIGhvcml6b250YWwpLiBJZiBzdHJpbmcgc2V0LCB0aGUgcG9zaXRpb24gd2lsbCBiZSB0aGUgZGVmYXVsdC5cblx0XHRcdCAqICAtICoqSWYgaXQncyBob3Jpem9udGFsIGF4aXM6Kipcblx0XHRcdCAqICAgIC0gaW5uZXItcmlnaHQgW2RlZmF1bHRdXG5cdFx0XHQgKiAgICAtIGlubmVyLWNlbnRlclxuXHRcdFx0ICogICAgLSBpbm5lci1sZWZ0XG5cdFx0XHQgKiAgICAtIG91dGVyLXJpZ2h0XG5cdFx0XHQgKiAgICAtIG91dGVyLWNlbnRlclxuXHRcdFx0ICogICAgLSBvdXRlci1sZWZ0XG5cdFx0XHQgKiAgLSAqKklmIGl0J3MgdmVydGljYWwgYXhpczoqKlxuXHRcdFx0ICogICAgLSBpbm5lci10b3AgW2RlZmF1bHRdXG5cdFx0XHQgKiAgICAtIGlubmVyLW1pZGRsZVxuXHRcdFx0ICogICAgLSBpbm5lci1ib3R0b21cblx0XHRcdCAqICAgIC0gb3V0ZXItdG9wXG5cdFx0XHQgKiAgICAtIG91dGVyLW1pZGRsZVxuXHRcdFx0ICogICAgLSBvdXRlci1ib3R0b21cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR44oCkbGFiZWxcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGxhYmVsOiBcIllvdXIgWCBBeGlzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICpcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFggQXhpc1wiLFxuXHRcdFx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLWNlbnRlclwiXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeF9sYWJlbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeCBBeGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxuXHRcdFx0ICpcblx0XHRcdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxuXHRcdFx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHRcdFx0ICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxuXHRcdFx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XG5cdFx0XHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcblx0XHRcdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHjigKRheGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHg6IHtcblx0XHRcdCAqICAgIGF4ZXM6IFtcblx0XHRcdCAqICAgICAge1xuXHRcdFx0ICogICAgICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICBjb3VudDogMixcblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICAuLi5cblx0XHRcdCAqICAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc194X2F4ZXM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjbGlwLXBhdGggYXR0cmlidXRlIGZvciB5IGF4aXMgZWxlbWVudFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRjbGlwUGF0aFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcblx0XHRcdCAqIGNsaXBQYXRoOiBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfY2xpcFBhdGg6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHR5cGUgb2YgeSBheGlzLjxicj48YnI+XG5cdFx0XHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAgLSB0aW1lc2VyaWVzXG5cdFx0XHQgKiAgIC0gY2F0ZWdvcnlcblx0XHRcdCAqICAgLSBpbmRleGVkXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHR5cGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdHlwZTogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtYXggdmFsdWUgb2YgeSBheGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIG1heDogMTAwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9tYXg6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgbWluIHZhbHVlIG9mIHkgYXhpcy5cblx0XHRcdCAqIC0gKipOT1RFOioqXG5cdFx0XHQgKiAgIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApG1pblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBtaW46IDEwMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfbWluOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeSBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRpbnZlcnRlZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9pbnZlcnRlZDogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5IGF4aXMuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICBjZW50ZXI6IDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfY2VudGVyOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyB5IGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkaW5uZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgaW5uZXI6IHRydWVcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfaW5uZXI6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBsYWJlbCBvbiB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFlvdSBjYW4gc2V0IHkgYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi4gVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueC5sYWJlbC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkbGFiZWxcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IFwiWW91ciBZIEF4aXNcIlxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKlxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWSBBeGlzXCIsXG5cdFx0XHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2xhYmVsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgZm9ybWF0dGVyIGZvciB5IGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRmb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IHkgYXhpcyBvdXRlciB0aWNrLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkb3V0ZXJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBvdXRlcjogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X3RpY2tfb3V0ZXI6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHkgYXhpcyB0aWNrIHZhbHVlcyBtYW51YWxseS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHZhbHVlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja192YWx1ZXM6IG51bGwsXG5cdFx0XHRheGlzX3lfdGlja19yb3RhdGU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XG5cdFx0XHQgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjb3VudFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBjb3VudDogNVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19jb3VudDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB5IGF4aXMgdGljayBsaW5lLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfdGlja19zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIHRleHQuXG5cdFx0XHQqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRzaG93XG5cdFx0XHQqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0KiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQqIEBleGFtcGxlXG5cdFx0XHQqIGF4aXM6IHtcblx0XHRcdCogICB5OiB7XG5cdFx0XHQqICAgICB0aWNrOiB7XG5cdFx0XHQqICAgICAgIHRleHQ6IHtcblx0XHRcdCogICAgICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQqICAgICAgIH1cblx0XHRcdCogICAgIH1cblx0XHRcdCogICB9XG5cdFx0XHQqIH1cblx0XHRcdCovXG5cdFx0XHRheGlzX3lfdGlja190ZXh0X3Nob3c6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHRoZSB5IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRwb3NpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICB4OiAxMCxcblx0XHRcdCAqICAgICAgICAgICB5OiAxMFxuXHRcdFx0ICogICAgICAgICB9XG5cdFx0XHQgKiAgICAgICB9XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cblx0XHRcdCAqIC0gKipOT1RFOioqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBjYWxjdWxhdGVkIHByZWNpc2VseSwgc28gdGhlIHZhbHVlcyBvbiB0aGUgdGlja3Mgd2lsbCBub3QgYmUgcm91bmRlZCBuaWNlbHkuIEluIHRoZSBjYXNlLCBheGlzLnkudGljay5mb3JtYXQgb3IgYXhpcy55LnRpY2sudmFsdWVzIHdpbGwgYmUgaGVscGZ1bC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRpbWVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0aW1lLnZhbHVlXSBEMydzIHRpbWUgaW50ZXJ2YWwgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lI2ludGVydmFscylcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHk6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0aW1lOiB7XG5cdFx0XHQgKiAgICAgICAgICAvLyB0aWNrcyBhdCAxNS1taW51dGUgaW50ZXJ2YWxzXG5cdFx0XHQgKiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RpbWVfdGlja3Ncblx0XHRcdCAqICAgICAgICAgIHZhbHVlOiBkMy50aW1lTWludXRlLmV2ZXJ5KDE1KVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHQvLyBAVE9ETzogbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldFxuXHRcdFx0YXhpc195X3RpY2tfdGltZV92YWx1ZTogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwYWRkaW5nIGZvciB5IGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFlvdSBjYW4gc2V0IHBhZGRpbmcgZm9yIHkgYXhpcyB0byBjcmVhdGUgbW9yZSBzcGFjZSBvbiB0aGUgZWRnZSBvZiB0aGUgYXhpcy5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IGFuZCBpdCBjYW4gaW5jbHVkZSB0b3AgYW5kIGJvdHRvbS4gdG9wLCBib3R0b20gd2lsbCBiZSB0cmVhdGVkIGFzIHBpeGVscy5cblx0XHRcdCAqXG5cdFx0XHQgKiAtICoqTk9URToqKiBGb3IgYXJlYSBhbmQgYmFyIHR5cGUgY2hhcnRzLCBbYXJlYS56ZXJvYmFzZWRdKCMuYXJlYSkgb3IgW2Jhci56ZXJvYmFzZWRdKCMuYmFyKSBvcHRpb25zIHNob3VsZCBiZSBzZXQgdG8gJ2ZhbHNlYCB0byBnZXQgcGFkZGVkIGJvdHRvbS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkcGFkZGluZ1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7fVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIHBhZGRpbmc6IHtcblx0XHRcdCAqICAgICAgIHRvcDogMCxcblx0XHRcdCAqICAgICAgIGJvdHRvbTogMFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3lfcGFkZGluZzoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeSBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR54oCkZGVmYXVsdFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeToge1xuXHRcdFx0ICogICAgIGRlZmF1bHQ6IFswLCAxMDAwXVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeV9kZWZhdWx0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeSBBeGlzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geSBBeGlzIHZhbHVlXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxuXHRcdFx0ICpcblx0XHRcdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxuXHRcdFx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHRcdFx0ICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxuXHRcdFx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XG5cdFx0XHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcblx0XHRcdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHnigKRheGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHk6IHtcblx0XHRcdCAqICAgIGF4ZXM6IFtcblx0XHRcdCAqICAgICAge1xuXHRcdFx0ICogICAgICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xuXHRcdFx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcblx0XHRcdCAqICAgICAgICAgIH0sXG5cdFx0XHQgKiAgICAgICAgICBjb3VudDogMixcblx0XHRcdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICAuLi5cblx0XHRcdCAqICAgIF1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195X2F4ZXM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkc2hvd1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgc2hvdzogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfc2hvdzogZmFsc2UsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IG1heCB2YWx1ZSBvZiB5MiBheGlzLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkbWF4XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBtYXg6IDEwMDBcblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX21heDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBtaW4gdmFsdWUgb2YgeTIgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApG1pblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgbWluOiAtMTAwMFxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfbWluOiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeTIgYXhpcy48YnI+PGJyPlxuXHRcdFx0ICogSWYgdHJ1ZSBzZXQsIHRoZSBkaXJlY3Rpb24gd2lsbCBiZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGludmVydGVkXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfaW52ZXJ0ZWQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeTIgYXhpcy5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGNlbnRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgY2VudGVyOiAwXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9jZW50ZXI6IHVuZGVmaW5lZCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IHkyIGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGlubmVyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICBpbm5lcjogdHJ1ZVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfaW5uZXI6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBsYWJlbCBvbiB5MiBheGlzLjxicj48YnI+XG5cdFx0XHQgKiBZb3UgY2FuIHNldCB5MiBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy54LmxhYmVsLlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkbGFiZWxcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIGxhYmVsOiBcIllvdXIgWTIgQXhpc1wiXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgbGFiZWw6IHtcblx0XHRcdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWTIgQXhpc1wiLFxuXHRcdFx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfbGFiZWw6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkyIGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy55LmZvcm1hdC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRmb3JtYXRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgZm9ybWF0OiBkMy5mb3JtYXQoXCIkLFwiKVxuXHRcdFx0ICogICAgICAgLy9vciBmb3JtYXQ6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiJFwiICsgZDsgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfZm9ybWF0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgb3V0ZXIgdGljay5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRvdXRlclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBvdXRlcjogZmFsc2Vcblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX291dGVyOiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB5MiBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHZhbHVlc1xuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgdGljazoge1xuXHRcdFx0ICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF1cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml90aWNrX3ZhbHVlczogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgdGhlIG51bWJlciBvZiB5MiBheGlzIHRpY2tzLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogVGhpcyB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgYXhpcy55LnRpY2suY291bnQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY291bnRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIGNvdW50OiA1XG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogICB9XG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfdGlja19jb3VudDogdW5kZWZpbmVkLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgbGluZS5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzaG93XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfc2hvdzogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyB0aWNrIHRleHQuXG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdGV4dOKApHNob3dcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogYXhpczoge1xuXHRcdFx0ICogICB5Mjoge1xuXHRcdFx0ICogICAgIHRpY2s6IHtcblx0XHRcdCAqICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfdGV4dF9zaG93OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGF4aXM6IHtcblx0XHRcdCAqICAgeTI6IHtcblx0XHRcdCAqICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICB0ZXh0OiB7XG5cdFx0XHQgKiAgICAgICAgIHBvc2l0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICAgeDogMTAsXG5cdFx0XHQgKiAgICAgICAgICAgeTogMTBcblx0XHRcdCAqICAgICAgICAgfVxuXHRcdFx0ICogICAgICAgfVxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aGUgbnVtYmVyIG9mIHkyIGF4aXMgdGlja3MuXG5cdFx0XHQgKiAtICoqTk9URToqKiBUaGlzIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkudGljay5jb3VudC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApHBhZGRpbmdcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQGRlZmF1bHQge31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgcGFkZGluZzoge1xuXHRcdFx0ICogICAgICAgdG9wOiAxMDAsXG5cdFx0XHQgKiAgICAgICBib3R0b206IDEwMFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqICAgfVxuXHRcdFx0ICogfVxuXHRcdFx0ICovXG5cdFx0XHRheGlzX3kyX3BhZGRpbmc6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkyIGF4aXMuPGJyPjxicj5cblx0XHRcdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cblx0XHRcdCAqIEBuYW1lIGF4aXPigKR5MuKApGRlZmF1bHRcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBheGlzOiB7XG5cdFx0XHQgKiAgIHkyOiB7XG5cdFx0XHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0YXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeTIgQXhpcy5cblx0XHRcdCAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkyIEF4aXMgdmFsdWVcblx0XHRcdCAqXG5cdFx0XHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XG5cdFx0XHQgKlxuXHRcdFx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XG5cdFx0XHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdFx0XHQgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XG5cdFx0XHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcblx0XHRcdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxuXHRcdFx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XG5cdFx0XHQgKiBAbmFtZSBheGlz4oCkeTLigKRheGVzXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHkyOiB7XG5cdFx0XHQgKiAgICBheGVzOiBbXG5cdFx0XHQgKiAgICAgIHtcblx0XHRcdCAqICAgICAgICB0aWNrOiB7XG5cdFx0XHQgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXG5cdFx0XHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgY291bnQ6IDIsXG5cdFx0XHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgLi4uXG5cdFx0XHQgKiAgICBdXG5cdFx0XHQgKiB9XG5cdFx0XHQgKi9cblx0XHRcdGF4aXNfeTJfYXhlczogW10sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHJlbGF0ZWQgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgZ3JpZFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmcm9udD1mYWxzZV0gU2V0ICdncmlkICYgZm9jdXMgbGluZXMnIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBncmlkIGxpbmVzIGFuZCBjaGFydCBlbGVtZW50cy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3guc2hvdz1mYWxzZV0gU2hvdyBncmlkcyBhbG9uZyB4IGF4aXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBbeC5saW5lcz1bXV0gU2hvdyBhZGRpdGlvbmFsIGdyaWQgbGluZXMgYWxvbmcgeCBheGlzLjxicj5cblx0XHRcdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXG5cdFx0XHQgKiAgSWYgeCBheGlzIGlzIGNhdGVnb3J5IGF4aXMsIHZhbHVlIGNhbiBiZSBjYXRlZ29yeSBuYW1lLiBJZiB4IGF4aXMgaXMgdGltZXNlcmllcyBheGlzLCB2YWx1ZSBjYW4gYmUgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbeS5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt5LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB5IGF4aXMuPGJyPlxuXHRcdFx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt5LnRpY2tzPTEwXSBOdW1iZXIgb2YgeSBncmlkcyB0byBiZSBzaG93bi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkcyB3aGVuIGZvY3VzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZXMuZnJvbnQ9dHJ1ZV0gU2V0IGdyaWQgbGluZXMgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGNoYXJ0IGVsZW1lbnRzLlxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBYIEdyaWQgTGluZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLk9wdGlvbmFsWEdyaWRMaW5lcylcblx0XHRcdCAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGdyaWQ6IHtcblx0XHRcdCAqICAgeDoge1xuXHRcdFx0ICogICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgbGluZXM6IFtcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogNiwgdGV4dDogXCJMYWJlbCBvbiA2XCIsIHBvc2l0aW9uOiBcInN0YXJ0XCJ9XG5cdFx0XHQgKiAgICAgXVxuXHRcdFx0ICogICB9LFxuXHRcdFx0ICogICB5OiB7XG5cdFx0XHQgKiAgICAgc2hvdzogdHJ1ZSxcblx0XHRcdCAqICAgICBsaW5lczogW1xuXHRcdFx0ICogICAgICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgb24gMTAwXCJ9LFxuXHRcdFx0ICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcblx0XHRcdCAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XG5cdFx0XHQgKiAgICAgXSxcblx0XHRcdCAqICAgICB0aWNrczogNVxuXHRcdFx0ICogICB9LFxuXHRcdFx0ICogICBmcm9udDogdHJ1ZSxcblx0XHRcdCAqICAgZm9jdXM6IHtcblx0XHRcdCAqICAgICAgc2hvdzogZmFsc2Vcblx0XHRcdCAqICAgfSxcblx0XHRcdCAqICAgbGluZXM6IHtcblx0XHRcdCAqICAgICAgZnJvbnQ6IGZhbHNlXG5cdFx0XHQgKiAgIH1cblx0XHRcdCAqIH1cblx0XHRcdCAqL1xuXHRcdFx0Z3JpZF94X3Nob3c6IGZhbHNlLFxuXHRcdFx0Z3JpZF94X3R5cGU6IFwidGlja1wiLFxuXHRcdFx0Z3JpZF94X2xpbmVzOiBbXSxcblx0XHRcdGdyaWRfeV9zaG93OiBmYWxzZSxcblx0XHRcdGdyaWRfeV9saW5lczogW10sXG5cdFx0XHRncmlkX3lfdGlja3M6IDEwLFxuXHRcdFx0Z3JpZF9mb2N1c19zaG93OiB0cnVlLFxuXHRcdFx0Z3JpZF9mcm9udDogZmFsc2UsXG5cdFx0XHRncmlkX2xpbmVzX2Zyb250OiB0cnVlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwb2ludCBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBwb2ludFxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwb2ludC5zaG93PXRydWVdIFdoZXRoZXIgdG8gc2hvdyBlYWNoIHBvaW50IGluIGxpbmUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cblx0XHRcdCAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuZm9jdXMuZXhwYW5kLmVuYWJsZWQ9dHJ1ZV0gV2hldGhlciB0byBleHBhbmQgZWFjaCBwb2ludCBvbiBmb2N1cy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cblx0XHRcdCAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2Vuc2l0aXZpdHk9MTBdIFRoZSBzZW5zdGl2aXR5IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2VsZWN0LnI9cG9pbnQucio0XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBzZWxlY3RlZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cblx0XHRcdCAqICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxuXHRcdFx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGNpcmNsZVxuXHRcdFx0ICogIC0gcmVjdGFuZ2xlXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBbcG9pbnQucGF0dGVybj1bXV0gVGhlIHR5cGUgb2YgcG9pbnQgb3Igc3ZnIHNoYXBlIGFzIHN0cmluZywgdG8gYmUgZHJhd24gZm9yIGVhY2ggbGluZVxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAtIFRoaXMgaXMgYW4gYGV4cGVyaW1lbnRhbGAgZmVhdHVyZSBhbmQgY2FuIGhhdmUgc29tZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cblx0XHRcdCAqICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cblx0XHRcdCAqICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxuXHRcdFx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGNpcmNsZVxuXHRcdFx0ICogIC0gcmVjdGFuZ2xlXG5cdFx0XHQgKiAgLSBzdmcgc2hhcGUgdGFnIGludGVycHJldGVkIGFzIHN0cmluZzxicj5cblx0XHRcdCAqICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBwb2ludCB0eXBlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUG9pbnQuUmVjdGFuZ2xlUG9pbnRzKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBwb2ludDoge1xuXHRcdFx0ICogICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgcjogNSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIGN1c3RvbWl6ZSB0aGUgcmFkaXVzXG5cdFx0XHQgKiAgICAgIHI6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdCAqICAgICAgICAgIC4uLlxuXHRcdFx0ICogICAgICAgICAgcmV0dXJuIHI7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBmb2N1czoge1xuXHRcdFx0ICogICAgICAgICAgZXhwYW5kOiB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcblx0XHRcdCAqICAgICAgICAgICAgICByOiAxXG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHNlbGVjdDoge1xuXHRcdFx0ICogICAgICAgICAgcjogM1xuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gaGF2aW5nIGxvd2VyIHZhbHVlLCBtZWFucyBob3cgY2xvc2VyIHRvIGJlIGZvciBpbnRlcmFjdGlvblxuXHRcdFx0ICogICAgICBzZW5zaXRpdml0eTogMyxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHZhbGlkIHZhbHVlcyBhcmUgXCJjaXJjbGVcIiBvciBcInJlY3RhbmdsZVwiXG5cdFx0XHQgKiAgICAgIHR5cGU6IFwicmVjdGFuZ2xlXCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBpbmRpY2F0ZSBhcyBwYXR0ZXJuXG4gXHRcdFx0ICogICAgICBwYXR0ZXJuOiBbXG4gXHRcdFx0ICogICAgICAgIFwiY2lyY2xlXCIsXG4gXHRcdFx0ICogICAgICAgIFwicmVjdGFuZ2xlXCIsXG4gXHRcdFx0ICogICAgICAgIFwiPHBvbHlnb24gcG9pbnRzPScwIDYgNCAwIC00IDAnPjwvcG9seWdvbj5cIlxuIFx0XHRcdCAqICAgICBdLFxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cG9pbnRfc2hvdzogdHJ1ZSxcblx0XHRcdHBvaW50X3I6IDIuNSxcblx0XHRcdHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcblx0XHRcdHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxuXHRcdFx0cG9pbnRfZm9jdXNfZXhwYW5kX3I6IHVuZGVmaW5lZCxcblx0XHRcdHBvaW50X3BhdHRlcm46IFtdLFxuXHRcdFx0cG9pbnRfc2VsZWN0X3I6IHVuZGVmaW5lZCxcblx0XHRcdHBvaW50X3R5cGU6IFwiY2lyY2xlXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGxpbmUgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgbGluZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLmNvbm5lY3ROdWxsPWZhbHNlXSBTZXQgaWYgbnVsbCBkYXRhIHBvaW50IHdpbGwgYmUgY29ubmVjdGVkIG9yIG5vdC48YnI+XG5cdFx0XHQgKiAgSWYgdHJ1ZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgYmUgY29ubmVjdGVkIHdpdGhvdXQgYW55IGRhdGEgcG9pbnQuIElmIGZhbHNlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBub3QgYmUgY29ubmVjdGVkIGFuZCBnZXQgZW1wdHkuXG5cdFx0XHQgKiBAcHJvcGVydHkge0FycmF5fSAgIFtsaW5lLmNsYXNzZXM9dW5kZWZpbmVkXSBJZiBzZXQsIHVzZWQgdG8gc2V0IGEgY3NzIGNsYXNzIG9uIGVhY2ggbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuc3RlcC50eXBlPXN0ZXBdIENoYW5nZSBzdGVwIHR5cGUgZm9yIHN0ZXAgY2hhcnQuPGJyPlxuXHRcdFx0ICogKipBdmFpbGFibGUgdmFsdWVzOioqXG5cdFx0XHQgKiAtIHN0ZXBcblx0XHRcdCAqIC0gc3RlcC1iZWZvcmVcblx0XHRcdCAqIC0gc3RlcC1hZnRlclxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufEFycmF5fSBbbGluZS5wb2ludD10cnVlXSBTZXQgdG8gZmFsc2UgdG8gbm90IGRyYXcgcG9pbnRzIG9uIGxpbmVjaGFydHMuIE9yIHBhc3MgYW4gYXJyYXkgb2YgbGluZSBpZHMgdG8gZHJhdyBwb2ludHMgZm9yLlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBsaW5lOiB7XG5cdFx0XHQgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxuXHRcdFx0ICogICAgICBjbGFzc2VzOiBbXG5cdFx0XHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MxXCIsXG5cdFx0XHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MyXCJcblx0XHRcdCAqICAgICAgXSxcblx0XHRcdCAqICAgICAgc3RlcDoge1xuXHRcdFx0ICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXG5cdFx0XHQgKiAgICAgIHBvaW50OiBmYWxzZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXG5cdFx0XHQgKiAgICAgIHBvaW50OiBbXG5cdFx0XHQgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxuXHRcdFx0ICogICAgICBdXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcblx0XHRcdGxpbmVfc3RlcF90eXBlOiBcInN0ZXBcIixcblx0XHRcdGxpbmVfY2xhc3NlczogdW5kZWZpbmVkLFxuXHRcdFx0bGluZV9wb2ludDogdHJ1ZSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYmFyIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGJhclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5wYWRkaW5nPTBdIFRoZSBwYWRkaW5nIHBpeGVsIHZhbHVlIGJldHdlZW4gZWFjaCBiYXIuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5yYWRpdXNdIFNldCB0aGUgcmFkaXVzIG9mIGJhciBlZGdlIGluIHBpeGVsLlxuXHRcdFx0ICogLSAqKk5PVEU6KiogV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5yYWRpdXMucmF0aW9dIFNldCB0aGUgcmFkaXVzIHJhdGlvIG9mIGJhciBlZGdlIGluIHJlbGF0aXZlIHRoZSBiYXIncyB3aWR0aC5cbiBcdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGhdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGgucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWVdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGZvciBpbmRpY2F0ZWQgZGF0YXNldCBvbmx5LlxuXHRcdFx0ICogLSAqKk5PVEU6Kipcblx0XHRcdCAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcblx0XHRcdCAqICAgLSBCYXJzIGFyZSBjZW50ZXJlZCBhY2NvZGluZyBpdHMgdG90YWwgd2lkdGggdmFsdWVcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Jhci56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJhciBjaGFydC5cblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciBwYWRkaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclBhZGRpbmcpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aClcblx0XHRcdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aCB2YXJpYW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoVmFyaWFudClcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgYmFyOiB7XG5cdFx0XHQgKiAgICAgIHBhZGRpbmc6IDEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB0aGUgJ3JhZGl1cycgb3B0aW9uIGNhbiBiZSB1c2VkIG9ubHkgZm9yIG5vbi1zdGFja2luZyBiYXJzXG5cdFx0XHQgKiAgICAgIHJhZGl1czogMTAsXG5cdFx0XHQgKiAgICAgIC8vIG9yXG5cdFx0XHQgKiAgICAgIHJhZGl1czoge1xuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuNVxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB3aWxsIG5vdCBoYXZlIG9mZnNldCBiZXR3ZWVuIGVhY2ggYmFyIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuXHRcdFx0ICogICAgICBzZW5zaXRpdml0eTogMCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIHdpZHRoOiAxMCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yXG5cdFx0XHQgKiAgICAgIHdpZHRoOiB7XG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogMC4yLFxuXHRcdFx0ICogICAgICAgICAgbWF4OiAyMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Igc3BlY2lmeSB3aWR0aCBwZXIgZGF0YXNldFxuXHRcdFx0ICogICAgICB3aWR0aDoge1xuXHRcdFx0ICogICAgICAgICAgZGF0YTE6IDIwLFxuXHRcdFx0ICogICAgICAgICAgZGF0YTI6IHtcblx0XHRcdCAqICAgICAgICAgICAgICByYXRpbzogMC4yLFxuXHRcdFx0ICogICAgICAgICAgICAgIG1heDogMjBcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2Vcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGJhcl9wYWRkaW5nOiAwLFxuXHRcdFx0YmFyX3JhZGl1czogdW5kZWZpbmVkLFxuXHRcdFx0YmFyX3JhZGl1c19yYXRpbzogdW5kZWZpbmVkLFxuXHRcdFx0YmFyX3NlbnNpdGl2aXR5OiAyLFxuXHRcdFx0YmFyX3dpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRiYXJfd2lkdGhfcmF0aW86IDAuNixcblx0XHRcdGJhcl93aWR0aF9tYXg6IHVuZGVmaW5lZCxcblx0XHRcdGJhcl96ZXJvYmFzZWQ6IHRydWUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGJ1YmJsZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBidWJibGVcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtidWJibGUubWF4Uj0zNV0gU2V0IHRoZSBtYXggYnViYmxlIHJhZGl1cyB2YWx1ZVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICBidWJibGU6IHtcblx0XHRcdCAqICAgICAgLy8gZXgpIElmIDEwMCBpcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbW9uZyBkYXRhIGJvdW5kLCB0aGUgcmVwcmVzZW50YXRpb24gYnViYmxlIG9mIDEwMCB3aWxsIGhhdmUgcmFkaXVzIG9mIDUwLlxuXHRcdFx0ICogICAgICAvLyBBbmQgdGhlIGxlc3NlciB3aWxsIGhhdmUgcmFkaXVzIHJlbGF0aXZlbHkgZnJvbSB0aGEgbWF4IHZhbHVlLlxuXHRcdFx0ICogICAgICBtYXhSOiA1MCxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIG9yIHNldCByYWRpdXMgY2FsbGJhY2tcblx0XHRcdCAqICAgICAgbWF4UjogZnVuY3Rpb24oZCkge1xuXHRcdFx0ICogICAgICAgICAgLy8gZXguIG9mIGQgcGFyYW0gLSB7eDogRnJpIE9jdCAwNiAyMDE3IDAwOjAwOjAwIEdNVCswOTAwLCB2YWx1ZTogODAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA1fVxuXHRcdFx0ICogICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUgKiAyKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0YnViYmxlX21heFI6IDM1LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBhcmVhIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGFyZWFcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbYXJlYS56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGFyZWEgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthcmVhLmFib3ZlPWZhbHNlXSBTZXQgYmFja2dyb3VuZCBhcmVhIGFib3ZlIHRoZSBkYXRhIGNoYXJ0IGxpbmUuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbYXJlYS5saW5lYXJHcmFkaWVudD1mYWxzZV0gU2V0IHRoZSBsaW5lYXIgZ3JhZGllbnQgb24gYXJlYS48YnI+PGJyPlxuXHRcdFx0ICogT3IgY3VzdG9taXplIGJ5IGdpdmluZyBiZWxvdyBvYmplY3QgdmFsdWU6XG5cdFx0XHQgKiAgLSB4IHtBcnJheX06IGB4MWAsIGB4MmAgdmFsdWVcblx0XHRcdCAqICAtIHkge0FycmF5fTogYHkxYCwgYHkyYCB2YWx1ZVxuXHRcdFx0ICogIC0gc3RvcHMge0FycmF5fTogRWFjaCBpdGVtIHNob3VsZCBiZSBoYXZpbmcgYFtvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eV1gIHZhbHVlcy5cblx0XHRcdCAqIEBzZWUgW01ETidzICZsdDtsaW5lYXJHcmFkaWVudD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2xpbmVhckdyYWRpZW50KSwgWyZsdDtzdG9wPl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3RvcClcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBhYm92ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuQWJvdmUpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiBsaW5lYXJHcmFkaWVudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuTGluZWFyR3JhZGllbnQpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGFyZWE6IHtcblx0XHRcdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZSxcblx0XHRcdCAqICAgICAgYWJvdmU6IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyB3aWxsIGdlbmVyYXRlIGZvbGx3aW5nIGxpbmVhckdyYWRpZW50OlxuXHRcdFx0ICogICAgICAvLyA8bGluZWFyR3JhZGllbnQgeDE9XCIwXCIgeDI9XCIwXCIgeTE9XCIwXCIgeTI9XCIxXCI+XG5cdFx0XHQgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIxXCI+PC9zdG9wPlxuXHRcdFx0ICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMFwiPjwvc3RvcD5cblx0XHRcdCAqICAgICAgLy8gPC9saW5lYXJHcmFkaWVudD5cblx0XHRcdCAqICAgICAgbGluZWFyR3JhZGllbnQ6IHRydWUsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBPciBjdXN0b21pemVkIGdyYWRpZW50XG5cdFx0XHQgKiAgICAgIGxpbmVhckdyYWRpZW50OiB7XG5cdFx0XHQgKiAgICAgIFx0eDogWzAsIDBdLCAgLy8geDEsIHgyIGF0dHJpYnV0ZXNcblx0XHRcdCAqICAgICAgXHR5OiBbMCwgMF0sICAvLyB5MSwgeTIgYXR0cmlidXRlc1xuXHRcdFx0ICogICAgICBcdHN0b3BzOiBbXG5cdFx0XHQgKiAgICAgIFx0XHQvLyBvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eVxuXHRcdFx0ICogICAgICBcdFx0WzAsIFwiIzdjYjVlY1wiLCAxXSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIFx0XHQvLyBzZXR0aW5nICdudWxsJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBzZXQgaXRzIG9yaWdpbmFsIGRhdGEgY29sb3Jcblx0XHRcdCAqICAgICAgXHRcdFswLjUsIG51bGwsIDBdLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgXHRcdC8vIHNldHRpbmcgJ2Z1bmN0aW9uJyBmb3Igc3RvcC1jb2xvciwgd2lsbCBwYXNzIGRhdGEgaWQgYXMgYXJndW1lbnQuXG5cdFx0XHQgKiAgICAgIFx0XHQvLyBJdCBzaG91bGQgcmV0dXJuIGNvbG9yIHN0cmluZyBvciBudWxsIHZhbHVlXG5cdFx0XHQgKiAgICAgIFx0XHRbMSwgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJibHVlXCI7IH0sIDBdLFxuXHRcdFx0ICogICAgICBcdF1cblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0YXJlYV96ZXJvYmFzZWQ6IHRydWUsXG5cdFx0XHRhcmVhX2Fib3ZlOiBmYWxzZSxcblx0XHRcdGFyZWFfbGluZWFyR3JhZGllbnQ6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBwaWUgb3B0aW9uc1xuXHRcdFx0ICogQG5hbWUgcGllXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BpZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtwaWUubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtwaWUubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3BpZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIHBpZSBwaWVjZXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ8T2JqZWN0fSBbcGllLmlubmVyUmFkaXVzPTBdIFNldHMgdGhlIGlubmVyIHJhZGl1cyBvZiBwaWUgYXJjLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkZGluZz0wXSBTZXRzIHRoZSBnYXAgYmV0d2VlbiBwaWUgYXJjcy5cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgcGllOiB7XG5cdFx0XHQgKiAgICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG5cdFx0XHQgKiAgICAgICAgICAgICAgLi4uXG5cdFx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xuXHRcdFx0ICogICAgICAgICAgfSxcblx0XHRcdCAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcblx0XHRcdCAqICAgICAgICAgIHJhdGlvOiAwLjVcblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXG5cdFx0XHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXG5cdFx0XHQgKiAgICAgIGV4cGFuZDoge1xuXHRcdFx0ICogICAgICAgICAgZHVyYXRpb246IDUwMFxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgaW5uZXJSYWRpdXM6IDAsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBzZXQgZGlmZmVyZW50IGlubmVyUmFkaXVzIGZvciBlYWNoIGRhdGFcblx0XHRcdCAqICAgICAgaW5uZXJSYWRpdXM6IHtcblx0XHRcdCAqICAgICAgXHRkYXRhMTogMTAsXG5cdFx0XHQgKiAgICAgIFx0ZGF0YTI6IDBcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgcGFkQW5nbGU6IDAuMSxcblx0XHRcdCAqICAgICAgcGFkZGluZzogMFxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0cGllX2xhYmVsX3Nob3c6IHRydWUsXG5cdFx0XHRwaWVfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG5cdFx0XHRwaWVfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxuXHRcdFx0cGllX2xhYmVsX3JhdGlvOiB1bmRlZmluZWQsXG5cdFx0XHRwaWVfZXhwYW5kOiB7fSxcblx0XHRcdHBpZV9leHBhbmRfZHVyYXRpb246IDUwLFxuXHRcdFx0cGllX2lubmVyUmFkaXVzOiAwLFxuXHRcdFx0cGllX3BhZEFuZ2xlOiAwLFxuXHRcdFx0cGllX3BhZGRpbmc6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHBsdWdpbnNcblx0XHRcdCAqIEBuYW1lIHBsdWdpbnNcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHBsdWdpbnM6IFtcblx0XHRcdCAqICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXG5cdFx0XHQgKiAgICBuZXcgUGx1Z2luQSgpLFxuXHRcdFx0ICogICAgLi4uXG5cdFx0XHQgKiBdXG5cdFx0XHQgKi9cblx0XHRcdHBsdWdpbnM6IFtdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCBnYXVnZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSBnYXVnZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnYXVnZS5mdWxsQ2lyY2xlPWZhbHNlXSBTaG93IGZ1bGwgY2lyY2xlIGFzIGRvbnV0LiBXaGVuIHNldCB0byAndHJ1ZScsIHRoZSBtYXggbGFiZWwgd2lsbCBub3QgYmUgc2hvd2VkIGR1ZSB0byBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgc2FtZSBsb2NhdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGdhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGdhdWdlLiBMYWJlbCB0ZXh0IGNhbiBiZSBtdWx0aWxpbmVkIHdpdGggYFxcbmAgY2hhcmFjdGVyLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmV4dGVudHNdIFNldCBjdXN0b21pemVkIG1pbi9tYXggbGFiZWwgdGV4dC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IHRoZSBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UubWluPTBdIFNldCBtaW4gdmFsdWUgb2YgdGhlIGdhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5tYXg9MTAwXSBTZXQgbWF4IHZhbHVlIG9mIHRoZSBnYXVnZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uuc3RhcnRpbmdBbmdsZT0tMSAqIE1hdGguUEkgLyAyXVxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZ2F1Z2UgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudW5pdHNdIFNldCB1bml0cyBvZiB0aGUgZ2F1Z2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLndpZHRoXSBTZXQgd2lkdGggb2YgZ2F1Z2UgY2hhcnQuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGdhdWdlOiB7XG5cdFx0XHQgKiAgICAgIGZ1bGxDaXJjbGU6IGZhbHNlLFxuXHRcdFx0ICogICAgICBsYWJlbDoge1xuXHRcdFx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXG5cdFx0XHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbykge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgZXh0ZW50czogZnVuY3Rpb24odmFsdWUsIGlzTWF4KSB7XG5cdFx0IFx0ICogICAgICAgICAgICAgIHJldHVybiAoaXNNYXggPyBcIk1heDpcIiA6IFwiTWluOlwiKSArIHZhbHVlO1xuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gb3Igc2V0IGR1cmF0aW9uXG5cdFx0XHQgKiAgICAgIGV4cGFuZDoge1xuXHRcdFx0ICogICAgICAgICAgZHVyYXRpb246IDIwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIG1pbjogLTEwMCxcblx0XHRcdCAqICAgICAgbWF4OiAyMDAsXG5cdFx0XHQgKiAgICAgIHRpdGxlOiBcIlRpdGxlIFRleHRcIixcblx0XHRcdCAqICAgICAgdW5pdHM6IFwiJVwiLFxuXHRcdFx0ICogICAgICB3aWR0aDogMTBcblx0XHRcdCAqICB9XG5cdFx0XHQgKi9cblx0XHRcdGdhdWdlX2Z1bGxDaXJjbGU6IGZhbHNlLFxuXHRcdFx0Z2F1Z2VfbGFiZWxfc2hvdzogdHJ1ZSxcblx0XHRcdGdhdWdlX2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2VfbWluOiAwLFxuXHRcdFx0Z2F1Z2VfbWF4OiAxMDAsXG5cdFx0XHRnYXVnZV9zdGFydGluZ0FuZ2xlOiAtMSAqIE1hdGguUEkgLyAyLFxuXHRcdFx0Z2F1Z2VfbGFiZWxfZXh0ZW50czogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2VfdGl0bGU6IFwiXCIsXG5cdFx0XHRnYXVnZV91bml0czogdW5kZWZpbmVkLFxuXHRcdFx0Z2F1Z2Vfd2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdGdhdWdlX2V4cGFuZDoge30sXG5cdFx0XHRnYXVnZV9leHBhbmRfZHVyYXRpb246IDUwLFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGRvbnV0IG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIGRvbnV0XG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RvbnV0LmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggZG9udXQgcGllY2UuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZG9udXQubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbZG9udXQubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBkb251dCBwaWVjZXMuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LndpZHRoXSBTZXQgd2lkdGggb2YgZG9udXQgY2hhcnQuXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2RvbnV0LnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBkb251dCBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIGRvbnV0OiB7XG5cdFx0XHQgKiAgICAgIGxhYmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xuXHRcdFx0ICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcblx0XHRcdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XG5cdFx0XHQgKiAgICAgICAgICBcdC4uLlxuXHRcdFx0ICogICAgICAgICAgXHRyZXR1cm4gcmF0aW87XG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuNVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxuXHRcdFx0ICogICAgICB3aWR0aDogMTAsXG5cdFx0XHQgKiAgICAgIHBhZEFuZ2xlOiAwLjIsXG5cdFx0XHQgKiAgICAgIHRpdGxlOiBcIkRvbnV0IFRpdGxlXCJcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHRpdGxlIHdpdGggbGluZSBicmVha1xuXHRcdFx0ICogICAgICB0aXRsZTogXCJUaXRsZTFcXG5UaXRsZTJcIlxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0ZG9udXRfbGFiZWxfc2hvdzogdHJ1ZSxcblx0XHRcdGRvbnV0X2xhYmVsX2Zvcm1hdDogdW5kZWZpbmVkLFxuXHRcdFx0ZG9udXRfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxuXHRcdFx0ZG9udXRfbGFiZWxfcmF0aW86IHVuZGVmaW5lZCxcblx0XHRcdGRvbnV0X3dpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRkb251dF90aXRsZTogXCJcIixcblx0XHRcdGRvbnV0X2V4cGFuZDoge30sXG5cdFx0XHRkb251dF9leHBhbmRfZHVyYXRpb246IDUwLFxuXHRcdFx0ZG9udXRfcGFkQW5nbGU6IDAsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IHNwbGluZSBvcHRpb25zXG5cdFx0XHQgKiAtICoqQXZhaWxhYmxlIGludGVycG9sYXRpb24gdHlwZSB2YWx1ZXM6Kipcblx0XHRcdCAqICAtIGJhc2lzIChkMy5jdXJ2ZUJhc2lzKVxuXHRcdFx0ICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxuXHRcdFx0ICogIC0gYmFzaXMtb3BlbiAoZDMuY3VydmVCYXNpc09wZW4pXG5cdFx0XHQgKiAgLSBidW5kbGUgKGQzLmN1cnZlQnVuZGxlKVxuXHRcdFx0ICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXG5cdFx0XHQgKiAgLSBjYXJkaW5hbC1jbG9zZWQgKGQzLmN1cnZlQ2FyZGluYWxDbG9zZWQpXG5cdFx0XHQgKiAgLSBjYXJkaW5hbC1vcGVuIChkMy5jdXJ2ZUNhcmRpbmFsT3Blbilcblx0XHRcdCAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXG5cdFx0XHQgKiAgLSBjYXRtdWxsLXJvbS1jbG9zZWQgKGQzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZClcblx0XHRcdCAqICAtIGNhdG11bGwtcm9tLW9wZW4gKGQzLmN1cnZlQ2F0bXVsbFJvbU9wZW4pXG5cdFx0XHQgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcblx0XHRcdCAqICAtIG1vbm90b25lLXkgKGQzLmN1cnZlTW9ub3RvbmVZKVxuXHRcdFx0ICogIC0gbmF0dXJhbCAoZDMuY3VydmVOYXR1cmFsKVxuXHRcdFx0ICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXG5cdFx0XHQgKiAgLSBsaW5lYXIgKGQzLmN1cnZlTGluZWFyKVxuXHRcdFx0ICogIC0gc3RlcCAoZDMuY3VydmVTdGVwKVxuXHRcdFx0ICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXG5cdFx0XHQgKiAgLSBzdGVwLWJlZm9yZSAoZDMuY3VydmVTdGVwQmVmb3JlKVxuXHRcdFx0ICogQG5hbWUgc3BsaW5lXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3BsaW5lLmludGVycG9sYXRpb24udHlwZT1cImNhcmRpbmFsXCJdXG5cdFx0XHQgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogIHNwbGluZToge1xuXHRcdFx0ICogICAgICBpbnRlcnBvbGF0aW9uOiB7XG5cdFx0XHQgKiAgICAgICAgICB0eXBlOiBcImNhcmRpbmFsXCJcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogIH1cblx0XHRcdCAqL1xuXHRcdFx0c3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTogXCJjYXJkaW5hbFwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCByYWRhciBvcHRpb25zXG5cdFx0XHQgKiAtICoqTk9URToqKlxuXHRcdFx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsuXG5cdFx0XHQgKiBAbmFtZSByYWRhclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLmF4aXMubWF4PXVuZGVmaW5lZF0gVGhlIG1heCB2YWx1ZSBvZiBheGlzLiBJZiBub3QgZ2l2ZW4sIGl0J2xsIHRha2UgdGhlIG1heCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBkYXRhLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIuYXhpcy5saW5lLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgbGluZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmF4aXMudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIHRleHQuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5kaXJlY3Rpb24uY2xvY2t3aXNlPWZhbHNlXSBTZXQgdGhlIGRpcmVjdGlvbiB0byBiZSBkcmF3bi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIubGV2ZWwuZGVwdGg9M10gU2V0IHRoZSBsZXZlbCBkZXB0aC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmxldmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3JhZGFyLmxldmVsLnRleHQuZm9ybWF0PSh4KSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKV0gU2V0IGZvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIGxldmVsIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbCB0ZXh0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5zaXplLnJhdGlvPTAuODddIFNldCBzaXplIHJhdGlvLlxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlJhZGFyQ2hhcnQpXG5cdFx0XHQgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogcmFkYXIgbGV2ZWxdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckxldmVsKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogcmFkYXIgc2l6ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyU2l6ZSlcblx0XHRcdCAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXMgbXVsdGlsaW5lXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzTXVsdGlsaW5lKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICByYWRhcjoge1xuXHRcdFx0ICogICAgICBheGlzOiB7XG5cdFx0XHQgKiAgICAgICAgICBtYXg6IDUwLFxuXHRcdFx0ICogICAgICAgICAgbGluZToge1xuXHRcdFx0ICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgdGV4dDoge1xuXHRcdFx0ICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIGRpcmVjdGlvbjoge1xuXHRcdFx0ICogICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIGxldmVsOiB7XG5cdFx0XHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcblx0XHRcdCAqICAgICAgICAgIHRleHQ6IHtcblx0XHRcdCAqICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcblx0XHRcdCAqICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcblx0XHRcdCAqICAgICAgICAgICAgICB9LFxuXHRcdFx0ICogICAgICAgICAgICAgIHNob3c6IHRydWVcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqICAgICAgc2l6ZToge1xuXHRcdFx0ICogICAgICAgICAgcmF0aW86IDAuN1xuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHRyYWRhcl9heGlzX21heDogdW5kZWZpbmVkLFxuXHRcdFx0cmFkYXJfYXhpc19saW5lX3Nob3c6IHRydWUsXG5cdFx0XHRyYWRhcl9heGlzX3RleHRfc2hvdzogdHJ1ZSxcblx0XHRcdHJhZGFyX2xldmVsX2RlcHRoOiAzLFxuXHRcdFx0cmFkYXJfbGV2ZWxfc2hvdzogdHJ1ZSxcblx0XHRcdHJhZGFyX2xldmVsX3RleHRfZm9ybWF0OiB4ID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpLFxuXHRcdFx0cmFkYXJfbGV2ZWxfdGV4dF9zaG93OiB0cnVlLFxuXHRcdFx0cmFkYXJfc2l6ZV9yYXRpbzogMC44Nyxcblx0XHRcdHJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U6IGZhbHNlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNob3cgcmVjdGFuZ2xlcyBpbnNpZGUgdGhlIGNoYXJ0Ljxicj48YnI+XG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgYXhpcywgc3RhcnQsIGVuZCBhbmQgY2xhc3MuIFRoZSBrZXlzIHN0YXJ0LCBlbmQgYW5kIGNsYXNzIGFyZSBvcHRpb25hbC5cblx0XHRcdCAqIGF4aXMgbXVzdCBiZSB4LCB5IG9yIHkyLiBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSB0aGUgdmFsdWUgd2hlcmUgcmVnaW9ucyBzdGFydCBhbmQgZW5kLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZWRnZSB2YWx1ZXMgd2lsbCBiZSB1c2VkLiBJZiB0aW1lc2VyaWVzIHggYXhpcywgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyIGNhbiBiZSB1c2VkLiBJZiBjbGFzcyBpcyBzZXQsIHRoZSByZWdpb24gZWxlbWVudCB3aWxsIGhhdmUgaXQgYXMgY2xhc3MuXG5cdFx0XHQgKiBAbmFtZSByZWdpb25zXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQGRlZmF1bHQgW11cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgcmVnaW9uczogW1xuXHRcdFx0ICogICAge1xuXHRcdFx0ICogICAgICBheGlzOiBcInhcIixcblx0XHRcdCAqICAgICAgc3RhcnQ6IDEsXG5cdFx0XHQgKiAgICAgIGVuZDogNCxcblx0XHRcdCAqICAgICAgY2xhc3M6IFwicmVnaW9uLTEtNFwiXG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiAgXVxuXHRcdFx0ICovXG5cdFx0XHRyZWdpb25zOiBbXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUb29sdGlwIG9wdGlvbnNcblx0XHRcdCAqIEBuYW1lIHRvb2x0aXBcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB0b29sdGlwLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5kb05vdEhpZGU9ZmFsc2VdIE1ha2UgdG9vbHRpcCBrZWVwIHNob3dpbmcgbm90IGhpZGluZyBvbiBpbnRlcmFjdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXAuZ3JvdXBlZD10cnVlXSBTZXQgaWYgdG9vbHRpcCBpcyBncm91cGVkIG9yIG5vdCBmb3IgdGhlIGRhdGEgcG9pbnRzLlxuXHRcdFx0ICogICAtICoqTk9URToqKiBUaGUgb3ZlcmxhcHBlZCBkYXRhIHBvaW50cyB3aWxsIGJlIGRpc3BsYXllZCBhcyBncm91cGVkIGV2ZW4gaWYgc2V0IGZhbHNlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5saW5rZWQ9ZmFsc2VdIFNldCBpZiB0b29sdGlwcyBvbiBhbGwgdmlzaWJsZSBjaGFydHMgd2l0aCBsaWtlIHggcG9pbnRzIGFyZSBzaG93biB0b2dldGhlciB3aGVuIG9uZSBpcyBzaG93bi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdG9vbHRpcC5saW5rZWQubmFtZT1cIlwiXSBHcm9waW5nIG5hbWUgZm9yIGxpbmtlZCB0b29sdGlwLjxicj5JZiBzcGVjaWZpZWQsIGxpbmtlZCB0b29sdGlwIHdpbGwgYmUgZ3JvcGVkIGludGVyYWN0aW5nIHRvIGJlIHdvcmtlZCBvbmx5IHdpdGggdGhlIHNhbWUgbmFtZS5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC50aXRsZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHRpdGxlIG9mIHRvb2x0aXAuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuXG5cdFx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQubmFtZV0gU2V0IGZvcm1hdCBmb3IgdGhlIG5hbWUgb2YgZWFjaCBkYXRhIGluIHRvb2x0aXAuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnZhbHVlXSBTZXQgZm9ybWF0IGZvciB0aGUgdmFsdWUgb2YgZWFjaCBkYXRhIGluIHRvb2x0aXAuPGJyPlxuXHRcdFx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxuXHRcdFx0ICogIElmIHVuZGVmaW5lZCByZXR1cm5lZCwgdGhlIHJvdyBvZiB0aGF0IHZhbHVlIHdpbGwgYmUgc2tpcHBlZC5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLnBvc2l0aW9uXSBTZXQgY3VzdG9tIHBvc2l0aW9uIGZvciB0aGUgdG9vbHRpcC48YnI+XG5cdFx0XHQgKiAgVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIHBvc2l0aW9uIGJ5IHJldHVybmluZyBvYmplY3QgdGhhdCBoYXMgdG9wIGFuZCBsZWZ0LlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbnxPYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzXSBTZXQgY3VzdG9tIEhUTUwgZm9yIHRoZSB0b29sdGlwLjxicj5cblx0XHRcdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgZGF0YSwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQgYW5kIGNvbG9yIG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIElmIHRvb2x0aXAuZ3JvdXBlZCBpcyB0cnVlLCBkYXRhIGluY2x1ZGVzIG11bHRpcGxlIGRhdGEgcG9pbnRzLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR9IFt0b29sdGlwLmNvbnRlbnRzLmJpbmR0bz11bmRlZmluZWRdIFNldCBDU1Mgc2VsZWN0b3Igb3IgZWxlbWVudCByZWZlcmVuY2UgdG8gYmluZCB0b29sdGlwLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IHRvb2x0aXAncyB0ZW1wbGF0ZS5cblx0XHRcdCAqICAtICoqTk9URToqKiBXaGVuIGlzIHNwZWNpZmllZCwgd2lsbCBub3QgYmUgdXBkYXRpbmcgdG9vbHRpcCdzIHBvc2l0aW9uLlxuXHRcdFx0ICogIC0gV2l0aGluIHRlbXBsYXRlLCBiZWxvdyBzeW50YXggd2lsbCBiZSByZXBsYWNlZCB1c2luZyB0ZW1wbGF0ZS1saWtlIHN5bnRheCBzdHJpbmc6XG5cdFx0XHQgKiAgICAtIHt7IC4uLiB9fTogdGhlIGRvdWJseSBjdXJseSBicmFja2V0cyBpbmRpY2F0ZSBsb29wIGJsb2NrIGZvciBkYXRhIHJvd3Ncblx0XHRcdCAqICAgIC0gez1DTEFTU19UT09MVElQfTogZGVmYXVsdCB0b29sdGlwIGNsYXNzIG5hbWUgYGJiLXRvb2x0aXBgLlxuXHRcdFx0ICogICAgLSB7PUNMQVNTX1RPT0xUSVBfTkFNRX06IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcblx0XHRcdCAqICAgIC0gez1USVRMRX06IHRpdGxlIHZhbHVlXG5cdFx0XHQgKiAgICAtIHs9Q09MT1J9OiBkYXRhIGNvbG9yXG5cdFx0XHQgKiAgICAtIHs9VkFMVUV9OiBkYXRhIHZhbHVlXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuY29udGVudHMudGV4dD11bmRlZmluZWRdIFNldCBhZGRpdGlvbmFsIHRleHQgY29udGVudCB3aXRoaW4gZGF0YSBsb29wLCB1c2luZyB0ZW1wbGF0ZSBzeW50YXguXG5cdFx0XHQgKiAgLSAqKk5PVEU6KiogSXQgc2hvdWxkIGNvbnRhaW4gYHsga2V5OiBBcnJheSwgLi4uIH1gIHZhbHVlXG5cdFx0XHQgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXG5cdFx0XHQgKiAgICAtIFRoZSB2YWx1ZSBhcnJheSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmluaXQuc2hvdz1mYWxzZV0gU2hvdyB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuaW5pdC5wb3NpdGlvbj17dG9wOiBcIjBweFwiLGxlZnQ6IFwiNTBweFwifV0gU2V0IHRoZSBwb3NpdGlvbiBvZiB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd10gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIHNob3duLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxuXHRcdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93bl0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZGVuXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cblx0XHRcdCAqICAqKkF2YWlsYWJsZSBWYWx1ZXM6Kipcblx0XHRcdCAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXG5cdFx0XHQgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcblx0XHRcdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgZGlzcGxheSBvcmRlcjxicj5cblx0XHRcdCAqICAgICAqKk5PVEU6KiogV2hlbiBgZGF0YS5ncm91cHNgIGlzIHNldCwgdGhlIG9yZGVyIHdpbGwgZm9sbG93IGFzIHRoZSBzdGFja2VkIGdyYXBoIG9yZGVyLjxicj5cblx0XHRcdCAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxuXHRcdFx0ICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogSGlkZSBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5IaWRlVG9vbHRpcClcblx0XHRcdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcblx0XHRcdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgRm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwRm9ybWF0KVxuXHRcdFx0ICogQHNlZSBbRGVtbzogTGlua2VkIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkxpbmtlZFRvb2x0aXBzKVxuXHRcdFx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqICB0b29sdGlwOiB7XG5cdFx0XHQgKiAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgIGRvTm90SGlkZTogdHJ1ZSxcblx0XHRcdCAqICAgICAgZ3JvdXBlZDogZmFsc2UsXG5cdFx0XHQgKiAgICAgIGZvcm1hdDoge1xuXHRcdFx0ICogICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFwiRGF0YSBcIiArIHg7IH0sXG5cdFx0XHQgKiAgICAgICAgICBuYW1lOiBmdW5jdGlvbihuYW1lLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiBuYW1lOyB9LFxuXHRcdFx0ICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxuXHRcdFx0ICogICAgICB9LFxuXHRcdFx0ICogICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodCwgZWxlbWVudCkge1xuXHRcdFx0ICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XG4gIFx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG4gIFx0XHRcdCAqICAgICAgY29udGVudHM6IGZ1bmN0aW9uKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xuICBcdFx0XHQgKiAgICAgICAgICByZXR1cm4gLi4uIC8vIGZvcm1hdHRlZCBodG1sIGFzIHlvdSB3YW50XG4gICAgXHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyBzcGVjaWZ5IHRvb2x0aXAgY29udGVudHMgdXNpbmcgdGVtcGxhdGVcblx0XHRcdCAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxuXHRcdFx0ICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxuXHRcdFx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6IzAwYzczY1wiPmRhdGExPC9zcGFuPjwvbGk+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj48L2xpPlxuXHRcdFx0ICogICAgICAgLy8gPC91bD5cblx0XHRcdCAqICAgICAgIGNvbnRlbnRzOiB7XG5cdFx0XHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXG5cdFx0XHQgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+PGJyPicgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj48L2xpPicgK1xuXHRcdFx0ICogICAgICBcdFx0J319PC91bD4nXG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAvLyB3aXRoIGFkZGl0aW9uYWwgdGV4dCB2YWx1ZVxuXHRcdFx0ICogICAgICAgLy8gLSBleGFtcGxlIG9mIEhUTUwgcmV0dXJuZWQ6XG5cdFx0XHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+Y29tbWVudDE8c3BhbiBzdHlsZT1cImNvbG9yOiMwMGM3M2NcIj5kYXRhMTwvc3Bhbj50ZXh0MTwvbGk+XG5cdFx0XHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj5jb21tZW50MjxzcGFuIHN0eWxlPVwiY29sb3I6I2ZhNzE3MVwiPmRhdGEyPC9zcGFuPnRleHQyPC9saT5cblx0XHRcdCAqICAgICAgIC8vIDwvdWw+XG5cdFx0XHQgKiAgICAgICBjb250ZW50czoge1xuXHRcdFx0ICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxuXHRcdFx0ICogICAgICBcdHRleHQ6IHtcblx0XHRcdCAqICAgICAgXHRcdC8vIGEpICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXG5cdFx0XHQgKiAgICAgIFx0XHQvLyBiKSB0aGUgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxuXHRcdFx0ICogICAgICBcdFx0VkFSMTogW1widGV4dDFcIiwgXCJ0ZXh0MlwiXSxcblx0XHRcdCAqICAgICAgXHRcdFZBUjI6IFtcImNvbW1lbnQxXCIsIFwiY29tbWVudDJcIl0sXG5cdFx0XHQgKiAgICAgIFx0fSxcblx0XHRcdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXG5cdFx0XHQgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj57PVZBUjJ9PGJyPicgK1xuXHRcdFx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj57PVZBUjF9PC9saT4nICtcblx0XHRcdCAqICAgICAgXHRcdCd9fTwvdWw+J1xuXHRcdFx0ICogICAgICB9XG4gICAgXHRcdCAqXG4gICAgXHRcdCAqICAgICAgLy8gc29ydCB0b29sdGlwIGRhdGEgdmFsdWUgZGlzcGxheSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICBcdFx0ICogICAgICBvcmRlcjogXCJhc2NcIixcbiAgICBcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXG5cdFx0XHQgKiAgICAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxuXHRcdFx0ICogICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn1cblx0XHRcdCAqICAgICAgICAgICAuLi5cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIHNob3cgYXQgdGhlIGluaXRpYWxpemF0aW9uXG5cdFx0XHQgKiAgICAgIGluaXQ6IHtcblx0XHRcdCAqICAgICAgICAgIHNob3c6IHRydWUsXG5cdFx0XHQgKiAgICAgICAgICB4OiAyLFxuXHRcdFx0ICogICAgICAgICAgcG9zaXRpb246IHtcblx0XHRcdCAqICAgICAgICAgICAgICB0b3A6IFwiMTUwcHhcIixcblx0XHRcdCAqICAgICAgICAgICAgICBsZWZ0OiBcIjI1MHB4XCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgfSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqICAgICAgb25zaG93OiBmdW5jdGlvbigpIHsgLi4ufSxcblx0XHRcdCAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBoaWRkZW5cblx0XHRcdCAqICAgICAgb25oaWRlOiBmdW5jdGlvbigpIHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgc2hvd25cblx0XHRcdCAqICAgICAgb25zaG93bjogZnVuY3Rpb24oKSB7IC4uLiB9LFxuXHRcdFx0ICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIGhpZGRlblxuXHRcdFx0ICogICAgICBvbmhpZGRlbjogZnVuY3Rpb24oKSB7IC4uLiB9LFxuXHRcdFx0ICpcblx0XHRcdCAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcblx0XHRcdCAqICAgICAgLy8gVXNlZnVsIGZvciB0aW1lc2VyaWVzIGNvcnJlbGF0aW9uXG5cdFx0XHQgKiAgICAgIGxpbmtlZDogdHJ1ZSxcblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgIC8vIFNwZWNpZnkgbmFtZSB0byBpbnRlcmFjdCB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgb25seS5cblx0XHRcdCAqICAgICAgbGlua2VkOiB7XG5cdFx0XHQgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxuXHRcdFx0ICogICAgICB9XG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHR0b29sdGlwX3Nob3c6IHRydWUsXG5cdFx0XHR0b29sdGlwX2RvTm90SGlkZTogZmFsc2UsXG5cdFx0XHR0b29sdGlwX2dyb3VwZWQ6IHRydWUsXG5cdFx0XHR0b29sdGlwX2Zvcm1hdF90aXRsZTogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9mb3JtYXRfbmFtZTogdW5kZWZpbmVkLFxuXHRcdFx0dG9vbHRpcF9mb3JtYXRfdmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdHRvb2x0aXBfcG9zaXRpb246IHVuZGVmaW5lZCxcblx0XHRcdHRvb2x0aXBfY29udGVudHM6IHt9LFxuXHRcdFx0dG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxuXHRcdFx0dG9vbHRpcF9pbml0X3g6IDAsXG5cdFx0XHR0b29sdGlwX2luaXRfcG9zaXRpb246IHtcblx0XHRcdFx0dG9wOiBcIjBweFwiLFxuXHRcdFx0XHRsZWZ0OiBcIjUwcHhcIlxuXHRcdFx0fSxcblx0XHRcdHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcblx0XHRcdHRvb2x0aXBfbGlua2VkX25hbWU6IFwiXCIsXG5cdFx0XHR0b29sdGlwX29uc2hvdzogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29uc2hvd246ICgpID0+IHt9LFxuXHRcdFx0dG9vbHRpcF9vbmhpZGRlbjogKCkgPT4ge30sXG5cdFx0XHR0b29sdGlwX29yZGVyOiBudWxsLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldCB0aXRsZSBvcHRpb25zXG5cdFx0XHQgKiBAbmFtZSB0aXRsZVxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnRleHRdIFRpdGxlIHRleHQuIElmIGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbGxvd2luZyBtdWx0aWxpbmUgdGl0bGUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcudG9wPTBdIFRvcCBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnJpZ2h0PTBdIFJpZ2h0IHBhZGRpbmcgdmFsdWUuXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcuYm90dG9tPTBdIEJvdHRvbSBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aXRsZS5wYWRkaW5nLmxlZnQ9MF0gTGVmdCBwYWRkaW5nIHZhbHVlLlxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFt0aXRsZS5wb3NpdGlvbj1jZW50ZXJdIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiAnY2VudGVyJywgJ3JpZ2h0JyBhbmQgJ2xlZnQnLlxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1RpdGxlLk11bHRpbGluZWRUaXRsZSlcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiAgdGl0bGU6IHtcblx0XHRcdCAqICAgICAgdGV4dDogXCJUaXRsZSBUZXh0XCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICAvLyBvciBNdWx0aWxpbmUgdGl0bGUgdGV4dFxuXHRcdFx0ICogICAgICB0ZXh0OiBcIk1haW4gdGl0bGUgdGV4dFxcblN1YiB0aXRsZSB0ZXh0XCIsXG5cdFx0XHQgKlxuXHRcdFx0ICogICAgICBwYWRkaW5nOiB7XG5cdFx0XHQgKiAgICAgICAgICB0b3A6IDEwLFxuXHRcdFx0ICogICAgICAgICAgcmlnaHQ6IDEwLFxuXHRcdFx0ICogICAgICAgICAgYm90dG9tOiAxMCxcblx0XHRcdCAqICAgICAgICAgIGxlZnQ6IDEwXG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiXG5cdFx0XHQgKiAgfVxuXHRcdFx0ICovXG5cdFx0XHR0aXRsZV90ZXh0OiB1bmRlZmluZWQsXG5cdFx0XHR0aXRsZV9wYWRkaW5nOiB7XG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdGJvdHRvbTogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlX3Bvc2l0aW9uOiBcImNlbnRlclwiXG5cdFx0fTtcblx0fVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IE9wdGlvbnMgZnJvbSBcIi4vT3B0aW9uc1wiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2lzRGVmaW5lZCwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0T3B0aW9ucygpIHtcblx0XHRyZXR1cm4gbmV3IE9wdGlvbnMoKTtcblx0fSxcblxuXHQvKipcblx0ICogTG9hZCBjb25maWd1cmF0aW9uIG9wdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFVzZXIncyBnZW5lcmF0aW9uIGNvbmZpZyB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0bG9hZENvbmZpZyhjb25maWcpIHtcblx0XHRjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWc7XG5cdFx0bGV0IHRhcmdldDtcblx0XHRsZXQga2V5cztcblx0XHRsZXQgcmVhZDtcblxuXHRcdGNvbnN0IGZpbmQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBrZXkgPSBrZXlzLnNoaWZ0KCk7XG5cblx0XHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XG5cdFx0XHRcdHJldHVybiBmaW5kKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0T2JqZWN0LmtleXModGhpc0NvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0dGFyZ2V0ID0gY29uZmlnO1xuXHRcdFx0a2V5cyA9IGtleS5zcGxpdChcIl9cIik7XG5cdFx0XHRyZWFkID0gZmluZCgpO1xuXG5cdFx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XG5cdFx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxuXHRzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyXG59IGZyb20gXCJkMy1zY2FsZVwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdldFNjYWxlKG1pbiwgbWF4LCBmb3JUaW1lc2VyaWVzKSB7XG5cdFx0cmV0dXJuIChmb3JUaW1lc2VyaWVzID9cblx0XHRcdGQzU2NhbGVUaW1lKCkgOiBkM1NjYWxlTGluZWFyKClcblx0XHQpLnJhbmdlKFttaW4sIG1heF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgeCBBeGlzIHNjYWxlIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldCBUaGUgb2Zmc2V0IGdldHRlciB0byBiZSBzdW1cblx0ICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRYKG1pbiwgbWF4LCBkb21haW4sIG9mZnNldCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzY2FsZSA9ICQkLnpvb21TY2FsZSB8fCAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuaXNUaW1lU2VyaWVzKCkpO1xuXG5cdFx0cmV0dXJuICQkLmdldEN1c3RvbWl6ZWRTY2FsZShcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXG5cdFx0XHRvZmZzZXRcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2FsZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0WShtaW4sIG1heCwgZG9tYWluKSB7XG5cdFx0Y29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKG1pbiwgbWF4LCB0aGlzLmlzVGltZVNlcmllc1koKSk7XG5cblx0XHRkb21haW4gJiYgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cblx0XHRyZXR1cm4gc2NhbGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjdXN0b21pemVkIHNjYWxlXG5cdCAqIEBwYXJhbSB7ZDMuc2NhbGVMaW5lYXJ8ZDMuc2NhbGVUaW1lfSBzY2FsZVZhbHVlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldFZhbHVlIE9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXG5cdCAqIEByZXR1cm4ge30gc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEN1c3RvbWl6ZWRTY2FsZShzY2FsZVZhbHVlLCBvZmZzZXRWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQueEF4aXMudGlja09mZnNldCgpKTtcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xuXHRcdFx0Y29uc3QgdiA9IHNjYWxlVmFsdWUoZCkgKyBvZmZzZXQoKTtcblxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XG5cdFx0fTtcblxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xuXHRcdGZvciAoY29uc3Qga2V5IGluIHNjYWxlVmFsdWUpIHtcblx0XHRcdHNjYWxlW2tleV0gPSBzY2FsZVZhbHVlW2tleV07XG5cdFx0fVxuXG5cdFx0c2NhbGUub3JnRG9tYWluID0gKCkgPT4gc2NhbGVWYWx1ZS5kb21haW4oKTtcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XG5cblx0XHQvLyBkZWZpbmUgY3VzdG9tIGRvbWFpbigpIGZvciBjYXRlZ29yaXplZCBheGlzXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0c2NhbGUuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluVmFsdWUpIHtcblx0XHRcdFx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xuXG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbWFpbiA9IHRoaXMub3JnRG9tYWluKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gW2RvbWFpblswXSwgZG9tYWluWzFdICsgMV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY2FsZVZhbHVlLmRvbWFpbihkb21haW4pO1xuXG5cdFx0XHRcdHJldHVybiBzY2FsZTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNjYWxlO1xuXHR9LFxuXG5cdGdldFlTY2FsZShpZCkge1xuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnkyIDogdGhpcy55O1xuXHR9LFxuXG5cdGdldFN1YllTY2FsZShpZCkge1xuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB0aGlzLnN1YlkyIDogdGhpcy5zdWJZO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgc2NhbGVcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgLSBwYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcblx0ICovXG5cdHVwZGF0ZVNjYWxlcyhpc0luaXQsIHVwZGF0ZVhEb21haW4gPSB0cnVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Ly8gdXBkYXRlIGVkZ2VzXG5cdFx0JCQueE1pbiA9IGlzUm90YXRlZCA/IDEgOiAwO1xuXHRcdCQkLnhNYXggPSBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcblx0XHQkJC55TWluID0gaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodDtcblx0XHQkJC55TWF4ID0gaXNSb3RhdGVkID8gJCQud2lkdGggOiAxO1xuXHRcdCQkLnN1YlhNaW4gPSAkJC54TWluO1xuXHRcdCQkLnN1YlhNYXggPSAkJC54TWF4O1xuXHRcdCQkLnN1YllNaW4gPSBpc1JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0Mjtcblx0XHQkJC5zdWJZTWF4ID0gaXNSb3RhdGVkID8gJCQud2lkdGgyIDogMTtcblxuXHRcdC8vIHVwZGF0ZSBzY2FsZXNcblx0XHQvLyB4IEF4aXNcblx0XHRjb25zdCB4RG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiAkJC54ICYmICQkLngub3JnRG9tYWluKCk7XG5cdFx0Y29uc3QgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgJCQub3JnWERvbWFpbjtcblxuXHRcdCQkLnggPSAkJC5nZXRYKCQkLnhNaW4sICQkLnhNYXgsIHhEb21haW4sICgpID0+ICQkLnhBeGlzLnRpY2tPZmZzZXQoKSk7XG5cdFx0JCQuc3ViWCA9ICQkLmdldFgoJCQueE1pbiwgJCQueE1heCwgeFN1YkRvbWFpbiwgZCA9PiAoZCAlIDEgPyAwIDogJCQuc3ViWEF4aXMudGlja09mZnNldCgpKSk7XG5cblx0XHQkJC54QXhpc1RpY2tGb3JtYXQgPSAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpO1xuXHRcdCQkLnhBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0WEF4aXNUaWNrVmFsdWVzKCk7XG5cblx0XHQkJC54QXhpcyA9ICQkLmF4aXNcblx0XHRcdC5nZXRYQXhpcyhcInhcIiwgJCQueCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xuXG5cdFx0JCQuc3ViWEF4aXMgPSAkJC5heGlzXG5cdFx0XHQuZ2V0WEF4aXMoXCJzdWJYXCIsICQkLnN1YlgsIGNvbmZpZy5heGlzX3hfdGlja19vdXRlciwgaXNJbml0KTtcblxuXHRcdC8vIHkgQXhpc1xuXHRcdCQkLnkgPSAkJC5nZXRZKCQkLnlNaW4sICQkLnlNYXgsICQkLnkgPyAkJC55LmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcblx0XHQkJC5zdWJZID0gJCQuZ2V0WSgkJC5zdWJZTWluLCAkJC5zdWJZTWF4LCAkJC5zdWJZID8gJCQuc3ViWS5kb21haW4oKSA6IGNvbmZpZy5heGlzX3lfZGVmYXVsdCk7XG5cblx0XHQkJC55QXhpc1RpY2tWYWx1ZXMgPSAkJC5heGlzLmdldFlBeGlzVGlja1ZhbHVlcygpO1xuXG5cdFx0JCQueUF4aXMgPSAkJC5heGlzXG5cdFx0XHQuZ2V0WUF4aXMoXCJ5XCIsICQkLnksIGNvbmZpZy5heGlzX3lfdGlja19vdXRlciwgaXNJbml0KTtcblxuXHRcdC8vIHkyIEF4aXNcblx0XHRpZiAoY29uZmlnLmF4aXNfeTJfc2hvdykge1xuXHRcdFx0JCQueTIgPSAkJC5nZXRZKCQkLnlNaW4sICQkLnlNYXgsICQkLnkyID8gJCQueTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcblx0XHRcdCQkLnN1YlkyID0gJCQuZ2V0WSgkJC5zdWJZTWluLCAkJC5zdWJZTWF4LFxuXHRcdFx0XHQkJC5zdWJZMiA/ICQkLnN1YlkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XG5cblx0XHRcdCQkLnkyQXhpc1RpY2tWYWx1ZXMgPSAkJC5heGlzLmdldFkyQXhpc1RpY2tWYWx1ZXMoKTtcblxuXHRcdFx0JCQueTJBeGlzID0gJCQuYXhpc1xuXHRcdFx0XHQuZ2V0WUF4aXMoXCJ5MlwiLCAkJC55MiwgY29uZmlnLmF4aXNfeTJfdGlja19vdXRlciwgaXNJbml0KTtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgZm9yIGFyY1xuXHRcdCQkLnVwZGF0ZUFyYyAmJiAkJC51cGRhdGVBcmMoKTtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmQsIGJydXNoRW1wdHksIGdldEJydXNoU2VsZWN0aW9uLCBnZXRNaW5NYXgsIGlzRGVmaW5lZCwgbm90RW1wdHksIGlzVmFsdWUsIGlzT2JqZWN0LCBpc051bWJlciwgZGlmZkRvbWFpbiwgc29ydFZhbHVlfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIHR5cGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzTWluID0gdHlwZSA9PT0gXCJtaW5cIjtcblxuXHRcdGNvbnN0IGRhdGFHcm91cHMgPSBjb25maWcuZGF0YV9ncm91cHM7XG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9JZHModGFyZ2V0cyk7XG5cdFx0Y29uc3QgeXMgPSAkJC5nZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cyk7XG5cblx0XHRpZiAoZGF0YUdyb3Vwcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBoYXNWYWx1ZSA9ICQkW2BoYXMke2lzTWluID8gXCJOZWdhdGl2ZVwiIDogXCJQb3NpdGl2ZVwifVZhbHVlSW5UYXJnZXRzYF0odGFyZ2V0cyk7XG5cblx0XHRcdGZvciAobGV0IGogPSAwLCBpZHNJbkdyb3VwOyAoaWRzSW5Hcm91cCA9IGRhdGFHcm91cHNbal0pOyBqKyspIHtcblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGJhc2VJZFxuXHRcdFx0XHRpZHNJbkdyb3VwID0gaWRzSW5Hcm91cC5maWx0ZXIodiA9PiBpZHMuaW5kZXhPZih2KSA+PSAwKTtcblxuXHRcdFx0XHRpZiAoaWRzSW5Hcm91cC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGJhc2VJZCA9IGlkc0luR3JvdXBbMF07XG5cdFx0XHRcdGNvbnN0IGJhc2VBeGlzSWQgPSAkJC5heGlzLmdldElkKGJhc2VJZCk7XG5cblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBiYXNlIHZhbHVlLiBTZXQgdG8gMCBpZiBub3QgbWF0Y2ggd2l0aCB0aGUgY29uZGl0aW9uXG5cdFx0XHRcdGlmIChoYXNWYWx1ZSAmJiB5c1tiYXNlSWRdKSB7XG5cdFx0XHRcdFx0eXNbYmFzZUlkXSA9IHlzW2Jhc2VJZF0ubWFwKHYgPT4gKFxuXHRcdFx0XHRcdFx0KGlzTWluID8gdiA8IDAgOiB2ID4gMCkgPyB2IDogMFxuXHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChsZXQgayA9IDEsIGlkOyAoaWQgPSBpZHNJbkdyb3VwW2tdKTsgaysrKSB7XG5cdFx0XHRcdFx0aWYgKCF5c1tpZF0pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoaWQpO1xuXG5cdFx0XHRcdFx0eXNbaWRdLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbCA9ICt2O1xuXHRcdFx0XHRcdFx0Y29uc3QgbWVldENvbmRpdGlvbiA9IGlzTWluID8gdmFsID4gMCA6IHZhbCA8IDA7XG5cblx0XHRcdFx0XHRcdGlmIChheGlzSWQgPT09IGJhc2VBeGlzSWQgJiYgIShoYXNWYWx1ZSAmJiBtZWV0Q29uZGl0aW9uKSkge1xuXHRcdFx0XHRcdFx0XHR5c1tiYXNlSWRdW2ldICs9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBnZXRNaW5NYXgodHlwZSwgT2JqZWN0LmtleXMoeXMpLm1hcChrZXkgPT4gZ2V0TWluTWF4KHR5cGUsIHlzW2tleV0pKSk7XG5cdH0sXG5cblx0Z2V0WURvbWFpbk1pbih0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcblx0fSxcblxuXHRnZXRZRG9tYWluTWF4KHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRZRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xuXHR9LFxuXG5cdGdldFlEb21haW4odGFyZ2V0cywgYXhpc0lkLCB4RG9tYWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDEwMF07XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGFyZ2V0c0J5QXhpc0lkID0gdGFyZ2V0cy5maWx0ZXIodCA9PiAkJC5heGlzLmdldElkKHQuaWQpID09PSBheGlzSWQpO1xuXHRcdGNvbnN0IHlUYXJnZXRzID0geERvbWFpbiA/ICQkLmZpbHRlckJ5WERvbWFpbih0YXJnZXRzQnlBeGlzSWQsIHhEb21haW4pIDogdGFyZ2V0c0J5QXhpc0lkO1xuXHRcdGNvbnN0IHlNaW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X21pbmBdO1xuXHRcdGNvbnN0IHlNYXggPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X21heGBdO1xuXHRcdGxldCB5RG9tYWluTWluID0gJCQuZ2V0WURvbWFpbk1pbih5VGFyZ2V0cyk7XG5cdFx0bGV0IHlEb21haW5NYXggPSAkJC5nZXRZRG9tYWluTWF4KHlUYXJnZXRzKTtcblxuXHRcdGNvbnN0IGNlbnRlciA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fY2VudGVyYF07XG5cdFx0bGV0IGlzWmVyb0Jhc2VkID0gKCQkLmhhc1R5cGUoXCJiYXJcIiwgeVRhcmdldHMpICYmIGNvbmZpZy5iYXJfemVyb2Jhc2VkKSB8fCAoJCQuaGFzVHlwZShcImFyZWFcIiwgeVRhcmdldHMpICYmIGNvbmZpZy5hcmVhX3plcm9iYXNlZCk7XG5cdFx0Y29uc3QgaXNJbnZlcnRlZCA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1faW52ZXJ0ZWRgXTtcblx0XHRjb25zdCBzaG93SG9yaXpvbnRhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3Qgc2hvd1ZlcnRpY2FsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHQvLyBNRU1POiBhdm9pZCBpbnZlcnRpbmcgZG9tYWluIHVuZXhwZWN0ZWRseVxuXHRcdHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6XG5cdFx0XHQoaXNWYWx1ZSh5TWF4KSA/ICh5RG9tYWluTWluIDwgeU1heCA/IHlEb21haW5NaW4gOiB5TWF4IC0gMTApIDogeURvbWFpbk1pbik7XG5cdFx0eURvbWFpbk1heCA9IGlzVmFsdWUoeU1heCkgPyB5TWF4IDpcblx0XHRcdChpc1ZhbHVlKHlNaW4pID8gKHlNaW4gPCB5RG9tYWluTWF4ID8geURvbWFpbk1heCA6IHlNaW4gKyAxMCkgOiB5RG9tYWluTWF4KTtcblxuXHRcdGlmICh5VGFyZ2V0cy5sZW5ndGggPT09IDApIHsgLy8gdXNlIGN1cnJlbnQgZG9tYWluIGlmIHRhcmdldCBvZiBheGlzSWQgaXMgbm9uZVxuXHRcdFx0cmV0dXJuICQkW2F4aXNJZF0uZG9tYWluKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKHlEb21haW5NaW4pKSB7IC8vIHNldCBtaW5pbXVtIHRvIHplcm8gd2hlbiBub3QgbnVtYmVyXG5cdFx0XHR5RG9tYWluTWluID0gMDtcblx0XHR9XG5cblx0XHRpZiAoaXNOYU4oeURvbWFpbk1heCkpIHsgLy8gc2V0IG1heGltdW0gdG8gaGF2ZSBzYW1lIHZhbHVlIGFzIHlEb21haW5NaW5cblx0XHRcdHlEb21haW5NYXggPSB5RG9tYWluTWluO1xuXHRcdH1cblxuXHRcdGlmICh5RG9tYWluTWluID09PSB5RG9tYWluTWF4KSB7XG5cdFx0XHR5RG9tYWluTWluIDwgMCA/IHlEb21haW5NYXggPSAwIDogeURvbWFpbk1pbiA9IDA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNBbGxQb3NpdGl2ZSA9IHlEb21haW5NaW4gPj0gMCAmJiB5RG9tYWluTWF4ID49IDA7XG5cdFx0Y29uc3QgaXNBbGxOZWdhdGl2ZSA9IHlEb21haW5NaW4gPD0gMCAmJiB5RG9tYWluTWF4IDw9IDA7XG5cblx0XHQvLyBDYW5jZWwgemVyb2Jhc2VkIGlmIGF4aXNfKl9taW4gLyBheGlzXypfbWF4IHNwZWNpZmllZFxuXHRcdGlmICgoaXNWYWx1ZSh5TWluKSAmJiBpc0FsbFBvc2l0aXZlKSB8fCAoaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSkge1xuXHRcdFx0aXNaZXJvQmFzZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcblx0XHRpZiAoaXNaZXJvQmFzZWQpIHtcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHlEb21haW5NaW4gPSAwKTtcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHlEb21haW5NYXggPSAwKTtcblx0XHR9XG5cblx0XHRjb25zdCBkb21haW5MZW5ndGggPSBNYXRoLmFicyh5RG9tYWluTWF4IC0geURvbWFpbk1pbik7XG5cdFx0Y29uc3QgcGFkZGluZyA9IHt0b3A6IGRvbWFpbkxlbmd0aCAqIDAuMSwgYm90dG9tOiBkb21haW5MZW5ndGggKiAwLjF9O1xuXG5cdFx0aWYgKGlzRGVmaW5lZChjZW50ZXIpKSB7XG5cdFx0XHRjb25zdCB5RG9tYWluQWJzID0gTWF0aC5tYXgoTWF0aC5hYnMoeURvbWFpbk1pbiksIE1hdGguYWJzKHlEb21haW5NYXgpKTtcblxuXHRcdFx0eURvbWFpbk1heCA9IGNlbnRlciArIHlEb21haW5BYnM7XG5cdFx0XHR5RG9tYWluTWluID0gY2VudGVyIC0geURvbWFpbkFicztcblx0XHR9XG5cblx0XHQvLyBhZGQgcGFkZGluZyBmb3IgZGF0YSBsYWJlbFxuXHRcdGlmIChzaG93SG9yaXpvbnRhbERhdGFMYWJlbCkge1xuXHRcdFx0Y29uc3QgZGlmZiA9IGRpZmZEb21haW4oJCQueS5yYW5nZSgpKTtcblx0XHRcdGNvbnN0IHJhdGlvID0gJCQuZ2V0RGF0YUxhYmVsTGVuZ3RoKHlEb21haW5NaW4sIHlEb21haW5NYXgsIFwid2lkdGhcIilcblx0XHRcdFx0Lm1hcCh2ID0+IHYgLyBkaWZmKTtcblxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0cGFkZGluZ1t2XSArPSBkb21haW5MZW5ndGggKiAocmF0aW9baV0gLyAoMSAtIHJhdGlvWzBdIC0gcmF0aW9bMV0pKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoc2hvd1ZlcnRpY2FsRGF0YUxhYmVsKSB7XG5cdFx0XHRjb25zdCBsZW5ndGhzID0gJCQuZ2V0RGF0YUxhYmVsTGVuZ3RoKHlEb21haW5NaW4sIHlEb21haW5NYXgsIFwiaGVpZ2h0XCIpO1xuXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRwYWRkaW5nW3ZdICs9ICQkLmF4aXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcobGVuZ3Roc1tpXSwgZG9tYWluTGVuZ3RoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICgvXnkyPyQvLnRlc3QoYXhpc0lkKSkge1xuXHRcdFx0Y29uc3QgcCA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fcGFkZGluZ2BdO1xuXG5cdFx0XHRpZiAobm90RW1wdHkocCkpIHtcblx0XHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdFx0cGFkZGluZ1t2XSA9ICQkLmF4aXMuZ2V0UGFkZGluZyhwLCB2LCBwYWRkaW5nW3ZdLCBkb21haW5MZW5ndGgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcblx0XHRpZiAoaXNaZXJvQmFzZWQpIHtcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHBhZGRpbmcuYm90dG9tID0geURvbWFpbk1pbik7XG5cdFx0XHRpc0FsbE5lZ2F0aXZlICYmIChwYWRkaW5nLnRvcCA9IC15RG9tYWluTWF4KTtcblx0XHR9XG5cblx0XHRjb25zdCBkb21haW4gPSBbeURvbWFpbk1pbiAtIHBhZGRpbmcuYm90dG9tLCB5RG9tYWluTWF4ICsgcGFkZGluZy50b3BdO1xuXG5cdFx0cmV0dXJuIGlzSW52ZXJ0ZWQgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xuXHR9LFxuXG5cdGdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB2YWx1ZSA9ICQkLmNvbmZpZ1tgYXhpc194XyR7dHlwZX1gXTtcblxuXHRcdHJldHVybiBpc0RlZmluZWQodmFsdWUpID9cblx0XHRcdCgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZSh2YWx1ZSkgOiB2YWx1ZSkgOlxuXHRcdFx0Z2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKHQgPT4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcCh2ID0+IHYueCkpKSk7XG5cdH0sXG5cblx0Z2V0WERvbWFpbk1pbih0YXJnZXRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcblx0fSxcblxuXHRnZXRYRG9tYWluTWF4KHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWF4XCIpO1xuXHR9LFxuXG5cdGdldFhEb21haW5QYWRkaW5nKGRvbWFpbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZGlmZiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcblx0XHRjb25zdCB4UGFkZGluZyA9IGNvbmZpZy5heGlzX3hfcGFkZGluZztcblx0XHRsZXQgbWF4RGF0YUNvdW50O1xuXHRcdGxldCBwYWRkaW5nO1xuXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0cGFkZGluZyA9IDA7XG5cdFx0fSBlbHNlIGlmICgkJC5oYXNUeXBlKFwiYmFyXCIpKSB7XG5cdFx0XHRtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcblx0XHRcdHBhZGRpbmcgPSBtYXhEYXRhQ291bnQgPiAxID8gKGRpZmYgLyAobWF4RGF0YUNvdW50IC0gMSkpIC8gMiA6IDAuNTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFkZGluZyA9IGRpZmYgKiAwLjAxO1xuXHRcdH1cblxuXHRcdGxldCBsZWZ0ID0gcGFkZGluZztcblx0XHRsZXQgcmlnaHQgPSBwYWRkaW5nO1xuXG5cdFx0aWYgKGlzT2JqZWN0KHhQYWRkaW5nKSAmJiBub3RFbXB0eSh4UGFkZGluZykpIHtcblx0XHRcdGxlZnQgPSBpc1ZhbHVlKHhQYWRkaW5nLmxlZnQpID8geFBhZGRpbmcubGVmdCA6IHBhZGRpbmc7XG5cdFx0XHRyaWdodCA9IGlzVmFsdWUoeFBhZGRpbmcucmlnaHQpID8geFBhZGRpbmcucmlnaHQgOiBwYWRkaW5nO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xuXHRcdFx0bGVmdCA9IHhQYWRkaW5nO1xuXHRcdFx0cmlnaHQgPSB4UGFkZGluZztcblx0XHR9XG5cblx0XHRyZXR1cm4ge2xlZnQsIHJpZ2h0fTtcblx0fSxcblxuXHRnZXRYRG9tYWluKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgeERvbWFpbiA9IFskJC5nZXRYRG9tYWluTWluKHRhcmdldHMpLCAkJC5nZXRYRG9tYWluTWF4KHRhcmdldHMpXTtcblx0XHRsZXQgZmlyc3RYID0geERvbWFpblswXTtcblx0XHRsZXQgbGFzdFggPSB4RG9tYWluWzFdO1xuXHRcdGNvbnN0IHBhZGRpbmcgPSAkJC5nZXRYRG9tYWluUGFkZGluZyh4RG9tYWluKTtcblx0XHRsZXQgbWluID0gMDtcblx0XHRsZXQgbWF4ID0gMDtcblxuXHRcdC8vIHNob3cgY2VudGVyIG9mIHggZG9tYWluIGlmIG1pbiBhbmQgbWF4IGFyZSB0aGUgc2FtZVxuXHRcdGlmICgoZmlyc3RYIC0gbGFzdFgpID09PSAwICYmICEkJC5pc0NhdGVnb3JpemVkKCkpIHtcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0XHRmaXJzdFggPSBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpICogMC41KTtcblx0XHRcdFx0bGFzdFggPSBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKiAxLjUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zmlyc3RYID0gZmlyc3RYID09PSAwID8gMSA6IChmaXJzdFggKiAwLjUpO1xuXHRcdFx0XHRsYXN0WCA9IGxhc3RYID09PSAwID8gLTEgOiAobGFzdFggKiAxLjUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChmaXJzdFggfHwgZmlyc3RYID09PSAwKSB7XG5cdFx0XHRtaW4gPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgLSBwYWRkaW5nLmxlZnQpIDogZmlyc3RYIC0gcGFkZGluZy5sZWZ0O1xuXHRcdH1cblxuXHRcdGlmIChsYXN0WCB8fCBsYXN0WCA9PT0gMCkge1xuXHRcdFx0bWF4ID0gJCQuaXNUaW1lU2VyaWVzKCkgPyBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKyBwYWRkaW5nLnJpZ2h0KSA6IGxhc3RYICsgcGFkZGluZy5yaWdodDtcblx0XHR9XG5cblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcblx0fSxcblxuXHR1cGRhdGVYRG9tYWluKHRhcmdldHMsIHdpdGhVcGRhdGVYRG9tYWluLCB3aXRoVXBkYXRlT3JnWERvbWFpbiwgd2l0aFRyaW0sIGRvbWFpbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xuXG5cdFx0aWYgKHdpdGhVcGRhdGVPcmdYRG9tYWluKSB7XG5cdFx0XHQkJC54LmRvbWFpbihkb21haW4gfHwgc29ydFZhbHVlKCQkLmdldFhEb21haW4odGFyZ2V0cykpKTtcblx0XHRcdCQkLm9yZ1hEb21haW4gPSAkJC54LmRvbWFpbigpO1xuXG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XG5cblx0XHRcdCQkLnN1YlguZG9tYWluKCQkLnguZG9tYWluKCkpO1xuXHRcdFx0JCQuYnJ1c2ggJiYgJCQuYnJ1c2guc2NhbGUoJCQuc3ViWCk7XG5cdFx0fVxuXG5cdFx0aWYgKHdpdGhVcGRhdGVYRG9tYWluKSB7XG5cdFx0XHRjb25zdCBkb21haW5WYWx1ZSA9IGRvbWFpbiB8fCAoISQkLmJydXNoIHx8IGJydXNoRW1wdHkoJCQpKSA/XG5cdFx0XHRcdCQkLm9yZ1hEb21haW4gOiBnZXRCcnVzaFNlbGVjdGlvbigkJCkubWFwKCQkLnN1YlguaW52ZXJ0KTtcblxuXHRcdFx0JCQueC5kb21haW4oZG9tYWluVmFsdWUpO1xuXHRcdFx0em9vbUVuYWJsZWQgJiYgJCQuem9vbS51cGRhdGVTY2FsZUV4dGVudCgpO1xuXHRcdH1cblxuXHRcdC8vIFRyaW0gZG9tYWluIHdoZW4gdG9vIGJpZyBieSB6b29tIG1vdXNlbW92ZSBldmVudFxuXHRcdHdpdGhUcmltICYmICQkLnguZG9tYWluKCQkLnRyaW1YRG9tYWluKCQkLngub3JnRG9tYWluKCkpKTtcblxuXHRcdHJldHVybiAkJC54LmRvbWFpbigpO1xuXHR9LFxuXG5cdHRyaW1YRG9tYWluKGRvbWFpbikge1xuXHRcdGNvbnN0IHpvb21Eb21haW4gPSB0aGlzLmdldFpvb21Eb21haW4oKTtcblx0XHRjb25zdCBbbWluLCBtYXhdID0gem9vbURvbWFpbjtcblxuXHRcdGlmIChkb21haW5bMF0gPD0gbWluKSB7XG5cdFx0XHRkb21haW5bMV0gPSArZG9tYWluWzFdICsgKG1pbiAtIGRvbWFpblswXSk7XG5cdFx0XHRkb21haW5bMF0gPSBtaW47XG5cdFx0fVxuXG5cdFx0aWYgKG1heCA8PSBkb21haW5bMV0pIHtcblx0XHRcdGRvbWFpblswXSA9ICtkb21haW5bMF0gLSAoZG9tYWluWzFdIC0gbWF4KTtcblx0XHRcdGRvbWFpblsxXSA9IG1heDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZG9tYWluO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7XG5cdGV4dGVuZCxcblx0Z2V0VW5pcXVlLFxuXHRoYXNWYWx1ZSxcblx0aXNBcnJheSxcblx0aXNCb29sZWFuLFxuXHRpc0RlZmluZWQsXG5cdGlzRnVuY3Rpb24sXG5cdGlzTnVtYmVyLFxuXHRpc09iamVjdCxcblx0aXNPYmplY3RUeXBlLFxuXHRpc1N0cmluZyxcblx0aXNVbmRlZmluZWQsXG5cdGlzVmFsdWUsXG5cdG5vdEVtcHR5LFxuXHRtZXJnZUFycmF5LFxuXHRzb3J0VmFsdWVcbn0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpc1goa2V5KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkYXRhS2V5ID0gY29uZmlnLmRhdGFfeCAmJiBrZXkgPT09IGNvbmZpZy5kYXRhX3g7XG5cdFx0Y29uc3QgZXhpc3RWYWx1ZSA9IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSAmJiBoYXNWYWx1ZShjb25maWcuZGF0YV94cywga2V5KTtcblxuXHRcdHJldHVybiBkYXRhS2V5IHx8IGV4aXN0VmFsdWU7XG5cdH0sXG5cblx0aXNOb3RYKGtleSkge1xuXHRcdHJldHVybiAhdGhpcy5pc1goa2V5KTtcblx0fSxcblxuXHRpc1N0YWNrTm9ybWFsaXplZCgpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuXHRcdHJldHVybiBjb25maWcuZGF0YV9zdGFja19ub3JtYWxpemUgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aDtcblx0fSxcblxuXHRpc0dyb3VwZWQoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZGF0YV9ncm91cHNcblx0XHRcdC5tYXAodiA9PiB2LmluZGV4T2YoaWQpID49IDApWzBdO1xuXHR9LFxuXG5cdGdldFhLZXkoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX3ggP1xuXHRcdFx0Y29uZmlnLmRhdGFfeCA6IChub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsKTtcblx0fSxcblxuXHRnZXRYVmFsdWVzT2ZYS2V5KGtleSwgdGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpZHMgPSB0YXJnZXRzICYmIG5vdEVtcHR5KHRhcmdldHMpID8gJCQubWFwVG9JZHModGFyZ2V0cykgOiBbXTtcblx0XHRsZXQgeFZhbHVlcztcblxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGlmICgkJC5nZXRYS2V5KGlkKSA9PT0ga2V5KSB7XG5cdFx0XHRcdHhWYWx1ZXMgPSAkJC5kYXRhLnhzW2lkXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB4VmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgaW5kZXggbnVtYmVyIGJhc2VkIG9uIGdpdmVuIHggQXhpcyB2YWx1ZVxuXHQgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ30geCB4IEF4aXMgdG8gYmUgY29tcGFyZWRcblx0ICogQHBhcmFtIHtBcnJheX0gYmFzZWRYIHggQXhpcyBsaXN0IHRvIGJlIGJhc2VkIG9uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gaW5kZXggbnVtYmVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRJbmRleEJ5WCh4LCBiYXNlZFgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gYmFzZWRYID9cblx0XHRcdGJhc2VkWC5pbmRleE9mKGlzU3RyaW5nKHgpID8geCA6ICt4KSA6XG5cdFx0XHQoJCQuZmlsdGVyQnlYKCQkLmRhdGEudGFyZ2V0cywgeClbMF0gfHwge2luZGV4OiBudWxsfSkuaW5kZXg7XG5cdH0sXG5cblx0Z2V0WFZhbHVlKGlkLCBpKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGlkIGluICQkLmRhdGEueHMgJiZcblx0XHRcdCQkLmRhdGEueHNbaWRdICYmXG5cdFx0XHRpc1ZhbHVlKCQkLmRhdGEueHNbaWRdW2ldKSA/ICQkLmRhdGEueHNbaWRdW2ldIDogaTtcblx0fSxcblxuXHRnZXRPdGhlclRhcmdldFhzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpZHNGb3JYID0gT2JqZWN0LmtleXMoJCQuZGF0YS54cyk7XG5cblx0XHRyZXR1cm4gaWRzRm9yWC5sZW5ndGggPyAkJC5kYXRhLnhzW2lkc0ZvclhbMF1dIDogbnVsbDtcblx0fSxcblxuXHRnZXRPdGhlclRhcmdldFgoaW5kZXgpIHtcblx0XHRjb25zdCB4cyA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xuXG5cdFx0cmV0dXJuIHhzICYmIGluZGV4IDwgeHMubGVuZ3RoID8geHNbaW5kZXhdIDogbnVsbDtcblx0fSxcblxuXHRhZGRYcyh4cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdCQkLmNvbmZpZy5kYXRhX3hzW2lkXSA9IHhzW2lkXTtcblx0XHR9KTtcblx0fSxcblxuXHRoYXNNdWx0aXBsZVgoeHMpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMoeHMpLm1hcChpZCA9PiB4c1tpZF0pLmxlbmd0aCA+IDE7XG5cdH0sXG5cblx0aXNNdWx0aXBsZVgoKSB7XG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRoaXMuY29uZmlnLmRhdGFfeHMpIHx8XG5cdFx0XHQhdGhpcy5jb25maWcuZGF0YV94U29ydCB8fFxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XG5cdFx0XHR0aGlzLmhhc1R5cGUoXCJzY2F0dGVyXCIpO1xuXHR9LFxuXG5cdGFkZE5hbWUoZGF0YSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgbmFtZTtcblxuXHRcdGlmIChkYXRhKSB7XG5cdFx0XHRuYW1lID0gJCQuY29uZmlnLmRhdGFfbmFtZXNbZGF0YS5pZF07XG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRnZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKVxuXHRcdFx0Lm1hcCh0ID0+ICQkLmFkZE5hbWUoJCQuZ2V0VmFsdWVPbkluZGV4KHQudmFsdWVzLCBpbmRleCkpKTtcblx0fSxcblxuXHRnZXRWYWx1ZU9uSW5kZXgodmFsdWVzLCBpbmRleCkge1xuXHRcdGNvbnN0IHZhbHVlT25JbmRleCA9IHZhbHVlcy5maWx0ZXIodiA9PiB2LmluZGV4ID09PSBpbmRleCk7XG5cblx0XHRyZXR1cm4gdmFsdWVPbkluZGV4Lmxlbmd0aCA/IHZhbHVlT25JbmRleFswXSA6IG51bGw7XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0WCh0YXJnZXRzLCB4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHR2LnggPSAkJC5nZW5lcmF0ZVRhcmdldFgoeFtpXSwgdC5pZCwgaSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXSA9IHg7XG5cdFx0fSk7XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0WHModGFyZ2V0cywgeHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHR4c1t0LmlkXSAmJiAkJC51cGRhdGVUYXJnZXRYKFt0XSwgeHNbdC5pZF0pO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaW5kZXgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHggPSAkJC5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IChyYXdYIHx8IGluZGV4KTtcblxuXHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0eCA9IHJhd1ggPyAkJC5wYXJzZURhdGUocmF3WCkgOiAkJC5wYXJzZURhdGUoJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCkpO1xuXHRcdH0gZWxzZSBpZiAoJCQuaXNDdXN0b21YKCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuXHRcdFx0eCA9IGlzVmFsdWUocmF3WCkgPyArcmF3WCA6ICQkLmdldFhWYWx1ZShpZCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB4O1xuXHR9LFxuXG5cdGNsb25lVGFyZ2V0KHRhcmdldCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRpZDogdGFyZ2V0LmlkLFxuXHRcdFx0aWRfb3JnOiB0YXJnZXQuaWRfb3JnLFxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcblx0XHR9O1xuXHR9LFxuXG5cdHVwZGF0ZVhzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xuXG5cdFx0aWYgKHRhcmdldHMubGVuZ3RoKSB7XG5cdFx0XHQkJC54cyA9IFtdO1xuXG5cdFx0XHR0YXJnZXRzWzBdLnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHQkJC54c1t2LmluZGV4XSA9IHYueDtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQcmV2WChpKSB7XG5cdFx0Y29uc3QgeCA9IHRoaXMueHNbaSAtIDFdO1xuXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHRYKGkpIHtcblx0XHRjb25zdCB4ID0gdGhpcy54c1tpICsgMV07XG5cblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBiYXNlIHZhbHVlIGlzQXJlYVJhbmdlVHlwZVxuXHQgKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRCYXNlVmFsdWUoZGF0YSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgdmFsdWUgPSBkYXRhLnZhbHVlO1xuXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cblx0XHQvLyB3aWxsIHRha2UgdGhlICdtaWQnIGFzIHRoZSBiYXNlIHZhbHVlXG5cdFx0aWYgKHZhbHVlICYmICQkLmlzQXJlYVJhbmdlVHlwZShkYXRhKSkge1xuXHRcdFx0dmFsdWUgPSAkJC5nZXRBcmVhUmFuZ2VEYXRhKGRhdGEsIFwibWlkXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IG1pbi9tYXggdmFsdWUgZnJvbSB0aGUgZGF0YVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBkYXRhIGFycmF5IGRhdGEgdG8gYmUgZXZhbHVhdGVkXG5cdCAqIEByZXR1cm4ge3ttaW46IHtOdW1iZXJ9LCBtYXg6IHtOdW1iZXJ9fX1cblx0ICovXG5cdGdldE1pbk1heFZhbHVlKGRhdGEpIHtcblx0XHRjb25zdCBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xuXHRcdGxldCBtaW47XG5cdFx0bGV0IG1heDtcblxuXHRcdChkYXRhIHx8IHRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcblx0XHRcdC5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xuXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKGkgPyBtaW4gOiBJbmZpbml0eSwgLi4udmFsdWUpO1xuXHRcdFx0XHRtYXggPSBNYXRoLm1heChpID8gbWF4IDogLUluZmluaXR5LCAuLi52YWx1ZSk7XG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiB7bWluLCBtYXh9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1pbi9tYXggZGF0YVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJuIHt7bWluOiBBcnJheSwgbWF4OiBBcnJheX19XG5cdCAqL1xuXHRnZXRNaW5NYXhEYXRhKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJG1pbk1heERhdGFcIjtcblx0XHRsZXQgbWluTWF4RGF0YSA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICghbWluTWF4RGF0YSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9ICQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcyk7XG5cdFx0XHRjb25zdCBtaW5NYXggPSAkJC5nZXRNaW5NYXhWYWx1ZShkYXRhKTtcblxuXHRcdFx0bGV0IG1pbiA9IFtdO1xuXHRcdFx0bGV0IG1heCA9IFtdO1xuXG5cdFx0XHRkYXRhLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IG1pbkRhdGEgPSAkJC5nZXRGaWx0ZXJlZERhdGFCeVZhbHVlKHYsIG1pbk1heC5taW4pO1xuXHRcdFx0XHRjb25zdCBtYXhEYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWF4KTtcblxuXHRcdFx0XHRpZiAobWluRGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0XHRtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1heERhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bWF4ID0gbWF4LmNvbmNhdChtYXhEYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgY2FjaGVkIGRhdGFcblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCBtaW5NYXhEYXRhID0ge21pbiwgbWF4fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbk1heERhdGE7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBzdW0gb2YgZGF0YSBwZXIgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRnZXRUb3RhbFBlckluZGV4KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJHRvdGFsUGVySW5kZXhcIjtcblx0XHRsZXQgc3VtID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgIXN1bSkge1xuXHRcdFx0c3VtID0gW107XG5cblx0XHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKHJvdyA9PiB7XG5cdFx0XHRcdHJvdy52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XG5cdFx0XHRcdFx0XHRzdW1baV0gPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN1bVtpXSArPSBpc051bWJlcih2LnZhbHVlKSA/IHYudmFsdWUgOiAwO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdW07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0b3RhbCBkYXRhIHN1bVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VG90YWxEYXRhU3VtKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJHRvdGFsRGF0YVN1bVwiO1xuXHRcdGxldCB0b3RhbERhdGFTdW0gPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRpZiAoIXRvdGFsRGF0YVN1bSkge1xuXHRcdFx0Y29uc3QgdG90YWwgPSBtZXJnZUFycmF5KCQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpXG5cdFx0XHRcdC5tYXAodiA9PiB2LnZhbHVlKVxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XG5cblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCB0b3RhbERhdGFTdW0gPSB0b3RhbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvdGFsRGF0YVN1bTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGZpbHRlcmVkIGRhdGEgYnkgdmFsdWVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge0FycmF5fSBmaWx0ZXJlZCBhcnJheSBkYXRhXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRGaWx0ZXJlZERhdGFCeVZhbHVlKGRhdGEsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBkYXRhXG5cdCAqIEByZXR1cm4ge051bWJlcn0gbWF4IGRhdGEgbGVuZ3RoXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRNYXhEYXRhQ291bnQoKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xuXHR9LFxuXG5cdGdldE1heERhdGFDb3VudFRhcmdldCh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgbGVuZ3RoID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0bGV0IG1heCA9IDA7XG5cdFx0bGV0IG1heFRhcmdldDtcblxuXHRcdGlmIChsZW5ndGggPiAxKSB7XG5cdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHRcdGlmICh0LnZhbHVlcy5sZW5ndGggPiBtYXgpIHtcblx0XHRcdFx0XHRtYXhUYXJnZXQgPSB0O1xuXHRcdFx0XHRcdG1heCA9IHQudmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1heFRhcmdldCA9IGxlbmd0aCA/IHRhcmdldHNbMF0gOiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXhUYXJnZXQ7XG5cdH0sXG5cblx0bWFwVG9JZHModGFyZ2V0cykge1xuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xuXHR9LFxuXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcblx0fSxcblxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpIHtcblx0XHRjb25zdCBpZHMgPSB0aGlzLm1hcFRvSWRzKHRhcmdldHMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xuXHRcdFx0aWYgKHZhbCA9PT0gaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YodGFyZ2V0SWQpIDwgMDtcblx0fSxcblxuXHRpc0xlZ2VuZFRvU2hvdyh0YXJnZXRJZCkge1xuXHRcdHJldHVybiB0aGlzLmhpZGRlbkxlZ2VuZElkcy5pbmRleE9mKHRhcmdldElkKSA8IDA7XG5cdH0sXG5cblx0ZmlsdGVyVGFyZ2V0c1RvU2hvdyh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICh0YXJnZXRzIHx8ICQkLmRhdGEudGFyZ2V0cykuZmlsdGVyKHQgPT4gJCQuaXNUYXJnZXRUb1Nob3codC5pZCkpO1xuXHR9LFxuXG5cdG1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHhzID0gW107XG5cblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xuXHRcdFx0eHMgPSBnZXRVbmlxdWUoXG5cdFx0XHRcdG1lcmdlQXJyYXkodGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcy5tYXAodiA9PiArdi54KSkpXG5cdFx0XHQpO1xuXG5cdFx0XHR4cyA9ICQkLmlzVGltZVNlcmllcygpID8geHMubWFwKHggPT4gbmV3IERhdGUoK3gpKSA6IHhzLm1hcCh4ID0+ICt4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc29ydFZhbHVlKHhzKTtcblx0fSxcblxuXHRhZGRIaWRkZW5UYXJnZXRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLmhpZGRlblRhcmdldElkcy5jb25jYXQodGFyZ2V0SWRzKTtcblx0fSxcblxuXHRyZW1vdmVIaWRkZW5UYXJnZXRJZHModGFyZ2V0SWRzKSB7XG5cdFx0dGhpcy5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XG5cdH0sXG5cblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcykge1xuXHRcdHRoaXMuaGlkZGVuTGVnZW5kSWRzID0gdGhpcy5oaWRkZW5MZWdlbmRJZHMuY29uY2F0KHRhcmdldElkcyk7XG5cdH0sXG5cblx0cmVtb3ZlSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcykge1xuXHRcdHRoaXMuaGlkZGVuTGVnZW5kSWRzID0gdGhpcy5oaWRkZW5MZWdlbmRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xuXHR9LFxuXG5cdGdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHlzID0ge307XG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xuXHRcdGNvbnN0IHhzID0gaXNNdWx0aXBsZVggPyAkJC5tYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKVxuXHRcdFx0Lm1hcCh2ID0+IChpc1N0cmluZyh2KSA/IHYgOiArdikpIDogbnVsbDtcblxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBbXTtcblxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2LnZhbHVlO1xuXG5cdFx0XHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGRhdGEucHVzaCguLi52YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpICYmIFwiaGlnaFwiIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcblx0XHRcdFx0XHRcdGRhdGFbJCQuZ2V0SW5kZXhCeVgodi54LCB4cyldID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGEucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0eXNbdC5pZF0gPSBkYXRhO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHlzO1xuXHR9LFxuXG5cdGNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgY2hlY2tlcikge1xuXHRcdGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKHRhcmdldHMpO1xuXHRcdGxldCB2YWx1ZXM7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzID0gdGFyZ2V0c1tpZHNbaV1dLnZhbHVlcztcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGhhc011bHRpVGFyZ2V0cygpIHtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJUYXJnZXRzVG9TaG93KCkubGVuZ3RoID4gMTtcblx0fSxcblxuXHRoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIHYgPT4gdiA8IDApO1xuXHR9LFxuXG5cdGhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cykge1xuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2ID4gMCk7XG5cdH0sXG5cblx0X2NoZWNrT3JkZXIodHlwZSkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IG9yZGVyID0gY29uZmlnLmRhdGFfb3JkZXI7XG5cblx0XHRyZXR1cm4gaXNTdHJpbmcob3JkZXIpICYmIG9yZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR5cGU7XG5cdH0sXG5cblx0aXNPcmRlckRlc2MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJkZXNjXCIpO1xuXHR9LFxuXG5cdGlzT3JkZXJBc2MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJhc2NcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNvcnQgdGFyZ2V0cyBkYXRhXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNWYWx1ZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9yZGVyVGFyZ2V0cyh0YXJnZXRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcblx0XHRjb25zdCBvcmRlckFzYyA9ICQkLmlzT3JkZXJBc2MoKTtcblx0XHRjb25zdCBvcmRlckRlc2MgPSAkJC5pc09yZGVyRGVzYygpO1xuXG5cdFx0aWYgKG9yZGVyQXNjIHx8IG9yZGVyRGVzYykge1xuXHRcdFx0dGFyZ2V0cy5zb3J0KCh0MSwgdDIpID0+IHtcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XG5cdFx0XHRcdGNvbnN0IHQxU3VtID0gdDEudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcblx0XHRcdFx0Y29uc3QgdDJTdW0gPSB0Mi52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xuXG5cdFx0XHRcdHJldHVybiBvcmRlckFzYyA/IHQyU3VtIC0gdDFTdW0gOiB0MVN1bSAtIHQyU3VtO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xuXHRcdFx0dGFyZ2V0cy5zb3J0KGNvbmZpZy5kYXRhX29yZGVyKTtcblx0XHR9IC8vIFRPRE86IGFjY2VwdCBuYW1lIGFycmF5IGZvciBvcmRlclxuXG5cdFx0cmV0dXJuIHRhcmdldHM7XG5cdH0sXG5cblx0ZmlsdGVyQnlYKHRhcmdldHMsIHgpIHtcblx0XHRyZXR1cm4gbWVyZ2VBcnJheSh0YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSkuZmlsdGVyKHYgPT4gdi54IC0geCA9PT0gMCk7XG5cdH0sXG5cblx0ZmlsdGVyUmVtb3ZlTnVsbChkYXRhKSB7XG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKGQgPT4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkpO1xuXHR9LFxuXG5cdGZpbHRlckJ5WERvbWFpbih0YXJnZXRzLCB4RG9tYWluKSB7XG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKHQgPT4gKHtcblx0XHRcdGlkOiB0LmlkLFxuXHRcdFx0aWRfb3JnOiB0LmlkX29yZyxcblx0XHRcdHZhbHVlczogdC52YWx1ZXMuZmlsdGVyKHYgPT4geERvbWFpblswXSA8PSB2LnggJiYgdi54IDw9IHhEb21haW5bMV0pXG5cdFx0fSkpO1xuXHR9LFxuXG5cdGhhc0RhdGFMYWJlbCgpIHtcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHM7XG5cblx0XHRyZXR1cm4gKGlzQm9vbGVhbihkYXRhTGFiZWxzKSAmJiBkYXRhTGFiZWxzKSB8fFxuXHRcdFx0KGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzKSAmJiBub3RFbXB0eShkYXRhTGFiZWxzKSk7XG5cdH0sXG5cblx0Z2V0RGF0YUxhYmVsTGVuZ3RoKG1pbiwgbWF4LCBrZXkpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbGVuZ3RocyA9IFswLCAwXTtcblx0XHRjb25zdCBwYWRkaW5nQ29lZiA9IDEuMztcblxuXHRcdCQkLnNlbGVjdENoYXJ0LnNlbGVjdChcInN2Z1wiKS5zZWxlY3RBbGwoXCIuZHVtbXlcIilcblx0XHRcdC5kYXRhKFttaW4sIG1heF0pXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcblx0XHRcdC50ZXh0KGQgPT4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKGQpKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRsZW5ndGhzW2ldID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldICogcGFkZGluZ0NvZWY7XG5cdFx0XHR9KVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIGxlbmd0aHM7XG5cdH0sXG5cblx0aXNOb25lQXJjKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuaWQpO1xuXHR9LFxuXG5cdGlzQXJjKGQpIHtcblx0XHRyZXR1cm4gXCJkYXRhXCIgaW4gZCAmJiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5kYXRhLmlkKTtcblx0fSxcblxuXHRmaW5kU2FtZVhPZlZhbHVlcyh2YWx1ZXMsIGluZGV4KSB7XG5cdFx0Y29uc3QgdGFyZ2V0WCA9IHZhbHVlc1tpbmRleF0ueDtcblx0XHRjb25zdCBzYW1lcyA9IFtdO1xuXHRcdGxldCBpO1xuXG5cdFx0Zm9yIChpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0c2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzYW1lcztcblx0fSxcblxuXHRmaW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHMsIHBvcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+ICQkLmZpbmRDbG9zZXN0KHRhcmdldC52YWx1ZXMsIHBvcykpOyAvLyBtYXAgdG8gYXJyYXkgb2YgY2xvc2VzdCBwb2ludHMgb2YgZWFjaCB0YXJnZXRcblxuXHRcdC8vIGRlY2lkZSBjbG9zZXN0IHBvaW50IGFuZCByZXR1cm5cblx0XHRyZXR1cm4gJCQuZmluZENsb3Nlc3QoY2FuZGlkYXRlcywgcG9zKTtcblx0fSxcblxuXHRmaW5kQ2xvc2VzdCh2YWx1ZXMsIHBvcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgbWluRGlzdCA9ICQkLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eTtcblx0XHRsZXQgY2xvc2VzdDtcblxuXHRcdC8vIGZpbmQgbW91c2VvdmVyaW5nIGJhclxuXHRcdHZhbHVlc1xuXHRcdFx0LmZpbHRlcih2ID0+IHYgJiYgJCQuaXNCYXJUeXBlKHYuaWQpKVxuXHRcdFx0LmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh2LmlkKX0gLiR7Q0xBU1MuYmFyfS0ke3YuaW5kZXh9YCkubm9kZSgpO1xuXG5cdFx0XHRcdGlmICghY2xvc2VzdCAmJiAkJC5pc1dpdGhpbkJhcihzaGFwZSkpIHtcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHQvLyBmaW5kIGNsb3Nlc3QgcG9pbnQgZnJvbSBub24tYmFyXG5cdFx0dmFsdWVzXG5cdFx0XHQuZmlsdGVyKHYgPT4gdiAmJiAhJCQuaXNCYXJUeXBlKHYuaWQpKVxuXHRcdFx0LmZvckVhY2godiA9PiB7XG5cdFx0XHRcdGNvbnN0IGQgPSAkJC5kaXN0KHYsIHBvcyk7XG5cblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0bWluRGlzdCA9IGQ7XG5cdFx0XHRcdFx0Y2xvc2VzdCA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XG5cdH0sXG5cblx0ZGlzdChkYXRhLCBwb3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGNvbnN0IHhJbmRleCA9IGlzUm90YXRlZCA/IDEgOiAwO1xuXHRcdGNvbnN0IHlJbmRleCA9IGlzUm90YXRlZCA/IDAgOiAxO1xuXHRcdGNvbnN0IHkgPSAkJC5jaXJjbGVZKGRhdGEsIGRhdGEuaW5kZXgpO1xuXHRcdGNvbnN0IHggPSAoJCQuem9vbVNjYWxlIHx8ICQkLngpKGRhdGEueCk7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NbeEluZGV4XSwgMikgKyBNYXRoLnBvdyh5IC0gcG9zW3lJbmRleF0sIDIpKTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydCBkYXRhIGZvciBzdGVwIHR5cGVcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIE9iamVjdCBkYXRhIHZhbHVlc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3Qgc3RlcFR5cGUgPSBjb25maWcubGluZV9zdGVwX3R5cGU7XG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xuXG5cdFx0aWYgKCFpc1JvdGF0ZWQgJiYgIWlzQ2F0ZWdvcml6ZWQpIHtcblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fVxuXG5cdFx0Ly8gaW5zZXJ0ICYgYXBwZW5kIGNsb25pbmcgZmlyc3QvbGFzdCB2YWx1ZSB0byBiZSBmdWxseSByZW5kZXJlZCBjb3ZlcmluZyBvbiBlYWNoIGdhcCBzaWRlc1xuXHRcdGNvbnN0IGlkID0gY29udmVydGVkWzBdLmlkO1xuXG5cdFx0Ly8gaW5zZXJ0XG5cdFx0bGV0IHggPSBjb252ZXJ0ZWRbMF0ueCAtIDE7XG5cdFx0bGV0IHZhbHVlID0gY29udmVydGVkWzBdLnZhbHVlO1xuXG5cdFx0aXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQudW5zaGlmdCh7eCwgdmFsdWUsIGlkfSk7XG5cblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcblx0XHRcdGNvbnZlcnRlZC51bnNoaWZ0KHt4OiB4IC0gMSwgdmFsdWUsIGlkfSk7XG5cblx0XHQvLyBhcHBlbmRcblx0XHR4ID0gY29udmVydGVkLmxlbmd0aDtcblx0XHR2YWx1ZSA9IGNvbnZlcnRlZFt4IC0gMV0udmFsdWU7XG5cblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC5wdXNoKHt4LCB2YWx1ZSwgaWR9KTtcblxuXHRcdHN0ZXBUeXBlID09PSBcInN0ZXAtYmVmb3JlXCIgJiZcblx0XHRcdGNvbnZlcnRlZC5wdXNoKHt4OiB4ICsgMSwgdmFsdWUsIGlkfSk7XG5cblx0XHRyZXR1cm4gY29udmVydGVkO1xuXHR9LFxuXG5cdGNvbnZlcnRWYWx1ZXNUb1JhbmdlKHZhbHVlcykge1xuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xuXHRcdGNvbnN0IHJhbmdlcyA9IFtdO1xuXG5cdFx0Y29udmVydGVkLmZvckVhY2gocmFuZ2UgPT4ge1xuXHRcdFx0Y29uc3Qge3gsIGlkfSA9IHJhbmdlO1xuXG5cdFx0XHRyYW5nZXMucHVzaCh7XG5cdFx0XHRcdHgsXG5cdFx0XHRcdGlkLFxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMF1cblx0XHRcdH0pO1xuXG5cdFx0XHRyYW5nZXMucHVzaCh7XG5cdFx0XHRcdHgsXG5cdFx0XHRcdGlkLFxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMl1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJhbmdlcztcblx0fSxcblxuXHR1cGRhdGVEYXRhQXR0cmlidXRlcyhuYW1lLCBhdHRycykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY3VycmVudCA9IGNvbmZpZ1tgZGF0YV8ke25hbWV9YF07XG5cblx0XHRpZiAoaXNVbmRlZmluZWQoYXR0cnMpKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudDtcblx0XHR9XG5cblx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjdXJyZW50W2lkXSA9IGF0dHJzW2lkXTtcblx0XHR9KTtcblxuXHRcdCQkLnJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xuXG5cdFx0cmV0dXJuIGN1cnJlbnQ7XG5cdH0sXG5cblx0Z2V0QXJlYVJhbmdlRGF0YShkLCB0eXBlKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBkLnZhbHVlO1xuXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IFtcImhpZ2hcIiwgXCJtaWRcIiwgXCJsb3dcIl0uaW5kZXhPZih0eXBlKTtcblxuXHRcdFx0cmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB2YWx1ZVtpbmRleF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlW3R5cGVdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgcmF0aW8gdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgUmF0aW8gZm9yIGdpdmVuIHR5cGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSB2YWx1ZSBvYmplY3Rcblx0ICogQHBhcmFtIHtCb29sZWFufSBhc1BlcmNlbnQgQ29udmVydCB0aGUgcmV0dXJuIGFzIHBlcmNlbnQgb3Igbm90XG5cdCAqIEByZXR1cm4ge051bWJlcn0gUmF0aW8gdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFJhdGlvKHR5cGUsIGQsIGFzUGVyY2VudCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXBpID0gJCQuYXBpO1xuXHRcdGxldCByYXRpbyA9IDA7XG5cblx0XHRpZiAoZCAmJiBhcGkuZGF0YS5zaG93bi5jYWxsKGFwaSkubGVuZ3RoKSB7XG5cdFx0XHRjb25zdCBkYXRhVmFsdWVzID0gYXBpLmRhdGEudmFsdWVzLmJpbmQoYXBpKTtcblxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XG5cblx0XHRcdGlmICh0eXBlID09PSBcImFyY1wiKSB7XG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXG5cdFx0XHRcdGlmICgkJC5waWUucGFkQW5nbGUoKSgpKSB7XG5cdFx0XHRcdFx0bGV0IHRvdGFsID0gJCQuZ2V0VG90YWxEYXRhU3VtKCk7XG5cblx0XHRcdFx0XHRpZiAoJCQuaGlkZGVuVGFyZ2V0SWRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dG90YWwgLT0gZGF0YVZhbHVlcygkJC5oaWRkZW5UYXJnZXRJZHMpLnJlZHVjZSgocCwgYykgPT4gcCArIGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJhdGlvID0gZC52YWx1ZSAvIHRvdGFsO1xuXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCBiYXNlZCBvbiB0aGUgcmVuZGVyZWQgYW5nbGUgdmFsdWVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcblx0XHRcdFx0XHRcdE1hdGguUEkgKiAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDEgOiAyKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbmRleFwiKSB7XG5cdFx0XHRcdGxldCB0b3RhbCA9IHRoaXMuZ2V0VG90YWxQZXJJbmRleCgpO1xuXG5cdFx0XHRcdGlmICgkJC5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bGV0IGhpZGRlblN1bSA9IGRhdGFWYWx1ZXMoJCQuaGlkZGVuVGFyZ2V0SWRzLCBmYWxzZSk7XG5cblx0XHRcdFx0XHRpZiAoaGlkZGVuU3VtLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aGlkZGVuU3VtID0gaGlkZGVuU3VtXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xuXG5cdFx0XHRcdFx0XHR0b3RhbCA9IHRvdGFsLm1hcCgodiwgaSkgPT4gdiAtIGhpZGRlblN1bVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XG5cdFx0XHRcdFx0ZC52YWx1ZSAvIHRvdGFsW2QuaW5kZXhdIDogMDtcblxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwicmFkYXJcIikge1xuXHRcdFx0XHRyYXRpbyA9IChwYXJzZUZsb2F0KE1hdGgubWF4KGQudmFsdWUsIDApKSAvICQkLm1heFZhbHVlKSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhc1BlcmNlbnQgJiYgcmF0aW8gPyByYXRpbyAqIDEwMCA6IHJhdGlvO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdGNzdlBhcnNlIGFzIGQzQ3N2UGFyc2UsXG5cdHRzdlBhcnNlIGFzIGQzVHN2UGFyc2UsXG5cdGNzdlBhcnNlUm93cyBhcyBkM0NzdlBhcnNlUm93cyxcblx0dHN2UGFyc2VSb3dzIGFzIGQzVHN2UGFyc2VSb3dzLFxufSBmcm9tIFwiZDMtZHN2XCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7aXNVbmRlZmluZWQsIGlzRGVmaW5lZCwgaXNPYmplY3QsIGlzVmFsdWUsIG5vdEVtcHR5LCBleHRlbmQsIGlzQXJyYXksIGNhcGl0YWxpemV9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENvbnZlcnQgZGF0YSBhY2NvcmRpbmcgaXRzIHR5cGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgZGF0YSBvYmplY3Rcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnZlcnREYXRhKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCBkYXRhO1xuXG5cdFx0aWYgKGFyZ3MuYmluZHRvKSB7XG5cdFx0XHRkYXRhID0ge307XG5cblx0XHRcdFtcInVybFwiLCBcIm1pbWVUeXBlXCIsIFwiaGVhZGVyc1wiLCBcImtleXNcIiwgXCJqc29uXCIsIFwia2V5c1wiLCBcInJvd3NcIiwgXCJjb2x1bW5zXCJdXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGtleSA9IGBkYXRhXyR7dn1gO1xuXG5cdFx0XHRcdFx0aWYgKGtleSBpbiBhcmdzKSB7XG5cdFx0XHRcdFx0XHRkYXRhW3ZdID0gYXJnc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChkYXRhLnVybCAmJiBjYWxsYmFjaykge1xuXHRcdFx0JCQuY29udmVydFVybFRvRGF0YShkYXRhLnVybCwgZGF0YS5taW1lVHlwZSwgZGF0YS5oZWFkZXJzLCBkYXRhLmtleXMsIGNhbGxiYWNrKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuanNvbikge1xuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEucm93cykge1xuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnRSb3dzVG9EYXRhKGRhdGEucm93cyk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLmNvbHVtbnMpIHtcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0Q29sdW1uc1RvRGF0YShkYXRhLmNvbHVtbnMpO1xuXHRcdH0gZWxzZSBpZiAoYXJncy5iaW5kdG8pIHtcblx0XHRcdHRocm93IEVycm9yKFwidXJsIG9yIGpzb24gb3Igcm93cyBvciBjb2x1bW5zIGlzIHJlcXVpcmVkLlwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRjb252ZXJ0VXJsVG9EYXRhKHVybCwgbWltZVR5cGUgPSBcImNzdlwiLCBoZWFkZXJzLCBrZXlzLCBkb25lKSB7XG5cdFx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRpZiAoaGVhZGVycykge1xuXHRcdFx0T2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xuXHRcdHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG5cdFx0XHRpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0aWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcblxuXHRcdFx0XHRcdHJlc3BvbnNlICYmIGRvbmUuY2FsbCh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpc1tgY29udmVydCR7Y2FwaXRhbGl6ZShtaW1lVHlwZSl9VG9EYXRhYF0oXG5cdFx0XHRcdFx0XHRcdG1pbWVUeXBlID09PSBcImpzb25cIiA/IEpTT04ucGFyc2UocmVzcG9uc2UpIDogcmVzcG9uc2UsXG5cdFx0XHRcdFx0XHRcdGtleXNcblx0XHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgJHt1cmx9OiBTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlcS5zZW5kKCk7XG5cdH0sXG5cblx0X2NvbnZlcnRDc3ZUc3ZUb0RhdGEocGFyc2VyLCB4c3YpIHtcblx0XHRjb25zdCByb3dzID0gcGFyc2VyLnJvd3MoeHN2KTtcblx0XHRsZXQgZDtcblxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0ZCA9IFt7fV07XG5cblx0XHRcdHJvd3NbMF0uZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRcdGRbMF1baWRdID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkID0gcGFyc2VyLnBhcnNlKHhzdik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGQ7XG5cdH0sXG5cblx0Y29udmVydENzdlRvRGF0YSh4c3YpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udmVydENzdlRzdlRvRGF0YSh7XG5cdFx0XHRyb3dzOiBkM0NzdlBhcnNlUm93cyxcblx0XHRcdHBhcnNlOiBkM0NzdlBhcnNlXG5cdFx0fSwgeHN2KTtcblx0fSxcblxuXHRjb252ZXJ0VHN2VG9EYXRhKHRzdikge1xuXHRcdHJldHVybiB0aGlzLl9jb252ZXJ0Q3N2VHN2VG9EYXRhKHtcblx0XHRcdHJvd3M6IGQzVHN2UGFyc2VSb3dzLFxuXHRcdFx0cGFyc2U6IGQzVHN2UGFyc2Vcblx0XHR9LCB0c3YpO1xuXHR9LFxuXG5cdGNvbnZlcnRKc29uVG9EYXRhKGpzb24sIGtleXNQYXJhbSkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IG5ld1Jvd3MgPSBbXTtcblx0XHRsZXQgdGFyZ2V0S2V5cztcblx0XHRsZXQgZGF0YTtcblxuXHRcdGlmIChpc0FycmF5KGpzb24pKSB7XG5cdFx0XHRjb25zdCBrZXlzID0ga2V5c1BhcmFtIHx8IGNvbmZpZy5kYXRhX2tleXM7XG5cblx0XHRcdGlmIChrZXlzLngpIHtcblx0XHRcdFx0dGFyZ2V0S2V5cyA9IGtleXMudmFsdWUuY29uY2F0KGtleXMueCk7XG5cdFx0XHRcdGNvbmZpZy5kYXRhX3ggPSBrZXlzLng7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0bmV3Um93cy5wdXNoKHRhcmdldEtleXMpO1xuXG5cdFx0XHRqc29uLmZvckVhY2gobyA9PiB7XG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHRhcmdldEtleXMubWFwKGtleSA9PiB7XG5cdFx0XHRcdFx0Ly8gY29udmVydCB1bmRlZmluZWQgdG8gbnVsbCBiZWNhdXNlIHVuZGVmaW5lZCBkYXRhIHdpbGwgYmUgcmVtb3ZlZCBpbiBjb252ZXJ0RGF0YVRvVGFyZ2V0cygpXG5cdFx0XHRcdFx0bGV0IHYgPSB0aGlzLmZpbmRWYWx1ZUluSnNvbihvLCBrZXkpO1xuXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XG5cdFx0XHRcdFx0XHR2ID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdFx0Y29uc3QgdG1wID0ganNvbltrZXldLmNvbmNhdCgpO1xuXG5cdFx0XHRcdHRtcC51bnNoaWZ0KGtleSk7XG5cdFx0XHRcdG5ld1Jvd3MucHVzaCh0bXApO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKG5ld1Jvd3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcblx0XHRpZiAob2JqZWN0W3BhdGhdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBvYmplY3RbcGF0aF07XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29udmVydGVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csIFwiLiQxXCIpOyAvLyBjb252ZXJ0IGluZGV4ZXMgdG8gcHJvcGVydGllcyAocmVwbGFjZSBbXSB3aXRoIC4pXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpOyAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XG5cdFx0bGV0IHRhcmdldCA9IG9iamVjdDtcblxuXHRcdHBhdGhBcnJheS5zb21lKGsgPT4gIShcblx0XHRcdHRhcmdldCA9IHRhcmdldCAmJiBrIGluIHRhcmdldCA/XG5cdFx0XHRcdHRhcmdldFtrXSA6IHVuZGVmaW5lZFxuXHRcdCkpO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHRjb252ZXJ0Um93c1RvRGF0YShyb3dzKSB7XG5cdFx0Y29uc3Qga2V5cyA9IHJvd3NbMF07XG5cdFx0Y29uc3QgbmV3Um93cyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGxlbjEgPSByb3dzLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykge1xuXHRcdFx0Y29uc3QgbmV3Um93ID0ge307XG5cblx0XHRcdGZvciAobGV0IGogPSAwLCBsZW4yID0gcm93c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJvd3NbaV1bal0pKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld1Jvd1trZXlzW2pdXSA9IHJvd3NbaV1bal07XG5cdFx0XHR9XG5cblx0XHRcdG5ld1Jvd3MucHVzaChuZXdSb3cpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdSb3dzO1xuXHR9LFxuXG5cdGNvbnZlcnRDb2x1bW5zVG9EYXRhKGNvbHVtbnMpIHtcblx0XHRjb25zdCBuZXdSb3dzID0gW107XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbGVuMSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgbGVuMTsgaSsrKSB7XG5cdFx0XHRjb25zdCBrZXkgPSBjb2x1bW5zW2ldWzBdO1xuXG5cdFx0XHRmb3IgKGxldCBqID0gMSwgbGVuMiA9IGNvbHVtbnNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdGlmIChpc1VuZGVmaW5lZChuZXdSb3dzW2ogLSAxXSkpIHtcblx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXSA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKGNvbHVtbnNbaV1bal0pKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld1Jvd3NbaiAtIDFdW2tleV0gPSBjb2x1bW5zW2ldW2pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBuZXdSb3dzO1xuXHR9LFxuXG5cdGNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEsIGFwcGVuZFhzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFbMF0gfHwge30pO1xuXHRcdGNvbnN0IGlkcyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc05vdFgsICQkKSA6IFtdO1xuXHRcdGNvbnN0IHhzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzWCwgJCQpIDogW107XG5cdFx0bGV0IHhzRGF0YTtcblxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGNvbnN0IHhLZXkgPSB0aGlzLmdldFhLZXkoaWQpO1xuXG5cdFx0XHRpZiAodGhpcy5pc0N1c3RvbVgoKSB8fCB0aGlzLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdC8vIGlmIGluY2x1ZGVkIGluIGlucHV0IGRhdGFcblx0XHRcdFx0aWYgKHhzLmluZGV4T2YoeEtleSkgPj0gMCkge1xuXHRcdFx0XHRcdHhzRGF0YSA9ICgoYXBwZW5kWHMgJiYgJCQuZGF0YS54c1tpZF0pIHx8IFtdKVxuXHRcdFx0XHRcdFx0LmNvbmNhdChcblx0XHRcdFx0XHRcdFx0ZGF0YS5tYXAoZCA9PiBkW3hLZXldKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoaXNWYWx1ZSlcblx0XHRcdFx0XHRcdFx0XHQubWFwKChyYXdYLCBpKSA9PiAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb25maWcuZGF0YV94KSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IGluY2x1ZGVkIGluIGlucHV0IGRhdGEsIGZpbmQgZnJvbSBwcmVsb2FkZWQgZGF0YSBvZiBvdGhlciBpZCdzIHhcblx0XHRcdFx0XHR4c0RhdGEgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhXG5cdFx0XHRcdFx0eHNEYXRhID0gJCQuZ2V0WFZhbHVlc09mWEtleSh4S2V5LCAkJC5kYXRhLnRhcmdldHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE1FTU86IGlmIG5vIHggaW5jbHVkZWQsIHVzZSBzYW1lIHggb2YgY3VycmVudCB3aWxsIGJlIHVzZWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHhzRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiBpKTtcblx0XHRcdH1cblxuXHRcdFx0eHNEYXRhICYmICh0aGlzLmRhdGEueHNbaWRdID0geHNEYXRhKTtcblx0XHR9KTtcblxuXHRcdC8vIGNoZWNrIHggaXMgZGVmaW5lZFxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcblx0XHRcdGlmICgheHNEYXRhKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgeCBpcyBub3QgZGVmaW5lZCBmb3IgaWQgPSBcIiR7aWR9XCIuYCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxuXHRcdGNvbnN0IHRhcmdldHMgPSBpZHMubWFwKChpZCwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGNvbnZlcnRlZElkID0gY29uZmlnLmRhdGFfaWRDb252ZXJ0ZXIoaWQpO1xuXHRcdFx0Y29uc3QgeEtleSA9ICQkLmdldFhLZXkoaWQpO1xuXHRcdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblx0XHRcdGNvbnN0IGhhc0NhdGVnb3J5ID0gaXNDYXRlZ29yaXplZCAmJiBkYXRhLm1hcCh2ID0+IHYueClcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcblx0XHRcdFx0aWRfb3JnOiBpZCxcblx0XHRcdFx0dmFsdWVzOiBkYXRhLm1hcCgoZCwgaSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xuXHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRbaWRdO1xuXHRcdFx0XHRcdGxldCB4O1xuXG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpID9cblx0XHRcdFx0XHRcdCtkW2lkXSA6IChpc0FycmF5KHZhbHVlKSB8fCAoaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmhpZ2gpID8gdmFsdWUgOiBudWxsKTtcblxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXG5cdFx0XHRcdFx0aWYgKGlzQ2F0ZWdvcml6ZWQgJiYgaW5kZXggPT09IDAgJiYgIWlzVW5kZWZpbmVkKHJhd1gpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWhhc0NhdGVnb3J5ICYmIGluZGV4ID09PSAwICYmIGkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gW107XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZihyYXdYKTtcblxuXHRcdFx0XHRcdFx0aWYgKHggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMucHVzaChyYXdYKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eCA9ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbWFyayBhcyB4ID0gdW5kZWZpbmVkIGlmIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmQgZmlsdGVyIHRvIHJlbW92ZSBhZnRlciBtYXBwZWRcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoZFtpZF0pIHx8ICQkLmRhdGEueHNbaWRdLmxlbmd0aCA8PSBpKSB7XG5cdFx0XHRcdFx0XHR4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB7eCwgdmFsdWUsIGlkOiBjb252ZXJ0ZWRJZH07XG5cdFx0XHRcdH0pLmZpbHRlcih2ID0+IGlzRGVmaW5lZCh2LngpKVxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIGZpbmlzaCB0YXJnZXRzXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0Ly8gc29ydCB2YWx1ZXMgYnkgaXRzIHhcblx0XHRcdGlmIChjb25maWcuZGF0YV94U29ydCkge1xuXHRcdFx0XHR0LnZhbHVlcyA9IHQudmFsdWVzLnNvcnQoKHYxLCB2MikgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHgxID0gdjEueCB8fCB2MS54ID09PSAwID8gdjEueCA6IEluZmluaXR5O1xuXHRcdFx0XHRcdGNvbnN0IHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHgxIC0geDI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmRleGluZyBlYWNoIHZhbHVlXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiAodi5pbmRleCA9IGkpKTtcblxuXHRcdFx0Ly8gdGhpcyBuZWVkcyB0byBiZSBzb3J0ZWQgYmVjYXVzZSBpdHMgaW5kZXggYW5kIHZhbHVlLmluZGV4IGlzIGlkZW50aWNhbFxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXS5zb3J0KCh2MSwgdjIpID0+IHYxIC0gdjIpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdmFsdWVzXG5cdFx0JCQuaGFzTmVnYXRpdmVWYWx1ZSA9ICQkLmhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XG5cdFx0JCQuaGFzUG9zaXRpdmVWYWx1ZSA9ICQkLmhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XG5cblx0XHQvLyBzZXQgdGFyZ2V0IHR5cGVzXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3R5cGUpIHtcblx0XHRcdCQkLnNldFRhcmdldFR5cGUoJCQubWFwVG9JZHModGFyZ2V0cylcblx0XHRcdFx0LmZpbHRlcihpZCA9PiAhKGlkIGluIGNvbmZpZy5kYXRhX3R5cGVzKSksIGNvbmZpZy5kYXRhX3R5cGUpO1xuXHRcdH1cblxuXHRcdC8vIGNhY2hlIGFzIG9yaWdpbmFsIGlkIGtleWVkXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4gJCQuYWRkQ2FjaGUoZC5pZF9vcmcsIGQsIHRydWUpKTtcblxuXHRcdHJldHVybiB0YXJnZXRzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0bG9hZChyYXdUYXJnZXRzLCBhcmdzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGxldCB0YXJnZXRzID0gcmF3VGFyZ2V0cztcblxuXHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHQvLyBmaWx0ZXIgbG9hZGluZyB0YXJnZXRzIGlmIG5lZWRlZFxuXHRcdFx0aWYgKGFyZ3MuZmlsdGVyKSB7XG5cdFx0XHRcdHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihhcmdzLmZpbHRlcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCB0eXBlIGlmIGFyZ3MudHlwZXMgfHwgYXJncy50eXBlIHNwZWNpZmllZFxuXHRcdFx0aWYgKGFyZ3MudHlwZSB8fCBhcmdzLnR5cGVzKSB7XG5cdFx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gKGFyZ3MudHlwZXMgJiYgYXJncy50eXBlc1t0LmlkXSkgfHwgYXJncy50eXBlO1xuXG5cdFx0XHRcdFx0JCQuc2V0VGFyZ2V0VHlwZSh0LmlkLCB0eXBlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZS9BZGQgZGF0YVxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XG5cdFx0XHRcdFx0XHRkLnZhbHVlcyA9IHRhcmdldHNbaV0udmFsdWVzO1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcblx0XHR9XG5cblx0XHQvLyBTZXQgdGFyZ2V0c1xuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdC8vIFJlZHJhdyB3aXRoIG5ldyB0YXJnZXRzXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXG5cdFx0fSk7XG5cblx0XHRhcmdzLmRvbmUgJiYgYXJncy5kb25lKCk7XG5cdH0sXG5cblx0bG9hZEZyb21BcmdzKGFyZ3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQvLyBwcmV2ZW50IGxvYWQgd2hlbiBjaGFydCBpcyBhbHJlYWR5IGRlc3Ryb3llZFxuXHRcdGlmICghJCQuY29uZmlnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgaW50ZXJuYWxseSBjYWNoZWQgZGF0YVxuXHRcdCQkLnJlc2V0Q2FjaGUoKTtcblxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XG5cblx0XHQkJC5sb2FkKGRhdGEgPyAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhKSA6IG51bGwsIGFyZ3MpO1xuXHR9LFxuXG5cdHVubG9hZChyYXdUYXJnZXRJZHMsIGN1c3RvbURvbmVDYikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgZG9uZSA9IGN1c3RvbURvbmVDYjtcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xuXG5cdFx0Ly8gcmVzZXQgaW50ZXJuYWxseSBjYWNoZWQgZGF0YVxuXHRcdCQkLnJlc2V0Q2FjaGUoKTtcblxuXHRcdGlmICghZG9uZSkge1xuXHRcdFx0ZG9uZSA9ICgpID0+IHt9O1xuXHRcdH1cblxuXHRcdC8vIGZpbHRlciBleGlzdGluZyB0YXJnZXRcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XG5cblx0XHQvLyBJZiBubyB0YXJnZXQsIGNhbGwgZG9uZSBhbmQgcmV0dXJuXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0ZG9uZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwodGFyZ2V0SWRzLm1hcChpZCA9PiAkJC5zZWxlY3RvclRhcmdldChpZCkpKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKVxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCBkb25lKTtcblxuXHRcdHRhcmdldElkcy5mb3JFYWNoKGlkID0+IHtcblx0XHRcdC8vIFJlc2V0IGZhZGVpbiBmb3IgZnV0dXJlIGxvYWRcblx0XHRcdCQkLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XG5cdFx0XHQvLyBSZW1vdmUgdGFyZ2V0J3MgZWxlbWVudHNcblx0XHRcdGlmICgkJC5sZWdlbmQpIHtcblx0XHRcdFx0JCQubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX0keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSB0YXJnZXRcblx0XHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5maWx0ZXIodCA9PiB0LmlkICE9PSBpZCk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENhdGVnb3J5IE5hbWVcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IGdhdGVnb3J5IE5hbWVcblx0ICovXG5cdGNhdGVnb3J5TmFtZShpKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRyZXR1cm4gaSA8IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGggPyBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gOiBpO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRtb3VzZSBhcyBkM01vdXNlLFxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdGV2ZW50IGFzIGQzRXZlbnRcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2VtdWxhdGVFdmVudCwgZXh0ZW5kLCBpc0Jvb2xlYW4sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxuXHQgKiBBZGQgYSBjb250YWluZXIgZm9yIHRoZSB6b25lIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0RXZlbnRSZWN0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0cylcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhd3MgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlZHJhd0V2ZW50UmVjdCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcblx0XHRsZXQgZXZlbnRSZWN0VXBkYXRlO1xuXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIHpvb21FbmFibGVkICYmIHpvb21FbmFibGVkLnR5cGUgIT09IFwiZHJhZ1wiID8gKFxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJucy1yZXNpemVcIiA6IFwiZXctcmVzaXplXCJcblx0XHRcdCkgOiBudWxsKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c011bHRpcGxlLCBpc011bHRpcGxlWClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XG5cblx0XHQvLyBjbGVhciBvbGQgcmVjdHNcblx0XHRldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnJlbW92ZSgpO1xuXG5cdFx0Ly8gb3BlbiBhcyBwdWJsaWMgY29uc3RpYWJsZVxuXHRcdCQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XG5cblx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmV2ZW50UmVjdC5kYXRhKFswXSk7XG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdC8vIGVudGVyOiBvbmx5IG9uZSByZWN0IHdpbGwgYmUgYWRkZWRcblx0XHRcdC8vIGV4aXQ6IG5vdCBuZWVkZWQgYmVjYXVzZSBhbHdheXMgb25seSBvbmUgcmVjdCBleGlzdHNcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTZXQgZGF0YSBhbmQgdXBkYXRlICQkLmV2ZW50UmVjdFxuXHRcdFx0Y29uc3QgbWF4RGF0YUNvdW50VGFyZ2V0ID0gJCQuZ2V0TWF4RGF0YUNvdW50VGFyZ2V0KCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0obWF4RGF0YUNvdW50VGFyZ2V0ID8gbWF4RGF0YUNvdW50VGFyZ2V0LnZhbHVlcyA6IFtdKTtcblx0XHRcdCQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5ldmVudFJlY3QuZGF0YShkID0+IGQpO1xuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRldmVudFJlY3RVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xuXG5cdFx0aWYgKCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICEkJC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHQkJC5iaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCk7XG5cdFx0fVxuXHR9LFxuXG5cdGJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IGdldEV2ZW50UmVjdCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0cmV0dXJuIGQzU2VsZWN0KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xuXHRcdH07XG5cblx0XHRjb25zdCBnZXRJbmRleCA9IGV2ZW50UmVjdCA9PiB7XG5cdFx0XHRsZXQgaW5kZXggPSBldmVudFJlY3QgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKSAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xuXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdGluZGV4ID0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xuXHRcdFx0aWYgKGlzTXVsdGlwbGVYKSB7XG5cdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZXZlbnRSZWN0KTtcblxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcblxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDpcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHQvLyBhY2NvcmRpbmcgJ2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaC5wcmV2ZW50RGVmYXVsdCcgb3B0aW9uXG5cdFx0Y29uc3QgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0O1xuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xuXHRcdGNvbnN0IHByZXZlbnRUaHJlc2hvbGQgPSAoIWlzTmFOKHByZXZlbnREZWZhdWx0KSAmJiBwcmV2ZW50RGVmYXVsdCkgfHwgbnVsbDtcblx0XHRsZXQgc3RhcnRQeDtcblxuXHRcdGNvbnN0IHByZXZlbnRFdmVudCA9IGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0Y29uc3QgY3VycmVudFhZID0gdG91Y2hbYGNsaWVudCR7Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwiWVwiIDogXCJYXCJ9YF07XG5cblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZXZlbnRUeXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZlbnRUaHJlc2hvbGQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRzdGFydFB4ID0gY3VycmVudFhZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQgfHwgc3RhcnRQeCA9PT0gdHJ1ZSB8fCAoXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHQvLyBvbmNlIHByZXZlbnRlZCwga2VlcCBwcmV2ZW50ZWQgZHVyaW5nIHdob2xlICd0b3VjaG1vdmUnIGNvbnRleHRcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXG5cdFx0JCQuc3ZnXG5cdFx0XHQub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdCB0b3VjaG1vdmUuZXZlbnRSZWN0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmV2ZW50RXZlbnQoZDNFdmVudCk7XG5cdFx0XHRcdFx0c2VsZWN0UmVjdCh0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQub24oXCJ0b3VjaGVuZC5ldmVudFJlY3RcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCAkJC5jYW5jZWxDbGljaykge1xuXHRcdFx0XHRcdFx0JCQuY2FuY2VsQ2xpY2sgJiYgKCQkLmNhbmNlbENsaWNrID0gZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGxvY2F0aW9uIGFuZCBzaXplIG9mIHRoZSBldmVudFJlY3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKi9cblx0dXBkYXRlRXZlbnRSZWN0KGV2ZW50UmVjdFVwZGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgeFNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cdFx0Y29uc3QgZXZlbnRSZWN0RGF0YSA9IGV2ZW50UmVjdFVwZGF0ZSB8fCAkJC5ldmVudFJlY3QuZGF0YSgpOy8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCB4O1xuXHRcdGxldCB5O1xuXHRcdGxldCB3O1xuXHRcdGxldCBoO1xuXG5cdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdC8vIFRPRE86IHJvdGF0ZWQgbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdHggPSAwO1xuXHRcdFx0eSA9IDA7XG5cdFx0XHR3ID0gJCQud2lkdGg7XG5cdFx0XHRoID0gJCQuaGVpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcmVjdFc7XG5cdFx0XHRsZXQgcmVjdFg7XG5cblx0XHRcdGlmICgkJC5pc0NhdGVnb3JpemVkKCkpIHtcblx0XHRcdFx0cmVjdFcgPSAkJC5nZXRFdmVudFJlY3RXaWR0aCgpO1xuXHRcdFx0XHRyZWN0WCA9IGQgPT4geFNjYWxlKGQueCkgLSAocmVjdFcgLyAyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBpbmRleCBmb3IgeCB0aGF0IGlzIHVzZWQgYnkgcHJldlggYW5kIG5leHRYXG5cdFx0XHRcdCQkLnVwZGF0ZVhzKCk7XG5cblx0XHRcdFx0Y29uc3QgZ2V0UHJldk5leHRYID0gZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcblx0XHRcdFx0XHRcdG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmVjdFcgPSBkID0+IHtcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IG1ha2UgdGhlIGV2ZW50UmVjdCBmdWxsIHdpZHRoIChvciBoZWlnaHQpXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpc1JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHgubmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0eC5uZXh0ID0geFNjYWxlLmRvbWFpbigpWzFdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCgwLCAoeFNjYWxlKHgubmV4dCkgLSB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZWN0WCA9IGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XG5cdFx0XHRcdFx0Y29uc3QgdGhpc1ggPSAkJC5kYXRhLnhzW2QuaWRdW2QuaW5kZXhdO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IHBvc2l0aW9uIHRoZSBldmVudFJlY3QgYXQgMFxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuICh4U2NhbGUodGhpc1gpICsgeFNjYWxlKHgucHJldikpIC8gMjtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiByZWN0WDtcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyByZWN0WCA6IDA7XG5cdFx0XHR3ID0gaXNSb3RhdGVkID8gJCQud2lkdGggOiByZWN0Vztcblx0XHRcdGggPSBpc1JvdGF0ZWQgPyByZWN0VyA6ICQkLmhlaWdodDtcblx0XHR9XG5cblx0XHRldmVudFJlY3REYXRhLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIHgpXG5cdFx0XHQuYXR0cihcInlcIiwgeSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdylcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xuXHR9LFxuXG5cdHNlbGVjdFJlY3RGb3JTaW5nbGUoY29udGV4dCwgZXZlbnRSZWN0LCBpbmRleCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25FbmFibGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ7XG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25Hcm91cGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ7XG5cdFx0Y29uc3QgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XG5cdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gJCQuZ2V0QWxsVmFsdWVzT25JbmRleChpbmRleCk7XG5cblx0XHRpZiAoaXNUb29sdGlwR3JvdXBlZCkge1xuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KTtcblx0XHRcdCQkLnNob3dYR3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XG5cblx0XHRcdGlmICghaXNTZWxlY3Rpb25FbmFibGVkIHx8IGlzU2VsZWN0aW9uR3JvdXBlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCkge1xuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XG5cdFx0XHRcdFx0JCQuaGlkZVhHcmlkRm9jdXMoKTtcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xuXG5cdFx0XHRcdFx0IWlzU2VsZWN0aW9uR3JvdXBlZCAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhbGwoc2VsZWN0ZWQgPT4ge1xuXHRcdFx0XHRjb25zdCBkID0gc2VsZWN0ZWQuZGF0YSgpO1xuXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQgJiYgKGlzU2VsZWN0aW9uR3JvdXBlZCB8fCBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKSkge1xuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChkLCBjb250ZXh0KTtcblx0XHRcdFx0XHQkJC5zaG93WEdyaWRGb2N1cyhkKTtcblxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdFx0XHRcdHNlbGVjdGVkLmVhY2goZCA9PiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCwgZC5pZCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleCwgaWQsIHJlc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCAmJlxuXHRcdFx0JCQuZXhwYW5kQ2lyY2xlcyhpbmRleCwgaWQsIHJlc2V0KTtcblxuXHRcdCQkLmV4cGFuZEJhcnMoaW5kZXgsIGlkLCByZXNldCk7XG5cdH0sXG5cblx0c2VsZWN0UmVjdEZvck11bHRpcGxlWHMoY29udGV4dCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcblxuXHRcdC8vIGRvIG5vdGhpbmcgd2hlbiBkcmFnZ2luZ1xuXHRcdGlmICgkJC5kcmFnZ2luZyB8fCAkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKGNvbnRleHQpO1xuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcblxuXHRcdGlmICgkJC5tb3VzZW92ZXIgJiYgKCFjbG9zZXN0IHx8IGNsb3Nlc3QuaWQgIT09ICQkLm1vdXNlb3Zlci5pZCkpIHtcblx0XHRcdGNvbmZpZy5kYXRhX29ub3V0LmNhbGwoJCQuYXBpLCAkJC5tb3VzZW92ZXIpO1xuXHRcdFx0JCQubW91c2VvdmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICghY2xvc2VzdCkge1xuXHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2FtZVhEYXRhID0gKFxuXHRcdFx0JCQuaXNCdWJibGVUeXBlKGNsb3Nlc3QpIHx8ICQkLmlzU2NhdHRlclR5cGUoY2xvc2VzdCkgfHwgIWNvbmZpZy50b29sdGlwX2dyb3VwZWRcblx0XHQpID8gW2Nsb3Nlc3RdIDogJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XG5cblx0XHQvLyBzaG93IHRvb2x0aXAgd2hlbiBjdXJzb3IgaXMgY2xvc2UgdG8gc29tZSBwb2ludFxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZCA9PiAkJC5hZGROYW1lKGQpKTtcblxuXHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XG5cblx0XHQvLyBleHBhbmQgcG9pbnRzXG5cdFx0JCQuZXhwYW5kQ2lyY2xlc0JhcnMoY2xvc2VzdC5pbmRleCwgY2xvc2VzdC5pZCwgdHJ1ZSk7XG5cblx0XHQvLyBTaG93IHhncmlkIGZvY3VzIGxpbmVcblx0XHQkJC5zaG93WEdyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xuXG5cdFx0Ly8gU2hvdyBjdXJzb3IgYXMgcG9pbnRlciBpZiBwb2ludCBpcyBjbG9zZSB0byBtb3VzZSBwb3NpdGlvblxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcblx0XHRcdCQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XG5cblx0XHRcdGlmICghJCQubW91c2VvdmVyKSB7XG5cdFx0XHRcdGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCk7XG5cdFx0XHRcdCQkLm1vdXNlb3ZlciA9IGNsb3Nlc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbnNlbGVjdCBFdmVudFJlY3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1bnNlbGVjdFJlY3QoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xuXHRcdCQkLmhpZGVYR3JpZEZvY3VzKCk7XG5cdFx0JCQuaGlkZVRvb2x0aXAoKTtcblx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKGZhbHNlKTtcblx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcblx0XHQkJC51bmV4cGFuZEJhcnMoKTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBvcHRpb25zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0T3Zlck91dChpc092ZXIsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XG5cblx0XHQvLyBDYWxsIGV2ZW50IGhhbmRsZXJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XG5cblx0XHRcdGNvbmZpZy5jb2xvcl9vbm92ZXIgJiYgJCQuc2V0T3ZlckNvbG9yKGlzT3ZlciwgZCwgaXNBcmMpO1xuXG5cdFx0XHRpZiAoaXNBcmMpIHtcblx0XHRcdFx0Y2FsbGJhY2soZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc092ZXIgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoZCwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApLmVhY2goY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2FsbCBkYXRhLm9ub3Zlci9vdXQgY2FsbGJhY2sgZm9yIHRvdWNoIGV2ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxsT3Zlck91dEZvclRvdWNoKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2FsbGVlID0gJCQuY2FsbE92ZXJPdXRGb3JUb3VjaDtcblx0XHRjb25zdCBsYXN0ID0gY2FsbGVlLmxhc3Q7XG5cblx0XHRpZiAoaXNPYmplY3QoZCkgJiYgbGFzdCA/IGQuaWQgIT09IGxhc3QuaWQgOiAoZCAhPT0gbGFzdCkpIHtcblx0XHRcdChsYXN0IHx8IGlzTnVtYmVyKGxhc3QpKSAmJiAkJC5zZXRPdmVyT3V0KGZhbHNlLCBsYXN0KTtcblx0XHRcdChkIHx8IGlzTnVtYmVyKGQpKSAmJiAkJC5zZXRPdmVyT3V0KHRydWUsIGQpO1xuXG5cdFx0XHRjYWxsZWUubGFzdCA9IGQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZHJhZ2dhYmxlIHNlbGVjdGlvbiBmdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldERyYWdnYWJsZVNlbGVjdGlvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUgJiYgJCQuZHJhZyA/XG5cdFx0XHRkM0RyYWcoKVxuXHRcdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkgeyAkJC5kcmFnKGQzTW91c2UodGhpcykpOyB9KVxuXHRcdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHsgJCQuZHJhZ3N0YXJ0KGQzTW91c2UodGhpcykpOyB9KVxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4geyAkJC5kcmFnZW5kKCk7IH0pIDogKCkgPT4ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBldmVudFJlY3QgZm9yIGVhY2ggZGF0YSBvbiB0aGUgeC1heGlzLlxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxuXHQgKi9cblx0Z2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWChldmVudFJlY3RFbnRlcikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gXCJwb2ludGVyXCIgOiBudWxsKVxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGhpcykoZCwgJCQpO1xuXHRcdFx0fSlcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcblxuXHRcdGlmICgkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xuXHRcdFx0cmVjdFxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXG5cdFx0XHRcdFx0aWYgKCQkLmRyYWdnaW5nIHx8ICQkLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dCh0cnVlLCBkLmluZGV4KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcblx0XHRcdFx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgaW5kZXggPSBkLmluZGV4O1xuXHRcdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH0tJHtpbmRleH1gKTtcblxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmXG5cdFx0XHRcdFx0XHQkJC5jb25maWcubGluZV9zdGVwX3R5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXG5cdFx0XHRcdFx0XHRkM01vdXNlKHRoaXMpWzBdIDwgJCQueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aW5kZXggLT0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCA9PT0gLTEgP1xuXHRcdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOiAkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHRoaXMsIGV2ZW50UmVjdCwgaW5kZXgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcblx0XHRcdFx0XHRpZiAoISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBkLmluZGV4KTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0Y2xpY2tIYW5kbGVyRm9yU2luZ2xlWChkLCBjdHgpIHtcblx0XHRjb25zdCAkJCA9IGN0eDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCAkJC5jYW5jZWxDbGljaykge1xuXHRcdFx0JCQuY2FuY2VsQ2xpY2sgJiYgKCQkLmNhbmNlbENsaWNrID0gZmFsc2UpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xuXG5cdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkMikge1xuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkMikpIHtcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBkMiwgaW5kZXgpO1xuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGQyLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBldmVudFJlY3QsXG5cdCAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXG5cdCAqL1xuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgcmVjdCA9IGV2ZW50UmVjdEVudGVyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIDApXG5cdFx0XHQuYXR0cihcInlcIiwgMClcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5oZWlnaHQpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdClcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xuXHRcdFx0fSlcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcblxuXHRcdGlmICgkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xuXHRcdFx0cmVjdFxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXIgbW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKHRoaXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gY2hhcnQgaXMgZGVzdHJveWVkXG5cdFx0XHRcdFx0aWYgKCEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdGNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMoY3R4KSB7XG5cdFx0Y29uc3QgJCQgPSBjdHg7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZSh0aGlzKTtcblx0XHRjb25zdCBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XG5cblx0XHRpZiAoIWNsb3Nlc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCl9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7Y2xvc2VzdC5pbmRleH1gKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBjbG9zZXN0KSkge1xuXHRcdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgY2xvc2VzdCwgY2xvc2VzdC5pbmRleCk7XG5cdFx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmNhbGwoJCQuYXBpLCBjbG9zZXN0LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBtb3VzZSBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZXZlbnQgdHlwZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgZXZlbnRSZWN0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZSB2YWx1ZVxuXHQgKi9cblx0ZGlzcGF0Y2hFdmVudCh0eXBlLCBpbmRleCwgbW91c2UpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcblx0XHRjb25zdCBldmVudFJlY3QgPSAkJC5tYWluLnNlbGVjdChzZWxlY3Rvcikubm9kZSgpO1xuXHRcdGNvbnN0IHt3aWR0aCwgbGVmdCwgdG9wfSA9IGV2ZW50UmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoaXNNdWx0aXBsZVggPyAwIDogKHdpZHRoIC8gMikpO1xuXHRcdGNvbnN0IHkgPSB0b3AgKyAobW91c2UgPyBtb3VzZVsxXSA6IDApO1xuXHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdHNjcmVlblg6IHgsXG5cdFx0XHRzY3JlZW5ZOiB5LFxuXHRcdFx0Y2xpZW50WDogeCxcblx0XHRcdGNsaWVudFk6IHlcblx0XHR9O1xuXG5cdFx0ZW11bGF0ZUV2ZW50Wy9eKG1vdXNlfGNsaWNrKS8udGVzdCh0eXBlKSA/IFwibW91c2VcIiA6IFwidG91Y2hcIl0oZXZlbnRSZWN0LCB0eXBlLCBwYXJhbXMpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7aXNWYWx1ZSwgY2VpbDEwLCBleHRlbmQsIGNhcGl0YWxpemV9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldENvbnRhaW5lclNpemUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY3VycmVudFdpZHRoID0gJCQuZ2V0Q3VycmVudFdpZHRoKCk7XG5cdFx0JCQuY3VycmVudEhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcblx0fSxcblxuXHRnZXRDdXJyZW50V2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5zaXplX3dpZHRoIHx8ICQkLmdldFBhcmVudFdpZHRoKCk7XG5cdH0sXG5cblx0Z2V0Q3VycmVudEhlaWdodCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XG5cblx0XHRyZXR1cm4gaCA+IDAgPyBoIDogMzIwIC8gKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBBeGlzIHNpemUgYWNjb3JkaW5nIGl0cyBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZCB2YWx1ZSAtIHgsIHkgb3IgeTJcblx0ICogQHJldHVybiB7bnVtYmVyfSBzaXplIEF4aXMgc2l6ZSB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0QXhpc1NpemUoaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRyZXR1cm4gKGlzUm90YXRlZCAmJiBpZCA9PT0gXCJ4XCIpIHx8ICghaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpKSA/XG5cdFx0XHQkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChpZCwgdHJ1ZSkgOlxuXHRcdFx0JCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nVG9wKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoO1xuXG5cdFx0bGV0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3RvcCkgP1xuXHRcdFx0Y29uZmlnLnBhZGRpbmdfdG9wIDogMDtcblxuXHRcdGlmICgkJC50aXRsZSAmJiAkJC50aXRsZS5ub2RlKCkpIHtcblx0XHRcdHBhZGRpbmcgKz0gJCQuZ2V0VGl0bGVQYWRkaW5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4ZXNMZW4gJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICogYXhlc0xlbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFkZGluZztcblx0fSxcblxuXHRnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XG5cdFx0Y29uc3QgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfYm90dG9tKSA/XG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xuXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXG5cdFx0KTtcblx0fSxcblxuXHRnZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBheGlzSWQgPSBpc1JvdGF0ZWQgPyBcInhcIiA6IFwieVwiO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoYXhpc0lkLCB3aXRob3V0UmVjb21wdXRlKTtcblx0XHRsZXQgcGFkZGluZztcblxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2xlZnQpKSB7XG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfbGVmdDtcblx0XHR9IGVsc2UgaWYgKGlzUm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyA9ICFjb25maWcuYXhpc194X3Nob3cgP1xuXHRcdFx0XHQxIDogTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKTtcblx0XHR9IGVsc2UgaWYgKCFjb25maWcuYXhpc195X3Nob3cgfHwgY29uZmlnLmF4aXNfeV9pbm5lcikgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxuXHRcdFx0cGFkZGluZyA9ICQkLmF4aXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDMwIDogMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBkZWZhdWx0UGFkZGluZyA9IDEwO1xuXHRcdGNvbnN0IGxlZ2VuZFdpZHRoT25SaWdodCA9ICQkLmlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpICsgMjAgOiAwO1xuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcblx0XHRjb25zdCBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpO1xuXHRcdGxldCBwYWRkaW5nO1xuXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfcmlnaHQpKSB7XG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfcmlnaHQgKyAxOyAvLyAxIGlzIG5lZWRlZCBub3QgdG8gaGlkZSB0aWNrIGxpbmVcblx0XHR9IGVsc2UgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcblx0XHRcdHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZyArIGxlZ2VuZFdpZHRoT25SaWdodDtcblx0XHR9IGVsc2UgaWYgKCFjb25maWcuYXhpc195Ml9zaG93IHx8IGNvbmZpZy5heGlzX3kyX2lubmVyKSB7IC8vICYmICFjb25maWcuYXhpc19yb3RhdGVkXG5cdFx0XHRwYWRkaW5nID0gMiArIGxlZ2VuZFdpZHRoT25SaWdodCArXG5cdFx0XHRcdCgkJC5heGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKS5pc091dGVyID8gMjAgOiAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhcmVudCByZWN0IGVsZW1lbnQncyBzaXplXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgcHJvcGVydHkvYXR0cmlidXRlIG5hbWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFBhcmVudFJlY3RWYWx1ZShrZXkpIHtcblx0XHRjb25zdCBvZmZzZXROYW1lID0gYG9mZnNldCR7Y2FwaXRhbGl6ZShrZXkpfWA7XG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuc2VsZWN0Q2hhcnQubm9kZSgpO1xuXHRcdGxldCB2O1xuXG5cdFx0d2hpbGUgKCF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHYgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClba2V5XTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKG9mZnNldE5hbWUgaW4gcGFyZW50KSB7XG5cdFx0XHRcdFx0Ly8gSW4gSUUgaW4gY2VydGFpbiBjYXNlcyBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdFx0XHQvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxuXHRcdFx0XHRcdHYgPSBwYXJlbnRbb2Zmc2V0TmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKGtleSA9PT0gXCJ3aWR0aFwiKSB7XG5cdFx0XHQvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHVzZSBib2R5J3Mgb2Zmc2V0V2lkdGggaW5zdGVhZC5cblx0XHRcdGNvbnN0IGJvZHlXaWR0aCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG5cblx0XHRcdHYgPiBib2R5V2lkdGggJiYgKHYgPSBib2R5V2lkdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2O1xuXHR9LFxuXG5cdGdldFBhcmVudFdpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBhcmVudFJlY3RWYWx1ZShcIndpZHRoXCIpO1xuXHR9LFxuXG5cdGdldFBhcmVudEhlaWdodCgpIHtcblx0XHRjb25zdCBoID0gdGhpcy5zZWxlY3RDaGFydC5zdHlsZShcImhlaWdodFwiKTtcblxuXHRcdHJldHVybiBoLmluZGV4T2YoXCJweFwiKSA+IDAgPyBwYXJzZUludChoLCAxMCkgOiAwO1xuXHR9LFxuXG5cdGdldFN2Z0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaGFzTGVmdEF4aXNSZWN0ID0gY29uZmlnLmF4aXNfcm90YXRlZCB8fCAoIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIpO1xuXHRcdGNvbnN0IGxlZnRBeGlzQ2xhc3MgPSBjb25maWcuYXhpc19yb3RhdGVkID8gQ0xBU1MuYXhpc1ggOiBDTEFTUy5heGlzWTtcblx0XHRjb25zdCBsZWZ0QXhpcyA9ICQkLm1haW4uc2VsZWN0KGAuJHtsZWZ0QXhpc0NsYXNzfWApLm5vZGUoKTtcblx0XHRjb25zdCBzdmdSZWN0ID0gbGVmdEF4aXMgJiYgaGFzTGVmdEF4aXNSZWN0ID8gbGVmdEF4aXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7cmlnaHQ6IDB9O1xuXHRcdGNvbnN0IGNoYXJ0UmVjdCA9ICQkLnNlbGVjdENoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XG5cdFx0Y29uc3Qgc3ZnTGVmdCA9IHN2Z1JlY3QucmlnaHQgLSBjaGFydFJlY3QubGVmdCAtXG5cdFx0XHQoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XG5cblx0XHRyZXR1cm4gc3ZnTGVmdCA+IDAgPyBzdmdMZWZ0IDogMDtcblx0fSxcblxuXHRnZXRBeGlzV2lkdGhCeUF4aXNJZChpZCwgd2l0aG91dFJlY29tcHV0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBwb3NpdGlvbiA9ICQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpO1xuXG5cdFx0cmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArXG5cdFx0XHQocG9zaXRpb24uaXNJbm5lciA/IDIwIDogNDApO1xuXHR9LFxuXG5cdGdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCBoID0gMzA7XG5cblx0XHRpZiAoaWQgPT09IFwieFwiICYmICFjb25maWcuYXhpc194X3Nob3cpIHtcblx0XHRcdHJldHVybiA4O1xuXHRcdH1cblxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgY29uZmlnLmF4aXNfeF9oZWlnaHQpIHtcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2hlaWdodDtcblx0XHR9XG5cblx0XHRpZiAoaWQgPT09IFwieVwiICYmICFjb25maWcuYXhpc195X3Nob3cpIHtcblx0XHRcdHJldHVybiBjb25maWcubGVnZW5kX3Nob3cgJiZcblx0XHRcdFx0ISQkLmlzTGVnZW5kUmlnaHQgJiZcblx0XHRcdFx0ISQkLmlzTGVnZW5kSW5zZXQgPyAxMCA6IDE7XG5cdFx0fVxuXG5cdFx0aWYgKGlkID09PSBcInkyXCIgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHtcblx0XHRcdHJldHVybiAkJC5yb3RhdGVkX3BhZGRpbmdfdG9wO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSB4L3kgYXhpcyBoZWlnaHQgd2hlbiB0aWNrIHJvdGF0ZWRcblx0XHRpZiAoKGlkID09PSBcInhcIiAmJiAhaXNSb3RhdGVkICYmIGNvbmZpZy5heGlzX3hfdGlja19yb3RhdGUpIHx8XG5cdFx0XHQoaWQgPT09IFwieVwiICYmIGlzUm90YXRlZCAmJiBjb25maWcuYXhpc195X3RpY2tfcm90YXRlKSkge1xuXHRcdFx0aCA9IDMwICtcblx0XHRcdFx0JCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoaWQpICpcblx0XHRcdFx0TWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3JvdGF0ZWBdKSAvIDE4MCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGggK1xuXHRcdFx0KCQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpLmlzSW5uZXIgPyAwIDogMTApICtcblx0XHRcdChpZCA9PT0gXCJ5MlwiICYmICFpc1JvdGF0ZWQgPyAtMTAgOiAwKTtcblx0fSxcblxuXHRnZXRFdmVudFJlY3RXaWR0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy54QXhpcy50aWNrSW50ZXJ2YWwoKSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0Y3VydmVTdGVwQmVmb3JlIGFzIGQzQ3VydmVTdGVwQmVmb3JlLFxuXHRjdXJ2ZVN0ZXBBZnRlciBhcyBkM0N1cnZlU3RlcEFmdGVyLFxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcblx0Y3VydmVCYXNpc09wZW4gYXMgZDNDdXJ2ZUJhc2lzT3Blbixcblx0Y3VydmVCYXNpcyBhcyBkM0N1cnZlQmFzaXMsXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXG5cdGN1cnZlQ2FyZGluYWxDbG9zZWQgYXMgZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxuXHRjdXJ2ZUNhcmRpbmFsT3BlbiBhcyBkM0N1cnZlQ2FyZGluYWxPcGVuLFxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcblx0Y3VydmVDYXRtdWxsUm9tQ2xvc2VkIGFzIGQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxuXHRjdXJ2ZUNhdG11bGxSb21PcGVuIGFzIGQzQ3VydmVDYXRtdWxsUm9tT3Blbixcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxuXHRjdXJ2ZUxpbmVhckNsb3NlZCBhcyBkM0N1cnZlTGluZWFyQ2xvc2VkLFxuXHRjdXJ2ZUxpbmVhciBhcyBkM0N1cnZlTGluZWFyLFxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxuXHRjdXJ2ZU1vbm90b25lWSBhcyBkM0N1cnZlTW9ub3RvbmVZLFxuXHRjdXJ2ZU5hdHVyYWwgYXMgZDNDdXJ2ZU5hdHVyYWwsXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxufSBmcm9tIFwiZDMtc2hhcGVcIjtcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0Z2V0U2hhcGVJbmRpY2VzKHR5cGVGaWx0ZXIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcblx0XHRsZXQgaSA9IDA7XG5cblx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0c1xuXHRcdFx0LmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpXG5cdFx0XHQuZm9yRWFjaChkID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGdyb3VwczsgKGdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwc1tqXSk7IGorKykge1xuXHRcdFx0XHRcdGlmIChncm91cHMuaW5kZXhPZihkLmlkKSA8IDApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSAwLCByb3c7IChyb3cgPSBncm91cHNba10pOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmIChyb3cgaW4gaW5kaWNlcykge1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzW2QuaWRdID0gaW5kaWNlc1tyb3ddO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoaW5kaWNlc1tkLmlkXSkpIHtcblx0XHRcdFx0XHRpbmRpY2VzW2QuaWRdID0gaSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGluZGljZXMuX19tYXhfXyA9IGkgLSAxO1xuXG5cdFx0cmV0dXJuIGluZGljZXM7XG5cdH0sXG5cblx0Z2V0U2hhcGVYKG9mZnNldCwgdGFyZ2V0c051bSwgaW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLnN1YlggOiAoJCQuem9vbVNjYWxlIHx8ICQkLngpO1xuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSAkJC5jb25maWcuYmFyX3BhZGRpbmc7XG5cdFx0Y29uc3Qgc3VtID0gKHAsIGMpID0+IHAgKyBjO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcblxuXHRcdHJldHVybiBkID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmRpY2VzID8gaW5kaWNlc1tkLmlkXSA6IDA7XG5cdFx0XHRsZXQgeCA9IDA7XG5cblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XG5cdFx0XHRcdGNvbnN0IHhQb3MgPSBzY2FsZShkLngpO1xuXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXG5cdFx0XHRcdFx0XHRvZmZzZXQudG90YWwuc2xpY2UoMCwgaW5kZXggKyAxKS5yZWR1Y2Uoc3VtKSAtXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHhQb3MgLSAoaXNOdW1iZXIob2Zmc2V0KSA/IG9mZnNldCA6IG9mZnNldC53aWR0aCkgKiAodGFyZ2V0c051bSAvIDIgLSBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0c051bSA9PT0gMikge1xuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRTaGFwZVkoaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xuXG5cdFx0cmV0dXJuIGQgPT4gKGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpKShcblx0XHRcdGlzU3RhY2tOb3JtYWxpemVkID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCBkLCB0cnVlKSA6IGQudmFsdWVcblx0XHQpO1xuXHR9LFxuXG5cdGdldFNoYXBlT2Zmc2V0KHR5cGVGaWx0ZXIsIGluZGljZXMsIGlzU3ViKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkpO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9IHRhcmdldHMubWFwKHQgPT4gdC5pZCk7XG5cblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xuXHRcdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZShkLmlkKSA6ICQkLmdldFlTY2FsZShkLmlkKTtcblx0XHRcdGNvbnN0IHkwID0gc2NhbGUoMCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0geTA7XG5cdFx0XHRsZXQgaSA9IGlkeDtcblxuXHRcdFx0dGFyZ2V0c1xuXHRcdFx0XHQuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0XHRjb25zdCByb3dWYWx1ZXMgPSAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuY29udmVydFZhbHVlc1RvU3RlcCh0LnZhbHVlcykgOiB0LnZhbHVlcztcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSByb3dWYWx1ZXMubWFwKHYgPT4gKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIHYsIHRydWUpIDogdi52YWx1ZSkpO1xuXG5cdFx0XHRcdFx0aWYgKHQuaWQgPT09IGQuaWQgfHwgaW5kaWNlc1t0LmlkXSAhPT0gaW5kaWNlc1tkLmlkXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0YXJnZXRJZHMuaW5kZXhPZih0LmlkKSA8IHRhcmdldElkcy5pbmRleE9mKGQuaWQpKSB7XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgeCB2YWx1ZXMgbGluZSB1cFxuXHRcdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJvd1ZhbHVlc1tpXSkgfHwgK3Jvd1ZhbHVlc1tpXS54ICE9PSArZC54KSB7IC8vIFwiK1wiIGZvciB0aW1lc2VyaWVzXG5cdFx0XHRcdFx0XHRcdC8vIGlmIG5vdCwgdHJ5IHRvIGZpbmQgdGhlIHZhbHVlIHRoYXQgZG9lcyBsaW5lIHVwXG5cdFx0XHRcdFx0XHRcdGkgPSAtMTtcblxuXHRcdFx0XHRcdFx0XHRyb3dWYWx1ZXMuZm9yRWFjaCgodiwgaikgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHgxID0gdi54LmNvbnN0cnVjdG9yID09PSBEYXRlID8gK3YueCA6IHYueDtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB4MiA9IGQueC5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/ICtkLnggOiBkLng7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoeDEgPT09IHgyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpID0gajtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoaSBpbiByb3dWYWx1ZXMgJiYgcm93VmFsdWVzW2ldLnZhbHVlICogZC52YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBzY2FsZSh2YWx1ZXNbaV0pIC0geTA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9O1xuXHR9LFxuXG5cdGlzV2l0aGluU2hhcGUodGhhdCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoYXQpO1xuXHRcdGxldCBpc1dpdGhpbjtcblxuXHRcdGlmICghJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpIHtcblx0XHRcdGlzV2l0aGluID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xuXHRcdFx0aXNXaXRoaW4gPSAkJC5pc1N0ZXBUeXBlKGQpID9cblx0XHRcdFx0JCQuaXNXaXRoaW5TdGVwKHRoYXQsICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKSkgOlxuXHRcdFx0XHQkJC5pc1dpdGhpbkNpcmNsZSh0aGF0LCAkJC5pc0J1YmJsZVR5cGUoZCkgPyAkJC5wb2ludFNlbGVjdFIoZCkgKiAxLjUgOiAwKTtcblx0XHR9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XG5cdFx0XHRpc1dpdGhpbiA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSA/ICQkLmlzV2l0aGluQmFyKHRoYXQpIDogdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXNXaXRoaW47XG5cdH0sXG5cblx0Z2V0SW50ZXJwb2xhdGUoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuZ2V0SW50ZXJwb2xhdGVUeXBlKGQpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdFwiYmFzaXNcIjogZDNDdXJ2ZUJhc2lzLFxuXHRcdFx0XCJiYXNpcy1jbG9zZWRcIjogZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxuXHRcdFx0XCJiYXNpcy1vcGVuXCI6IGQzQ3VydmVCYXNpc09wZW4sXG5cdFx0XHRcImJ1bmRsZVwiOiBkM0N1cnZlQnVuZGxlLFxuXHRcdFx0XCJjYXJkaW5hbFwiOiBkM0N1cnZlQ2FyZGluYWwsXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiOiBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIjogZDNDdXJ2ZUNhcmRpbmFsT3Blbixcblx0XHRcdFwiY2F0bXVsbC1yb21cIjogZDNDdXJ2ZUNhdG11bGxSb20sXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiOiBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiOiBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXG5cdFx0XHRcIm1vbm90b25lLXhcIjogZDNDdXJ2ZU1vbm90b25lWCxcblx0XHRcdFwibW9ub3RvbmUteVwiOiBkM0N1cnZlTW9ub3RvbmVZLFxuXHRcdFx0XCJuYXR1cmFsXCI6IGQzQ3VydmVOYXR1cmFsLFxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCI6IGQzQ3VydmVMaW5lYXJDbG9zZWQsXG5cdFx0XHRcImxpbmVhclwiOiBkM0N1cnZlTGluZWFyLFxuXHRcdFx0XCJzdGVwXCI6IGQzQ3VydmVTdGVwLFxuXHRcdFx0XCJzdGVwLWFmdGVyXCI6IGQzQ3VydmVTdGVwQWZ0ZXIsXG5cdFx0XHRcInN0ZXAtYmVmb3JlXCI6IGQzQ3VydmVTdGVwQmVmb3JlXG5cdFx0fVtpbnRlcnBvbGF0aW9uXTtcblx0fSxcblxuXHRnZXRJbnRlcnBvbGF0ZVR5cGUoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0eXBlID0gJCQuY29uZmlnLnNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGU7XG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmlzSW50ZXJwb2xhdGlvblR5cGUodHlwZSkgPyB0eXBlIDogXCJjYXJkaW5hbFwiO1xuXG5cdFx0cmV0dXJuICQkLmlzU3BsaW5lVHlwZShkKSA/XG5cdFx0XHRpbnRlcnBvbGF0aW9uIDogKFxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cblx0XHRcdFx0XHQkJC5jb25maWcubGluZV9zdGVwX3R5cGUgOiBcImxpbmVhclwiXG5cdFx0XHQpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0ZXZlbnQgYXMgZDNFdmVudFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1xuXHRhcmMgYXMgZDNBcmMsXG5cdHBpZSBhcyBkM1BpZVxufSBmcm9tIFwiZDMtc2hhcGVcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgZDNJbnRlcnBvbGF0ZX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmQsIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRQaWUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nO1xuXG5cdFx0Y29uc3QgcGFkQW5nbGUgPSAkJC5oYXNUeXBlKFwicGllXCIpICYmIHBhZGRpbmcgP1xuXHRcdFx0cGFkZGluZyAqIDAuMDEgOiBjb25maWdbYCR7Y29uZmlnLmRhdGFfdHlwZX1fcGFkQW5nbGVgXSA/XG5cdFx0XHRcdGNvbmZpZ1tgJHtjb25maWcuZGF0YV90eXBlfV9wYWRBbmdsZWBdIDogMDtcblxuXHRcdCQkLnBpZSA9IGQzUGllKClcblx0XHRcdC5wYWRBbmdsZShwYWRBbmdsZSlcblx0XHRcdC5zb3J0VmFsdWVzKFxuXHRcdFx0XHQkJC5pc09yZGVyQXNjKCkgfHwgJCQuaXNPcmRlckRlc2MoKSA/XG5cdFx0XHRcdFx0KGEsIGIpID0+ICgkJC5pc09yZGVyQXNjKCkgPyBhIC0gYiA6IGIgLSBhKSA6IG51bGxcblx0XHRcdClcblx0XHRcdC52YWx1ZShkID0+IGQudmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApKTtcblx0fSxcblxuXHR1cGRhdGVSYWRpdXMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucGllX2lubmVyUmFkaXVzO1xuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XG5cdFx0Y29uc3QgdyA9IGNvbmZpZy5nYXVnZV93aWR0aCB8fCBjb25maWcuZG9udXRfd2lkdGg7XG5cblx0XHQkJC5yYWRpdXNFeHBhbmRlZCA9IE1hdGgubWluKCQkLmFyY1dpZHRoLCAkJC5hcmNIZWlnaHQpIC8gMjtcblx0XHQkJC5yYWRpdXMgPSAkJC5yYWRpdXNFeHBhbmRlZCAqIDAuOTU7XG5cdFx0JCQuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoJCQucmFkaXVzIC0gdykgLyAkJC5yYWRpdXMgOiAwLjY7XG5cblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAoXG5cdFx0XHRwYWRkaW5nID8gcGFkZGluZyAqICgkJC5pbm5lclJhZGl1c1JhdGlvICsgMC4xKSA6IDBcblx0XHQpO1xuXG5cdFx0Ly8gTk9URTogaW5uZXJSYWRpdXMgY2FuIGJlIGFuIG9iamVjdCBieSB1c2VyIHNldHRpbmcsIG9ubHkgZm9yICdwaWUnIHR5cGVcblx0XHQkJC5pbm5lclJhZGl1cyA9ICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgP1xuXHRcdFx0JCQucmFkaXVzICogJCQuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xuXHR9LFxuXG5cdGdldElubmVyUmFkaXVzKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHJhZGl1cyA9ICQkLmlubmVyUmFkaXVzO1xuXG5cdFx0aWYgKCFpc051bWJlcihyYWRpdXMpICYmIGQpIHtcblx0XHRcdHJhZGl1cyA9IHJhZGl1c1tkLmRhdGEuaWRdIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhZGl1cztcblx0fSxcblxuXHR1cGRhdGVBcmMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuc3ZnQXJjID0gJCQuZ2V0U3ZnQXJjKCk7XG5cdFx0JCQuc3ZnQXJjRXhwYW5kZWQgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgpO1xuXHRcdCQkLnN2Z0FyY0V4cGFuZGVkU3ViID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoMC45OCk7XG5cdH0sXG5cblx0dXBkYXRlQW5nbGUoZFZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRsZXQgcGllID0gJCQucGllO1xuXHRcdGxldCBkID0gZFZhbHVlO1xuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0aWYgKCFjb25maWcpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChkLmRhdGEgJiYgJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xuXHRcdFx0Y29uc3QgdG90YWxTdW0gPSAkJC5nZXRUb3RhbERhdGFTdW0oKTtcblxuXHRcdFx0Ly8gaWYgZ2F1Z2VfbWF4IGxlc3MgdGhhbiB0b3RhbFN1bSwgbWFrZSB0b3RhbFN1bSB0byBtYXggdmFsdWVcblx0XHRcdGlmICh0b3RhbFN1bSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcblx0XHRcdFx0Y29uZmlnLmdhdWdlX21heCA9IHRvdGFsU3VtO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByYWRpdXMgPSBNYXRoLlBJICogKGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xuXHRcdFx0Y29uc3QgZ1N0YXJ0ID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XG5cdFx0XHRjb25zdCBnRW5kID0gcmFkaXVzICogKHRvdGFsU3VtIC8gKGNvbmZpZy5nYXVnZV9tYXggLSBjb25maWcuZ2F1Z2VfbWluKSk7XG5cblx0XHRcdHBpZSA9ICQkLnBpZVxuXHRcdFx0XHQuc3RhcnRBbmdsZShnU3RhcnQpXG5cdFx0XHRcdC5lbmRBbmdsZShnRW5kICsgZ1N0YXJ0KTtcblx0XHR9XG5cblx0XHRwaWUoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygpKS5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0aWYgKCFmb3VuZCAmJiB0LmRhdGEuaWQgPT09IGQuZGF0YS5pZCkge1xuXHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdGQgPSB0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGlzTmFOKGQuc3RhcnRBbmdsZSkpIHtcblx0XHRcdGQuc3RhcnRBbmdsZSA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKGQuZW5kQW5nbGUpKSB7XG5cdFx0XHRkLmVuZEFuZ2xlID0gZC5zdGFydEFuZ2xlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmb3VuZCA/IGQgOiBudWxsO1xuXHR9LFxuXG5cdGdldFN2Z0FyYygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpO1xuXHRcdGxldCBhcmMgPSBkM0FyYygpXG5cdFx0XHQub3V0ZXJSYWRpdXMoJCQucmFkaXVzKVxuXHRcdFx0LmlubmVyUmFkaXVzKGlzTnVtYmVyKGlyKSA/IGlyIDogMCk7XG5cblx0XHRjb25zdCBuZXdBcmMgPSAoZCwgd2l0aG91dFVwZGF0ZSkgPT4ge1xuXHRcdFx0bGV0IHBhdGggPSBcIk0gMCAwXCI7XG5cblx0XHRcdGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xuXHRcdFx0XHRpZiAoIWlzTnVtYmVyKGlyKSkge1xuXHRcdFx0XHRcdGFyYyA9IGFyYy5pbm5lclJhZGl1cygkJC5nZXRJbm5lclJhZGl1cyhkKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gIXdpdGhvdXRVcGRhdGUgJiYgJCQudXBkYXRlQW5nbGUoZCk7XG5cblx0XHRcdFx0aWYgKHdpdGhvdXRVcGRhdGUpIHtcblx0XHRcdFx0XHRwYXRoID0gYXJjKGQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHVwZGF0ZWQpIHtcblx0XHRcdFx0XHRwYXRoID0gYXJjKHVwZGF0ZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH07XG5cblx0XHQvLyBUT0RPOiBleHRlbmRzIGFsbCBmdW5jdGlvblxuXHRcdG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZDtcblxuXHRcdHJldHVybiBuZXdBcmM7XG5cdH0sXG5cblx0Z2V0U3ZnQXJjRXhwYW5kZWQocmF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBhcmMgPSBkM0FyYygpXG5cdFx0XHQub3V0ZXJSYWRpdXMoJCQucmFkaXVzRXhwYW5kZWQgKiAocmF0ZSB8fCAxKSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xuXHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXG5cdFx0XHRyZXR1cm4gdXBkYXRlZCA/IGFyYy5pbm5lclJhZGl1cygkJC5nZXRJbm5lclJhZGl1cyhkKSkodXBkYXRlZCkgOiBcIk0gMCAwXCI7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRBcmMoZCwgd2l0aG91dFVwZGF0ZSwgZm9yY2UpIHtcblx0XHRyZXR1cm4gZm9yY2UgfHwgdGhpcy5pc0FyY1R5cGUoZC5kYXRhKSA/IHRoaXMuc3ZnQXJjKGQsIHdpdGhvdXRVcGRhdGUpIDogXCJNIDAgMFwiO1xuXHR9LFxuXG5cdHRyYW5zZm9ybUZvckFyY0xhYmVsKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRsZXQgdHJhbnNsYXRlID0gXCJcIjtcblxuXHRcdGlmICh1cGRhdGVkICYmICghJCQuaGFzVHlwZShcImdhdWdlXCIpIHx8ICQkLmhhc011bHRpVGFyZ2V0cygpKSkge1xuXHRcdFx0Y29uc3QgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xuXHRcdFx0Y29uc3QgeCA9IGlzTmFOKGNbMF0pID8gMCA6IGNbMF07XG5cdFx0XHRjb25zdCB5ID0gaXNOYU4oY1sxXSkgPyAwIDogY1sxXTtcblx0XHRcdGNvbnN0IGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cblx0XHRcdGxldCByYXRpbyA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSB8fFxuXHRcdFx0XHQoJCQuaGFzVHlwZShcInBpZVwiKSAmJiBjb25maWcucGllX2xhYmVsX3JhdGlvKTtcblxuXHRcdFx0aWYgKHJhdGlvKSB7XG5cdFx0XHRcdHJhdGlvID0gaXNGdW5jdGlvbihyYXRpbykgPyByYXRpbyhkLCAkJC5yYWRpdXMsIGgpIDogcmF0aW87XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYXRpbyA9ICQkLnJhZGl1cyAmJlxuXHRcdFx0XHRcdChoID8gKDM2IC8gJCQucmFkaXVzID4gMC4zNzUgPyAxLjE3NSAtIDM2IC8gJCQucmFkaXVzIDogMC44KSAqICQkLnJhZGl1cyAvIGggOiAwKTtcblx0XHRcdH1cblxuXHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3ggKiByYXRpb30sJHt5ICogcmF0aW99KWA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRyYW5zbGF0ZTtcblx0fSxcblxuXHRjb252ZXJ0VG9BcmNEYXRhKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGROYW1lKHtcblx0XHRcdGlkOiBkLmRhdGEuaWQsXG5cdFx0XHR2YWx1ZTogZC52YWx1ZSxcblx0XHRcdHJhdGlvOiB0aGlzLmdldFJhdGlvKFwiYXJjXCIsIGQpLFxuXHRcdFx0aW5kZXg6IGQuaW5kZXgsXG5cdFx0fSk7XG5cdH0sXG5cblx0dGV4dEZvckFyY0xhYmVsKHNlbGVjdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGlmICgkJC5zaG91bGRTaG93QXJjTGFiZWwoKSkge1xuXHRcdFx0c2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB1cGRhdGVkID8gdXBkYXRlZC52YWx1ZSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IHJhdGlvID0gJCQuZ2V0UmF0aW8oXCJhcmNcIiwgdXBkYXRlZCk7XG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhLmlkO1xuXHRcdFx0XHRjb25zdCBpc1VuZGVyVGhyZXNob2xkID0gIShcblx0XHRcdFx0XHQhJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICEkJC5tZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChpc1VuZGVyVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGV4dCA9IChcblx0XHRcdFx0XHRcdCQkLmdldEFyY0xhYmVsRm9ybWF0KCkgfHwgJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0XG5cdFx0XHRcdFx0KSh2YWx1ZSwgcmF0aW8sIGlkKS50b1N0cmluZygpO1xuXG5cdFx0XHRcdFx0c2V0VGV4dFZhbHVlKG5vZGUsIHRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0dGV4dEZvckdhdWdlTWluTWF4KHZhbHVlLCBpc01heCkge1xuXHRcdGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0R2F1Z2VMYWJlbEV4dGVudHMoKTtcblxuXHRcdHJldHVybiBmb3JtYXQgPyBmb3JtYXQodmFsdWUsIGlzTWF4KSA6IHZhbHVlO1xuXHR9LFxuXG5cdGV4cGFuZEFyYyh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQvLyBNRU1POiBhdm9pZCB0byBjYW5jZWwgdHJhbnNpdGlvblxuXHRcdGlmICgkJC50cmFuc2l0aW5nKSB7XG5cdFx0XHRjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdFx0aWYgKCEkJC50cmFuc2l0aW5nKSB7XG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cblx0XHRcdFx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZH1gKS5zaXplKCkgPiAwICYmXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRBcmModGFyZ2V0SWRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTApO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcblxuXHRcdCQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRpZiAoISQkLnNob3VsZEV4cGFuZChkLmRhdGEuaWQpIHx8IGQudmFsdWUgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBleHBhbmREdXJhdGlvbiA9ICQkLmV4cGFuZER1cmF0aW9uKGQuZGF0YS5pZCk7XG5cblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuc2VsZWN0QWxsKFwicGF0aFwiKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24pXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyY0V4cGFuZGVkKVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24gKiAyKVxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmNFeHBhbmRlZFN1Yik7XG5cdFx0XHR9KTtcblx0fSxcblxuXHR1bmV4cGFuZEFyYyh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQudHJhbnNpdGluZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyhuZXdUYXJnZXRJZHMsIGAuJHtDTEFTUy5jaGFydEFyY31gKSlcblx0XHRcdC5zZWxlY3RBbGwoXCJwYXRoXCIpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZCA9PiAkJC5leHBhbmREdXJhdGlvbihkLmRhdGEuaWQpKVxuXHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyYyk7XG5cblx0XHQkJC5zdmcuc2VsZWN0QWxsKGAke0NMQVNTLmFyY31gKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH0sXG5cblx0ZXhwYW5kRHVyYXRpb24oaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCB0eXBlO1xuXG5cdFx0aWYgKCQkLmlzRG9udXRUeXBlKGlkKSkge1xuXHRcdFx0dHlwZSA9IFwiZG9udXRcIjtcblx0XHR9IGVsc2UgaWYgKCQkLmlzR2F1Z2VUeXBlKGlkKSkge1xuXHRcdFx0dHlwZSA9IFwiZ2F1Z2VcIjtcblx0XHR9IGVsc2UgaWYgKCQkLmlzUGllVHlwZShpZCkpIHtcblx0XHRcdHR5cGUgPSBcInBpZVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiB0eXBlID8gY29uZmlnW2Ake3R5cGV9X2V4cGFuZF9kdXJhdGlvbmBdIDogNTA7XG5cdH0sXG5cblx0c2hvdWxkRXhwYW5kKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdHJldHVybiAoJCQuaXNEb251dFR5cGUoaWQpICYmIGNvbmZpZy5kb251dF9leHBhbmQpIHx8XG5cdFx0XHQoJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQpIHx8XG5cdFx0XHQoJCQuaXNQaWVUeXBlKGlkKSAmJiBjb25maWcucGllX2V4cGFuZCk7XG5cdH0sXG5cblx0c2hvdWxkU2hvd0FyY0xhYmVsKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiXVxuXHRcdFx0LnNvbWUodiA9PiAkJC5oYXNUeXBlKHYpICYmIGNvbmZpZ1tgJHt2fV9sYWJlbF9zaG93YF0pO1xuXHR9LFxuXG5cdG1lZXRzQXJjTGFiZWxUaHJlc2hvbGQocmF0aW8pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHRocmVzaG9sZCA9ICQkLmhhc1R5cGUoXCJkb251dFwiKSA/IGNvbmZpZy5kb251dF9sYWJlbF90aHJlc2hvbGQgOiBjb25maWcucGllX2xhYmVsX3RocmVzaG9sZDtcblxuXHRcdHJldHVybiByYXRpbyA+PSB0aHJlc2hvbGQ7XG5cdH0sXG5cblx0Z2V0QXJjTGFiZWxGb3JtYXQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRsZXQgZm9ybWF0ID0gY29uZmlnLnBpZV9sYWJlbF9mb3JtYXQ7XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZm9ybWF0O1xuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImRvbnV0XCIpKSB7XG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZG9udXRfbGFiZWxfZm9ybWF0O1xuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXQ7XG5cdH0sXG5cblx0Z2V0R2F1Z2VMYWJlbEV4dGVudHMoKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cblx0XHRyZXR1cm4gY29uZmlnLmdhdWdlX2xhYmVsX2V4dGVudHM7XG5cdH0sXG5cblx0Z2V0QXJjVGl0bGUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHR5cGUgPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIFwiZG9udXRcIikgfHwgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiBcImdhdWdlXCIpO1xuXG5cdFx0cmV0dXJuIHR5cGUgPyAkJC5jb25maWdbYCR7dHlwZX1fdGl0bGVgXSA6IFwiXCI7XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0c0ZvckFyYyh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRBcmMgPSAkJC5jbGFzc0NoYXJ0QXJjLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQXJjcyA9ICQkLmNsYXNzQXJjcy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcblx0XHRjb25zdCBtYWluUGllVXBkYXRlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcblx0XHRcdC5kYXRhKCQkLnBpZSh0YXJnZXRzKSlcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QXJjKGQpICsgY2xhc3NGb2N1cyhkLmRhdGEpKTtcblxuXHRcdGNvbnN0IG1haW5QaWVFbnRlciA9IG1haW5QaWVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRBcmMpO1xuXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmNzKVxuXHRcdFx0Lm1lcmdlKG1haW5QaWVVcGRhdGUpO1xuXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcInRleHRcIilcblx0XHRcdC5hdHRyKFwiZHlcIiwgaGFzR2F1Z2UgJiYgISQkLmhhc011bHRpVGFyZ2V0cygpID8gXCItLjFlbVwiIDogXCIuMzVlbVwiKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi4sIGJ1dCBub3QgYmFkIHRvIHVwZGF0ZSBjb2xvciBpbiByZWRyYXdcblx0XHQvLyBtYWluUGllVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcblx0fSxcblxuXHRpbml0QXJjKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmFyY3MgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QXJjcylcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XG5cblx0XHQkJC5zZXRBcmNUaXRsZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgYXJjIHRpdGxlIHRleHRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldEFyY1RpdGxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0aXRsZSA9ICQkLmdldEFyY1RpdGxlKCk7XG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XG5cblx0XHRpZiAodGl0bGUpIHtcblx0XHRcdGNvbnN0IHRleHQgPSAkJC5hcmNzLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTU1toYXNHYXVnZSA/IFwiY2hhcnRBcmNzR2F1Z2VUaXRsZVwiIDogXCJjaGFydEFyY3NUaXRsZVwiXSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG5cblx0XHRcdGlmIChoYXNHYXVnZSkge1xuXHRcdFx0XHR0ZXh0XG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0wLjNlbVwiKVxuXHRcdFx0XHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjI3cHhcIik7XG5cdFx0XHR9XG5cblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCB0aXRsZSwgaGFzR2F1Z2UgPyB1bmRlZmluZWQgOiBbLTEuMywgMS4zXSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3aXRoVHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBtYWluID0gJCQubWFpbjtcblx0XHRjb25zdCBoYXNJbnRlcmFjdGlvbiA9IGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkO1xuXG5cdFx0bGV0IG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfWApXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcblxuXHRcdG1haW5BcmMuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRtYWluQXJjID0gbWFpbkFyYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmMuYmluZCgkJCkpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZC5kYXRhKSlcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IGhhc0ludGVyYWN0aW9uICYmIChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGlmICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XG5cdFx0XHRcdFx0ZC5zdGFydEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XG5cdFx0XHRcdFx0ZC5lbmRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY3VycmVudCA9IGQ7XG5cdFx0XHR9KVxuXHRcdFx0Lm1lcmdlKG1haW5BcmMpO1xuXG5cdFx0bWFpbkFyY1xuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiAoISQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMClcIiA6IFwiXCIpKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdHJldHVybiBkID09PSB0aGlzLl9jdXJyZW50ID8gXCIwXCIgOiBcIjFcIjtcblx0XHRcdH0pXG5cdFx0XHQuZWFjaCgoKSA9PiB7XG5cdFx0XHRcdCQkLnRyYW5zaXRpbmcgPSB0cnVlO1xuXHRcdFx0fSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5hdHRyVHdlZW4oXCJkXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXG5cdFx0XHRcdGlmICghdXBkYXRlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiBcIk0gMCAwXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5zdGFydEFuZ2xlKSkge1xuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5lbmRBbmdsZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50LmVuZEFuZ2xlID0gdGhpcy5fY3VycmVudC5zdGFydEFuZ2xlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIHVwZGF0ZWQpO1xuXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKHQpO1xuXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVkLmRhdGEgPSBkLmRhdGE7IC8vIGRhdGEuaWQgd2lsbCBiZSB1cGRhdGVkIGJ5IGludGVycG9yYXRvclxuXHRcdFx0XHRcdHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgxKVwiIDogXCJcIilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiAoJCQubGV2ZWxDb2xvciA/XG5cdFx0XHRcdCQkLmxldmVsQ29sb3IoZC5kYXRhLnZhbHVlc1swXS52YWx1ZSkgOiAkJC5jb2xvcihkLmRhdGEuaWQpKVxuXHRcdFx0KVxuXHRcdFx0Ly8gV2hlcmUgZ2F1Z2UgcmVhZGluZyBjb2xvciB3b3VsZCByZWNlaXZlIGN1c3RvbWl6YXRpb24uXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCAoKSA9PiB7XG5cdFx0XHRcdCQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gYmluZCBhcmMgZXZlbnRzXG5cdFx0aGFzSW50ZXJhY3Rpb24gJiYgJCQuYmluZEFyY0V2ZW50KG1haW5BcmMpO1xuXG5cdFx0JCQucmVkcmF3QXJjVGV4dChkdXJhdGlvbik7XG5cdH0sXG5cblx0YmluZEFyY0V2ZW50KGFyYykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1RvdWNoID0gJCQuaW5wdXRUeXBlID09PSBcInRvdWNoXCI7XG5cdFx0Y29uc3QgaXNNb3VzZSA9ICQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xuXG5cdFx0ZnVuY3Rpb24gc2VsZWN0QXJjKF90aGlzLCBhcmNEYXRhLCBpZCkge1xuXHRcdFx0Ly8gdHJhbnNpdGlvbnNcblx0XHRcdCQkLmV4cGFuZEFyYyhpZCk7XG5cdFx0XHQkJC5hcGkuZm9jdXMoaWQpO1xuXHRcdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQoaWQsIHRydWUpO1xuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCBfdGhpcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YSkge1xuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdCQkLnVuZXhwYW5kQXJjKGlkKTtcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcblx0XHRcdCQkLnJldmVydExlZ2VuZCgpO1xuXHRcdFx0JCQuaGlkZVRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRhcmNcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXHRcdFx0XHRsZXQgYXJjRGF0YTtcblxuXHRcdFx0XHRpZiAodXBkYXRlZCkge1xuXHRcdFx0XHRcdGFyY0RhdGEgPSAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpO1xuXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUgJiYgJCQudG9nZ2xlU2hhcGUodGhpcywgYXJjRGF0YSwgaSk7XG5cdFx0XHRcdFx0JCQuY29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgYXJjRGF0YSwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0Ly8gbW91c2UgZXZlbnRzXG5cdFx0aWYgKGlzTW91c2UpIHtcblx0XHRcdGFyY1xuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdGlmICgkJC50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuXHRcdFx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KHRydWUsIGFyY0RhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcblx0XHRcdFx0XHRpZiAoJCQudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcblxuXHRcdFx0XHRcdHVuc2VsZWN0QXJjKCk7XG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XG5cblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyB0b3VjaCBldmVudHNcblx0XHRpZiAoaXNUb3VjaCAmJiAkJC5oYXNBcmNUeXBlKCkgJiYgISQkLnJhZGFycykge1xuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmMgPSBkM1NlbGVjdChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcblxuXHRcdFx0XHRyZXR1cm4gZXZlbnRBcmM7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICgkJC50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcblx0XHRcdFx0Y29uc3QgZGF0dW0gPSBldmVudEFyYy5kYXR1bSgpO1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGFyY0RhdGEpO1xuXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XG5cdFx0XHRcdFx0dW5zZWxlY3RBcmMoKSA6IHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQkJC5zdmdcblx0XHRcdFx0Lm9uKFwidG91Y2hzdGFydFwiLCBoYW5kbGVyKVxuXHRcdFx0XHQub24oXCJ0b3VjaG1vdmVcIiwgaGFuZGxlcik7XG5cdFx0fVxuXHR9LFxuXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xuXG5cdFx0Y29uc3QgdGV4dCA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEFyY31gKVxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gKCQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgPyBDTEFTUy5nYXVnZVZhbHVlIDogbnVsbCkpXG5cdFx0XHQuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC50cmFuc2Zvcm1Gb3JBcmNMYWJlbC5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IGAke01hdGgucm91bmQoJCQucmFkaXVzIC8gNSl9cHhgIDogXCJcIikpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGQgPT4gKCQkLmlzVGFyZ2V0VG9TaG93KGQuZGF0YS5pZCkgJiYgJCQuaXNBcmNUeXBlKGQuZGF0YSkgPyBcIjFcIiA6IFwiMFwiKSk7XG5cblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzVGl0bGV9YClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaGFzVHlwZShcImRvbnV0XCIpIHx8IGhhc0dhdWdlID8gXCIxXCIgOiBcIjBcIik7XG5cblx0XHRpZiAoaGFzR2F1Z2UpIHtcblx0XHRcdGNvbnN0IGlzRnVsbENpcmNsZSA9IGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlO1xuXHRcdFx0Y29uc3QgZW5kQW5nbGUgPSAoaXNGdWxsQ2lyY2xlID8gLTQgOiAtMSkgKiBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcblxuXHRcdFx0aXNGdWxsQ2lyY2xlICYmIHRleHQuYXR0cihcImR5XCIsIGAke01hdGgucm91bmQoJCQucmFkaXVzIC8gMTQpfWApO1xuXG5cdFx0XHQkJC5hcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gKVxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGQgPSB7XG5cdFx0XHRcdFx0XHRkYXRhOiBbe3ZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4fV0sXG5cdFx0XHRcdFx0XHRzdGFydEFuZ2xlOiBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZSxcblx0XHRcdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0JCQuYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdH1gKVxuXHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLjc1ZW1cIilcblx0XHRcdFx0LnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKTtcblxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XG5cdFx0XHRcdCQkLmFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1pbn1gKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7LTEgKiAoJCQuaW5uZXJSYWRpdXMgKyAoKCQkLnJhZGl1cyAtICQkLmlubmVyUmFkaXVzKSAvIChjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDEgOiAyKSkpfXB4YClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcblx0XHRcdFx0XHQudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21pbiwgZmFsc2UpKTtcblxuXHRcdFx0XHQvLyBzaG93IG1heCB0ZXh0IHdoZW4gaXNuJ3QgZnVsbENpcmNsZVxuXHRcdFx0XHQhaXNGdWxsQ2lyY2xlICYmICQkLmFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1heH1gKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7JCQuaW5uZXJSYWRpdXMgKyAoKCQkLnJhZGl1cyAtICQkLmlubmVyUmFkaXVzKSAvIDIpfXB4YClcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcblx0XHRcdFx0XHQudGV4dCgkJC50ZXh0Rm9yR2F1Z2VNaW5NYXgoY29uZmlnLmdhdWdlX21heCwgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbml0R2F1Z2UoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBhcmNzID0gJCQuYXJjcztcblx0XHRjb25zdCBhcHBlbmRUZXh0ID0gY2xhc3NOYW1lID0+IHtcblx0XHRcdGFyY3MuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXHRcdH07XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XG5cdFx0XHRhcmNzLmFwcGVuZChcInBhdGhcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcblxuXHRcdFx0Y29uZmlnLmdhdWdlX3VuaXRzICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0KTtcblxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XG5cdFx0XHRcdGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW4pO1xuXHRcdFx0XHQhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldEdhdWdlTGFiZWxIZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyAyMCA6IDA7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHttb3VzZSBhcyBkM01vdXNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRSYW5kb20sIGdldFJlY3RTZWdMaXN0LCBpc051bWJlciwgaXNPYmplY3RUeXBlLCBpc1ZhbHVlfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGluaXRCYXIoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcblx0fSxcblxuXHR1cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcblx0XHRjb25zdCBtYWluQmFyVXBkYXRlID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QmFyc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcblx0XHRcdC5kYXRhKHRhcmdldHMpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydEJhcihkKSArIGNsYXNzRm9jdXMoZCkpO1xuXHRcdGNvbnN0IG1haW5CYXJFbnRlciA9IG1haW5CYXJVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXG5cdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXG5cdFx0bWFpbkJhckVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKVxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcblx0fSxcblxuXHR1cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGJhckRhdGEgPSAkJC5iYXJEYXRhLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCk7XG5cdFx0Y29uc3QgaW5pdGlhbE9wYWNpdHkgPSAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKTtcblxuXHRcdCQkLm1haW5CYXIgPSAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxuXHRcdFx0LmRhdGEoYmFyRGF0YSk7XG5cblx0XHQkJC5tYWluQmFyLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpbkJhciA9ICQkLm1haW5CYXIuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFyKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcblx0XHRcdC5tZXJnZSgkJC5tYWluQmFyKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBpbml0aWFsT3BhY2l0eSk7XG5cdH0sXG5cblx0cmVkcmF3QmFyKGRyYXdCYXIsIHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRoaXMubWFpbkJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IHRoaXMubWFpbkJhcilcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcblx0XHRdO1xuXHR9LFxuXG5cdGdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdGlja0ludGVydmFsID0gYXhpcy50aWNrSW50ZXJ2YWwoJCQuZ2V0TWF4RGF0YUNvdW50KCkpO1xuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XG5cdFx0bGV0IHJlc3VsdDtcblxuXHRcdGNvbnN0IGdldFdpZHRoID0gaWQgPT4ge1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBpZCA/IGNvbmZpZy5iYXJfd2lkdGhbaWRdIDogY29uZmlnLmJhcl93aWR0aDtcblx0XHRcdGNvbnN0IHJhdGlvID0gaWQgPyB3aWR0aC5yYXRpbyA6IGNvbmZpZy5iYXJfd2lkdGhfcmF0aW87XG5cdFx0XHRjb25zdCBtYXggPSBpZCA/IHdpZHRoLm1heCA6IGNvbmZpZy5iYXJfd2lkdGhfbWF4O1xuXHRcdFx0Y29uc3QgdyA9IGlzTnVtYmVyKHdpZHRoKSA/XG5cdFx0XHRcdHdpZHRoIDogYmFyVGFyZ2V0c051bSA/ICh0aWNrSW50ZXJ2YWwgKiByYXRpbykgLyBiYXJUYXJnZXRzTnVtIDogMDtcblxuXHRcdFx0cmV0dXJuIG1heCAmJiB3ID4gbWF4ID8gbWF4IDogdztcblx0XHR9O1xuXG5cdFx0cmVzdWx0ID0gZ2V0V2lkdGgoKTtcblxuXHRcdGlmICghaXNHcm91cGVkICYmIGlzT2JqZWN0VHlwZShjb25maWcuYmFyX3dpZHRoKSkge1xuXHRcdFx0cmVzdWx0ID0ge3dpZHRoOiByZXN1bHQsIHRvdGFsOiBbXX07XG5cblx0XHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRpZiAoY29uZmlnLmJhcl93aWR0aFt2LmlkXSkge1xuXHRcdFx0XHRcdHJlc3VsdFt2LmlkXSA9IGdldFdpZHRoKHYuaWQpO1xuXHRcdFx0XHRcdHJlc3VsdC50b3RhbC5wdXNoKHJlc3VsdFt2LmlkXSB8fCByZXN1bHQud2lkdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdGdldEJhcnMoaSwgaWQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xuXG5cdFx0cmV0dXJuIChpZCA/ICQkLm1haW5cblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC5tYWluKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfSR7c3VmZml4fWApO1xuXHR9LFxuXG5cdGV4cGFuZEJhcnMoaSwgaWQsIHJlc2V0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCk7XG5cdFx0JCQuZ2V0QmFycyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XG5cdH0sXG5cblx0dW5leHBhbmRCYXJzKGkpIHtcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xuXHR9LFxuXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgaXNHcm91cGVkID0gY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aDtcblx0XHRjb25zdCBiYXJSYWRpdXMgPSBjb25maWcuYmFyX3JhZGl1cztcblx0XHRjb25zdCBiYXJSYWRpdXNSYXRpbyA9IGNvbmZpZy5iYXJfcmFkaXVzX3JhdGlvO1xuXG5cdFx0Ly8gZ2V0IHRoZSBiYXIgcmFkaXVzXG5cdFx0Y29uc3QgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID9cblx0XHRcdCgpID0+IGJhclJhZGl1cyA6IChcblx0XHRcdFx0aXNOdW1iZXIoYmFyUmFkaXVzUmF0aW8pID8gdyA9PiB3ICogYmFyUmFkaXVzUmF0aW8gOiBudWxsXG5cdFx0XHQpO1xuXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGdldFBvaW50cyhkLCBpKTtcblxuXHRcdFx0Ly8gc3dpdGNoIHBvaW50cyBpZiBheGlzIGlzIHJvdGF0ZWQsIG5vdCBhcHBsaWNhYmxlIGZvciBzdWIgY2hhcnRcblx0XHRcdGNvbnN0IGluZGV4WCA9ICtpc1JvdGF0ZWQ7XG5cdFx0XHRjb25zdCBpbmRleFkgPSArIWluZGV4WDtcblxuXHRcdFx0Y29uc3QgaXNOZWdhdGl2ZSA9IGQudmFsdWUgPCAwO1xuXHRcdFx0Y29uc3QgcGF0aFJhZGl1cyA9IFtcIlwiLCBcIlwiXTtcblx0XHRcdGxldCByYWRpdXMgPSAwO1xuXG5cdFx0XHRpZiAoZ2V0UmFkaXVzICYmICFpc0dyb3VwZWQpIHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpc1JvdGF0ZWQgPyBpbmRleFkgOiBpbmRleFg7XG5cdFx0XHRcdGNvbnN0IGJhclcgPSBwb2ludHNbMl1baW5kZXhdIC0gcG9pbnRzWzBdW2luZGV4XTtcblxuXHRcdFx0XHRyYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XG5cblx0XHRcdFx0Y29uc3QgYXJjID0gYGEke3JhZGl1c30sJHtyYWRpdXN9ICR7aXNOZWdhdGl2ZSA/IGAxIDAgMGAgOiBgMCAwIDFgfSBgO1xuXG5cdFx0XHRcdHBhdGhSYWRpdXNbKyFpc1JvdGF0ZWRdID0gYCR7YXJjfSR7cmFkaXVzfSwke3JhZGl1c31gO1xuXHRcdFx0XHRwYXRoUmFkaXVzWytpc1JvdGF0ZWRdID0gYCR7YXJjfSR7Wy1yYWRpdXMsIHJhZGl1c11baXNSb3RhdGVkID8gXCJzb3J0XCIgOiBcInJldmVyc2VcIl0oKX1gO1xuXG5cdFx0XHRcdGlzTmVnYXRpdmUgJiYgcGF0aFJhZGl1cy5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhdGggc3RyaW5nIGRhdGEgc2hvdWxkbid0IGJlIGNvbnRhaW5pbmcgbmV3IGxpbmUgY2hhcnNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzUzMFxuXHRcdFx0Y29uc3QgcGF0aCA9IGlzUm90YXRlZCA/XG5cdFx0XHRcdGBIJHtwb2ludHNbMV1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzBdfVYke3BvaW50c1syXVtpbmRleFldIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMV19SCR7cG9pbnRzWzNdW2luZGV4WF19YCA6XG5cdFx0XHRcdGBWJHtwb2ludHNbMV1baW5kZXhZXSArIChpc05lZ2F0aXZlID8gLXJhZGl1cyA6IHJhZGl1cyl9ICR7cGF0aFJhZGl1c1swXX1IJHtwb2ludHNbMl1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfVYke3BvaW50c1szXVtpbmRleFldfWA7XG5cblx0XHRcdHJldHVybiBgTSR7cG9pbnRzWzBdW2luZGV4WF19LCR7cG9pbnRzWzBdW2luZGV4WV19JHtwYXRofXpgO1xuXHRcdH07XG5cdH0sXG5cblx0Z2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYXhpcyA9IGlzU3ViID8gJCQuc3ViWEF4aXMgOiAkJC54QXhpcztcblx0XHRjb25zdCBiYXJUYXJnZXRzTnVtID0gYmFySW5kaWNlcy5fX21heF9fICsgMTtcblx0XHRjb25zdCBiYXJXID0gJCQuZ2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtKTtcblx0XHRjb25zdCBiYXJYID0gJCQuZ2V0U2hhcGVYKGJhclcsIGJhclRhcmdldHNOdW0sIGJhckluZGljZXMsICEhaXNTdWIpO1xuXHRcdGNvbnN0IGJhclkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XG5cdFx0Y29uc3QgYmFyT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNCYXJUeXBlLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XG5cdFx0XHRjb25zdCBvZmZzZXQgPSBiYXJPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBiYXIgY2hhcnRcblx0XHRcdGNvbnN0IHdpZHRoID0gaXNOdW1iZXIoYmFyVykgPyBiYXJXIDogYmFyV1tkLmlkXSB8fCBiYXJXLndpZHRoO1xuXHRcdFx0Y29uc3QgcG9zWCA9IGJhclgoZCk7XG5cdFx0XHRsZXQgcG9zWSA9IGJhclkoZCk7XG5cblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuXHRcdFx0aWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxuXHRcdFx0KSkge1xuXHRcdFx0XHRwb3NZID0geTA7XG5cdFx0XHR9XG5cblx0XHRcdHBvc1kgLT0gKHkwIC0gb2Zmc2V0KTtcblxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcblx0XHRcdFx0W3Bvc1gsIHBvc1ldLFxuXHRcdFx0XHRbcG9zWCArIHdpZHRoLCBwb3NZXSxcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgb2Zmc2V0XVxuXHRcdFx0XTtcblx0XHR9O1xuXHR9LFxuXG5cdGlzV2l0aGluQmFyKHRoYXQpIHtcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhhdCk7XG5cdFx0Y29uc3QgbGlzdCA9IGdldFJlY3RTZWdMaXN0KHRoYXQpO1xuXHRcdGNvbnN0IFtzZWcwLCBzZWcxXSA9IGxpc3Q7XG5cdFx0Y29uc3QgeCA9IE1hdGgubWluKHNlZzAueCwgc2VnMS54KTtcblx0XHRjb25zdCB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpO1xuXHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuY29uZmlnLmJhcl9zZW5zaXRpdml0eTtcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGF0LmdldEJCb3goKTtcblx0XHRjb25zdCBzeCA9IHggLSBvZmZzZXQ7XG5cdFx0Y29uc3QgZXggPSB4ICsgd2lkdGggKyBvZmZzZXQ7XG5cdFx0Y29uc3Qgc3kgPSB5ICsgaGVpZ2h0ICsgb2Zmc2V0O1xuXHRcdGNvbnN0IGV5ID0geSAtIG9mZnNldDtcblxuXHRcdHJldHVybiBzeCA8IG1vdXNlWzBdICYmXG5cdFx0XHRtb3VzZVswXSA8IGV4ICYmXG5cdFx0XHRleSA8IG1vdXNlWzFdICYmXG5cdFx0XHRtb3VzZVsxXSA8IHN5O1xuXHR9XG59KTtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgZ2V0TWluTWF4LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3R9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0QnViYmxlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xuXHRcdFx0Y29uZmlnLnBvaW50X3Nob3cgPSB0cnVlO1xuXHRcdFx0Y29uZmlnLnBvaW50X3R5cGUgPSBcImNpcmNsZVwiO1xuXHRcdFx0Y29uZmlnLnBvaW50X3NlbnNpdGl2aXR5ID0gMjU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHVzZXIgdW5pdHNcblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dlb21ldHJ5RWxlbWVudC9nZXRUb3RhbExlbmd0aFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRCYXNlTGVuZ3RoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJGJhc2VMZW5ndGhcIjtcblx0XHRsZXQgYmFzZUxlbmd0aCA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xuXHRcdFx0JCQuYWRkQ2FjaGUoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW1xuXHRcdFx0XHQkJC5heGVzLnguc2VsZWN0KFwicGF0aFwiKS5ub2RlKClcblx0XHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKSxcblx0XHRcdFx0JCQuYXhlcy55LnNlbGVjdChcInBhdGhcIikubm9kZSgpXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKClcblx0XHRcdF0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYmFzZUxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuIFx0ICovXG5cdGdldEJ1YmJsZVIoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgbWF4UiA9ICQkLmNvbmZpZy5idWJibGVfbWF4UjtcblxuXHRcdGlmIChpc0Z1bmN0aW9uKG1heFIpKSB7XG5cdFx0XHRtYXhSID0gbWF4UihkKTtcblx0XHR9IGVsc2UgaWYgKCFpc051bWJlcihtYXhSKSkge1xuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcblx0XHR9XG5cblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoaXNPYmplY3QoZC52YWx1ZSkgPyBkLnZhbHVlLm1pZCA6IGQudmFsdWUpKSk7XG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcblx0XHRjb25zdCBhcmVhID0gZC52YWx1ZSAqIChtYXhBcmVhIC8gbWF4KTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdGFyZWEgYXMgZDNBcmVhLFxuXHRsaW5lIGFzIGQzTGluZVxufSBmcm9tIFwiZDMtc2hhcGVcIjtcbmltcG9ydCB7XG5cdG1vdXNlIGFzIGQzTW91c2UsXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRSYW5kb20sIGlzQXJyYXksIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGlzVmFsdWV9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aW5pdExpbmUoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0c0ZvckxpbmUodGFyZ2V0cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0FyZWFzID0gJCQuY2xhc3NBcmVhcy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG5cblx0XHRjb25zdCBtYWluTGluZVVwZGF0ZSA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcblx0XHRcdC5kYXRhKHRhcmdldHMpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydExpbmUoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcblxuXHRcdGNvbnN0IG1haW5MaW5lRW50ZXIgPSBtYWluTGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXG5cdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxuXHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcblxuXHRcdC8vIEFyZWFzXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJlYXMpO1xuXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XG5cdFx0XHQvLyBDaXJjbGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgb24gbGluZXNcblx0XHRcdGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZXMsIGQuaWQpKTtcblxuXHRcdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxuXHRcdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBkYXRlIGZvciBzZWxlY3RlZCBjaXJjbGVzXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXG5cdFx0XHRcdC5zZWxlY3RBbGwoYCR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9YClcblx0XHRcdFx0LmVhY2goZCA9PiB7XG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uXG5cdFx0Ly8gbWFpbkxpbmVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbkxpbmUgPSAkJC5tYWluXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZX1gKVxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuXG5cdFx0JCQubWFpbkxpbmUuZXhpdCgpLnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluTGluZSA9ICQkLm1haW5MaW5lLmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7JCQuY2xhc3NMaW5lLmJpbmQoJCQpKGQpfSAkeyQkLmV4dHJhTGluZUNsYXNzZXMoZCkgfHwgXCJcIn1gKVxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxuXHRcdFx0Lm1lcmdlKCQkLm1haW5MaW5lKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcInNoYXBlLXJlbmRlcmluZ1wiLCBkID0+ICgkJC5pc1N0ZXBUeXBlKGQpID8gXCJjcmlzcEVkZ2VzXCIgOiBcIlwiKSlcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xuXHR9LFxuXG5cdHJlZHJhd0xpbmUoZHJhd0xpbmUsIHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRoaXMubWFpbkxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiB0aGlzLm1haW5MaW5lKVxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmNvbG9yKVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxuXHRcdF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VydmUgaW50ZXJwb2xhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldEN1cnZlKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNSb3RhdGVkU3RlcFR5cGUgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmICQkLmlzU3RlcFR5cGUoZCk7XG5cblx0XHQvLyB3aGVuIGlzIHN0ZXAgJiByb3RhdGVkLCBzaG91bGQgYmUgY29tcHV0ZWQgaW4gZGlmZmVyZW50IHdheVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxuXHRcdHJldHVybiBpc1JvdGF0ZWRTdGVwVHlwZSA/IGNvbnRleHQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RlcCA9ICQkLmdldEludGVycG9sYXRlKGQpKGNvbnRleHQpO1xuXG5cdFx0XHQvLyBrZWVwIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0XHRcdHN0ZXAub3JnUG9pbnQgPSBzdGVwLnBvaW50O1xuXG5cdFx0XHQvLyB0byBnZXQgcm90YXRlZCBwYXRoIGRhdGFcblx0XHRcdHN0ZXAucG9pbnRSb3RhdGVkID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMSAmJiAodGhpcy5fcG9pbnQgPSAyKTtcblxuXHRcdFx0XHRjb25zdCB5MSA9IHRoaXMuX3kgKiAoMSAtIHRoaXMuX3QpICsgeSAqIHRoaXMuX3Q7XG5cblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeTEpO1xuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5MSk7XG5cblx0XHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0fTtcblxuXHRcdFx0c3RlcC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDAgPyB0aGlzLm9yZ1BvaW50KHgsIHkpIDogdGhpcy5wb2ludFJvdGF0ZWQoeCwgeSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gc3RlcDtcblx0XHR9IDogJCQuZ2V0SW50ZXJwb2xhdGUoZCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVEcmF3TGluZShsaW5lSW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGxpbmVDb25uZWN0TnVsbCA9IGNvbmZpZy5saW5lX2Nvbm5lY3ROdWxsO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdGNvbnN0IHhWYWx1ZSA9IGQgPT4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XG5cdFx0Y29uc3QgeVZhbHVlID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcblx0XHRcdHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpXG5cdFx0KTtcblxuXHRcdGxldCBsaW5lID0gZDNMaW5lKCk7XG5cblx0XHRsaW5lID0gaXNSb3RhdGVkID9cblx0XHRcdGxpbmUueCh5VmFsdWUpLnkoeFZhbHVlKSA6IGxpbmUueCh4VmFsdWUpLnkoeVZhbHVlKTtcblxuXHRcdGlmICghbGluZUNvbm5lY3ROdWxsKSB7XG5cdFx0XHRsaW5lID0gbGluZS5kZWZpbmVkKGQgPT4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsKTtcblx0XHR9XG5cblx0XHRjb25zdCB4ID0gaXNTdWIgPyAkJC5zdWJYIDogJCQueDtcblxuXHRcdHJldHVybiBkID0+IHtcblx0XHRcdGNvbnN0IHkgPSB5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCk7XG5cdFx0XHRsZXQgdmFsdWVzID0gbGluZUNvbm5lY3ROdWxsID8gJCQuZmlsdGVyUmVtb3ZlTnVsbChkLnZhbHVlcykgOiBkLnZhbHVlcztcblx0XHRcdGxldCB4MCA9IDA7XG5cdFx0XHRsZXQgeTAgPSAwO1xuXHRcdFx0bGV0IHBhdGg7XG5cblx0XHRcdGlmICgkJC5pc0xpbmVUeXBlKGQpKSB7XG5cdFx0XHRcdGNvbnN0IHJlZ2lvbnMgPSBjb25maWcuZGF0YV9yZWdpb25zW2QuaWRdO1xuXG5cdFx0XHRcdGlmIChyZWdpb25zKSB7XG5cdFx0XHRcdFx0cGF0aCA9ICQkLmxpbmVXaXRoUmVnaW9ucyh2YWx1ZXMsIHgsIHksIHJlZ2lvbnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGF0aCA9IGxpbmUuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHR4MCA9IHgodmFsdWVzWzBdLngpO1xuXHRcdFx0XHRcdHkwID0geSh2YWx1ZXNbMF0udmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xuXHRcdH07XG5cdH0sXG5cblx0Z2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1YlZhbHVlKSB7IC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGxpbmVUYXJnZXRzTnVtID0gbGluZUluZGljZXMuX19tYXhfXyArIDE7XG5cdFx0Y29uc3QgaXNTdWIgPSAhIWlzU3ViVmFsdWU7XG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBsaW5lVGFyZ2V0c051bSwgbGluZUluZGljZXMsIGlzU3ViKTtcblx0XHRjb25zdCB5ID0gJCQuZ2V0U2hhcGVZKGlzU3ViKTtcblx0XHRjb25zdCBsaW5lT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNMaW5lVHlwZSwgbGluZUluZGljZXMsIGlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XG5cdFx0XHRjb25zdCBvZmZzZXQgPSBsaW5lT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxuXHRcdFx0Y29uc3QgcG9zWCA9IHgoZCk7XG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XG5cblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxuXHRcdFx0KSkge1xuXHRcdFx0XHRwb3NZID0geTA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgbGluZSBwb3NpdGlvblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnQsIC8vIGZyb20gaGVyZSBhbmQgYmVsb3csIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnRcblx0XHRcdF07XG5cdFx0fTtcblx0fSxcblxuXHRsaW5lV2l0aFJlZ2lvbnMoZCwgeCwgeSwgX3JlZ2lvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XG5cdFx0Y29uc3QgeE9mZnNldCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSA/IDAuNSA6IDA7XG5cdFx0Y29uc3QgcmVnaW9ucyA9IFtdO1xuXHRcdGNvbnN0IGRhc2hhcnJheSA9IFwiMiAyXCI7IC8vIGRlZmF1bHQgdmFsdWVcblxuXHRcdGxldCB4cDtcblx0XHRsZXQgeXA7XG5cdFx0bGV0IGRpZmY7XG5cdFx0bGV0IGRpZmZ4MjtcblxuXHRcdC8vIGNoZWNrIHdlYXRoZXIgZGF0YSBpcyB3aXRoaW4gcmVnaW9uXG5cdFx0Y29uc3QgaXNXaXRoaW5SZWdpb25zID0gKHdpdGhpblgsIHdpdGhpblJlZ2lvbnMpID0+IHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSB3aXRoaW5SZWdpb25zW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkge1xuXHRcdFx0XHRcdHJldHVybiByZWcuc3R5bGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBDaGVjayBzdGFydC9lbmQgb2YgcmVnaW9uc1xuXHRcdGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XG5cdFx0XHRjb25zdCBnZXRWYWx1ZSA9ICh2LCBkZWYpID0+IChcblx0XHRcdFx0aXNVbmRlZmluZWQodikgPyBkZWYgOiAoaXNUaW1lU2VyaWVzID8gJCQucGFyc2VEYXRlKHYpIDogdilcblx0XHRcdCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSBfcmVnaW9uc1tpXSk7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzdGFydCA9IGdldFZhbHVlKHJlZy5zdGFydCwgZFswXS54KTtcblx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0VmFsdWUocmVnLmVuZCwgZFtkLmxlbmd0aCAtIDFdLngpO1xuXHRcdFx0XHRjb25zdCBzdHlsZSA9IHJlZy5zdHlsZSB8fCB7ZGFzaGFycmF5fTtcblxuXHRcdFx0XHRyZWdpb25zW2ldID0ge3N0YXJ0LCBlbmQsIHN0eWxlfTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgc2NhbGVzXG5cdFx0Y29uc3QgeFZhbHVlID0gaXNSb3RhdGVkID8gZHQgPT4geShkdC52YWx1ZSkgOiBkdCA9PiB4KGR0LngpO1xuXHRcdGNvbnN0IHlWYWx1ZSA9IGlzUm90YXRlZCA/IGR0ID0+IHgoZHQueCkgOiBkdCA9PiB5KGR0LnZhbHVlKTtcblxuXHRcdC8vIERlZmluZSBzdmcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGZvciByZWdpb25cblx0XHRjb25zdCBnZW5lcmF0ZU0gPSBwb2ludHMgPT4gYE0ke3BvaW50c1swXVswXX0sJHtwb2ludHNbMF1bMV19TCR7cG9pbnRzWzFdWzBdfSwke3BvaW50c1sxXVsxXX1gO1xuXG5cdFx0Y29uc3Qgc1dpdGhSZWdpb24gPSBpc1RpbWVTZXJpZXMgPyAoZDAsIGQxLCBrLCB0aW1lc2VyaWVzRGlmZikgPT4ge1xuXHRcdFx0Y29uc3QgeDAgPSBkMC54LmdldFRpbWUoKTtcblx0XHRcdGNvbnN0IHhEaWZmID0gZDEueCAtIGQwLng7XG5cdFx0XHRjb25zdCB4djAgPSBuZXcgRGF0ZSh4MCArIHhEaWZmICogayk7XG5cdFx0XHRjb25zdCB4djEgPSBuZXcgRGF0ZSh4MCArIHhEaWZmICogKGsgKyB0aW1lc2VyaWVzRGlmZikpO1xuXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xuXHRcdFx0XHRbW3koeXAoaykpLCB4KHh2MCldLCBbeSh5cChrICsgZGlmZikpLCB4KHh2MSldXSA6XG5cdFx0XHRcdFtbeCh4djApLCB5KHlwKGspKV0sIFt4KHh2MSksIHkoeXAoayArIGRpZmYpKV1dO1xuXG5cdFx0XHRyZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XG5cdFx0fSA6IChkMCwgZDEsIGssIG90aGVyRGlmZikgPT4ge1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gaXNSb3RhdGVkID9cblx0XHRcdFx0W1t5KHlwKGspLCB0cnVlKSwgeCh4cChrKSldLCBbeSh5cChrICsgb3RoZXJEaWZmKSwgdHJ1ZSksIHgoeHAoayArIG90aGVyRGlmZikpXV0gOlxuXHRcdFx0XHRbW3goeHAoayksIHRydWUpLCB5KHlwKGspKV0sIFt4KHhwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeSh5cChrICsgb3RoZXJEaWZmKSldXTtcblxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xuXHRcdH07XG5cblx0XHQvLyBHZW5lcmF0ZVxuXHRcdGxldCBwYXRoID0gXCJNXCI7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgZGF0YTsgKGRhdGEgPSBkW2ldKTsgaSsrKSB7XG5cdFx0XHRjb25zdCBwcmV2RGF0YSA9IGRbaSAtIDFdO1xuXHRcdFx0bGV0IHN0eWxlID0gaXNXaXRoaW5SZWdpb25zKGRhdGEueCwgcmVnaW9ucyk7XG5cblx0XHRcdC8vIERyYXcgYXMgbm9ybWFsXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQocmVnaW9ucykgfHwgIXN0eWxlKSB7XG5cdFx0XHRcdHBhdGggKz0gYCR7aSA/IFwiTFwiIDogXCJcIn0ke3hWYWx1ZShkYXRhKX0sJHt5VmFsdWUoZGF0YSl9YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c3R5bGUgPSBzdHlsZS5kYXNoYXJyYXkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0c3R5bGUgPSBkYXNoYXJyYXkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRHJhdyB3aXRoIHJlZ2lvbiAvLyBUT0RPOiBGaXggZm9yIGhvcml6b3RhbCBjaGFydHNcblx0XHRcdFx0eHAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS54ICsgeE9mZnNldCwgZGF0YS54ICsgeE9mZnNldCwgaXNUaW1lU2VyaWVzKTtcblx0XHRcdFx0eXAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS52YWx1ZSwgZGF0YS52YWx1ZSk7XG5cblx0XHRcdFx0Y29uc3QgZHggPSB4KGRhdGEueCkgLSB4KHByZXZEYXRhLngpO1xuXHRcdFx0XHRjb25zdCBkeSA9IHkoZGF0YS52YWx1ZSkgLSB5KHByZXZEYXRhLnZhbHVlKTtcblx0XHRcdFx0Y29uc3QgZGQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcblxuXHRcdFx0XHRkaWZmID0gc3R5bGVbMF0gLyBkZDtcblx0XHRcdFx0ZGlmZngyID0gZGlmZiAqIHN0eWxlWzFdO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSBkaWZmOyBqIDw9IDE7IGogKz0gZGlmZngyKSB7XG5cdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgaiwgZGlmZik7XG5cblx0XHRcdFx0XHQvLyB0byBtYWtlIHN1cmUgY29ycmVjdCBsaW5lIGRyYXdpbmdcblx0XHRcdFx0XHRpZiAoaiArIGRpZmZ4MiA+PSAxKSB7XG5cdFx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCAxLCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHR1cGRhdGVBcmVhR3JhZGllbnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XG5cdFx0XHRjb25zdCBpZCA9IGAkeyQkLmRhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YDtcblxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkgJiYgJCQuZGVmcy5zZWxlY3QoYCMke2lkfWApLmVtcHR5KCkpIHtcblx0XHRcdFx0Y29uc3QgY29sb3IgPSAkJC5jb2xvcihkKTtcblx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdHggPSBbMCwgMF0sXG5cdFx0XHRcdFx0eSA9IFswLCAxXSxcblx0XHRcdFx0XHRzdG9wcyA9IFtbMCwgY29sb3IsIDFdLCBbMSwgY29sb3IsIDBdXVxuXHRcdFx0XHR9ID0gJCQuY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQ7XG5cblx0XHRcdFx0Y29uc3QgbGluZWFyR3JhZGllbnQgPSAkJC5kZWZzLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBgJHtpZH1gKVxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgeFswXSlcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHhbMV0pXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5WzBdKVxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgeVsxXSk7XG5cblx0XHRcdFx0c3RvcHMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRjb25zdCBzdG9wQ29sb3IgPSBpc0Z1bmN0aW9uKHZbMV0pID8gdlsxXShkLmlkKSA6IHZbMV07XG5cblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudC5hcHBlbmQoXCJzdG9wXCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcIm9mZnNldFwiLCB2WzBdKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLWNvbG9yXCIsIHN0b3BDb2xvciB8fCBjb2xvcilcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIHZbMl0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVBcmVhQ29sb3IoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XG5cdFx0XHRgdXJsKCMkeyQkLmRhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9KWAgOlxuXHRcdFx0JCQuY29sb3IoZCk7XG5cdH0sXG5cblx0dXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCAmJiAkJC51cGRhdGVBcmVhR3JhZGllbnQoKTtcblxuXHRcdCQkLm1haW5BcmVhID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWFzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG5cblx0XHQkJC5tYWluQXJlYS5leGl0KCkudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW5BcmVhID0gJCQubWFpbkFyZWEuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlQXJlYUNvbG9yLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCQub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XG5cdFx0XHRcdHJldHVybiBcIjBcIjtcblx0XHRcdH0pXG5cdFx0XHQubWVyZ2UoJCQubWFpbkFyZWEpO1xuXG5cdFx0JCQubWFpbkFyZWFcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQub3JnQXJlYU9wYWNpdHkpO1xuXHR9LFxuXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLm1haW5BcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogJCQubWFpbkFyZWEpXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QXJlYSlcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiAoJCQuaXNBcmVhUmFuZ2VUeXBlKGQpID8gJCQub3JnQXJlYU9wYWNpdHkgLyAxLjc1IDogJCQub3JnQXJlYU9wYWNpdHkpKVxuXHRcdF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXG5cdCAqIEBwYXJhbSBhcmVhSW5kaWNlc1xuXHQgKiBAcGFyYW0gaXNTdWJcblx0ICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiAoKnxzdHJpbmcpfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWIpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGxpbmVDb25uZWN0TnVsbCA9IGNvbmZpZy5saW5lX2Nvbm5lY3ROdWxsO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdGNvbnN0IHhWYWx1ZSA9IGQgPT4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcblx0XHRcdHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKShcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwiaGlnaFwiKSA6IDBcblx0XHRcdCkpO1xuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cblx0XHRcdGdldFBvaW50cyhkLCBpKVsxXVsxXSA6XG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XG5cdFx0XHRcdFx0JCQuZ2V0QXJlYVJhbmdlRGF0YShkLCBcImxvd1wiKSA6IGQudmFsdWVcblx0XHRcdCkpO1xuXG5cdFx0cmV0dXJuIGQgPT4ge1xuXHRcdFx0bGV0IHZhbHVlcyA9IGxpbmVDb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXM7XG5cdFx0XHRsZXQgeDAgPSAwO1xuXHRcdFx0bGV0IHkwID0gMDtcblx0XHRcdGxldCBwYXRoO1xuXG5cdFx0XHRpZiAoJCQuaXNBcmVhVHlwZShkKSkge1xuXHRcdFx0XHRsZXQgYXJlYSA9IGQzQXJlYSgpO1xuXG5cdFx0XHRcdGFyZWEgPSBpc1JvdGF0ZWQgP1xuXHRcdFx0XHRcdGFyZWEueSh4VmFsdWUpXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxuXHRcdFx0XHRcdFx0LngxKHZhbHVlMSkgOlxuXHRcdFx0XHRcdGFyZWEueCh4VmFsdWUpXG5cdFx0XHRcdFx0XHQueTAoY29uZmlnLmFyZWFfYWJvdmUgPyAwIDogdmFsdWUwKVxuXHRcdFx0XHRcdFx0LnkxKHZhbHVlMSk7XG5cblx0XHRcdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcblx0XHRcdFx0XHRhcmVhID0gYXJlYS5kZWZpbmVkKGQgPT4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0eDAgPSAkJC54KHZhbHVlc1swXS54KTtcblx0XHRcdFx0XHR5MCA9ICQkLmdldFlTY2FsZShkLmlkKSh2YWx1ZXNbMF0udmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xuXHRcdH07XG5cdH0sXG5cblx0Z2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yikge1xuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGFyZWFUYXJnZXRzTnVtID0gYXJlYUluZGljZXMuX19tYXhfXyArIDE7XG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBhcmVhVGFyZ2V0c051bSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XG5cdFx0Y29uc3QgYXJlYU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQXJlYVR5cGUsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgwKTtcblx0XHRcdGNvbnN0IG9mZnNldCA9IGFyZWFPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcblx0XHRcdGxldCBwb3NZID0geShkKTtcblxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXG5cdFx0XHQpKSB7XG5cdFx0XHRcdHBvc1kgPSB5MDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBhcmVhIHBvc2l0aW9uXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSxcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdFx0XTtcblx0XHR9O1xuXHR9LFxuXG5cdHVwZGF0ZUNpcmNsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoISQkLmNvbmZpZy5wb2ludF9zaG93KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQubWFpbkNpcmNsZSA9ICQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfWApXG5cdFx0XHQuZGF0YShkID0+ICEkJC5pc0JhclR5cGUoZCkgJiYgKCEkJC5pc0xpbmVUeXBlKGQpIHx8ICQkLnNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpKSAmJlxuXHRcdFx0XHQkJC5sYWJlbGlzaERhdGEoZCkpO1xuXG5cdFx0JCQubWFpbkNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluQ2lyY2xlID0gJCQubWFpbkNpcmNsZS5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKCQkLnBvaW50KFwiY3JlYXRlXCIsIHRoaXMsICQkLmNsYXNzQ2lyY2xlLmJpbmQoJCQpLCAkJC5wb2ludFIuYmluZCgkJCksICQkLmNvbG9yKSlcblx0XHRcdC5tZXJnZSgkJC5tYWluQ2lyY2xlKVxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKSk7XG5cdH0sXG5cblx0cmVkcmF3Q2lyY2xlKGN4LCBjeSwgd2l0aFRyYW5zaXRpb24sIGZsb3cpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRDaXJjbGVzID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApO1xuXG5cdFx0aWYgKCEkJC5jb25maWcucG9pbnRfc2hvdykge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1haW5DaXJjbGVzID0gW107XG5cblx0XHQkJC5tYWluQ2lyY2xlLmVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0Y29uc3QgZm4gPSAkJC5wb2ludChcInVwZGF0ZVwiLCAkJCwgY3gsIGN5LCAkJC5vcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpLCAkJC5jb2xvciwgd2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykuYmluZCh0aGlzKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKGQpO1xuXG5cdFx0XHRtYWluQ2lyY2xlcy5wdXNoKHJlc3VsdCk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBwb3NBdHRyID0gJCQuaXNDaXJjbGVQb2ludCgpID8gXCJjXCIgOiBcIlwiO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdG1haW5DaXJjbGVzLFxuXHRcdFx0c2VsZWN0ZWRDaXJjbGVzXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eGAsIGN4KVxuXHRcdFx0XHQuYXR0cihgJHtwb3NBdHRyfXlgLCBjeSlcblx0XHRdO1xuXHR9LFxuXG5cdGNpcmNsZVgoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBoYXNWYWx1ZSA9IGlzVmFsdWUoZC54KTtcblxuXHRcdHJldHVybiAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLnpvb21TY2FsZSA/XG5cdFx0XHQoaGFzVmFsdWUgPyAkJC56b29tU2NhbGUoZC54KSA6IG51bGwpIDpcblx0XHRcdChoYXNWYWx1ZSA/ICQkLngoZC54KSA6IG51bGwpO1xuXHR9LFxuXG5cdHVwZGF0ZUNpcmNsZVkoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY2lyY2xlWSA9IChkLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBpZCA9IGQuaWQ7XG5cblx0XHRcdHJldHVybiAkJC5pc0dyb3VwZWQoaWQpID9cblx0XHRcdFx0JCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKCQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSkoZCwgaSlbMF1bMV0gOlxuXHRcdFx0XHQkJC5nZXRZU2NhbGUoaWQpKCQkLmdldEJhc2VWYWx1ZShkKSk7XG5cdFx0fTtcblx0fSxcblxuXHRnZXRDaXJjbGVzKGksIGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHN1ZmZpeCA9IChpc1ZhbHVlKGkpID8gYC0ke2l9YCA6IGBgKTtcblxuXHRcdHJldHVybiAoaWQgPyAkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKSA6ICQkLm1haW4pXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9JHtzdWZmaXh9YCk7XG5cdH0sXG5cblx0ZXhwYW5kQ2lyY2xlcyhpLCBpZCwgcmVzZXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgciA9ICQkLnBvaW50RXhwYW5kZWRSLmJpbmQoJCQpO1xuXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRDaXJjbGVzKCk7XG5cblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XG5cdFx0Y29uc3Qgc2NhbGUgPSByKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3I7XG5cdFx0Y29uc3QgcmF0aW8gPSAxIC0gc2NhbGU7XG5cblx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XG5cdFx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB0cmFuc2Zvcm0gbXVzdCBiZSBhcHBsaWVkIHRvIGVhY2ggbm9kZSBpbmRpdmlkdWFsbHlcblx0XHRcdGNpcmNsZXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBkM1NlbGVjdCh0aGlzKTtcblxuXHRcdFx0XHRpZiAodGhpcy50YWdOYW1lID09PSBcImNpcmNsZVwiKSB7XG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInJcIiwgcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5nZXRCQm94KCk7XG5cdFx0XHRcdFx0Y29uc3QgeCA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieFwiKSArIHdpZHRoIC8gMik7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieVwiKSArIGhlaWdodCAvIDIpO1xuXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0gJHt5fSkgc2NhbGUoJHtzY2FsZX0pYCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHR1bmV4cGFuZENpcmNsZXMoaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCByID0gJCQucG9pbnRSLmJpbmQoJCQpO1xuXG5cdFx0Y29uc3QgY2lyY2xlcyA9ICQkLmdldENpcmNsZXMoaSlcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVEKTtcblx0XHRcdH0pXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xuXG5cdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcblxuXHRcdCEkJC5pc0NpcmNsZVBvaW50KCkgJiZcblx0XHRcdGNpcmNsZXMuYXR0cihcInRyYW5zZm9ybVwiLCBgc2NhbGUoJHtyKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3J9KWApO1xuXHR9LFxuXG5cdHBvaW50UihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBwb2ludFIgPSBjb25maWcucG9pbnRfcjtcblx0XHRsZXQgciA9IHBvaW50UjtcblxuXHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XG5cdFx0XHRyID0gMDtcblx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xuXHRcdFx0ciA9ICQkLmdldEJ1YmJsZVIoZCk7XG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBvaW50UikpIHtcblx0XHRcdHIgPSBwb2ludFIoZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHI7XG5cdH0sXG5cblx0cG9pbnRFeHBhbmRlZFIoZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgc2NhbGUgPSAkJC5pc0J1YmJsZVR5cGUoZCkgPyAxLjE1IDogMS43NTtcblxuXHRcdHJldHVybiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgP1xuXHRcdFx0KGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfciB8fCAkJC5wb2ludFIoZCkgKiBzY2FsZSkgOiAkJC5wb2ludFIoZCk7XG5cdH0sXG5cblx0cG9pbnRTZWxlY3RSKGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgc2VsZWN0UiA9ICQkLmNvbmZpZy5wb2ludF9zZWxlY3RfcjtcblxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKHNlbGVjdFIpID9cblx0XHRcdHNlbGVjdFIoZCkgOiAoc2VsZWN0UiB8fCAkJC5wb2ludFIoZCkgKiA0KTtcblx0fSxcblxuXHRpc1dpdGhpbkNpcmNsZShub2RlLCByKSB7XG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKG5vZGUpO1xuXHRcdGNvbnN0IGVsZW1lbnQgPSBkM1NlbGVjdChub2RlKTtcblx0XHRjb25zdCBwcmVmaXggPSB0aGlzLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcblxuXHRcdGxldCBjeCA9ICtlbGVtZW50LmF0dHIoYCR7cHJlZml4fXhgKTtcblx0XHRsZXQgY3kgPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH15YCk7XG5cblx0XHQvLyBpZiBub2RlIGRvbid0IGhhdmUgY3gveSBvciB4L3kgYXR0cmlidXRlIHZhbHVlXG5cdFx0aWYgKCEoY3ggfHwgY3kpICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdGNvbnN0IHt4LCB5fSA9IG5vZGUuZ2V0QkJveCA/IG5vZGUuZ2V0QkJveCgpIDogbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0Y3ggPSB4O1xuXHRcdFx0Y3kgPSB5O1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzID0gTWF0aC5zcXJ0KFxuXHRcdFx0TWF0aC5wb3coY3ggLSBtb3VzZVswXSwgMikgKyBNYXRoLnBvdyhjeSAtIG1vdXNlWzFdLCAyKVxuXHRcdCkgPCAociB8fCB0aGlzLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSk7XG5cblx0XHRyZXR1cm4gaXM7XG5cdH0sXG5cblx0aXNXaXRoaW5TdGVwKHRoYXQsIHkpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoeSAtIGQzTW91c2UodGhhdClbMV0pIDwgMzA7XG5cdH0sXG5cblx0c2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCkge1xuXHRcdGNvbnN0IGxpbmVQb2ludCA9IHRoaXMuY29uZmlnLmxpbmVfcG9pbnQ7XG5cblx0XHRyZXR1cm4gbGluZVBvaW50ID09PSB0cnVlIHx8XG5cdFx0XHQoaXNBcnJheShsaW5lUG9pbnQpICYmIGxpbmVQb2ludC5pbmRleE9mKGQuaWQpICE9PSAtMSk7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzLFxuXHRzZWxlY3QgYXMgZDNTZWxlY3Rcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vaW50ZXJuYWxzL2Jyb3dzZXJcIjtcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0Z1bmN0aW9uLCBpc09iamVjdFR5cGUsIHRvQXJyYXksIGV4dGVuZCwgbm90RW1wdHl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aGFzVmFsaWRQb2ludFR5cGUodHlwZSkge1xuXHRcdHJldHVybiAvXihjaXJjbGV8cmVjdChhbmdsZSk/fHBvbHlnb258ZWxsaXBzZXx1c2UpJC9pLnRlc3QodHlwZSB8fCB0aGlzLmNvbmZpZy5wb2ludF90eXBlKTtcblx0fSxcblxuXHRoYXNWYWxpZFBvaW50RHJhd01ldGhvZHModHlwZSkge1xuXHRcdGNvbnN0IHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcblxuXHRcdHJldHVybiBpc09iamVjdFR5cGUocG9pbnRUeXBlKSAmJlxuXHRcdFx0aXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xuXHR9LFxuXG5cdGluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvcHlBdHRyID0gKGZyb20sIHRhcmdldCkgPT4ge1xuXHRcdFx0Y29uc3QgYXR0cmlicyA9IGZyb20uYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG5hbWU7IChuYW1lID0gYXR0cmlic1tpXSk7IGkrKykge1xuXHRcdFx0XHRuYW1lID0gbmFtZS5uYW1lO1xuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhwb2ludCwgXCJpbWFnZS9zdmcreG1sXCIpO1xuXHRcdGNvbnN0IG5vZGUgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG5cblx0XHRjbG9uZS5pZCA9IGlkO1xuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcblx0XHRjbG9uZS5zdHlsZS5zdHJva2UgPSBcImluaGVyaXRcIjtcblxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcblxuXHRcdGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xuXG5cdFx0XHRpZiAoXCJpbm5lckhUTUxcIiBpbiBjbG9uZSkge1xuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b0FycmF5KG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JCQuZGVmcy5ub2RlKCkuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXHR9LFxuXG5cdHBvaW50RnJvbURlZnMoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5kZWZzLnNlbGVjdChgIyR7aWR9YCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVQb2ludCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlkcyA9IFtdO1xuXHRcdGNvbnN0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcucG9pbnRfcGF0dGVybikgPyBjb25maWcucG9pbnRfcGF0dGVybiA6IFtjb25maWcucG9pbnRfdHlwZV07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCAuLi5hcmdzKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0bGV0IHBvaW50O1xuXG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XG5cdFx0XHRcdFx0aWRzLnB1c2goaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50ID0gcGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XG5cblx0XHRcdFx0aWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkge1xuXHRcdFx0XHRcdHBvaW50ID0gJCRbcG9pbnRdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCEkJC5oYXNWYWxpZFBvaW50RHJhd01ldGhvZHMocG9pbnQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRJZCA9IGAkeyQkLmRhdGV0aW1lSWR9LXBvaW50LSR7aWR9YDtcblx0XHRcdFx0XHRjb25zdCBwb2ludEZyb21EZWZzID0gJCQucG9pbnRGcm9tRGVmcyhwb2ludElkKTtcblxuXHRcdFx0XHRcdGlmIChwb2ludEZyb21EZWZzLnNpemUoKSA8IDEpIHtcblx0XHRcdFx0XHRcdCQkLmluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIHBvaW50SWQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtZXRob2QgPT09IFwiY3JlYXRlXCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkJC5jdXN0b20uY3JlYXRlLmJpbmQoY29udGV4dCkoZWxlbWVudCwgcG9pbnRJZCwgLi4uYXJncyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtZXRob2QgPT09IFwidXBkYXRlXCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkJC5jdXN0b20udXBkYXRlLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHBvaW50W21ldGhvZF0uYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSxcblxuXHRnZXRUcmFuc2l0aW9uTmFtZSgpIHtcblx0XHRyZXR1cm4gZ2V0UmFuZG9tKCk7XG5cdH0sXG5cblx0Y3VzdG9tOiB7XG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGlkLCBjc3NDbGFzc0ZuLCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJ1c2VcIilcblx0XHRcdFx0LmF0dHIoXCJ4bGluazpocmVmXCIsIGAjJHtpZH1gKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNzc0NsYXNzRm4pXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXG5cdFx0XHRcdC5ub2RlKCk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpO1xuXG5cdFx0XHRjb25zdCB4UG9zRm4yID0gZCA9PiB4UG9zRm4oZCkgLSB3aWR0aCAvIDI7XG5cdFx0XHRjb25zdCB5UG9zRm4yID0gZCA9PiB5UG9zRm4oZCkgLSBoZWlnaHQgLyAyO1xuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcblxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcblxuXHRcdFx0XHRpZiAoZmxvdykge1xuXHRcdFx0XHRcdG1haW5DaXJjbGVzID0gZWxlbWVudFxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhQb3NGbjIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBlbGVtZW50XG5cdFx0XHRcdFx0LnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhQb3NGbjIpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlQb3NGbjIpXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xuXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKCQkLmdldFRyYW5zaXRpb25OYW1lKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBlbGVtZW50XG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhQb3NGbjIpXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlQb3NGbjIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICdjaXJjbGUnIGRhdGEgcG9pbnRcblx0Y2lyY2xlOiB7XG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGNzc0NsYXNzRm4sIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcImNpcmNsZVwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNzc0NsYXNzRm4pXG5cdFx0XHRcdC5hdHRyKFwiclwiLCBzaXplRm4pXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXG5cdFx0XHRcdC5ub2RlKCk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcblxuXHRcdFx0Ly8gd2hlbiAnLmxvYWQoKScgY2FsbGVkLCBidWJibGUgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZFxuXHRcdFx0aWYgKCQkLmhhc1R5cGUoXCJidWJibGVcIikpIHtcblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlc1xuXHRcdFx0XHRcdC5hdHRyKFwiclwiLCAkJC5wb2ludFIuYmluZCgkJCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuXG5cdFx0XHRcdGlmIChmbG93KSB7XG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlc1xuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCB4UG9zRm4pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBlbGVtZW50LmF0dHIoXCJjeFwiKSA/XG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSlcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgeFBvc0ZuKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeVwiLCB5UG9zRm4pXG5cdFx0XHRcdFx0XHQudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSkgOlxuXHRcdFx0XHRcdG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiLCB4UG9zRm4pXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbik7XG5cblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzXG5cdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCB4UG9zRm4pXG5cdFx0XHRcdFx0LmF0dHIoXCJjeVwiLCB5UG9zRm4pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICdyZWN0YW5nbGUnIGRhdGEgcG9pbnRcblx0cmVjdGFuZ2xlOiB7XG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGNzc0NsYXNzRm4sIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcblx0XHRcdGNvbnN0IHJlY3RTaXplRm4gPSBkID0+IHNpemVGbihkKSAqIDIuMDtcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNzc0NsYXNzRm4pXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgcmVjdFNpemVGbilcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgcmVjdFNpemVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbilcblx0XHRcdFx0Lm5vZGUoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0XHRjb25zdCByID0gJCQuY29uZmlnLnBvaW50X3I7XG5cdFx0XHRjb25zdCByZWN0WFBvc0ZuID0gZCA9PiB4UG9zRm4oZCkgLSByO1xuXHRcdFx0Y29uc3QgcmVjdFlQb3NGbiA9IGQgPT4geVBvc0ZuKGQpIC0gcjtcblxuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcblxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcblxuXHRcdFx0XHRpZiAoZmxvdykge1xuXHRcdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXNcblx0XHRcdFx0XHRcdC5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXNcblx0XHRcdFx0XHQudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSlcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgcmVjdFhQb3NGbilcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbilcblx0XHRcdFx0XHQudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XG5cblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHJlY3RZUG9zRm4pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0ZXZlbnQgYXMgZDNFdmVudFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBnZXRNaW5NYXgsIGdldFJhbmdlLCBpc0RlZmluZWQsIGlzRW1wdHksIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlLCB0b0FycmF5fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xvY2t3aXNlIElmIHRoZSBkaXJlY3Rpb24gaXMgY2xvY2t3aXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb29yZGluYXRlIHR5cGUgJ3gnIG9yICd5J1xuICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2UgTnVtYmVyIG9mIGVkZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgVGhlIGluZGV4ZWQgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZSwgdHlwZSwgZWRnZSwgcG9zLCByYW5nZSwgcmF0aW8pIHtcblx0Y29uc3QgaW5kZXggPSBpc0Nsb2Nrd2lzZSAmJiBwb3MgPiAwID8gZWRnZSAtIHBvcyA6IHBvcztcblx0Y29uc3QgciA9IDIgKiBNYXRoLlBJO1xuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xuXG5cdHJldHVybiByYW5nZSAqICgxIC0gcmF0aW8gKiBmdW5jKGluZGV4ICogciAvIGVkZ2UpKTtcbn1cblxuLy8gY2FjaGUga2V5XG5jb25zdCBjYWNoZUtleSA9IFwiJHJhZGFyUG9pbnRzXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UmFkYXIoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcblx0XHRcdCQkLnJhZGFycyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRSYWRhcnMpO1xuXG5cdFx0XHQvLyBsZXZlbFxuXHRcdFx0JCQucmFkYXJzLmxldmVscyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGV2ZWxzKTtcblxuXHRcdFx0Ly8gYXhpc1xuXHRcdFx0JCQucmFkYXJzLmF4ZXMgPSAkJC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXMpO1xuXG5cdFx0XHQvLyBzaGFwZXNcblx0XHRcdCQkLnJhZGFycy5zaGFwZXMgPSAkJC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnNoYXBlcyk7XG5cblx0XHRcdCQkLm1heFZhbHVlID0gY29uZmlnLnJhZGFyX2F4aXNfbWF4IHx8ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFJhZGFyU2l6ZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGggPCA0ID8gLTIwIDogMTA7XG5cdFx0Y29uc3Qgc2l6ZSA9IChNYXRoLm1pbigkJC5hcmNXaWR0aCwgJCQuYXJjSGVpZ2h0KSAtIHBhZGRpbmcpIC8gMjtcblxuXHRcdHJldHVybiBbc2l6ZSwgc2l6ZV07XG5cdH0sXG5cblx0dXBkYXRlVGFyZ2V0c0ZvclJhZGFyKHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzKSkge1xuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gZ2V0UmFuZ2UoMCwgZ2V0TWluTWF4KFwibWF4XCIsIHRhcmdldHMubWFwKHYgPT4gdi52YWx1ZXMubGVuZ3RoKSkpO1xuXHRcdH1cblxuXHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcblx0fSxcblxuXHRnZXRSYWRhclBvc2l0aW9uKHR5cGUsIGluZGV4LCByYW5nZSwgcmF0aW8pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XG5cblx0XHRjb25zdCBwb3MgPSB0b0FycmF5KHR5cGUpLm1hcCh2ID0+IGdldFBvc2l0aW9uKFxuXHRcdFx0aXNDbG9ja3dpc2UsXG5cdFx0XHR2LFxuXHRcdFx0ZWRnZSxcblx0XHRcdGluZGV4LFxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlKSA/IHJhbmdlIDogKHR5cGUgPT09IFwieFwiID8gd2lkdGggOiBoZWlnaHQpLFxuXHRcdFx0aXNOdW1iZXIocmF0aW8pID8gcmF0aW8gOiBjb25maWcucmFkYXJfc2l6ZV9yYXRpb1xuXHRcdCkpO1xuXG5cdFx0cmV0dXJuIHBvcy5sZW5ndGggPT09IDEgPyBwb3NbMF0gOiBwb3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xuXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuZ2V0Q2FjaGUoY2FjaGVLZXkpIHx8IHt9O1xuXHRcdGNvbnN0IHNpemUgPSBwb2ludHMuX3NpemU7XG5cblx0XHQvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvbmx5IHdoZW4gdGhlIHByZXZpb3VzIGRpbWVuc2lvbiBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0aWYgKCFzaXplIHx8IChzaXplLndpZHRoICE9PSB3aWR0aCAmJiBzaXplLmhlaWdodCAhPT0gaGVpZ2h0KSkge1xuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xuXHRcdFx0XHRwb2ludHNbZC5pZF0gPSBkLnZhbHVlcy5tYXAoKHYsIGkpID0+IChcblx0XHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCB1bmRlZmluZWQsICQkLmdldFJhdGlvKFwicmFkYXJcIiwgdikpXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCBwb2ludHMpO1xuXHRcdH1cblx0fSxcblxuXHRyZWRyYXdSYWRhcihkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9ICQkLmdldFRyYW5zbGF0ZShcInJhZGFyXCIpO1xuXG5cdFx0Ly8gQWRqdXN0IHJhZGFyLCBjaXJjbGVzIGFuZCB0ZXh0cycgcG9zaXRpb25cblx0XHRpZiAodHJhbnNsYXRlKSB7XG5cdFx0XHQkJC5yYWRhcnMuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXHRcdFx0JCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXHRcdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xuXG5cdFx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XG5cdFx0XHQkJC51cGRhdGVSYWRhckxldmVsKCk7XG5cdFx0XHQkJC51cGRhdGVSYWRhckF4ZXMoKTtcblx0XHRcdCQkLnVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdlbmVyYXRlR2V0UmFkYXJQb2ludHMoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmdldENhY2hlKGNhY2hlS2V5KTtcblxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbZC5pZF1baV07XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50XG5cdFx0XHRdO1xuXHRcdH07XG5cdH0sXG5cblx0dXBkYXRlUmFkYXJMZXZlbCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGRlcHRoID0gY29uZmlnLnJhZGFyX2xldmVsX2RlcHRoO1xuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xuXHRcdGNvbnN0IHNob3dUZXh0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfc2hvdztcblxuXHRcdGNvbnN0IHJhZGFyTGV2ZWxzID0gJCQucmFkYXJzLmxldmVscztcblx0XHRjb25zdCBsZXZlbERhdGEgPSBnZXRSYW5nZSgwLCBkZXB0aCk7XG5cblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucmFkYXJfc2l6ZV9yYXRpbyAqIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuXHRcdGNvbnN0IGxldmVsUmF0aW8gPSBsZXZlbERhdGEubWFwKGwgPT4gcmFkaXVzICogKChsICsgMSkgLyBkZXB0aCkpO1xuXHRcdGNvbnN0IGxldmVsVGV4dEZvcm1hdCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdDtcblxuXHRcdC8vIEdlbmVyYXRlIHBvaW50c1xuXHRcdGNvbnN0IHBvaW50cyA9IGxldmVsRGF0YS5tYXAodiA9PiB7XG5cdFx0XHRjb25zdCByYW5nZSA9IGxldmVsUmF0aW9bdl07XG5cdFx0XHRjb25zdCBwb3MgPSBnZXRSYW5nZSgwLCBlZGdlKS5tYXAoaSA9PiAoXG5cdFx0XHRcdCQkLmdldFJhZGFyUG9zaXRpb24oW1wieFwiLCBcInlcIl0sIGksIHJhbmdlLCAxKSkuam9pbihcIixcIilcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiBwb3Muam9pbihcIiBcIik7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBsZXZlbCA9IHJhZGFyTGV2ZWxzXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZXZlbH1gKVxuXHRcdFx0LmRhdGEobGV2ZWxEYXRhKTtcblxuXHRcdGxldmVsLmV4aXQoKS5yZW1vdmUoKTtcblxuXHRcdGNvbnN0IGxldmVsRW50ZXIgPSBsZXZlbC5lbnRlcigpLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmxldmVsfSAke0NMQVNTLmxldmVsfS0ke2l9YCk7XG5cblx0XHRsZXZlbEVudGVyLmFwcGVuZChcInBvbHlnb25cIilcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIik7XG5cblx0XHRpZiAoc2hvd1RleHQpIHtcblx0XHRcdGlmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkpIHtcblx0XHRcdFx0cmFkYXJMZXZlbHNcblx0XHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItLjdlbVwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gbGV2ZWxUZXh0Rm9ybWF0KDApKTtcblx0XHRcdH1cblxuXHRcdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXHRcdFx0XHQudGV4dChkID0+IGxldmVsVGV4dEZvcm1hdChcblx0XHRcdFx0XHQkJC5tYXhWYWx1ZSAvIGxldmVsRGF0YS5sZW5ndGggKiAoZCArIDEpXG5cdFx0XHRcdCkpO1xuXHRcdH1cblxuXHRcdGxldmVsRW50ZXJcblx0XHRcdC5tZXJnZShsZXZlbClcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke3dpZHRoIC0gbGV2ZWxSYXRpb1tkXX0sICR7aGVpZ2h0IC0gbGV2ZWxSYXRpb1tkXX0pYClcblx0XHRcdC5zZWxlY3RBbGwoXCJwb2x5Z29uXCIpXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkXSk7XG5cblx0XHQvLyB1cGRhdGUgbGV2ZWwgdGV4dCBwb3NpdGlvblxuXHRcdGlmIChzaG93VGV4dCkge1xuXHRcdFx0cmFkYXJMZXZlbHMuc2VsZWN0QWxsKFwidGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcInhcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyB3aWR0aCA6IHBvaW50c1tkXS5zcGxpdChcIixcIilbMF0pKVxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyBoZWlnaHQgOiAwKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZVJhZGFyQXhlcygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xuXHRcdGNvbnN0IGNhdGVnb3JpZXMgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XG5cblx0XHRsZXQgYXhpcyA9ICQkLnJhZGFycy5heGVzLnNlbGVjdEFsbChcImdcIilcblx0XHRcdC5kYXRhKGNhdGVnb3JpZXMpO1xuXG5cdFx0YXhpcy5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRjb25zdCBheGlzRW50ZXIgPSBheGlzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuYXhpc30tJHtpfWApO1xuXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xuXHRcdGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuXHRcdGF4aXMgPSBheGlzRW50ZXIubWVyZ2UoYXhpcyk7XG5cblx0XHQvLyBheGlzIGxpbmVcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93KSB7XG5cdFx0XHRheGlzLnNlbGVjdChcImxpbmVcIilcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB3aWR0aClcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBoZWlnaHQpXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGkpKVxuXHRcdFx0XHQuYXR0cihcInkyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpKSk7XG5cdFx0fVxuXG5cdFx0Ly8gYXhpcyB0ZXh0XG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdykge1xuXHRcdFx0YXhpcy5zZWxlY3QoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNWVtXCIpXG5cdFx0XHRcdC5jYWxsKHNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0c2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdFx0c2V0VGV4dFZhbHVlKGQzU2VsZWN0KHRoaXMpLCBkLCBbLTEuMiwgMS4yXSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kYXR1bSgoZCwgaSkgPT4gKHtpbmRleDogaX0pKVxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgkeyQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGksIHVuZGVmaW5lZCwgMSl9ICR7JCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgaSwgdW5kZWZpbmVkLCAxKX0pYCk7XG5cdFx0fVxuXG5cdFx0JCQuYmluZEV2ZW50KCk7XG5cdH0sXG5cblx0YmluZEV2ZW50KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQpIHtcblx0XHRcdGNvbnN0IGlzTW91c2UgPSAkJC5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcblx0XHRcdGNvbnN0IGdldEluZGV4ID0gKCkgPT4ge1xuXHRcdFx0XHRsZXQgdGFyZ2V0ID0gZDNFdmVudC50YXJnZXQ7XG5cblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBtdWx0aWxpbmVkIGF4aXMgdGV4dFxuXHRcdFx0XHRpZiAoL3RzcGFuL2kudGVzdCh0YXJnZXQudGFnTmFtZSkpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGQgPSBkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCk7XG5cblx0XHRcdFx0cmV0dXJuIGQgJiYgT2JqZWN0LmtleXMoZCkubGVuZ3RoID09PSAxID8gZC5pbmRleCA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0XHRjb25zdCBoaWRlID0gKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XG5cdFx0XHRcdGNvbnN0IG5vSW5kZXggPSBpc1VuZGVmaW5lZChpbmRleCk7XG5cblx0XHRcdFx0aWYgKGlzTW91c2UgfHwgbm9JbmRleCkge1xuXHRcdFx0XHRcdHRoaXMuaGlkZVRvb2x0aXAoKTtcblx0XHRcdFx0XHR0aGlzLnVuZXhwYW5kQ2lyY2xlcygpO1xuXG5cdFx0XHRcdFx0aWYgKGlzTW91c2UpIHtcblx0XHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGluZGV4KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vSW5kZXgpIHtcblx0XHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdCQkLnJhZGFycy5zZWxlY3QoYC4ke0NMQVNTLmF4aXN9YClcblx0XHRcdFx0Lm9uKGlzTW91c2UgPyBcIm1vdXNlb3ZlciBcIiA6IFwidG91Y2hzdGFydFwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCQkLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xuXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZSgkJC5zdmcubm9kZSgpLCBudWxsLCBpbmRleCk7XG5cdFx0XHRcdFx0aXNNb3VzZSA/ICQkLnNldE92ZXJPdXQodHJ1ZSwgaW5kZXgpIDogJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGlzTW91c2UgPyBoaWRlIDogbnVsbCk7XG5cblx0XHRcdGlmICghaXNNb3VzZSkge1xuXHRcdFx0XHQkJC5zdmcub24oXCJ0b3VjaHN0YXJ0XCIsIGhpZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcblx0XHRjb25zdCBwb2ludHMgPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRjb25zdCBhcmVhcyA9ICQkLnJhZGFycy5zaGFwZXNcblx0XHRcdC5zZWxlY3RBbGwoXCJwb2x5Z29uXCIpXG5cdFx0XHQuZGF0YSh0YXJnZXRzKTtcblxuXHRcdGNvbnN0IGFyZWFzRW50ZXIgPSBhcmVhcy5lbnRlcigpLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NDaGFydFJhZGFyLmJpbmQoJCQpKTtcblxuXHRcdGFyZWFzLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRhcmVhc0VudGVyXG5cdFx0XHQuYXBwZW5kKFwicG9seWdvblwiKVxuXHRcdFx0Lm1lcmdlKGFyZWFzKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIGQgPT4gJCQuY29sb3IoZCkpXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkLmlkXS5qb2luKFwiIFwiKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBkYXRhIHBvaW50IHggY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyYWRhckNpcmNsZVgoZCkge1xuXHRcdHJldHVybiB0aGlzLmdldENhY2hlKGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVswXTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGRhdGEgcG9pbnQgeSBjb29yZGluYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJhZGFyQ2lyY2xlWShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FjaGUoY2FjaGVLZXkpW2QuaWRdW2QuaW5kZXhdWzFdO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgZXh0ZW5kLCBnZXRSYW5kb20sIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFRleHQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRUZXh0cyk7XG5cblx0XHQkJC5tYWluVGV4dCA9IGQzU2VsZWN0QWxsKFtdKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGNoYXJ0VGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXG5cdCAqL1xuXHR1cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NUZXh0cyA9ICQkLmNsYXNzVGV4dHMuYmluZCgkJCk7XG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG5cdFx0Y29uc3QgbWFpblRleHRVcGRhdGUgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0VGV4dH1gKVxuXHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0VGV4dChkKSArIGNsYXNzRm9jdXMoZCkpO1xuXG5cdFx0Y29uc3QgbWFpblRleHRFbnRlciA9IG1haW5UZXh0VXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0VGV4dClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cblx0XHRtYWluVGV4dEVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0ZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHR1cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZGF0YUZuID0gJCQubGFiZWxpc2hEYXRhLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzVGV4dCA9ICQkLmNsYXNzVGV4dC5iaW5kKCQkKTtcblxuXHRcdCQkLm1haW5UZXh0ID0gJCQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxuXHRcdFx0LmRhdGEoZCA9PiAodGhpcy5pc1JhZGFyVHlwZShkKSA/IGQudmFsdWVzIDogZGF0YUZuKGQpKSk7XG5cblx0XHQkJC5tYWluVGV4dC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5tYWluVGV4dCA9ICQkLm1haW5UZXh0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQubWVyZ2UoJCQubWFpblRleHQpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZCA9PiAoY29uZmlnLmF4aXNfcm90YXRlZCA/IChkLnZhbHVlIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpIDogXCJtaWRkbGVcIikpXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZVRleHRDb2xvci5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC50ZXh0KChkLCBpLCBqKSA9PiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZC52YWx1ZSwgZC5pZCwgaSwgaikpO1xuXHR9LFxuXG5cdHVwZGF0ZVRleHRDb2xvcihkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGxhYmVsQ29sb3JzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzX2NvbG9ycztcblx0XHRsZXQgY29sb3I7XG5cblx0XHRpZiAoaXNTdHJpbmcobGFiZWxDb2xvcnMpKSB7XG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzO1xuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QobGFiZWxDb2xvcnMpKSB7XG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzW2QuaWRdO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb2xvciB8fCAkJC5jb2xvcihkKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IGNoYXJ0VGV4dFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB4XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHkgUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHlcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JGbG93XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb24gdHJhbnNpdGlvbiBpcyBlbmFibGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZWRyYXdUZXh0KHgsIHksIGZvckZsb3csIHdpdGhUcmFuc2l0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHQgPSBnZXRSYW5kb20oKTtcblx0XHRjb25zdCBvcGFjaXR5Rm9yVGV4dCA9IGZvckZsb3cgPyAwIDogJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCk7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0dGhpcy5tYWluVGV4dC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCB0ZXh0ID0gZDNTZWxlY3QodGhpcyk7XG5cblx0XHRcdFx0Ly8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcblx0XHRcdFx0KHdpdGhUcmFuc2l0aW9uICYmIHRleHQuYXR0cihcInhcIikgPyB0ZXh0LnRyYW5zaXRpb24odCkgOiB0ZXh0KVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB4KVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5KVxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBvcGFjaXR5Rm9yVGV4dCk7XG5cdFx0XHR9KVxuXHRcdF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0ICovXG5cdGdldFRleHRSZWN0KGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgYmFzZSA9IChlbGVtZW50Lm5vZGUgPyBlbGVtZW50Lm5vZGUoKSA6IGVsZW1lbnQpO1xuXG5cdFx0aWYgKCEvdGV4dC9pLnRlc3QoYmFzZS50YWdOYW1lKSkge1xuXHRcdFx0YmFzZSA9IGJhc2UucXVlcnlTZWxlY3RvcihcInRleHRcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dCA9IGJhc2UudGV4dENvbnRlbnQ7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBgJCR7dGV4dC5yZXBsYWNlKC9cXFcvZywgXCJfXCIpfWA7XG5cdFx0bGV0IHJlY3QgPSAkJC5nZXRDYWNoZShjYWNoZUtleSk7XG5cblx0XHRpZiAoIXJlY3QpIHtcblx0XHRcdCQkLnN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcblx0XHRcdFx0LnN0eWxlKFwiZm9udFwiLCBkM1NlbGVjdChiYXNlKS5zdHlsZShcImZvbnRcIikpXG5cdFx0XHRcdC5jbGFzc2VkKGNsYXNzTmFtZSwgdHJ1ZSlcblx0XHRcdFx0LnRleHQodGV4dClcblx0XHRcdFx0LmNhbGwodiA9PiB7XG5cdFx0XHRcdFx0cmVjdCA9IHYubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRcdCQkLmFkZENhY2hlKGNhY2hlS2V5LCByZWN0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgeCBvciB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyB2YWx1ZXNcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JYIHdoZXRoZXIgb3Igbm90IHRvIHhcblx0ICogQHJldHVybnMge051bWJlcn0gY29vcmRpbmF0ZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlWFlGb3JUZXh0KGluZGljZXMsIGZvclgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhpbmRpY2VzKTtcblx0XHRjb25zdCBwb2ludHMgPSB7fTtcblx0XHRjb25zdCBnZXR0ZXIgPSBmb3JYID8gJCQuZ2V0WEZvclRleHQgOiAkJC5nZXRZRm9yVGV4dDtcblxuXHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIik7XG5cblx0XHR0eXBlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0cG9pbnRzW3ZdID0gJCRbYGdlbmVyYXRlR2V0JHtjYXBpdGFsaXplKHYpfVBvaW50c2BdKGluZGljZXNbdl0sIGZhbHNlKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRjb25zdCB0eXBlID0gKCQkLmlzQXJlYVR5cGUoZCkgJiYgXCJhcmVhXCIpIHx8XG5cdFx0XHRcdCgkJC5pc0JhclR5cGUoZCkgJiYgXCJiYXJcIikgfHxcblx0XHRcdFx0KCQkLmlzUmFkYXJUeXBlKGQpICYmIFwicmFkYXJcIikgfHwgXCJsaW5lXCI7XG5cblx0XHRcdHJldHVybiBnZXR0ZXIuY2FsbCgkJCwgcG9pbnRzW3R5cGVdKGQsIGkpLCBkLCB0aGlzKTtcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgY2VudGVyaXplZCB0ZXh0IHBvc2l0aW9uIGZvciBiYXIgdHlwZSBkYXRhLmxhYmVsLnRleHRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3Rcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFBvc2l0aW9uIHZhbHVlXG5cdCAqL1xuXHRnZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdGlmIChjb25maWcuZGF0YV9sYWJlbHMuY2VudGVyZWQgJiYgJCQuaXNCYXJUeXBlKGQpKSB7XG5cdFx0XHRjb25zdCByZWN0ID0gdGV4dEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRjb25zdCBpc1Bvc2l0aXZlID0gZC52YWx1ZSA+PSAwO1xuXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XG5cdFx0XHRcdGNvbnN0IHcgPSAoXG5cdFx0XHRcdFx0aXNQb3NpdGl2ZSA/XG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0gOlxuXHRcdFx0XHRcdFx0cG9pbnRzWzBdWzFdIC0gcG9pbnRzWzFdWzFdXG5cdFx0XHRcdCkgLyAyICsgKHJlY3Qud2lkdGggLyAyKTtcblxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IC13IC0gMyA6IHcgKyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgaCA9IChcblx0XHRcdFx0XHRpc1Bvc2l0aXZlID9cblx0XHRcdFx0XHRcdHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXSA6XG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV1cblx0XHRcdFx0KSAvIDIgKyAocmVjdC5oZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IGggOiAtaCAtIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHJldHVybnMge051bWJlcn0geCBjb29yZGluYXRlXG5cdCAqL1xuXHRnZXRYRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGxldCB4UG9zO1xuXHRcdGxldCBwYWRkaW5nO1xuXG5cdFx0aWYgKGlzUm90YXRlZCkge1xuXHRcdFx0cGFkZGluZyA9ICQkLmlzQmFyVHlwZShkKSA/IDQgOiA2O1xuXHRcdFx0eFBvcyA9IHBvaW50c1syXVsxXSArIHBhZGRpbmcgKiAoZC52YWx1ZSA8IDAgPyAtMSA6IDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4UG9zID0gJCQuaGFzVHlwZShcImJhclwiKSA/IChwb2ludHNbMl1bMF0gKyBwb2ludHNbMF1bMF0pIC8gMiA6IHBvaW50c1swXVswXTtcblx0XHR9XG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcblx0XHRpZiAoZC52YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKHhQb3MgPiAkJC53aWR0aCkge1xuXHRcdFx0XHR4UG9zID0gJCQud2lkdGggLSB0ZXh0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdH0gZWxzZSBpZiAoeFBvcyA8IDApIHtcblx0XHRcdFx0eFBvcyA9IDQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzUm90YXRlZCkge1xuXHRcdFx0eFBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHhQb3MgKyAoY29uZmlnLmRhdGFfbGFiZWxzX3Bvc2l0aW9uLnggfHwgMCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHJldHVybnMge051bWJlcn0geSBjb29yZGluYXRlXG5cdCAqL1xuXHRnZXRZRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IHIgPSBjb25maWcucG9pbnRfcjtcblx0XHRjb25zdCByZWN0ID0gdGV4dEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0bGV0IGJhc2VZID0gMztcblx0XHRsZXQgeVBvcztcblxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcblx0XHRcdHlQb3MgPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzJdWzBdICsgcmVjdC5oZWlnaHQgKiAwLjYpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eVBvcyA9IHBvaW50c1syXVsxXTtcblxuXHRcdFx0aWYgKGlzTnVtYmVyKHIpICYmIHIgPiA1ICYmICgkJC5pc0xpbmVUeXBlKGQpIHx8ICQkLmlzU2NhdHRlclR5cGUoZCkpKSB7XG5cdFx0XHRcdGJhc2VZICs9IGNvbmZpZy5wb2ludF9yIC8gMi4zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZC52YWx1ZSA8IDAgfHwgKGQudmFsdWUgPT09IDAgJiYgISQkLmhhc1Bvc2l0aXZlVmFsdWUpKSB7XG5cdFx0XHRcdHlQb3MgKz0gcmVjdC5oZWlnaHQ7XG5cblx0XHRcdFx0aWYgKCQkLmlzQmFyVHlwZShkKSkge1xuXHRcdFx0XHRcdHlQb3MgLT0gYmFzZVk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoISQkLmlzQmFyVHlwZShkKSkge1xuXHRcdFx0XHRcdHlQb3MgKz0gYmFzZVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBkaWZmID0gLWJhc2VZICogMjtcblxuXHRcdFx0XHRpZiAoJCQuaXNCYXJUeXBlKGQpKSB7XG5cdFx0XHRcdFx0ZGlmZiA9IC1iYXNlWTtcblx0XHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVR5cGUoZCkpIHtcblx0XHRcdFx0XHRkaWZmID0gYmFzZVk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5UG9zICs9IGRpZmY7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcblx0XHRpZiAoZC52YWx1ZSA9PT0gbnVsbCAmJiAhaXNSb3RhdGVkKSB7XG5cdFx0XHRjb25zdCBib3hIZWlnaHQgPSByZWN0LmhlaWdodDtcblxuXHRcdFx0aWYgKHlQb3MgPCBib3hIZWlnaHQpIHtcblx0XHRcdFx0eVBvcyA9IGJveEhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoeVBvcyA+IHRoaXMuaGVpZ2h0KSB7XG5cdFx0XHRcdHlQb3MgPSB0aGlzLmhlaWdodCAtIDQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1JvdGF0ZWQpIHtcblx0XHRcdHlQb3MgKz0gJCQuZ2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB5UG9zICsgKGNvbmZpZy5kYXRhX2xhYmVsc19wb3NpdGlvbi55IHx8IDApO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXksIGV4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG4vLyBkZWZpbmVkIGNoYXJ0IHR5cGVzIGFzIGNhdGVnb3J5XG5jb25zdCBUWVBFUyA9IHtcblx0QXJlYTogW1wiYXJlYVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIiwgXCJhcmVhLWxpbmUtcmFuZ2VcIiwgXCJhcmVhLXN0ZXBcIl0sXG5cdEFyZWFSYW5nZTogW1wiYXJlYS1zcGxpbmUtcmFuZ2VcIiwgXCJhcmVhLWxpbmUtcmFuZ2VcIl0sXG5cdEFyYzogW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiLCBcInJhZGFyXCJdLFxuXHRMaW5lOiBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwiYXJlYVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIiwgXCJhcmVhLWxpbmUtcmFuZ2VcIiwgXCJzdGVwXCIsIFwiYXJlYS1zdGVwXCJdLFxuXHRTdGVwOiBbXCJzdGVwXCIsIFwiYXJlYS1zdGVwXCJdLFxuXHRTcGxpbmU6IFtcInNwbGluZVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIl1cbn07XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRzZXRUYXJnZXRUeXBlKHRhcmdldElkcywgdHlwZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0JCQud2l0aG91dEZhZGVJbltpZF0gPSAodHlwZSA9PT0gY29uZmlnLmRhdGFfdHlwZXNbaWRdKTtcblx0XHRcdGNvbmZpZy5kYXRhX3R5cGVzW2lkXSA9IHR5cGU7XG5cdFx0fSk7XG5cblx0XHRpZiAoIXRhcmdldElkcykge1xuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZSA9IHR5cGU7XG5cdFx0fVxuXHR9LFxuXG5cdGhhc1R5cGUodHlwZSwgdGFyZ2V0c1ZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IHR5cGVzID0gJCQuY29uZmlnLmRhdGFfdHlwZXM7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHRhcmdldHNWYWx1ZSB8fCAkJC5kYXRhLnRhcmdldHM7XG5cdFx0bGV0IGhhcyA9IGZhbHNlO1xuXG5cdFx0aWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4ge1xuXHRcdFx0XHRjb25zdCB0ID0gdHlwZXNbdGFyZ2V0LmlkXTtcblxuXHRcdFx0XHRpZiAoKHQgJiYgdC5pbmRleE9mKHR5cGUpID49IDApIHx8ICghdCAmJiB0eXBlID09PSBcImxpbmVcIikpIHtcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHR5cGVzKS5sZW5ndGgpIHtcblx0XHRcdE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGlkID0+IHtcblx0XHRcdFx0aWYgKHR5cGVzW2lkXSA9PT0gdHlwZSkge1xuXHRcdFx0XHRcdGhhcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYXMgPSAkJC5jb25maWcuZGF0YV90eXBlID09PSB0eXBlO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGNvbnRhaW5zIGdpdmVuIGNoYXJ0IHR5cGVzXG5cdCAqIEBwYXJtYSB7U3RyaW5nfSB0eXBlIFR5cGUga2V5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGUgRXhjbHVkZWQgdHlwZXNcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhhc1R5cGVPZih0eXBlLCB0YXJnZXRzLCBleGNsdWRlID0gW10pIHtcblx0XHRyZXR1cm4gIVRZUEVTW3R5cGVdXG5cdFx0XHQuZmlsdGVyKHYgPT4gZXhjbHVkZS5pbmRleE9mKHYpID09PSAtMSlcblx0XHRcdC5ldmVyeSh2ID0+ICF0aGlzLmhhc1R5cGUodiwgdGFyZ2V0cykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBnaXZlbiBkYXRhIGlzIGNlcnRhaW4gY2hhcnQgdHlwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBjaGFydCB0eXBlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpc1R5cGVPZihkLCB0eXBlKSB7XG5cdFx0Y29uc3QgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xuXHRcdGNvbnN0IGRhdGFUeXBlID0gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF07XG5cblx0XHRyZXR1cm4gaXNBcnJheSh0eXBlKSA/XG5cdFx0XHR0eXBlLmluZGV4T2YoZGF0YVR5cGUpID49IDAgOiBkYXRhVHlwZSA9PT0gdHlwZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgYXJjIHR5cGVzIGNoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGUgRXhjbHVkZWQgdHlwZXNcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhhc0FyY1R5cGUodGFyZ2V0cywgZXhjbHVkZSkge1xuXHRcdHJldHVybiB0aGlzLmhhc1R5cGVPZihcIkFyY1wiLCB0YXJnZXRzLCBleGNsdWRlKTtcblx0fSxcblxuXHRpc0xpbmVUeXBlKGQpIHtcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XG5cblx0XHRyZXR1cm4gIXRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdIHx8XG5cdFx0XHR0aGlzLmlzVHlwZU9mKGlkLCBUWVBFUy5MaW5lKTtcblx0fSxcblxuXHRpc1N0ZXBUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5TdGVwKTtcblx0fSxcblxuXHRpc1NwbGluZVR5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlNwbGluZSk7XG5cdH0sXG5cblx0aXNBcmVhVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuQXJlYSk7XG5cdH0sXG5cblx0aXNBcmVhUmFuZ2VUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5BcmVhUmFuZ2UpO1xuXHR9LFxuXG5cdGlzQmFyVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJiYXJcIik7XG5cdH0sXG5cblx0aXNCdWJibGVUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJ1YmJsZVwiKTtcblx0fSxcblxuXHRpc1NjYXR0ZXJUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInNjYXR0ZXJcIik7XG5cdH0sXG5cblx0aXNQaWVUeXBlKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInBpZVwiKTtcblx0fSxcblxuXHRpc0dhdWdlVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJnYXVnZVwiKTtcblx0fSxcblxuXHRpc0RvbnV0VHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJkb251dFwiKTtcblx0fSxcblxuXHRpc1JhZGFyVHlwZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJyYWRhclwiKTtcblx0fSxcblxuXHRpc0FyY1R5cGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzUGllVHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc0RvbnV0VHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc0dhdWdlVHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKTtcblx0fSxcblxuXHQvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxuXHRpc0NpcmNsZVBvaW50KCkge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHRcdGNvbnN0IHBhdHRlcm4gPSBjb25maWcucG9pbnRfcGF0dGVybjtcblxuXHRcdHJldHVybiBjb25maWcucG9pbnRfdHlwZSA9PT0gXCJjaXJjbGVcIiAmJlxuXHRcdFx0KCFwYXR0ZXJuIHx8IChpc0FycmF5KHBhdHRlcm4pICYmIHBhdHRlcm4ubGVuZ3RoID09PSAwKSk7XG5cdH0sXG5cblx0bGluZURhdGEoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzTGluZVR5cGUoZCkgPyBbZF0gOiBbXTtcblx0fSxcblxuXHRhcmNEYXRhKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0FyY1R5cGUoZC5kYXRhKSA/IFtkXSA6IFtdO1xuXHR9LFxuXG5cdGJhckRhdGEoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBkYXRhIGFkYXB0IGZvciBkYXRhIGxhYmVsIHNob3dpbmdcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3Rcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRsYWJlbGlzaERhdGEoZCkge1xuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fFxuXHRcdFx0dGhpcy5pc0xpbmVUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzU2NhdHRlclR5cGUoZCkgfHxcblx0XHRcdHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8XG5cdFx0XHR0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcblx0fSxcblxuXHRiYXJMaW5lQnViYmxlRGF0YShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8IHRoaXMuaXNMaW5lVHlwZShkKSB8fCB0aGlzLmlzQnViYmxlVHlwZShkKSA/XG5cdFx0XHRkLnZhbHVlcyA6IFtdO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZSNjdXJ2ZXNcblx0aXNJbnRlcnBvbGF0aW9uVHlwZSh0eXBlKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFwiYmFzaXNcIixcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCIsXG5cdFx0XHRcImJhc2lzLW9wZW5cIixcblx0XHRcdFwiYnVuZGxlXCIsXG5cdFx0XHRcImNhcmRpbmFsXCIsXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiLFxuXHRcdFx0XCJjYXJkaW5hbC1vcGVuXCIsXG5cdFx0XHRcImNhdG11bGwtcm9tXCIsXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiLFxuXHRcdFx0XCJjYXRtdWxsLXJvbS1vcGVuXCIsXG5cdFx0XHRcImxpbmVhclwiLFxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCIsXG5cdFx0XHRcIm1vbm90b25lLXhcIixcblx0XHRcdFwibW9ub3RvbmUteVwiLFxuXHRcdFx0XCJuYXR1cmFsXCJcblx0XHRdLmluZGV4T2YodHlwZSkgPj0gMDtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgaXNBcnJheSwgaXNWYWx1ZX0gZnJvbSBcIi4vdXRpbFwiO1xuXG4vLyBHcmlkIHBvc2l0aW9uIGFuZCB0ZXh0IGFuY2hvciBoZWxwZXJzXG5jb25zdCBnZXRHcmlkVGV4dEFuY2hvciA9IGQgPT4gaXNWYWx1ZShkLnBvc2l0aW9uKSB8fCBcImVuZFwiO1xuY29uc3QgZ2V0R3JpZFRleHREeCA9IGQgPT4gKGQucG9zaXRpb24gPT09IFwic3RhcnRcIiA/IDQgOiAoZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIiA/IDAgOiAtNCkpO1xuY29uc3QgZ2V0R3JpZFRleHRYID0gKGlzWCwgd2lkdGgsIGhlaWdodCkgPT4gZCA9PiB7XG5cdGxldCB4ID0gaXNYID8gMCA6IHdpZHRoO1xuXG5cdGlmIChkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcblx0XHR4ID0gaXNYID8gLWhlaWdodCA6IDA7XG5cdH0gZWxzZSBpZiAoZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIikge1xuXHRcdHggPSAoaXNYID8gLWhlaWdodCA6IHdpZHRoKSAvIDI7XG5cdH1cblxuXHRyZXR1cm4geDtcbn07XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0R3JpZCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC54Z3JpZCA9IGQzU2VsZWN0QWxsKFtdKTtcblxuXHRcdCQkLmluaXRHcmlkTGluZXMoKTtcblx0XHQkJC5pbml0WFlGb2N1c0dyaWQoKTtcblx0fSxcblxuXHRpbml0R3JpZExpbmVzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcblx0XHRcdCQkLmdyaWRMaW5lcyA9ICQkLm1haW4uaW5zZXJ0KFwiZ1wiLCBgLiR7Q0xBU1MuY2hhcnR9JHtjb25maWcuZ3JpZF9saW5lc19mcm9udCA/IFwiICsgKlwiIDogXCJcIn1gKVxuXHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aEZvckdyaWQpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYCR7Q0xBU1MuZ3JpZH0gJHtDTEFTUy5ncmlkTGluZXN9YCk7XG5cblx0XHRcdCQkLmdyaWRMaW5lcy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZExpbmVzKTtcblx0XHRcdCQkLmdyaWRMaW5lcy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZExpbmVzKTtcblxuXHRcdFx0JCQueGdyaWRMaW5lcyA9IGQzU2VsZWN0QWxsKFtdKTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlWEdyaWQod2l0aG91dFVwZGF0ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCB4Z3JpZERhdGEgPSAkJC5nZW5lcmF0ZUdyaWREYXRhKGNvbmZpZy5ncmlkX3hfdHlwZSwgJCQueCk7XG5cdFx0Y29uc3QgdGlja09mZnNldCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSA/ICQkLnhBeGlzLnRpY2tPZmZzZXQoKSA6IDA7XG5cdFx0Y29uc3QgcG9zID0gZCA9PiAoKCQkLnpvb21TY2FsZSB8fCAkJC54KShkKSArIHRpY2tPZmZzZXQpICogKGlzUm90YXRlZCA/IC0xIDogMSk7XG5cblx0XHQkJC54Z3JpZEF0dHIgPSBpc1JvdGF0ZWQgPyB7XG5cdFx0XHRcIngxXCI6IDAsXG5cdFx0XHRcIngyXCI6ICQkLndpZHRoLFxuXHRcdFx0XCJ5MVwiOiBwb3MsXG5cdFx0XHRcInkyXCI6IHBvcyxcblx0XHR9IDoge1xuXHRcdFx0XCJ4MVwiOiBwb3MsXG5cdFx0XHRcIngyXCI6IHBvcyxcblx0XHRcdFwieTFcIjogMCxcblx0XHRcdFwieTJcIjogJCQuaGVpZ2h0LFxuXHRcdH07XG5cblx0XHQkJC54Z3JpZCA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZHN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnhncmlkfWApXG5cdFx0XHQuZGF0YSh4Z3JpZERhdGEpO1xuXG5cdFx0JCQueGdyaWQuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0JCQueGdyaWQgPSAkJC54Z3JpZC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZClcblx0XHRcdC5tZXJnZSgkJC54Z3JpZCk7XG5cblx0XHRpZiAoIXdpdGhvdXRVcGRhdGUpIHtcblx0XHRcdCQkLnhncmlkLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGdyaWQgPSBkM1NlbGVjdCh0aGlzKTtcblxuXHRcdFx0XHRPYmplY3Qua2V5cygkJC54Z3JpZEF0dHIpLmZvckVhY2goaWQgPT4ge1xuXHRcdFx0XHRcdGdyaWQuYXR0cihpZCwgJCQueGdyaWRBdHRyW2lkXSlcblx0XHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgKCkgPT4gKFxuXHRcdFx0XHRcdFx0XHRncmlkLmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiKSA9PT0gKGlzUm90YXRlZCA/ICQkLmhlaWdodCA6IDApID9cblx0XHRcdFx0XHRcdFx0XHRcIjBcIiA6IFwiMVwiXG5cdFx0XHRcdFx0XHQpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlWUdyaWQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGdyaWRWYWx1ZXMgPSAkJC55QXhpcy50aWNrVmFsdWVzKCkgfHwgJCQueS50aWNrcyhjb25maWcuZ3JpZF95X3RpY2tzKTtcblx0XHRjb25zdCBwb3MgPSBkID0+IE1hdGguY2VpbCgkJC55KGQpKTtcblxuXHRcdCQkLnlncmlkID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnlncmlkc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWR9YClcblx0XHRcdC5kYXRhKGdyaWRWYWx1ZXMpO1xuXG5cdFx0JCQueWdyaWQuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdFx0JCQueWdyaWQgPSAkJC55Z3JpZFxuXHRcdFx0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkKVxuXHRcdFx0Lm1lcmdlKCQkLnlncmlkKTtcblxuXHRcdCQkLnlncmlkLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAwKVxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAkJC53aWR0aClcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gMCA6IHBvcylcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogcG9zKTtcblxuXHRcdCQkLnNtb290aExpbmVzKCQkLnlncmlkLCBcImdyaWRcIik7XG5cdH0sXG5cblx0dXBkYXRlR3JpZChkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCEkJC5ncmlkTGluZXMgJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xuXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxuXHRcdCQkLmdyaWQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIik7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YClcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG5cblx0XHQkJC51cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKTtcblx0XHQkJC51cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIFggR3JpZCBsaW5lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZVhHcmlkTGluZXMoZHVyYXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgbWFpbiA9ICQkLm1haW47XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiYgJCQudXBkYXRlWEdyaWQoKTtcblxuXHRcdCQkLnhncmlkTGluZXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueGdyaWRMaW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWRMaW5lfWApXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF94X2xpbmVzKTtcblxuXHRcdC8vIGV4aXRcblx0XHQkJC54Z3JpZExpbmVzLmV4aXQoKS50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQvLyBlbnRlclxuXHRcdGNvbnN0IHhncmlkTGluZSA9ICQkLnhncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuXG5cdFx0eGdyaWRMaW5lLmFwcGVuZChcImxpbmVcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xuXG5cdFx0eGdyaWRMaW5lLmFwcGVuZChcInRleHRcIilcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpXG5cdFx0XHQuYXR0cihcImR5XCIsIC01KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cblx0XHQkJC54Z3JpZExpbmVzID0geGdyaWRMaW5lLm1lcmdlKCQkLnhncmlkTGluZXMpO1xuXG5cdFx0JCQueGdyaWRMaW5lc1xuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLnhncmlkTGluZX0gJHtkLmNsYXNzIHx8IFwiXCJ9YC50cmltKCkpXG5cdFx0XHQuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBZIEdyaWQgbGluZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmICQkLnVwZGF0ZVlHcmlkKCk7XG5cblx0XHQkJC55Z3JpZExpbmVzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLnlncmlkTGluZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkTGluZX1gKVxuXHRcdFx0LmRhdGEoY29uZmlnLmdyaWRfeV9saW5lcyk7XG5cblx0XHQvLyBleGl0XG5cdFx0JCQueWdyaWRMaW5lcy5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQvLyBlbnRlclxuXHRcdGNvbnN0IHlncmlkTGluZSA9ICQkLnlncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcImxpbmVcIilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xuXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcInRleHRcIilcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwicm90YXRlKC05MClcIiA6IFwiXCIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcblxuXHRcdCQkLnlncmlkTGluZXMgPSB5Z3JpZExpbmUubWVyZ2UoJCQueWdyaWRMaW5lcyk7XG5cblx0XHQvLyB1cGRhdGVcblx0XHRjb25zdCB5diA9ICQkLnl2LmJpbmQoJCQpO1xuXG5cdFx0JCQueWdyaWRMaW5lc1xuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLnlncmlkTGluZX0gJHtkLmNsYXNzIHx8IFwiXCJ9YC50cmltKCkpXG5cdFx0XHQuc2VsZWN0KFwibGluZVwiKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyB5diA6IDApXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHl2IDogJCQud2lkdGgpXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiB5dilcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gJCQuaGVpZ2h0IDogeXYpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblxuXHRcdCQkLnlncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKGlzUm90YXRlZCwgJCQud2lkdGgsICQkLmhlaWdodCkpXG5cdFx0XHQuYXR0cihcInlcIiwgeXYpXG5cdFx0XHQudGV4dChkID0+IGQudGV4dClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXHR9LFxuXG5cdHJlZHJhd0dyaWQod2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCB4diA9ICQkLnh2LmJpbmQoJCQpO1xuXG5cdFx0bGV0IGxpbmVzID0gJCQueGdyaWRMaW5lcy5zZWxlY3QoXCJsaW5lXCIpO1xuXHRcdGxldCB0ZXh0cyA9ICQkLnhncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKTtcblxuXHRcdGxpbmVzID0gKHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiB4dilcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8geHYgOiAwKVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyB4diA6ICQkLmhlaWdodCk7XG5cblx0XHR0ZXh0cyA9ICh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIGdldEdyaWRUZXh0WCghaXNSb3RhdGVkLCAkJC53aWR0aCwgJCQuaGVpZ2h0KSlcblx0XHRcdC5hdHRyKFwieVwiLCB4dilcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSxcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXG5cdFx0XTtcblx0fSxcblxuXHRpbml0WFlGb2N1c0dyaWQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc0Zyb250ID0gY29uZmlnLmdyaWRfZnJvbnQ7XG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gYC4ke0NMQVNTW2lzRnJvbnQgJiYgJCQuZ3JpZExpbmVzID8gXCJncmlkTGluZXNcIiA6IFwiY2hhcnRcIl19JHtpc0Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWA7XG5cblx0XHQkJC5ncmlkID0gJCQubWFpbi5pbnNlcnQoXCJnXCIsIGNsYXNzTmFtZSlcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoRm9yR3JpZClcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZ3JpZCk7XG5cblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiZcblx0XHRcdCQkLmdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRzKTtcblxuXHRcdGNvbmZpZy5ncmlkX3lfc2hvdyAmJlxuXHRcdFx0JCQuZ3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZHMpO1xuXG5cdFx0aWYgKGNvbmZpZy5ncmlkX2ZvY3VzX3Nob3cpIHtcblx0XHRcdCQkLmdyaWQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkRm9jdXMpXG5cdFx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cyk7XG5cdFx0fVxuXHR9LFxuXG5cdHNob3dYR3JpZEZvY3VzKHNlbGVjdGVkRGF0YSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcblx0XHRjb25zdCBmb2N1c0VsID0gJCQubWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApO1xuXHRcdGNvbnN0IHh4ID0gJCQueHguYmluZCgkJCk7XG5cblx0XHRpZiAoIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBIaWRlIHdoZW4gYnViYmxlL3NjYXR0ZXIvc3RhbmZvcmQgcGxvdCBleGlzdHNcblx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNUeXBlKFwic2NhdHRlclwiKSB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb2N1c0VsXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxuXHRcdFx0LmRhdGEoW2RhdGFUb1Nob3dbMF1dKVxuXHRcdFx0LmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiLCB4eClcblx0XHRcdC5hdHRyKGlzUm90YXRlZCA/IFwieTJcIiA6IFwieDJcIiwgeHgpO1xuXG5cdFx0JCQuc21vb3RoTGluZXMoZm9jdXNFbCwgXCJncmlkXCIpO1xuXHR9LFxuXG5cdGhpZGVYR3JpZEZvY3VzKCkge1xuXHRcdHRoaXMubWFpbi5zZWxlY3QoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0fSxcblxuXHR1cGRhdGVYZ3JpZEZvY3VzKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xuXG5cdFx0JCQubWFpbi5zZWxlY3QoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiAtMTApXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/ICQkLndpZHRoIDogLTEwKVxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAtMTAgOiAwKVxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAtMTAgOiAkJC5oZWlnaHQpO1xuXHR9LFxuXG5cdGdlbmVyYXRlR3JpZERhdGEodHlwZSwgc2NhbGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgdGlja051bSA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKVxuXHRcdFx0LnNlbGVjdEFsbChcIi50aWNrXCIpXG5cdFx0XHQuc2l6ZSgpO1xuXHRcdGxldCBncmlkRGF0YSA9IFtdO1xuXG5cdFx0aWYgKHR5cGUgPT09IFwieWVhclwiKSB7XG5cdFx0XHRjb25zdCB4RG9tYWluID0gJCQuZ2V0WERvbWFpbigpO1xuXHRcdFx0Y29uc3QgZmlyc3RZZWFyID0geERvbWFpblswXS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0Y29uc3QgbGFzdFllYXIgPSB4RG9tYWluWzFdLmdldEZ1bGxZZWFyKCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSBmaXJzdFllYXI7IGkgPD0gbGFzdFllYXI7IGkrKykge1xuXHRcdFx0XHRncmlkRGF0YS5wdXNoKG5ldyBEYXRlKGAke2l9LTAxLTAxIDAwOjAwOjAwYCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRncmlkRGF0YSA9IHNjYWxlLnRpY2tzKDEwKTtcblxuXHRcdFx0aWYgKGdyaWREYXRhLmxlbmd0aCA+IHRpY2tOdW0pIHsgLy8gdXNlIG9ubHkgaW50XG5cdFx0XHRcdGdyaWREYXRhID0gZ3JpZERhdGEuZmlsdGVyKGQgPT4gU3RyaW5nKGQpLmluZGV4T2YoXCIuXCIpIDwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdyaWREYXRhO1xuXHR9LFxuXG5cdGdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpIHtcblx0XHRyZXR1cm4gcGFyYW1zID8gbGluZSA9PiB7XG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcblxuXHRcdFx0KGlzQXJyYXkocGFyYW1zKSA/IHBhcmFtcy5jb25jYXQoKSA6IFtwYXJhbXNdKS5mb3JFYWNoKHBhcmFtID0+IHtcblx0XHRcdFx0aWYgKCgoXCJ2YWx1ZVwiIGluIHBhcmFtICYmIGxpbmUudmFsdWUgPT09IHBhcmFtLnZhbHVlKSB8fCAoXCJjbGFzc1wiIGluIHBhcmFtICYmIGxpbmUuY2xhc3MgPT09IHBhcmFtLmNsYXNzKSkpIHtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0fSA6ICgpID0+IHRydWU7XG5cdH0sXG5cblx0cmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgZm9yWCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgdG9SZW1vdmUgPSAkJC5nZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKTtcblx0XHRjb25zdCB0b1Nob3cgPSBsaW5lID0+ICF0b1JlbW92ZShsaW5lKTtcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gZm9yWCA/IENMQVNTLnhncmlkTGluZXMgOiBDTEFTUy55Z3JpZExpbmVzO1xuXHRcdGNvbnN0IGNsYXNzTGluZSA9IGZvclggPyBDTEFTUy54Z3JpZExpbmUgOiBDTEFTUy55Z3JpZExpbmU7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Y2xhc3NMaW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Y2xhc3NMaW5lfWApXG5cdFx0XHQuZmlsdGVyKHRvUmVtb3ZlKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdGNvbnN0IGdyaWRMaW5lcyA9IGBncmlkXyR7Zm9yWCA/IFwieFwiIDogXCJ5XCJ9X2xpbmVzYDtcblxuXHRcdGNvbmZpZ1tncmlkTGluZXNdID0gY29uZmlnW2dyaWRMaW5lc10uZmlsdGVyKHRvU2hvdyk7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcblx0bW91c2UgYXMgZDNNb3VzZVxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1ZhbHVlLCBjYWxsRm4sIHNhbml0aXNlLCB0cGxQcm9jZXNzLCBpc1VuZGVmaW5lZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0VG9vbHRpcCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGJpbmR0byA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmR0bztcblxuXHRcdCQkLnRvb2x0aXAgPSBkM1NlbGVjdChiaW5kdG8pO1xuXG5cdFx0aWYgKCQkLnRvb2x0aXAuZW1wdHkoKSkge1xuXHRcdFx0JCQudG9vbHRpcCA9ICQkLnNlbGVjdENoYXJ0XG5cdFx0XHRcdC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcblx0XHRcdFx0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRvb2x0aXBDb250YWluZXIpXG5cdFx0XHRcdC5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXHRcdH1cblxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBuZWVkZWRcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSB7XG5cdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgaXNTdHJpbmcoY29uZmlnLnRvb2x0aXBfaW5pdF94KSkge1xuXHRcdFx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzWzBdO1xuXHRcdFx0XHRsZXQgaTtcblx0XHRcdFx0bGV0IHZhbDtcblxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSAkJC5wYXJzZURhdGUoY29uZmlnLnRvb2x0aXBfaW5pdF94KTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyAodmFsID0gdGFyZ2V0cy52YWx1ZXNbaV0pOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoKHZhbC54IC0gY29uZmlnLnRvb2x0aXBfaW5pdF94KSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uZmlnLnRvb2x0aXBfaW5pdF94ID0gaTtcblx0XHRcdH1cblxuXHRcdFx0JCQudG9vbHRpcC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxuXHRcdFx0XHQkJC5kYXRhLnRhcmdldHMubWFwKGQgPT4gJCQuYWRkTmFtZShkLnZhbHVlc1tjb25maWcudG9vbHRpcF9pbml0X3hdKSksXG5cdFx0XHRcdCQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksXG5cdFx0XHRcdCQkLmdldFlGb3JtYXQoJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSkpLFxuXHRcdFx0XHQkJC5jb2xvclxuXHRcdFx0KSk7XG5cblx0XHRcdGlmICghYmluZHRvKSB7XG5cdFx0XHRcdCQkLnRvb2x0aXAuc3R5bGUoXCJ0b3BcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi50b3ApXG5cdFx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLmxlZnQpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSB0b29sdGlwIEhUTUwgc3RyaW5nXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEZvcm1hdHRlZCBIVE1MIHN0cmluZ1xuXHQgKi9cblx0Z2V0VG9vbHRpcEhUTUwoLi4uYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjb25maWcudG9vbHRpcF9jb250ZW50cykgP1xuXHRcdFx0Y29uZmlnLnRvb2x0aXBfY29udGVudHMuY2FsbCgkJCwgLi4uYXJncykgOiAkJC5nZXRUb29sdGlwQ29udGVudCguLi5hcmdzKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdG9vbHRpcCBjb250ZW50KEhUTUwgc3RyaW5nKVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRUaXRsZUZvcm1hdCBEZWZhdWx0IHRpdGxlIGZvcm1hdFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0VmFsdWVGb3JtYXQgRGVmYXVsdCBmb3JtYXQgZm9yIGVhY2ggZGF0YSB2YWx1ZSBpbiB0aGUgdG9vbHRpcC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3IgQ29sb3IgZnVuY3Rpb25cblx0ICogQHJldHVybnMge1N0cmluZ30gaHRtbFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VG9vbHRpcENvbnRlbnQoZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB0aXRsZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF90aXRsZSB8fCBkZWZhdWx0VGl0bGVGb3JtYXQ7XG5cdFx0Y29uc3QgbmFtZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF9uYW1lIHx8IChuYW1lID0+IG5hbWUpO1xuXHRcdGNvbnN0IHZhbHVlRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X3ZhbHVlIHx8ICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gKCh2LCByYXRpbykgPT4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDIpfSVgKSA6IGRlZmF1bHRWYWx1ZUZvcm1hdCk7XG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcudG9vbHRpcF9vcmRlcjtcblx0XHRjb25zdCBnZXRSb3dWYWx1ZSA9IHJvdyA9PiAkJC5nZXRCYXNlVmFsdWUocm93KTtcblx0XHRjb25zdCBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IHJvdyA9PiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSkgOiByb3cgPT4gY29sb3Iocm93KTtcblx0XHRjb25zdCBjb250ZW50cyA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzO1xuXHRcdGNvbnN0IHRwbFN0ciA9IGNvbnRlbnRzLnRlbXBsYXRlO1xuXG5cdFx0aWYgKG9yZGVyID09PSBudWxsICYmIGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGgpIHtcblx0XHRcdC8vIGZvciBzdGFja2VkIGRhdGEsIG9yZGVyIHNob3VsZCBhbGlnbmVkIHdpdGggdGhlIHZpc3VhbGx5IGRpc3BsYXllZCBkYXRhXG5cdFx0XHRjb25zdCBpZHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZGF0YS50YXJnZXRzKVxuXHRcdFx0XHQubWFwKGkyID0+IGkyLmlkKVxuXHRcdFx0XHQucmV2ZXJzZSgpO1xuXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0bGV0IHYxID0gYSA/IGEudmFsdWUgOiBudWxsO1xuXHRcdFx0XHRsZXQgdjIgPSBiID8gYi52YWx1ZSA6IG51bGw7XG5cblx0XHRcdFx0aWYgKHYxID4gMCAmJiB2MiA+IDApIHtcblx0XHRcdFx0XHR2MSA9IGEuaWQgPyBpZHMuaW5kZXhPZihhLmlkKSA6IG51bGw7XG5cdFx0XHRcdFx0djIgPSBiLmlkID8gaWRzLmluZGV4T2YoYi5pZCkgOiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHYxIC0gdjI7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKC9eKGFzY3xkZXNjKSQvLnRlc3Qob3JkZXIpKSB7XG5cdFx0XHRjb25zdCBpc0FzY2VuZGluZyA9IG9yZGVyID09PSBcImFzY1wiO1xuXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0Y29uc3QgdjEgPSBhID8gZ2V0Um93VmFsdWUoYSkgOiBudWxsO1xuXHRcdFx0XHRjb25zdCB2MiA9IGIgPyBnZXRSb3dWYWx1ZShiKSA6IG51bGw7XG5cblx0XHRcdFx0cmV0dXJuIGlzQXNjZW5kaW5nID8gdjEgLSB2MiA6IHYyIC0gdjE7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24ob3JkZXIpKSB7XG5cdFx0XHRkLnNvcnQob3JkZXIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRwbCA9ICQkLmdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUodHBsU3RyKTtcblx0XHRsZXQgdGV4dDtcblx0XHRsZXQgcm93O1xuXHRcdGxldCBwYXJhbTtcblx0XHRsZXQgdmFsdWU7XG5cdFx0bGV0IGk7XG5cblx0XHRmb3IgKGkgPSAwOyAocm93ID0gZFtpXSk7IGkrKykge1xuXHRcdFx0aWYgKCEoZ2V0Um93VmFsdWUocm93KSB8fCBnZXRSb3dWYWx1ZShyb3cpID09PSAwKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHRleHQpKSB7XG5cdFx0XHRcdGNvbnN0IHRpdGxlID0gc2FuaXRpc2UodGl0bGVGb3JtYXQgPyB0aXRsZUZvcm1hdChyb3cueCkgOiByb3cueCk7XG5cblx0XHRcdFx0dGV4dCA9IHRwbFByb2Nlc3ModHBsWzBdLCB7XG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUDogQ0xBU1MudG9vbHRpcCxcblx0XHRcdFx0XHRUSVRMRTogaXNWYWx1ZSh0aXRsZSkgPyAoXG5cdFx0XHRcdFx0XHR0cGxTdHIgPyB0aXRsZSA6IGA8dHI+PHRoIGNvbHNwYW49XCIyXCI+JHt0aXRsZX08L3RoPjwvdHI+YFxuXHRcdFx0XHRcdCkgOiBcIlwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwYXJhbSA9IFtyb3cucmF0aW8sIHJvdy5pZCwgcm93LmluZGV4LCBkXTtcblx0XHRcdHZhbHVlID0gc2FuaXRpc2UodmFsdWVGb3JtYXQoZ2V0Um93VmFsdWUocm93KSwgLi4ucGFyYW0pKTtcblxuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShyb3cpKSB7XG5cdFx0XHRcdGNvbnN0IFtoaWdoLCBsb3ddID0gW1wiaGlnaFwiLCBcImxvd1wiXS5tYXAodiA9PiBzYW5pdGlzZShcblx0XHRcdFx0XHR2YWx1ZUZvcm1hdCgkJC5nZXRBcmVhUmFuZ2VEYXRhKHJvdywgdiksIC4uLnBhcmFtKVxuXHRcdFx0XHQpKTtcblxuXHRcdFx0XHR2YWx1ZSA9IGA8Yj5NaWQ6PC9iPiAke3ZhbHVlfSA8Yj5IaWdoOjwvYj4gJHtoaWdofSA8Yj5Mb3c6PC9iPiAke2xvd31gO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxuXHRcdFx0XHRpZiAocm93Lm5hbWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBzYW5pdGlzZShuYW1lRm9ybWF0KHJvdy5uYW1lLCAuLi5wYXJhbSkpO1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IGdldEJnQ29sb3Iocm93KTtcblx0XHRcdFx0Y29uc3QgY29udGVudFZhbHVlID0ge1xuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVBfTkFNRTogQ0xBU1MudG9vbHRpcE5hbWUgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChyb3cuaWQpLFxuXHRcdFx0XHRcdENPTE9SOiAodHBsU3RyIHx8ICEkJC5wYXR0ZXJucykgPyBjb2xvciA6IGA8c3ZnPjxyZWN0IHN0eWxlPVwiZmlsbDoke2NvbG9yfVwiIHdpZHRoPVwiMTBcIiBoZWlnaHQ9XCIxMFwiPjwvcmVjdD48L3N2Zz5gLFxuXHRcdFx0XHRcdE5BTUU6IG5hbWUsXG5cdFx0XHRcdFx0VkFMVUU6IHZhbHVlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHRwbFN0ciAmJiBpc09iamVjdChjb250ZW50cy50ZXh0KSkge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGNvbnRlbnRzLnRleHQpLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdFx0XHRcdGNvbnRlbnRWYWx1ZVtrZXldID0gY29udGVudHMudGV4dFtrZXldW2ldO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dCArPSB0cGxQcm9jZXNzKHRwbFsxXSwgY29udGVudFZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYCR7dGV4dH08L3RhYmxlPmA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY29udGVudCB0ZW1wbGF0ZSBzdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRwbFN0clxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRlbXBsYXRlIHN0cmluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpIHtcblx0XHRyZXR1cm4gKHRwbFN0ciB8fCBgPHRhYmxlIGNsYXNzPVwiez1DTEFTU19UT09MVElQfVwiPjx0Ym9keT5cblx0XHRcdFx0ez1USVRMRX1cblx0XHRcdFx0e3s8dHIgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj5cblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJuYW1lXCI+JHt0aGlzLnBhdHRlcm5zID8gYHs9Q09MT1J9YCA6IGA8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ez1DT0xPUn1cIj48L3NwYW4+YH17PU5BTUV9PC90ZD5cblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJ2YWx1ZVwiPns9VkFMVUV9PC90ZD5cblx0XHRcdFx0PC90cj59fVxuXHRcdFx0PC90Ym9keT48L3RhYmxlPmApXG5cdFx0XHQucmVwbGFjZSgvKFxccj9cXG58XFx0KS9nLCBcIlwiKVxuXHRcdFx0LnNwbGl0KC97eyguKil9fS8pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVRvU2hvdyBkYXRhXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0V2lkdGggV2lkdGggdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0SGVpZ2h0IEhlaWdodCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0b3AsIGxlZnQgdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRvb2x0aXBQb3NpdGlvbihkYXRhVG9TaG93LCB0V2lkdGgsIHRIZWlnaHQsIGVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBbbGVmdCwgdG9wXSA9IGQzTW91c2UoZWxlbWVudCk7XG5cblx0XHRjb25zdCBzdmdMZWZ0ID0gJCQuZ2V0U3ZnTGVmdCh0cnVlKTtcblx0XHRsZXQgY2hhcnRSaWdodCA9IHN2Z0xlZnQgKyAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCk7XG5cblx0XHR0b3AgKz0gMjA7XG5cblx0XHQvLyBEZXRlcm1pbmUgdG9vbHRpcCBwb3NpdGlvblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcblx0XHRcdGNvbnN0IHJhdyA9ICQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcblxuXHRcdFx0aWYgKCFyYXcpIHtcblx0XHRcdFx0dG9wICs9ICQkLmhlaWdodCAvIDI7XG5cdFx0XHRcdGxlZnQgKz0gKCQkLndpZHRoIC0gKCQkLmlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCkpIC8gMjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZGF0YVNjYWxlID0gJCQueChkYXRhVG9TaG93WzBdLngpO1xuXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuXHRcdFx0XHR0b3AgPSBkYXRhU2NhbGUgKyAyMDtcblx0XHRcdFx0bGVmdCArPSBzdmdMZWZ0ICsgMTAwO1xuXHRcdFx0XHRjaGFydFJpZ2h0IC09IHN2Z0xlZnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b3AgLT0gNTtcblx0XHRcdFx0bGVmdCA9IHN2Z0xlZnQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQodHJ1ZSkgKyAyMCArICgkJC56b29tU2NhbGUgPyBsZWZ0IDogZGF0YVNjYWxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByaWdodCA9IGxlZnQgKyB0V2lkdGg7XG5cblx0XHRpZiAocmlnaHQgPiBjaGFydFJpZ2h0KSB7XG5cdFx0XHQvLyAyMCBpcyBuZWVkZWQgZm9yIEZpcmVmb3ggdG8ga2VlcCB0b29sdGlwIHdpZHRoXG5cdFx0XHRsZWZ0IC09IHJpZ2h0IC0gY2hhcnRSaWdodCArIDIwO1xuXHRcdH1cblxuXHRcdGlmICh0b3AgKyB0SGVpZ2h0ID4gJCQuY3VycmVudEhlaWdodCkge1xuXHRcdFx0dG9wIC09IHRIZWlnaHQgKyAzMDtcblx0XHR9XG5cblx0XHRpZiAodG9wIDwgMCkge1xuXHRcdFx0dG9wID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3RvcCwgbGVmdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIHRvb2x0aXBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGVkRGF0YVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG5cdCAqL1xuXHRzaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGVsZW1lbnQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGJpbmR0byA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmR0bztcblx0XHRjb25zdCBmb3JBcmMgPSAkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKTtcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcblx0XHRjb25zdCBwb3NpdGlvbkZ1bmN0aW9uID0gY29uZmlnLnRvb2x0aXBfcG9zaXRpb24gfHwgJCQudG9vbHRpcFBvc2l0aW9uO1xuXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZGF0dW0gPSAkJC50b29sdGlwLmRhdHVtKCk7XG5cdFx0Y29uc3QgZGF0YVN0ciA9IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRGF0YSk7XG5cdFx0bGV0IHdpZHRoID0gKGRhdHVtICYmIGRhdHVtLndpZHRoKSB8fCAwO1xuXHRcdGxldCBoZWlnaHQgPSAoZGF0dW0gJiYgZGF0dW0uaGVpZ2h0KSB8fCAwO1xuXG5cdFx0aWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHNlbGVjdGVkRGF0YS5jb25jYXQoKS5zb3J0KClbMF0uaW5kZXg7XG5cblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkKTtcblxuXHRcdFx0Ly8gc2V0IHRvb2x0aXAgY29udGVudFxuXHRcdFx0JCQudG9vbHRpcFxuXHRcdFx0XHQuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcblx0XHRcdFx0XHRzZWxlY3RlZERhdGEsXG5cdFx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcblx0XHRcdFx0XHQkJC5nZXRZRm9ybWF0KGZvckFyYyksXG5cdFx0XHRcdFx0JCQuY29sb3Jcblx0XHRcdFx0KSlcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcblx0XHRcdFx0LmRhdHVtKHtcblx0XHRcdFx0XHRpbmRleCxcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRXaWR0aFwiKSxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCA9ICQkLnRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRIZWlnaHRcIilcblx0XHRcdFx0fSk7XG5cblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3duLCAkJCk7XG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcblx0XHR9XG5cblx0XHRpZiAoIWJpbmR0bykge1xuXHRcdFx0Ly8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbkZ1bmN0aW9uLmNhbGwodGhpcywgZGF0YVRvU2hvdywgd2lkdGgsIGhlaWdodCwgZWxlbWVudCk7XG5cblx0XHRcdC8vIFNldCB0b29sdGlwIHBvc2l0aW9uXG5cdFx0XHQkJC50b29sdGlwXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBgJHtwb3NpdGlvbi50b3B9cHhgKVxuXHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGAke3Bvc2l0aW9uLmxlZnR9cHhgKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSB0byBoaWRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoaWRlVG9vbHRpcChmb3JjZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2RvTm90SGlkZSB8fCBmb3JjZSkge1xuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZSwgJCQpO1xuXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXBcblx0XHRcdHRoaXMudG9vbHRpcFxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpIC8vIGZvciBJRTlcblx0XHRcdFx0LmRhdHVtKG51bGwpO1xuXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRkZW4sICQkKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBkaXNwbGF5IGZvciBsaW5rZWQgY2hhcnQgaW5zdGFuY2VzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdyB0cnVlOiBzaG93LCBmYWxzZTogaGlkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggeCBBeGlzIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaGFuZGxlTGlua2VkQ2hhcnRzKHNob3csIGluZGV4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCQkLmNvbmZpZy50b29sdGlwX2xpbmtlZCkge1xuXHRcdFx0Y29uc3QgbGlua2VkTmFtZSA9ICQkLmNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xuXG5cdFx0XHQoJCQuYXBpLmludGVybmFsLmNoYXJ0cyB8fCBbXSkuZm9yRWFjaChjID0+IHtcblx0XHRcdFx0aWYgKGMgIT09ICQkLmFwaSkge1xuXHRcdFx0XHRcdGNvbnN0IGNvbmZpZyA9IGMuaW50ZXJuYWwuY29uZmlnO1xuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcblx0XHRcdFx0XHRjb25zdCBpc0luRG9tID0gZG9jdW1lbnQuYm9keS5jb250YWlucyhjLmVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0aWYgKGlzTGlua2VkICYmIGxpbmtlZE5hbWUgPT09IG5hbWUgJiYgaXNJbkRvbSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGMuaW50ZXJuYWwudG9vbHRpcC5kYXRhKClbMF07XG5cdFx0XHRcdFx0XHRjb25zdCBpc05vdFNhbWVJbmRleCA9IGluZGV4ICE9PSAoZGF0YSAmJiBkYXRhLmluZGV4KTtcblxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCB0aHJvd2luZyBlcnJvciBmb3Igbm9uLXBhaXJlZCBsaW5rZWQgaW5kZXhlc1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuc2hvdyh7aW5kZXh9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghc2hvdykge1xuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxuXHRldmVudCBhcyBkM0V2ZW50LFxuXHRuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlc1xufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZuLCBpc0RlZmluZWQsIGdldE9wdGlvbiwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgbm90RW1wdHksIHRwbFByb2Nlc3N9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0TGVnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQkJC5sZWdlbmRJdGVtVGV4dEJveCA9IHt9O1xuXHRcdCQkLmxlZ2VuZEhhc1JlbmRlcmVkID0gZmFsc2U7XG5cdFx0JCQubGVnZW5kID0gJCQuc3ZnLmFwcGVuZChcImdcIik7XG5cblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9zaG93KSB7XG5cdFx0XHQkJC5sZWdlbmQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xuXG5cdFx0XHQvLyBNRU1POiBjYWxsIGhlcmUgdG8gdXBkYXRlIGxlZ2VuZCBib3ggYW5kIHRyYW5zbGF0ZSBmb3IgYWxsXG5cdFx0XHQvLyBNRU1POiB0cmFuc2xhdGUgd2lsbCBiZSB1cGRhdGVkIGJ5IHRoaXMsIHNvIHRyYW5zZm9ybSBub3QgbmVlZGVkIGluIHVwZGF0ZUxlZ2VuZCgpXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0XHRcdCQkLmhpZGRlbkxlZ2VuZElkcyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIGVsZW1lbnRcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25zIFJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGVnZW5kKHRhcmdldElkcywgb3B0aW9ucywgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG9wdGlvbnogPSBvcHRpb25zIHx8IHtcblx0XHRcdHdpdGhUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlXG5cdFx0fTtcblxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgdHJ1ZSk7XG5cblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8gJiYgY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSkge1xuXHRcdFx0JCQudXBkYXRlTGVnZW5kVGVtcGxhdGUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCQudXBkYXRlTGVnZW5kRWxlbWVudChcblx0XHRcdFx0dGFyZ2V0SWRzIHx8ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksXG5cdFx0XHRcdG9wdGlvbnosXG5cdFx0XHRcdHRyYW5zaXRpb25zXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcblx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcblxuXHRcdC8vIFVwZGF0ZSBzaXplIGFuZCBzY2FsZVxuXHRcdCQkLnVwZGF0ZVNjYWxlcyhmYWxzZSwgISQkLnpvb21TY2FsZSk7XG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xuXG5cdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXG5cdFx0JCQudHJhbnNmb3JtQWxsKG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKTtcblxuXHRcdCQkLmxlZ2VuZEhhc1JlbmRlcmVkID0gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGxlZ2VuZCB1c2luZyB0ZW1wbGF0ZSBvcHRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgd3JhcHBlciA9IGQzU2VsZWN0KGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvKTtcblx0XHRjb25zdCB0ZW1wbGF0ZSA9IGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGU7XG5cblx0XHRpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cdFx0XHRjb25zdCBpZHMgPSBbXTtcblx0XHRcdGxldCBodG1sID0gXCJcIjtcblxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gaXNGdW5jdGlvbih0ZW1wbGF0ZSkgP1xuXHRcdFx0XHRcdHRlbXBsYXRlLmNhbGwoJCQsIHYsICQkLmNvbG9yKHYpLCAkJC5hcGkuZGF0YSh2KVswXS52YWx1ZXMpIDpcblx0XHRcdFx0XHR0cGxQcm9jZXNzKHRlbXBsYXRlLCB7XG5cdFx0XHRcdFx0XHRDT0xPUjogJCQuY29sb3IodiksXG5cdFx0XHRcdFx0XHRUSVRMRTogdlxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdFx0aWRzLnB1c2godik7XG5cdFx0XHRcdFx0aHRtbCArPSBjb250ZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzOyB9KVxuXHRcdFx0XHQuZGF0YShpZHMpO1xuXG5cdFx0XHQkJC5zZXRMZWdlbmRJdGVtKGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHQkJC5sZWdlbmQgPSB3cmFwcGVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBsZWdlbmQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNcblx0ICovXG5cdHVwZGF0ZVNpemVGb3JMZWdlbmQoc2l6ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcblxuXHRcdGNvbnN0IGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XG5cdFx0XHR0b3A6ICQkLmlzTGVnZW5kVG9wID9cblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSArIDUuNSA6XG5cdFx0XHRcdCQkLmN1cnJlbnRIZWlnaHQgLSBoZWlnaHQgLSAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF95LFxuXHRcdFx0bGVmdDogJCQuaXNMZWdlbmRMZWZ0ID9cblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAwLjUgOlxuXHRcdFx0XHQkJC5jdXJyZW50V2lkdGggLSB3aWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNVxuXHRcdH07XG5cblx0XHQkJC5tYXJnaW4zID0ge1xuXHRcdFx0dG9wOiAkJC5pc0xlZ2VuZFJpZ2h0ID9cblx0XHRcdFx0MCA6ICQkLmlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6ICQkLmN1cnJlbnRIZWlnaHQgLSBoZWlnaHQsXG5cdFx0XHRyaWdodDogTmFOLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogJCQuaXNMZWdlbmRSaWdodCA/XG5cdFx0XHRcdCQkLmN1cnJlbnRXaWR0aCAtIHdpZHRoIDogJCQuaXNMZWdlbmRJbnNldCA/IGluc2V0TGVnZW5kUG9zaXRpb24ubGVmdCA6IDBcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm0gTGVnZW5kXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICovXG5cdHRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLmxlZ2VuZC50cmFuc2l0aW9uKCkgOiAkJC5sZWdlbmQpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZCBzdGVwXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRTdGVwKHN0ZXApIHtcblx0XHR0aGlzLmxlZ2VuZFN0ZXAgPSBzdGVwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gd2lkdGhcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRJdGVtV2lkdGgodykge1xuXHRcdHRoaXMubGVnZW5kSXRlbVdpZHRoID0gdztcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KGgpIHtcblx0XHR0aGlzLmxlZ2VuZEl0ZW1IZWlnaHQgPSBoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxuXHQgKi9cblx0Z2V0TGVnZW5kV2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcblx0XHRcdCQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/XG5cdFx0XHRcdCQkLmxlZ2VuZEl0ZW1XaWR0aCAqICgkJC5sZWdlbmRTdGVwICsgMSkgOiAkJC5jdXJyZW50V2lkdGhcblx0XHQpIDogMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGVnZW5kSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXG5cdFx0XHQkJC5pc0xlZ2VuZFJpZ2h0ID9cblx0XHRcdFx0JCQuY3VycmVudEhlaWdodCA6IE1hdGgubWF4KDIwLCAkJC5sZWdlbmRJdGVtSGVpZ2h0KSAqICgkJC5sZWdlbmRTdGVwICsgMSlcblx0XHQpIDogMDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLlNlbGVjdFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBvcGFjaXR5XG5cdCAqL1xuXHRvcGFjaXR5Rm9yTGVnZW5kKGxlZ2VuZEl0ZW0pIHtcblx0XHRyZXR1cm4gbGVnZW5kSXRlbS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4pID8gbnVsbCA6IFwiMVwiO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZCB0aGF0IGlzIHVuZm9jdXNlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kSXRlbSwgZDMuU2VsZWN0XG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IG9wYWNpdHlcblx0ICovXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSkge1xuXHRcdHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogXCIwLjNcIjtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgZm9jdXMgb2YgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIGZvY3VzLlxuXHQgKi9cblx0dG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmb2N1cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCB0YXJnZXRJZHogPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuXG5cdFx0JCQubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxuXHRcdFx0LmZpbHRlcihpZCA9PiB0YXJnZXRJZHouaW5kZXhPZihpZCkgPj0gMClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmb2N1cylcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKGZvY3VzID8gJCQub3BhY2l0eUZvckxlZ2VuZCA6ICQkLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQpXG5cdFx0XHRcdFx0LmNhbGwoJCQsIGQzU2VsZWN0KHRoaXMpKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXZlcnQgdGhlIGxlZ2VuZCB0byBpdHMgZGVmYXVsdCBzdGF0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmV2ZXJ0TGVnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSlcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2hvd3MgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKi9cblx0c2hvd0xlZ2VuZCh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCFjb25maWcubGVnZW5kX3Nob3cpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IHRydWU7XG5cdFx0XHQkJC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcblxuXHRcdFx0ISQkLmxlZ2VuZEhhc1JlbmRlcmVkICYmICQkLnVwZGF0ZUxlZ2VuZCgpO1xuXHRcdH1cblx0XHQkJC5yZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcblxuXHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIGxlZ2VuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxuXHQgKi9cblx0aGlkZUxlZ2VuZCh0YXJnZXRJZHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdyAmJiBpc0VtcHR5KHRhcmdldElkcykpIHtcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuXHRcdFx0JCQubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0XHR9XG5cblx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcblx0XHQkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENsZWFyIHRoZSBMZWdlbmRJdGVtVGV4dEJveCBjYWNoZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSgpIHtcblx0XHR0aGlzLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBsZWdlbmQgaXRlbSBzdHlsZSAmIGJpbmQgZXZlbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBpdGVtXG5cdCAqL1xuXHRzZXRMZWdlbmRJdGVtKGl0ZW0pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzVG91Y2ggPSAkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcblxuXHRcdGl0ZW1cblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gaXRlbUNsYXNzICsgJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5sZWdlbmRJdGVtLCBpZCk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBpZCA9PiAoJCQuaXNMZWdlbmRUb1Nob3coaWQpID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSlcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcblx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29uY2xpY2ssICQkLCBpZCkpIHtcblx0XHRcdFx0XHRpZiAoZDNFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdCQkLmFwaS5oaWRlKCk7XG5cdFx0XHRcdFx0XHQkJC5hcGkuc2hvdyhpZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCQkLmFwaS50b2dnbGUoaWQpO1xuXHRcdFx0XHRcdFx0IWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gJCQuYXBpLmZvY3VzKGlkKSA6ICQkLmFwaS5yZXZlcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpc1RvdWNoICYmICQkLmhpZGVUb29sdGlwKCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICghaXNUb3VjaCkge1xuXHRcdFx0aXRlbVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm91dCwgJCQsIGlkKSkge1xuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0JCQuYXBpLnJldmVydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3ZlciwgJCQsIGlkKSkge1xuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRcdGlmICghJCQudHJhbnNpdGluZyAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkpIHtcblx0XHRcdFx0XHRcdFx0JCQuYXBpLmZvY3VzKGlkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsZWdlbmRcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cbiBcdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcGFkZGluZ1RvcCA9IDQ7XG5cdFx0Y29uc3QgcGFkZGluZ1JpZ2h0ID0gMTA7XG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XG5cdFx0Y29uc3QgdGlsZVdpZHRoID0gY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGggKyA1O1xuXHRcdGxldCBtYXhXaWR0aCA9IDA7XG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XG5cdFx0bGV0IHhGb3JMZWdlbmQ7XG5cdFx0bGV0IHlGb3JMZWdlbmQ7XG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcblx0XHRjb25zdCBvZmZzZXRzID0ge307XG5cdFx0Y29uc3Qgd2lkdGhzID0ge307XG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xuXHRcdGNvbnN0IG1hcmdpbnMgPSBbMF07XG5cdFx0Y29uc3Qgc3RlcHMgPSB7fTtcblx0XHRsZXQgc3RlcCA9IDA7XG5cdFx0bGV0IGJhY2tncm91bmQ7XG5cdFx0Y29uc3QgaXNMZWdlbmRSaWdodE9ySW5zZXQgPSAkJC5pc0xlZ2VuZFJpZ2h0IHx8ICQkLmlzTGVnZW5kSW5zZXQ7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxuXHRcdGNvbnN0IHRhcmdldElkeiA9IHRhcmdldElkc1xuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcblxuXHRcdGNvbnN0IHdpdGhUcmFuc2l0aW9uID0gb3B0aW9ucy53aXRoVHJhbnNpdGlvbjtcblxuXHRcdGNvbnN0IGdldFRleHRCb3ggPSBmdW5jdGlvbih0ZXh0RWxlbWVudCwgaWQpIHtcblx0XHRcdGlmICghJCQubGVnZW5kSXRlbVRleHRCb3hbaWRdKSB7XG5cdFx0XHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSA9XG5cdFx0XHRcdFx0JCQuZ2V0VGV4dFJlY3QodGV4dEVsZW1lbnQsIENMQVNTLmxlZ2VuZEl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gJCQubGVnZW5kSXRlbVRleHRCb3hbaWRdO1xuXHRcdH07XG5cblx0XHRjb25zdCB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbih0ZXh0RWxlbWVudCwgaWQsIGluZGV4KSB7XG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xuXHRcdFx0Y29uc3QgaXNMYXN0ID0gaW5kZXggPT09IHRhcmdldElkei5sZW5ndGggLSAxO1xuXHRcdFx0Y29uc3QgYm94ID0gZ2V0VGV4dEJveCh0ZXh0RWxlbWVudCwgaWQpO1xuXHRcdFx0Y29uc3QgaXRlbVdpZHRoID0gYm94LndpZHRoICsgdGlsZVdpZHRoICtcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcblx0XHRcdGNvbnN0IGl0ZW1IZWlnaHQgPSBib3guaGVpZ2h0ICsgcGFkZGluZ1RvcDtcblx0XHRcdGNvbnN0IGl0ZW1MZW5ndGggPSBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IGl0ZW1IZWlnaHQgOiBpdGVtV2lkdGg7XG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XG5cdFx0XHRsZXQgbWFyZ2luO1xuXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxuXHRcdFx0Y29uc3QgdXBkYXRlVmFsdWVzID0gZnVuY3Rpb24oaWQyLCB3aXRob3V0U3RlcCkge1xuXHRcdFx0XHRpZiAoIXdpdGhvdXRTdGVwKSB7XG5cdFx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSB0b3RhbExlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcblxuXHRcdFx0XHRcdGlmIChtYXJnaW4gPCBwb3NNaW4pIHtcblx0XHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gaXRlbUxlbmd0aCkgLyAyO1xuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0c3RlcCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0ZXBzW2lkMl0gPSBzdGVwO1xuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gJCQuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xuXHRcdFx0XHRvZmZzZXRzW2lkMl0gPSB0b3RhbExlbmd0aDtcblx0XHRcdFx0dG90YWxMZW5ndGggKz0gaXRlbUxlbmd0aDtcblx0XHRcdH07XG5cblx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cdFx0XHRcdHN0ZXAgPSAwO1xuXHRcdFx0XHRtYXhXaWR0aCA9IDA7XG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xuXHRcdFx0XHR3aWR0aHNbaWRdID0gMDtcblx0XHRcdFx0aGVpZ2h0c1tpZF0gPSAwO1xuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xuXHRcdFx0XHRvZmZzZXRzW2lkXSA9IDA7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xuXHRcdFx0aGVpZ2h0c1tpZF0gPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xuXHRcdFx0XHRtYXhXaWR0aCA9IGl0ZW1XaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFtYXhIZWlnaHQgfHwgaXRlbUhlaWdodCA+PSBtYXhIZWlnaHQpIHtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gaXRlbUhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWF4TGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBtYXhIZWlnaHQgOiBtYXhXaWR0aDtcblxuXHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRfZXF1YWxseSkge1xuXHRcdFx0XHRPYmplY3Qua2V5cyh3aWR0aHMpLmZvckVhY2goaWQyID0+ICh3aWR0aHNbaWQyXSA9IG1heFdpZHRoKSk7XG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcblx0XHRcdFx0bWFyZ2luID0gKGFyZWFMZW5ndGggLSBtYXhMZW5ndGggKiB0YXJnZXRJZHoubGVuZ3RoKSAvIDI7XG5cblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xuXHRcdFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcblx0XHRcdFx0XHRzdGVwID0gMDtcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVwZGF0ZVZhbHVlcyhpZCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVwZGF0ZVZhbHVlcyhpZCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmICgkJC5pc0xlZ2VuZEluc2V0KSB7XG5cdFx0XHRzdGVwID0gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwID8gY29uZmlnLmxlZ2VuZF9pbnNldF9zdGVwIDogdGFyZ2V0SWR6Lmxlbmd0aDtcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmlzTGVnZW5kUmlnaHQpIHtcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXJnaW5zW3N0ZXBzW2lkXV0gKyBvZmZzZXRzW2lkXTtcblx0XHR9IGVsc2UgaWYgKCQkLmlzTGVnZW5kSW5zZXQpIHtcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWF4SGVpZ2h0ICogc3RlcHNbaWRdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHhGb3JMZWdlbmRUZXh0ID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSArIDQgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcblx0XHRjb25zdCB4Rm9yTGVnZW5kUmVjdCA9IChpZCwgaSkgPT4geEZvckxlZ2VuZChpZCwgaSk7XG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XG5cdFx0Y29uc3QgeDJGb3JMZWdlbmRUaWxlID0gKGlkLCBpKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDIgKyBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aDtcblxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XG5cdFx0Y29uc3QgeUZvckxlZ2VuZFJlY3QgPSAoaWQsIGkpID0+IHlGb3JMZWdlbmQoaWQsIGkpIC0gNTtcblx0XHRjb25zdCB5Rm9yTGVnZW5kVGlsZSA9IChpZCwgaSkgPT4geUZvckxlZ2VuZChpZCwgaSkgKyA0O1xuXG5cdFx0Y29uc3QgcG9zID0gLTIwMDtcblxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxuXHRcdGNvbnN0IGwgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHQuZGF0YSh0YXJnZXRJZHopXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImdcIik7XG5cblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xuXG5cdFx0bC5hcHBlbmQoXCJ0ZXh0XCIpXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpZCwgaSkge1xuXHRcdFx0XHR1cGRhdGVQb3NpdGlvbnModGhpcywgaWQsIGkpO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geEZvckxlZ2VuZFRleHQgOiBwb3MpXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XG5cblx0XHRsLmFwcGVuZChcInJlY3RcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geEZvckxlZ2VuZFJlY3QgOiBwb3MpXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XG5cblx0XHRjb25zdCB1c2VQb2ludCA9ICQkLmNvbmZpZy5sZWdlbmRfdXNlUG9pbnQ7XG5cblx0XHRpZiAodXNlUG9pbnQpIHtcblx0XHRcdGNvbnN0IGlkcyA9IFtdO1xuXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcblx0XHRcdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/XG5cdFx0XHRcdFx0Y29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xuXG5cdFx0XHRcdGlkcy5pbmRleE9mKGQpID09PSAtMSAmJiBpZHMucHVzaChkKTtcblxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xuXG5cdFx0XHRcdGlmIChwb2ludCA9PT0gXCJyZWN0YW5nbGVcIikge1xuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XG5cdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1Qb2ludClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcblx0XHRcdFx0LmF0dHIoXCJocmVmXCIsIChkYXRhLCBpZHgsIHNlbGVjdGlvbikgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHskJC5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEl0ZW1UaWxlKVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8geDFGb3JMZWdlbmRUaWxlIDogcG9zKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGlzTGVnZW5kUmlnaHRPckluc2V0ID8gcG9zIDogeUZvckxlZ2VuZFRpbGUpXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgYmFja2dyb3VuZCBmb3IgaW5zZXQgbGVnZW5kXG5cdFx0YmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcblxuXHRcdGlmICgkJC5pc0xlZ2VuZEluc2V0ICYmIG1heFdpZHRoID4gMCAmJiBiYWNrZ3JvdW5kLnNpemUoKSA9PT0gMCkge1xuXHRcdFx0YmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kQmFja2dyb3VuZClcblx0XHRcdFx0LmFwcGVuZChcInJlY3RcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dHMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKFwidGV4dFwiKVxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxuXHRcdFx0LnRleHQoaWQgPT4gKGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQpKSAvLyBNRU1POiBuZWVkZWQgZm9yIHVwZGF0ZVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oaWQsIGkpIHtcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcblx0XHRcdH0pO1xuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXG5cdFx0XHQuYXR0cihcInhcIiwgeEZvckxlZ2VuZFRleHQpXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFRleHQpO1xuXG5cdFx0Y29uc3QgcmVjdHMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGByZWN0LiR7Q0xBU1MubGVnZW5kSXRlbUV2ZW50fWApXG5cdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xuXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVjdHMudHJhbnNpdGlvbigpIDogcmVjdHMpXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIGlkID0+IHdpZHRoc1tpZF0pXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kUmVjdClcblx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yTGVnZW5kUmVjdCk7XG5cblxuXHRcdGlmICh1c2VQb2ludCkge1xuXHRcdFx0Y29uc3QgdGlsZXMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcblxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9ICQkLmNvbmZpZy5wb2ludF9yO1xuXHRcdFx0XHRcdGxldCB4ID0gXCJ4XCI7XG5cdFx0XHRcdFx0bGV0IHkgPSBcInlcIjtcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XG5cdFx0XHRcdFx0bGV0IHlPZmZzZXQgPSAyLjU7XG5cdFx0XHRcdFx0bGV0IHJhZGl1cztcblx0XHRcdFx0XHRsZXQgd2lkdGg7XG5cdFx0XHRcdFx0bGV0IGhlaWdodDtcblxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IHBvaW50UiAqIDAuMjtcblxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcblx0XHRcdFx0XHRcdHkgPSBcImN5XCI7XG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBwb2ludFIgKyBzaXplO1xuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gLXNpemU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJyZWN0XCIpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XG5cblx0XHRcdFx0XHRcdHdpZHRoID0gc2l6ZTtcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XG5cdFx0XHRcdFx0XHR5T2Zmc2V0ID0gMztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxuXHRcdFx0XHRcdFx0LmF0dHIoeCwgZCA9PiB4MUZvckxlZ2VuZFRpbGUoZCkgKyB4T2Zmc2V0KVxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXG5cdFx0XHRcdFx0XHQuYXR0cihcInJcIiwgcmFkaXVzKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB0aWxlcyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xuXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIHgxRm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4MkZvckxlZ2VuZFRpbGUpXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgeUZvckxlZ2VuZFRpbGUpO1xuXHRcdH1cblxuXHRcdGlmIChiYWNrZ3JvdW5kKSB7XG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldExlZ2VuZEhlaWdodCgpIC0gMTIpXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4V2lkdGggKiAoc3RlcCArIDEpICsgMTApO1xuXHRcdH1cblxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcblx0XHQvLyAkJC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXG5cdFx0Ly8gXHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcblxuXHRcdC8vIFVwZGF0ZSBhbGwgdG8gcmVmbGVjdCBjaGFuZ2Ugb2YgbGVnZW5kXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcblx0XHQkJC51cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KG1heEhlaWdodCk7XG5cdFx0JCQudXBkYXRlTGVnZW5kU3RlcChzdGVwKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2V4dGVuZCwgaXNOdW1iZXIsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuXG4vKipcbiAqIEdldCB0aGUgdGV4dCBwb3NpdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHBvcyByaWdodCwgbGVmdCBvciBjZW50ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBjaGFydCB3aWR0aFxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn0gdGV4dC1hbmNob3IgdmFsdWUgb3IgcG9zaXRpb24gaW4gcGl4ZWxcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldFRleHRQb3MgPSAocG9zID0gXCJsZWZ0XCIsIHdpZHRoKSA9PiB7XG5cdGxldCBwb3NpdGlvbjtcblx0Y29uc3QgaXNOdW0gPSBpc051bWJlcih3aWR0aCk7XG5cblx0aWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpID4gLTEpIHtcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggLyAyIDogXCJtaWRkbGVcIjtcblx0fSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpID4gLTEpIHtcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggOiBcImVuZFwiO1xuXHR9IGVsc2Uge1xuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyAwIDogXCJzdGFydFwiO1xuXHR9XG5cblx0cmV0dXJuIHBvc2l0aW9uO1xufTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQuY29uZmlnLnRpdGxlX3RleHQpIHtcblx0XHRcdCQkLnRpdGxlID0gJCQuc3ZnLmFwcGVuZChcImdcIik7XG5cblx0XHRcdGNvbnN0IHRleHQgPSAkJC50aXRsZVxuXHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBnZXRUZXh0UG9zKCQkLmNvbmZpZy50aXRsZV9wb3NpdGlvbikpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudGl0bGUpO1xuXG5cdFx0XHRzZXRUZXh0VmFsdWUodGV4dCwgJCQuY29uZmlnLnRpdGxlX3RleHQsIFswLjMsIDEuNV0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRpdGxlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZWRyYXdUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRpZiAoJCQudGl0bGUpIHtcblx0XHRcdGNvbnN0IHkgPSAkJC55Rm9yVGl0bGUuY2FsbCgkJCk7XG5cblx0XHRcdGlmICgvZy9pLnRlc3QoJCQudGl0bGUubm9kZSgpLnRhZ05hbWUpKSB7XG5cdFx0XHRcdCQkLnRpdGxlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2dldFRleHRQb3MoJCQuY29uZmlnLnRpdGxlX3Bvc2l0aW9uLCAkJC5jdXJyZW50V2lkdGgpfSwgJHt5fSlgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnRpdGxlLmF0dHIoXCJ4XCIsICQkLnhGb3JUaXRsZS5jYWxsKCQkKSkuYXR0cihcInlcIiwgeSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0geCBhdHRyaWJ1dGUgdmFsdWVcblx0ICovXG5cdHhGb3JUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8IFwibGVmdFwiO1xuXHRcdGxldCB4O1xuXG5cdFx0aWYgKC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikpIHtcblx0XHRcdHggPSAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRUZXh0UmVjdCgkJC50aXRsZSwgQ0xBU1MudGl0bGUpLndpZHRoO1xuXG5cdFx0XHRpZiAocG9zaXRpb24uaW5kZXhPZihcInJpZ2h0XCIpID49IDApIHtcblx0XHRcdFx0eCAtPSAoY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmluZGV4T2YoXCJjZW50ZXJcIikgPj0gMCkge1xuXHRcdFx0XHR4IC89IDI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbGVmdFxuXHRcdFx0eCA9IChjb25maWcudGl0bGVfcGFkZGluZy5sZWZ0IHx8IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiB4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB5IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0geSBhdHRyaWJ1dGUgdmFsdWVcblx0ICovXG5cdHlGb3JUaXRsZSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCB8fCAwKSArXG5cdFx0XHQkJC5nZXRUZXh0UmVjdCgkJC50aXRsZSwgQ0xBU1MudGl0bGUpLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRpdGxlIHBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge051bWJlcn0gcGFkZGluZyB2YWx1ZVxuXHQgKi9cblx0Z2V0VGl0bGVQYWRkaW5nKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC55Rm9yVGl0bGUoKSArICgkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b20gfHwgMCk7XG5cdH0sXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0aW5pdENsaXAoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxuXHRcdCQkLmNsaXBJZCA9IGAkeyQkLmRhdGV0aW1lSWR9LWNsaXBgO1xuXG5cdFx0JCQuY2xpcElkRm9yWEF4aXMgPSBgJHskJC5jbGlwSWR9LXhheGlzYDtcblx0XHQkJC5jbGlwSWRGb3JZQXhpcyA9IGAkeyQkLmNsaXBJZH0teWF4aXNgO1xuXHRcdCQkLmNsaXBJZEZvckdyaWQgPSBgJHskJC5jbGlwSWR9LWdyaWRgO1xuXG5cdFx0Ly8gRGVmaW5lICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHQkJC5jbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZCk7XG5cdFx0JCQuY2xpcFBhdGhGb3JYQXhpcyA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvclhBeGlzKTtcblx0XHQkJC5jbGlwUGF0aEZvcllBeGlzID0gJCQuZ2V0Q2xpcFBhdGgoJCQuY2xpcElkRm9yWUF4aXMpO1xuXHRcdCQkLmNsaXBQYXRoRm9yR3JpZCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvckdyaWQpO1xuXHR9LFxuXG5cdGdldENsaXBQYXRoKGlkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcblx0XHRcdCghY29uZmlnLmF4aXNfeF9jbGlwUGF0aCAmJiAvLWNsaXAteGF4aXMkLy50ZXN0KGlkKSkgfHxcblx0XHRcdCghY29uZmlnLmF4aXNfeV9jbGlwUGF0aCAmJiAvLWNsaXAteWF4aXMkLy50ZXN0KGlkKSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XG5cdFx0XHR3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb25cblx0XHRcdFx0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1zaWUgOS5cIikgPj0gMCA6IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGB1cmwoJHsoaXNJRTkgPyBcIlwiIDogZG9jdW1lbnQuVVJMLnNwbGl0KFwiI1wiKVswXSl9IyR7aWR9KWA7XG5cdH0sXG5cblx0YXBwZW5kQ2xpcChwYXJlbnQsIGlkKSB7XG5cdFx0cmV0dXJuIHBhcmVudC5hcHBlbmQoXCJjbGlwUGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xuXHR9LFxuXG5cdGdldEF4aXNDbGlwWChmb3JIb3Jpem9udGFsKSB7XG5cdFx0Ly8gYXhpcyBsaW5lIHdpZHRoICsgcGFkZGluZyBmb3IgbGVmdFxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgdGhpcy5tYXJnaW4ubGVmdCk7XG5cblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0oMSArIGxlZnQpIDogLShsZWZ0IC0gMSk7XG5cdH0sXG5cblx0Z2V0QXhpc0NsaXBZKGZvckhvcml6b250YWwpIHtcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0yMCA6IC10aGlzLm1hcmdpbi50b3A7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwWCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fSxcblxuXHRnZXRYQXhpc0NsaXBZKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldFlBeGlzQ2xpcFgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xuXHRcdFx0LTEgOiAkJC5nZXRBeGlzQ2xpcFgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwWSgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBZKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuXHR9LFxuXG5cdGdldEF4aXNDbGlwV2lkdGgoZm9ySG9yaXpvbnRhbCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMzAsICQkLm1hcmdpbi5sZWZ0KTtcblx0XHRjb25zdCByaWdodCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ucmlnaHQpO1xuXG5cdFx0Ly8gd2lkdGggKyBheGlzIGxpbmUgd2lkdGggKyBwYWRkaW5nIGZvciBsZWZ0L3JpZ2h0XG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgP1xuXHRcdFx0JCQud2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogJCQubWFyZ2luLmxlZnQgKyAyMDtcblx0fSxcblxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsKSB7XG5cdFx0Ly8gbGVzcyB0aGFuIDIwIGlzIG5vdCBlbm91Z2ggdG8gc2hvdyB0aGUgYXhpcyBsYWJlbCAnb3V0ZXInIHdpdGhvdXQgbGVnZW5kXG5cdFx0cmV0dXJuIChmb3JIb3Jpem9udGFsID8gdGhpcy5tYXJnaW4uYm90dG9tIDogKHRoaXMubWFyZ2luLnRvcCArIHRoaXMuaGVpZ2h0KSkgKyAyMDtcblx0fSxcblxuXHRnZXRYQXhpc0NsaXBXaWR0aCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WEF4aXNDbGlwSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwV2lkdGgoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkgKyAoJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IDIwIDogMCk7XG5cdH0sXG5cblx0Z2V0WUF4aXNDbGlwSGVpZ2h0KCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiOyAvLyBzZWxlY3Rpb25cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7aXNWYWx1ZSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRpbml0UmVnaW9uKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLnJlZ2lvbiA9ICQkLm1haW4uYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGgpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnJlZ2lvbnMpO1xuXHR9LFxuXG5cdHVwZGF0ZVJlZ2lvbihkdXJhdGlvbikge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXG5cdFx0JCQucmVnaW9uLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xuXG5cdFx0Ly8gc2VsZWN0IDxnPiBlbGVtZW50XG5cdFx0JCQubWFpblJlZ2lvbiA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5yZWdpb259YClcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcblxuXHRcdCQkLm1haW5SZWdpb24uZXhpdCgpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQubWFpblJlZ2lvbiA9ICQkLm1haW5SZWdpb24uZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5tZXJnZSgkJC5tYWluUmVnaW9uKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc1JlZ2lvbi5iaW5kKCQkKSk7XG5cblx0XHQkJC5tYWluUmVnaW9uXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcblx0fSxcblxuXHRyZWRyYXdSZWdpb24od2l0aFRyYW5zaXRpb24pIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC5tYWluUmVnaW9uLnNlbGVjdChcInJlY3RcIik7XG5cblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcInlcIiwgJCQucmVnaW9uWS5iaW5kKCQkKSlcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5yZWdpb25IZWlnaHQuYmluZCgkJCkpO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucylcblx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIGQgPT4gKGlzVmFsdWUoZC5vcGFjaXR5KSA/IGQub3BhY2l0eSA6IFwiMC4xXCIpKVxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IHJlY3QgYWZ0ZXIgdHJhbnNpdGlvblxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMucGFyZW50Tm9kZSlcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cdFx0XHRcdH0pXG5cdFx0XTtcblx0fSxcblxuXHRnZXRSZWdpb25YWSh0eXBlLCBkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xuXHRcdGNvbnN0IGlzWCA9IHR5cGUgPT09IFwieFwiO1xuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XG5cdFx0bGV0IHNjYWxlO1xuXHRcdGxldCBwb3MgPSAwO1xuXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcblx0XHRcdGlmICghaXNYKSB7XG5cdFx0XHRcdGtleSA9IFwiZW5kXCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoaXNYID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcblx0XHRcdFx0c2NhbGUgPSAkJFtkLmF4aXNdO1xuXHRcdFx0XHRwb3MgPSBzY2FsZShkW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoKGlzWCA/ICFpc1JvdGF0ZWQgOiBpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XG5cdFx0XHRzY2FsZSA9ICQkLnpvb21TY2FsZSB8fCAkJC54O1xuXHRcdFx0cG9zID0gc2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvcztcblx0fSxcblxuXHRyZWdpb25YKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25YWShcInhcIiwgZCk7XG5cdH0sXG5cblx0cmVnaW9uWShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ5XCIsIGQpO1xuXHR9LFxuXG5cdGdldFJlZ2lvblNpemUodHlwZSwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xuXHRcdGNvbnN0IHN0YXJ0ID0gJCRbaXNXaWR0aCA/IFwicmVnaW9uWFwiIDogXCJyZWdpb25ZXCJdKGQpO1xuXHRcdGxldCBzY2FsZTtcblx0XHRsZXQga2V5ID0gXCJlbmRcIjtcblx0XHRsZXQgZW5kID0gJCRbdHlwZV07XG5cblx0XHRpZiAoZC5heGlzID09PSBcInlcIiB8fCBkLmF4aXMgPT09IFwieTJcIikge1xuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XG5cdFx0XHRcdGtleSA9IFwic3RhcnRcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKChpc1dpZHRoID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcblx0XHRcdFx0c2NhbGUgPSAkJFtkLmF4aXNdO1xuXHRcdFx0XHRlbmQgPSBzY2FsZShkW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xuXHRcdFx0c2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblx0XHRcdGVuZCA9IHNjYWxlKCQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGRba2V5XSkgOiBkW2tleV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmQgPCBzdGFydCA/IDAgOiBlbmQgLSBzdGFydDtcblx0fSxcblxuXHRyZWdpb25XaWR0aChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xuXHR9LFxuXG5cdHJlZ2lvbkhlaWdodChkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcImhlaWdodFwiLCBkKTtcblx0fSxcblxuXHRpc1JlZ2lvbk9uWChkKSB7XG5cdFx0cmV0dXJuICFkLmF4aXMgfHwgZC5heGlzID09PSBcInhcIjtcblx0fSxcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmQsIGdldFBhdGhCb3h9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGRyYWdnaW5nLlxuXHQgKiBEYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSBPYmplY3Rcblx0ICovXG5cdGRyYWcobW91c2UpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG1haW4gPSAkJC5tYWluO1xuXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fFxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkIHx8IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcblx0XHRcdChjb25maWcuem9vbV9lbmFibGVkICYmICEkJC56b29tLmFsdERvbWFpbikgfHwgLy8gc2tpcCBpZiB6b29tYWJsZSBiZWNhdXNlIG9mIGNvbmZsaWN0IGRyYWcgYmVoYXZpb3Jcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUgLy8gc2tpcCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gYmVjYXVzZSBkcmFnIGlzIHVzZWQgZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IFtzeCwgc3ldID0gJCQuZHJhZ1N0YXJ0O1xuXHRcdGNvbnN0IFtteCwgbXldID0gbW91c2U7XG5cblx0XHRjb25zdCBtaW5YID0gTWF0aC5taW4oc3gsIG14KTtcblx0XHRjb25zdCBtYXhYID0gTWF0aC5tYXgoc3gsIG14KTtcblx0XHRjb25zdCBtaW5ZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyAkJC5tYXJnaW4udG9wIDogTWF0aC5taW4oc3ksIG15KTtcblx0XHRjb25zdCBtYXhZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyAkJC5oZWlnaHQgOiBNYXRoLm1heChzeSwgbXkpO1xuXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXG5cdFx0XHQuYXR0cihcInhcIiwgbWluWClcblx0XHRcdC5hdHRyKFwieVwiLCBtaW5ZKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBtYXhYIC0gbWluWClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG1heFkgLSBtaW5ZKTtcblxuXHRcdC8vIFRPRE86IGJpbmFyeSBzZWFyY2ggd2hlbiBtdWx0aXBsZSB4c1xuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZmlsdGVyKGQgPT4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXHRcdFx0XHRjb25zdCBpc0luY2x1ZGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCk7XG5cdFx0XHRcdGxldCB0b2dnbGU7XG5cdFx0XHRcdGxldCBpc1dpdGhpbiA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcblx0XHRcdFx0XHRjb25zdCB4ID0gc2hhcGUuYXR0cihcImN4XCIpICogMTtcblx0XHRcdFx0XHRjb25zdCB5ID0gc2hhcGUuYXR0cihcImN5XCIpICogMTtcblxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBvaW50O1xuXHRcdFx0XHRcdGlzV2l0aGluID0gbWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpKSB7XG5cdFx0XHRcdFx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gZ2V0UGF0aEJveCh0aGlzKTtcblxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBhdGg7XG5cdFx0XHRcdFx0aXNXaXRoaW4gPSAhKG1heFggPCB4IHx8IHggKyB3aWR0aCA8IG1pblgpICYmICEobWF4WSA8IHkgfHwgeSArIGhlaWdodCA8IG1pblkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XG5cdFx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgIWlzSW5jbHVkZWQpO1xuXHRcdFx0XHRcdC8vIFRPRE86IGluY2x1ZGVkL3VuaW5jbHVkZWQgY2FsbGJhY2sgaGVyZVxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcblx0XHRcdFx0XHR0b2dnbGUuY2FsbCgkJCwgIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIHN0YXJ0cy5cblx0ICogQWRkcyBhbmQgU2hvd3MgdGhlIGRyYWcgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIE9iamVjdFxuXHQgKi9cblx0ZHJhZ3N0YXJ0KG1vdXNlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQuZHJhZ1N0YXJ0ID0gbW91c2U7XG5cblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmRyYWdhcmVhKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjAuMVwiKTtcblxuXHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBkcmFnIGZpbmlzaGVzLlxuXHQgKiBSZW1vdmVzIHRoZSBkcmFnIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmFnZW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkgeyAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcblx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsIGZhbHNlKTtcblxuXHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xuXHR9LFxuXG5cdHNldERyYWdTdGF0dXMoaXNEcmFnZ2luZykge1xuXHRcdHRoaXMuZHJhZ2dpbmcgPSBpc0RyYWdnaW5nO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3JnYiBhcyBkM1JnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZufSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogU2VsZWN0IGEgcG9pbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICovXG5cdHNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblx0XHRjb25zdCBjeCA9IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkuYmluZCgkJCk7XG5cdFx0Y29uc3QgY3kgPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpO1xuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcblxuXHRcdC8vIGFkZCBzZWxlY3RlZC1jaXJjbGUgb24gbG93IGxheWVyIGdcblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcblx0XHRcdC5kYXRhKFtkXSlcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwiY2lyY2xlXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICgpID0+ICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2VsZWN0ZWRDaXJjbGUsIGkpKVxuXHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcblx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpXG5cdFx0XHQuYXR0cihcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5hdHRyKFwiclwiLCBkMiA9PiAkJC5wb2ludFNlbGVjdFIoZDIpICogMS40KVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKDEwMClcblx0XHRcdC5hdHRyKFwiclwiLCByKTtcblx0fSxcblxuXHQvKipcblx0ICogVW5lbGVjdCBhIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHR1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGNhbGxGbigkJC5jb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG5cblx0XHQvLyByZW1vdmUgc2VsZWN0ZWQtY2lyY2xlIGZyb20gbG93IGxheWVyIGdcblx0XHQkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbigxMDApXG5cdFx0XHQuYXR0cihcInJcIiwgMClcblx0XHRcdC5yZW1vdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHBvaW50c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHNlbGVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICovXG5cdHRvZ2dsZVBvaW50KHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcblx0XHRjb25zdCBtZXRob2QgPSBgJHtzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCJ9c2VsZWN0UG9pbnRgO1xuXG5cdFx0dGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNlbGVjdCBhIHBhdGhcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqL1xuXHRzZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xuXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gZDNSZ2IoJCQuY29sb3IoZCkpLmJyaWdodGVyKDAuNzUpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVuZWxlY3QgYSBwYXRoXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcGF0aFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cblx0dW5zZWxlY3RQYXRoKHRhcmdldCwgZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJCwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG5cblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiAkJC5jb2xvcihkKSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgbGluZXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHR0b2dnbGVQYXRoKHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcblx0XHR0aGlzW1xuXHRcdFx0YCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBhdGhgXG5cdFx0XSh0YXJnZXQsIGQsIGkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b2dnbGUgbWV0aG9kIG9mIHRoZSB0YXJnZXRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBzaGFwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRvZ2dsZSBtZXRob2Rcblx0ICovXG5cdGdldFRvZ2dsZSh0aGF0LCBkKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiID9cblx0XHRcdCQkLnRvZ2dsZVBhdGggOiAoXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xuXHRcdFx0XHRcdCgpID0+IHt9IDogLy8gY2lyY2xlIGlzIGhpZGRlbiBpbiBzdGVwIGNoYXJ0LCBzbyB0cmVhdCBhcyB3aXRoaW4gdGhlIGNsaWNrIGFyZWFcblx0XHRcdFx0XHQkJC50b2dnbGVQb2ludFxuXHRcdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHNoYXBlc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKi9cblx0dG9nZ2xlU2hhcGUodGhhdCwgZCwgaSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcblx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoYXQsIGQpLmJpbmQoJCQpO1xuXHRcdGxldCB0b2dnbGVkU2hhcGU7XG5cblx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSkge1xuXHRcdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUpIHtcblx0XHRcdFx0bGV0IHNlbGVjdG9yID0gYC4ke0NMQVNTLnNoYXBlc31gO1xuXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkge1xuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JCQubWFpbi5zZWxlY3RBbGwoc2VsZWN0b3IpXG5cdFx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCkpIHtcblx0XHRcdFx0XHRcdFx0dG9nZ2xlZFNoYXBlID0gc2hhcGU7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0b2dnbGVkU2hhcGUgfHwgdG9nZ2xlZFNoYXBlLm5vZGUoKSAhPT0gc2hhcGUubm9kZSgpKSB7XG5cdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcblx0XHRcdFx0dG9nZ2xlKCFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge1xuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXG5cdGV2ZW50IGFzIGQzRXZlbnRcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtcblx0YnJ1c2hYIGFzIGQzQnJ1c2hYLFxuXHRicnVzaFkgYXMgZDNCcnVzaFksXG5cdGJydXNoU2VsZWN0aW9uIGFzIGQzQnJ1c2hTZWxlY3Rpb25cbn0gZnJvbSBcImQzLWJydXNoXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kLCBicnVzaEVtcHR5LCBjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBnZXRSYW5kb219IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGJydXNoLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdEJydXNoKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcblxuXHRcdC8vIHNldCB0aGUgYnJ1c2hcblx0XHQkJC5icnVzaCA9IGlzUm90YXRlZCA/IGQzQnJ1c2hZKCkgOiBkM0JydXNoWCgpO1xuXG5cdFx0Ly8gc2V0IFwiYnJ1c2hcIiBldmVudFxuXHRcdGNvbnN0IGJydXNoSGFuZGxlciA9ICgpID0+IHtcblx0XHRcdCQkLnJlZHJhd0ZvckJydXNoKCk7XG5cdFx0fTtcblx0XHRjb25zdCBnZXRCcnVzaFNpemUgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBicnVzaCA9ICQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xuXHRcdFx0Y29uc3QgYnJ1c2hTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XG5cdFx0XHRcdGJydXNoU2l6ZS53aWR0aCA9ICticnVzaC5hdHRyKFwid2lkdGhcIik7XG5cdFx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJydXNoU2l6ZVtpc1JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcblx0XHR9O1xuXG5cdFx0bGV0IGxhc3REb21haW47XG5cdFx0bGV0IHRpbWVvdXQ7XG5cblx0XHQkJC5icnVzaFxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgKCkgPT4ge1xuXHRcdFx0XHQkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5oaWRlVG9vbHRpcCgpO1xuXHRcdFx0XHRicnVzaEhhbmRsZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJicnVzaFwiLCBicnVzaEhhbmRsZXIpXG5cdFx0XHQub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRsYXN0RG9tYWluID0gJCQueC5vcmdEb21haW4oKTtcblx0XHRcdH0pO1xuXG5cdFx0JCQuYnJ1c2gudXBkYXRlUmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRsYXN0RG9tYWluICYmIGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uLm5vZGUoKSkgJiZcblx0XHRcdFx0XHR0aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcCgkJC5zdWJYLm9yZ1NjYWxlKCkpKTtcblx0XHRcdH0sIDApO1xuXHRcdH07XG5cblx0XHQkJC5icnVzaC51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMuZXh0ZW50KCkoKTtcblxuXHRcdFx0aWYgKGV4dGVudFsxXS5maWx0ZXIodiA9PiBpc05hTih2KSkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdCQkLmNvbnRleHQgJiYgJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvLyBzZXQgdGhlIGJydXNoIGV4dGVudFxuXHRcdCQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRcdGNvbnN0IGggPSBjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgfHwgZ2V0QnJ1c2hTaXplKCk7XG5cdFx0XHRsZXQgZXh0ZW50ID0gJCQuZ2V0RXh0ZW50KCk7XG5cblx0XHRcdGlmICghZXh0ZW50ICYmIHNjYWxlLnJhbmdlKSB7XG5cdFx0XHRcdGV4dGVudCA9IFtbMCwgMF0sIFtzY2FsZS5yYW5nZSgpWzFdLCBoXV07XG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZXh0ZW50KSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKCh2LCBpKSA9PiBbdiwgaSA+IDAgPyBoIDogaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBbW3gwLCB5MF0sIFt4MSwgeTFdXSwgd2hlcmUgW3gwLCB5MF0gaXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBhbmQgW3gxLCB5MV0gaXMgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXJcblx0XHRcdGlzUm90YXRlZCAmJiBleHRlbnRbMV0ucmV2ZXJzZSgpO1xuXHRcdFx0dGhpcy5leHRlbnQoZXh0ZW50KTtcblxuXHRcdFx0Ly8gd2hlbiBleHRlbnQgdXBkYXRlcywgYnJ1c2ggc2VsZWN0aW9uIGFsc28gYmUgcmUtYXBwbGllZFxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cblx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24gPSAoKSA9PiAoXG5cdFx0XHQkJC5jb250ZXh0ID8gJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApIDogZDNTZWxlY3QoW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgc3ViY2hhcnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0U3ViY2hhcnQoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG5cdFx0Y29uc3QgY2xpcElkID0gYCR7JCQuY2xpcElkfS1zdWJjaGFydGA7XG5cdFx0Y29uc3QgY2xpcFBhdGggPSAkJC5nZXRDbGlwUGF0aChjbGlwSWQpO1xuXG5cdFx0JCQuY2xpcElkRm9yU3ViY2hhcnQgPSBjbGlwSWQ7XG5cdFx0JCQuYXBwZW5kQ2xpcCgkJC5kZWZzLCBjbGlwSWQpO1xuXHRcdCQkLmluaXRCcnVzaCgpO1xuXG5cdFx0JCQuY29udGV4dCA9ICQkLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XG5cblx0XHRjb25zdCBjb250ZXh0ID0gJCQuY29udGV4dDtcblxuXHRcdGNvbnRleHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIHZpc2liaWxpdHkpO1xuXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcblx0XHRjb250ZXh0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydCk7XG5cblx0XHQvLyBEZWZpbmUgZyBmb3IgYmFyIGNoYXJ0IGFyZWFcblx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxuXHRcdFx0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcblxuXHRcdC8vIERlZmluZSBnIGZvciBsaW5lIGNoYXJ0IGFyZWFcblx0XHRjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcblx0XHRcdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xuXG5cdFx0Ly8gQWRkIGV4dGVudCByZWN0IGZvciBCcnVzaFxuXHRcdGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmJydXNoKVxuXHRcdFx0LmNhbGwoJCQuYnJ1c2gpO1xuXG5cdFx0Ly8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXG5cdFx0Ly8gQWRkIEF4aXNcblx0XHQkJC5heGVzLnN1YnggPSBjb250ZXh0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpc1gpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJzdWJ4XCIpKVxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiAkJC5jbGlwUGF0aEZvclhBeGlzKVxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgPyB2aXNpYmlsaXR5IDogXCJoaWRkZW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9ICQkLmRhdGEudGFyZ2V0c1xuXHQgKi9cblx0dXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29udGV4dCA9ICQkLmNvbnRleHQ7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcblx0XHRjb25zdCBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xuXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XG5cdFx0XHQvLyAtLSBCYXIgLS0vL1xuXHRcdFx0Y29uc3QgY29udGV4dEJhclVwZGF0ZSA9IGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKTtcblx0XHRcdGNvbnN0IGNvbnRleHRCYXJFbnRlciA9IGNvbnRleHRCYXJVcGRhdGUuZW50ZXIoKVxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXG5cdFx0XHRcdC5tZXJnZShjb250ZXh0QmFyVXBkYXRlKTtcblxuXHRcdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXG5cdFx0XHRjb250ZXh0QmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XG5cblx0XHRcdC8vIC0tIExpbmUgLS0vL1xuXHRcdFx0Y29uc3QgY29udGV4dExpbmVVcGRhdGUgPSBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSk7XG5cdFx0XHRjb25zdCBjb250ZXh0TGluZUVudGVyID0gY29udGV4dExpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXG5cdFx0XHRcdC5tZXJnZShjb250ZXh0TGluZVVwZGF0ZSk7XG5cblx0XHRcdC8vIExpbmVzIGZvciBlYWNoIGRhdGFcblx0XHRcdGNvbnRleHRMaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGluZXMpO1xuXG5cdFx0XHQvLyBBcmVhXG5cdFx0XHQkJC5oYXNUeXBlKFwiYXJlYVwiKSAmJiBjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcblxuXHRcdFx0Ly8gLS0gQnJ1c2ggLS0vL1xuXHRcdFx0Y29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcblx0XHRcdFx0LmF0dHIoY29uZmlnLmF4aXNfcm90YXRlZCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aDIgOiAkJC5oZWlnaHQyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uRm9yRXhpdFxuXHQgKi9cblx0dXBkYXRlQmFyRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuY29udGV4dEJhciA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXG5cdFx0XHQuZGF0YSgkJC5iYXJEYXRhLmJpbmQoJCQpKTtcblxuXHRcdCQkLmNvbnRleHRCYXJcblx0XHRcdC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQuY29udGV4dEJhciA9ICQkLmNvbnRleHRCYXJcblx0XHRcdC5lbnRlcigpXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0Jhci5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBcIm5vbmVcIilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXG5cdFx0XHQubWVyZ2UoJCQuY29udGV4dEJhcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgYmFyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHJlZHJhd0JhckZvclN1YmNoYXJ0KGRyYXdCYXJPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dEJhciA9IHdpdGhUcmFuc2l0aW9uID9cblx0XHRcdHRoaXMuY29udGV4dEJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxuXHRcdFx0dGhpcy5jb250ZXh0QmFyO1xuXG5cdFx0Y29udGV4dEJhci5hdHRyKFwiZFwiLCBkcmF3QmFyT25TdWIpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsaW5lIG9mIHRoZSBzdWIgY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cblx0ICovXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cblx0XHQkJC5jb250ZXh0TGluZSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZX1gKVxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuXG5cdFx0JCQuY29udGV4dExpbmVcblx0XHRcdC5leGl0KClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0JCQuY29udGV4dExpbmUgPSAkJC5jb250ZXh0TGluZVxuXHRcdFx0LmVudGVyKClcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzTGluZS5iaW5kKCQkKSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcblx0XHRcdC5tZXJnZSgkJC5jb250ZXh0TGluZSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGxpbmUgb2YgdGhlIHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXdMaW5lRm9yU3ViY2hhcnQoZHJhd0xpbmVPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dExpbmUgPSB3aXRoVHJhbnNpdGlvbiA/XG5cdFx0XHR0aGlzLmNvbnRleHRMaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6XG5cdFx0XHR0aGlzLmNvbnRleHRMaW5lO1xuXG5cdFx0Y29udGV4dExpbmUuYXR0cihcImRcIiwgZHJhd0xpbmVPblN1Yilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGFyZWEgb2YgdGhlIHN1YiBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxuXHQgKi9cblx0dXBkYXRlQXJlYUZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdCQkLmNvbnRleHRBcmVhID0gJCQuY29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWFzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG5cblx0XHQkJC5jb250ZXh0QXJlYVxuXHRcdFx0LmV4aXQoKVxuXHRcdFx0LnRyYW5zaXRpb24oKVxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHQkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHRBcmVhXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQkLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xuXHRcdFx0XHRyZXR1cm4gXCIwXCI7XG5cdFx0XHR9KVxuXHRcdFx0Lm1lcmdlKCQkLmNvbnRleHRBcmVhKVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XG5cdH0sXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGFyZWEgb2YgdGhlIHN1YmNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXdBcmVhRm9yU3ViY2hhcnQoZHJhd0FyZWFPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgY29udGV4dEFyZWEgPSB3aXRoVHJhbnNpdGlvbiA/XG5cdFx0XHR0aGlzLmNvbnRleHRBcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6XG5cdFx0XHR0aGlzLmNvbnRleHRBcmVhO1xuXG5cdFx0Y29udGV4dEFyZWEuYXR0cihcImRcIiwgZHJhd0FyZWFPblN1Yilcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5vcmdBcmVhT3BhY2l0eSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyBzdWJjaGFydC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gZHVyYXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IHNoYXBlIFNoYXBlJ3MgaW5mb1xuXHQgKi9cblx0cmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0JCQuY29udGV4dC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xuXG5cdFx0Ly8gc3ViY2hhcnRcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcblx0XHRcdC8vIHJlZmxlY3QgbWFpbiBjaGFydCB0byBleHRlbnQgb24gc3ViY2hhcnQgaWYgem9vbWVkXG5cdFx0XHRpZiAoZDNFdmVudCAmJiBkM0V2ZW50LnR5cGUgPT09IFwiem9vbVwiKSB7XG5cdFx0XHRcdCQkLmJydXNoLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgc3ViY2hhcnQgZWxlbWVudHMgaWYgbmVlZGVkXG5cdFx0XHRpZiAod2l0aFN1YmNoYXJ0KSB7XG5cdFx0XHRcdC8vIGV4dGVudCByZWN0XG5cdFx0XHRcdCFicnVzaEVtcHR5KCQkKSAmJiAkJC5icnVzaC51cGRhdGUoKTtcblxuXHRcdFx0XHRPYmplY3Qua2V5cyhzaGFwZS50eXBlKS5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjYXBpdGFsaXplKHYpO1xuXHRcdFx0XHRcdGNvbnN0IGRyYXcgPSAkJFtgZ2VuZXJhdGVEcmF3JHtuYW1lfWBdKHNoYXBlLmluZGljZXNbdl0sIHRydWUpO1xuXG5cdFx0XHRcdFx0JCRbYHVwZGF0ZSR7bmFtZX1Gb3JTdWJjaGFydGBdKGR1cmF0aW9uKTtcblx0XHRcdFx0XHQkJFtgcmVkcmF3JHtuYW1lfUZvclN1YmNoYXJ0YF0oZHJhdywgZHVyYXRpb24sIGR1cmF0aW9uKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIGJydXNoLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVkcmF3Rm9yQnJ1c2goKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcdHdpdGhZOiAkJC5jb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLmNvbmZpZy5zdWJjaGFydF9vbmJydXNoLmNhbGwoJCQuYXBpLCAkJC54Lm9yZ0RvbWFpbigpKTtcblx0fSxcblxuXHQvKipcblx0ICogVHJhbnNmb3JtIGNvbnRleHRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmRpY2F0ZXMgdHJhbnNpdGlvbiBpcyBlbmFibGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zIG1ldGhvZCBvZiBBeGlzLlxuXHQgKi9cblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IHN1YlhBeGlzO1xuXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNTdWJYKSB7XG5cdFx0XHRzdWJYQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNTdWJYO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdWJYQXhpcyA9ICQkLmNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKTtcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikgeyBzdWJYQXhpcyA9IHN1YlhBeGlzLnRyYW5zaXRpb24oKTsgfVxuXHRcdH1cblxuXHRcdCQkLmNvbnRleHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YnhcIikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgZXh0ZW50IHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZGVmYXVsdCBleHRlbnRcblx0ICovXG5cdGdldEV4dGVudCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0bGV0IGV4dGVudCA9ICQkLmNvbmZpZy5heGlzX3hfZXh0ZW50O1xuXG5cdFx0aWYgKGV4dGVudCkge1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oZXh0ZW50KSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpLCAkJC5zdWJYKTtcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gJCQuc3ViWCgkJC5wYXJzZURhdGUodikpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW50O1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7XG5cdG1vdXNlIGFzIGQzTW91c2UsXG5cdGV2ZW50IGFzIGQzRXZlbnQsXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IHt6b29tIGFzIGQzWm9vbX0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uL2ludGVybmFscy9icm93c2VyXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2V4dGVuZCwgY2FsbEZuLCBkaWZmRG9tYWluLCBnZXRNaW5NYXgsIGlzRGVmaW5lZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB6b29tLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdFpvb20oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0JCQuem9vbVNjYWxlID0gbnVsbDtcblxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xuXHRcdCQkLmluaXRab29tQmVoYXZpb3VyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJpbmQgem9vbSBldmVudFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSAkJC5jb25maWcuem9vbV9lbmFibGVkO1xuXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XG5cblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XG5cblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xuXHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcblx0XHR9IGVsc2UgaWYgKGJpbmQgPT09IGZhbHNlKSB7XG5cdFx0XHQkJC5hcGkudW56b29tKCk7XG5cblx0XHRcdGV2ZW50UmVjdHNcblx0XHRcdFx0Lm9uKFwiLnpvb21cIiwgbnVsbClcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB6b29tXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZW5lcmF0ZVpvb20oKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGNvbnN0IHpvb20gPSBkM1pvb20oKS5kdXJhdGlvbigwKVxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXG5cdFx0XHQub24oXCJ6b29tXCIsICQkLm9uWm9vbS5iaW5kKCQkKSlcblx0XHRcdC5vbihcImVuZFwiLCAkJC5vblpvb21FbmQuYmluZCgkJCkpO1xuXG5cdFx0Ly8gZ2V0IHpvb20gZXh0ZW50XG5cdFx0em9vbS5vcmdTY2FsZUV4dGVudCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xuXG5cdFx0XHRyZXR1cm4gW2V4dGVudFswXSwgTWF0aC5tYXgoJCQuZ2V0TWF4RGF0YUNvdW50KCkgLyBleHRlbnRbMV0sIGV4dGVudFsxXSldO1xuXHRcdH07XG5cblx0XHR6b29tLnVwZGF0ZVNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLm9yZ1NjYWxlRXh0ZW50KCk7XG5cblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUgPSB0cmFuc2Zvcm0gPT4ge1xuXHRcdFx0Ly8gaW4gY2FzZSBvZiByZXNpemUsIHVwZGF0ZSByYW5nZSBvZiBvcmdYU2NhbGVcblx0XHRcdCQkLm9yZ1hTY2FsZSAmJiAkJC5vcmdYU2NhbGUucmFuZ2UoJCQueC5yYW5nZSgpKTtcblxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxuXHRcdFx0Y29uc3QgbmV3U2NhbGUgPSB0cmFuc2Zvcm1bXG5cdFx0XHRcdGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJlc2NhbGVZXCIgOiBcInJlc2NhbGVYXCJcblx0XHRcdF0oJCQub3JnWFNjYWxlIHx8ICQkLngpO1xuXG5cdFx0XHRjb25zdCBkb21haW4gPSAkJC50cmltWERvbWFpbihuZXdTY2FsZS5kb21haW4oKSk7XG5cdFx0XHRjb25zdCByZXNjYWxlID0gY29uZmlnLnpvb21fcmVzY2FsZTtcblxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKGRvbWFpbiwgJCQub3JnWERvbWFpbik7XG5cblx0XHRcdCQkLnpvb21TY2FsZSA9ICQkLmdldEN1c3RvbWl6ZWRTY2FsZShuZXdTY2FsZSk7XG5cdFx0XHQkJC54QXhpcy5zY2FsZSgkJC56b29tU2NhbGUpO1xuXG5cdFx0XHRpZiAocmVzY2FsZSkge1xuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxuXHRcdFx0XHQhJCQub3JnWFNjYWxlICYmICgkJC5vcmdYU2NhbGUgPSAkJC54LmNvcHkoKSk7XG5cdFx0XHRcdCQkLnguZG9tYWluKGRvbWFpbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdCQkLnpvb20gPSB6b29tO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiAnc3RhcnQnIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvblpvb21TdGFydCgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50O1xuXG5cdFx0aWYgKCFldmVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLnpvb20uc3RhcnRFdmVudCA9IGV2ZW50O1xuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb21zdGFydCwgJCQuYXBpLCBldmVudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25ab29tKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xuXG5cdFx0aWYgKFxuXHRcdFx0IWNvbmZpZy56b29tX2VuYWJsZWQgfHxcblx0XHRcdCFldmVudC5zb3VyY2VFdmVudCB8fFxuXHRcdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCA9PT0gMFxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzTW91c2Vtb3ZlID0gZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIjtcblx0XHRjb25zdCBpc1pvb21PdXQgPSBldmVudC5zb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMDtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XG5cblx0XHRpZiAoIWlzTW91c2Vtb3ZlICYmIGlzWm9vbU91dCAmJiAkJC54LmRvbWFpbigpLmV2ZXJ5KCh2LCBpKSA9PiB2ICE9PSAkJC5vcmdYRG9tYWluW2ldKSkge1xuXHRcdFx0JCQueC5kb21haW4oJCQub3JnWERvbWFpbik7XG5cdFx0fVxuXG5cdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSh0cmFuc2Zvcm0pO1xuXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiAkJC54Lm9yZ0RvbWFpbigpWzBdID09PSAkJC5vcmdYRG9tYWluWzBdKSB7XG5cdFx0XHQkJC54LmRvbWFpbihbJCQub3JnWERvbWFpblswXSAtIDFlLTEwLCAkJC54Lm9yZ0RvbWFpbigpWzFdXSk7XG5cdFx0fVxuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLmNhbmNlbENsaWNrID0gaXNNb3VzZW1vdmU7XG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgJCQuYXBpLCAkJC56b29tU2NhbGUuZG9tYWluKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiAnZW5kJyBldmVudCBsaXN0ZW5lclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25ab29tRW5kKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBzdGFydEV2ZW50ID0gJCQuem9vbS5zdGFydEV2ZW50O1xuXG5cdFx0Ly8gaWYgY2xpY2ssIGRvIG5vdGhpbmcuIG90aGVyd2lzZSwgY2xpY2sgaW50ZXJhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cblx0XHRpZiAoIXN0YXJ0RXZlbnQgfHxcblx0XHRcdChldmVudCAmJiBzdGFydEV2ZW50LmNsaWVudFggPT09IGV2ZW50LmNsaWVudFggJiYgc3RhcnRFdmVudC5jbGllbnRZID09PSBldmVudC5jbGllbnRZKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuXHRcdCQkLnVwZGF0ZVpvb20oKTtcblxuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb21lbmQsICQkLmFwaSwgJCRbJCQuem9vbVNjYWxlID8gXCJ6b29tU2NhbGVcIiA6IFwic3ViWFwiXS5kb21haW4oKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB6b29tIGRvbWFpblxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHpvb20gZG9tYWluXG4gXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Wm9vbURvbWFpbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGxldCBbbWluLCBtYXhdID0gJCQub3JnWERvbWFpbjtcblxuXHRcdGlmIChpc0RlZmluZWQoY29uZmlnLnpvb21feF9taW4pKSB7XG5cdFx0XHRtaW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW21pbiwgY29uZmlnLnpvb21feF9taW5dKTtcblx0XHR9XG5cblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWF4KSkge1xuXHRcdFx0bWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFttYXgsIGNvbmZpZy56b29tX3hfbWF4XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB6b29tXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgdW56b29tXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVab29tKGZvcmNlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXG5cdFx0aWYgKCQkLnpvb21TY2FsZSkge1xuXHRcdFx0Y29uc3Qgem9vbURvbWFpbiA9ICQkLnpvb21TY2FsZS5kb21haW4oKTtcblx0XHRcdGNvbnN0IHhEb21haW4gPSAkJC5zdWJYLmRvbWFpbigpO1xuXHRcdFx0Y29uc3QgZGVsdGEgPSAwLjAxNTsgLy8gYXJiaXRyYXJ5IHZhbHVlXG5cblx0XHRcdGNvbnN0IGlzZnVsbHlTaG93biA9ICh6b29tRG9tYWluWzBdIDw9IHhEb21haW5bMF0gfHwgKHpvb21Eb21haW5bMF0gLSBkZWx0YSkgPD0geERvbWFpblswXSkgJiZcblx0XHRcdFx0KHhEb21haW5bMV0gPD0gem9vbURvbWFpblsxXSB8fCB4RG9tYWluWzFdIDw9ICh6b29tRG9tYWluWzFdIC0gZGVsdGEpKTtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHpvb21lZCBjaGFydCBpcyBmdWxseSBzaG93biwgdGhlbiByZXNldCBzY2FsZSB3aGVuIHpvb20gaXMgb3V0IGFzIGluaXRpYWxcblx0XHRcdGlmIChmb3JjZSB8fCBpc2Z1bGx5U2hvd24pIHtcblx0XHRcdFx0JCQueEF4aXMuc2NhbGUoJCQuc3ViWCk7XG5cdFx0XHRcdCQkLnguZG9tYWluKCQkLnN1Ylgub3JnRG9tYWluKCkpO1xuXHRcdFx0XHQkJC56b29tU2NhbGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQXR0YWNoIHpvb20gZXZlbnQgb24gPHJlY3Q+XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRiaW5kWm9vbU9uRXZlbnRSZWN0KGV2ZW50UmVjdHMsIHR5cGUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgYmVoYXZpb3VyID0gdHlwZSA9PT0gXCJkcmFnXCIgPyAkJC56b29tQmVoYXZpb3VyIDogJCQuem9vbTtcblxuXHRcdGV2ZW50UmVjdHNcblx0XHRcdC5jYWxsKGJlaGF2aW91cilcblx0XHRcdC5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0Wm9vbUJlaGF2aW91cigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XG5cdFx0bGV0IHN0YXJ0ID0gMDtcblx0XHRsZXQgZW5kID0gMDtcblx0XHRsZXQgem9vbVJlY3QgPSBudWxsO1xuXG5cdFx0Y29uc3QgcHJvcCA9IHtcblx0XHRcdGF4aXM6IGlzUm90YXRlZCA/IFwieVwiIDogXCJ4XCIsXG5cdFx0XHRhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxuXHRcdFx0aW5kZXg6IGlzUm90YXRlZCA/IDEgOiAwXG5cdFx0fTtcblxuXHRcdCQkLnpvb21CZWhhdmlvdXIgPSBkM0RyYWcoKVxuXHRcdFx0LmNsaWNrRGlzdGFuY2UoNClcblx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkJC5zZXREcmFnU3RhdHVzKHRydWUpO1xuXG5cdFx0XHRcdGlmICghem9vbVJlY3QpIHtcblx0XHRcdFx0XHR6b29tUmVjdCA9ICQkLm1haW4uYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuY2xpcFBhdGgpXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnpvb21CcnVzaClcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgaXNSb3RhdGVkID8gJCQud2lkdGggOiAwKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6ICQkLmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGFydCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XG5cdFx0XHRcdGVuZCA9IHN0YXJ0O1xuXG5cdFx0XHRcdHpvb21SZWN0XG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBzdGFydClcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIDApO1xuXG5cdFx0XHRcdCQkLm9uWm9vbVN0YXJ0KCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwiZHJhZ1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZW5kID0gZDNNb3VzZSh0aGlzKVtwcm9wLmluZGV4XTtcblxuXHRcdFx0XHR6b29tUmVjdFxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgTWF0aC5taW4oc3RhcnQsIGVuZCkpXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xuXHRcdFx0fSlcblx0XHRcdC5vbihcImVuZFwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gJCQuem9vbVNjYWxlIHx8ICQkLng7XG5cblx0XHRcdFx0JCQuc2V0RHJhZ1N0YXR1cyhmYWxzZSk7XG5cblx0XHRcdFx0em9vbVJlY3Rcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIDApXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCAwKTtcblxuXHRcdFx0XHRpZiAoc3RhcnQgPiBlbmQpIHtcblx0XHRcdFx0XHRbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhcnQgPCAwKSB7XG5cdFx0XHRcdFx0ZW5kICs9IE1hdGguYWJzKHN0YXJ0KTtcblx0XHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhcnQgIT09IGVuZCkge1xuXHRcdFx0XHRcdCQkLmFwaS56b29tKFtzdGFydCwgZW5kXS5tYXAodiA9PiBzY2FsZS5pbnZlcnQodikpKTtcblx0XHRcdFx0XHQkJC5vblpvb21FbmQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUy5iaW5kKHRoaXMpKCQkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50IHx8IGQzRXZlbnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBbeCwgeV0gPSBcImNsaWVudFhcIiBpbiBldmVudCA/IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXSA6IFtldmVudC54LCBldmVudC55XTtcblx0XHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG5cblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0YXJnZXQpKGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKSwgJCQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0c2V0Wm9vbVJlc2V0QnV0dG9uKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgcmVzZXRCdXR0b24gPSBjb25maWcuem9vbV9yZXNldEJ1dHRvbjtcblxuXHRcdGlmIChyZXNldEJ1dHRvbiAmJiBjb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiKSB7XG5cdFx0XHRpZiAoISQkLnpvb20ucmVzZXRCdG4pIHtcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0biA9ICQkLnNlbGVjdENoYXJ0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvbiwgdHJ1ZSlcblx0XHRcdFx0XHQuYXBwZW5kKFwic3BhblwiKVxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsICQkLmFwaS51bnpvb20uYmluZCgkJCkpXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uWm9vbVJlc2V0LCB0cnVlKVxuXHRcdFx0XHRcdC50ZXh0KHJlc2V0QnV0dG9uLnRleHQgfHwgXCJSZXNldCBab29tXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3NjYWxlT3JkaW5hbCBhcyBkM1NjYWxlT3JkaW5hbH0gZnJvbSBcImQzLXNjYWxlXCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9DaGFydEludGVybmFsXCI7XG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7bm90RW1wdHksIGV4dGVuZCwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzU3RyaW5nfSBmcm9tIFwiLi91dGlsXCI7XG5cbi8qKlxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXG4gKiAoaXQgYWRkcyBhIDxyZWN0PiBlbGVtZW50IHRvIHNpbXVsYXRlIGJnLWNvbG9yKVxuICogQHBhcmFtIHtTVkdQYXR0ZXJuRWxlbWVudH0gcGF0dGVybiBTVkcgcGF0dGVybiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgSUQgdG8gYmUgc2V0XG4gKiBAcmV0dXJuIHt7aWQ6IHN0cmluZywgbm9kZTogU1ZHUGF0dGVybkVsZW1lbnR9fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY29sb3JpemVQYXR0ZXJuID0gKHBhdHRlcm4sIGNvbG9yLCBpZCkgPT4ge1xuXHRjb25zdCBub2RlID0gZDNTZWxlY3QocGF0dGVybi5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdG5vZGVcblx0XHQuYXR0cihcImlkXCIsIGlkKVxuXHRcdC5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpXG5cdFx0LmF0dHIoXCJ3aWR0aFwiLCBub2RlLmF0dHIoXCJ3aWR0aFwiKSlcblx0XHQuYXR0cihcImhlaWdodFwiLCBub2RlLmF0dHIoXCJoZWlnaHRcIikpXG5cdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cblx0cmV0dXJuIHtcblx0XHRpZCxcblx0XHRub2RlOiBub2RlLm5vZGUoKVxuXHR9O1xufTtcblxuLy8gUmVwbGFjZW1lbnQgb2YgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5cbi8vIENvbnRhaW5lZCBkaWZmZXJlbnRseSBkZXBlbmQgb24gZDMgdmVyc2lvbjogdjQoZDMtc2NhbGUpLCB2NShkMy1zY2FsZS1jaHJvbWF0aWMpXG5jb25zdCBzY2hlbWVDYXRlZ29yeTEwID0gW1wiIzFmNzdiNFwiLCBcIiNmZjdmMGVcIiwgXCIjMmNhMDJjXCIsIFwiI2Q2MjcyOFwiLCBcIiM5NDY3YmRcIiwgXCIjOGM1NjRiXCIsIFwiI2UzNzdjMlwiLCBcIiM3ZjdmN2ZcIiwgXCIjYmNiZDIyXCIsIFwiIzE3YmVjZlwiXTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZXQgY29sb3IgcGF0dGVybiBmcm9tIENTUyBmaWxlXG5cdCAqIENTUyBzaG91bGQgYmUgZGVmaW5lZCBhczogYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiIzAwYzczYzsjZmE3MTcxOyAuLi5cIik7XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q29sb3JGcm9tQ3NzKCkge1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCJfX2NvbG9yUGF0dGVybl9fXCI7XG5cdFx0Y29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0bGV0IHBhdHRlcm4gPSBib2R5W2NhY2hlS2V5XTtcblxuXHRcdGlmICghcGF0dGVybikge1xuXHRcdFx0Y29uc3QgZGVsaW1pdGVyID0gXCI7XCI7XG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cblx0XHRcdHNwYW4uY2xhc3NOYW1lID0gQ0xBU1MuY29sb3JQYXR0ZXJuO1xuXHRcdFx0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xuXG5cdFx0XHRjb25zdCBjb250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuYmFja2dyb3VuZEltYWdlO1xuXG5cdFx0XHRzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XG5cblx0XHRcdGlmIChjb250ZW50LmluZGV4T2YoZGVsaW1pdGVyKSA+IC0xKSB7XG5cdFx0XHRcdHBhdHRlcm4gPSBjb250ZW50XG5cdFx0XHRcdFx0LnJlcGxhY2UoL3VybFteI10qfFtcIicoKV18KFxcc3wlMjApL2csIFwiXCIpXG5cdFx0XHRcdFx0LnNwbGl0KGRlbGltaXRlcilcblx0XHRcdFx0XHQubWFwKHYgPT4gdi50cmltKCkucmVwbGFjZSgvW1xcXCInXFxzXS9nLCBcIlwiKSlcblx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdFx0XHRcdGJvZHlbY2FjaGVLZXldID0gcGF0dGVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0dGVybjtcblx0fSxcblxuXHRnZW5lcmF0ZUNvbG9yKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0Y29uc3QgY29sb3JzID0gY29uZmlnLmRhdGFfY29sb3JzO1xuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XG5cdFx0Y29uc3QgaWRzID0gW107XG5cblx0XHRsZXQgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5jb2xvcl9wYXR0ZXJuKSA/IGNvbmZpZy5jb2xvcl9wYXR0ZXJuIDpcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XG5cblx0XHRjb25zdCBvcmlnaW5hbENvbG9yUGF0dGVybiA9IHBhdHRlcm47XG5cblx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcuY29sb3JfdGlsZXMpKSB7XG5cdFx0XHRjb25zdCB0aWxlcyA9IGNvbmZpZy5jb2xvcl90aWxlcygpO1xuXG5cdFx0XHQvLyBBZGQgYmFja2dyb3VuZCBjb2xvciB0byBwYXR0ZXJuc1xuXHRcdFx0Y29uc3QgY29sb3JpemVkUGF0dGVybnMgPSBwYXR0ZXJuLm1hcCgocCwgaW5kZXgpID0+IHtcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBwLnJlcGxhY2UoL1sjXFwoXFwpXFxzLF0vZywgXCJcIik7XG5cdFx0XHRcdGNvbnN0IGlkID0gYCR7JCQuZGF0ZXRpbWVJZH0tcGF0dGVybi0ke2NvbG9yfS0ke2luZGV4fWA7XG5cblx0XHRcdFx0cmV0dXJuIGNvbG9yaXplUGF0dGVybih0aWxlc1tpbmRleCAlIHRpbGVzLmxlbmd0aF0sIHAsIGlkKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRwYXR0ZXJuID0gY29sb3JpemVkUGF0dGVybnMubWFwKHAgPT4gYHVybCgjJHtwLmlkfSlgKTtcblx0XHRcdCQkLnBhdHRlcm5zID0gY29sb3JpemVkUGF0dGVybnM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcblx0XHRcdGNvbnN0IGlkID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcblx0XHRcdGNvbnN0IGlzTGluZSA9ICQkLmlzVHlwZU9mKGlkLCBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwic3RlcFwiXSkgfHwgISQkLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcblx0XHRcdGxldCBjb2xvcjtcblxuXHRcdFx0Ly8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWRcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbG9yc1tpZF0pKSB7XG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXShkKTtcblxuXHRcdFx0Ly8gaWYgc3BlY2lmaWVkLCBjaG9vc2UgdGhhdCBjb2xvclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXTtcblxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxuXHRcdFx0XHRcdHBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgcGF0dGVybi5sZW5ndGhdO1xuXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cblx0XHRcdFx0Y2FsbGJhY2soY29sb3IsIGQpIDogY29sb3I7XG5cdFx0fTtcblx0fSxcblxuXHRnZW5lcmF0ZUxldmVsQ29sb3IoKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblx0XHRjb25zdCBjb2xvcnMgPSBjb25maWcuY29sb3JfcGF0dGVybjtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSBjb25maWcuY29sb3JfdGhyZXNob2xkO1xuXHRcdGNvbnN0IGFzVmFsdWUgPSB0aHJlc2hvbGQudW5pdCA9PT0gXCJ2YWx1ZVwiO1xuXHRcdGNvbnN0IG1heCA9IHRocmVzaG9sZC5tYXggfHwgMTAwO1xuXHRcdGNvbnN0IHZhbHVlcyA9IHRocmVzaG9sZC52YWx1ZXMgJiZcblx0XHRcdHRocmVzaG9sZC52YWx1ZXMubGVuZ3RoID8gdGhyZXNob2xkLnZhbHVlcyA6IFtdO1xuXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRocmVzaG9sZCkgPyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y29uc3QgdiA9IGFzVmFsdWUgPyB2YWx1ZSA6ICh2YWx1ZSAqIDEwMCAvIG1heCk7XG5cdFx0XHRsZXQgY29sb3IgPSBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKHYgPD0gdmFsdWVzW2ldKSB7XG5cdFx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbG9yO1xuXHRcdH0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRhdGEgb3ZlciBjb2xvci5cblx0ICogV2hlbiBpcyBvdXQsIHdpbGwgcmVzdG9yZSBpbiBpdHMgcHJldmlvdXMgY29sb3IgdmFsdWVcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc092ZXIgdHJ1ZTogc2V0IG92ZXJlZCBjb2xvciwgZmFsc2U6IHJlc3RvcmVcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldE92ZXJDb2xvcihpc092ZXIsIGQpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRcdGNvbnN0IG9ub3ZlciA9IGNvbmZpZy5jb2xvcl9vbm92ZXI7XG5cdFx0bGV0IGNvbG9yID0gaXNPdmVyID8gb25vdmVyIDogJCQuY29sb3I7XG5cblx0XHRpZiAoaXNPYmplY3QoY29sb3IpKSB7XG5cdFx0XHRjb2xvciA9IGQgPT4ge1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuaWQ7XG5cblx0XHRcdFx0cmV0dXJuIGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3IpKSB7XG5cdFx0XHRjb2xvciA9ICgpID0+IG9ub3Zlcjtcblx0XHR9XG5cblx0XHQvLyB3aGVuIGlzIEFyYyB0eXBlXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XG5cdFx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfS0ke2QuaWR9YClcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcihkKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBjb2xvcihkKTtcblxuXHRcdFx0XHRcdHRoaXMuc3R5bGUuc3Ryb2tlID0gdmFsO1xuXHRcdFx0XHRcdHRoaXMuc3R5bGUuZmlsbCA9IHZhbDtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7aXNWYWx1ZSwgaXNGdW5jdGlvbiwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuY29uc3QgZ2V0Rm9ybWF0ID0gKCQkLCB0eXBlVmFsdWUsIHYpID0+IHtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRjb25zdCB0eXBlID0gYGF4aXNfJHt0eXBlVmFsdWV9X3RpY2tfZm9ybWF0YDtcblx0Y29uc3QgZm9ybWF0ID0gY29uZmlnW3R5cGVdID9cblx0XHRjb25maWdbdHlwZV0gOiAkJC5kZWZhdWx0VmFsdWVGb3JtYXQ7XG5cblx0cmV0dXJuIGZvcm1hdCh2KTtcbn07XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHRnZXRZRm9ybWF0KGZvckFyYykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRsZXQgZm9ybWF0Rm9yWSA9ICQkLnlGb3JtYXQ7XG5cdFx0bGV0IGZvcm1hdEZvclkyID0gJCQueTJGb3JtYXQ7XG5cblx0XHRpZiAoZm9yQXJjICYmICEkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcblx0XHRcdGZvcm1hdEZvclkgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XG5cdFx0XHRmb3JtYXRGb3JZMiA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odiwgcmF0aW8sIGlkKSB7XG5cdFx0XHRjb25zdCBmb3JtYXQgPSAkJC5heGlzLmdldElkKGlkKSA9PT0gXCJ5MlwiID9cblx0XHRcdFx0Zm9ybWF0Rm9yWTIgOiBmb3JtYXRGb3JZO1xuXG5cdFx0XHRyZXR1cm4gZm9ybWF0LmNhbGwoJCQsIHYsIHJhdGlvKTtcblx0XHR9O1xuXHR9LFxuXG5cdHlGb3JtYXQodikge1xuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xuXHR9LFxuXG5cdHkyRm9ybWF0KHYpIHtcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieTJcIiwgdik7XG5cdH0sXG5cblx0ZGVmYXVsdFZhbHVlRm9ybWF0KHYpIHtcblx0XHRyZXR1cm4gaXNWYWx1ZSh2KSA/ICt2IDogXCJcIjtcblx0fSxcblxuXHRkZWZhdWx0QXJjVmFsdWVGb3JtYXQodiwgcmF0aW8pIHtcblx0XHRyZXR1cm4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDEpfSVgO1xuXHR9LFxuXG5cdGRhdGFMYWJlbEZvcm1hdCh0YXJnZXRJZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzO1xuXHRcdGNvbnN0IGRlZmF1bHRGb3JtYXQgPSB2ID0+IChpc1ZhbHVlKHYpID8gK3YgOiBcIlwiKTtcblx0XHRsZXQgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdDtcblxuXHRcdC8vIGZpbmQgZm9ybWF0IGFjY29yZGluZyB0byBheGlzIGlkXG5cdFx0aWYgKGlzRnVuY3Rpb24oZGF0YUxhYmVscy5mb3JtYXQpKSB7XG5cdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdDtcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzLmZvcm1hdCkpIHtcblx0XHRcdGlmIChkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF0pIHtcblx0XHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID9cblx0XHRcdFx0XHRkZWZhdWx0Rm9ybWF0IDogZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9ybWF0ID0gKCkgPT4gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZm9ybWF0O1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWxcIjtcbmltcG9ydCB7dG9BcnJheSwgZXh0ZW5kfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQWRkIGNhY2hlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGF0YVR5cGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFkZENhY2hlKGtleSwgdmFsdWUsIGlzRGF0YVR5cGUgPSBmYWxzZSkge1xuXHRcdHRoaXMuY2FjaGVba2V5XSA9IGlzRGF0YVR5cGUgPyB0aGlzLmNsb25lVGFyZ2V0KHZhbHVlKSA6IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgY2FjaGVcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVtb3ZlQ2FjaGUoa2V5KSB7XG5cdFx0dG9BcnJheShrZXkpLmZvckVhY2godiA9PiBkZWxldGUgdGhpcy5jYWNoZVt2XSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjYWhjZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEYXRhVHlwZVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0Q2FjaGUoa2V5LCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcblx0XHRpZiAoaXNEYXRhVHlwZSkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWQ7IChpZCA9IGtleVtpXSk7IGkrKykge1xuXHRcdFx0XHRpZiAoaWQgaW4gdGhpcy5jYWNoZSkge1xuXHRcdFx0XHRcdHRhcmdldHMucHVzaCh0aGlzLmNsb25lVGFyZ2V0KHRoaXMuY2FjaGVbaWRdKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV0gfHwgbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIHJlc2V0IGNhY2hlZCBkYXRhXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIHRydWU6IHJlc2V0IGFsbCBkYXRhLCBmYWxzZTogcmVzZXQgb25seSAnJCcgcHJlZml4ZWQga2V5IGRhdGFcblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRyZXNldENhY2hlKGFsbCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdGZvciAoY29uc3QgeCBpbiAkJC5jYWNoZSkge1xuXHRcdFx0Ly8gcmVzZXQgdGhlIHByZWZpeGVkICckJyBrZXkod2hpY2ggaXMgaW50ZXJuYWwgdXNlIGRhdGEpIG9ubHkuXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XG5cdFx0XHRcdCQkLmNhY2hlW3hdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdGdlbmVyYXRlQ2xhc3MocHJlZml4LCB0YXJnZXRJZCkge1xuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XG5cdH0sXG5cblx0Y2xhc3NUZXh0KGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHQsIGQuaW5kZXgpO1xuXHR9LFxuXG5cdGNsYXNzVGV4dHMoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dHMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzU2hhcGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xuXHR9LFxuXG5cdGNsYXNzU2hhcGVzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlcywgZC5pZCk7XG5cdH0sXG5cblx0Z2VuZXJhdGVFeHRyYUxpbmVDbGFzcygpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XG5cdFx0Y29uc3QgaWRzID0gW107XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xuXHRcdFx0Y29uc3QgaWQgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xuXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xuXHRcdFx0XHRpZHMucHVzaChpZCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGFzc2VzW2lkcy5pbmRleE9mKGlkKSAlIGNsYXNzZXMubGVuZ3RoXTtcblx0XHR9O1xuXHR9LFxuXG5cdGNsYXNzTGluZShkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc0xpbmVzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lcywgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaXJjbGUoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuY2lyY2xlLCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc0NpcmNsZXMoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZXMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzQmFyKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhciwgZC5pbmRleCk7XG5cdH0sXG5cblx0Y2xhc3NCYXJzKGQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5iYXJzLCBkLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyYyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyYywgZC5kYXRhLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyY3MoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjcywgZC5kYXRhLmlkKTtcblx0fSxcblxuXHRjbGFzc0FyZWEoZCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYSwgZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NBcmVhcyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYXMsIGQuaWQpO1xuXHR9LFxuXG5cdGNsYXNzUmVnaW9uKGQsIGkpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnJlZ2lvbiwgaSl9ICR7XCJjbGFzc1wiIGluIGQgPyBkLmNsYXNzIDogXCJcIn1gO1xuXHR9LFxuXG5cdGNsYXNzRXZlbnQoZCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuZXZlbnRSZWN0LCBkLmluZGV4KTtcblx0fSxcblxuXHRjbGFzc1RhcmdldChpZCkge1xuXHRcdGNvbnN0IGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCA9IHRoaXMuY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF07XG5cdFx0bGV0IGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XG5cblx0XHRpZiAoYWRkaXRpb25hbENsYXNzU3VmZml4KSB7XG5cdFx0XHRhZGRpdGlvbmFsQ2xhc3MgPSBgICR7Q0xBU1MudGFyZ2V0fS0ke2FkZGl0aW9uYWxDbGFzc1N1ZmZpeH1gO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XG5cdH0sXG5cblx0Y2xhc3NGb2N1cyhkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NGb2N1c2VkKGQpICsgdGhpcy5jbGFzc0RlZm9jdXNlZChkKTtcblx0fSxcblxuXHRjbGFzc0ZvY3VzZWQoZCkge1xuXHRcdHJldHVybiBgICR7dGhpcy5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiBcIlwifWA7XG5cdH0sXG5cblx0Y2xhc3NEZWZvY3VzZWQoZCkge1xuXHRcdHJldHVybiBgICR7dGhpcy5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogXCJcIn1gO1xuXHR9LFxuXG5cdGNsYXNzQ2hhcnRUZXh0KGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRUZXh0ICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcblx0fSxcblxuXHRjbGFzc0NoYXJ0TGluZShkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydEJhcihkKSB7XG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcblx0fSxcblxuXHRjbGFzc0NoYXJ0QXJjKGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRBcmMgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuZGF0YS5pZCk7XG5cdH0sXG5cblx0Y2xhc3NDaGFydFJhZGFyKGQpIHtcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRSYWRhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG5cdH0sXG5cblx0Z2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpIHtcblx0XHRyZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgP1xuXHRcdFx0YC0ke3RhcmdldElkfWAucmVwbGFjZSgvW1xccz8hQCMkJV4mKigpXz0rLC48PidcIjo7XFxbXFxdXFwvfH5ge31cXFxcXS9nLCBcIi1cIikgOiBcIlwiO1xuXHR9LFxuXG5cdHNlbGVjdG9yVGFyZ2V0KGlkLCBwcmVmaXgpIHtcblx0XHRyZXR1cm4gYCR7cHJlZml4IHx8IFwiXCJ9LiR7Q0xBU1MudGFyZ2V0ICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YDtcblx0fSxcblxuXHRzZWxlY3RvclRhcmdldHMoaWRzVmFsdWUsIHByZWZpeCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblx0XHRjb25zdCBpZHMgPSBpZHNWYWx1ZSB8fCBbXTtcblxuXHRcdHJldHVybiBpZHMubGVuZ3RoID9cblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQsIHByZWZpeCkpIDogbnVsbDtcblx0fSxcblxuXHRzZWxlY3RvckxlZ2VuZChpZCkge1xuXHRcdHJldHVybiBgLiR7Q0xBU1MubGVnZW5kSXRlbSArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XG5cdH0sXG5cblx0c2VsZWN0b3JMZWdlbmRzKGlkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcztcblxuXHRcdHJldHVybiBpZHMgJiYgaWRzLmxlbmd0aCA/XG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yTGVnZW5kKGlkKSkgOiBudWxsO1xuXHR9LFxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuXHQgKiBAbWV0aG9kIGZvY3VzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBkYXRhMSB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XG5cdCAqICBjaGFydC5mb2N1cyhcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxuXHQgKiBjaGFydC5mb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZFxuXHQgKiBjaGFydC5mb2N1cygpO1xuXHQgKi9cblx0Zm9jdXModGFyZ2V0SWRzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkJC5zdmcuc2VsZWN0QWxsKFxuXHRcdFx0JCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZXZlcnQoKTtcblx0XHR0aGlzLmRlZm9jdXMoKTtcblxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCB0cnVlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xuXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XG5cblx0XHQkJC5mb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9ICQkLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgQVBJIGZhZGVzIG91dCBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgcmV2ZXJ0cyB0aGUgb3RoZXJzLjxicj48YnI+XG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxuXHQgKiBAbWV0aG9kIGRlZm9jdXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gVGFyZ2V0IGlkcyB0byBiZSBmYWRlZCBvdXQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LmRlZm9jdXMoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LmRlZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxuXHQgKiBjaGFydC5kZWZvY3VzKCk7XG5cdCAqL1xuXHRkZWZvY3VzKHRhcmdldElkc1ZhbHVlKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuc3ZnLnNlbGVjdEFsbChcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXG5cdFx0KTtcblxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCBmYWxzZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIHRydWUpO1xuXHRcdCQkLmhhc0FyY1R5cGUoKSAmJiAkJC51bmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgZmFsc2UpO1xuXG5cdFx0JCQuZm9jdXNlZFRhcmdldElkcyA9ICQkLmZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xuXHRcdCQkLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBBUEkgcmV2ZXJ0cyBzcGVjaWZpZWQgdGFyZ2V0cy48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBAbWV0aG9kIHJldmVydFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBUYXJnZXQgaWRzIHRvIGJlIHJldmVydGVkXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgcmV2ZXJ0ZWQuXG5cdCAqIGNoYXJ0LnJldmVydChcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSByZXZlcnRlZC5cblx0ICogY2hhcnQucmV2ZXJ0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxuXHQgKiBjaGFydC5yZXZlcnQoKTtcblx0ICovXG5cdHJldmVydCh0YXJnZXRJZHNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXG5cblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XG5cblx0XHRpZiAoJCQuY29uZmlnLmxlZ2VuZF9zaG93KSB7XG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcblx0XHRcdCQkLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXG5cdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdCQkLmZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcblx0XHQkJC5kZWZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBTaG93L0hpZGUgZGF0YSBzZXJpZXNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zaG93SGlkZShzaG93LCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XG5cblx0XHQkJFtgJHtzaG93ID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJ9SGlkZGVuVGFyZ2V0SWRzYF0odGFyZ2V0SWRzKTtcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XG5cdFx0Y29uc3Qgb3BhY2l0eSA9IHNob3cgPyBcIjFcIiA6IFwiMFwiO1xuXG5cdFx0dGFyZ2V0cy50cmFuc2l0aW9uKClcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSwgXCJpbXBvcnRhbnRcIilcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgKCkgPT4ge1xuXHRcdFx0XHR0YXJnZXRzLnN0eWxlKFwib3BhY2l0eVwiLCBudWxsKS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XG5cdFx0XHR9KTtcblxuXHRcdG9wdGlvbnMud2l0aExlZ2VuZCAmJiAkJFtgJHtzaG93ID8gXCJzaG93XCIgOiBcImhpZGVcIn1MZWdlbmRgXSh0YXJnZXRJZHMpO1xuXG5cdFx0JCQucmVkcmF3KHtcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgZGF0YSBzZXJpZXMgb24gY2hhcnRcblx0ICogQG1ldGhvZCBzaG93XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHNob3cgJ2RhdGExJ1xuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIHNob3cgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xuXHQgKi9cblx0c2hvdyh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fc2hvd0hpZGUodHJ1ZSwgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcblx0ICogQG1ldGhvZCBoaWRlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGhpZGUgJ2RhdGExJ1xuXHQgKiBjaGFydC5oaWRlKFwiZGF0YTFcIik7XG5cdCAqXG5cdCAqIC8vIGhpZGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xuXHQgKi9cblx0aGlkZSh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fc2hvd0hpZGUoZmFsc2UsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXG5cdCAqIEBtZXRob2QgdG9nZ2xlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZT1hbGxdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cblx0ICpcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnXG5cdCAqIGNoYXJ0LnRvZ2dsZShcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xuXHQgKiBjaGFydC50b2dnbGUoW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XG5cdCAqL1xuXHR0b2dnbGUodGFyZ2V0SWRzLCBvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHtzaG93OiBbXSwgaGlkZTogW119O1xuXG5cdFx0Ly8gc29ydCBzaG93ICYgaGlkZSB0YXJnZXQgaWRzXG5cdFx0JCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKVxuXHRcdFx0LmZvckVhY2goaWQgPT4gdGFyZ2V0c1skJC5pc1RhcmdldFRvU2hvdyhpZCkgPyBcImhpZGVcIiA6IFwic2hvd1wiXS5wdXNoKGlkKSk7XG5cblx0XHQvLyBwZXJmb3JtIHNob3cgJiBoaWRlIHRhc2sgc2VwYXJhdGVseVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ1NFxuXHRcdHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyk7XG5cdFx0dGFyZ2V0cy5oaWRlLmxlbmd0aCAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGlkZSh0YXJnZXRzLmhpZGUsIG9wdGlvbnMpLCAwKTtcblx0fVxufSk7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7em9vbUlkZW50aXR5IGFzIGQzWm9vbUlkZW50aXR5LCB6b29tVHJhbnNmb3JtIGFzIGQzWm9vbVRyYW5zZm9ybX0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5pbXBvcnQge2NhbGxGbiwgZXh0ZW5kLCBnZXRNaW5NYXgsIGlzRGVmaW5lZCwgaXNPYmplY3QsIGlzU3RyaW5nfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZG9tYWluIGlzIHdpdGhpbiB6b29tIHJhbmdlXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoaW5SYW5nZSA9IChkb21haW4sIHJhbmdlKSA9PiB7XG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcblxuXHRyZXR1cm4gZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiAoXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXG5cdCkpO1xufTtcblxuLyoqXG4gKiBab29tIGJ5IGdpdmluZyB4IGRvbWFpbi5cbiAqIC0gKipOT1RFOioqXG4gKiAgLSBGb3IgYHdoZWVsYCB0eXBlIHpvb20sIHRoZSBtaW5pbXVtIHpvb20gcmFuZ2Ugd2lsbCBiZSBzZXQgYXMgdGhlIGdpdmVuIGRvbWFpbi4gVG8gZ2V0IHRoZSBpbml0aWFsIHN0YXRlLCBbLnVuem9vbSgpXSgjdW56b29tKSBzaG91bGQgYmUgY2FsbGVkLlxuICogIC0gVG8gYmUgdXNlZCBbem9vbS5lbmFibGVkXShPcHRpb25zLmh0bWwjLnpvb20pIG9wdGlvbiBzaG91bGQgYmUgc2V0IGFzIGB0cnV0aHlgLlxuICogQG1ldGhvZCB6b29tXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0FycmF5fSBkb21haW4gdmFsdWUgaW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbShbMTAsIDIwXSk7XG4gKlxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXG4gKiAgY2hhcnQuem9vbSgpO1xuICovXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWUpIHtcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XG5cdGxldCByZXN1bHREb21haW47XG5cblx0aWYgKCQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmlzVGltZVNlcmllcygpO1xuXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xuXHRcdFx0ZG9tYWluID0gZG9tYWluLm1hcCh4ID0+ICQkLnBhcnNlRGF0ZSh4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKCQkLmNvbmZpZy5zdWJjaGFydF9zaG93KSB7XG5cdFx0XHRjb25zdCB4U2NhbGUgPSAkJC56b29tU2NhbGUgfHwgJCQueDtcblxuXHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBbeFNjYWxlKGRvbWFpblswXSksIHhTY2FsZShkb21haW5bMV0pXSk7XG5cdFx0XHRyZXN1bHREb21haW4gPSBkb21haW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLnguZG9tYWluKGRvbWFpbik7XG5cdFx0XHQkJC56b29tU2NhbGUgPSAkJC54O1xuXHRcdFx0JCQueEF4aXMuc2NhbGUoJCQuem9vbVNjYWxlKTtcblxuXHRcdFx0cmVzdWx0RG9tYWluID0gJCQuem9vbVNjYWxlLm9yZ0RvbWFpbigpO1xuXHRcdH1cblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcdHdpdGhZOiAkJC5jb25maWcuem9vbV9yZXNjYWxlLFxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdCQkLnNldFpvb21SZXNldEJ1dHRvbigpO1xuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb20sIHJlc3VsdERvbWFpbik7XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0RG9tYWluID0gJCQuem9vbVNjYWxlID9cblx0XHRcdCQkLnpvb21TY2FsZS5kb21haW4oKSA6ICQkLngub3JnRG9tYWluKCk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0RG9tYWluO1xufTtcblxuZXh0ZW5kKHpvb20sIHtcblx0LyoqXG5cdCAqIEVuYWJsZSBhbmQgZGlzYWJsZSB6b29taW5nLlxuXHQgKiBAbWV0aG9kIHpvb23igKRlbmFibGVcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBlbmFibGVkIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXMgYXJlIFwid2hlZWxcIiBvciBcImRyYWdcIi4gSWYgZW5hYmxlZCBpcyB0cnVlLCBcIndoZWVsXCIgd2lsbCBiZSB1c2VkLiBJZiBmYWxzZSBpcyBnaXZlbiwgem9vbWluZyB3aWxsIGJlIGRpc2FibGVkLjxicj5XaGVuIHNldCB0byBmYWxzZSwgdGhlIGN1cnJlbnQgem9vbWluZyBzdGF0dXMgd2lsbCBiZSByZXNldC5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSB3aGVlbFxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUodHJ1ZSk7XG5cdCAqICAvLyBPclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJ3aGVlbFwiKTtcblx0ICpcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcImRyYWdcIik7XG5cdCAqXG5cdCAqICAvLyBEaXNhYmxlIHpvb21pbmdcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKGZhbHNlKTtcblx0ICovXG5cdGVuYWJsZTogZnVuY3Rpb24oZW5hYmxlZCA9IFwid2hlZWxcIikge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cdFx0bGV0IGVuYWJsZVR5cGUgPSBlbmFibGVkO1xuXG5cdFx0aWYgKGVuYWJsZWQpIHtcblx0XHRcdGVuYWJsZVR5cGUgPSBpc1N0cmluZyhlbmFibGVkKSAmJiAvXihkcmFnfHdoZWVsKSQvLnRlc3QoZW5hYmxlZCkgP1xuXHRcdFx0XHR7dHlwZTogZW5hYmxlZH0gOiBlbmFibGVkO1xuXHRcdH1cblxuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgPSBlbmFibGVUeXBlO1xuXG5cdFx0aWYgKCEkJC56b29tKSB7XG5cdFx0XHQkJC5pbml0Wm9vbSgpO1xuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoZmFsc2UpO1xuXHRcdH1cblxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgb3IgZ2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2UgdmFsdWVcblx0ICogQG1ldGhvZCB6b29t4oCkbWF4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXG5cdCAqIEByZXR1cm4ge051bWJlcn0gem9vbSBtYXggdmFsdWVcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIFNldCBtYXhpbXVtIHJhbmdlIHZhbHVlXG5cdCAqICBjaGFydC56b29tLm1heCgyMCk7XG5cdCAqL1xuXHRtYXg6IGZ1bmN0aW9uKG1heCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAobWF4ID09PSAwIHx8IG1heCkge1xuXHRcdFx0Y29uZmlnLnpvb21feF9tYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgWyQkLm9yZ1hEb21haW5bMV0sIG1heF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21heDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlIHZhbHVlXG5cdCAqIEBtZXRob2Qgem9vbeKApG1pblxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWluIHZhbHVlXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxuXHQgKiAgY2hhcnQuem9vbS5taW4oLTEpO1xuXHQgKi9cblx0bWluOiBmdW5jdGlvbihtaW4pIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcblx0XHRcdGNvbmZpZy56b29tX3hfbWluID0gZ2V0TWluTWF4KFwibWluXCIsIFskJC5vcmdYRG9tYWluWzBdLCBtaW5dKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9taW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB6b29tIHJhbmdlXG5cdCAqIEBtZXRob2Qgem9vbeKApHJhbmdlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtyYW5nZV1cblx0ICogQHJldHVybiB7T2JqZWN0fSB6b29tIHJhbmdlIHZhbHVlXG5cdCAqIHtcblx0ICogICBtaW46IDAsXG5cdCAqICAgbWF4OiAxMDBcblx0ICogfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgY2hhcnQuem9vbS5yYW5nZSh7XG5cdCAqICAgICAgbWluOiAxMCxcblx0ICogICAgICBtYXg6IDEwMFxuXHQgKiAgfSk7XG5cdCAqL1xuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRjb25zdCB6b29tID0gdGhpcy56b29tO1xuXG5cdFx0aWYgKGlzT2JqZWN0KHJhbmdlKSkge1xuXHRcdFx0Y29uc3Qge21pbiwgbWF4fSA9IHJhbmdlO1xuXG5cdFx0XHRpc0RlZmluZWQobWluKSAmJiB6b29tLm1pbihtaW4pO1xuXHRcdFx0aXNEZWZpbmVkKG1heCkgJiYgem9vbS5tYXgobWF4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiB6b29tLm1pbigpLFxuXHRcdFx0bWF4OiB6b29tLm1heCgpXG5cdFx0fTtcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0em9vbSxcblxuXHQvKipcblx0ICogVW56b29tIHpvb21lZCBhcmVhXG5cdCAqIEBtZXRob2QgdW56b29tXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQGV4YW1wbGVcblx0ICogIGNoYXJ0LnVuem9vbSgpO1xuXHQgKi9cblx0dW56b29tKCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoJCQuem9vbVNjYWxlKSB7XG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyA/XG5cdFx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgbnVsbCkgOlxuXHRcdFx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKGQzWm9vbUlkZW50aXR5KTtcblxuXHRcdFx0JCQudXBkYXRlWm9vbSh0cnVlKTtcblx0XHRcdCQkLnpvb20ucmVzZXRCdG4gJiYgJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG5cdFx0XHQvLyByZXNldCB0cmFuc2Zvcm1cblx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcblxuXHRcdFx0aWYgKGQzWm9vbVRyYW5zZm9ybShldmVudFJlY3RzLm5vZGUoKSkgIT09IGQzWm9vbUlkZW50aXR5KSB7XG5cdFx0XHRcdCQkLnpvb20udHJhbnNmb3JtKGV2ZW50UmVjdHMsIGQzWm9vbUlkZW50aXR5KTtcblx0XHRcdH1cblxuXHRcdFx0JCQucmVkcmF3KHtcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGVcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmQsIGlzU3RyaW5nLCBpc0FycmF5fSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogTG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XG5cdCAqICAgLSB1bmxvYWQgc2hvdWxkIGJlIHVzZWQgaWYgc29tZSBkYXRhIG5lZWRzIHRvIGJlIHVubG9hZGVkIHNpbXVsdGFuZW91c2x5LlxuXHQgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxuXHQgKiAgIC0gZG9uZSB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy5cblx0ICogICAgIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxuXHQgKiAgICB8IC0tLSB8IC0tLSB8XG5cdCAqICAgIHwgLSB1cmw8YnI+LSBqc29uPGJyPi0gcm93czxicj4tIGNvbHVtbnMgfCBUaGUgZGF0YSB3aWxsIGJlIGxvYWRlZC4gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkIHxcblx0ICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZCB8XG5cdCAqICAgIHwgbmFtZXMgfCBTYW1lIGFzIGRhdGEubmFtZXMoKSB8XG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XG5cdCAqICAgIHwgY2xhc3NlcyB8IFRoZSBjbGFzc2VzIHNwZWNpZmllZCBieSBkYXRhLmNsYXNzZXMgd2lsbCBiZSB1cGRhdGVkLiBjbGFzc2VzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XG5cdCAqICAgIHwgY2F0ZWdvcmllcyB8IFRoZSBjYXRlZ29yaWVzIHNwZWNpZmllZCBieSBheGlzLnguY2F0ZWdvcmllcyBvciBkYXRhLnggd2lsbCBiZSB1cGRhdGVkLiBjYXRlZ29yaWVzIG11c3QgYmUgQXJyYXkuIHxcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcblx0ICogICAgfCBjb2xvcnMgfCBUaGUgY29sb3JzIHNwZWNpZmllZCBieSBkYXRhLmNvbG9ycyB3aWxsIGJlIHVwZGF0ZWQuIGNvbG9ycyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxuXHQgKiAgICB8IGhlYWRlcnMgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIGRhdGEudXJsLjxicj5Ac2VlIFtkYXRh4oCkaGVhZGVyc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0aGVhZGVycykgfFxuXHQgKiAgICB8IGtleXMgfCAgQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0cyBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLjxicj4qKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuPGJyPkBzZWUgW2RhdGHigKRrZXlzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKSB8XG5cdCAqICAgIHwgbWltZVR5cGUgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIHVybC48YnI+QHNlZSBbZGF0YeKApG1pbWVUeXBlXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRtaW1lVHlwZSkgfFxuXHQgKiAgICB8IC0gdHlwZTxicj4tIHR5cGVzIHwgVGhlIHR5cGUgb2YgdGFyZ2V0cyB3aWxsIGJlIHVwZGF0ZWQuIHR5cGUgbXVzdCBiZSBTdHJpbmcgYW5kIHR5cGVzIG11c3QgYmUgT2JqZWN0LiB8XG5cdCAqICAgIHwgdW5sb2FkIHwgU3BlY2lmeSB0aGUgZGF0YSB3aWxsIGJlIHVubG9hZGVkIGJlZm9yZSBsb2FkaW5nIG5ldyBkYXRhLiBJZiB0cnVlIGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiBJZiB0YXJnZXQgaWRzIGdpdmVuIGFzIFN0cmluZyBvciBBcnJheSwgc3BlY2lmaWVkIHRhcmdldHMgd2lsbCBiZSB1bmxvYWRlZC4gSWYgYWJzZW50IG9yIGZhbHNlIGdpdmVuLCB1bmxvYWQgd2lsbCBub3Qgb2NjdXIuIHxcblx0ICogICAgfCBkb25lIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZC58XG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFGcm9tVVJMKVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBMb2FkIGRhdGExIGFuZCB1bmxvYWQgZGF0YTIgYW5kIGRhdGEzXG5cdCAqIGNoYXJ0LmxvYWQoe1xuXHQgKiAgICAgY29sdW1uczogW1xuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMTAwLCAyMDAsIDE1MCwgLi4uXSxcblx0ICogICAgICAgIC4uLlxuXHQgKiAgICBdLFxuXHQgKiAgICB1bmxvYWQ6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXG5cdCAqICAgIHVybDogXCIuLi5cIixcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7IC4uLiB9XG5cdCAqIH0pO1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBteUFQSS5qc29uXG5cdCAqIC8vIHtcblx0ICogLy8gICBcImRhdGExXCI6IFsyMjAsIDI0MCwgMjcwLCAyNTAsIDI4MF0sXG5cdCAqIC8vICAgXCJkYXRhMlwiOiBbMTgwLCAxNTAsIDMwMCwgNzAsIDEyMF1cblx0ICogLy8gfVxuXHQgKlxuXHQgKiBjaGFydC5sb2FkKHtcblx0ICogICAgIHVybDogJy4vZGF0YS9teUFQSS5qc29uJyxcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxuXHQgKiB9KTtcblx0ICovXG5cdGxvYWQoYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHQvLyB1cGRhdGUgeHMgaWYgc3BlY2lmaWVkXG5cdFx0YXJncy54cyAmJiAkJC5hZGRYcyhhcmdzLnhzKTtcblxuXHRcdC8vIHVwZGF0ZSBuYW1lcyBpZiBleGlzdHNcblx0XHRcIm5hbWVzXCIgaW4gYXJncyAmJiB0aGlzLmRhdGEubmFtZXMoYXJncy5uYW1lcyk7XG5cblx0XHQvLyB1cGRhdGUgY2xhc3NlcyBpZiBleGlzdHNcblx0XHRcImNsYXNzZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY2xhc3NlcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XG5cdFx0fSk7XG5cblx0XHQvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcblx0XHRpZiAoXCJjYXRlZ29yaWVzXCIgaW4gYXJncyAmJiAkJC5pc0NhdGVnb3JpemVkKCkpIHtcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGFyZ3MuY2F0ZWdvcmllcztcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgYXhlcyBpZiBleGlzdHNcblx0XHRcImF4ZXNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuYXhlcykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XG5cdFx0fSk7XG5cblx0XHQvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xuXHRcdFwiY29sb3JzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNvbG9ycykuZm9yRWFjaChpZCA9PiB7XG5cdFx0XHRjb25maWcuZGF0YV9jb2xvcnNbaWRdID0gYXJncy5jb2xvcnNbaWRdO1xuXHRcdH0pO1xuXG5cdFx0Ly8gdW5sb2FkIGlmIG5lZWRlZFxuXHRcdGlmIChcInVubG9hZFwiIGluIGFyZ3MgJiYgYXJncy51bmxvYWQgIT09IGZhbHNlKSB7XG5cdFx0XHQvLyBUT0RPOiBkbyBub3QgdW5sb2FkIGlmIHRhcmdldCB3aWxsIGxvYWQgKGluY2x1ZGVkIGluIHVybC9yb3dzL2NvbHVtbnMpXG5cdFx0XHQkJC51bmxvYWQoJCQubWFwVG9UYXJnZXRJZHMoYXJncy51bmxvYWQgPT09IHRydWUgPyBudWxsIDogYXJncy51bmxvYWQpLCAoKSA9PlxuXHRcdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncylcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVubG9hZCBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XG5cdCAqIElmIHlvdSBjYWxsIGxvYWQgQVBJIHNvb24gYWZ0ZXIvYmVmb3JlIHVubG9hZCwgdW5sb2FkIHBhcmFtIG9mIGxvYWQgc2hvdWxkIGJlIHVzZWQuIE90aGVyd2lzZSBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxuXHQgKiBgZG9uZWAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nLlxuXHQgKiBAbWV0aG9kIHVubG9hZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG5cdCAqICB8IGtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XG5cdCAqICB8IC0tLSB8IC0tLSB8IC0tLSB8XG5cdCAqICB8IGlkcyB8IFN0cmluZyAmdmVydDsgQXJyYXkgfCBUYXJnZXQgaWQgZGF0YSB0byBiZSB1bmxvYWRlZC4gSWYgbm90IGdpdmVuLCBhbGwgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiB8XG5cdCAqICB8IGRvbmUgfCBGdWN0aW9uIHwgQ2FsbGJhY2sgYWZ0ZXIgZGF0YSBpcyB1bmxvYWRlZC4gfFxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gVW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xuXHQgKiAgY2hhcnQudW5sb2FkKHtcblx0ICogICAgaWRzOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHtcblx0ICogICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSB1bmxvYWRlZFxuXHQgKiAgICB9XG5cdCAqICB9KTtcblx0ICovXG5cdHVubG9hZChhcmdzVmFsdWUpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0bGV0IGFyZ3MgPSBhcmdzVmFsdWUgfHwge307XG5cblx0XHRpZiAoaXNBcnJheShhcmdzKSkge1xuXHRcdFx0YXJncyA9IHtpZHM6IGFyZ3N9O1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJncykpIHtcblx0XHRcdGFyZ3MgPSB7aWRzOiBbYXJnc119O1xuXHRcdH1cblxuXHRcdGNvbnN0IGlkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MuaWRzKTtcblxuXHRcdCQkLnVubG9hZChpZHMsICgpID0+IHtcblx0XHRcdCQkLnJlZHJhdyh7XG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxuXHRcdFx0fSk7XG5cblx0XHRcdCQkLnJlbW92ZUNhY2hlKGlkcyk7XG5cdFx0XHRhcmdzLmRvbmUgJiYgYXJncy5kb25lKCk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7ZWFzZUxpbmVhciBhcyBkM0Vhc2VMaW5lYXJ9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IHtpc0RlZmluZWQsIGlzVmFsdWUsIGRpZmZEb21haW4sIGV4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEZsb3cgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cblx0ICogQnkgdGhpcyBBUEksIHlvdSBjYW4gYXBwZW5kIG5ldyBkYXRhIHBvaW50cyB0byB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgZmxvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IGpzb24gfCBPYmplY3QgfCBEYXRhIGFzIEpTT04gZm9ybWF0IChAc2VlIFtkYXRh4oCkanNvbl0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcblx0ICogICAgfCByb3dzIHwgQXJyYXkgfCBEYXRhIGluIGFycmF5IGFzIHJvdyBmb3JtYXQgKEBzZWUgW2RhdGHigKRyb3dzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxuXHQgKiAgICB8IGNvbHVtbnMgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgY29sdW1uIGZvcm1hdCAoQHNlZSBbZGF0YeKApGNvbHVtbnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbHVtbnMpKSB8XG5cdCAqICAgIHwgdG8gfCBTdHJpbmcgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSB0byB0aGF0IHBvaW50LiBJZiBub3QgZ2l2ZW4sIHRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgZ2l2ZW4gZGF0YSBwb2ludHMgfFxuXHQgKiAgICB8IGxlbmd0aCB8IE51bWJlciB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgdGhpcyBhcmd1bWVudCB8XG5cdCAqICAgIHwgZHVyYXRpb24gfCBOdW1iZXIgfCBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBzcGVjaWZpZWQgdmFsdWUuIElmIG5vdCBnaXZlbiwgdHJhbnNpdGlvbi5kdXJhdGlvbiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB8XG5cdCAqICAgIHwgZG9uZSB8IEZ1bmN0aW9uIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIGZsb3cgZW5kcyB8XG5cdCAqXG5cdCAqIC0gKipOT1RFOioqXG5cdCAqICAgLSBJZiBqc29uLCByb3dzIGFuZCBjb2x1bW5zIGdpdmVuLCB0aGUgZGF0YSB3aWxsIGJlIGxvYWRlZC5cblx0ICogICAtIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSBhcHBlbmRlZC5cblx0ICogICAtIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkLiBPbmUgb2YgdGhlc2UgaXMgcmVxdWlyZWQgd2hlbiBjYWxsaW5nLlxuXHQgKiAgIC0gSWYganNvbiBzcGVjaWZpZWQsIGtleXMgaXMgcmVxdWlyZWQgYXMgd2VsbCBhcyBkYXRhLmpzb24uXG5cdCAqIFx0IC0gSWYgdGFiIGlzbid0IHZpc2libGUoYnkgZXZhbHVhdGluZyBgZG9jdW1lbnQuaGlkZGVuYCksIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnkgd29yay5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gMiBkYXRhIHBvaW50cyB3aWxsIGJlIGFwcHJlbmRlZCB0byB0aGUgdGFpbCBhbmQgcG9wcGVkIGZyb20gdGhlIGhlYWQuXG5cdCAqIC8vIEFmdGVyIHRoYXQsIDQgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHBlbmRlZCBhbmQgbm8gZGF0YSBwb2ludHMgd2lsbCBiZSBwb3Bwb2VkLlxuXHQgKiBjaGFydC5mbG93KHtcblx0ICogIGNvbHVtbnM6IFtcblx0ICogICAgW1wieFwiLCBcIjIwMTgtMDEtMTFcIiwgXCIyMDE4LTAxLTIxXCJdLFxuXHQgKiAgICBbXCJkYXRhMVwiLCA1MDAsIDIwMF0sXG5cdCAqICAgIFtcImRhdGEyXCIsIDEwMCwgMzAwXSxcblx0ICogICAgW1wiZGF0YTNcIiwgMjAwLCAxMjBdXG5cdCAqICBdLFxuXHQgKiAgdG86IFwiMjAxMy0wMS0xMVwiLFxuXHQgKiAgZG9uZTogZnVuY3Rpb24gKCkge1xuXHQgKiAgICBjaGFydC5mbG93KHtcblx0ICogICAgICBjb2x1bW5zOiBbXG5cdCAqICAgICAgICBbXCJ4XCIsIFwiMjAxOC0wMi0xMVwiLCBcIjIwMTgtMDItMTJcIiwgXCIyMDE4LTAyLTEzXCIsIFwiMjAxOC0wMi0xNFwiXSxcblx0ICogICAgICAgIFtcImRhdGExXCIsIDIwMCwgMzAwLCAxMDAsIDI1MF0sXG5cdCAqICAgICAgICBbXCJkYXRhMlwiLCAxMDAsIDkwLCA0MCwgMTIwXSxcblx0ICogICAgICAgIFtcImRhdGEzXCIsIDEwMCwgMTAwLCAzMDAsIDUwMF1cblx0ICogICAgICBdLFxuXHQgKiAgICAgIGxlbmd0aDogMixcbiAgICAgKiAgICAgIGR1cmF0aW9uOiAxNTAwXG5cdCAqICAgIH0pO1xuXHQgKiAgfVxuXHQgKiB9KTtcblx0ICovXG5cdGZsb3coYXJncykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgZGF0YTtcblx0XHRsZXQgZG9tYWluO1xuXHRcdGxldCBsZW5ndGggPSAwO1xuXHRcdGxldCB0YWlsID0gMDtcblx0XHRsZXQgZGlmZjtcblx0XHRsZXQgdG87XG5cblx0XHRpZiAoYXJncy5qc29uIHx8IGFyZ3Mucm93cyB8fCBhcmdzLmNvbHVtbnMpIHtcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0RGF0YShhcmdzKTtcblx0XHR9XG5cblx0XHRpZiAoIWRhdGEgfHwgISQkLmlzVGFiVmlzaWJsZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm90Zm91bmRJZHMgPSBbXTtcblx0XHRjb25zdCBvcmdEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgdHJ1ZSk7XG5cblx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHQuaWQgPT09IHRhcmdldHNbaV0uaWQpIHtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAodC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0pIHtcblx0XHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGVuZ3RoID0gdGFyZ2V0c1tpXS52YWx1ZXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0uaW5kZXggPSB0YWlsICsgajtcblxuXHRcdFx0XHRcdFx0aWYgKCEkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzW2ldLnZhbHVlc1tqXS54ID0gdGFpbCArIGo7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xuXHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCFmb3VuZCAmJiBub3Rmb3VuZElkcy5wdXNoKHQuaWQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5vdGZvdW5kSWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xuXHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR0LnZhbHVlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aWQ6IHQuaWQsXG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0YWlsICsgaixcblx0XHRcdFx0XHRcdFx0eDogJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5nZXRPdGhlclRhcmdldFgodGFpbCArIGopIDogdGFpbCArIGosXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEdlbmVyYXRlIG51bGwgdmFsdWVzIGZvciBuZXcgdGFyZ2V0XG5cdFx0aWYgKCQkLmRhdGEudGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcblx0XHRcdFx0Y29uc3QgbWlzc2luZyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzWzBdLmluZGV4OyBpIDwgdGFpbDsgaSsrKSB7XG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKHtcblx0XHRcdFx0XHRcdGlkOiB0LmlkLFxuXHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0XHR2LmluZGV4ICs9IHRhaWw7XG5cblx0XHRcdFx0XHRpZiAoISQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0XHR2LnggKz0gdGFpbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXG5cblx0XHQvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXRcInMgb25seSBvbmVcblx0XHQvLyBjb25zdCBkYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcblx0XHRjb25zdCBiYXNlVGFyZ2V0ID0gJCQuZGF0YS50YXJnZXRzWzBdO1xuXHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VUYXJnZXQudmFsdWVzWzBdO1xuXG5cdFx0Ly8gVXBkYXRlIGxlbmd0aCB0byBmbG93IGlmIG5lZWRlZFxuXHRcdGlmIChpc0RlZmluZWQoYXJncy50bykpIHtcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHR0byA9ICQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKGFyZ3MudG8pIDogYXJncy50bztcblxuXHRcdFx0YmFzZVRhcmdldC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcblx0XHRcdFx0di54IDwgdG8gJiYgbGVuZ3RoKys7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLmxlbmd0aCkpIHtcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIElmIG9ubHkgb25lIGRhdGEsIHVwZGF0ZSB0aGUgZG9tYWluIHRvIGZsb3cgZnJvbSBsZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHtcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuXHRcdFx0XHRkaWZmID0gYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoID4gMSA/XG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcblx0XHRcdFx0XHRiYXNlVmFsdWUueCAtICQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKVswXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpZmYgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XG5cdFx0fSBlbHNlIGlmIChvcmdEYXRhQ291bnQgPT09IDEgJiYgJCQuaXNUaW1lU2VyaWVzKCkpIHtcblx0XHRcdGRpZmYgPSAoYmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54KSAvIDI7XG5cdFx0XHRkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcblx0XHR9XG5cblx0XHRkb21haW4gJiYgJCQudXBkYXRlWERvbWFpbihudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgZG9tYWluKTtcblxuXHRcdC8vIFNldCB0YXJnZXRzXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcblx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0Zmxvdzoge1xuXHRcdFx0XHRpbmRleDogYmFzZVZhbHVlLmluZGV4LFxuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcblx0XHRcdFx0ZHVyYXRpb246IGlzVmFsdWUoYXJncy5kdXJhdGlvbikgPyBhcmdzLmR1cmF0aW9uIDogJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24sXG5cdFx0XHRcdGRvbmU6IGFyZ3MuZG9uZSxcblx0XHRcdFx0b3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnQsXG5cdFx0XHR9LFxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZSxcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxuXHRcdFx0d2l0aFRyaW1YRG9tYWluOiBmYWxzZSxcblx0XHRcdHdpdGhVcGRhdGVYQXhpczogdHJ1ZVxuXHRcdH0pO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBmbG93XG5cdCAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKi9cblx0Z2VuZXJhdGVGbG93KGFyZ3MpIHtcblx0XHRjb25zdCAkJCA9IHRoaXM7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IGFyZ3MudGFyZ2V0cztcblx0XHRcdGNvbnN0IGZsb3cgPSBhcmdzLmZsb3c7XG5cblx0XHRcdGNvbnN0IHtiYXI6IGRyYXdCYXIsIGxpbmU6IGRyYXdMaW5lLCBhcmVhOiBkcmF3QXJlYX0gPSBhcmdzLnNoYXBlLnR5cGU7XG5cdFx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gYXJncy5zaGFwZS5wb3M7XG5cdFx0XHRjb25zdCB4diA9IGFyZ3MueHY7XG5cdFx0XHRjb25zdCBkdXJhdGlvbiA9IGFyZ3MuZHVyYXRpb247XG5cblx0XHRcdGxldCB0cmFuc2xhdGVYO1xuXHRcdFx0bGV0IHNjYWxlWCA9IDE7XG5cdFx0XHRjb25zdCBmbG93SW5kZXggPSBmbG93LmluZGV4O1xuXHRcdFx0Y29uc3QgZmxvd0xlbmd0aCA9IGZsb3cubGVuZ3RoO1xuXHRcdFx0bGV0IGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCBmbG93SW5kZXgpO1xuXHRcdFx0bGV0IGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgZmxvd0luZGV4ICsgZmxvd0xlbmd0aCk7XG5cdFx0XHRjb25zdCBvcmdEb21haW4gPSAkJC54LmRvbWFpbigpO1xuXHRcdFx0Y29uc3QgZHVyYXRpb25Gb3JGbG93ID0gZmxvdy5kdXJhdGlvbiB8fCBkdXJhdGlvbjtcblx0XHRcdGNvbnN0IGRvbmUgPSBmbG93LmRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdGNvbnN0IHdhaXQgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcblxuXHRcdFx0Y29uc3QgeGdyaWQgPSAkJC54Z3JpZCB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCB4Z3JpZExpbmVzID0gJCQueGdyaWRMaW5lcyB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluUmVnaW9uID0gJCQubWFpblJlZ2lvbiB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluVGV4dCA9ICQkLm1haW5UZXh0IHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5CYXIgPSAkJC5tYWluQmFyIHx8IGQzU2VsZWN0QWxsKFtdKTtcblx0XHRcdGNvbnN0IG1haW5MaW5lID0gJCQubWFpbkxpbmUgfHwgZDNTZWxlY3RBbGwoW10pO1xuXHRcdFx0Y29uc3QgbWFpbkFyZWEgPSAkJC5tYWluQXJlYSB8fCBkM1NlbGVjdEFsbChbXSk7XG5cdFx0XHRjb25zdCBtYWluQ2lyY2xlID0gJCQubWFpbkNpcmNsZSB8fCBkM1NlbGVjdEFsbChbXSk7XG5cblx0XHRcdC8vIHNldCBmbGFnXG5cdFx0XHQkJC5mbG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGhlYWQgZGF0YSBhZnRlciByZW5kZXJlZFxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XG5cdFx0XHRcdGQudmFsdWVzLnNwbGljZSgwLCBmbG93TGVuZ3RoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyB1cGRhdGUgeCBkb21haW4gdG8gZ2VuZXJhdGUgYXhpcyBlbGVtZW50cyBmb3IgZmxvd1xuXHRcdFx0Y29uc3QgZG9tYWluID0gJCQudXBkYXRlWERvbWFpbih0YXJnZXRzLCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxuXHRcdFx0aWYgKCQkLnVwZGF0ZVhHcmlkKSB7ICQkLnVwZGF0ZVhHcmlkKHRydWUpOyB9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRyYW5zZm9ybSB0byBmbG93XG5cdFx0XHRpZiAoIWZsb3cub3JnRGF0YUNvdW50KSB7IC8vIGlmIGVtcHR5XG5cdFx0XHRcdGlmICgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0XHRmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgMCk7XG5cdFx0XHRcdFx0XHRmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVYID0gJCQueChmbG93U3RhcnQueCkgLSAkJC54KGZsb3dFbmQueCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmbG93Lm9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xuXHRcdFx0XHR0cmFuc2xhdGVYID0gJCQueChvcmdEb21haW5bMF0pIC0gJCQueChkb21haW5bMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9ICgkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAoJCQueChmbG93U3RhcnQueCkgLSAkJC54KGZsb3dFbmQueCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNjYWxlWCA9IChkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbikpO1xuXHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LDApIHNjYWxlKCR7c2NhbGVYfSwxKWA7XG5cblx0XHRcdCQkLmhpZGVYR3JpZEZvY3VzKCk7XG5cblx0XHRcdGNvbnN0IGd0ID0gZDNUcmFuc2l0aW9uKCkuZWFzZShkM0Vhc2VMaW5lYXIpXG5cdFx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckZsb3cpO1xuXG5cdFx0XHR3YWl0LmFkZChbXG5cdFx0XHRcdCQkLmF4ZXMueFxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5jYWxsKGcgPT4gJCQueEF4aXMuc2V0VHJhbnNpdGlvbihndCkuY3JlYXRlKGcpKSxcblxuXHRcdFx0XHRtYWluQmFyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHRtYWluTGluZVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXG5cblx0XHRcdFx0bWFpbkFyZWFcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdG1haW5UZXh0XG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHRtYWluUmVnaW9uXG5cdFx0XHRcdFx0LmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxuXG5cdFx0XHRcdHhncmlkXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblxuXHRcdFx0XHR4Z3JpZExpbmVzXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcblx0XHRcdF0pO1xuXG5cdFx0XHRndC5jYWxsKHdhaXQsICgpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gW107XG5cdFx0XHRcdGNvbnN0IHRleHRzID0gW107XG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBbXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgZmxvd2VkIGVsZW1lbnRzXG5cdFx0XHRcdGlmIChmbG93TGVuZ3RoKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZmxvd0luZGV4ICsgaTtcblxuXHRcdFx0XHRcdFx0c2hhcGVzLnB1c2goYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApO1xuXHRcdFx0XHRcdFx0dGV4dHMucHVzaChgLiR7Q0xBU1MudGV4dH0tJHtpbmRleH1gKTtcblx0XHRcdFx0XHRcdGV2ZW50UmVjdHMucHVzaChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxuXHRcdFx0XHRcdFx0LnNlbGVjdEFsbChzaGFwZXMpXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHQkJC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy50ZXh0c31gKVxuXHRcdFx0XHRcdFx0LnNlbGVjdEFsbCh0ZXh0cylcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YClcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoZXZlbnRSZWN0cylcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdCQkLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLnhncmlkfWApXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkcmF3IGFnYWluIGZvciByZW1vdmluZyBmbG93ZWQgZWxlbWVudHMgYW5kIHJldmVydGluZyBhdHRyXG5cdFx0XHRcdHhncmlkLnNpemUoKSAmJiB4Z3JpZFxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoJCQueGdyaWRBdHRyKTtcblxuXHRcdFx0XHR4Z3JpZExpbmVzXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cblx0XHRcdFx0eGdyaWRMaW5lcy5zZWxlY3QoXCJsaW5lXCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gMCA6IHh2KVxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogeHYpO1xuXG5cdFx0XHRcdHhncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiAwKVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB4dik7XG5cblx0XHRcdFx0bWFpbkJhclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpO1xuXG5cdFx0XHRcdG1haW5MaW5lXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpO1xuXG5cdFx0XHRcdG1haW5BcmVhXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpO1xuXG5cdFx0XHRcdG1haW5DaXJjbGVcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcblxuXHRcdFx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XG5cdFx0XHRcdFx0bWFpbkNpcmNsZVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHhGdW5jID0gZCA9PiBjeChkKSAtIGNvbmZpZy5wb2ludF9yO1xuXHRcdFx0XHRcdGNvbnN0IHlGdW5jID0gZCA9PiBjeShkKSAtIGNvbmZpZy5wb2ludF9yO1xuXG5cdFx0XHRcdFx0bWFpbkNpcmNsZVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhGdW5jKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGdW5jKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCBjeCkgLy8gd2hlbiBwYXR0ZXJuIGlzIHVzZWQsIGl0IHBvc3NpYmx5IGNvbnRhaW4gJ2NpcmNsZScgYWxzby5cblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFpblRleHRcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yVGV4dClcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQpXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcblxuXHRcdFx0XHRtYWluUmVnaW9uXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XG5cblx0XHRcdFx0bWFpblJlZ2lvbi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcblx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKTtcblxuXHRcdFx0XHRjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAkJC5yZWRyYXdFdmVudFJlY3QoKTtcblxuXHRcdFx0XHQvLyBjYWxsYmFjayBmb3IgZW5kIG9mIGZsb3dcblx0XHRcdFx0ZG9uZSgpO1xuXG5cdFx0XHRcdCQkLmZsb3dpbmcgPSBmYWxzZTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IHNlbGVjdGVkIGRhdGEgcG9pbnRzLjxicj48YnI+XG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGdldCBzZWxlY3RlZCBkYXRhIHBvaW50cyBpbmZvcm1hdGlvbi4gVG8gdXNlIHRoaXMgQVBJLCBkYXRhLnNlbGVjdGlvbi5lbmFibGVkIG5lZWRzIHRvIGJlIHNldCB0cnVlLlxuXHQgKiBAbWV0aG9kIHNlbGVjdGVkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRJZF0gWW91IGNhbiBmaWx0ZXIgdGhlIHJlc3VsdCBieSBnaXZpbmcgdGFyZ2V0IGlkIHRoYXQgeW91IHdhbnQgdG8gZ2V0LiBJZiBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZGF0YVBvaW50IEFycmF5IG9mIHRoZSBkYXRhIHBvaW50cy48YnI+ZXguKSBgW3t4OiAxLCB2YWx1ZTogMjAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogMSwgbmFtZTogXCJkYXRhMVwifSwgLi4uXWBcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiAgY2hhcnQuc2VsZWN0ZWQoKTtcblx0ICogIC8vIC0tPiBleC4pIFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLiBdXG5cdCAqXG5cdCAqICAvLyBhbGwgc2VsZWN0ZWQgZGF0YSBwb2ludHMgb2YgZGF0YTEgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogIGNoYXJ0LnNlbGVjdGVkKFwiZGF0YTFcIik7XG5cdCAqL1xuXHRzZWxlY3RlZCh0YXJnZXRJZCkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBkYXRhUG9pbnQgPSBbXTtcblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZCl9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZCA9PiBkYXRhUG9pbnQucHVzaChkKSk7XG5cblx0XHRyZXR1cm4gZGF0YVBvaW50O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcblx0ICogQG1ldGhvZCBzZWxlY3Rcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gZ2V0IHNlbGVjdGVkLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXNldE90aGVyXSBVbnNlbGVjdCBhbHJlYWR5IHNlbGVjdGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xuXHQgKiAgY2hhcnQuc2VsZWN0KCk7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTJcIik7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xuXHQgKiAgY2hhcnQuc2VsZWN0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuXHQgKlxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFsyXSwgdHJ1ZSk7XG5cdCAqXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFswLCAzLCA1XSk7XG5cdCAqL1xuXHRzZWxlY3QoaWRzLCBpbmRpY2VzLCByZXNldE90aGVyKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkJC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XG5cdFx0XHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKTtcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xuXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MubGluZSkgfHwgc2hhcGUuY2xhc3NlZChDTEFTUy5hcmVhKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXgpIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSAmJiAhaXNTZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0dG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKHJlc2V0T3RoZXIpICYmIHJlc2V0T3RoZXIgJiYgaXNTZWxlY3RlZCkge1xuXHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSB1bi1zZWxlY3RlZC5cblx0ICogQG1ldGhvZCB1bnNlbGVjdFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbaWRzXSBpZCB2YWx1ZSB0byBiZSB1bnNlbGVjdGVkLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGRhdGEgcG9pbnRzXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xuXHQgKlxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGZyb20gJ2RhdGExJ1xuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogIC8vIHVuc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XG5cdCAqL1xuXHR1bnNlbGVjdChpZHMsIGluZGljZXMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQkLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xuXHRcdFx0XHRjb25zdCBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMDtcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG5cblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzVGFyZ2V0SWQgJiYgaXNUYXJnZXRJbmRleCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpICYmIGlzU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBjaGFydC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNGb3JSZWRyYXdcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVG8odGFyZ2V0SWRzLCB0eXBlLCBvcHRpb25zRm9yUmVkcmF3KSB7XG5cdGNvbnN0ICQkID0gdGhpcztcblx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNGb3JSZWRyYXcgfHwge3dpdGhUcmFuc2l0aW9uRm9yQXhpczogISQkLmhhc0FyY1R5cGUoKX07XG5cblx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGZhbHNlO1xuXHQkJC50cmFuc2l0aW5nID0gZmFsc2U7XG5cblx0JCQuc2V0VGFyZ2V0VHlwZSh0YXJnZXRJZHMsIHR5cGUpO1xuXHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7IC8vIHRoaXMgaXMgbmVlZGVkIHdoZW4gdHJhbnNmb3JtaW5nIHRvIGFyY1xuXHQkJC51cGRhdGVBbmRSZWRyYXcob3B0aW9ucyk7XG59XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgdHlwZSBvZiB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgdHJhbnNmb3JtXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgU3BlY2lmeSB0aGUgdHlwZSB0byBiZSB0cmFuc2Zvcm1lZC4gVGhlIHR5cGVzIGxpc3RlZCBpbiBkYXRhLnR5cGUgY2FuIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgU3BlY2lmeSB0YXJnZXRzIHRvIGJlIHRyYW5zZm9ybWVkLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YXJnZXRzIHdpbGwgYmUgdGhlIGNhbmRpZGF0ZS5cblx0ICogQGV4YW1wbGVcblx0ICogIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgYmFyIGNoYXJ0LlxuXHQgKiAgY2hhcnQudHJhbnNmb3JtKFwiYmFyXCIpO1xuXHQgKlxuXHQgKiAgLy8gb25seSBkYXRhMSB3aWxsIGJlIGJhciBjaGFydC5cblx0ICogIGNoYXJ0LnRyYW5zZm9ybShcImJhclwiLCBcImRhdGExXCIpO1xuXHQgKlxuXHQgKiAgLy8gb25seSBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBiYXIgY2hhcnQuXG5cdCAqICBjaGFydC50cmFuc2Zvcm0oXCJiYXJcIiwgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqL1xuXHR0cmFuc2Zvcm0odHlwZSwgdGFyZ2V0SWRzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBbXCJwaWVcIiwgXCJkb251dFwiXVxuXHRcdFx0LmluZGV4T2YodHlwZSkgPj0gMCA/IHt3aXRoVHJhbnNmb3JtOiB0cnVlfSA6IG51bGw7XG5cblx0XHR0cmFuc2Zvcm1Uby5iaW5kKCQkKSh0YXJnZXRJZHMsIHR5cGUsIG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVW5kZWZpbmVkLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBVcGRhdGUgZ3JvdXBzIGZvciB0aGUgdGFyZ2V0cy5cblx0ICogQG1ldGhvZCBncm91cHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgVGhpcyBhcmd1bWVudCBuZWVkcyB0byBiZSBhbiBBcnJheSB0aGF0IGluY2x1ZGVzIG9uZSBvciBtb3JlIEFycmF5IHRoYXQgaW5jbHVkZXMgdGFyZ2V0IGlkcyB0byBiZSBncm91cGVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gR3JvdXBlZCBkYXRhIG5hbWVzIGFycmF5XG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cblx0ICogIGNoYXJ0Lmdyb3VwcyhbXG5cdCAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXG5cdCAqICBdKTtcblx0ICovXG5cdGdyb3Vwcyhncm91cHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGdyb3VwcykpIHtcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xuXHRcdCQkLnJlZHJhdygpO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3Vwcztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFVwZGF0ZSB4IGdyaWQgbGluZXMuXG4gKiBAbWV0aG9kIHhncmlkc1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQ2hhcnRcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueC5saW5lcy5cbiAqIEBleGFtcGxlXG4gKiAgLy8gU2hvdyAyIHggZ3JpZCBsaW5lc1xuICogY2hhcnQueGdyaWRzKFtcbiAqICAgIHt2YWx1ZTogMSwgdGV4dDogXCJMYWJlbCAxXCJ9LFxuICogICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAqIF0pO1xuICovXG5jb25zdCB4Z3JpZHMgPSBmdW5jdGlvbihncmlkcykge1xuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRpZiAoIWdyaWRzKSB7XG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XG5cdH1cblxuXHRjb25maWcuZ3JpZF94X2xpbmVzID0gZ3JpZHM7XG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XG59O1xuXG5leHRlbmQoeGdyaWRzLCB7XG5cdC8qKlxuXHQgKiBBZGQgeCBncmlkIGxpbmVzLjxicj5cblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxuXHQgKiBAbWV0aG9kIHhncmlkc+KApGFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeCBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogKTtcblx0ICpcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcblx0ICogY2hhcnQueGdyaWRzLmFkZChbXG5cdCAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXG5cdCAqICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogXSk7XG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzKSB7XG5cdFx0cmV0dXJuIHRoaXMueGdyaWRzKFxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF94X2xpbmVzXG5cdFx0XHRcdC5jb25jYXQoZ3JpZHMgfHwgW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHggZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxuXHQgKiBAbWV0aG9kIHhncmlkc+KApHJlbW92ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB4IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8geCBncmlkIGxpbmUgb24geCA9IDIgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe3ZhbHVlOiAyfSk7XG5cdCAqXG5cdCAqIC8vIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe1xuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKCk7XG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcykgeyAvLyBUT0RPOiBtdWx0aXBsZVxuXHRcdHRoaXMuaW50ZXJuYWwucmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG5cbi8qKlxuICogVXBkYXRlIHkgZ3JpZCBsaW5lcy5cbiAqIEBtZXRob2QgeWdyaWRzXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWSBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzLlxuICogQGV4YW1wbGVcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXG4gKiBjaGFydC55Z3JpZHMoW1xuICogICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSxcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cbiAqIF0pO1xuICovXG5jb25zdCB5Z3JpZHMgPSBmdW5jdGlvbihncmlkcykge1xuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRpZiAoIWdyaWRzKSB7XG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XG5cdH1cblxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7XG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XG59O1xuXG5leHRlbmQoeWdyaWRzLCB7XG5cdC8qKlxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeSBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeWdyaWRzLlxuXHQgKiBAbWV0aG9kIHlncmlkc+KApGFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeSBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxuXHQgKiApO1xuXHQgKlxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFtcblx0ICogICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCAyXCJ9LFxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cblx0ICogXSk7XG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzKSB7XG5cdFx0cmV0dXJuIHRoaXMueWdyaWRzKFxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXG5cdFx0XHRcdC5jb25jYXQoZ3JpZHMgfHwgW10pXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxuXHQgKiBAbWV0aG9kIHlncmlkc+KApHJlbW92ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8geSBncmlkIGxpbmUgb24geSA9IDIwMCB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xuXHQgKlxuXHQgKiAvLyB5IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxuXHQgKiB9KTtcblx0ICpcblx0ICogLy8gYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSgpO1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXMpIHsgLy8gVE9ETzogbXVsdGlwbGVcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZhbHNlKTtcblx0fVxufSk7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0eGdyaWRzLFxuXHR5Z3JpZHNcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcbmltcG9ydCB7Z2V0T3B0aW9uLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFVwZGF0ZSByZWdpb25zLlxuICogQG1ldGhvZCByZWdpb25zXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBDaGFydFxuICogQHBhcmFtIHtBcnJheX0gcmVnaW9ucyBSZWdpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucy5cbiAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zXG4gKiBAZXhhbXBsZVxuICogLy8gU2hvdyAyIHJlZ2lvbnNcbiAqIGNoYXJ0LnJlZ2lvbnMoW1xuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcbiAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuICogXSk7XG4gKi9cbmNvbnN0IHJlZ2lvbnMgPSBmdW5jdGlvbihyZWdpb25zKSB7XG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXG5cdGlmICghcmVnaW9ucykge1xuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcblx0fVxuXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcblxuXHRyZXR1cm4gcmVnaW9ucztcbn07XG5cbmV4dGVuZChyZWdpb25zLCB7XG5cdC8qKlxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyByZWdpb24gaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSByZWdpb25zLlxuXHQgKiBAbWV0aG9kIHJlZ2lvbnPigKRhZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBBZGQgYSBuZXcgcmVnaW9uXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxuXHQgKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9XG5cdCAqICk7XG5cdCAqXG5cdCAqIC8vIEFkZCBuZXcgcmVnaW9uc1xuXHQgKiBjaGFydC5yZWdpb25zLmFkZChbXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXG5cdCAqICAgIHtheGlzOiBcInlcIiwgZW5kOiA1MCwgY2xhc3M6IFwicmVnaW9uWVwifVxuXHQgKl0pO1xuXHQgKi9cblx0YWRkOiBmdW5jdGlvbihyZWdpb25zKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghcmVnaW9ucykge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xuXHRcdH1cblxuXHRcdGNvbmZpZy5yZWdpb25zID0gY29uZmlnLnJlZ2lvbnMuY29uY2F0KHJlZ2lvbnMpO1xuXHRcdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG5cblx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSByZWdpb25zLjxicj48YnI+XG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgcmVnaW9ucy5cblx0ICogQG1ldGhvZCByZWdpb25z4oCkcmVtb3ZlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlZ2lvbnMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XG5cdCAqICAgY2xhc3NlczogW1xuXHQgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcblx0ICogICBdXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKCk7XG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRjb25zdCBvcHRpb25zID0gb3B0aW9uc1ZhbHVlIHx8IHt9O1xuXHRcdGNvbnN0IGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xuXHRcdGNvbnN0IGNsYXNzZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJjbGFzc2VzXCIsIFtDTEFTUy5yZWdpb25dKTtcblx0XHRsZXQgcmVnaW9ucyA9ICQkLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXG5cdFx0XHQuc2VsZWN0QWxsKGNsYXNzZXMubWFwKGMgPT4gYC4ke2N9YCkpO1xuXG5cdFx0KGR1cmF0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pIDogcmVnaW9ucylcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRyZWdpb25zID0gY29uZmlnLnJlZ2lvbnM7XG5cblx0XHRpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG5cdFx0XHRyZWdpb25zID0gcmVnaW9ucy5maWx0ZXIocmVnaW9uID0+IHtcblx0XHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCFyZWdpb24uY2xhc3MpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlZ2lvbi5jbGFzcy5zcGxpdChcIiBcIikuZm9yRWFjaChjID0+IHtcblx0XHRcdFx0XHRpZiAoY2xhc3Nlcy5pbmRleE9mKGMpID49IDApIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiAhZm91bmQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25maWcucmVnaW9ucyA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZWdpb25zO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge3JlZ2lvbnN9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZCwgaXNVbmRlZmluZWQsIGlzQXJyYXl9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIEdldCBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXG4gKiBAbWV0aG9kIGRhdGFcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIENoYXJ0XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIHJldHVybnMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZGF0YS4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IG9ubHkgZGF0YTEgZGF0YVxuICogY2hhcnQuZGF0YShcImRhdGExXCIpO1xuICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXG4gKlxuICogLy8gR2V0IGRhdGExIGFuZCBkYXRhMiBkYXRhXG4gKiBjaGFydC5kYXRhKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xuICpcbiAqIC8vIEdldCBhbGwgZGF0YVxuICogY2hhcnQuZGF0YSgpO1xuICovXG5jb25zdCBkYXRhID0gZnVuY3Rpb24odGFyZ2V0SWRzKSB7XG5cdGNvbnN0IHRhcmdldHMgPSB0aGlzLmludGVybmFsLmRhdGEudGFyZ2V0cztcblxuXHRyZXR1cm4gaXNVbmRlZmluZWQodGFyZ2V0SWRzKSA/XG5cdFx0dGFyZ2V0cyA6IHRhcmdldHMuZmlsdGVyKHQgPT4gdGFyZ2V0SWRzLmluZGV4T2YodC5pZCkgPj0gMCk7XG59O1xuXG5leHRlbmQoZGF0YSwge1xuXHQvKipcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKRzaG93blxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBBUEkgZmlsdGVycyB0aGUgZGF0YSB3aXRoIHNwZWNpZmllZCB0YXJnZXQgaWRzLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgYWxsIHNob3duIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgc2hvd24gZGF0YSBieSBmaWx0ZXJpbmcgdG8gaW5jbHVkZSBvbmx5IGRhdGExIGRhdGFcblx0ICogY2hhcnQuZGF0YS5zaG93bihcImRhdGExXCIpO1xuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cblx0ICpcblx0ICogLy8gR2V0IHNob3duIGRhdGEgYnkgZmlsdGVyaW5nIHRvIGluY2x1ZGUgZGF0YTEgYW5kIGRhdGEyIGRhdGFcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcblx0ICpcblx0ICogLy8gR2V0IGFsbCBzaG93biBkYXRhXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcblx0ICovXG5cdHNob3duOiBmdW5jdGlvbih0YXJnZXRJZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5maWx0ZXJUYXJnZXRzVG9TaG93KHRoaXMuZGF0YSh0YXJnZXRJZHMpKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKR2YWx1ZXNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIFRoaXMgQVBJIHJldHVybnMgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgbnVsbCB3aWxsIGJlIHJldHJ1bmVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIHZhbHVlc1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgZGF0YTEgdmFsdWVzXG5cdCAqIGNoYXJ0LmRhdGEudmFsdWVzKFwiZGF0YTFcIik7XG5cdCAqIC8vIC0tPiBbMTAsIDIwLCAzMCwgNDBdXG5cdCAqL1xuXHR2YWx1ZXM6IGZ1bmN0aW9uKHRhcmdldElkLCBmbGF0ID0gdHJ1ZSkge1xuXHRcdGxldCB2YWx1ZXMgPSBudWxsO1xuXG5cdFx0aWYgKHRhcmdldElkKSB7XG5cdFx0XHRjb25zdCB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkKTtcblxuXHRcdFx0aWYgKHRhcmdldHMgJiYgaXNBcnJheSh0YXJnZXRzKSkge1xuXHRcdFx0XHR2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YVZhbHVlID0gdi52YWx1ZXMubWFwKGQgPT4gZC52YWx1ZSk7XG5cblx0XHRcdFx0XHRmbGF0ID8gKHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoZGF0YVZhbHVlKSkgOiB2YWx1ZXMucHVzaChkYXRhVmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBuYW1lcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIGRhdGHigKRuYW1lc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbmFtZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgbmFtZXNcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xuXHQgKiAvLyAtLT4ge2RhdGExOiBcInRlc3QxXCIsIGRhdGEyOiBcInRlc3QyXCJ9XG5cdCAqXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xuXHQgKiBjaGFydC5kYXRhLm5hbWVzKHtcblx0ICogIGRhdGExOiBcIk5ldyBOYW1lIDFcIixcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxuXHQgKn0pO1xuXHQgKi9cblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzKSB7XG5cdFx0dGhpcy5pbnRlcm5hbC5jbGVhckxlZ2VuZEl0ZW1UZXh0Qm94Q2FjaGUoKTtcblxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwibmFtZXNcIiwgbmFtZXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBjb2xvcnMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkY29sb3JzXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY29sb3JzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGNvbG9ycyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgW2RhdGEuY29sb3JzXSguL09wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbG9ycykuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBkYXRhIGNvbG9yIHZhbHVlIGFjY29yZGluZyBpdHMga2V5IHZhbHVlLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgY3VycmVudCBjb2xvcnNcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoKTtcblx0ICogLy8gLS0+IHtkYXRhMTogXCIjMDBjNzNjXCIsIGRhdGEyOiBcIiNmYTcxNzFcIn1cblx0ICpcblx0ICogLy8gVXBkYXRlIGNvbG9yc1xuXHQgKiBjaGFydC5kYXRhLmNvbG9ycyh7XG5cdCAqICBkYXRhMTogXCIjRkZGRkZGXCIsXG5cdCAqICBkYXRhMjogXCIjMDAwMDAwXCJcblx0ICogfSk7XG5cdCAqL1xuXHRjb2xvcnM6IGZ1bmN0aW9uKGNvbG9ycykge1xuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIGNvbG9ycyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCBkYXRh4oCkYXhlc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBheGVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBheGVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGF4ZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBheGVzIHZhbHVlIGZvciBkYXRhLCBpZiBzcGVjaWZpZWQgYXhlcyB2YWx1ZS5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuXHQgKiBjaGFydC5kYXRhLmF4ZXMoKTtcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XG5cdCAqXG5cdCAqIC8vIFVwZGF0ZSBheGVzXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcyh7XG5cdCAqICBkYXRhMTogXCJ5XCIsXG5cdCAqICBkYXRhMjogXCJ5MlwiXG5cdCAqIH0pO1xuXHQgKi9cblx0YXhlczogZnVuY3Rpb24oYXhlcykge1xuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBheGVzKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBtaW5pbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XG5cdCAqIEBtZXRob2QgZGF0YeKApG1pblxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcblx0ICogQGV4YW1wbGVcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xuXHQgKiBjaGFydC5kYXRhLm1pbigpO1xuXHQgKiAvLyAtLT4gW3t4OiAwLCB2YWx1ZTogMzAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAwfSwgLi4uXVxuXHQgKi9cblx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWluO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1heGltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcblx0ICogQG1ldGhvZCBkYXRh4oCkbWF4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXG5cdCAqIGNoYXJ0LmRhdGEubWF4KCk7XG5cdCAqIC8vIC0tPiBbe3g6IDMsIHZhbHVlOiA0MDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAzfSwgLi4uXVxuXHQgKi9cblx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRNaW5NYXhEYXRhKCkubWF4O1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge2RhdGF9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIFNldCBzcGVjaWZpZWQgY2F0ZWdvcnkgbmFtZSBvbiBjYXRlZ29yeSBheGlzLlxuXHQgKiBAbWV0aG9kIGNhdGVnb3J5XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGkgaW5kZXggb2YgY2F0ZWdvcnkgdG8gYmUgY2hhbmdlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgdmFsdWUgdG8gYmUgY2hhbmdlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5jYXRlZ29yeSgyLCBcIkNhdGVnb3J5IDNcIik7XG5cdCAqL1xuXHRjYXRlZ29yeShpLCBjYXRlZ29yeSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA9IGNhdGVnb3J5O1xuXHRcdFx0JCQucmVkcmF3KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXG5cdCAqIEBtZXRob2QgY2F0ZWdvcmllc1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNhdGVnb3JpZXMgVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmNhdGVnb3JpZXMoW1xuXHQgKiAgICAgIFwiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXG5cdCAqIF0pO1xuXHQgKi9cblx0Y2F0ZWdvcmllcyhjYXRlZ29yaWVzKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXHRcdGNvbnN0IGNvbmZpZyA9ICQkLmNvbmZpZztcblxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcblx0XHR9XG5cblx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuXHRcdCQkLnJlZHJhdygpO1xuXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNvbG9yXG5cdCAqIEBtZXRob2QgY29sb3Jcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjaGFydC5jb2xvcihcImRhdGExXCIpO1xuXHQgKi9cblx0Y29sb3IoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5jb2xvcihpZCk7IC8vIG1vcmUgcGF0dGVybnNcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cblx0ICogQG1ldGhvZCB4XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtBcnJheX0geCBJZiB4IGlzIGdpdmVuLCB4IHZhbHVlcyBvZiBldmVyeSB0YXJnZXQgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cblx0ICogQHJldHVybiB7T2JqZWN0fSB4c1xuXHQgKiBAZXhhbXBsZVxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcblx0ICogIGNoYXJ0LngoKTtcblx0ICpcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcblx0ICogIGNoYXJ0LngoWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXSk7XG5cdCAqL1xuXHR4KHgpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcblxuXHRcdGlmIChpc0FycmF5KHgpKSB7XG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xuXHRcdFx0XHQkJC5hcGkuY2F0ZWdvcmllcyh4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldFgoJCQuZGF0YS50YXJnZXRzLCB4KTtcblxuXHRcdFx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpc0NhdGVnb3JpemVkID8gJCQuYXBpLmNhdGVnb3JpZXMoKSA6ICQkLmRhdGEueHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXG5cdCAqIEBtZXRob2QgeHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge0FycmF5fSB4cyBJZiB4cyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIHggdmFsdWVzIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcblx0ICogQGV4YW1wbGVcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXG5cdCAqICBjaGFydC54cygpO1xuXHQgKlxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xuXHQgKiAgY2hhcnQueHMoe1xuXHQgKiAgICBkYXRhMTogWzEwLCAyMCwgMzAsIDQwLCAuLi5dLFxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxuXHQgKiAgfSk7XG5cdCAqL1xuXHR4cyh4cykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdGlmIChpc09iamVjdCh4cykpIHtcblx0XHRcdCQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xuXG5cdFx0XHQkJC5yZWRyYXcoe1xuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiAkJC5kYXRhLnhzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG4vKipcbiAqIFNldCB0aGUgbWluL21heCB2YWx1ZVxuICogQHBhcmFtIHtDaGFydH0gJCRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNldE1pbk1heCA9ICgkJCwgdHlwZSwgdmFsdWUpID0+IHtcblx0Y29uc3QgY29uZmlnID0gJCQuY29uZmlnO1xuXHRjb25zdCBheGlzWCA9IGBheGlzX3hfJHt0eXBlfWA7XG5cdGNvbnN0IGF4aXNZID0gYGF4aXNfeV8ke3R5cGV9YDtcblx0Y29uc3QgYXhpc1kyID0gYGF4aXNfeTJfJHt0eXBlfWA7XG5cblx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcblx0XHRpZiAoaXNPYmplY3RUeXBlKHZhbHVlKSkge1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS54KSAmJiAoY29uZmlnW2F4aXNYXSA9IHZhbHVlLngpO1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55KSAmJiAoY29uZmlnW2F4aXNZXSA9IHZhbHVlLnkpO1xuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55MikgJiYgKGNvbmZpZ1theGlzWTJdID0gdmFsdWUueTIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25maWdbYXhpc1ldID0gdmFsdWU7XG5cdFx0XHRjb25maWdbYXhpc1kyXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdCQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pbi9tYXggdmFsdWVcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7e3gsIHksIHkyfX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldE1pbk1heCA9ICgkJCwgdHlwZSkgPT4ge1xuXHRjb25zdCBjb25maWcgPSAkJC5jb25maWc7XG5cblx0cmV0dXJuIHtcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXG5cdFx0eTogY29uZmlnW2BheGlzX3lfJHt0eXBlfWBdLFxuXHRcdHkyOiBjb25maWdbYGF4aXNfeTJfJHt0eXBlfWBdXG5cdH07XG59O1xuXG4vKipcbiAqIERlZmluZSBheGlzXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGF4aXMgPSBleHRlbmQoKCkgPT4ge30sIHtcblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxuXHQgKiBAbWV0aG9kIGF4aXPigKRsYWJlbHNcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxzIHNwZWNpZmllZCBheGlzJyBsYWJlbCB0byBiZSB1cGRhdGVkLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcblx0ICogY2hhcnQuYXhpcy5sYWJlbHMoe1xuXHQgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxuXHQgKiAgIHk6IFwiTmV3IFkgQXhpcyBMYWJlbFwiXG5cdCAqIH0pO1xuXHQgKi9cblx0bGFiZWxzOiBmdW5jdGlvbihsYWJlbHMpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0T2JqZWN0LmtleXMobGFiZWxzKS5mb3JFYWNoKGF4aXNJZCA9PiB7XG5cdFx0XHRcdCQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdCQkLmF4aXMudXBkYXRlTGFiZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiB2YWx1ZS5cblx0ICogQG1ldGhvZCBheGlz4oCkbWluXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG1pbiBJZiBtaW4gaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtaW4gdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWluIHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIG1pblxuXHQgKiBjaGFydC5heGlzLm1pbih7XG5cdCAqICAgeDogLTEwLFxuXHQgKiAgIHk6IDEwMDAsXG5cdCAqICAgeTI6IDEwMFxuXHQgKiB9KTtcblx0ICovXG5cdG1pbjogZnVuY3Rpb24obWluKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1pblwiLCBtaW4pIDpcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtaW5cIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxuXHQgKiBAbWV0aG9kIGF4aXPigKRtYXhcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxuXHQgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtYXggdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtYXggdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcblx0ICogY2hhcnQuYXhpcy5tYXgoe1xuXHQgKiAgICB4OiAxMDAsXG5cdCAqICAgIHk6IDEwMDAsXG5cdCAqICAgIHkyOiAxMDAwMFxuXHQgKiB9KTtcblx0ICovXG5cdG1heDogZnVuY3Rpb24obWF4KSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1heFwiLCBtYXgpIDpcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtYXhcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXG5cdCAqIEBtZXRob2QgYXhpc+KApHJhbmdlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXG5cdCAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xuXHQgKiAgIG1pbjoge1xuXHQgKiAgICAgeDogLTEwLFxuXHQgKiAgICAgeTogLTEwMDAsXG5cdCAqICAgICB5MjogLTEwMDAwXG5cdCAqICAgfSxcblx0ICogICBtYXg6IHtcblx0ICogICAgIHg6IDEwMCxcblx0ICogICAgIHk6IDEwMDAsXG5cdCAqICAgICB5MjogMTAwMDBcblx0ICogICB9LFxuXHQgKiB9KTtcblx0ICovXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1heCkgJiYgYXhpcy5tYXgocmFuZ2UubWF4KTtcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5taW4pICYmIGF4aXMubWluKHJhbmdlLm1pbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1heDogYXhpcy5tYXgoKSxcblx0XHRcdFx0bWluOiBheGlzLm1pbigpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7YXhpc30pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IENoYXJ0IGZyb20gXCIuLi9pbnRlcm5hbHMvQ2hhcnRcIjtcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBEZWZpbmUgbGVnZW5kXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGxlZ2VuZCA9IGV4dGVuZCgoKSA9PiB7fSwge1xuXHQvKipcblx0ICogU2hvdyBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxuXHQgKiBAbWV0aG9kIGxlZ2VuZOKApHNob3dcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXG5cdCAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMS5cblx0ICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cblx0ICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIFNob3cgYWxsIGxlZ2VuZC5cblx0ICogY2hhcnQubGVnZW5kLnNob3coKTtcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdCQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cblx0ICogQG1ldGhvZCBsZWdlbmTigKRoaWRlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXG5cdCAqIC0gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMS5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoXCJkYXRhMVwiKTtcblx0ICpcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XG5cdCAqXG5cdCAqIC8vIEhpZGUgYWxsIGxlZ2VuZC5cblx0ICogY2hhcnQubGVnZW5kLmhpZGUoKTtcblx0ICovXG5cdGhpZGU6IGZ1bmN0aW9uKHRhcmdldElkcykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblxuXHRcdCQkLmhpZGVMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XG5cdH1cbn0pO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7bGVnZW5kfSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL2ludGVybmFscy9DaGFydFwiO1xuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi9pbnRlcm5hbHMvYnJvd3NlclwiO1xuaW1wb3J0IHtub3RFbXB0eSwgaXNEZWZpbmVkLCBleHRlbmR9IGZyb20gXCIuLi9pbnRlcm5hbHMvdXRpbFwiO1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0LlxuXHQgKiBAbWV0aG9kIHJlc2l6ZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaXplIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIFJlc2l6ZSB0byA2NDB4NDgwXG5cdCAqIGNoYXJ0LnJlc2l6ZSh7XG5cdCAqICAgIHdpZHRoOiA2NDAsXG5cdCAqICAgIGhlaWdodDogNDgwXG5cdCAqIH0pO1xuXHQgKi9cblx0cmVzaXplKHNpemUpIHtcblx0XHRjb25zdCBjb25maWcgPSB0aGlzLmludGVybmFsLmNvbmZpZztcblxuXHRcdGNvbmZpZy5zaXplX3dpZHRoID0gc2l6ZSA/IHNpemUud2lkdGggOiBudWxsO1xuXHRcdGNvbmZpZy5zaXplX2hlaWdodCA9IHNpemUgPyBzaXplLmhlaWdodCA6IG51bGw7XG5cblx0XHR0aGlzLmZsdXNoKGZhbHNlLCB0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogRm9yY2UgdG8gcmVkcmF3LlxuXHQgKiBAbWV0aG9kIGZsdXNoXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc29mdF0gRm9yIHNvZnQgcmVkcmF3LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0Zyb21SZXNpemVdIEZvciBzb2Z0IHJlZHJhdy5cblx0ICogQGV4YW1wbGVcblx0ICogY2hhcnQuZmx1c2goKTtcblx0ICpcblx0ICogLy8gZm9yIHNvZnQgcmVkcmF3XG5cdCAqIGNoYXJ0LmZsdXNoKHRydWUpO1xuXHQgKi9cblx0Zmx1c2goc29mdCwgaXNGcm9tUmVzaXplKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZVxuXHRcdGlmIChpc0Zyb21SZXNpemUpIHtcblx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyByZS11cGRhdGUgY29uZmlnIGluZm9cblx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcblx0XHR9XG5cblx0XHQkJC56b29tU2NhbGUgPSBudWxsO1xuXG5cdFx0c29mdCA/ICQkLnJlZHJhdyh7XG5cdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcblx0XHR9KSA6ICQkLnVwZGF0ZUFuZFJlZHJhdyh7XG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgY2hhcnQgb2JqZWN0IGFuZCByZW1vdmUgZWxlbWVudCBhbmQgZXZlbnRzIGNvbXBsZXRlbHkuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNoYXJ0LmRlc3Ryb3koKTtcblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xuXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xuXHRcdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkd2lsbERlc3Ryb3lcIik7XG5cdFx0XHQkJC5jaGFydHMuc3BsaWNlKCQkLmNoYXJ0cy5pbmRleE9mKHRoaXMpLCAxKTtcblxuXHRcdFx0Ly8gY2xlYXIgdGltZXJzICYmIHBlbmRpbmcgdHJhbnNpdGlvblxuXHRcdFx0JCQuc3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCk7XG5cdFx0XHRpc0RlZmluZWQoJCQucmVzaXplVGltZW91dCkgJiYgd2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcblxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xuXHRcdFx0JCQuc2VsZWN0Q2hhcnQuY2xhc3NlZChcImJiXCIsIGZhbHNlKS5odG1sKFwiXCIpO1xuXG5cdFx0XHQvLyByZWxlYXNpbmcgcmVmZXJlbmNlc1xuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0XHRrZXkgPT09IFwiaW50ZXJuYWxcIiAmJiBPYmplY3Qua2V5cygkJCkuZm9yRWFjaChrID0+IHtcblx0XHRcdFx0XHQkJFtrXSA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXNba2V5XSA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IG9yIHNldCBzaW5nbGUgY29uZmlnIG9wdGlvbiB2YWx1ZS5cblx0ICogQG1ldGhvZCBjb25maWdcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWRyYXddIFNldCB0byByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvbiBjaGFuZ2VzLlxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEdldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XG5cdCAqXG5cdCAqIC8vIFNldHRlclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcblx0ICpcblx0ICogLy8gU2V0dGVyICYgcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb25cblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XG5cdCAqL1xuXHRjb25maWcobmFtZSwgdmFsdWUsIHJlZHJhdykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcblx0XHRsZXQgcmVzO1xuXG5cdFx0aWYgKGtleSBpbiAkJC5jb25maWcpIHtcblx0XHRcdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRcdCQkLmNvbmZpZ1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xuXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMgPSAkJC5jb25maWdba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgZXh0ZW5kfSBmcm9tIFwiLi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuLyoqXG4gKiBEZWZpbmUgdG9vbHRpcFxuICogQGlnbm9yZVxuICovXG5jb25zdCB0b29sdGlwID0gZXh0ZW5kKCgpID0+IHt9LCB7XG5cdC8qKlxuXHQgKiBTaG93IHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XG5cdCAqXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcblx0ICogICAgfCB4IHwgTnVtYmVyICZ2ZXJ0OyBEYXRlIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IHggQXhpcyBpbmRleCB8XG5cdCAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkIHggQXhpcyBlbGVtZW50Ljxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge051bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge051bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7U3RyaW5nfTogQXhpcyBpZC4gJ3knIG9yICd5MicoZGVmYXVsdCAneScpPGJyPi0gdmFsdWUge051bWJlcn06IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciB0b29sdGlwLiB8XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBzaG93IHRoZSAybmQgeCBBeGlzIGNvb3JkaW5hdGUgdG9vbHRpcFxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcblx0ICogICAgaW5kZXg6IDFcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gc2hvdyB0b29sdGlwIGZvciB0aGUgM3JkIHggQXhpcyBpbiB4OjUwIGFuZCB5OjEwMCBjb29yZGluYXRlIHJlbGF0aXZlIHRoZSB4IEF4aXMgZWxlbWVudC5cblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHt4OiAyfSxcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xuXHQgKiAgICB4OiBuZXcgRGF0ZShcIjIwMTgtMDEtMDIgMDA6MDBcIilcblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzIHVzZWRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIHg6IDMsICAvLyB4IEF4aXMgdmFsdWVcblx0ICogICAgICAgIGlkOiBcInlcIiwgIC8vIGF4aXMgaWQuICd5JyBvciAneTInIChkZWZhdWx0ICd5Jylcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcblx0ICogICAgfVxuXHQgKiAgfSk7XG5cdCAqXG5cdCAqICAvLyB3aGVuIGRhdGEueHMgaXNuJ3QgdXNlZCwgYnV0IHRvb2x0aXAuZ3JvdXBlZD1mYWxzZSBpcyBzZXRcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XG5cdCAqICAgIGRhdGE6IHtcblx0ICogICAgICAgIGluZGV4OiAzLCAgLy8gb3IgJ3gnIGtleSB2YWx1ZVxuXHQgKiAgICAgICAgaWQ6IFwieVwiLCAgLy8gYXhpcyBpZC4gJ3knIG9yICd5MicgKGRlZmF1bHQgJ3knKVxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxuXHQgKiAgICB9XG5cdCAqICB9KTtcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MgPSB7fSkge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRsZXQgaW5kZXg7XG5cdFx0bGV0IG1vdXNlO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIG1vdXNlIHBvc2l0aW9uIG9uIHRoZSBjaGFydFxuXHRcdGlmIChhcmdzLm1vdXNlKSB7XG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcblx0XHRpZiAoYXJncy5kYXRhKSB7XG5cdFx0XHRjb25zdCB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcblxuXHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcblx0XHRcdFx0Ly8gaWYgbXVsdGlwbGUgeHMsIHRhcmdldCBwb2ludCB3aWxsIGJlIGRldGVybWluZWQgYnkgbW91c2Vcblx0XHRcdFx0bW91c2UgPSBbJCQueChhcmdzLmRhdGEueCksIHldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkJC5jb25maWcudG9vbHRpcF9ncm91cGVkKSB7XG5cdFx0XHRcdFx0bW91c2UgPSBbMCwgeV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCA9IGlzVmFsdWUoYXJncy5kYXRhLmluZGV4KSA/IGFyZ3MuZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGFyZ3MuZGF0YS54KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XG5cdFx0XHRpbmRleCA9ICQkLmdldEluZGV4QnlYKGFyZ3MueCk7XG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5pbmRleCkpIHtcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcblx0XHR9XG5cblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XG5cdFx0KCQkLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiID9cblx0XHRcdFtcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiXSA6IFtcInRvdWNoc3RhcnRcIl1cblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcblx0XHRcdCQkLmRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBpbmRleCwgbW91c2UpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRvb2x0aXBcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkaGlkZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENoYXJ0XG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cblx0XHQkJC5oaWRlVG9vbHRpcCh0cnVlKTtcblx0XHQkJC5oaWRlWEdyaWRGb2N1cygpO1xuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xuXHR9XG59KTtcblxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge3Rvb2x0aXB9KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBDaGFydCBmcm9tIFwiLi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vaW50ZXJuYWxzL2Jyb3dzZXJcIjtcbmltcG9ydCB7ZXh0ZW5kLCBpc0Z1bmN0aW9uLCB0b0FycmF5LCBnZXRDc3NSdWxlc30gZnJvbSBcIi4uL2ludGVybmFscy91dGlsXCI7XG5cbi8qKlxuICogRW5jb2RlIHRvIGJhc2U2NFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXG4gKi9cbmNvbnN0IGI2NEVuY29kZVVuaWNvZGUgPSBzdHIgPT4gYnRvYShcblx0ZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcblx0XHQucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGAweCR7cH1gKSlcbik7XG5cbi8qKlxuICogQ29udmVydCBzdmcgbm9kZSB0byBkYXRhIHVybFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9kZVRvU3ZnRGF0YVVybCA9IChub2RlLCBzaXplKSA9PiB7XG5cdGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuXHRjb25zdCBjc3NUZXh0ID0gZ2V0Q3NzUnVsZXModG9BcnJheShkb2N1bWVudC5zdHlsZVNoZWV0cykpXG5cdFx0LmZpbHRlcihyID0+IHIuY3NzVGV4dClcblx0XHQubWFwKHIgPT4gci5jc3NUZXh0KTtcblxuXHRjbG9uZS5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBkM05hbWVzcGFjZXMueGh0bWwpO1xuXG5cdGNvbnN0IG5vZGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKGNsb25lKTtcblxuXHQvLyBlc2NhcGUgY3NzIGZvciBYTUxcblx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dC5qb2luKFwiXFxuXCIpKSk7XG5cblx0Y29uc3Qgc3R5bGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN0eWxlKTtcblxuXHQvLyBmb3JlaWduT2JqZWN0IG5vdCBzdXBwb3J0ZWQgaW4gSUUxMSBhbmQgYmVsb3dcblx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XG5cdGNvbnN0IGRhdGFTdHIgPSBgPHN2ZyB4bWxucz1cIiR7ZDNOYW1lc3BhY2VzLnN2Z31cIiB3aWR0aD1cIiR7c2l6ZS53aWR0aH1cIiBoZWlnaHQ9XCIke3NpemUuaGVpZ2h0fVwiPlxuXHRcdFx0PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPlxuXHRcdFx0XHQke3N0eWxlWG1sfVxuXHRcdFx0XHQke25vZGVYbWwucmVwbGFjZSgvKHVybFxcKClbXiNdKy9nLCBcIiQxXCIpfVxuXHRcdFx0PC9mb3JlaWduT2JqZWN0Pjwvc3ZnPmBcblx0XHQucmVwbGFjZShcIi9cXG4vZ1wiLCBcIiUwQVwiKTtcblxuXHRyZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtiNjRFbmNvZGVVbmljb2RlKGRhdGFTdHIpfWA7XG59O1xuXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBFeHBvcnQgY2hhcnQgYXMgYW4gaW1hZ2UuXG5cdCAqIC0gKipOT1RFOioqXG5cdCAqICAgLSBJRTExIGFuZCBiZWxvdyBub3Qgd29yayBwcm9wZXJseSBkdWUgdG8gdGhlIGxhY2sgb2YgdGhlIGZlYXR1cmUoPGEgaHJlZj1cImh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFwiPmZvcmVpZ25PYmplY3Q8L2E+KSBzdXBwb3J0XG5cdCAqICAgLSBUaGUgYmFzaWMgQ1NTIGZpbGUoZXguIGJpbGxib2FyZC5jc3MpIHNob3VsZCBiZSBhdCBzYW1lIGRvbWFpbiBhcyBBUEkgY2FsbCBjb250ZXh0IHRvIGdldCBjb3JyZWN0IHN0eWxlZCBleHBvcnQgaW1hZ2UuXG5cdCAqIEBtZXRob2QgZXhwb3J0XG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttaW1lVHlwZT1pbWFnZS9wbmddIFRoZSBkZXNpcmVkIG91dHB1dCBpbWFnZSBmb3JtYXQuIChleC4gJ2ltYWdlL3BuZycgZm9yIHBuZywgJ2ltYWdlL2pwZWcnIGZvciBqcGVnIGZvcm1hdClcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGV4cG9ydCBpcyByZWFkeS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBkYXRhVVJJXG5cdCAqIEBleGFtcGxlXG5cdCAqICBjaGFydC5leHBvcnQoKTtcblx0ICogIC8vIC0tPiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOLi4uXCJcblx0ICpcblx0ICogIC8vIEluaXRpYWxpemUgdGhlIGRvd25sb2FkIGF1dG9tYXRpY2FsbHlcblx0ICogIGNoYXJ0LmV4cG9ydChcImltYWdlL3BuZ1wiLCBkYXRhVXJsID0+IHtcblx0ICogICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0ICpcblx0ICogICAgIGxpbmsuZG93bmxvYWQgPSBgJHtEYXRlLm5vdygpfS5wbmdgO1xuXHQgKiAgICAgbGluay5ocmVmID0gZGF0YVVybDtcblx0ICogICAgIGxpbmsuaW5uZXJIVE1MID0gXCJEb3dubG9hZCBjaGFydCBhcyBpbWFnZVwiO1xuXHQgKlxuXHQgKiAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblx0ICogIH0pO1xuXHQgKi9cblx0ZXhwb3J0KG1pbWVUeXBlLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcblx0XHRjb25zdCBzaXplID0ge3dpZHRoOiAkJC5jdXJyZW50V2lkdGgsIGhlaWdodDogJCQuY3VycmVudEhlaWdodH07XG5cdFx0Y29uc3Qgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwodGhpcy5lbGVtZW50LCBzaXplKTtcblxuXHRcdGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdGltZy5jcm9zc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuXHRcdFx0aW1nLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRcdFx0XHRjYW52YXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblxuXHRcdFx0XHRjYWxsYmFjayhjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlKSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcuc3JjID0gc3ZnRGF0YVVybDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3ZnRGF0YVVybDtcblx0fVxufSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIGJpbGxib2FyZCBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4vaW50ZXJuYWxzL0NoYXJ0XCI7XG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi9pbnRlcm5hbHMvQ2hhcnRJbnRlcm5hbFwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4vYXhpcy9BeGlzXCI7XG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZU9ian0gZnJvbSBcIi4vaW50ZXJuYWxzL3V0aWxcIjtcblxuaW1wb3J0IFwiLi9jb25maWcvY29uZmlnXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9zY2FsZVwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XG5pbXBvcnQgXCIuL2RhdGEvZGF0YVwiO1xuaW1wb3J0IFwiLi9kYXRhL2RhdGEuY29udmVydFwiO1xuaW1wb3J0IFwiLi9kYXRhL2RhdGEubG9hZFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY2F0ZWdvcnlcIjtcbmltcG9ydCBcIi4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uXCI7XG5pbXBvcnQgXCIuL2ludGVybmFscy9zaXplXCI7XG5pbXBvcnQgXCIuL3NoYXBlL3NoYXBlXCI7XG5pbXBvcnQgXCIuL3NoYXBlL2FyY1wiO1xuaW1wb3J0IFwiLi9zaGFwZS9iYXJcIjtcbmltcG9ydCBcIi4vc2hhcGUvYnViYmxlXCI7XG5pbXBvcnQgXCIuL3NoYXBlL2xpbmVcIjtcbmltcG9ydCBcIi4vc2hhcGUvcG9pbnRcIjtcbmltcG9ydCBcIi4vc2hhcGUvcmFkYXJcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3RleHRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3R5cGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2dyaWRcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3Rvb2x0aXBcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2xlZ2VuZFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvdGl0bGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NsaXBcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL3JlZ2lvblwiO1xuaW1wb3J0IFwiLi9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvc2VsZWN0aW9uXCI7XG5pbXBvcnQgXCIuL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xuaW1wb3J0IFwiLi9pbnRlcmFjdGlvbnMvem9vbVwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xuaW1wb3J0IFwiLi9pbnRlcm5hbHMvY2FjaGVcIjtcbmltcG9ydCBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZm9jdXNcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5zaG93XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuem9vbVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmxvYWRcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5mbG93XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuc2VsZWN0aW9uXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkudHJhbnNmb3JtXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZ3JvdXBcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS5ncmlkXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkucmVnaW9uXCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuZGF0YVwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmNhdGVnb3J5XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuY29sb3JcIjtcbmltcG9ydCBcIi4vYXBpL2FwaS54XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkuYXhpc1wiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmxlZ2VuZFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmNoYXJ0XCI7XG5pbXBvcnQgXCIuL2FwaS9hcGkudG9vbHRpcFwiO1xuaW1wb3J0IFwiLi9hcGkvYXBpLmV4cG9ydFwiO1xuXG5sZXQgZGVmYXVsdHMgPSB7fTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGJiXG4gKiBAdmVyc2lvbiAxLjkuNVxuICovXG5jb25zdCBiYiA9IHtcblx0LyoqXG5cdCAqIFZlcnNpb24gaW5mb3JtYXRpb25cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IHZlcnNpb24gdmVyc2lvblxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgICBiYi52ZXJzaW9uOyAgLy8gXCIxLjAuMFwiXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKi9cblx0dmVyc2lvbjogXCIxLjkuNVwiLFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBjaGFydFxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICogQHJldHVybiB7Q2hhcnR9XG5cdCAqIEBzZWUge0BsaW5rIE9wdGlvbnN9IGZvciBkaWZmZXJlbnQgZ2VuZXJhdGlvbiBvcHRpb25zXG5cdCAqIEBzZWUge0BsaW5rIENoYXJ0fSBmb3IgZGlmZmVyZW50IG1ldGhvZHMgQVBJXG5cdCAqIEBleGFtcGxlXG5cdCAqICA8IS0tIGNoYXJ0IGhvbGRlciAtLT5cblx0ICogPGRpdiBpZD1cIkxpbmVDaGFydFwiPjwvZGl2PlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIGdlbmVyYXRlIGNoYXJ0IHdpdGggb3B0aW9uc1xuXHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xuXHQgKiAgICAgIFwiYmluZHRvXCI6IFwiI0xpbmVDaGFydFwiXG5cdCAqICAgICAgXCJkYXRhXCI6IHtcblx0ICogICAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMCwgNDAwLCAxNTAsIDI1MF0sXG5cdCAqICAgICAgICAgICAgICBbXCJkYXRhMlwiLCA1MCwgMjAsIDEwLCA0MCwgMTUsIDI1XVxuXHQgKiAgICAgICAgICAgXVxuXHQgKiAgICAgIH1cblx0ICogIH0pO1xuXHQgKlxuXHQgKiAgLy8gY2FsbCBzb21lIEFQSVxuXHQgKiAgLy8gZXgpIGdldCB0aGUgZGF0YSBvZiAnZGF0YTEnXG5cdCAqICBjaGFydC5kYXRhKFwiZGF0YTFcIik7XG5cdCAqL1xuXHRnZW5lcmF0ZShjb25maWcpIHtcblx0XHRjb25zdCBvcHRpb25zID0gbWVyZ2VPYmooe30sIGRlZmF1bHRzLCBjb25maWcpO1xuXHRcdGNvbnN0IGluc3QgPSBuZXcgQ2hhcnQob3B0aW9ucyk7XG5cblx0XHRpbnN0LmludGVybmFsLmNoYXJ0cyA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0dGhpcy5pbnN0YW5jZS5wdXNoKGluc3QpO1xuXG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cblx0ICogLSAqKk5PVEU6Kipcblx0ICogICAtIFRoZSBvcHRpb25zIHZhbHVlcyBzZXR0aW5ncyBhcmUgdmFsaWQgd2l0aGluIHBhZ2UgY29udGV4dCBvbmx5LlxuXHQgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxuXHQgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICogQHJldHVybiB7T3B0aW9uc31cblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc31cblx0ICogQGV4YW1wbGVcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXG5cdCAqIGJiLmRlZmF1bHRzKHtcblx0ICogICBkYXRhOiB7XG5cdCAqICAgICB0eXBlOiBcImJhclwiXG5cdCAqICAgfVxuXHQgKiB9KTtcblx0ICpcblx0ICogYmIuZGVmYXVsdHMoKTsgIC8vIHtkYXRhOnt0eXBlOiBcImJhclwifX1cblx0ICpcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXG5cdCAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xuXHQgKi9cblx0ZGVmYXVsdHMob3B0aW9ucykge1xuXHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHRcdFx0ZGVmYXVsdHMgPSBvcHRpb25zO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZhdWx0cztcblx0fSxcblxuXHQvKipcblx0ICogQW4gYXJyYXkgY29udGFpbmluZyBpbnN0YW5jZSBjcmVhdGVkXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IGluc3RhbmNlIGluc3RhbmNlIGFycmF5XG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBnZW5lcmF0ZSBjaGFydHNcblx0ICogIHZhciBjaGFydDEgPSBiYi5nZW5lcmF0ZSguLi4pO1xuXHQgKiAgdmFyIGNoYXJ0MiA9IGJiLmdlbmVyYXRlKC4uLik7XG5cdCAqXG5cdCAqICBiYi5pbnN0YW5jZTsgIC8vIFsgY2hhcnQxLCBjaGFydDIsIC4uLiBdXG5cdCAqIEBtZW1iZXJvZiBiYlxuXHQgKi9cblx0aW5zdGFuY2U6IFtdLFxuXG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgZm9yIHBsdWdpbnNcblx0ICogQHByb3BlcnR5IHtPYmplY3R9IHBsdWdpbiBwbHVnaW4gbmFtZXNwYWNlXG5cdCAqIEBleGFtcGxlXG5cdCAqICAvLyBTdGFuZm9yZCBkaWFncmFtIHBsdWdpblxuXHQgKiAgYmIucGx1Z2luLnN0YW5mb3JkO1xuXHQgKiBAbWVtYmVyb2YgYmJcblx0ICovXG5cdHBsdWdpbjoge30sXG5cblx0LyoqXG5cdCAqIEludGVybmFsIGNoYXJ0IG9iamVjdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2hhcnQ6IHtcblx0XHRmbjogQ2hhcnQucHJvdG90eXBlLFxuXHRcdGludGVybmFsOiB7XG5cdFx0XHRmbjogQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsXG5cdFx0XHRheGlzOiB7XG5cdFx0XHRcdGZuOiBBeGlzLnByb3RvdHlwZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuZXhwb3J0IHtiYn07XG5leHBvcnQgZGVmYXVsdCBiYjtcbiJdLCJzb3VyY2VSb290IjoiIn0=